/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/yfiles/index.d.ts:
/** @const */
var yfiles = {};
/** @const */
yfiles.lang = {};
/**
 * @record
 * @struct
 */
yfiles.lang.ClassConstructor = function() {};

/* TODO: ConstructSignature: yfiles.lang */

/**
 * @template T
 * @param {...?} base
 * @return {!yfiles.lang.ClassConstructor<T>}
 */
yfiles.lang.BaseClass = function(base) {};
/**
 * @record
 * @struct
 */
yfiles.lang.Object_Interface = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Object_Interface.$class;

/**
 * Tests whether this object and the other object are equal.
 * @param {!Object} other The tested object.
 * @return {boolean} <code>true</code>, if the objects are equal; <code>false</code> otherwise.
 */
yfiles.lang.Object_Interface.prototype.equals = function(other) {};

/**
 * Tests if two objects are equal.
 * @param {!Object} a One of the objects. Can be null or of any type.
 * @param {!Object} b One of the objects. Can be null or of any type.
 * @return {boolean} <code>true</code>, if the objects are equal; <code>false</code> otherwise.
 */
yfiles.lang.Object_Interface.equals = function(a, b) {};

/**
 * Returns the type of this object.
 * @return {!yfiles.lang.Class} The type of this object.
 */
yfiles.lang.Object_Interface.prototype.getClass = function() {};

/**
 * Returns an object with a get and/or a set method that is optionally bound to this instance.
 * <p>
 * The requested <code>name</code> must be a property (with getter and/or setter).
 * </p>
 * @param {string} name The name of the property.
 * @param {boolean} bound If <code>true</code>, then the get/set methods of the returned object will be bound to this instance.
 * @return {!Object} An object with a get and/or set method that reads/writes to the specified field.
 */
yfiles.lang.Object_Interface.prototype.getOwnProperty = function(name, bound) {};

/**
 * Returns the most recently defined property descriptor in the prototype chain of the given object.
 * @param {!Object} o The object that the property belongs to
 * @param {string} name The name of the property.
 * @return {!Object} The most recently defined property descriptor in the prototype chain of the given object.
 */
yfiles.lang.Object_Interface.getPropertyDescriptor = function(o, name) {};

/**
 * Returns the hash code of this object.
 * <p>
 * If two objects are {\@link yfiles.lang.Object_Interface#equals equal}, then they must have the same hash code.
 * </p>
 * @return {number} The hash code of this object.
 */
yfiles.lang.Object_Interface.prototype.hashCode = function() {};

/**
 * Shallow clones an object.
 * <p>
 * It will also clone any value types.
 * </p>
 * @return {!Object} A cloned instance of the same type.
 */
yfiles.lang.Object_Interface.prototype.memberwiseClone = function() {};

/**
 * Tests if two objects are identical.
 * @param {!Object} a One of the objects.
 * @param {!Object} b One of the objects.
 * @return {boolean} <code>true</code>, if the objects are the identical; <code>false</code> otherwise.
 */
yfiles.lang.Object_Interface.referenceEquals = function(a, b) {};

/**
 * Displays the textual representation of the object.
 * @return {string} The textual representation of this object.
 */
yfiles.lang.Object_Interface.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
yfiles.lang.Abstract = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Abstract.$class;

/**
 * Tests whether the given object or property descriptor is a representation of an abstract value.
 * @param {!Object} o The object to test.
 * @return {boolean} <code>true</code>, if the object is abstract; <code>false</code> otherwise.
 */
yfiles.lang.Abstract.isAbstract = function(o) {};
/**
 * @record
 * @struct
 */
yfiles.lang.Class = function() {};
 /** @type {boolean} */
yfiles.lang.Class.prototype.isEnum;
 /** @type {boolean} */
yfiles.lang.Class.prototype.isPrimitive;
 /** @type {boolean} */
yfiles.lang.Class.prototype.isValueType;
 /** @type {boolean} */
yfiles.lang.Class.prototype.isClass;
 /** @type {string} */
yfiles.lang.Class.prototype.name;
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Class.$class;

/**
 * Returns the class object for the given name, or <code>null</code> if no such class exists.
 * @param {string} name The name of the requested class.
 * @return {!yfiles.lang.Class} The class object or <code>null</code>, if no such class exists.
 */
yfiles.lang.Class.forName = function(name) {};

/**
 * Returns all attributes that belong to this type.
 * @param {boolean=} inherited
 * @return {!Array<!yfiles.lang.Attribute>} An array of attributes that belong to this type.
 */
yfiles.lang.Class.prototype.getAttributes = function(inherited) {};

/**
 * Returns an array of all properties of the type.
 * Returns an array of all properties of the type.
 * @param {boolean|{inherited: boolean, staticProperties: boolean}=} inherited_or_options
 * @param {boolean=} staticProperties
 * @return {!Array<!yfiles.lang.PropertyInfo>} An array of properties.
 */
yfiles.lang.Class.prototype.getProperties = function(inherited_or_options, staticProperties) {};

/**
 * Modify an existing object <code>obj</code> that is not created with the help of the yfiles class framework to be usable with our
 * library functions.
 * <p>
 * This method modifies a given object <code>obj</code> in the following ways:
 * </p>
 * <ul>
 * <li>Methods and properties that implement member declarations of the <code>traits</code> are callable from yfiles library code.</li>
 * <li>For each interface <code>trait</code> in <code>traits</code>, <code>trait.isInstance(obj)</code> is true.</li>
 * </ul>
 * <p>
 * Note that this method does not enable extended usages, e.g. <code>obj</code> does not implement the full reflection API necessary for
 * GraphML serialization, and it is not possible to inject actual classes as opposed to interfaces.
 * </p>
 * <p>
 * To modify an object on an instance level:
 * </p>
 * <pre>
 * //Create a plain JavaScript object
 * var myHitTestable = {};
 * myHitTestable.isHit = function(p, ctx) { return false; };
 * myHitTestable.lookup = function(clazz) { return null; };
 * //Modify
 * yfiles.lang.Class.injectInterfaces(myHitTestable, [yfiles.drawing.IHitTestable, yfiles.support.ILookup]);
 * //These are equally valid:
 * //yfiles.lang.Class.injectInterfaces(myHitTestable, ["yfiles.drawing.IHitTestable", "yfiles.support.ILookup"]);
 * //yfiles.lang.Class.injectInterfaces(myHitTestable, [yfiles.drawing.IHitTestable.$class, yfiles.support.ILookup.$class]);
 * //As well as using a variable number of arguments, such as:
 * //yfiles.lang.Class.injectInterfaces(myHitTestable, yfiles.drawing.IHitTestable, yfiles.support.ILookup);
 * 
 * //This is true now:
 * yfiles.drawing.IHitTestable.isInstance(myHitTestable);
 * //And the object can be used where an interface instance is expected:
 * graphEditorInputMode.clickInputMode.validClickHitTestable = myHitTestable;
 * </pre>
 * 
 * <p>
 * It is also possible to modify an object prototype, e.g. in TypeScript: Class definition:
 * </p>
 * <pre>
 * export class MyHitTestable implements yfiles.drawing.IHitTestable {
 *    isHit(p: yfiles.geometry.PointD, ctx: yfiles.canvas.ICanvasContext): boolean {
 *        return false;
 *    }
 * }
 * </pre>
 * 
 * <p>
 * Usage:
 * </p>
 * <pre>
 * //This is false:
 * //yfiles.drawing.IHitTestable.isInstance(new MyHitTestable());
 * //Modify
 * yfiles.lang.Class.injectInterfaces(MyHitTestable.prototype, [yfiles.drawing.IHitTestable]);
 * //Now it is true
 * var myHitTestable = new MyHitTestable();
 * yfiles.drawing.IHitTestable.isInstance(myHitTestable);
 * //And the object can be used where an interface instance is expected:
 * graphEditorInputMode.clickInputMode.validClickHitTestable = myHitTestable;
 * </pre>
 * 
 * @param {!Object} obj The object to modify.
 * @param {...!Object} traits Array or variable number of {\@link }s, {\@link } objects of traits or fully qualified string names of
 * traits.
 * @return {void}
 */
yfiles.lang.Class.injectInterfaces = function(obj, traits) {};

/**
 * Tests whether an object is an instance of this type.
 * <p>
 * This is the only way to test if an object implements a {\@link yfiles.lang.Trait}.
 * </p>
 * @param {!Object} o The object that may be an instance of this type.
 * @return {boolean} <code>true</code>, if the object is an instance of this type; <code>false</code> otherwise.
 */
yfiles.lang.Class.prototype.isInstance = function(o) {};

/**
 * Creates a new instance of this type using its default constructor.
 * @return {!Object} A new instance of this type using its default constructor.
 */
yfiles.lang.Class.prototype.newInstance = function() {};
/**
 * @record
 * @struct
 */
yfiles.lang.Number = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Number.$class;

/**
 * Compares this number with another one.
 * @param {!Object} obj The other number to compare with.
 * @return {number} <code>0</code> if both numbers are equal, <code>-1</code> if this number is smaller than the other one, <code>1</code> otherwise.
 */
yfiles.lang.Number.prototype.compareTo = function(obj) {};
/**
 * @record
 * @struct
 */
yfiles.lang.String = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.String.$class;

/**
 * Compares this string with another one.
 * @param {!Object} obj The other string to compare with.
 * @return {number} <code>0</code> if both strings are equal, <code>-1</code> if this string comes before the other one in lexicographic sort order, <code>1</code> otherwise.
 */
yfiles.lang.String.prototype.compareTo = function(obj) {};
/**
 * @record
 * @struct
 */
yfiles.lang.Boolean = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Boolean.$class;

/**
 * Compares this boolean with another one.
 * @param {!Object} obj The other boolean to compare with.
 * @return {number} <code>0</code> if both booleans are equal, <code>-1</code> if this boolean is <code>false</code> and the other is <code>true</code>, <code>1</code> otherwise.
 */
yfiles.lang.Boolean.prototype.compareTo = function(obj) {};
/**
 * @record
 * @struct
 */
yfiles.lang.Struct = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Struct.$class;

/**
 * This methods creates an instance of the struct in which all of its values are set to their default values without using
 * any of its constructors.
 * @return {!Object}
 */
yfiles.lang.Struct.createDefault = function() {};

/**
 * Tests whether another object is equal to this struct.
 * <p>
 * As opposed to the implementation of
 * {\@link yfiles.lang.Object_Interface#equals}, this implementation tests the members of both objects to determine equality.
 * </p>
 * @param {!Object} other The other struct.
 * @return {boolean} <code>true</code>, if both objects are equal; <code>false</code> otherwise.
 */
yfiles.lang.Struct.prototype.equals = function(other) {};

/**
 * Calculates the hash code of this struct based on its members.
 * @return {number} The hash code.
 */
yfiles.lang.Struct.prototype.hashCode = function() {};
/**
 * @record
 * @struct
 */
yfiles.lang.Enum = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Enum.$class;

/**
 * Returns the name of an enum value.
 * @param {!yfiles.lang.Class} type The type of the enum.
 * @param {!yfiles.lang.Enum} value The value of the field.
 * @return {string} The name of the field.
 */
yfiles.lang.Enum.getName = function(type, value) {};

/**
 * Returns a list of all field names that represent an enum value.
 * @param {!yfiles.lang.Class} type The type of the enum.
 * @return {?<!Object>} A list of all field names that represent an enum value.
 */
yfiles.lang.Enum.getValueNames = function(type) {};

/**
 * Returns a list of all numeric values.
 * @param {!yfiles.lang.Class} type The type of the enum.
 * @return {?<!Object>} A list of all numeric values.
 */
yfiles.lang.Enum.getValues = function(type) {};

/**
 * Returns the value of the field with the given ID.
 * @param {!yfiles.lang.Class} type The type of the enum.
 * @param {string} id The name of the field.
 * @param {boolean} ignoreCase If <code>true</code>, then the case of the field will be ignored and the search is case-insensitive.
 * @return {!yfiles.lang.Enum} The value of the field with the given ID.
 */
yfiles.lang.Enum.parse = function(type, id, ignoreCase) {};
/**
 * @record
 * @struct
 */
yfiles.lang.delegate = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.delegate.$class;

/**
 * Combines two delegates into a single one.
 * @param {!Function} d1 One of the delegates to combine.
 * @param {!Function} d2 One of the delegates to combine.
 * @return {!Function} A delegate that combines both original delegates.
 */
yfiles.lang.delegate.combine = function(d1, d2) {};

/**
 * Creates a new delegate from the given <code>functions</code> and the execution target.
 * <p>
 * When the delegate is executed, the <code>functions</code> will be <code>applied</code> on
 * <code>target</code>, independent from the current closure. If multiple functions are specified, they will all be applied in order.
 * </p>
 * @param {!Array<!Function>} functions The functions from which the delegate should be created.
 * @param {!Object} target The target object on which the <code>functions</code> should be applied.
 * @return {!Function} A new delegate.
 */
yfiles.lang.delegate.createDelegate = function(functions, target) {};

/**
 * Apply <code>function</code> in the <b>current</b> execution context.
 * @param {!Function} function2 The function to execute.
 * @param {...!Object} args Optional function arguments.
 * @return {!Object} The result from invoking <code>function</code>.
 */
yfiles.lang.delegate.dynamicInvoke = function(function2, args) {};

/**
 * Return a list of all delegates that are combined into <code>del</code>.
 * @param {!Function} del The delegate to test.
 * @return {!Array<!Function>} A list of all delegates that are combined into <code>del</code>.
 */
yfiles.lang.delegate.getInvocationList = function(del) {};

/**
 * Removes the first occurrence of <code>d2</code> from the {\@link yfiles.lang.delegate#getInvocationList invocation list} of <code>d1</code>.
 * @param {!Function} d1 The delegate that should be modified.
 * @param {!Function} d2 The delegate that should be removed.
 * @return {!Function} The modified delegate <code>d1</code>.
 */
yfiles.lang.delegate.remove = function(d1, d2) {};

/**
 * Removes all occurrences of <code>d2</code> from the {\@link yfiles.lang.delegate#getInvocationList invocation list} of <code>d1</code>.
 * @param {!Function} d1 The delegate that should be modified.
 * @param {!Function} d2 The delegate that should be removed.
 * @return {!Function} The modified delegate <code>d1</code>.
 */
yfiles.lang.delegate.removeAll = function(d1, d2) {};
/**
 * @record
 * @struct
 */
yfiles.lang.Trait = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Trait.$class;

/**
 * Tests whether the given object is a trait.
 * <p>
 * This method is equivalent to using <code>obj.$class.isTrait</code> but safe in case the object does not have a <code>$class</code> property.
 * </p>
 * @param {!Object} o The trait candidate.
 * @return {boolean} <code>true</code>, if the object is a trait; <code>false</code> otherwise.
 */
yfiles.lang.Trait.isTrait = function(o) {};
/**
 * @record
 * @struct
 */
yfiles.lang.Attribute = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Attribute.$class;
/**
 * @record
 * @struct
 */
yfiles.lang.ClassDefinition = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.ClassDefinition.$class;
/**
 * @record
 * @struct
 */
yfiles.lang.InterfaceDefinition = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.InterfaceDefinition.$class;
/**
 * @record
 * @struct
 */
yfiles.lang.StructDefinition = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.StructDefinition.$class;
/**
 * @record
 * @struct
 */
yfiles.lang.EnumDefinition = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.EnumDefinition.$class;
/**
 * @record
 * @struct
 */
yfiles.lang.AttributeDefinition = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.lang.AttributeDefinition.$class;
/**
 * @record
 * @struct
 */
yfiles.lang.EventArgs = function() {};
 /** @type {!yfiles.lang.EventArgs} */
yfiles.lang.EventArgs.EMPTY;
 /** @type {!yfiles.lang.Class} */
yfiles.lang.EventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.lang.PropertyChangedEventArgs = function() {};
 /** @type {string} */
yfiles.lang.PropertyChangedEventArgs.prototype.propertyName;
 /** @type {!yfiles.lang.Class} */
yfiles.lang.PropertyChangedEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.lang.IPropertyObservable = function() {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when a property changes.
 * @see yfiles.lang.IPropertyObservable#removePropertyChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.lang.IPropertyObservable.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when a property changes.
 * @see yfiles.lang.IPropertyObservable#addPropertyChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.lang.IPropertyObservable.prototype.removePropertyChangedListener = function(listener) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.lang.IPropertyObservable;
/**
 * @record
 * @struct
 */
yfiles.lang.PropertyInfo = function() {};
 /** @type {boolean} */
yfiles.lang.PropertyInfo.prototype.canRead;
 /** @type {boolean} */
yfiles.lang.PropertyInfo.prototype.canWrite;
 /** @type {boolean} */
yfiles.lang.PropertyInfo.prototype.isStatic;
 /** @type {!yfiles.lang.Class} */
yfiles.lang.PropertyInfo.prototype.propertyType;
 /** @type {!yfiles.lang.Class} */
yfiles.lang.PropertyInfo.prototype.declaringType;
 /** @type {string} */
yfiles.lang.PropertyInfo.prototype.name;
 /** @type {!yfiles.lang.Class} */
yfiles.lang.PropertyInfo.$class;

/**
 * Gets the attributes associated with this property.
 * @param {boolean=} inherit
 * @return {!Array<!yfiles.lang.Attribute>} The attributes or an empty array.
 */
yfiles.lang.PropertyInfo.prototype.getAttributes = function(inherit) {};

/**
 * Gets the value of the property from the given object.
 * @param {!Object} obj The object which has the property, <code>null</code> for static properties.
 * @return {!Object} The value of the property from the given object.
 */
yfiles.lang.PropertyInfo.prototype.getValue = function(obj) {};

/**
 * Sets the value of the property on the given object.
 * @param {!Object} obj The object whose property should be written, <code>null</code> for static properties.
 * @param {!Object} value
 * @return {void}
 */
yfiles.lang.PropertyInfo.prototype.setValue = function(obj, value) {};
/**
 * @record
 * @struct
 */
yfiles.lang.IComparable = function() {};

/**
 * Compares this object to the given object of the same type.
 * @abstract
 * @param {!Object} obj The object to compare this to.
 * @return {number} 
 * <ul>
 * <li>-1: this is less than <code>obj</code></li>
 * <li>0: this is equal to <code>obj</code></li>
 * <li>1: this is greater than <code>obj</code></li>
 * </ul>
 */
yfiles.lang.IComparable.prototype.compareTo = function(obj) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.lang.IComparable;
/**
 * @record
 * @struct
 */
yfiles.lang.ICloneable = function() {};

/**
 * Create a clone of this object.
 * @abstract
 * @return {!Object} A clone of this object.
 */
yfiles.lang.ICloneable.prototype.clone = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.lang.ICloneable;
/**
 * @record
 * @struct
 */
yfiles.lang.TimeSpan = function() {};
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.lang.TimeSpan.ZERO;
 /** @type {number} */
yfiles.lang.TimeSpan.prototype.totalMilliseconds;
 /** @type {number} */
yfiles.lang.TimeSpan.prototype.totalSeconds;
 /** @type {number} */
yfiles.lang.TimeSpan.prototype.totalMinutes;
 /** @type {!yfiles.lang.Class} */
yfiles.lang.TimeSpan.$class;

/**
 *
 * @param {!Object} obj
 * @return {number}
 */
yfiles.lang.TimeSpan.prototype.compareTo = function(obj) {};

/**
 * Creates a new time span with the given length in milliseconds.
 * @param {number} milliseconds The length of the time span in milliseconds.
 * @return {!yfiles.lang.TimeSpan} A newly created time span.
 */
yfiles.lang.TimeSpan.fromMilliseconds = function(milliseconds) {};

/**
 * Creates a new time span with the given length in minutes.
 * @param {number} minutes The length of the time span in minutes.
 * @return {!yfiles.lang.TimeSpan} A newly created time span.
 */
yfiles.lang.TimeSpan.fromMinutes = function(minutes) {};

/**
 * Creates a new time span with the given length in seconds.
 * @param {number} seconds The length of the time span in seconds.
 * @return {!yfiles.lang.TimeSpan} A newly created time span.
 */
yfiles.lang.TimeSpan.fromSeconds = function(seconds) {};
/**
 * @record
 * @struct
 */
yfiles.lang.Exception = function() {};
 /** @type {string} */
yfiles.lang.Exception.prototype.message;
 /** @type {string} */
yfiles.lang.Exception.prototype.name;
 /** @type {!yfiles.lang.Exception} */
yfiles.lang.Exception.prototype.innerException;
 /** @type {boolean} */
yfiles.lang.Exception.catchErrors;
 /** @type {function(!Object): void} */
yfiles.lang.Exception.handler;
 /** @type {!yfiles.lang.Class} */
yfiles.lang.Exception.$class;

/**
 * This function is called in catch blocks in the library if {\@link yfiles.lang.Exception#catchErrors} is enabled.
 * <p>
 * If a {\@link yfiles.lang.Exception#handler} is registered, the error is passed to the error handler, otherwise if {\@link yfiles.lang.Exception#catchErrors} is set to <code>true</code> the error is logged to the
 * console using <code>console.warn</code> if available.
 * </p>
 * @param {!Object} error The error object that has been caught
 * @return {void}
 */
yfiles.lang.Exception.handleError = function(error) {};
/** @const */
yfiles.collections = {};
/**
 * @record
 * @struct
 */
yfiles.collections.Map = function() {};
 /** @type {number} */
yfiles.collections.Map.prototype.size;
 /** @type {boolean} */
yfiles.collections.Map.prototype.isReadOnly;
 /** @type {?<TKey>} */
yfiles.collections.Map.prototype.keys;
 /** @type {?<TValue>} */
yfiles.collections.Map.prototype.values;
 /** @type {!yfiles.lang.Class} */
yfiles.collections.Map.$class;

/**
 *
 * @param {!yfiles.collections.MapEntry<TKey, TValue>} item
 * @return {void}
 */
yfiles.collections.Map.prototype.add = function(item) {};

/**
 *
 * @return {void}
 */
yfiles.collections.Map.prototype.clear = function() {};

/**
 * Whether this dictionary contains the given <code>value</code>.
 * @param {TValue} value The value to search for.
 * @return {boolean} <code>true</code> if this dictionary contains the given value.
 */
yfiles.collections.Map.prototype.containsValue = function(value) {};

/**
 *
 * @param {!Array<!yfiles.collections.MapEntry<TKey, TValue>>} array
 * @param {number} arrayIndex
 * @return {void}
 */
yfiles.collections.Map.prototype.copyTo = function(array, arrayIndex) {};

/**
 *
 * @param {TKey} key
 * @return {boolean}
 */
yfiles.collections.Map.prototype.delete = function(key) {};

/**
 *
 * @param {TKey} key
 * @return {TValue}
 */
yfiles.collections.Map.prototype.get = function(key) {};

/**
 *
 * @return {?<!yfiles.collections.MapEntry<TKey, TValue>>}
 */
yfiles.collections.Map.prototype.getEnumerator = function() {};

/**
 *
 * @param {TKey} key
 * @return {boolean}
 */
yfiles.collections.Map.prototype.has = function(key) {};

/**
 *
 * @param {!yfiles.collections.MapEntry<TKey, TValue>} item
 * @return {boolean}
 */
yfiles.collections.Map.prototype.includes = function(item) {};

/**
 *
 * @param {!yfiles.collections.MapEntry<TKey, TValue>} item
 * @return {boolean}
 */
yfiles.collections.Map.prototype.remove = function(item) {};

/**
 *
 * @param {TKey} key
 * @param {TValue} value
 * @return {void}
 */
yfiles.collections.Map.prototype.set = function(key, value) {};
/**
 * @record
 * @struct
 */
yfiles.collections.ICollection = function() {};
 /** @type {number} */
yfiles.collections.ICollection.prototype.size;
 /** @type {boolean} */
yfiles.collections.ICollection.prototype.isReadOnly;

/**
 * Adds the given <code>item</code> to the collection.
 * @abstract
 * @param {T} item
 * @return {void}
 */
yfiles.collections.ICollection.prototype.add = function(item) {};

/**
 * Removes all items from this collection.
 * @abstract
 * @return {void}
 */
yfiles.collections.ICollection.prototype.clear = function() {};

/**
 * Copies all elements of this collection into the given array.
 * @abstract
 * @param {!Array<T>} array The array to copy the elements to.
 * @param {number} arrayIndex The index in the given array where the first element should be copied to.
 * @return {void}
 */
yfiles.collections.ICollection.prototype.copyTo = function(array, arrayIndex) {};

/**
 * Whether the given <code>item</code> is contained in this collection.
 * @abstract
 * @param {T} item The item to search for.
 * @return {boolean} <code>true</code> if the given <code>item</code> is contained in this collection.
 */
yfiles.collections.ICollection.prototype.includes = function(item) {};

/**
 * Removes the given <code>item</code> from this collection.
 * @abstract
 * @param {T} item The item to remove.
 * @return {boolean} Whether the item was removed from the collection.
 */
yfiles.collections.ICollection.prototype.remove = function(item) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.collections.ICollection;
/**
 * @record
 * @struct
 */
yfiles.collections.IMap = function() {};
 /** @type {?<TKey>} */
yfiles.collections.IMap.prototype.keys;
 /** @type {?<TValue>} */
yfiles.collections.IMap.prototype.values;

/**
 * Removes the key/value pair which is represented by the given <code>key</code>.
 * @abstract
 * @param {TKey} key The key of the key/value pair to remove.
 * @return {boolean} <code>true</code> if a key/value pair with the given key was removed from this collection.
 */
yfiles.collections.IMap.prototype.delete = function(key) {};

/**
 * Gets the value of the key/value pair with the given key.
 * <p>
 * Setter: if there is already a key/value pair with the given key in the dictionary its value will be overridden. If not a
 * new key/value pair will be added.
 * <br />
 * Getter: if there is no key/value pair with the given key in this dictionary <code>null</code> will be returned.
 * </p>
 * @see yfiles.collections.IMap.<TKey,TValue>#set
 * @abstract
 * @param {TKey} key
 * @return {TValue}
 */
yfiles.collections.IMap.prototype.get = function(key) {};

/**
 * Whether this dictionary's key collection contains the given key.
 * @abstract
 * @param {TKey} key The key to search for.
 * @return {boolean} <code>true</code> if this dictionary contains the given <code>key</code>.
 */
yfiles.collections.IMap.prototype.has = function(key) {};

/**
 * Sets the value of the key/value pair with the given key.
 * <p>
 * Setter: if there is already a key/value pair with the given key in the dictionary its value will be overridden. If not a
 * new key/value pair will be added.
 * <br />
 * Getter: if there is no key/value pair with the given key in this dictionary <code>null</code> will be returned.
 * </p>
 * @see yfiles.collections.IMap.<TKey,TValue>#get
 * @abstract
 * @param {TKey} key
 * @param {TValue} value
 * @return {void}
 */
yfiles.collections.IMap.prototype.set = function(key, value) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.collections.IMap;
/**
 * @record
 * @struct
 */
yfiles.collections.IEnumerable = function() {};
 /** @type {number} */
yfiles.collections.IEnumerable.prototype.size;

/**
 *
 * @param {?} enumerable
 * @return {?}
 */
yfiles.collections.IEnumerable.prototype.concat = function(enumerable) {};

/**
 * Returns the element at the given <code>index</code> in the enumerable.
 * @throws {Stubs.Exceptions.ArgumentError} If the <code>index</code> is not within the enumerable's range.
 * @param {number} index The index of the element to return.
 * @return {T} The element at the given <code>index</code>.
 */
yfiles.collections.IEnumerable.prototype.elementAt = function(index) {};

/**
 * Whether all elements of the enumerable match the given <code>predicate</code>.
 * @throws {Stubs.Exceptions.ArgumentError} <code>e</code> is <code>null</code>.
 * @throws {Stubs.Exceptions.ArgumentError} <code>predicate</code> is <code>null</code>.
 * @param {function(T, number, ?): boolean} predicate A function with the signature <code>function(element):boolean</code> which returns <code>true</code> if the element matches a condition.
 * @param {!Object=} thisArg
 * @return {boolean} Whether all elements of the enumerable match the given <code>predicate</code>.
 */
yfiles.collections.IEnumerable.prototype.every = function(predicate, thisArg) {};

/**
 * Returns an enumerable which only contains elements of the source enumerable which match a given <code>predicate</code>.
 * @param {function(T, number, ?): boolean} predicate A function with the signature <code>function(element):boolean</code> which returns <code>true</code> if the given element should be included in
 * the resulting enumerable.
 * @param {!Object=} thisArg
 * @return {?} An enumerable which contains the elements of the source enumeration which match the given <code>predicate</code>.
 */
yfiles.collections.IEnumerable.prototype.filter = function(predicate, thisArg) {};

/**
 * Returns the first element of the enumerable which matches a given filter.
 * @throws {Stubs.Exceptions.ArgumentError} If the given enumerable is <code>null</code>.
 * @throws {Stubs.Exceptions.InvalidOperationError} If the enumerable does not contain a matching element.
 * Returns the first element of the enumerable which matches a given filter.
 * @throws {Stubs.Exceptions.ArgumentError} If the given enumerable is <code>null</code>.
 * @throws {Stubs.Exceptions.InvalidOperationError} If the enumerable does not contain a matching element.
 * @param {function(T, number, ?): boolean|{predicate: function(T, number, ?): boolean, thisArg: !Object}=} predicate_or_options
 * @param {!Object=} thisArg
 * @return {T} The first matching element of the enumerable.
 */
yfiles.collections.IEnumerable.prototype.first = function(predicate_or_options, thisArg) {};

/**
 * Returns the first element of the enumerable, the first element of the enumerable which matches a given filter if
 * sepcified, or <code>null</code> if there is no such element.
 * @throws {Stubs.Exceptions.ArgumentError} If the given enumerable is <code>null</code>.
 * Returns the first element of the enumerable, the first element of the enumerable which matches a given filter if
 * sepcified, or <code>null</code> if there is no such element.
 * @throws {Stubs.Exceptions.ArgumentError} If the given enumerable is <code>null</code>.
 * @param {function(T, number, ?): boolean|{predicate: function(T, number, ?): boolean, thisArg: !Object}=} predicate_or_options
 * @param {!Object=} thisArg
 * @return {T} The first element of the enumerable or <code>null</code>.
 */
yfiles.collections.IEnumerable.prototype.firstOrDefault = function(predicate_or_options, thisArg) {};

/**
 * Iterates over the enumerable and invokes the action for each element passing the value and index as arguments.
 * @param {function(T, number, ?): void} action The delegate to call.
 * @param {!Object=} thisArg
 * @return {void}
 */
yfiles.collections.IEnumerable.prototype.forEach = function(action, thisArg) {};

/**
 * Gets an {\@link yfiles.collections.IEnumerator.<T>} which can be used to iterate over the items in this instance
 * @abstract
 * @return {?<T>} The {\@link } which can be used to iterate over the items in this instance
 */
yfiles.collections.IEnumerable.prototype.getEnumerator = function() {};

/**
 * Whether the given value is contained in the enumerable.
 * @param {T} value The value to search for.
 * @return {boolean} <code>true</code> if the enumerable contains the given value.
 */
yfiles.collections.IEnumerable.prototype.includes = function(value) {};

/**
 * Returns the last element of the enumerable.
 * @throws {Stubs.Exceptions.ArgumentError} If the given enumerable is <code>null</code>.
 * @throws {Stubs.Exceptions.InvalidOperationError} If the enumerable is empty.
 * @return {T} The last element of the enumerable.
 */
yfiles.collections.IEnumerable.prototype.last = function() {};

/**
 * Returns the last element of the enumerable or <code>null</code> if the enumerable is empty.
 * @throws {Stubs.Exceptions.ArgumentError} If the given enumerable is <code>null</code>.
 * @return {T} The last element of the enumerable or <code>null</code>.
 */
yfiles.collections.IEnumerable.prototype.lastOrDefault = function() {};

/**
 * Maps each element of the enumerable into a new element in a new enumerable.
 * Type parameter <code>TResult</code>: The type of the mapped elements.
 * @template TResult
 * @param {function(T, number, ?): TResult} selector A function with the signature <code>function(element, index):TResult</code> which converts each element into a new element of the
 * type <code>TResult</code> depending on the element's index.
 * @param {!Object=} thisArg
 * @return {?<TResult>} A projection of the original enumerable.
 */
yfiles.collections.IEnumerable.prototype.map = function(selector, thisArg) {};

/**
 * Converts a untyped enumerable into an enumerable with the given type.
 * <p>
 * The source enumerable may contain elements which are not of the given type. Those elements will not be contained in the
 * returned enumerable.
 * </p>
 * Type parameter <code>TResult</code>.
 * @template TResult
 * @param {!yfiles.lang.Class} resultType
 * @return {?<TResult>} A typed enumerable.
 */
yfiles.collections.IEnumerable.prototype.ofType = function(resultType) {};

/**
 * Applies an <code>func</code> function over the enumerable's elements.
 * Type parameter <code>TAccumulate</code>: The type of the accumulated value.
 * @template TAccumulate
 * @param {TAccumulate} seed The start value for the accumulator.
 * @param {function(TAccumulate, T, number, ?): TAccumulate} func A function with the signature <code>function(seed,element):TAccumulate</code> which "adds" (accumulates) a value depending on the
 * element to the seed value and returns the result.
 * @return {TAccumulate} The final value of the accumulator.
 */
yfiles.collections.IEnumerable.prototype.reduce = function(seed, func) {};

/**
 * Creates a flattened view of a given enumerable using the given <code>selector</code> function which returns an enumerable for each
 * element of the source enumerable.
 * Type parameter <code>TResult</code>.
 * @template TResult
 * @param {function(T, number, ?): ?<TResult>} selector A function with the signature <code>function(element):IEnumerable</code> which returns an enumerable for each element of the source
 * enumerable.
 * @param {!Object=} thisArg
 * @return {?<TResult>} A flattened view of the given enumerable. The enumerables which are returned by the <code>selector</code> method for each element are
 * concatenated in the result.
 */
yfiles.collections.IEnumerable.prototype.selectMany = function(selector, thisArg) {};

/**
 * Whether the enumerable contains any elements matching the given <code>predicate</code>.
 * @throws {Stubs.Exceptions.ArgumentError} <code>e</code> is <code>null</code>.
 * Whether the enumerable contains any elements matching the given <code>predicate</code>.
 * @throws {Stubs.Exceptions.ArgumentError} <code>e</code> is <code>null</code>.
 * @param {function(T, number, ?): boolean|{predicate: function(T, number, ?): boolean, thisArg: !Object}=} predicate_or_options
 * @param {!Object=} thisArg
 * @return {boolean} Whether the enumerable contains any elements matching the given <code>predicate</code>.
 */
yfiles.collections.IEnumerable.prototype.some = function(predicate_or_options, thisArg) {};

/**
 * Calculates the sum of the elements of the enumerable.
 * @param {function(T, number, ?): number} selector A function with the signature <code>function(element):Number</code> which returns a numeric value for the given element.
 * @param {!Object=} thisArg
 * @return {number} The sum of the elements of the enumerable.
 */
yfiles.collections.IEnumerable.prototype.sum = function(selector, thisArg) {};

/**
 * Returns elements from an enumerable as long as the given <code>predicate</code> is <code>true</code>.
 * @param {function(T, number, ?): boolean} predicate A function with the signature <code>function(element):boolean</code> which returns <code>true</code> as long as the elements should be added to
 * the returned enumerable.
 * @param {!Object=} thisArg
 * @return {?} A subset of the original enumerable.
 */
yfiles.collections.IEnumerable.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * Creates an array with the values of the enumerable.
 * @return {!Array<T>} An array with the enumerable's elements.
 */
yfiles.collections.IEnumerable.prototype.toArray = function() {};

/**
 * Creates a {\@link yfiles.collections.List.<T>} with the values of the enumerable.
 * @return {!yfiles.collections.List<T>} An {\@link } with the enumerable's elements.
 */
yfiles.collections.IEnumerable.prototype.toList = function() {};

/**
 * Returns an enumerable which contains the elements of the original enumerable in reverse order.
 * @return {?} An enumerable which contains the elements of the original enumerable in reverse order.
 */
yfiles.collections.IEnumerable.prototype.toReversed = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.collections.IEnumerable;
/**
 * @record
 * @struct
 */
yfiles.collections.IEnumerator = function() {};
 /** @type {T} */
yfiles.collections.IEnumerator.prototype.current;

/**
 * Moves this enumerator to the next element.
 * <p>
 * A newly created enumerator's {\@link yfiles.collections.IEnumerator.<T>#current current position} is before the first element. Thus, this method must be called before first
 * access to the {\@link yfiles.collections.IEnumerator.<T>#current} property. The same applies to the state after calling {\@link yfiles.collections.IEnumerator.<T>#reset}.
 * </p>
 * @abstract
 * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
 */
yfiles.collections.IEnumerator.prototype.moveNext = function() {};

/**
 * Resets the enumerator to its starting state.
 * <p>
 * In other words: sets the current position before the first element.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.collections.IEnumerator.prototype.reset = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.collections.IEnumerator;
/**
 * @record
 * @struct
 */
yfiles.collections.IList = function() {};

/**
 * Gets the item at the given index.
 * @see yfiles.collections.IList.<T>#set
 * @abstract
 * @param {number} index The index of the item to access.
 * @return {T} The item at the given index.
 */
yfiles.collections.IList.prototype.get = function(index) {};

/**
 * The index of the given item in the list.
 * @abstract
 * @param {T} item The item to search for.
 * @return {number} The index of the given item in the list. <code>-1</code> if the item is not in the list.
 */
yfiles.collections.IList.prototype.indexOf = function(item) {};

/**
 * Inserts the given <code>item</code> at the given <code>index</code>.
 * @abstract
 * @param {number} index The index to insert the item at.
 * @param {T} item The item to insert.
 * @return {void}
 */
yfiles.collections.IList.prototype.insert = function(index, item) {};

/**
 * Removes the item at the given index from the list.
 * @abstract
 * @param {number} index The index of the item to remove.
 * @return {void}
 */
yfiles.collections.IList.prototype.removeAt = function(index) {};

/**
 * Sets the item at the given index.
 * @see yfiles.collections.IList.<T>#get
 * @abstract
 * @param {number} index The index of the item to access.
 * @param {T} value The item at the given index.
 * @return {void}
 */
yfiles.collections.IList.prototype.set = function(index, value) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.collections.IList;
/**
 * @record
 * @struct
 */
yfiles.collections.MapEntry = function() {};
 /** @type {TKey} */
yfiles.collections.MapEntry.prototype.key;
 /** @type {TValue} */
yfiles.collections.MapEntry.prototype.value;
 /** @type {!yfiles.lang.Class} */
yfiles.collections.MapEntry.$class;
/**
 * @record
 * @struct
 */
yfiles.collections.List = function() {};
 /** @type {number} */
yfiles.collections.List.prototype.size;
 /** @type {boolean} */
yfiles.collections.List.prototype.isReadOnly;
 /** @type {number} */
yfiles.collections.List.prototype.capacity;
 /** @type {!yfiles.lang.Class} */
yfiles.collections.List.$class;

/**
 *
 * @param {T} item
 * @return {void}
 */
yfiles.collections.List.prototype.add = function(item) {};

/**
 * Adds the elements of the given collection to this list.
 * @param {?<T>} enumerable The collection to add.
 * @return {void}
 */
yfiles.collections.List.prototype.addRange = function(enumerable) {};

/**
 * Searches the (sorted) list for the given <code>item</code>.
 * <p>
 * This search is done as a binary search, therefore the list must be sorted. The given <code>comparer</code> is used to compare the
 * elements to each other.
 * </p>
 * @param {T} item The item to search for.
 * @param {?<T>} comparer The comparer to use for comparing the elements.
 * @return {number} The index of the item in the list. -1 if the item is not found.
 */
yfiles.collections.List.prototype.binarySearch = function(item, comparer) {};

/**
 *
 * @return {void}
 */
yfiles.collections.List.prototype.clear = function() {};

/**
 *
 * @param {!Array<T>} array
 * @param {number} arrayIndex
 * @return {void}
 */
yfiles.collections.List.prototype.copyTo = function(array, arrayIndex) {};

/**
 * Searches the list for the first element for which <code>match</code> returns <code>true</code>.
 * @param {function(T): boolean} match A predicate function with the signature <code>function(o:Object):boolean</code> which returns <code>true</code> if o matches the conditions of the
 * element to search for.
 * @return {T} The first element for which <code>match</code> returns <code>true</code> or <code>null</code> is no such element in the list.
 */
yfiles.collections.List.prototype.find = function(match) {};

/**
 * Searches the list for the first element for which <code>match</code> returns <code>true</code> and returns its index.
 * @param {function(T): boolean} match A predicate function with the signature <code>function(o:Object):boolean</code> which returns <code>true</code> if o matches the conditions of the
 * element to search for.
 * @return {number} The index of the first element for which <code>match</code> returns <code>true</code> or -1 if there is no such element in the list.
 */
yfiles.collections.List.prototype.findIndex = function(match) {};

/**
 * Creates a new list with the given array used as the live backing store.
 * <p>
 * Modifying the list or the array will modify both instances.
 * </p>
 * @template T
 * @param {!Array<T>} array The array to create a list view over from.
 * @return {!yfiles.collections.List<T>} A list backed by the given array.
 */
yfiles.collections.List.fromArray = function(array) {};

/**
 *
 * @param {number} index
 * @return {T}
 */
yfiles.collections.List.prototype.get = function(index) {};

/**
 *
 * @return {?<T>}
 */
yfiles.collections.List.prototype.getEnumerator = function() {};

/**
 *
 * @param {T} item
 * @return {boolean}
 */
yfiles.collections.List.prototype.includes = function(item) {};

/**
 *
 * @param {T} item
 * @return {number}
 */
yfiles.collections.List.prototype.indexOf = function(item) {};

/**
 *
 * @param {number} index
 * @param {T} item
 * @return {void}
 */
yfiles.collections.List.prototype.insert = function(index, item) {};

/**
 *
 * @param {T} item
 * @return {boolean}
 */
yfiles.collections.List.prototype.remove = function(item) {};

/**
 * Removes all elements for which <code>match</code> returns <code>true</code>.
 * @param {function(T): boolean} match A predicate function with the signature <code>function(o:Object):boolean</code> which returns <code>true</code> if o matches the conditions of the
 * element to search for.
 * @return {number} The number of elements which were removed.
 */
yfiles.collections.List.prototype.removeAll = function(match) {};

/**
 *
 * @param {number} index
 * @return {void}
 */
yfiles.collections.List.prototype.removeAt = function(index) {};

/**
 * Removes a given <code>count</code> of elements starting from the given <code>index</code>.
 * @param {number} index The index of the first element to remove.
 * @param {number} count The number of elements to remove.
 * @return {void}
 */
yfiles.collections.List.prototype.removeRange = function(index, count) {};

/**
 * Reverses the order of the elements in the list.
 * @return {void}
 */
yfiles.collections.List.prototype.reverse = function() {};

/**
 *
 * @param {number} index
 * @param {T} value
 * @return {void}
 */
yfiles.collections.List.prototype.set = function(index, value) {};

/**
 * Sorts all elements in the list using the given <code>comparison</code> function.
 * Sorts all elements in the list using the given <code>comparer</code>.
 * Sorts all elements in list using the default comparer.
 * @param {function(!Object, !Object): number|?<T>=} comparison_or_comparer The comparison function to use. / The comparer to use.
 * @return {void}
 */
yfiles.collections.List.prototype.sort = function(comparison_or_comparer) {};

/**
 * Copies the elements of this list into an array.
 * @return {!Array<T>} An array containing the elements of this list.
 */
yfiles.collections.List.prototype.toArray = function() {};
/**
 * @record
 * @struct
 */
yfiles.collections.IComparer = function() {};

/**
 * Compares two objects of type T.
 * @abstract
 * @param {T} x The first object.
 * @param {T} y The second object.
 * @return {number} 
 * <ul>
 * <li>-1: <code>x</code> is less than <code>y</code></li>
 * <li>0: <code>x</code> is equal to <code>y</code></li>
 * <li>1: <code>x</code> is greater than <code>y</code></li>
 * </ul>
 */
yfiles.collections.IComparer.prototype.compare = function(x, y) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.collections.IComparer;
/**
 * @record
 * @struct
 */
yfiles.collections.ObservableCollection = function() {};
 /** @type {number} */
yfiles.collections.ObservableCollection.prototype.size;
 /** @type {boolean} */
yfiles.collections.ObservableCollection.prototype.isReadOnly;
 /** @type {?<T>} */
yfiles.collections.ObservableCollection.prototype.items;
 /** @type {!yfiles.lang.Class} */
yfiles.collections.ObservableCollection.$class;

/**
 * Adds the item the the collection and triggers the {\@link yfiles.collections.ObservableCollection.<T>#addItemAddedListener ItemAdded} event.
 * <p>
 * This implementation calls the {\@link yfiles.collections.ObservableCollection.<T>#onItemAdded} method.
 * </p>
 * @param {T} item The item to add to the collection.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.add = function(item) {};

/**
 * Clears this collection, triggering an {\@link yfiles.collections.ObservableCollection.<T>#addItemRemovedListener ItemRemoved} event for each element removed.
 * @see yfiles.collections.ObservableCollection.<T>#onItemRemoved
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.clear = function() {};

/**
 * Copies the items to the given array.
 * @param {!Array<T>} array
 * @param {number} arrayIndex
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.copyTo = function(array, arrayIndex) {};

/**
 * Returns an enumerator over the elements in this collection.
 * @return {?<T>}
 */
yfiles.collections.ObservableCollection.prototype.getEnumerator = function() {};

/**
 * Checks for containment of the item in this collection.
 * @param {T} item The item to check.
 * @return {boolean} Whether the item is contained in this collection.
 */
yfiles.collections.ObservableCollection.prototype.includes = function(item) {};

/**
 * Callback method that will trigger the {\@link yfiles.collections.ObservableCollection.<T>#addItemAddedListener ItemAdded} event.
 * @protected
 * @param {T} item The item that has just been added to the collection.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.onItemAdded = function(item) {};

/**
 * Callback method that will trigger the {\@link yfiles.collections.ObservableCollection.<T>#addItemChangedListener ItemChanged} event.
 * @protected
 * @param {T} item The item that has changed.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.onItemChanged = function(item) {};

/**
 * Callback method that will trigger the {\@link yfiles.collections.ObservableCollection.<T>#addItemRemovedListener ItemRemoved} event.
 * @protected
 * @param {T} item The item that has just been removed from the collection.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.onItemRemoved = function(item) {};

/**
 * Method that may be called by client code to trigger an {\@link yfiles.collections.ObservableCollection.<T>#addItemChangedListener ItemChanged} event.
 * @see yfiles.collections.ObservableCollection.<T>#onItemChanged
 * @param {T} item The item to trigger the change event for.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.publishItemChanged = function(item) {};

/**
 * Tries to remove the item from the collection and triggers the {\@link yfiles.collections.ObservableCollection.<T>#addItemRemovedListener ItemRemoved} event.
 * @see yfiles.collections.ObservableCollection.<T>#onItemRemoved
 * @param {T} item The item to remove.
 * @return {boolean} Whether the item has been removed.
 */
yfiles.collections.ObservableCollection.prototype.remove = function(item) {};

/**
 * Adds the given listener for the <code>ItemAdded</code> event that occurs when an item has been added to this collection.
 * @see yfiles.collections.ObservableCollection.<T>#removeItemAddedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to add.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.addItemAddedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemAdded</code> event that occurs when an item has been added to this collection.
 * @see yfiles.collections.ObservableCollection.<T>#addItemAddedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.removeItemAddedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemRemoved</code> event that occurs when an item has been removed from this collection.
 * @see yfiles.collections.ObservableCollection.<T>#removeItemRemovedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to add.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.addItemRemovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemRemoved</code> event that occurs when an item has been removed from this collection.
 * @see yfiles.collections.ObservableCollection.<T>#addItemRemovedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.removeItemRemovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemChanged</code> event that occurs when an item has been changed inside this collection.
 * @see yfiles.collections.ObservableCollection.<T>#removeItemChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to add.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.addItemChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemChanged</code> event that occurs when an item has been changed inside this collection.
 * @see yfiles.collections.ObservableCollection.<T>#addItemChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.collections.ObservableCollection.prototype.removeItemChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.collections.Mapper = function() {};
 /** @type {?<!yfiles.collections.MapEntry<K, V>>} */
yfiles.collections.Mapper.prototype.entries;
 /** @type {V} */
yfiles.collections.Mapper.prototype.defaultValue;
 /** @type {!yfiles.lang.Class} */
yfiles.collections.Mapper.$class;

/**
 * Calls {\@link yfiles.collections.Map.<TKey,TValue>#clear} on the backing implementation.
 * @return {void}
 */
yfiles.collections.Mapper.prototype.clear = function() {};

/**
 *
 * @param {K} key
 * @return {void}
 */
yfiles.collections.Mapper.prototype.delete = function(key) {};

/**
 *
 * @param {K} key
 * @return {V}
 */
yfiles.collections.Mapper.prototype.get = function(key) {};

/**
 *
 * @param {K} key
 * @param {V} value
 * @return {void}
 */
yfiles.collections.Mapper.prototype.set = function(key, value) {};
/**
 * @record
 * @struct
 */
yfiles.collections.IObservableCollection = function() {};

/**
 * Adds the given listener for the <code>ItemAdded</code> event that occurs when an item has been added to this collection.
 * @see yfiles.collections.IObservableCollection.<T>#removeItemAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to add.
 * @return {void}
 */
yfiles.collections.IObservableCollection.prototype.addItemAddedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemAdded</code> event that occurs when an item has been added to this collection.
 * @see yfiles.collections.IObservableCollection.<T>#addItemAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.collections.IObservableCollection.prototype.removeItemAddedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemRemoved</code> event that occurs when an item has been removed from this collection.
 * @see yfiles.collections.IObservableCollection.<T>#removeItemRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to add.
 * @return {void}
 */
yfiles.collections.IObservableCollection.prototype.addItemRemovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemRemoved</code> event that occurs when an item has been removed from this collection.
 * @see yfiles.collections.IObservableCollection.<T>#addItemRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.collections.IObservableCollection.prototype.removeItemRemovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemChanged</code> event that occurs when an item in this collection has changed
 * significantly.
 * <p>
 * It is up to the implementation whether and when to trigger this event.
 * </p>
 * @see yfiles.collections.IObservableCollection.<T>#removeItemChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to add.
 * @return {void}
 */
yfiles.collections.IObservableCollection.prototype.addItemChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemChanged</code> event that occurs when an item in this collection has changed
 * significantly.
 * <p>
 * It is up to the implementation whether and when to trigger this event.
 * </p>
 * @see yfiles.collections.IObservableCollection.<T>#addItemChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.collections.IObservableCollection.prototype.removeItemChangedListener = function(listener) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.collections.IObservableCollection;
/**
 * @record
 * @struct
 */
yfiles.collections.IListEnumerable = function() {};
 /** @type {number} */
yfiles.collections.IListEnumerable.prototype.size;

/**
 * Gets the <code>i</code>-th element in the collection.
 * @throws {Stubs.Exceptions.ArgumentError} <code>i</code> is not a valid index in the {\@link yfiles.collections.IListEnumerable.<T>}.
 * @abstract
 * @param {number} i the zero-based index of the item in this collection
 * @return {T} the item for the given index
 */
yfiles.collections.IListEnumerable.prototype.get = function(i) {};
 /** @type {{EMPTY: ?<?>, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.collections.IListEnumerable;
/**
 * @record
 * @struct
 */
yfiles.collections.ListEnumerable = function() {};
 /** @type {?<T>} */
yfiles.collections.ListEnumerable.prototype.backingEnumerable;
 /** @type {number} */
yfiles.collections.ListEnumerable.prototype.size;
 /** @type {!yfiles.lang.Class} */
yfiles.collections.ListEnumerable.$class;

/**
 *
 * @param {number} i
 * @return {T}
 */
yfiles.collections.ListEnumerable.prototype.get = function(i) {};

/**
 *
 * @return {?<T>}
 */
yfiles.collections.ListEnumerable.prototype.getEnumerator = function() {};
/**
 * @record
 * @struct
 */
yfiles.collections.ItemEventArgs = function() {};
 /** @type {T} */
yfiles.collections.ItemEventArgs.prototype.item;
 /** @type {!yfiles.lang.Class} */
yfiles.collections.ItemEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.collections.IMapper = function() {};

/**
 * Gets the value for a given key in the mapping.
 * <p>
 * Setting a value for an already existing key overwrites the previous value.
 * </p>
 * <p>
 * It depends on the specific implementation of the mapper whether a mapping can be removed. If an implementation provides
 * a way to remove a mapping, that should be preferred over setting a <code>null</code> value. For example, {\@link yfiles.collections.Mapper.<K,V>} provides the {\@link yfiles.collections.Mapper.<K,V>#delete}
 * method.
 * </p>
 * @see yfiles.collections.IMapper.<K,V>#set
 * @abstract
 * @param {K} key The key of the mapping.
 * @return {V} The value.
 */
yfiles.collections.IMapper.prototype.get = function(key) {};

/**
 * Sets the value for a given key in the mapping.
 * <p>
 * Setting a value for an already existing key overwrites the previous value.
 * </p>
 * <p>
 * It depends on the specific implementation of the mapper whether a mapping can be removed. If an implementation provides
 * a way to remove a mapping, that should be preferred over setting a <code>null</code> value. For example, {\@link yfiles.collections.Mapper.<K,V>} provides the {\@link yfiles.collections.Mapper.<K,V>#delete}
 * method.
 * </p>
 * @see yfiles.collections.IMapper.<K,V>#get
 * @abstract
 * @param {K} key The key of the mapping.
 * @param {V} value The value.
 * @return {void}
 */
yfiles.collections.IMapper.prototype.set = function(key, value) {};
 /** @type {{fromConstant: function(V): ?<K, V>, fromDelegate: function(function(K): V): ?<K, V>, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.collections.IMapper;
/** @const */
yfiles.graphml = {};
/**
 * @record
 * @struct
 */
yfiles.graphml.XmlName = function() {};
 /** @type {string} */
yfiles.graphml.XmlName.prototype.localName;
 /** @type {string} */
yfiles.graphml.XmlName.prototype.namespace;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.XmlName.$class;

/**
 * Performs a conversion from {\@link string} to {\@link yfiles.graphml.XmlName}.
 * <p>
 * The name is made up of at most two parts: the namespace and the local name. When given an input like <code>"http://www.w3.org/2000/xmlns/}local"</code>
 * it will be split at the "}" character and the first part will be used as the namespace URI, the second part as the local
 * name. If no "}" character is used in the input then it will be assumed that the input consists of the local name only.
 * </p>
 * @param {string} expandedName Name of the expanded.
 * @return {!yfiles.graphml.XmlName} The result of the conversion.
 */
yfiles.graphml.XmlName.convertFrom = function(expandedName) {};

/** @const */
yfiles.graphml.XamlAttributeWritePolicy = {};
/** @const {number} */
yfiles.graphml.XamlAttributeWritePolicy.AUTO;
/** @const {number} */
yfiles.graphml.XamlAttributeWritePolicy.NEVER;
/** @const {number} */
yfiles.graphml.XamlAttributeWritePolicy.ALWAYS;

/** @const */
yfiles.graphml.GraphMLSharingPolicy = {};
/** @const {number} */
yfiles.graphml.GraphMLSharingPolicy.AUTO;
/** @const {number} */
yfiles.graphml.GraphMLSharingPolicy.NEVER;
/** @const {number} */
yfiles.graphml.GraphMLSharingPolicy.ALWAYS;

/** @const */
yfiles.graphml.GraphMLMemberVisibility = {};
/** @const {number} */
yfiles.graphml.GraphMLMemberVisibility.VISIBLE;
/** @const {number} */
yfiles.graphml.GraphMLMemberVisibility.CONTENT;
/** @const {number} */
yfiles.graphml.GraphMLMemberVisibility.HIDDEN;

/** @const */
yfiles.graphml.UndefinedHandling = {};
/** @const {number} */
yfiles.graphml.UndefinedHandling.EXPLICIT;
/** @const {number} */
yfiles.graphml.UndefinedHandling.THROW;
/** @const {number} */
yfiles.graphml.UndefinedHandling.AS_NULL;
/** @const {number} */
yfiles.graphml.UndefinedHandling.AS_DEFAULT;
/**
 * @record
 * @struct
 */
yfiles.graphml.GraphMLAttribute = function() {};
 /** @type {string} */
yfiles.graphml.GraphMLAttribute.prototype.name;
 /** @type {string} */
yfiles.graphml.GraphMLAttribute.prototype.xmlNamespace;
 /** @type {boolean} */
yfiles.graphml.GraphMLAttribute.prototype.writeEnclosingTag;
 /** @type {yfiles.graphml.XamlAttributeWritePolicy} */
yfiles.graphml.GraphMLAttribute.prototype.writeAsAttribute;
 /** @type {yfiles.graphml.GraphMLSharingPolicy} */
yfiles.graphml.GraphMLAttribute.prototype.shareable;
 /** @type {yfiles.graphml.GraphMLMemberVisibility} */
yfiles.graphml.GraphMLAttribute.prototype.visibility;
 /** @type {string} */
yfiles.graphml.GraphMLAttribute.prototype.contentProperty;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLAttribute.prototype.valueSerializer;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLAttribute.prototype.markupExtensionConverter;
 /** @type {!Array<!yfiles.lang.Class>} */
yfiles.graphml.GraphMLAttribute.prototype.singletonContainers;
 /** @type {!Object} */
yfiles.graphml.GraphMLAttribute.prototype.defaultValue;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLAttribute.$class;

/** @const */
yfiles.graphml.KeyType = {};
/** @const {number} */
yfiles.graphml.KeyType.INT;
/** @const {number} */
yfiles.graphml.KeyType.LONG;
/** @const {number} */
yfiles.graphml.KeyType.FLOAT;
/** @const {number} */
yfiles.graphml.KeyType.DOUBLE;
/** @const {number} */
yfiles.graphml.KeyType.STRING;
/** @const {number} */
yfiles.graphml.KeyType.BOOLEAN;
/** @const {number} */
yfiles.graphml.KeyType.COMPLEX;

/** @const */
yfiles.graphml.KeyScope = {};
/** @const {number} */
yfiles.graphml.KeyScope.ALL;
/** @const {number} */
yfiles.graphml.KeyScope.NODE;
/** @const {number} */
yfiles.graphml.KeyScope.EDGE;
/** @const {number} */
yfiles.graphml.KeyScope.GRAPH;
/** @const {number} */
yfiles.graphml.KeyScope.PORT;
/** @const {number} */
yfiles.graphml.KeyScope.GRAPHML;
/**
 * @record
 * @struct
 */
yfiles.graphml.IParseContext = function() {};
 /** @type {?<!Object>} */
yfiles.graphml.IParseContext.prototype.objectStack;
 /** @type {?} */
yfiles.graphml.IParseContext.prototype.parseEvents;
 /** @type {?} */
yfiles.graphml.IParseContext.prototype.graph;

/**
 * Deserialize the object representation in <code>targetNode</code>.
 * <p>
 * This method calls {\@link yfiles.graphml.IParseContext#deserializeCore} with <code>context</code> as first argument and should be used in
 * virtually all cases.
 * </p>
 * Type parameter <code>T</code>: The desired target type.
 * @throws {yfiles.graphml.DeserializationNotSupportedError}
 * @see yfiles.graphml.IParseContext#deserializeCore
 * @template T
 * @param {!yfiles.lang.Class} targetType The desired target type.
 * @param {!Node} targetNode The XML node that should be deserialized.
 * @return {T} an instance of <code>T</code> or <code>null</code>.
 */
yfiles.graphml.IParseContext.prototype.deserialize = function(targetType, targetNode) {};

/**
 * Deserialize the object representation in <code>targetNode</code>
 * <p>
 * Client code should usually use the extension method {\@link yfiles.graphml.IParseContext#deserialize} instead to ensure the the
 * correct <code>context</code> instance is used.
 * </p>
 * Type parameter <code>T</code>: The expected return type.
 * @see yfiles.graphml.IParseContext#deserialize
 * @abstract
 * @template T
 * @param {!yfiles.lang.Class} targetType The expected return type.
 * @param {?} context The current parse context.
 * @param {!Node} targetNode The XML node that should be deserialized.
 * @return {T} The deserialized object from <code>targetNode</code> or an {\@link } if <code>targetNode</code> could not be deserialized.
 */
yfiles.graphml.IParseContext.prototype.deserializeCore = function(targetType, context, targetNode) {};

/**
 * Returns the most current (the last element) within the container hierarchy as it is returned by {\@link yfiles.graphml.IParseContext#objectStack} or <code>default(T)</code> if the
 * most current element is not of the desired target type.
 * Type parameter <code>T</code>: The desired target type.
 * @abstract
 * @template T
 * @param {!yfiles.lang.Class} itemType The desired target type.
 * @return {T} the most current element within the container hierarchy or <code>default(T)</code>.
 */
yfiles.graphml.IParseContext.prototype.getCurrent = function(itemType) {};

/**
 * Get a property value that specifies information about how to handle specific cases.
 * @abstract
 * @param {string} key The identifier for the property
 * @return {!Object} The property value, or <code>null</code> if no such property exists.
 */
yfiles.graphml.IParseContext.prototype.getDeserializationProperty = function(key) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IParseContext;
/**
 * @record
 * @struct
 */
yfiles.graphml.IParseEvents = function() {};

/**
 * Adds the given listener for the <code>DocumentParsing</code> event that occurs when the document is about to be parsed.
 * <p>
 * This event is triggered when the document element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeDocumentParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addDocumentParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DocumentParsing</code> event that occurs when the document is about to be parsed.
 * <p>
 * This event is triggered when the document element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#addDocumentParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeDocumentParsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DocumentParsed</code> event that occurs when the document has been parsed.
 * <p>
 * This event is triggered when the document has been fully parsed.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeDocumentParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addDocumentParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DocumentParsed</code> event that occurs when the document has been parsed.
 * <p>
 * This event is triggered when the document has been fully parsed.
 * </p>
 * @see yfiles.graphml.IParseEvents#addDocumentParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeDocumentParsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeParsing</code> event that occurs when a node element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'node' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeNodeParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addNodeParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeParsing</code> event that occurs when a node element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'node' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#addNodeParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeNodeParsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeParsed</code> event that occurs after a node element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'node' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeNodeParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addNodeParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeParsed</code> event that occurs after a node element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'node' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#addNodeParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeNodeParsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeParsing</code> event that occurs when an edge element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'edge' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeEdgeParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addEdgeParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeParsing</code> event that occurs when an edge element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'edge' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#addEdgeParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeEdgeParsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeParsed</code> event that occurs after a edge element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'edge' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeEdgeParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addEdgeParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeParsed</code> event that occurs after a edge element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'edge' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#addEdgeParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeEdgeParsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortParsing</code> event that occurs when a port element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'port' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#removePortParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addPortParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortParsing</code> event that occurs when a port element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'port' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#addPortParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removePortParsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortParsed</code> event that occurs after a port element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'port' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#removePortParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addPortParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortParsed</code> event that occurs after a port element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'port' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#addPortParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removePortParsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphParsing</code> event that occurs when a graph element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'graph' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeGraphParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addGraphParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphParsing</code> event that occurs when a graph element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'graph' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#addGraphParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeGraphParsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphParsed</code> event that occurs after a graph element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'graph' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeGraphParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addGraphParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphParsed</code> event that occurs after a graph element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'graph' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#addGraphParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeGraphParsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphMLParsing</code> event that occurs when the graphml element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'graphml' root-element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeGraphMLParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addGraphMLParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphMLParsing</code> event that occurs when the graphml element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'graphml' root-element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#addGraphMLParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeGraphMLParsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphMLParsed</code> event that occurs after the graphml element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'graphml' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeGraphMLParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addGraphMLParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphMLParsed</code> event that occurs after the graphml element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'graphml' closing tag has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#addGraphMLParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeGraphMLParsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DataParsing</code> event that occurs when a data element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'data' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeDataParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addDataParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DataParsing</code> event that occurs when a data element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'data' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#addDataParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeDataParsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DataParsed</code> event that occurs after a data element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'data' element has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeDataParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addDataParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DataParsed</code> event that occurs after a data element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'data' element has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#addDataParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeDataParsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>KeyParsing</code> event that occurs when a key element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'key' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeKeyParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addKeyParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>KeyParsing</code> event that occurs when a key element is about to be parsed.
 * <p>
 * This event is triggered when a GraphML 'key' element has been encountered.
 * </p>
 * @see yfiles.graphml.IParseEvents#addKeyParsingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeKeyParsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>KeyParsed</code> event that occurs after a key element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'key' element has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#removeKeyParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.addKeyParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>KeyParsed</code> event that occurs after a key element has been fully parsed.
 * <p>
 * This event is triggered when a GraphML 'key' element has been handled.
 * </p>
 * @see yfiles.graphml.IParseEvents#addKeyParsedListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IParseEvents.prototype.removeKeyParsedListener = function(listener) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IParseEvents;
/**
 * @record
 * @struct
 */
yfiles.graphml.ParseEventArgs = function() {};
 /** @type {?} */
yfiles.graphml.ParseEventArgs.prototype.context;
 /** @type {!Element} */
yfiles.graphml.ParseEventArgs.prototype.element;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.ParseEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.GraphMLXmlAttribute = function() {};
 /** @type {!yfiles.graphml.XmlName} */
yfiles.graphml.GraphMLXmlAttribute.prototype.name;
 /** @type {string} */
yfiles.graphml.GraphMLXmlAttribute.prototype.value;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLXmlAttribute.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.IOutputHandler = function() {};
 /** @type {yfiles.graphml.WritePrecedence} */
yfiles.graphml.IOutputHandler.prototype.precedence;
 /** @type {?<!yfiles.graphml.GraphMLXmlAttribute>} */
yfiles.graphml.IOutputHandler.prototype.keyDefinitionAttributes;
 /** @type {?<!yfiles.graphml.GraphMLXmlAttribute>} */
yfiles.graphml.IOutputHandler.prototype.dataTagAttributes;

/**
 * Determines whether in the current context, the value is the default value and therefore no data element needs to be
 * written.
 * @abstract
 * @param {?} context The context.
 * @return {boolean} <code>true</code> if for the current context the default value applies and therefore no data element needs to be written.
 */
yfiles.graphml.IOutputHandler.prototype.isDefaultValue = function(context) {};

/**
 * Writes the contents of the key definition.
 * <p>
 * At the time this method is called, the surrounding 'key' element has already been written. However no 'default' element
 * is written by the framework.
 * </p>
 * @abstract
 * @param {?} context The context.
 * @return {void}
 */
yfiles.graphml.IOutputHandler.prototype.writeKeyDefinitionContent = function(context) {};

/**
 * Actually writes the value for the current context.
 * <p>
 * At the time this method is called, the surrounding 'data' element has already been written.
 * </p>
 * @abstract
 * @param {?} context The context.
 * @return {void}
 */
yfiles.graphml.IOutputHandler.prototype.writeValue = function(context) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IOutputHandler;

/** @const */
yfiles.graphml.WritePrecedence = {};
/** @const {number} */
yfiles.graphml.WritePrecedence.BEFORE_CHILDREN;
/** @const {number} */
yfiles.graphml.WritePrecedence.DEFAULT;
/** @const {number} */
yfiles.graphml.WritePrecedence.AFTER_CHILDREN;
/**
 * @record
 * @struct
 */
yfiles.graphml.IWriteContext = function() {};
 /** @type {?<!Object>} */
yfiles.graphml.IWriteContext.prototype.objectStack;
 /** @type {?} */
yfiles.graphml.IWriteContext.prototype.writeEvents;
 /** @type {?} */
yfiles.graphml.IWriteContext.prototype.writer;
 /** @type {?} */
yfiles.graphml.IWriteContext.prototype.graph;

/**
 * Returns the most current (the last element) within the container hierarchy as it is returned by {\@link yfiles.graphml.IWriteContext#objectStack} or <code>default(T)</code> if the
 * most current element is not of the desired target type.
 * Type parameter <code>T</code>: The desired target type.
 * @abstract
 * @template T
 * @param {!yfiles.lang.Class} itemType The desired target type.
 * @return {T} the most current element within the container hierarchy or <code>default(T)</code>.
 */
yfiles.graphml.IWriteContext.prototype.getCurrent = function(itemType) {};

/**
 * Get a property value that specifies information about how to handle specific cases
 * @abstract
 * @param {string} key The identifier for the property
 * @return {!Object} The property value, or <code>null</code> if no such property exists
 */
yfiles.graphml.IWriteContext.prototype.getSerializationProperty = function(key) {};

/**
 * Serializes the specified item using the provided type information.
 * <p>
 * <code>item</code> should be assignable to type <code>t</code>. This method simply delegates to
 * {\@link yfiles.graphml.IWriteContext#serializeCore}, using the correct type parameter.
 * </p>
 * Serialize the <code>item</code>.
 * <p>
 * This method calls {\@link yfiles.graphml.IWriteContext#serializeCore} with <code>context</code> as first argument and should be used in
 * virtually all cases.
 * </p>
 * Type parameter <code>T</code>: The type of the object that is serialized.
 * @throws {yfiles.graphml.SerializationNotSupportedError}
 * @see yfiles.graphml.IWriteContext#serializeCore
 * @template T
 * @param {!Object|!yfiles.lang.Class} item_or_targetType The item to serialize. / The type of the object that is serialized.
 * @param {!yfiles.lang.Class|T} t_or_item The type the item is known to be of at deserialization time. / The object that should be serialized.
 * @return {void}
 */
yfiles.graphml.IWriteContext.prototype.serialize = function(item_or_targetType, t_or_item) {};

/**
 * Serialize <code>item</code> to an XML representation.
 * <p>
 * Client code should usually use the extension method {\@link yfiles.graphml.IWriteContext#serialize} instead to ensure the the
 * correct <code>context</code> instance is used.
 * </p>
 * Type parameter <code>T</code>: The type of the object that is serialized.
 * @throws {yfiles.graphml.SerializationNotSupportedError}
 * @see yfiles.graphml.IWriteContext#serialize
 * @abstract
 * @template T
 * @param {!yfiles.lang.Class} targetType The type of the object that is serialized.
 * @param {?} context The current write context.
 * @param {T} item The object that should be serialized.
 * @return {void}
 */
yfiles.graphml.IWriteContext.prototype.serializeCore = function(targetType, context, item) {};

/**
 * Serialize an replacement object <code>replacement</code> instead of the original <code>originalItem</code>.
 * <p>
 * Calling this method allows to remember the original object instance, even if the object is really written through a {\@link yfiles.graphml.MarkupExtension}
 * or similar replacement mechanisms.
 * </p>
 * Type parameter <code>T</code>: The type of the object that is serialized.
 * @throws {yfiles.graphml.SerializationNotSupportedError}
 * @see yfiles.graphml.IWriteContext#serializeCore
 * @template T
 * @param {!yfiles.lang.Class} targetType
 * @param {!Object} originalItem The original object that should be serialized.
 * @param {T} replacement The replacement object that will actually be serialized instead.
 * @return {void}
 */
yfiles.graphml.IWriteContext.prototype.serializeReplacement = function(targetType, originalItem, replacement) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IWriteContext;
/**
 * @record
 * @struct
 */
yfiles.graphml.IWriteEvents = function() {};

/**
 * Adds the given listener for the <code>DocumentWriting</code> event that occurs just after the {\@link yfiles.graphml.IXmlWriter#writeStartDocument}
 * has been called.
 * @see yfiles.graphml.IWriteEvents#removeDocumentWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addDocumentWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DocumentWriting</code> event that occurs just after the {\@link yfiles.graphml.IXmlWriter#writeStartDocument}
 * has been called.
 * @see yfiles.graphml.IWriteEvents#addDocumentWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeDocumentWritingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DocumentWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndDocument}
 * will be called.
 * @see yfiles.graphml.IWriteEvents#removeDocumentWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addDocumentWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>DocumentWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndDocument}
 * will be called.
 * @see yfiles.graphml.IWriteEvents#addDocumentWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeDocumentWrittenListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'node' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeNodeWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addNodeWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'node' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#addNodeWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeNodeWritingListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'node' element will be called.
 * <p>
 * This can be used to append more custom elements to the node element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeNodeWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addNodeWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'node' element will be called.
 * <p>
 * This can be used to append more custom elements to the node element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#addNodeWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeNodeWrittenListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'edge' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeEdgeWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addEdgeWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'edge' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#addEdgeWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeEdgeWritingListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'edge' element will be called.
 * <p>
 * This can be used to append more custom elements to the edge element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeEdgeWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addEdgeWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'edge' element will be called.
 * <p>
 * This can be used to append more custom elements to the edge element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#addEdgeWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeEdgeWrittenListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'port' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#removePortWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addPortWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'port' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#addPortWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removePortWritingListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'port' element will be called.
 * <p>
 * This can be used to append more custom elements to the port element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#removePortWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addPortWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'port' element will be called.
 * <p>
 * This can be used to append more custom elements to the port element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#addPortWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removePortWrittenListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'graph' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeGraphWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addGraphWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'graph' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#addGraphWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeGraphWritingListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'graph' element will be called.
 * <p>
 * This can be used to append more custom elements to the graph element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeGraphWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addGraphWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'graph' element will be called.
 * <p>
 * This can be used to append more custom elements to the graph element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#addGraphWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeGraphWrittenListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphMLWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'graphml' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeGraphMLWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addGraphMLWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphMLWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'graphml' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#addGraphMLWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeGraphMLWritingListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphMLWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'graphml' element will be called.
 * <p>
 * This can be used to append more custom elements to the graphml element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeGraphMLWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addGraphMLWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphMLWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'graphml' element will be called.
 * <p>
 * This can be used to append more custom elements to the graphml element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#addGraphMLWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeGraphMLWrittenListener = function(listener) {};

/**
 * Adds the given listener for the <code>DataWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'data' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeDataWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addDataWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DataWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'data' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#addDataWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeDataWritingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DataWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'data' element will be called.
 * <p>
 * This can be used to append more custom elements to the data element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeDataWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addDataWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>DataWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'data' element will be called.
 * <p>
 * This can be used to append more custom elements to the data element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#addDataWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeDataWrittenListener = function(listener) {};

/**
 * Adds the given listener for the <code>KeyWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'key' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeKeyWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addKeyWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>KeyWriting</code> event that occurs right after the {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * method for writing a GraphMl 'key' element has been called.
 * <p>
 * At that state, callees can use the {\@link yfiles.graphml.IXmlWriter#writeAttributeNS} methods to add custom attributes to the
 * XML element or write a first custom inner element using {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * </p>
 * @see yfiles.graphml.IWriteEvents#addKeyWritingListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeKeyWritingListener = function(listener) {};

/**
 * Adds the given listener for the <code>KeyWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'key' element will be called.
 * <p>
 * This can be used to append more custom elements to the key element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#removeKeyWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.addKeyWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>KeyWritten</code> event that occurs just before the {\@link yfiles.graphml.IXmlWriter#writeEndElement}
 * for the GraphML 'key' element will be called.
 * <p>
 * This can be used to append more custom elements to the key element.
 * </p>
 * @see yfiles.graphml.IWriteEvents#addKeyWrittenListener
 * @abstract
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.IWriteEvents.prototype.removeKeyWrittenListener = function(listener) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IWriteEvents;
/**
 * @record
 * @struct
 */
yfiles.graphml.IXmlWriter = function() {};
 /** @type {?} */
yfiles.graphml.IXmlWriter.prototype.namespaceManager;

/**
 * Close the document.
 * <p>
 * This is typically used to actually flush the document to an output stream
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.graphml.IXmlWriter.prototype.flushDocument = function() {};

/**
 * Gets a text representation of all content that has been written so far.
 * @abstract
 * @return {string}
 */
yfiles.graphml.IXmlWriter.prototype.getXmlString = function() {};

/**
 * Write an XML attribute with the given parameters.
 * <p>
 * The attribute is not bound to a XML namespace.
 * </p>
 * @param {string} localName The name of the attribute.
 * @param {string} value The value of the attribute.
 * @return {?} The writer instance <code>writer</code> for writer chaining.
 */
yfiles.graphml.IXmlWriter.prototype.writeAttribute = function(localName, value) {};

/**
 * Write a XML attribute node.
 * <p>
 * The attribute is attached to the closest open XML element that has been started with {\@link yfiles.graphml.IXmlWriter#writeStartElement}
 * or {\@link yfiles.graphml.IXmlWriter#writeStartElement}. Note that namespace declarations should not be written directly as
 * attributes. Instead the {\@link yfiles.graphml.IXmlWriter#namespaceManager} should be used.
 * </p>
 * @abstract
 * @param {string} prefix The namespace prefix of the attribute
 * @param {string} localName The local name of the attribute
 * @param {string} ns The namespace URI of this attribute
 * @param {string} value The value of this attribute
 * @return {?} The writer instance for further chaining
 */
yfiles.graphml.IXmlWriter.prototype.writeAttributeNS = function(prefix, localName, ns, value) {};

/**
 * Write a CDATA section.
 * @abstract
 * @param {string} content The content of the CDATA section
 * @return {?} The writer instance for further chaining
 */
yfiles.graphml.IXmlWriter.prototype.writeCData = function(content) {};

/**
 * Write a XML comment node
 * @abstract
 * @param {string} comment The content of the comment
 * @return {?} The writer instance for further chaining
 */
yfiles.graphml.IXmlWriter.prototype.writeComment = function(comment) {};

/**
 * Write a document fragment
 * @abstract
 * @param {!Document} fragment
 * @return {?} The writer instance for further chaining
 */
yfiles.graphml.IXmlWriter.prototype.writeDocumentFragment = function(fragment) {};

/**
 * Close the output.
 * <p>
 * Attempts to write after this method has been called will have undefined results.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.graphml.IXmlWriter.prototype.writeEndDocument = function() {};

/**
 * Close a XML element previously opened with {\@link yfiles.graphml.IXmlWriter#writeStartElement} or
 * {\@link yfiles.graphml.IXmlWriter#writeStartElement}.
 * @abstract
 * @return {?} The writer instance for further chaining
 */
yfiles.graphml.IXmlWriter.prototype.writeEndElement = function() {};

/**
 * Write an XML attribute from the given <code>attribute</code> struct.
 * @param {!yfiles.graphml.GraphMLXmlAttribute} attribute Encapsulates the current attribute values.
 * @return {?} The writer instance <code>writer</code> for writer chaining.
 */
yfiles.graphml.IXmlWriter.prototype.writeGraphMLXmlAttribute = function(attribute) {};

/**
 * Write a xml processing instruction.
 * @abstract
 * @param {string} target The target of the PI
 * @param {string} data The data of the PI
 * @return {?} The writer instance for further chaining
 */
yfiles.graphml.IXmlWriter.prototype.writeProcessingInstruction = function(target, data) {};

/**
 * Begin the output process
 * @abstract
 * @return {?} The writer instance for further chaining
 */
yfiles.graphml.IXmlWriter.prototype.writeStartDocument = function() {};

/**
 * Begin a new XML element with given parameters
 * <p>
 * All subsequent output is attached to this element until {\@link yfiles.graphml.IXmlWriter#writeEndElement} has been called or a
 * new element has been started.
 * </p>
 * @abstract
 * Begin a new XML element with given parameters
 * <p>
 * All subsequent output is attached to this element until {\@link yfiles.graphml.IXmlWriter#writeEndElement} has been called or a
 * new element has been started.
 * </p>
 * <p>
 * This acts like {\@link yfiles.graphml.IXmlWriter#writeStartElement}, but uses the default prefix for the namespace
 * </p>
 * @abstract
 * @param {string} prefix_or_localName The namespace prefix to use for this element / The local name of this element
 * @param {string} localName_or_ns The local name of this element / The namespace of this element
 * @param {string=} ns The namespace of this element
 * @return {?} The writer instance for further chaining
 */
yfiles.graphml.IXmlWriter.prototype.writeStartElement = function(prefix_or_localName, localName_or_ns, ns) {};

/**
 * Write a text node.
 * <p>
 * The string value of <code>s</code> will be correctly escaped
 * </p>
 * @abstract
 * @param {string} s The string that gets written as XML text
 * @return {?} The writer instance for further chaining
 */
yfiles.graphml.IXmlWriter.prototype.writeString = function(s) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IXmlWriter;
/**
 * @record
 * @struct
 */
yfiles.graphml.IXmlNamespaceManager = function() {};
 /** @type {?<string, string>} */
yfiles.graphml.IXmlNamespaceManager.prototype.globalNamespaces;

/**
 * Returns a unique namespace prefix, or creates and registeres one.
 * @abstract
 * @param {string} ns The namespace URI for which a prefix is searched.
 * @return {string} a unique namespace prefix for <code>ns</code>.
 */
yfiles.graphml.IXmlNamespaceManager.prototype.getOrCreateUniqueMapping = function(ns) {};

/**
 * Pops a current declaration scope.
 * @abstract
 * @return {void}
 */
yfiles.graphml.IXmlNamespaceManager.prototype.popScope = function() {};

/**
 * Pushes a current declaration scope.
 * @abstract
 * @return {void}
 */
yfiles.graphml.IXmlNamespaceManager.prototype.pushScope = function() {};

/**
 * Register a local namespace/prefix mapping
 * @abstract
 * @param {string} nsUri The namespace URI
 * @param {string} prefix The preferred namespace prefix or <code>null</code> if any prefix may be used.
 * @return {string} The prefix that finally has been used for the namespace URI.
 */
yfiles.graphml.IXmlNamespaceManager.prototype.registerLocalMapping = function(nsUri, prefix) {};

/**
 * Seals the current declaration scope.
 * <p>
 * No further namespace mappings may be added to a sealed scope.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.graphml.IXmlNamespaceManager.prototype.sealScope = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IXmlNamespaceManager;
/**
 * @record
 * @struct
 */
yfiles.graphml.SerializationProperties = function() {};
 /** @type {string} */
yfiles.graphml.SerializationProperties.DISABLE_USER_TAGS;
 /** @type {string} */
yfiles.graphml.SerializationProperties.DISABLE_STYLES;
 /** @type {string} */
yfiles.graphml.SerializationProperties.DISABLE_ITEMS;
 /** @type {string} */
yfiles.graphml.SerializationProperties.DISABLE_GEOMETRY;
 /** @type {string} */
yfiles.graphml.SerializationProperties.DISABLE_STRIPE_USER_TAGS;
 /** @type {string} */
yfiles.graphml.SerializationProperties.DISABLE_STRIPE_STYLES;
 /** @type {string} */
yfiles.graphml.SerializationProperties.DISABLE_STRIPE_LABELS;
 /** @type {string} */
yfiles.graphml.SerializationProperties.DISABLE_GRAPH_SETTINGS;
 /** @type {string} */
yfiles.graphml.SerializationProperties.IGNORE_PROPERTY_CASE;
 /** @type {string} */
yfiles.graphml.SerializationProperties.UNDEFINED_HANDLING;
 /** @type {string} */
yfiles.graphml.SerializationProperties.INDENT_OUTPUT;
 /** @type {string} */
yfiles.graphml.SerializationProperties.CURRENT_KEY_SCOPE;
 /** @type {string} */
yfiles.graphml.SerializationProperties.REPRESENTED_EDGE;
 /** @type {string} */
yfiles.graphml.SerializationProperties.WRITE_NODE_STYLE_DEFAULT;
 /** @type {string} */
yfiles.graphml.SerializationProperties.WRITE_EDGE_STYLE_DEFAULT;
 /** @type {string} */
yfiles.graphml.SerializationProperties.WRITE_PORT_STYLE_DEFAULT;
 /** @type {string} */
yfiles.graphml.SerializationProperties.WRITE_STRIPE_DEFAULTS;
 /** @type {string} */
yfiles.graphml.SerializationProperties.WRITE_LABEL_SIZE_PREDICATE;
 /** @type {string} */
yfiles.graphml.SerializationProperties.PARSE_LABEL_SIZE;
 /** @type {string} */
yfiles.graphml.SerializationProperties.BASE_URI;
 /** @type {string} */
yfiles.graphml.SerializationProperties.REWRITE_RELATIVE_RESOURCE_URIS;
 /** @type {string} */
yfiles.graphml.SerializationProperties.IGNORE_XAML_DESERIALIZATION_ERRORS;
 /** @type {string} */
yfiles.graphml.SerializationProperties.CACHE_EXTERNAL_REFERENCES;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.SerializationProperties.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.WriteEventArgs = function() {};
 /** @type {?} */
yfiles.graphml.WriteEventArgs.prototype.context;
 /** @type {!Object} */
yfiles.graphml.WriteEventArgs.prototype.item;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.WriteEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.IMarkupExtensionConverter = function() {};

/**
 * Returns if the converter can convert the <code>value</code> to a {\@link yfiles.graphml.MarkupExtension} in the current write context.
 * @abstract
 * @param {?} context The current write context.
 * @param {!Object} value The object to convert.
 * @return {boolean} Whether the converter can convert the passed value.
 */
yfiles.graphml.IMarkupExtensionConverter.prototype.canConvert = function(context, value) {};

/**
 * Converts the <code>value</code> to a {\@link yfiles.graphml.MarkupExtension} using the current write context.
 * @abstract
 * @param {?} context The current write context.
 * @param {!Object} value The object to convert.
 * @return {!yfiles.graphml.MarkupExtension} The {\@link } the value was converted to.
 */
yfiles.graphml.IMarkupExtensionConverter.prototype.convert = function(context, value) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IMarkupExtensionConverter;
/**
 * @record
 * @struct
 */
yfiles.graphml.IXamlNameMapper = function() {};

/**
 * Returns a {\@link yfiles.lang.Class} that matches the given <code>fqTagName</code> of an XML element.
 * <p>
 * <code>fqTagName</code> must follow the usual XAML naming rules.
 * </p>
 * @abstract
 * @param {?} context The current parse context.
 * @param {!yfiles.graphml.XmlName} fqTagName The fully qualified XML element name that must describe a valid type in this CLR namespace.
 * @return {!yfiles.lang.Class} The first matching type, if any.
 */
yfiles.graphml.IXamlNameMapper.prototype.getClassForName = function(context, fqTagName) {};

/**
 * Returns the XML tag name that belongs to type <code>type</code>
 * @abstract
 * @param {?} context The current write context.
 * @param {!yfiles.lang.Class} type The type for which an XML namespace mapping is searched.
 * @return {!yfiles.graphml.XmlName} the XML tag name that belongs to type <code>type</code>
 */
yfiles.graphml.IXamlNameMapper.prototype.getNameForClass = function(context, type) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IXamlNameMapper;
/**
 * @record
 * @struct
 */
yfiles.graphml.Property = function() {};
 /** @type {boolean} */
yfiles.graphml.Property.prototype.canRead;
 /** @type {boolean} */
yfiles.graphml.Property.prototype.canWrite;
 /** @type {boolean} */
yfiles.graphml.Property.prototype.isStatic;
 /** @type {yfiles.graphml.GraphMLMemberVisibility} */
yfiles.graphml.Property.prototype.serializationVisibility;
 /** @type {!yfiles.graphml.ValueSerializer} */
yfiles.graphml.Property.prototype.valueSerializer;
 /** @type {?} */
yfiles.graphml.Property.prototype.markupExtensionConverter;
 /** @type {!yfiles.graphml.GraphMLAttribute} */
yfiles.graphml.Property.prototype.graphMLAttribute;
 /** @type {boolean} */
yfiles.graphml.Property.prototype.isContentProperty;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.Property.prototype.type;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.Property.prototype.ownerType;
 /** @type {!Object} */
yfiles.graphml.Property.prototype.defaultValue;
 /** @type {boolean} */
yfiles.graphml.Property.prototype.hasDefaultValue;
 /** @type {string} */
yfiles.graphml.Property.prototype.name;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.Property.$class;

/**
 * Gets the value the wrapped property has on the given instance.
 * @param {!Object} ownerInstance The instance to get the property value from.
 * @return {!Object} The value the wrapped property has on the given instance.
 */
yfiles.graphml.Property.prototype.getValue = function(ownerInstance) {};

/**
 * Sets the value to the wrapped property on the given instance.
 * @param {!Object} ownerInstance The instance to set the property value on.
 * @param {!Object} value The value to set.
 * @return {void}
 */
yfiles.graphml.Property.prototype.setValue = function(ownerInstance, value) {};

/** @const */
yfiles.graphml.SliderParameterLocation = {};
/** @const {number} */
yfiles.graphml.SliderParameterLocation.LEFT;
/** @const {number} */
yfiles.graphml.SliderParameterLocation.RIGHT;
/** @const {number} */
yfiles.graphml.SliderParameterLocation.FROM_SOURCE;
/** @const {number} */
yfiles.graphml.SliderParameterLocation.FROM_TARGET;
/** @const {number} */
yfiles.graphml.SliderParameterLocation.CENTER;
/**
 * @record
 * @struct
 */
yfiles.graphml.IValueSerializerContext = function() {};

/**
 * Gets the value serializer for a specific {\@link yfiles.graphml.Property}.
 * @abstract
 * Gets the value serializer for a specific type.
 * @abstract
 * @param {!yfiles.graphml.Property|!yfiles.lang.Class} property_or_type The descriptor of the property. / The type to obtain a serializer for.
 * @return {!yfiles.graphml.ValueSerializer} A serializer or <code>null</code>.
 */
yfiles.graphml.IValueSerializerContext.prototype.getValueSerializerFor = function(property_or_type) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IValueSerializerContext;
/**
 * @record
 * @struct
 */
yfiles.graphml.MarkupExtension = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.MarkupExtension.$class;

/**
 * Returns an object that is set as the value of the target property for this markup extension.
 * @abstract
 * @param {?} serviceProvider Object that can provide services for the markup extension.
 * @return {!Object} The object value to set on the property where the extension is applied.
 */
yfiles.graphml.MarkupExtension.prototype.provideValue = function(serviceProvider) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.ValueSerializer = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.ValueSerializer.$class;

/**
 * Determines whether this instance can convert the specified value from the given string.
 * @param {string} value The string value to convert.
 * @param {?} context The context.
 * @return {boolean} <code>true</code> if this instance can convert the specified value from the string; otherwise, <code>false</code>.
 */
yfiles.graphml.ValueSerializer.prototype.canConvertFromString = function(value, context) {};

/**
 * Determines whether this instance can convert the specified value to a string.
 * @param {!Object} value The value.
 * @param {?} context The context.
 * @return {boolean} <code>true</code> if this instance can convert the specified value to a string; otherwise, <code>false</code>.
 */
yfiles.graphml.ValueSerializer.prototype.canConvertToString = function(value, context) {};

/**
 * Converts the string to an appropriate instance.
 * @param {string} value The value to convert to an object.
 * @param {?} context The context.
 * @return {!Object} The converted object
 */
yfiles.graphml.ValueSerializer.prototype.convertFromString = function(value, context) {};

/**
 * Converts the given value to string.
 * @param {!Object} o The value.
 * @param {?} context The context.
 * @return {string} The value as string representation.
 */
yfiles.graphml.ValueSerializer.prototype.convertToString = function(o, context) {};

/**
 * Gets the {\@link yfiles.graphml.ValueSerializer} implementation for the given type.
 * Gets the {\@link yfiles.graphml.ValueSerializer} implementation for the given descriptor.
 * Gets the {\@link yfiles.graphml.ValueSerializer} implementation for the given descriptor.
 * Gets the {\@link yfiles.graphml.ValueSerializer} implementation for the given type.
 * @param {!yfiles.lang.Class|!yfiles.graphml.Property} type_or_property The type. / The descriptor.
 * @param {?=} context The context.
 * @return {!yfiles.graphml.ValueSerializer} The serializer to use for the type. / The serializer to use for the descriptor.
 */
yfiles.graphml.ValueSerializer.getSerializerFor = function(type_or_property, context) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.Future = function() {};
 /** @type {T} */
yfiles.graphml.Future.prototype.value;
 /** @type {boolean} */
yfiles.graphml.Future.prototype.hasValue;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.Future.$class;

/**
 * Called when the {\@link yfiles.graphml.Future.<T>#value} property of this future has been determined.
 * <p>
 * This will set the {\@link yfiles.graphml.Future.<T>#hasValue} property to <code>true</code> and assign the {\@link yfiles.graphml.Future.<T>#value} property. Also the corresponding {\@link yfiles.graphml.Future.<T>#addPropertyChangedListener PropertyChanged} events
 * will be triggered if necessary.
 * </p>
 * @param {T} value The value.
 * @return {void}
 */
yfiles.graphml.Future.prototype.onValueDetermined = function(value) {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * <p>
 * This event will be triggered for {\@link yfiles.graphml.Future.<T>#hasValue} changes and changes of the {\@link yfiles.graphml.Future.<T>#value} property. Note that if the determined future value is the
 * same as the default, the event will only be triggered for the {\@link yfiles.graphml.Future.<T>#hasValue} property.
 * </p>
 * @see yfiles.graphml.Future.<T>#removePropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.Future.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * <p>
 * This event will be triggered for {\@link yfiles.graphml.Future.<T>#hasValue} changes and changes of the {\@link yfiles.graphml.Future.<T>#value} property. Note that if the determined future value is the
 * same as the default, the event will only be triggered for the {\@link yfiles.graphml.Future.<T>#hasValue} property.
 * </p>
 * @see yfiles.graphml.Future.<T>#addPropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.Future.prototype.removePropertyChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.GraphMLIOHandler = function() {};
 /** @type {boolean} */
yfiles.graphml.GraphMLIOHandler.prototype.writeXMLSchema;
 /** @type {boolean} */
yfiles.graphml.GraphMLIOHandler.prototype.writeSharedReferences;
 /** @type {boolean} */
yfiles.graphml.GraphMLIOHandler.prototype.clearGraphBeforeRead;
 /** @type {?<string, !Object>} */
yfiles.graphml.GraphMLIOHandler.prototype.serializationPropertyOverrides;
 /** @type {?<string, !Object>} */
yfiles.graphml.GraphMLIOHandler.prototype.deserializationPropertyOverrides;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLIOHandler.$class;

/**
 * Create a {\@link yfiles.graphml.Future.<T>} instance that wraps an {\@link yfiles.graphml.IInputHandler} that is dynamically created by <code>factory</code>.
 * <p>
 * The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with {\@link yfiles.graphml.Future.<T>#hasValue}.
 * The validity is determined by <code>keyDefinitionPredicate</code>. This methods creates and configures the necessary handler itself.
 * </p>
 * @param {function(!Element): boolean} keyDefinitionPredicate The predicate that matches the key definition.
 * @param {?} factory A factory to create {\@link } instances.
 * @return {!yfiles.graphml.Future<?>} A {\@link } instance that wraps an {\@link } that actually parses the data.
 */
yfiles.graphml.GraphMLIOHandler.prototype.addInputHandlerFactory = function(keyDefinitionPredicate, factory) {};

/**
 * Register a {\@link yfiles.collections.IMapper.<K,V>} instance for use as an input data target.
 * <p>
 * This method uses a custom event handler for the actual deserialization.
 * </p>
 * <p>
 * This methods creates and configures the necessary handler itself.
 * </p>
 * Type parameter <code>TKey</code>: The type of the mapper keys
 * Type parameter <code>TData</code>: The type of the mapper values
 * Register a {\@link yfiles.collections.IMapper.<K,V>} instance for use as an input data target.
 * <p>
 * This methods creates and configures the necessary handler itself.
 * </p>
 * Type parameter <code>TKey</code>: The type of the mapper keys
 * Type parameter <code>TData</code>: The type of the mapper values
 * @template TKey, TData
 * @param {!yfiles.lang.Class} keyType The type of the mapper keys
 * @param {!yfiles.lang.Class} dataType The type of the mapper values
 * @param {function(!Element): boolean|string} keyDefinitionPredicate_or_name The predicate function that will determine whether to create an {\@link } for the given key
 * definition. / The name of the attribute
 * @param {?<TKey, TData>} mapper the mapper that serves as data source
 * @param {function(!Object, !yfiles.graphml.HandleDeserializationEventArgs): void=} deserializationCallback custom deserialization callback.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addInputMapper = function(keyType, dataType, keyDefinitionPredicate_or_name, mapper, deserializationCallback) {};

/**
 * Create a {\@link yfiles.graphml.Future.<T>} instance that wraps an {\@link yfiles.collections.IMapper.<K,V>} for use as an input data target.
 * <p>
 * The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with {\@link yfiles.graphml.Future.<T>#hasValue}
 * This methods creates and configures the necessary handler itself.
 * </p>
 * Type parameter <code>TKey</code>: The type of the mapper keys
 * Type parameter <code>TData</code>: The type of the mapper values
 * Create a {\@link yfiles.graphml.Future.<T>} instance that wraps an {\@link yfiles.collections.IMapper.<K,V>} for use as an input data target.
 * <p>
 * The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with {\@link yfiles.graphml.Future.<T>#hasValue}
 * This methods creates and configures the necessary handler itself.
 * </p>
 * Type parameter <code>TKey</code>: The type of the mapper keys
 * Type parameter <code>TData</code>: The type of the mapper values
 * @template TKey, TData
 * @param {!yfiles.lang.Class} keyType The type of the mapper keys
 * @param {!yfiles.lang.Class} dataType The type of the mapper values
 * @param {function(!Element): boolean|string} keyDefinitionPredicate_or_name The predicate function that will determine whether to create an {\@link } for the given key
 * definition. / The name of the attribute
 * @param {function(!Object, !yfiles.graphml.HandleDeserializationEventArgs): void=} deserializationCallback custom deserialization callback.
 * @return {!yfiles.graphml.Future<?<TKey, TData>>} A {\@link } instance that wraps an {\@link } that actually holds the data.
 */
yfiles.graphml.GraphMLIOHandler.prototype.addInputMapperFuture = function(keyType, dataType, keyDefinitionPredicate_or_name, deserializationCallback) {};

/**
 * Adds a namespace to the header of a GraphML file.
 * @param {string} namespaceURI The namespace URI
 * @param {string} shortName The namespace prefix
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addNamespace = function(namespaceURI, shortName) {};

/**
 * Register a {\@link yfiles.collections.IMapper.<K,V>} instance for use as an output data source.
 * <p>
 * This method uses a custom event handler for the actual serialization.
 * </p>
 * <p>
 * This methods creates and configures the necessary handler itself.
 * </p>
 * Type parameter <code>TModelItem</code>: The type of the mapper keys
 * Type parameter <code>TValue</code>: The type of the mapper values
 * Register a {\@link yfiles.collections.IMapper.<K,V>} instance for use as an output data source
 * <p>
 * This methods creates and configures the necessary handler itself
 * </p>
 * Type parameter <code>TModelItem</code>: The type of the mapper keys
 * Type parameter <code>TValue</code>: The type of the mapper values
 * @template TModelItem, TValue
 * @param {!yfiles.lang.Class} modelItemType The type of the mapper keys
 * @param {!yfiles.lang.Class} dataType The type of the mapper values
 * @param {string} name The name of the attribute
 * @param {string|?<TModelItem, TValue>} uri_or_mapper The URI to add to the key definition to disambiguate keys. / the mapper that serves as data source
 * @param {?<TModelItem, TValue>=} mapper the mapper that serves as data source
 * @param {function(!Object, !yfiles.graphml.HandleSerializationEventArgs): void=} serializationCallback custom serialization callback.
 * @param {yfiles.graphml.KeyType=} declaredKeyType The key type to write in the declaration.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addOutputMapper = function(modelItemType, dataType, name, uri_or_mapper, mapper, serializationCallback, declaredKeyType) {};

/**
 * Create a {\@link yfiles.graphml.Future.<T>} instance that wraps an {\@link yfiles.graphml.IInputHandler} that stores the data in an {\@link yfiles.collections.IMapper.<K,V>} that will be {\@link yfiles.graphml.GraphMLIOHandler#createMapper created} in the
 * graph's {\@link yfiles.graph.IMapperRegistry}.
 * <p>
 * The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with {\@link yfiles.graphml.Future.<T>#hasValue}.
 * This methods creates and configures the necessary handler itself and {\@link yfiles.graphml.GraphMLIOHandler#createMapper creates} an {\@link yfiles.collections.IMapper.<K,V>} in the {\@link yfiles.graph.IMapperRegistry}
 * with name <code>tag</code>.
 * </p>
 * Type parameter <code>TKey</code>.
 * Type parameter <code>TData</code>.
 * Create a {\@link yfiles.graphml.Future.<T>} instance that wraps an {\@link yfiles.graphml.IInputHandler} that stores the data in an {\@link yfiles.collections.IMapper.<K,V>} that will be {\@link yfiles.graphml.GraphMLIOHandler#createMapper created} in the
 * graph's {\@link yfiles.graph.IMapperRegistry}.
 * <p>
 * The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with {\@link yfiles.graphml.Future.<T>#hasValue}.
 * The attribute must be registered under the attribute name <code>name</code>. This methods creates and configures the necessary
 * handler itself and {\@link yfiles.graphml.GraphMLIOHandler#createMapper creates} an {\@link yfiles.collections.IMapper.<K,V>} in the {\@link yfiles.graph.IMapperRegistry} with name <code>name</code>.
 * </p>
 * Type parameter <code>TKey</code>.
 * Type parameter <code>TData</code>.
 * @template TKey, TData
 * @param {!yfiles.lang.Class} keyType
 * @param {!yfiles.lang.Class} dataType
 * @param {!Object|string} tag_or_name The name of the key in the {\@link }. / The name of the GraphML attribute and the key in the {\@link }.
 * @param {function(!Element): boolean=} keyDefinitionPredicate A predicate to determine whether the key definition is valid.
 * @param {function(!Object, !yfiles.graphml.HandleDeserializationEventArgs): void=} deserializationCallback The custom deserialization callback, can be <code>null</code> which will result in default deserialization.
 * @return {!yfiles.graphml.Future<?<TKey, TData>>} A {\@link } instance that wraps an {\@link } that actually holds the data.
 */
yfiles.graphml.GraphMLIOHandler.prototype.addRegistryInputMapper = function(keyType, dataType, tag_or_name, keyDefinitionPredicate, deserializationCallback) {};

/**
 * Use a registered {\@link yfiles.collections.IMapper.<K,V>} instance as source for the given GraphML attribute.
 * Type parameter <code>TModelItem</code>.
 * Type parameter <code>TValue</code>.
 * Use a registered {\@link yfiles.collections.IMapper.<K,V>} instance as source for the given GraphML attribute.
 * Type parameter <code>TModelItem</code>.
 * Type parameter <code>TValue</code>.
 * Use a registered {\@link yfiles.collections.IMapper.<K,V>} instance as source for the given GraphML attribute.
 * <p>
 * The type arguments of the mapper are determined automatically.
 * </p>
 * Use a registered {\@link yfiles.collections.IMapper.<K,V>} instance as source for the given GraphML attribute.
 * <p>
 * The type arguments of the mapper are determined automatically.
 * </p>
 * @template TModelItem, TValue
 * @param {!yfiles.lang.Class|string} modelItemType_or_name The GraphML name of the attribute
 * @param {!yfiles.lang.Class|string|!Object} valueType_or_uri_or_tag The optional URI of the attribute / The tag name of the mapper in the {\@link }
 * @param {string|!Object=} name_or_tag The GraphML name of the attribute / The tag name of the mapper in the {\@link }
 * @param {string|!Object|function(!Object, !yfiles.graphml.HandleSerializationEventArgs): void=} uri_or_tag_or_serializationCallback The URI to add to the key definition to disambiguate keys. / The tag name of the mapper in the {\@link } / An optional serialization handler
 * @param {!Object=} tag The tag name of the mapper in the {\@link }
 * @param {function(!Object, !yfiles.graphml.HandleSerializationEventArgs): void=} serializationCallback custom serialization callback.
 * @param {yfiles.graphml.KeyType=} declaredKeyType The key type to write in the declaration.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addRegistryOutputMapper = function(modelItemType_or_name, valueType_or_uri_or_tag, name_or_tag, uri_or_tag_or_serializationCallback, tag, serializationCallback, declaredKeyType) {};

/**
 * Adds a schema location to the header of a GraphML file.
 * @param {string} schemaNamespace The namespace URI for this schema location
 * @param {string} schemaLocation The schema location
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addSchemaLocation = function(schemaNamespace, schemaLocation) {};

/**
 * Add a namespace mapping between a fully qualified XML name (consisting of <code>xmlNamespace</code> and <code>tagName</code> and a type.
 * <p>
 * Either of <code>xmlNamespace</code> or <code>tagName</code> may be <code>null</code>, meaning that the default rules for determining the namespace and/or tag
 * name of <code>type</code> are used.
 * </p>
 * <p>
 * This is used both for writing and parsing objects.
 * </p>
 * @see yfiles.graphml.IXamlNameMapper
 * @see yfiles.graphml.GraphMLIOHandler#createXamlNameMapper
 * @see yfiles.graphml.GraphMLIOHandler#addXamlNamespaceMapping
 * Add a namespace mapping between an XML namespace and a JavaScript <code>module</code>.
 * <p>
 * This is used both for writing and parsing objects.
 * </p>
 * @see yfiles.graphml.IXamlNameMapper
 * @see yfiles.graphml.GraphMLIOHandler#createXamlNameMapper
 * @see yfiles.graphml.GraphMLIOHandler#addXamlNamespaceMapping
 * @param {string} xmlNamespace The XML namespace that corresponds to <code>type</code>. If <code>null</code>, the namespace will be determined based on the JavaScript module
 * that contains <code>type</code> / The XML namespace that corresponds to <code>module</code>.
 * @param {string|!Object} tagName_or_module The XML tag name that corresponds to <code>type</code>. If <code>null</code>, the name will be determined from the type name automatically. / The module that is mapped to the namespace.
 * @param {!yfiles.lang.Class=} type The type that is mapped to the fully qualified XML name.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addXamlNamespaceMapping = function(xmlNamespace, tagName_or_module, type) {};

/**
 * Configure the predefined handlers for the {\@link yfiles.graphml.GraphMLParser#addHandleDeserializationListener HandleDeserialization}
 * event.
 * <p>
 * Except for text content and primitive types, this implementation delegates all work to
 * {\@link yfiles.graphml.GraphMLIOHandler#handleXamlDeserialization}
 * </p>
 * <p>
 * This method is called for each parse process.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#handlePrimitivesDeserialization
 * @see yfiles.graphml.GraphMLIOHandler#handleXamlDeserialization
 * @see yfiles.graphml.GraphMLIOHandler#handleTextNodeDeserialization
 * @protected
 * @param {?} graph The graph that will be parsed.
 * @param {!yfiles.graphml.GraphMLParser} parser The parser to configure.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureDeserializationHandlers = function(graph, parser) {};

/**
 * Configures the {\@link yfiles.graphml.GraphMLIOHandler#deserializationPropertyOverrides deserialization property overrides} for the given parser.
 * <p>
 * This method is called for each parse process.
 * </p>
 * @protected
 * @param {!yfiles.graphml.GraphMLParser} parser The parser to set the deserialization properties.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureDeserializationPropertyOverrides = function(parser) {};

/**
 * Configures a given instance of {\@link yfiles.graphml.GraphMLParser} that can handle the given graph.
 * <p>
 * This method is called by {\@link yfiles.graphml.GraphMLIOHandler#createGraphMLParser}.
 * </p>
 * @protected
 * @param {!yfiles.graphml.GraphMLParser} parser The parser to configure
 * @param {?} graph The graph that should be filled by the parser
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureGraphMLParser = function(parser, graph) {};

/**
 * Configures a given {\@link yfiles.graphml.GraphMLWriter} that is used for writing <code>graph</code>.
 * <p>
 * This method is called by {\@link yfiles.graphml.GraphMLIOHandler#createGraphMLWriter}.
 * </p>
 * @protected
 * @param {!yfiles.graphml.GraphMLWriter} writer The writer to configure
 * @param {?} graph The graph that will be written.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureGraphMLWriter = function(writer, graph) {};

/**
 * Configures default event handlers for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event.
 * <p>
 * This implementation configures several input handlers for the standard yFiles for HTML GraphML attributes (styles,
 * folding state, labels, geometry).
 * </p>
 * <p>
 * This method is called for each parse process.
 * </p>
 * @protected
 * @param {!yfiles.graphml.GraphMLParser} parser The parser that should be configured.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureInputHandlers = function(parser) {};

/**
 * Configures <code>writer</code> to use the namespace declarations set with {\@link yfiles.graphml.GraphMLIOHandler#addNamespace}.
 * <p>
 * In addition to the namespace declarations provided with {\@link yfiles.graphml.GraphMLIOHandler#addNamespace}, the default {\@link yfiles.graphml.GraphMLWriter}
 * implementation also automatically places all namespace declarations that have occurred
 * </p>
 * <p>
 * This method is called for each write process.
 * </p>
 * @protected
 * @param {!yfiles.graphml.GraphMLWriter} writer The writer to configure.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureNamespaces = function(writer) {};

/**
 * Configures default event handlers for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event.
 * <p>
 * This implementation configures several output handlers for the standard yFiles GraphML attributes (styles, folding
 * state, labels, geometry).
 * </p>
 * <p>
 * This method is called for each write process.
 * </p>
 * @protected
 * @param {?} graph The graph that will be written.
 * @param {!yfiles.graphml.GraphMLWriter} writer The writer that should be configured.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureOutputHandlers = function(graph, writer) {};

/**
 * Configures the lookup of the given parser.
 * <p>
 * This method is called for each parse process.
 * </p>
 * @protected
 * @param {!yfiles.graphml.GraphMLParser} parser The parser to configure.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureParserLookup = function(parser) {};

/**
 * Configures <code>writer</code> to use the schema locations set with {\@link yfiles.graphml.GraphMLIOHandler#addSchemaLocation}.
 * <p>
 * This method is called for each write process.
 * </p>
 * @protected
 * @param {!yfiles.graphml.GraphMLWriter} writer The writer to configure.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureSchemaLocations = function(writer) {};

/**
 * Configures the predefined handlers for the {\@link yfiles.graphml.GraphMLWriter#addHandleSerializationListener HandleSerialization}
 * event.
 * <p>
 * This method is called for each write process.
 * </p>
 * @protected
 * @param {?} graph The graph that will be written.
 * @param {!yfiles.graphml.GraphMLWriter} writer The writer to configure.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureSerializationHandlers = function(graph, writer) {};

/**
 * Configure important serialization properties from properties of {\@link yfiles.graphml.GraphMLIOHandler}.
 * <p>
 * This method is called for each write process.
 * </p>
 * @see yfiles.graphml.GraphMLWriter#setSerializationProperty
 * @protected
 * @param {?} graph The graph to write.
 * @param {!yfiles.graphml.GraphMLWriter} writer The writer to configure.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureSerializationProperties = function(graph, writer) {};

/**
 * Configures the {\@link yfiles.graphml.GraphMLIOHandler#serializationPropertyOverrides serialization property overrides} for the given writer.
 * <p>
 * This method is called for each write process.
 * </p>
 * @protected
 * @param {!yfiles.graphml.GraphMLWriter} writer The writer to set the serialization properties.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureSerializationPropertyOverrides = function(writer) {};

/**
 * Configure the lookup map of <code>writer</code>.
 * <p>
 * This method is called for each write process.
 * </p>
 * @see yfiles.graphml.GraphMLWriter#setLookup
 * @protected
 * @param {?} graph The graph that will be written.
 * @param {!yfiles.graphml.GraphMLWriter} writer The writer to configure.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureWriterLookup = function(graph, writer) {};

/**
 * Configure <code>writer</code>.
 * <p>
 * This method is called for each write process.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @param {?} writer The writer to configure.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.configureXMLWriter = function(writer) {};

/**
 * Creates the default value serializer context and returns it.
 * <p>
 * This factory method can be used to provide custom {\@link yfiles.graphml.ValueSerializer}s in cases where no {\@link yfiles.graphml.GraphMLAttribute#valueSerializer} can be used.
 * </p>
 * @return {?} An implementation of the {\@link } interface.
 */
yfiles.graphml.GraphMLIOHandler.prototype.createDefaultValueSerializerContext = function() {};

/**
 * Create an {\@link yfiles.graphml.IGraphElementFactory} instance that creates the graph elements for the <code>graph</code> instance.
 * <p>
 * This method is called for each parse process.
 * </p>
 * @protected
 * @param {!yfiles.graphml.GraphMLParser} parser The parser to use.
 * @param {?} graph The graph that is populated.
 * @return {?} An {\@link } instance that is configured for the given parameters.
 */
yfiles.graphml.GraphMLIOHandler.prototype.createGraphElementFactory = function(parser, graph) {};

/**
 * Create a suitable instance of {\@link yfiles.graphml.GraphMLParser} that can handle the given graph.
 * <p>
 * This method is called for each parse process.
 * </p>
 * <p>
 * It delegates the configuration of the parser to {\@link yfiles.graphml.GraphMLIOHandler#configureGraphMLParser}.
 * </p>
 * @protected
 * @param {?} graph The graph that should be filled by this instance
 * @return {!yfiles.graphml.GraphMLParser} a suitable instance of {\@link } that can handle the given graph
 */
yfiles.graphml.GraphMLIOHandler.prototype.createGraphMLParser = function(graph) {};

/**
 * Create and configure a new {\@link yfiles.graphml.GraphMLWriter} that is used for writing <code>graph</code>.
 * <p>
 * This method is called for each write process. It delegates the configuration of the writer to
 * {\@link yfiles.graphml.GraphMLIOHandler#configureGraphMLWriter}.
 * </p>
 * @protected
 * @param {?} graph The graph that will be written.
 * @return {!yfiles.graphml.GraphMLWriter} A new {\@link } instance that is configured for <code>graph</code>.
 */
yfiles.graphml.GraphMLIOHandler.prototype.createGraphMLWriter = function(graph) {};

/**
 * Callback used by {\@link yfiles.graphml.GraphMLIOHandler#addRegistryInputMapper} and its overloads to creates the mapper
 * instance.
 * <p>
 * This method creates the mapper instance, unless there is an existing mapper in the target graph with a matching type. In
 * this case the existing mapper is returned. In all other cases a new mapper will be created and returned. If a mapper is
 * already registered with the same <code>registryTag</code> but wrong types, it will be replaced.
 * </p>
 * Type parameter <code>TKey</code>: The type of the keys.
 * Type parameter <code>TData</code>: The type of the data.
 * @protected
 * @template TKey, TData
 * @param {!yfiles.lang.Class} keyType The type of the keys.
 * @param {!yfiles.lang.Class} dataType The type of the data.
 * @param {?} context
 * @param {!Object} registryTag The tag for the mapper in the registry.
 * @return {?<TKey, TData>} The mapper instance to use.
 */
yfiles.graphml.GraphMLIOHandler.prototype.createMapper = function(keyType, dataType, context, registryTag) {};

/**
 * Convenience factory method that can create an instance of several predefined {\@link yfiles.graphml.IInputHandler}
 * implementations that match the provided <code>TKey</code> and <code>TData</code>.
 * Type parameter <code>TKey</code>: The type of the mapper keys
 * Type parameter <code>TData</code>: The type of the mapper entries
 * @template TKey, TData
 * @param {!yfiles.lang.Class} modelItemType The type of the mapper keys
 * @param {!yfiles.lang.Class} dataType The type of the mapper entries
 * @param {?<TKey, TData>} mapper The mapper to use.
 * @param {function(!Object, !yfiles.graphml.HandleDeserializationEventArgs): void} deserializationCallback Optional deserialization callback for complex data.
 * @return {!yfiles.graphml.MapperInputHandler<TKey, TData>} A suitable {\@link } implementation
 */
yfiles.graphml.GraphMLIOHandler.createMapperInputHandler = function(modelItemType, dataType, mapper, deserializationCallback) {};

/**
 * Convenience factory method that can create an instance of several predefined {\@link yfiles.graphml.IOutputHandler}
 * implementations that match the provided <code>TKey</code> and <code>TData</code>.
 * Type parameter <code>TKey</code>: The type of the mapper keys
 * Type parameter <code>TData</code>: The type of the mapper entries
 * @template TKey, TData
 * @param {!yfiles.lang.Class} modelItemType The type of the mapper keys
 * @param {!yfiles.lang.Class} dataType The type of the mapper entries
 * @param {string} name The name of the graphml attribute
 * @param {?<TKey, TData>} mapper The mapper to use.
 * @param {function(!Object, !yfiles.graphml.HandleSerializationEventArgs): void} serializationCallback Optional serialization callback for complex data.
 * @return {!yfiles.graphml.MapperOutputHandler<TKey, TData>} A suitable {\@link } implementation
 */
yfiles.graphml.GraphMLIOHandler.createMapperOutputHandler = function(modelItemType, dataType, name, mapper, serializationCallback) {};

/**
 * Configure mappings from CLR to XML names.
 * <p>
 * This implementation scans all loaded assemblies for XmlnsDefinitionAttributes and returns a suitable instance of
 * {\@link yfiles.graphml.IXamlNameMapper}.
 * </p>
 * <p>
 * This method is called for each read or write process.
 * </p>
 * @protected
 * @return {?}
 */
yfiles.graphml.GraphMLIOHandler.prototype.createXamlNameMapper = function() {};

/**
 * Configure mappings from XML namespaces to prefixes.
 * <p>
 * This method is called for each write process.
 * </p>
 * @protected
 * @return {?}
 */
yfiles.graphml.GraphMLIOHandler.prototype.createXamlPrefixMapper = function() {};

/**
 * Factory method that creates and configures a suitable {\@link yfiles.graphml.IXmlWriter} implementation.
 * <p>
 * This method is called for each write process. The {\@link yfiles.graphml.IXmlWriter} implementation is used by default for all
 * low-level write operations.
 * </p>
 * @see yfiles.graphml.IWriteContext#writer
 * @protected
 * @return {?} A suitable {\@link } instance for the serialization
 */
yfiles.graphml.GraphMLIOHandler.prototype.createXMLWriter = function() {};

/**
 * Handle the serialization of arrays.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} is an array. This handler is registered by default.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleArraySerialization = function(sender, evt) {};

/**
 * Handle the serialization for enums.
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleEnumSerialization = function(sender, evt) {};

/**
 * Handle the serialization of types that extend FrameworkTemplate.
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleDeserializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleJSONDeserialization = function(sender, evt) {};

/**
 * Handle the serialization of plain JavaScript object that can be serialized to JSON.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} can be converted to JSON data. This serializer is only called from element property syntax and
 * is registered by default.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleJSONSerialization = function(sender, evt) {};

/**
 * Handle the serialization of {\@link yfiles.collections.IEnumerable.<T>} instances.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} is an IEnumerable instance. This handler is registered by default.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleListSerialization = function(sender, evt) {};

/**
 * Handle the serialization of {\@link yfiles.graphml.MarkupExtension} convertible instances.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} can be converted to a {\@link yfiles.graphml.MarkupExtension} instance. This handler is registered by
 * default.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleMarkupExtensionBasedSerialization = function(sender, evt) {};

/**
 * Handle the serialization of <code>null</code> references.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} is a <code>null</code> reference. This handler is registered by default and is only used to write <code>null</code>
 * references in XML element syntax.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleNullSerialization = function(sender, evt) {};

/**
 * Handle the serialization of primitive types, enums and strings.
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleDeserializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handlePrimitivesDeserialization = function(sender, evt) {};

/**
 * Handle the serialization of primitive types, enums and strings.
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handlePrimitivesSerialization = function(sender, evt) {};

/**
 * Handle the serialization of {\@link yfiles.graphml.IReferenceHandle} instances.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} is a {\@link yfiles.graphml.IReferenceHandle} instance. This handler is registered by default and should
 * not be removed if {\@link yfiles.graphml.GraphMLIOHandler#writeSharedReferences} is enabled.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleReferenceHandleSerialization = function(sender, evt) {};

/**
 * Handle the serialization of instances that can be serialized through a {\@link yfiles.graphml.ValueSerializer}.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} can be converted to a string with a
 * {\@link yfiles.graphml.ValueSerializer}. This serializer is only called from element property syntax and is registered by
 * default.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleTextConvertibleSerialization = function(sender, evt) {};

/**
 * Callback for the {\@link yfiles.graphml.GraphMLParser#addHandleDeserializationListener HandleDeserialization} event.
 * @see yfiles.graphml.HandleDeserializationEventArgs
 * @protected
 * @param {!Object} source The source of the event.
 * @param {!yfiles.graphml.HandleDeserializationEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleTextNodeDeserialization = function(source, evt) {};

/**
 * Handle the serialization of TypeExtensions.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} is an array. This handler is registered by default.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleTypeExtensionSerialization = function(sender, evt) {};

/**
 * Handle the serialization of Types.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} is an array. This handler is registered by default.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleTypeSerialization = function(sender, evt) {};

/**
 * Handle the serialization of <code>undefined</code> references.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} is an <code>undefined</code> reference. This handler is registered by default and is only used to write <code>undefined</code>
 * references in XML element syntax.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleUndefinedSerialization = function(sender, evt) {};

/**
 * Callback for the {\@link yfiles.graphml.GraphMLParser#addHandleDeserializationListener HandleDeserialization} event.
 * @see yfiles.graphml.HandleDeserializationEventArgs
 * @protected
 * @param {!Object} source The source of the event.
 * @param {!yfiles.graphml.HandleDeserializationEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleXamlDeserialization = function(source, evt) {};

/**
 * Handle the serialization of complex objects that are not handled by other callbacks.
 * <p>
 * This sets {\@link yfiles.graphml.HandleSerializationEventArgs#handled} to <code>true</code> iff {\@link yfiles.graphml.HandleSerializationEventArgs#item} is not a <code>null</code> reference. This handler is registered by default and uses {\@link yfiles.graphml.XamlSerializer}
 * to create XAML output.
 * </p>
 * @protected
 * @param {!Object} sender The origin of the event.
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The event handler arguments.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.handleXamlSerialization = function(sender, evt) {};

/**
 * Checks whether the <code>name</code> attribute in <code>definition</code> matches <code>name</code>
 * @param {!Element} definition The key definition to check
 * @param {string} name The name that should be matched
 * @return {boolean} <code>true</code> if the name attribute in <code>definition</code> matches <code>name</code>
 */
yfiles.graphml.GraphMLIOHandler.matchesName = function(definition, name) {};

/**
 * Checks whether the <code>scope</code> attribute in <code>definition</code> matches <code>scope</code>
 * @param {!Element} definition The key definition to check
 * @param {yfiles.graphml.KeyScope} scope The scope that should be matched
 * @return {boolean} <code>true</code> if the scope attribute in <code>definition</code> matches <code>scope</code>
 */
yfiles.graphml.GraphMLIOHandler.matchesScope = function(definition, scope) {};

/**
 * Checks whether the <code>type</code> attribute in <code>definition</code> matches <code>type</code>
 * @param {!Element} definition The key definition to check
 * @param {yfiles.graphml.KeyType} type The type that should be matched
 * @return {boolean} <code>true</code> if the type attribute in <code>definition</code> matches <code>type</code>
 */
yfiles.graphml.GraphMLIOHandler.matchesType = function(definition, type) {};

/**
 * Checks whether the <code>uri</code> attribute in <code>definition</code> matches <code>uri</code>
 * @param {!Element} definition The key definition to check
 * @param {string} uri The uri that should be matched
 * @return {boolean} <code>true</code> if the uri attribute in <code>definition</code> matches <code>uri</code>
 */
yfiles.graphml.GraphMLIOHandler.matchesUri = function(definition, uri) {};

/**
 * Event handler for the {\@link yfiles.graphml.GraphMLParser#addHandleDeserializationListener HandleDeserialization} event.
 * <p>
 * This event handler is used to propagate the {\@link yfiles.graphml.GraphMLParser#addHandleDeserializationListener HandleDeserialization}
 * event to subscribers of
 * {\@link yfiles.graphml.GraphMLIOHandler#addHandleDeserializationListener HandleDeserialization}. This implementation
 * just calls {\@link yfiles.graphml.GraphMLIOHandler#onHandleDeserialization}, which in turn raises the {\@link yfiles.graphml.GraphMLIOHandler#addHandleDeserializationListener HandleDeserialization}
 * event.
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.HandleDeserializationEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onGraphMLParserHandleDeserialization = function(sender, evt) {};

/**
 * Event handler for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers} event.
 * <p>
 * This event handler is used to propagate the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event to subscribers of {\@link yfiles.graphml.GraphMLIOHandler#addQueryInputHandlersListener QueryInputHandlers}.
 * This implementation just calls {\@link yfiles.graphml.GraphMLIOHandler#onQueryInputHandlers}, which in turn raises the {\@link yfiles.graphml.GraphMLIOHandler#addQueryInputHandlersListener QueryInputHandlers}
 * event.
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onGraphMLParserQueryInputHandlers = function(sender, evt) {};

/**
 * Event handler for the {\@link yfiles.graphml.GraphMLWriter#addHandleSerializationListener HandleSerialization} event.
 * <p>
 * This event handler is used to propagate the {\@link yfiles.graphml.GraphMLWriter#addHandleSerializationListener HandleSerialization}
 * event to subscribers of {\@link yfiles.graphml.GraphMLIOHandler#addHandleSerializationListener HandleSerialization}.
 * This implementation just calls {\@link yfiles.graphml.GraphMLIOHandler#onHandleSerialization}, which in turn raises the {\@link yfiles.graphml.GraphMLIOHandler#addHandleSerializationListener HandleSerialization}
 * event.
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onGraphMLWriterHandleSerialization = function(sender, evt) {};

/**
 * Event handler for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers} event.
 * <p>
 * This event handler is used to propagate the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event to subscribers of {\@link yfiles.graphml.GraphMLIOHandler#addQueryOutputHandlersListener QueryOutputHandlers}.
 * This implementation just calls {\@link yfiles.graphml.GraphMLIOHandler#onQueryOutputHandlers}, which in turn raises the {\@link yfiles.graphml.GraphMLIOHandler#addQueryOutputHandlersListener QueryOutputHandlers}
 * event.
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onGraphMLWriterQueryOutputHandlers = function(sender, evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLIOHandler#addHandleDeserializationListener HandleDeserialization} event.
 * @protected
 * @param {!yfiles.graphml.HandleDeserializationEventArgs} evt The arguments for the {\@link #addHandleDeserializationListener HandleDeserialization}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onHandleDeserialization = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLIOHandler#addHandleSerializationListener HandleSerialization} event.
 * @protected
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The arguments for the {\@link #addHandleSerializationListener HandleSerialization}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onHandleSerialization = function(evt) {};

/**
 * Fires the {\@link yfiles.graphml.GraphMLIOHandler#addOverrideResolveReferenceListener OverrideResolveReference} event.
 * @protected
 * @param {!yfiles.graphml.ResolveReferenceEventArgs} evt The arguments that get passed to the {\@link #addOverrideResolveReferenceListener OverrideResolveReference}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onOverrideResolveReference = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLIOHandler#addParsedListener Parsed} event.
 * <p>
 * This method is called when the document has been parsed and after {\@link yfiles.graphml.IParseEvents#addDocumentParsedListener DocumentParsed}
 * is called.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addParsedListener
 * @protected
 * @param {!yfiles.graphml.ParseEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onParsed = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLIOHandler#addParsingListener Parsing} event.
 * <p>
 * This method is called just before the parsing starts and before {\@link yfiles.graphml.IParseEvents#addDocumentParsingListener DocumentParsing}
 * is called.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addParsingListener
 * @protected
 * @param {!yfiles.graphml.ParseEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onParsing = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLIOHandler#addQueryInputHandlersListener QueryInputHandlers} event.
 * @protected
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt The arguments for the {\@link #addQueryInputHandlersListener QueryInputHandlers}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onQueryInputHandlers = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLIOHandler#addQueryOutputHandlersListener QueryOutputHandlers} event.
 * @protected
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt The arguments for the {\@link #addQueryOutputHandlersListener QueryOutputHandlers}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onQueryOutputHandlers = function(evt) {};

/**
 * Fires the {\@link yfiles.graphml.GraphMLIOHandler#addQueryReferenceIdListener QueryReferenceId} event.
 * @throws {Stubs.Exceptions.ArgumentError} <code>args</code> is null.
 * @see yfiles.graphml.GraphMLWriter#onQueryReferenceId
 * @protected
 * @param {!yfiles.graphml.QueryReferenceIdEventArgs} evt The arguments that get passed to the {\@link #addQueryReferenceIdListener QueryReferenceId}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onQueryReferenceId = function(evt) {};

/**
 * Fires the {\@link yfiles.graphml.GraphMLIOHandler#addResolveReferenceListener ResolveReference} event.
 * @protected
 * @param {!yfiles.graphml.ResolveReferenceEventArgs} evt The arguments that get passed to the {\@link #addResolveReferenceListener ResolveReference}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onResolveReference = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLIOHandler#addWritingListener Writing} event.
 * <p>
 * This method is called just before the writing starts and before {\@link yfiles.graphml.IWriteEvents#addDocumentWritingListener DocumentWriting}
 * is called.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addWritingListener
 * @protected
 * @param {!yfiles.graphml.WriteEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onWriting = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLIOHandler#addWrittenListener Written} event.
 * <p>
 * This method is called just after the writing finishes and after {\@link yfiles.graphml.IWriteEvents#addDocumentWrittenListener DocumentWritten}
 * is called.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addWrittenListener
 * @protected
 * @param {!yfiles.graphml.WriteEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.onWritten = function(evt) {};

/**
 * Read GraphML from an existing XML document.
 * @throws {Stubs.Exceptions.ArgumentError} <code>document</code> is null.
 * @throws {Stubs.Exceptions.ArgumentError} <code>graph</code> is null.
 * @param {?} graph The Graph object that is to be populated with nodes and edges as read from the document.
 * @param {!Document} document The XML document. <b>Note</b>: If you are using Internet Explorer 9 and {\@link }s to retrieve the document, you may not use
 * the value from the {\@link #responseXML} property. Please parse {\@link #responseText} instead and use the
 * result. For further reference see {\@link http://msdn.microsoft.com/en-us/library/ie/hh180177.aspx}.
 * @return {!Promise<?>}
 */
yfiles.graphml.GraphMLIOHandler.prototype.readFromDocument = function(graph, document) {};

/**
 * Convenience method that imports the <code>graph</code> from an XML data provided in a string <code>data</code>.
 * @param {?} graph The Graph object that is to be populated with nodes and edges as read from the GraphML data.
 * @param {string} data A string that contains GraphML data.
 * @return {!Promise<?>}
 */
yfiles.graphml.GraphMLIOHandler.prototype.readFromGraphMLText = function(graph, data) {};

/**
 * Reads a GraphML file from the given GraphML file and populates the Graph object.
 * <p>
 * Note that this is an asynchronous method that returns immediately. Use the returned Promise to get notified when the
 * actual parsing has completed.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>url</code> is null.
 * @throws {Stubs.Exceptions.ArgumentError} <code>graph</code> is null.
 * @param {?} graph The Graph object that is to be populated with nodes and edges as read from the GraphML file.
 * @param {string} url The url of the file to be read.
 * @return {!Promise<?>}
 */
yfiles.graphml.GraphMLIOHandler.prototype.readFromURL = function(graph, url) {};

/**
 * Predefined input handler that reads edge bends.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerEdgeBendsInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes edge bends.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerEdgeBendsOutputHandler = function(sender, evt) {};

/**
 * Predefined input handler that reads edge labels.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerEdgeLabelsInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes edge labels.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerEdgeLabelsOutputHandler = function(sender, evt) {};

/**
 * Predefined input handler that reads edge styles.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerEdgeStyleInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes edge styles.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerEdgeStyleOutputHandler = function(sender, evt) {};

/**
 * Predefined input handler that reads {\@link yfiles.graph.IGraph} graph default settings.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerGraphSettingsInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes the settings of a graph.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event.
 * </p>
 * @see yfiles.graphml.SerializationProperties#DISABLE_GRAPH_SETTINGS
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerGraphSettingsOutputHandler = function(sender, evt) {};

/**
 * Predefined input handler that reads node labels.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerNodeLabelsInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes node labels.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerNodeLabelsOutputHandler = function(sender, evt) {};

/**
 * Predefined input handler that reads node layouts.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerNodeLayoutInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes node layouts.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerNodeLayoutOutputHandler = function(sender, evt) {};

/**
 * Predefined input handler that reads node styles.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerNodeStyleInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes node styles.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerNodeStyleOutputHandler = function(sender, evt) {};

/**
 * Predefined input handler that reads port locations.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerPortLocationInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes port locations.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerPortLocationOutputHandler = function(sender, evt) {};

/**
 * Predefined input handler that reads port styles.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerPortStyleInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes port styles.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerPortStyleOutputHandler = function(sender, evt) {};

/**
 * Predefined input handler that reads {\@link yfiles.graph.ITagOwner} tags.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerTagInputHandler = function(sender, evt) {};

/**
 * Predefined output handler that writes {\@link yfiles.graph.ITagOwner} tags.
 * <p>
 * This handler is by default registered for the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.registerTagOutputHandler = function(sender, evt) {};

/**
 * Writes the given graph object to a GraphML file with a given filename.
 * @param {?} graph The Graph object that is to be written to a GraphML file.
 * @return {!Promise<string>} A string containing the GraphML data.
 */
yfiles.graphml.GraphMLIOHandler.prototype.write = function(graph) {};

/**
 * Adds the given listener for the <code>OverrideResolveReference</code> event that occurs before inline references are evaluated.
 * <p>
 * Subscribe to this event to customize resolving of GraphML object references. This event is fired before the framework
 * tries to resolve internal references and can therefore be used to override internal references, for example.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addResolveReferenceListener
 * @see yfiles.graphml.GraphMLIOHandler#removeOverrideResolveReferenceListener
 * @param {function(!Object, !yfiles.graphml.ResolveReferenceEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addOverrideResolveReferenceListener = function(listener) {};

/**
 * Removes the given listener for the <code>OverrideResolveReference</code> event that occurs before inline references are evaluated.
 * <p>
 * Subscribe to this event to customize resolving of GraphML object references. This event is fired before the framework
 * tries to resolve internal references and can therefore be used to override internal references, for example.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addResolveReferenceListener
 * @see yfiles.graphml.GraphMLIOHandler#addOverrideResolveReferenceListener
 * @param {function(!Object, !yfiles.graphml.ResolveReferenceEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeOverrideResolveReferenceListener = function(listener) {};

/**
 * Adds the given listener for the <code>ResolveReference</code> event that occurs after references are evaluated.
 * <p>
 * Subscribe to this event to customize resolving of GraphML object references. This event is fired when the framework
 * could not resolve an object reference by an internal one.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addOverrideResolveReferenceListener
 * @see yfiles.graphml.GraphMLIOHandler#removeResolveReferenceListener
 * @param {function(!Object, !yfiles.graphml.ResolveReferenceEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addResolveReferenceListener = function(listener) {};

/**
 * Removes the given listener for the <code>ResolveReference</code> event that occurs after references are evaluated.
 * <p>
 * Subscribe to this event to customize resolving of GraphML object references. This event is fired when the framework
 * could not resolve an object reference by an internal one.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addOverrideResolveReferenceListener
 * @see yfiles.graphml.GraphMLIOHandler#addResolveReferenceListener
 * @param {function(!Object, !yfiles.graphml.ResolveReferenceEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeResolveReferenceListener = function(listener) {};

/**
 * Adds the given listener for the <code>QueryReferenceId</code> event that occurs when a reference is queried.
 * <p>
 * This event can be used to provide names of external or internal references for objects.
 * </p>
 * <p>
 * The reference targets are not serialized to the GraphML file if they are set to
 * {\@link yfiles.graphml.GraphMLReferenceType#EXTERNAL}. To resolve these references when parsing, you typically have to subscribe
 * to the {\@link yfiles.graphml.GraphMLIOHandler#addResolveReferenceListener ResolveReference} event.
 * </p>
 * @see yfiles.graphml.QueryReferenceIdEventArgs#referenceId
 * @see yfiles.graphml.QueryReferenceIdEventArgs#referenceType
 * @see yfiles.graphml.GraphMLIOHandler#removeQueryReferenceIdListener
 * @param {function(!Object, !yfiles.graphml.QueryReferenceIdEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addQueryReferenceIdListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryReferenceId</code> event that occurs when a reference is queried.
 * <p>
 * This event can be used to provide names of external or internal references for objects.
 * </p>
 * <p>
 * The reference targets are not serialized to the GraphML file if they are set to
 * {\@link yfiles.graphml.GraphMLReferenceType#EXTERNAL}. To resolve these references when parsing, you typically have to subscribe
 * to the {\@link yfiles.graphml.GraphMLIOHandler#addResolveReferenceListener ResolveReference} event.
 * </p>
 * @see yfiles.graphml.QueryReferenceIdEventArgs#referenceId
 * @see yfiles.graphml.QueryReferenceIdEventArgs#referenceType
 * @see yfiles.graphml.GraphMLIOHandler#addQueryReferenceIdListener
 * @param {function(!Object, !yfiles.graphml.QueryReferenceIdEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeQueryReferenceIdListener = function(listener) {};

/**
 * Adds the given listener for the <code>Written</code> event that occurs when the writing of a document has been finished.
 * @see yfiles.graphml.GraphMLIOHandler#onWritten
 * @see yfiles.graphml.GraphMLWriter#addWrittenListener
 * @see yfiles.graphml.GraphMLIOHandler#removeWrittenListener
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>Written</code> event that occurs when the writing of a document has been finished.
 * @see yfiles.graphml.GraphMLIOHandler#onWritten
 * @see yfiles.graphml.GraphMLWriter#addWrittenListener
 * @see yfiles.graphml.GraphMLIOHandler#addWrittenListener
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeWrittenListener = function(listener) {};

/**
 * Adds the given listener for the <code>Writing</code> event that occurs when the writing of a document is just about to begin.
 * <p>
 * This event can be used to register to the fine-grained events available in the {\@link yfiles.graphml.WriteEventArgs#context}'s {\@link yfiles.graphml.IWriteContext#writeEvents} and to configure the writing process
 * on a per write case.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#onWriting
 * @see yfiles.graphml.GraphMLWriter#addWritingListener
 * @see yfiles.graphml.GraphMLIOHandler#removeWritingListener
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Writing</code> event that occurs when the writing of a document is just about to begin.
 * <p>
 * This event can be used to register to the fine-grained events available in the {\@link yfiles.graphml.WriteEventArgs#context}'s {\@link yfiles.graphml.IWriteContext#writeEvents} and to configure the writing process
 * on a per write case.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#onWriting
 * @see yfiles.graphml.GraphMLWriter#addWritingListener
 * @see yfiles.graphml.GraphMLIOHandler#addWritingListener
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeWritingListener = function(listener) {};

/**
 * Adds the given listener for the <code>QueryType</code> event that occurs when a type is queried.
 * <p>
 * This event can be used to override type resolution for XML names in XAML.
 * </p>
 * @see yfiles.graphml.QueryTypeEventArgs
 * @see yfiles.graphml.GraphMLIOHandler#removeQueryTypeListener
 * @param {function(!Object, !yfiles.graphml.QueryTypeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addQueryTypeListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryType</code> event that occurs when a type is queried.
 * <p>
 * This event can be used to override type resolution for XML names in XAML.
 * </p>
 * @see yfiles.graphml.QueryTypeEventArgs
 * @see yfiles.graphml.GraphMLIOHandler#addQueryTypeListener
 * @param {function(!Object, !yfiles.graphml.QueryTypeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeQueryTypeListener = function(listener) {};

/**
 * Adds the given listener for the <code>QueryName</code> event that occurs when a name is queried.
 * <p>
 * This event can be used to override name mappings to XML names in XAML.
 * </p>
 * <p>
 * If the event handler determines that it map resolve {\@link yfiles.graphml.QueryNameEventArgs#type} to a xml name, it should place the result into the {\@link yfiles.graphml.QueryNameEventArgs#result} property and
 * thus mark the event as {\@link yfiles.graphml.QueryNameEventArgs#handled}.
 * </p>
 * <p>
 * It is valid to provide only part of the XML name by setting the other part to null. In that case, the default name
 * determination rules are used for that part.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#removeQueryNameListener
 * @param {function(!Object, !yfiles.graphml.QueryNameEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addQueryNameListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryName</code> event that occurs when a name is queried.
 * <p>
 * This event can be used to override name mappings to XML names in XAML.
 * </p>
 * <p>
 * If the event handler determines that it map resolve {\@link yfiles.graphml.QueryNameEventArgs#type} to a xml name, it should place the result into the {\@link yfiles.graphml.QueryNameEventArgs#result} property and
 * thus mark the event as {\@link yfiles.graphml.QueryNameEventArgs#handled}.
 * </p>
 * <p>
 * It is valid to provide only part of the XML name by setting the other part to null. In that case, the default name
 * determination rules are used for that part.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addQueryNameListener
 * @param {function(!Object, !yfiles.graphml.QueryNameEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeQueryNameListener = function(listener) {};

/**
 * Adds the given listener for the <code>HandleSerialization</code> event that occurs when XML content is about to be serialized.
 * <p>
 * Subscribe to this event to provide custom serialization handling for XML content.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * The current item is provided by {\@link yfiles.graphml.HandleSerializationEventArgs#item}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#removeHandleSerializationListener
 * @param {function(!Object, !yfiles.graphml.HandleSerializationEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addHandleSerializationListener = function(listener) {};

/**
 * Removes the given listener for the <code>HandleSerialization</code> event that occurs when XML content is about to be serialized.
 * <p>
 * Subscribe to this event to provide custom serialization handling for XML content.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * The current item is provided by {\@link yfiles.graphml.HandleSerializationEventArgs#item}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addHandleSerializationListener
 * @param {function(!Object, !yfiles.graphml.HandleSerializationEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeHandleSerializationListener = function(listener) {};

/**
 * Adds the given listener for the <code>QueryOutputHandlers</code> event that occurs when a GraphML attribute is about to be written.
 * <p>
 * Subscribe to this event to dynamically register one or more {\@link yfiles.graphml.IOutputHandler} instance(s) for a given
 * GraphML attribute key definition.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * If you want to register an {\@link yfiles.graphml.IOutputHandler} for this GraphML attribute, you can add the handler with
 * {\@link yfiles.graphml.QueryOutputHandlersEventArgs#addOutputHandler}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#removeQueryOutputHandlersListener
 * @param {function(!Object, !yfiles.graphml.QueryOutputHandlersEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addQueryOutputHandlersListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryOutputHandlers</code> event that occurs when a GraphML attribute is about to be
 * written.
 * <p>
 * Subscribe to this event to dynamically register one or more {\@link yfiles.graphml.IOutputHandler} instance(s) for a given
 * GraphML attribute key definition.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * If you want to register an {\@link yfiles.graphml.IOutputHandler} for this GraphML attribute, you can add the handler with
 * {\@link yfiles.graphml.QueryOutputHandlersEventArgs#addOutputHandler}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addQueryOutputHandlersListener
 * @param {function(!Object, !yfiles.graphml.QueryOutputHandlersEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeQueryOutputHandlersListener = function(listener) {};

/**
 * Adds the given listener for the <code>Parsed</code> event that occurs when the the document has been parsed.
 * @see yfiles.graphml.GraphMLIOHandler#onParsed
 * @see yfiles.graphml.GraphMLParser#addParsedListener
 * @see yfiles.graphml.GraphMLIOHandler#removeParsedListener
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Parsed</code> event that occurs when the the document has been parsed.
 * @see yfiles.graphml.GraphMLIOHandler#onParsed
 * @see yfiles.graphml.GraphMLParser#addParsedListener
 * @see yfiles.graphml.GraphMLIOHandler#addParsedListener
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeParsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>Parsing</code> event that occurs when the parsing of a document is just about to begin.
 * <p>
 * This event can be used to register to the fine-grained events available in the {\@link yfiles.graphml.ParseEventArgs#context}'s {\@link yfiles.graphml.IParseContext#parseEvents} and to configure the parsing process
 * on a per parse case.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#onParsing
 * @see yfiles.graphml.GraphMLParser#addParsingListener
 * @see yfiles.graphml.GraphMLIOHandler#removeParsingListener
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Parsing</code> event that occurs when the parsing of a document is just about to begin.
 * <p>
 * This event can be used to register to the fine-grained events available in the {\@link yfiles.graphml.ParseEventArgs#context}'s {\@link yfiles.graphml.IParseContext#parseEvents} and to configure the parsing process
 * on a per parse case.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#onParsing
 * @see yfiles.graphml.GraphMLParser#addParsingListener
 * @see yfiles.graphml.GraphMLIOHandler#addParsingListener
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeParsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>QueryInputHandlers</code> event that occurs when a GraphML attribute is about to be read.
 * <p>
 * Subscribe to this event to dynamically register one or more {\@link yfiles.graphml.IInputHandler} instance(s) for a given GraphML
 * attribute key definition.
 * </p>
 * <p>
 * The current key definition is provided by {\@link yfiles.graphml.QueryInputHandlersEventArgs#keyDefinition}. If you want to register an {\@link yfiles.graphml.IInputHandler} for this GraphML
 * attribute, you can add the handler with {\@link yfiles.graphml.QueryInputHandlersEventArgs#addInputHandler} method.
 * Implementations should also consider the {\@link yfiles.graphml.QueryInputHandlersEventArgs#handled} property.
 * </p>
 * @see yfiles.graphml.GraphMLParser#addQueryInputHandlersListener
 * @see yfiles.graphml.GraphMLIOHandler#removeQueryInputHandlersListener
 * @param {function(!Object, !yfiles.graphml.QueryInputHandlersEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addQueryInputHandlersListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryInputHandlers</code> event that occurs when a GraphML attribute is about to be read.
 * <p>
 * Subscribe to this event to dynamically register one or more {\@link yfiles.graphml.IInputHandler} instance(s) for a given GraphML
 * attribute key definition.
 * </p>
 * <p>
 * The current key definition is provided by {\@link yfiles.graphml.QueryInputHandlersEventArgs#keyDefinition}. If you want to register an {\@link yfiles.graphml.IInputHandler} for this GraphML
 * attribute, you can add the handler with {\@link yfiles.graphml.QueryInputHandlersEventArgs#addInputHandler} method.
 * Implementations should also consider the {\@link yfiles.graphml.QueryInputHandlersEventArgs#handled} property.
 * </p>
 * @see yfiles.graphml.GraphMLParser#addQueryInputHandlersListener
 * @see yfiles.graphml.GraphMLIOHandler#addQueryInputHandlersListener
 * @param {function(!Object, !yfiles.graphml.QueryInputHandlersEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeQueryInputHandlersListener = function(listener) {};

/**
 * Adds the given listener for the <code>HandleDeserialization</code> event that occurs when XML content is about to be deserialized.
 * <p>
 * Subscribe to this event to provide custom deserialization handling for XML content.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * The current XML content is provided by {\@link yfiles.graphml.HandleDeserializationEventArgs#xmlNode}. If you want to return deserialized content, set the value of the {\@link yfiles.graphml.HandleDeserializationEventArgs#result} property.
 * </p>
 * @see yfiles.graphml.GraphMLParser#addHandleDeserializationListener
 * @see yfiles.graphml.GraphMLIOHandler#removeHandleDeserializationListener
 * @param {function(!Object, !yfiles.graphml.HandleDeserializationEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.addHandleDeserializationListener = function(listener) {};

/**
 * Removes the given listener for the <code>HandleDeserialization</code> event that occurs when XML content is about to be
 * deserialized.
 * <p>
 * Subscribe to this event to provide custom deserialization handling for XML content.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * The current XML content is provided by {\@link yfiles.graphml.HandleDeserializationEventArgs#xmlNode}. If you want to return deserialized content, set the value of the {\@link yfiles.graphml.HandleDeserializationEventArgs#result} property.
 * </p>
 * @see yfiles.graphml.GraphMLParser#addHandleDeserializationListener
 * @see yfiles.graphml.GraphMLIOHandler#addHandleDeserializationListener
 * @param {function(!Object, !yfiles.graphml.HandleDeserializationEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLIOHandler.prototype.removeHandleDeserializationListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.IGenericInputHandlerFactory = function() {};

/**
 * Create an {\@link yfiles.graphml.IInputHandler} instance based on the given <code>args</code>.
 * @abstract
 * @param {!yfiles.lang.Class} keyType The key type as inferred by the caller from the GraphML contents.
 * @param {!yfiles.lang.Class} valueType The type of the value as inferred by the caller from the GraphML contents.
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt The event argument that is used like in
 * {\@link #addQueryInputHandlersListener QueryInputHandlers}
 * @return {?} The specific input handler to use.
 */
yfiles.graphml.IGenericInputHandlerFactory.prototype.createInputHandler = function(keyType, valueType, evt) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IGenericInputHandlerFactory;
/**
 * @record
 * @struct
 */
yfiles.graphml.GraphMLSupport = function() {};
 /** @type {!yfiles.graphml.GraphMLIOHandler} */
yfiles.graphml.GraphMLSupport.prototype.graphMLIOHandler;
 /** @type {yfiles.graphml.StorageLocation} */
yfiles.graphml.GraphMLSupport.prototype.storageLocation;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLSupport.$class;

/**
 * Helper callback method that creates the {\@link HTMLInputElement} for use in the handling of the {\@link yfiles.input.ICommand#OPEN}
 * command.
 * <p>
 * The open command that is enabled if {\@link yfiles.graphml.GraphMLSupport#storageLocation} is set to a value different from {\@link yfiles.graphml.StorageLocation#NONE} will use this
 * method to create the input element for opening the files.
 * </p>
 * @protected
 * @return {!HTMLInputElement} The preconfigured element to use.
 */
yfiles.graphml.GraphMLSupport.prototype.createOpenFileInputElement = function() {};

/**
 * Helper callback method that creates the {\@link HTMLElement} for use in the handling of the
 * {\@link yfiles.input.ICommand#SAVE}and SaveAs commands.
 * <p>
 * If {\@link yfiles.graphml.GraphMLSupport#storageLocation} is set to {\@link yfiles.graphml.StorageLocation#FILE_SYSTEM} but saving to a file is not supported by the user's browser,
 * this method is called to create the element to which the GraphML content is appended.
 * </p>
 * @protected
 * @return {!HTMLElement} The preconfigured element to use. Null if element creation failed.
 */
yfiles.graphml.GraphMLSupport.prototype.createSaveFileTextElement = function() {};

/**
 * Gets the {\@link yfiles.graphml.GraphMLSupport#graphMLIOHandler} to use for the various I/O methods in this instance.
 * <p>
 * This method will first query the {\@link yfiles.graph.ILookup#lookup} of the <code>graph</code>,
 * </p>
 * @protected
 * @param {?} graph
 * @return {!yfiles.graphml.GraphMLIOHandler} The instance to use for IO.
 */
yfiles.graphml.GraphMLSupport.prototype.getGraphMLIOHandler = function(graph) {};

/**
 * Default implementation of {\@link yfiles.input.ICommand#OPEN} that shows a {\@link yfiles.graphml.GraphMLSupport#createOpenFileInputElement open file dialog} and imports the GraphML.
 * <p>
 * This method is called in response to the {\@link yfiles.input.ICommand#OPEN} command if {\@link yfiles.graphml.GraphMLSupport#storageLocation} is set to a value different from
 * {\@link yfiles.graphml.StorageLocation#NONE}.
 * </p>
 * <p>
 * Any exception thrown during loading of the GraphML file will reject the promise.
 * </p>
 * @see yfiles.graphml.GraphMLSupport#storageLocation
 * @see yfiles.graphml.GraphMLSupport#saveFile
 * Default implementation of {\@link yfiles.input.ICommand#OPEN} that shows a {\@link yfiles.graphml.GraphMLSupport#createOpenFileInputElement open file dialog} and imports the GraphML.
 * <p>
 * This method is called in response to the {\@link yfiles.input.ICommand#OPEN} command if {\@link yfiles.graphml.GraphMLSupport#storageLocation} is set to a value different from
 * {\@link yfiles.graphml.StorageLocation#NONE}.
 * </p>
 * <p>
 * Any exception thrown during loading of the GraphML file will be caught and an error message displayed to the user. For
 * more control over error behaviour it is recommended to use {\@link yfiles.graphml.GraphMLSupport#graphMLIOHandler} directly, e.g. from a custom command handler.
 * </p>
 * @see yfiles.graphml.GraphMLSupport#storageLocation
 * @see yfiles.graphml.GraphMLSupport#saveFile
 * @param {!yfiles.view.GraphComponent|?} graphComponent_or_graph
 * @param {yfiles.graphml.StorageLocation=} storageLocation
 * @return {!Promise<?>} A promise that will resolve to the loaded graph instance or reject upon exceptions during loading. Note that if the file
 * open dialog is cancelled by the user, the promise will stay unresolved because there is no API available that can be
 * used to determine whether the user has pressed cancel. Depending on the UA implementation it may be possible to listen
 * to focus or other input device events on the page to detect when the user has closed the file open dialog.
 */
yfiles.graphml.GraphMLSupport.prototype.openFile = function(graphComponent_or_graph, storageLocation) {};

/**
 * Registers bindings for {\@link yfiles.input.ICommand#OPEN} and {\@link yfiles.input.ICommand#SAVE} on the given <code>graphControl</code>.
 * @param {!yfiles.view.GraphComponent} graphComponent The {\@link } to register the command bindings on.
 * @return {void}
 */
yfiles.graphml.GraphMLSupport.prototype.registerCommands = function(graphComponent) {};

/**
 * Convenience method that exports the graph as GraphML and saves it to a storage location.
 * <p>
 * This method is called in response to the {\@link yfiles.input.ICommand#SAVE} command if {\@link yfiles.graphml.GraphMLSupport#storageLocation} is set to a value different from
 * {\@link yfiles.graphml.StorageLocation#NONE}.
 * </p>
 * <p>
 * Any exception thrown during loading of the GraphML file will be caught and an error message displayed to the user. For
 * more control over error behaviour it is recommended to use {\@link yfiles.graphml.GraphMLSupport#graphMLIOHandler} directly, e.g. from a custom command handler.
 * </p>
 * @see yfiles.graphml.GraphMLSupport#storageLocation
 * @see yfiles.graphml.GraphMLSupport#saveFile
 * @see yfiles.graphml.GraphMLSupport#openFile
 * @param {?} graph
 * @param {yfiles.graphml.StorageLocation=} storageLocation
 * @return {!Promise<string>} A promise that will resolve to the saved string representation of the graph or reject upon exceptions during the save
 * operation.
 */
yfiles.graphml.GraphMLSupport.prototype.saveFile = function(graph, storageLocation) {};

/** @const */
yfiles.graphml.StorageLocation = {};
/** @const {number} */
yfiles.graphml.StorageLocation.NONE;
/** @const {number} */
yfiles.graphml.StorageLocation.LOCAL_STORAGE;
/** @const {number} */
yfiles.graphml.StorageLocation.SESSION_STORAGE;
/** @const {number} */
yfiles.graphml.StorageLocation.FILE_SYSTEM;
/**
 * @record
 * @struct
 */
yfiles.graphml.ChildParseContext = function() {};
 /** @type {?} */
yfiles.graphml.ChildParseContext.prototype.parentContext;
 /** @type {?<!Object>} */
yfiles.graphml.ChildParseContext.prototype.objectStack;
 /** @type {?} */
yfiles.graphml.ChildParseContext.prototype.parseEvents;
 /** @type {?} */
yfiles.graphml.ChildParseContext.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.ChildParseContext.$class;

/**
 * 
 * Type parameter <code>T</code>.
 * @template T
 * @param {!yfiles.lang.Class} targetType
 * @param {?} context
 * @param {!Node} targetNode
 * @return {T}
 */
yfiles.graphml.ChildParseContext.prototype.deserializeCore = function(targetType, context, targetNode) {};

/**
 * 
 * Type parameter <code>T</code>.
 * @template T
 * @param {!yfiles.lang.Class} itemType
 * @return {T}
 */
yfiles.graphml.ChildParseContext.prototype.getCurrent = function(itemType) {};

/**
 *
 * @param {string} key
 * @return {!Object}
 */
yfiles.graphml.ChildParseContext.prototype.getDeserializationProperty = function(key) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graphml.ChildParseContext.prototype.lookup = function(type) {};

/**
 * Removes a previously locally {\@link yfiles.graphml.ChildParseContext#setDeserializationProperty set} deserialization property.
 * @param {string} key The key for which the local property override should be removed.
 * @return {void}
 */
yfiles.graphml.ChildParseContext.prototype.removeDeserializationProperty = function(key) {};

/**
 * Removes a local lookup override that has been added using {\@link yfiles.graphml.ChildParseContext#setLookup}
 * Type parameter <code>T</code>: The type key to remove.
 * @template T
 * @param {!yfiles.lang.Class} tType The type key to remove.
 * @return {void}
 */
yfiles.graphml.ChildParseContext.prototype.removeLookup = function(tType) {};

/**
 * Sets the local deserialization property for the given key to the value.
 * @param {string} key The key to override.
 * @param {!Object} value The value.
 * @return {void}
 */
yfiles.graphml.ChildParseContext.prototype.setDeserializationProperty = function(key, value) {};

/**
 * Adds another lookup result to the local lookup override.
 * Type parameter <code>T</code>: The type to use as a key for the lookup.
 * @see yfiles.graphml.ChildParseContext#removeLookup
 * @template T
 * @param {!yfiles.lang.Class} tType The type to use as a key for the lookup.
 * @param {T} value The value to provide for queries to <code>T</code>.
 * @return {void}
 */
yfiles.graphml.ChildParseContext.prototype.setLookup = function(tType, value) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.CreationProperties = function() {};
 /** @type {string} */
yfiles.graphml.CreationProperties.IS_GROUP_NODE;
 /** @type {string} */
yfiles.graphml.CreationProperties.LABELS;
 /** @type {string} */
yfiles.graphml.CreationProperties.LAYOUT;
 /** @type {string} */
yfiles.graphml.CreationProperties.STYLE;
 /** @type {string} */
yfiles.graphml.CreationProperties.TAG;
 /** @type {string} */
yfiles.graphml.CreationProperties.BENDS;
 /** @type {string} */
yfiles.graphml.CreationProperties.PORT_LOCATION_MODEL_PARAMETER;
 /** @type {?<!yfiles.collections.MapEntry<!Object, !Object>>} */
yfiles.graphml.CreationProperties.prototype.entries;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.CreationProperties.$class;

/**
 * Clears all entries from this property store.
 * @return {void}
 */
yfiles.graphml.CreationProperties.prototype.clear = function() {};

/**
 * Gets the value associated with the specified key.
 * @see yfiles.graphml.CreationProperties#set
 * @param {!Object} key The key.
 * @return {!Object} The value stored for the key.
 */
yfiles.graphml.CreationProperties.prototype.get = function(key) {};

/**
 * Removes the associated entry for the given key
 * @param {!Object} key The entry key to remove.
 * @return {void}
 */
yfiles.graphml.CreationProperties.prototype.removeValue = function(key) {};

/**
 * Sets the value associated with the specified key.
 * @see yfiles.graphml.CreationProperties#get
 * @param {!Object} key The key.
 * @param {!Object} value The value stored for the key.
 * @return {void}
 */
yfiles.graphml.CreationProperties.prototype.set = function(key, value) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.GraphMLParser = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLParser.$class;

/**
 * Create the initial {\@link yfiles.graphml.IParseContext} instance.
 * @protected
 * @param {?} graph The graph that is parsed.
 * @return {?} An {\@link } instance that is suitable for <code>graph</code>.
 */
yfiles.graphml.GraphMLParser.prototype.createParseContext = function(graph) {};

/**
 * Deserialize the content of <code>element</code>.
 * <p>
 * Typically, this method is called only indirectly by calls to {\@link yfiles.graphml.IParseContext#deserializeCore}. This
 * implementation calls {\@link yfiles.graphml.GraphMLParser#onHandleDeserialization}, which in turn raises the {\@link yfiles.graphml.GraphMLParser#addHandleDeserializationListener HandleDeserialization}
 * event.
 * </p>
 * Type parameter <code>T</code>: The desired type of the result.
 * @see yfiles.graphml.IParseContext#deserializeCore
 * @see yfiles.graphml.GraphMLParser#addHandleDeserializationListener
 * @template T
 * @param {!yfiles.lang.Class} targetType The desired type of the result.
 * @param {?} context The current parse context.
 * @param {!Node} element The XML content that should be deserialized.
 * @return {T} An instance of <code>T</code> that is represented by <code>element</code>.
 */
yfiles.graphml.GraphMLParser.prototype.deserialize = function(targetType, context, element) {};

/**
 * Retrieve a deserialization property that has been set by {\@link yfiles.graphml.GraphMLParser#setDeserializationProperty}.
 * @see yfiles.graphml.IParseContext#getDeserializationProperty
 * @param {string} key The key for the property.
 * @return {!Object}
 */
yfiles.graphml.GraphMLParser.prototype.getDeserializationProperty = function(key) {};

/**
 * Dynamically retrieve all {\@link yfiles.graphml.IInputHandler} instances that process a GraphML attribute with key definition
 * <code>keyDefinition</code>.
 * <p>
 * Typically, this method is called only indirectly by the parse process. This implementation calls
 * {\@link yfiles.graphml.GraphMLParser#onQueryInputHandlers}, which in turn raises the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers}
 * event.
 * </p>
 * @param {?} context The current parse context.
 * @param {!Element} keyDefinition The key definition element of the GraphML attribute.
 * @return {?<?>} A list of {\@link  IInputHandlers} that claim to be responsible for handling the given GraphML attribute.
 */
yfiles.graphml.GraphMLParser.prototype.getInputHandlers = function(context, keyDefinition) {};

/**
 * Dynamically retrieve an instance of <code>type</code>.
 * @param {!yfiles.lang.Class} type The type for which an implementation is needed.
 * @return {!Object} An implementation of <code>type</code>, or <code>null</code>.
 */
yfiles.graphml.GraphMLParser.prototype.lookup = function(type) {};

/**
 * Fires the {\@link yfiles.graphml.GraphMLParser#addHandleDeserializationListener HandleDeserialization} event.
 * @see yfiles.graphml.GraphMLIOHandler#onHandleDeserialization
 * @protected
 * @param {!yfiles.graphml.HandleDeserializationEventArgs} evt The arguments that get passed to the {\@link #addHandleDeserializationListener HandleDeserialization}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.onHandleDeserialization = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLParser#addParsedListener Parsed} event.
 * <p>
 * This method is called when the document has been parsed and after {\@link yfiles.graphml.IParseEvents#addDocumentParsedListener DocumentParsed}
 * is called.
 * </p>
 * @see yfiles.graphml.GraphMLParser#addParsedListener
 * @protected
 * @param {!yfiles.graphml.ParseEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.onParsed = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLParser#addParsingListener Parsing} event.
 * <p>
 * This method is called just before the parsing starts and before {\@link yfiles.graphml.IParseEvents#addDocumentParsingListener DocumentParsing}
 * is called.
 * </p>
 * @see yfiles.graphml.GraphMLParser#addParsingListener
 * @protected
 * @param {!yfiles.graphml.ParseEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.onParsing = function(evt) {};

/**
 * Fires the {\@link yfiles.graphml.GraphMLParser#addQueryInputHandlersListener QueryInputHandlers} event.
 * @see yfiles.graphml.GraphMLIOHandler#onQueryInputHandlers
 * @protected
 * @param {!yfiles.graphml.QueryInputHandlersEventArgs} evt The arguments that get passed to the {\@link #addQueryInputHandlersListener QueryInputHandlers}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.onQueryInputHandlers = function(evt) {};

/**
 * Parse the XML document <code>document</code> into an <code>graph</code> instance, using <code>elementFactory</code> to create the elements.
 * <p>
 * Typically, this method is called indirectly from {\@link yfiles.graphml.GraphMLIOHandler#readFromDocument}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#readFromDocument
 * @param {?} graph The graph instance that is populated.
 * @param {!Document} document The XML document instance to parse. <b>Note</b>: If you are using Internet Explorer 9 and {\@link }s to retrieve the document,
 * you may not use the value from the {\@link #responseXML} property. Please parse {\@link #responseText} instead
 * and use the result. For further reference see {\@link http://msdn.microsoft.com/en-us/library/ie/hh180177.aspx}.
 * @param {?} elementFactory The {\@link } instance that is used to create the elements.
 * @return {!Promise<?>}
 */
yfiles.graphml.GraphMLParser.prototype.parseFromDocument = function(graph, document, elementFactory) {};

/**
 * Parse the input <code>url</code> into an <code>graph</code> instance, using <code>elementFactory</code> to create the elements.
 * <p>
 * Typically, this method is called indirectly from {\@link yfiles.graphml.GraphMLIOHandler#readFromURL}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#readFromGraphMLText
 * @param {?} graph The graph instance that is populated.
 * @param {string} url The URL to the input to parse.
 * @param {?} elementFactory The {\@link } instance that is used to create the elements.
 * @return {!Promise<?>}
 */
yfiles.graphml.GraphMLParser.prototype.parseFromURL = function(graph, url, elementFactory) {};

/**
 * Remove a deserialization property that has been set by {\@link yfiles.graphml.GraphMLParser#setDeserializationProperty}.
 * @see yfiles.graphml.IParseContext#getDeserializationProperty
 * @param {string} key The key for the property.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.removeDeserializationProperty = function(key) {};

/**
 * Remove an implementation of <code>T</code> that has been set with {\@link yfiles.graphml.GraphMLParser#setLookup}.
 * Type parameter <code>T</code>.
 * @template T
 * @param {!yfiles.lang.Class} tType
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.removeLookup = function(tType) {};

/**
 * Set a deserialization property that allows to fine tune the parsing process.
 * @see yfiles.graphml.IParseContext#getDeserializationProperty
 * @param {string} key The key for the property.
 * @param {!Object} value The property value.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.setDeserializationProperty = function(key, value) {};

/**
 * Register an implementation of <code>T</code> for use with {\@link yfiles.graphml.GraphMLParser#lookup}.
 * Type parameter <code>T</code>: The type of <code>instance</code>.
 * @template T
 * @param {!yfiles.lang.Class} tType The type of <code>instance</code>.
 * @param {T} instance The implementation of <code>T</code> for lookup retrieval.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.setLookup = function(tType, instance) {};

/**
 * Adds the given listener for the <code>QueryInputHandlers</code> event that occurs when {\@link yfiles.graphml.IInputHandler}s are queried.
 * <p>
 * Subscribe to this event to dynamically register one or more {\@link yfiles.graphml.IInputHandler} instance(s) for a given GraphML
 * attribute key definition.
 * </p>
 * <p>
 * The current key definition is provided by {\@link yfiles.graphml.QueryInputHandlersEventArgs#keyDefinition}. If you want to register an {\@link yfiles.graphml.IInputHandler} for this GraphML
 * attribute, you can add the handler with {\@link yfiles.graphml.QueryInputHandlersEventArgs#addInputHandler}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addQueryInputHandlersListener
 * @see yfiles.graphml.GraphMLParser#removeQueryInputHandlersListener
 * @param {function(!Object, !yfiles.graphml.QueryInputHandlersEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.addQueryInputHandlersListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryInputHandlers</code> event that occurs when {\@link yfiles.graphml.IInputHandler}s are queried.
 * <p>
 * Subscribe to this event to dynamically register one or more {\@link yfiles.graphml.IInputHandler} instance(s) for a given GraphML
 * attribute key definition.
 * </p>
 * <p>
 * The current key definition is provided by {\@link yfiles.graphml.QueryInputHandlersEventArgs#keyDefinition}. If you want to register an {\@link yfiles.graphml.IInputHandler} for this GraphML
 * attribute, you can add the handler with {\@link yfiles.graphml.QueryInputHandlersEventArgs#addInputHandler}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addQueryInputHandlersListener
 * @see yfiles.graphml.GraphMLParser#addQueryInputHandlersListener
 * @param {function(!Object, !yfiles.graphml.QueryInputHandlersEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.removeQueryInputHandlersListener = function(listener) {};

/**
 * Adds the given listener for the <code>HandleDeserialization</code> event that occurs when XML content is about to be deserialized.
 * <p>
 * Subscribe to this event to provide custom deserialization handling for XML content.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * The current XML content is provided by {\@link yfiles.graphml.HandleDeserializationEventArgs#xmlNode}. If you want to return deserialized content, set the value of the {\@link yfiles.graphml.HandleDeserializationEventArgs#result} property.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addHandleDeserializationListener
 * @see yfiles.graphml.GraphMLParser#removeHandleDeserializationListener
 * @param {function(!Object, !yfiles.graphml.HandleDeserializationEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.addHandleDeserializationListener = function(listener) {};

/**
 * Removes the given listener for the <code>HandleDeserialization</code> event that occurs when XML content is about to be
 * deserialized.
 * <p>
 * Subscribe to this event to provide custom deserialization handling for XML content.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * The current XML content is provided by {\@link yfiles.graphml.HandleDeserializationEventArgs#xmlNode}. If you want to return deserialized content, set the value of the {\@link yfiles.graphml.HandleDeserializationEventArgs#result} property.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addHandleDeserializationListener
 * @see yfiles.graphml.GraphMLParser#addHandleDeserializationListener
 * @param {function(!Object, !yfiles.graphml.HandleDeserializationEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.removeHandleDeserializationListener = function(listener) {};

/**
 * Adds the given listener for the <code>Parsed</code> event that occurs when the the document has been parsed.
 * @see yfiles.graphml.GraphMLParser#onParsed
 * @see yfiles.graphml.GraphMLParser#removeParsedListener
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.addParsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Parsed</code> event that occurs when the the document has been parsed.
 * @see yfiles.graphml.GraphMLParser#onParsed
 * @see yfiles.graphml.GraphMLParser#addParsedListener
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.removeParsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>Parsing</code> event that occurs when the parsing of the document is just about to begin.
 * <p>
 * This event can be used to register to the fine-grained events available in the {\@link yfiles.graphml.ParseEventArgs#context}'s {\@link yfiles.graphml.IParseContext#parseEvents} and the configure the parsing process
 * on a per parse case.
 * </p>
 * @see yfiles.graphml.GraphMLParser#onParsing
 * @see yfiles.graphml.GraphMLParser#removeParsingListener
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.addParsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Parsing</code> event that occurs when the parsing of the document is just about to begin.
 * <p>
 * This event can be used to register to the fine-grained events available in the {\@link yfiles.graphml.ParseEventArgs#context}'s {\@link yfiles.graphml.IParseContext#parseEvents} and the configure the parsing process
 * on a per parse case.
 * </p>
 * @see yfiles.graphml.GraphMLParser#onParsing
 * @see yfiles.graphml.GraphMLParser#addParsingListener
 * @param {function(!Object, !yfiles.graphml.ParseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLParser.prototype.removeParsingListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.HandleDeserializationEventArgs = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.HandleDeserializationEventArgs.prototype.targetType;
 /** @type {!Object} */
yfiles.graphml.HandleDeserializationEventArgs.prototype.result;
 /** @type {boolean} */
yfiles.graphml.HandleDeserializationEventArgs.prototype.handled;
 /** @type {?} */
yfiles.graphml.HandleDeserializationEventArgs.prototype.context;
 /** @type {!Node} */
yfiles.graphml.HandleDeserializationEventArgs.prototype.xmlNode;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.HandleDeserializationEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.IGraphElementFactory = function() {};

/**
 * Adds a new port to the given {\@link yfiles.graph.IPortOwner}.
 * @abstract
 * @param {?} context The context from which the graph, the {\@link }, and the {\@link #objectStack} can be queried.
 * @param {?} owner The owner of the port.
 * @return {?} A newly created port.
 */
yfiles.graphml.IGraphElementFactory.prototype.addPort = function(context, owner) {};

/**
 * Creates an edge for the given context and the provided source and target nodes or ports.
 * @abstract
 * @param {?} context The context from which the graph, the {\@link }, and the {\@link #objectStack} can be queried.
 * @param {?} sourceNode The source node for the edge.
 * @param {?} sourcePort The source port for the edge, if specified, otherwise <code>null</code>.
 * @param {?} targetNode The target node for the edge.
 * @param {?} targetPort The target port for the edge, if specified, otherwise <code>null</code>.
 * @return {?} A newly created edge.
 */
yfiles.graphml.IGraphElementFactory.prototype.createEdge = function(context, sourceNode, sourcePort, targetNode, targetPort) {};

/**
 * Creates a node for the given context.
 * @abstract
 * @param {?} context The context from which the graph, the {\@link }, and the {\@link #objectStack} can be queried.
 * @return {?} A newly created node
 */
yfiles.graphml.IGraphElementFactory.prototype.createNode = function(context) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IGraphElementFactory;
/**
 * @record
 * @struct
 */
yfiles.graphml.IGraphElementIdAcceptor = function() {};

/**
 * Store the value of the id attribute for the given edge.
 * @abstract
 * @param {?} context The current parse context.
 * @param {?} edge The current edge element
 * @param {string} id The id of the edge's XML representation
 * @return {void}
 */
yfiles.graphml.IGraphElementIdAcceptor.prototype.storeEdgeId = function(context, edge, id) {};

/**
 * Store the value of the id attribute for the given graph.
 * @abstract
 * @param {?} context The current parse context.
 * @param {?} graph The current graph element
 * @param {string} id The id of the graph's XML representation
 * @return {void}
 */
yfiles.graphml.IGraphElementIdAcceptor.prototype.storeGraphId = function(context, graph, id) {};

/**
 * Store the value of the id attribute for the given node.
 * @abstract
 * @param {?} context The current parse context.
 * @param {?} node The current node element
 * @param {string} id The id of the node's XML representation
 * @return {void}
 */
yfiles.graphml.IGraphElementIdAcceptor.prototype.storeNodeId = function(context, node, id) {};

/**
 * Store the value of the id attribute for the given port.
 * @abstract
 * @param {?} context The current parse context.
 * @param {?} port The current port element
 * @param {string} id The id of the port's XML representation
 * @return {void}
 */
yfiles.graphml.IGraphElementIdAcceptor.prototype.storePortId = function(context, port, id) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IGraphElementIdAcceptor;
/**
 * @record
 * @struct
 */
yfiles.graphml.GraphElementIdAcceptor = function() {};
 /** @type {?<?, string>} */
yfiles.graphml.GraphElementIdAcceptor.prototype.graphIds;
 /** @type {?<?, string>} */
yfiles.graphml.GraphElementIdAcceptor.prototype.nodeIds;
 /** @type {?<?, string>} */
yfiles.graphml.GraphElementIdAcceptor.prototype.edgeIds;
 /** @type {?<?, string>} */
yfiles.graphml.GraphElementIdAcceptor.prototype.portIds;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphElementIdAcceptor.$class;

/**
 * Factory method to create a default implementation of {\@link yfiles.graphml.IGraphElementIdProvider} that delegates to <code>fallback</code>
 * and uses the values stored by this {\@link yfiles.graphml.GraphElementIdAcceptor} instance, if possible.
 * @param {?} fallback The fallback.
 * @return {?}
 */
yfiles.graphml.GraphElementIdAcceptor.prototype.createIdProvider = function(fallback) {};

/**
 *
 * @param {?} context
 * @param {string} id
 * @return {?}
 */
yfiles.graphml.GraphElementIdAcceptor.prototype.resolveEdge = function(context, id) {};

/**
 *
 * @param {?} context
 * @param {string} id
 * @return {?}
 */
yfiles.graphml.GraphElementIdAcceptor.prototype.resolveGraph = function(context, id) {};

/**
 *
 * @param {?} context
 * @param {string} id
 * @return {?}
 */
yfiles.graphml.GraphElementIdAcceptor.prototype.resolveNode = function(context, id) {};

/**
 *
 * @param {?} context
 * @param {string} ownerId
 * @param {string} id
 * @return {?}
 */
yfiles.graphml.GraphElementIdAcceptor.prototype.resolvePort = function(context, ownerId, id) {};

/**
 *
 * @param {?} context
 * @param {?} edge
 * @param {string} id
 * @return {void}
 */
yfiles.graphml.GraphElementIdAcceptor.prototype.storeEdgeId = function(context, edge, id) {};

/**
 *
 * @param {?} context
 * @param {?} graph
 * @param {string} id
 * @return {void}
 */
yfiles.graphml.GraphElementIdAcceptor.prototype.storeGraphId = function(context, graph, id) {};

/**
 *
 * @param {?} context
 * @param {?} node
 * @param {string} id
 * @return {void}
 */
yfiles.graphml.GraphElementIdAcceptor.prototype.storeNodeId = function(context, node, id) {};

/**
 *
 * @param {?} context
 * @param {?} port
 * @param {string} id
 * @return {void}
 */
yfiles.graphml.GraphElementIdAcceptor.prototype.storePortId = function(context, port, id) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.IGraphElementResolver = function() {};

/**
 * Resolve the GraphML <code>id</code> to an {\@link yfiles.graph.IEdge} instance.
 * @abstract
 * @param {?} context The current parse context.
 * @param {string} id The id that should be resolved.
 * @return {?} The {\@link } that is defined by this GraphML <code>id</code>, or <code>null</code> if no such edge exists yet.
 */
yfiles.graphml.IGraphElementResolver.prototype.resolveEdge = function(context, id) {};

/**
 * Resolve the GraphML <code>id</code> to an {\@link yfiles.graph.IGraph} instance.
 * @abstract
 * @param {?} context The current parse context.
 * @param {string} id The id that should be resolved.
 * @return {?} The {\@link } that is defined by this GraphML <code>id</code>, or <code>null</code> if no such graph exists yet.
 */
yfiles.graphml.IGraphElementResolver.prototype.resolveGraph = function(context, id) {};

/**
 * Resolve the GraphML <code>id</code> to an {\@link yfiles.graph.INode} instance.
 * @abstract
 * @param {?} context The current parse context.
 * @param {string} id The id that should be resolved.
 * @return {?} The {\@link } that is defined by this GraphML <code>id</code>, or <code>null</code> if no such node exists yet.
 */
yfiles.graphml.IGraphElementResolver.prototype.resolveNode = function(context, id) {};

/**
 * Resolve the GraphML <code>id</code> to an {\@link yfiles.graph.IPort} instance.
 * <p>
 * The port owner is specified by the <code>ownerId</code> attribute.
 * </p>
 * @abstract
 * @param {?} context The current parse context.
 * @param {string} ownerId The GraphML id of the port owner.
 * @param {string} id The id that should be resolved.
 * @return {?} The {\@link } that is defined by the GraphML ids, or <code>null</code> if no such port exists yet.
 */
yfiles.graphml.IGraphElementResolver.prototype.resolvePort = function(context, ownerId, id) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IGraphElementResolver;
/**
 * @record
 * @struct
 */
yfiles.graphml.IInputHandler = function() {};
 /** @type {yfiles.graphml.ParsePrecedence} */
yfiles.graphml.IInputHandler.prototype.precedence;

/**
 * This method is invoked when no data tag is defined, and the default value should be applied.
 * @abstract
 * @param {?} context the current parse context.
 * @return {void}
 */
yfiles.graphml.IInputHandler.prototype.applyDefault = function(context) {};

/**
 * This method is invoked each time a data element with matching key is processed.
 * @abstract
 * @param {?} context the current parse context.
 * @param {!Node} node the DOM node representing the data element.
 * @return {void}
 */
yfiles.graphml.IInputHandler.prototype.parseData = function(context, node) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IInputHandler;

/** @const */
yfiles.graphml.ParsePrecedence = {};
/** @const {number} */
yfiles.graphml.ParsePrecedence.FIRST;
/** @const {number} */
yfiles.graphml.ParsePrecedence.BEFORE_OWNER;
/** @const {number} */
yfiles.graphml.ParsePrecedence.BEFORE_CHILDREN;
/** @const {number} */
yfiles.graphml.ParsePrecedence.DEFAULT;
/** @const {number} */
yfiles.graphml.ParsePrecedence.AFTER_CHILDREN;
/** @const {number} */
yfiles.graphml.ParsePrecedence.AFTER_OWNER;
/** @const {number} */
yfiles.graphml.ParsePrecedence.LAST;
/**
 * @record
 * @struct
 */
yfiles.graphml.InputHandlerBase = function() {};
 /** @type {boolean} */
yfiles.graphml.InputHandlerBase.prototype.parseDefaultValue;
 /** @type {TData} */
yfiles.graphml.InputHandlerBase.prototype.defaultValue;
 /** @type {boolean} */
yfiles.graphml.InputHandlerBase.prototype.defaultExists;
 /** @type {yfiles.graphml.ParsePrecedence} */
yfiles.graphml.InputHandlerBase.prototype.precedence;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.InputHandlerBase.$class;

/**
 * This method is invoked when no data tag is defined, and the default value should be applied.
 * <p>
 * This implementation delegates to {\@link yfiles.graphml.InputHandlerBase.<TKey,TData>#setValue} if {\@link yfiles.graphml.InputHandlerBase.<TKey,TData>#defaultExists a default exists} using the {\@link yfiles.graphml.InputHandlerBase.<TKey,TData>#defaultValue}.
 * </p>
 * @param {?} context the current parse context.
 * @return {void}
 */
yfiles.graphml.InputHandlerBase.prototype.applyDefault = function(context) {};

/**
 * Initializes this instance from the GraphML key definition.
 * <p>
 * This implementation looks for the GraphML default element and delegates to {\@link yfiles.graphml.InputHandlerBase.<TKey,TData>#parseDataCore} if a default is found to store
 * the {\@link yfiles.graphml.InputHandlerBase.<TKey,TData>#defaultValue}.
 * </p>
 * @param {?} context The context.
 * @param {!Element} definition The definition.
 * @return {void}
 */
yfiles.graphml.InputHandlerBase.prototype.initializeFromKeyDefinition = function(context, definition) {};

/**
 * This method is invoked each time a data element with matching key is processed.
 * <p>
 * If the {\@link yfiles.graphml.IParseContext#getCurrent current element} is of the same type as this <code>TKey</code>, this method delegates the actual parsing to {\@link yfiles.graphml.InputHandlerBase.<TKey,TData>#parseDataCore} and
 * {\@link yfiles.graphml.InputHandlerBase.<TKey,TData>#setValue}
 * </p>
 * @param {?} context the current parse context.
 * @param {!Node} node the DOM node representing the data element.
 * @return {void}
 */
yfiles.graphml.InputHandlerBase.prototype.parseData = function(context, node) {};

/**
 * Abstract method callback that actually parses the data.
 * @protected
 * @abstract
 * @param {?} context The context.
 * @param {!Node} node The node that contains the data. This is either the GraphML 'data' element or the 'default' element.
 * @return {TData} The parsed data.
 */
yfiles.graphml.InputHandlerBase.prototype.parseDataCore = function(context, node) {};

/**
 * Abstract method callback that actually stores the value with the keys.
 * @protected
 * @abstract
 * @param {?} context The context.
 * @param {TKey} key The key.
 * @param {TData} data The data.
 * @return {void}
 */
yfiles.graphml.InputHandlerBase.prototype.setValue = function(context, key, data) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.MapperInputHandler = function() {};
 /** @type {?<TKey, TData>} */
yfiles.graphml.MapperInputHandler.prototype.mapper;
 /** @type {boolean} */
yfiles.graphml.MapperInputHandler.prototype.overrideDefaultValue;
 /** @type {boolean} */
yfiles.graphml.MapperInputHandler.prototype.useParentElementForDeserialization;
 /** @type {function(!Object, !yfiles.graphml.HandleDeserializationEventArgs): void} */
yfiles.graphml.MapperInputHandler.prototype.deserializer;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.MapperInputHandler.prototype.deserializerTargetType;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.MapperInputHandler.$class;

/**
 * Gets the node to pass to {\@link yfiles.graphml.MapperInputHandler.<TKey,TData>#deserializer} or {\@link yfiles.graphml.IParseContext#deserializeCore IParseContext.Deserialize} respectively, given the 'data' or 'default' element from the
 * GraphML.
 * <p>
 * This method is called by {\@link yfiles.graphml.MapperInputHandler.<TKey,TData>#parseDataCore} to determine the node to pass to the deserialization mechanism.
 * </p>
 * <p>
 * This implementation returns <code>node</code> iff {\@link yfiles.graphml.MapperInputHandler.<TKey,TData>#useParentElementForDeserialization} is <code>true</code> (i.e. the <code>'data'</code> or <code>'default'</code> node itself), otherwise the first child of
 * the <code>node</code> that is not a comment or processing instruction.
 * </p>
 * @see yfiles.graphml.MapperInputHandler.<TKey,TData>#useParentElementForDeserialization
 * @protected
 * @param {?} context The context within which the node is parsed.
 * @param {!Node} node The 'data' or 'default' node.
 * @return {!Node} The node that should be deserialized.
 */
yfiles.graphml.MapperInputHandler.prototype.getDeserializationXmlNode = function(context, node) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.QueryInputHandlersEventArgs = function() {};
 /** @type {!Element} */
yfiles.graphml.QueryInputHandlersEventArgs.prototype.keyDefinition;
 /** @type {boolean} */
yfiles.graphml.QueryInputHandlersEventArgs.prototype.handled;
 /** @type {?} */
yfiles.graphml.QueryInputHandlersEventArgs.prototype.context;
 /** @type {?<?>} */
yfiles.graphml.QueryInputHandlersEventArgs.prototype.handlers;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.QueryInputHandlersEventArgs.$class;

/**
 * Register an {\@link yfiles.graphml.IInputHandler} instance for the current {\@link yfiles.graphml.QueryInputHandlersEventArgs#keyDefinition}.
 * <p>
 * Calling this method automatically sets {\@link yfiles.graphml.QueryInputHandlersEventArgs#handled} to <code>true</code>.
 * </p>
 * @param {?} handler
 * @return {void}
 */
yfiles.graphml.QueryInputHandlersEventArgs.prototype.addInputHandler = function(handler) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.ChildWriteContext = function() {};
 /** @type {?<!Object>} */
yfiles.graphml.ChildWriteContext.prototype.objectStack;
 /** @type {?} */
yfiles.graphml.ChildWriteContext.prototype.writeEvents;
 /** @type {?} */
yfiles.graphml.ChildWriteContext.prototype.parentContext;
 /** @type {?} */
yfiles.graphml.ChildWriteContext.prototype.writer;
 /** @type {?} */
yfiles.graphml.ChildWriteContext.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.ChildWriteContext.$class;

/**
 * 
 * Type parameter <code>T</code>.
 * @template T
 * @param {!yfiles.lang.Class} itemType
 * @return {T}
 */
yfiles.graphml.ChildWriteContext.prototype.getCurrent = function(itemType) {};

/**
 *
 * @param {string} key
 * @return {!Object}
 */
yfiles.graphml.ChildWriteContext.prototype.getSerializationProperty = function(key) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graphml.ChildWriteContext.prototype.lookup = function(type) {};

/**
 * Removes a local lookup override that has been added using {\@link yfiles.graphml.ChildWriteContext#setLookup}
 * Type parameter <code>T</code>: The type key to remove.
 * @template T
 * @param {!yfiles.lang.Class} tType The type key to remove.
 * @return {void}
 */
yfiles.graphml.ChildWriteContext.prototype.removeLookup = function(tType) {};

/**
 * Removes a previously locally {\@link yfiles.graphml.ChildWriteContext#setSerializationProperty set} serialization property.
 * @param {string} key The key for which the local property override should be removed.
 * @return {void}
 */
yfiles.graphml.ChildWriteContext.prototype.removeSerializationProperty = function(key) {};

/**
 * 
 * Type parameter <code>T</code>.
 * @template T
 * @param {!yfiles.lang.Class} targetType
 * @param {?} context
 * @param {T} item
 * @return {void}
 */
yfiles.graphml.ChildWriteContext.prototype.serializeCore = function(targetType, context, item) {};

/**
 * Adds another lookup result to the local lookup override.
 * Type parameter <code>T</code>: The type to use as a key for the lookup.
 * @see yfiles.graphml.ChildWriteContext#removeLookup
 * @template T
 * @param {!yfiles.lang.Class} tType The type to use as a key for the lookup.
 * @param {T} value The value to provide for queries to <code>T</code>.
 * @return {void}
 */
yfiles.graphml.ChildWriteContext.prototype.setLookup = function(tType, value) {};

/**
 * Sets the local serialization property for the given key to the value.
 * @param {string} key The key to override.
 * @param {!Object} value The value.
 * @return {void}
 */
yfiles.graphml.ChildWriteContext.prototype.setSerializationProperty = function(key, value) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.GraphMLWriter = function() {};
 /** @type {?} */
yfiles.graphml.GraphMLWriter.prototype.writeEvents;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLWriter.$class;

/**
 * Create the initial {\@link yfiles.graphml.IWriteContext} instance.
 * @protected
 * @param {?} graph The graph that is written.
 * @param {?} writer The core {\@link } instance that does the actual writing of XML content.
 * @return {?} An {\@link } instance that is suitable for <code>graph</code>.
 */
yfiles.graphml.GraphMLWriter.prototype.createWriteContext = function(graph, writer) {};

/**
 * Dynamically retrieve all {\@link yfiles.graphml.IOutputHandler} that should be used for the current write process.
 * <p>
 * Typically, this method is called only indirectly by the write process. This implementation calls
 * {\@link yfiles.graphml.GraphMLWriter#onQueryOutputHandlers}, which in turn raises the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers}
 * event.
 * </p>
 * @param {?} context The current write context.
 * @param {yfiles.graphml.KeyScope} scope The scope to get output handlers for.
 * @return {?<?>} A dictionary from handler definition ids to {\@link  IOutputHandlers}.
 */
yfiles.graphml.GraphMLWriter.prototype.getOutputHandlers = function(context, scope) {};

/**
 * Retrieve a serialization property that has been set by {\@link yfiles.graphml.GraphMLWriter#setSerializationProperty}.
 * @see yfiles.graphml.IWriteContext#getSerializationProperty
 * @param {string} key The key for the property.
 * @return {!Object}
 */
yfiles.graphml.GraphMLWriter.prototype.getSerializationProperty = function(key) {};

/**
 * Dynamically retrieve an instance of <code>type</code>.
 * @protected
 * @param {!yfiles.lang.Class} type The type for which an implementation is needed.
 * @return {!Object} An implementation of <code>type</code>, or <code>null</code>.
 */
yfiles.graphml.GraphMLWriter.prototype.lookup = function(type) {};

/**
 * Fires the {\@link yfiles.graphml.GraphMLWriter#addHandleSerializationListener HandleSerialization} event.
 * @see yfiles.graphml.GraphMLIOHandler#onHandleSerialization
 * @protected
 * @param {!yfiles.graphml.HandleSerializationEventArgs} evt The arguments that get passed to the {\@link #addHandleSerializationListener HandleSerialization}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.onHandleSerialization = function(evt) {};

/**
 * Fires the {\@link yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener QueryOutputHandlers} event.
 * @see yfiles.graphml.GraphMLIOHandler#onQueryOutputHandlers
 * @protected
 * @param {!yfiles.graphml.QueryOutputHandlersEventArgs} evt The arguments that get passed to the {\@link #addQueryOutputHandlersListener QueryOutputHandlers}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.onQueryOutputHandlers = function(evt) {};

/**
 * Fires the {\@link yfiles.graphml.GraphMLWriter#addQueryReferenceIdListener QueryReferenceId} event.
 * @see yfiles.graphml.GraphMLIOHandler#onQueryReferenceId
 * @protected
 * @param {!yfiles.graphml.QueryReferenceIdEventArgs} evt The arguments that get passed to the {\@link #addQueryReferenceIdListener QueryReferenceId}
 * event.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.onQueryReferenceId = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLWriter#addWritingListener Writing} event.
 * <p>
 * This method is called just before the writing starts and before {\@link yfiles.graphml.IWriteEvents#addDocumentWritingListener DocumentWriting}
 * is called for the first time.
 * </p>
 * @see yfiles.graphml.GraphMLWriter#addWritingListener
 * @protected
 * @param {!yfiles.graphml.WriteEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.onWriting = function(evt) {};

/**
 * Raises the {\@link yfiles.graphml.GraphMLWriter#addWrittenListener Written} event.
 * <p>
 * This method is called just before the writing has been finished and after {\@link yfiles.graphml.IWriteEvents#addDocumentWrittenListener DocumentWritten}
 * is called for the last time.
 * </p>
 * @see yfiles.graphml.GraphMLWriter#addWrittenListener
 * @protected
 * @param {!yfiles.graphml.WriteEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.onWritten = function(evt) {};

/**
 * Remove an implementation of <code>T</code> that has been set with {\@link yfiles.graphml.GraphMLWriter#setLookup}.
 * Type parameter <code>T</code>.
 * @template T
 * @param {!yfiles.lang.Class} tType
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.removeLookup = function(tType) {};

/**
 * Remove a serialization property that has been set by {\@link yfiles.graphml.GraphMLWriter#setSerializationProperty}.
 * @see yfiles.graphml.IWriteContext#getSerializationProperty
 * @param {string} key The key for the property.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.removeSerializationProperty = function(key) {};

/**
 * Serialize <code>item</code>.
 * <p>
 * Typically, this method is called only indirectly by calls to {\@link yfiles.graphml.IWriteContext#serializeCore}. This
 * implementation calls {\@link yfiles.graphml.GraphMLWriter#onHandleSerialization}, which in turn raises the {\@link yfiles.graphml.GraphMLWriter#addHandleSerializationListener HandleSerialization}
 * event.
 * </p>
 * Type parameter <code>T</code>: The desired type of the result.
 * @throws {yfiles.graphml.SerializationNotSupportedError} <code>SerializationNotSupportedException</code> if <code>item</code> cannot be serialized.
 * @see yfiles.graphml.IWriteContext#serializeCore
 * @see yfiles.graphml.GraphMLWriter#addHandleSerializationListener
 * @protected
 * @template T
 * @param {!yfiles.lang.Class} targetType The desired type of the result.
 * @param {?} context The current parse context.
 * @param {T} item The object that should be serialized.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.serialize = function(targetType, context, item) {};

/**
 * Register an implementation of <code>T</code> for use with {\@link yfiles.graphml.GraphMLWriter#lookup}.
 * Type parameter <code>T</code>: The type of <code>instance</code>.
 * @template T
 * @param {!yfiles.lang.Class} tType The type of <code>instance</code>.
 * @param {T} instance The implementation of <code>T</code> for lookup retrieval.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.setLookup = function(tType, instance) {};

/**
 * Set a serialization property that allows to fine tune the write process.
 * @see yfiles.graphml.IWriteContext#getSerializationProperty
 * @param {string} key The key for the property.
 * @param {!Object} value The property value.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.setSerializationProperty = function(key, value) {};

/**
 * Write the GraphML representation of <code>graph</code>, using <code>writer</code> for the actual XML generation.
 * <p>
 * Typically, this method is called indirectly from {\@link yfiles.graphml.GraphMLIOHandler#write}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#write
 * @param {?} graph The graph instance that is populated.
 * @param {?} writer The writer that actually writes the XML content.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.write = function(graph, writer) {};

/**
 * Adds the given listener for the <code>HandleSerialization</code> event that occurs when XML content is about to be serialized.
 * <p>
 * Subscribe to this event to provide custom serialization handling for XML content.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * The current item is provided by {\@link yfiles.graphml.HandleSerializationEventArgs#item}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addHandleSerializationListener
 * @see yfiles.graphml.GraphMLWriter#removeHandleSerializationListener
 * @param {function(!Object, !yfiles.graphml.HandleSerializationEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.addHandleSerializationListener = function(listener) {};

/**
 * Removes the given listener for the <code>HandleSerialization</code> event that occurs when XML content is about to be serialized.
 * <p>
 * Subscribe to this event to provide custom serialization handling for XML content.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * The current item is provided by {\@link yfiles.graphml.HandleSerializationEventArgs#item}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addHandleSerializationListener
 * @see yfiles.graphml.GraphMLWriter#addHandleSerializationListener
 * @param {function(!Object, !yfiles.graphml.HandleSerializationEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.removeHandleSerializationListener = function(listener) {};

/**
 * Adds the given listener for the <code>QueryOutputHandlers</code> event that occurs when {\@link yfiles.graphml.IOutputHandler}s are queried.
 * <p>
 * Subscribe to this event to dynamically register one or more {\@link yfiles.graphml.IOutputHandler} instance(s) for a given
 * GraphML attribute key definition.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * If you want to register an {\@link yfiles.graphml.IOutputHandler} for this GraphML attribute, you can add the handler with
 * {\@link yfiles.graphml.QueryOutputHandlersEventArgs#addOutputHandler}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addQueryOutputHandlersListener
 * @see yfiles.graphml.GraphMLWriter#removeQueryOutputHandlersListener
 * @param {function(!Object, !yfiles.graphml.QueryOutputHandlersEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.addQueryOutputHandlersListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryOutputHandlers</code> event that occurs when
 * {\@link yfiles.graphml.IOutputHandler}s are queried.
 * <p>
 * Subscribe to this event to dynamically register one or more {\@link yfiles.graphml.IOutputHandler} instance(s) for a given
 * GraphML attribute key definition.
 * </p>
 * <p>
 * The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called
 * earlier.
 * </p>
 * <p>
 * If you want to register an {\@link yfiles.graphml.IOutputHandler} for this GraphML attribute, you can add the handler with
 * {\@link yfiles.graphml.QueryOutputHandlersEventArgs#addOutputHandler}.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addQueryOutputHandlersListener
 * @see yfiles.graphml.GraphMLWriter#addQueryOutputHandlersListener
 * @param {function(!Object, !yfiles.graphml.QueryOutputHandlersEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.removeQueryOutputHandlersListener = function(listener) {};

/**
 * Adds the given listener for the <code>QueryReferenceId</code> event that occurs when a reference is queried.
 * <p>
 * This event can be used to provide names of external references for objects.
 * </p>
 * <p>
 * These reference targets are not serialized to the GraphML file.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addQueryReferenceIdListener
 * @see yfiles.graphml.GraphMLWriter#removeQueryReferenceIdListener
 * @param {function(!Object, !yfiles.graphml.QueryReferenceIdEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.addQueryReferenceIdListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryReferenceId</code> event that occurs when a reference is queried.
 * <p>
 * This event can be used to provide names of external references for objects.
 * </p>
 * <p>
 * These reference targets are not serialized to the GraphML file.
 * </p>
 * @see yfiles.graphml.GraphMLIOHandler#addQueryReferenceIdListener
 * @see yfiles.graphml.GraphMLWriter#addQueryReferenceIdListener
 * @param {function(!Object, !yfiles.graphml.QueryReferenceIdEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.removeQueryReferenceIdListener = function(listener) {};

/**
 * Adds the given listener for the <code>Written</code> event that occurs when the writing of a document has just been finished.
 * @see yfiles.graphml.GraphMLWriter#onWritten
 * @see yfiles.graphml.GraphMLWriter#removeWrittenListener
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.addWrittenListener = function(listener) {};

/**
 * Removes the given listener for the <code>Written</code> event that occurs when the writing of a document has just been finished.
 * @see yfiles.graphml.GraphMLWriter#onWritten
 * @see yfiles.graphml.GraphMLWriter#addWrittenListener
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.removeWrittenListener = function(listener) {};

/**
 * Adds the given listener for the <code>Writing</code> event that occurs when the writing of a document is just about to begin.
 * <p>
 * This event can be used to register to the fine-grained events available in the {\@link yfiles.graphml.WriteEventArgs#context}'s {\@link yfiles.graphml.IWriteContext#writeEvents} and to configure the writing process
 * on a per write case.
 * </p>
 * @see yfiles.graphml.GraphMLWriter#onWriting
 * @see yfiles.graphml.GraphMLWriter#removeWritingListener
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.addWritingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Writing</code> event that occurs when the writing of a document is just about to begin.
 * <p>
 * This event can be used to register to the fine-grained events available in the {\@link yfiles.graphml.WriteEventArgs#context}'s {\@link yfiles.graphml.IWriteContext#writeEvents} and to configure the writing process
 * on a per write case.
 * </p>
 * @see yfiles.graphml.GraphMLWriter#onWriting
 * @see yfiles.graphml.GraphMLWriter#addWritingListener
 * @param {function(!Object, !yfiles.graphml.WriteEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graphml.GraphMLWriter.prototype.removeWritingListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.HandleSerializationEventArgs = function() {};
 /** @type {!Object} */
yfiles.graphml.HandleSerializationEventArgs.prototype.item;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.HandleSerializationEventArgs.prototype.sourceType;
 /** @type {boolean} */
yfiles.graphml.HandleSerializationEventArgs.prototype.handled;
 /** @type {?} */
yfiles.graphml.HandleSerializationEventArgs.prototype.context;
 /** @type {?} */
yfiles.graphml.HandleSerializationEventArgs.prototype.writer;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.HandleSerializationEventArgs.$class;

/**
 * Replaces the {\@link yfiles.graphml.HandleSerializationEventArgs#item} using a substitute for serialization.
 * <p>
 * This method can be used to replace the {\@link yfiles.graphml.HandleSerializationEventArgs#item} and {\@link yfiles.graphml.HandleSerializationEventArgs#sourceType} property so that the serialization chain can be traversed with a
 * substituted item. If this method has been called the {\@link yfiles.graphml.HandleSerializationEventArgs#handled} property should not be set to <code>true</code>.
 * </p>
 * @param {!Object} item The substitute to assign to the {\@link #item} property.
 * @param {!yfiles.lang.Class} serializationType The serialization type to assign to the {\@link #sourceType} property.
 * @return {void}
 */
yfiles.graphml.HandleSerializationEventArgs.prototype.replaceItem = function(item, serializationType) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.IGraphElementIdProvider = function() {};

/**
 * Get an ID for the specified <code>edge</code> object
 * @abstract
 * @param {?} context The current write context, for further information to the provider
 * @param {?} edge The current graph object
 * @return {string} an ID for the specified edge object
 */
yfiles.graphml.IGraphElementIdProvider.prototype.getEdgeId = function(context, edge) {};

/**
 * Get an ID for the specified <code>graph</code> object
 * @abstract
 * @param {?} context The current write context, for further information to the provider
 * @param {?} graph The current graph object
 * @return {string} an ID for the specified graph object
 */
yfiles.graphml.IGraphElementIdProvider.prototype.getGraphId = function(context, graph) {};

/**
 * Get an ID for the specified <code>node</code> object
 * @abstract
 * @param {?} context The current write context, for further information to the provider
 * @param {?} node The current graph object
 * @return {string} an ID for the specified graph object
 */
yfiles.graphml.IGraphElementIdProvider.prototype.getNodeId = function(context, node) {};

/**
 * Get an ID for the specified <code>port</code> object
 * @abstract
 * @param {?} context The current write context, for further information to the provider
 * @param {?} port The current port object
 * @return {string} an ID for the specified port object
 */
yfiles.graphml.IGraphElementIdProvider.prototype.getPortId = function(context, port) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IGraphElementIdProvider;
/**
 * @record
 * @struct
 */
yfiles.graphml.MapperOutputHandler = function() {};
 /** @type {!yfiles.graph.MapperMetadata} */
yfiles.graphml.MapperOutputHandler.prototype.mapperMetadata;
 /** @type {?<TKey, TData>} */
yfiles.graphml.MapperOutputHandler.prototype.mapper;
 /** @type {function(!Object, !yfiles.graphml.HandleSerializationEventArgs): void} */
yfiles.graphml.MapperOutputHandler.prototype.serializer;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.MapperOutputHandler.prototype.sourceType;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.MapperOutputHandler.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.OutputHandlerBase = function() {};
 /** @type {TData} */
yfiles.graphml.OutputHandlerBase.prototype.defaultValue;
 /** @type {boolean} */
yfiles.graphml.OutputHandlerBase.prototype.defaultExists;
 /** @type {yfiles.graphml.WritePrecedence} */
yfiles.graphml.OutputHandlerBase.prototype.precedence;
 /** @type {?<!yfiles.graphml.GraphMLXmlAttribute>} */
yfiles.graphml.OutputHandlerBase.prototype.keyDefinitionAttributes;
 /** @type {?<!yfiles.graphml.GraphMLXmlAttribute>} */
yfiles.graphml.OutputHandlerBase.prototype.dataTagAttributes;
 /** @type {boolean} */
yfiles.graphml.OutputHandlerBase.prototype.writeKeyDefault;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.OutputHandlerBase.$class;

/**
 * Callback method that obtains the data for the given key.
 * @protected
 * @abstract
 * @param {?} context The context.
 * @param {TKey} key The key.
 * @return {TData} The data that is associated with the key.
 */
yfiles.graphml.OutputHandlerBase.prototype.getValue = function(context, key) {};

/**
 * Determines whether in the current context, the value is the default value and therefore no data element needs to be
 * written.
 * <p>
 * This implementation will return <code>false</code> if no {\@link yfiles.graphml.OutputHandlerBase.<TKey,TData>#defaultExists default has been set}. Otherwise it will use {\@link yfiles.graphml.OutputHandlerBase.<TKey,TData>#getValue} and compare the result
 * with the {\@link yfiles.graphml.OutputHandlerBase.<TKey,TData>#defaultValue} to determine whether they are equal and therefore no data needs to be written.
 * </p>
 * @param {?} context The context.
 * @return {boolean} <code>true</code> if for the current context the default value applies and therefore no data element needs to be written.
 */
yfiles.graphml.OutputHandlerBase.prototype.isDefaultValue = function(context) {};

/**
 * Sets the name for the key definition.
 * @param {string} name The name of the key element.
 * @return {void}
 */
yfiles.graphml.OutputHandlerBase.prototype.setKeyDefinitionName = function(name) {};

/**
 * Sets the scope for the key definition.
 * <p>
 * Note that the official GraphML schema does not support the {\@link yfiles.graphml.KeyScope#GRAPHML} so this implementation will
 * silently ignore this which will result in {\@link yfiles.graphml.KeyScope#ALL} implicitly being defined.
 * </p>
 * @param {yfiles.graphml.KeyScope} scope The scope of the key element.
 * @return {void}
 */
yfiles.graphml.OutputHandlerBase.prototype.setKeyDefinitionScope = function(scope) {};

/**
 * Sets the key type for the key definition.
 * @param {yfiles.graphml.KeyType} type The type of the key element.
 * @return {void}
 */
yfiles.graphml.OutputHandlerBase.prototype.setKeyDefinitionType = function(type) {};

/**
 * Sets an optional URI for the key definition.
 * <p>
 * By default, no URI is set.
 * </p>
 * @param {string} uri The URI of the key element.
 * @return {void}
 */
yfiles.graphml.OutputHandlerBase.prototype.setKeyDefinitionUri = function(uri) {};

/**
 * Writes the contents of the key definition.
 * <p>
 * Depending on whether {\@link yfiles.graphml.OutputHandlerBase.<TKey,TData>#writeKeyDefault} is enabled and {\@link yfiles.graphml.OutputHandlerBase.<TKey,TData>#defaultExists} is <code>true</code>, this method will write the GraphML 'default' element and use {\@link yfiles.graphml.OutputHandlerBase.<TKey,TData>#writeValueCore}
 * to serialize the {\@link yfiles.graphml.OutputHandlerBase.<TKey,TData>#defaultValue}.
 * </p>
 * @param {?} context The context.
 * @return {void}
 */
yfiles.graphml.OutputHandlerBase.prototype.writeKeyDefinitionContent = function(context) {};

/**
 * Actually writes the value for the current context.
 * <p>
 * This method will use {\@link yfiles.graphml.OutputHandlerBase.<TKey,TData>#getValue} to obtain the data and delegate to {\@link yfiles.graphml.OutputHandlerBase.<TKey,TData>#writeValueCore} to perform the actual serialization.
 * </p>
 * @param {?} context The context.
 * @return {void}
 */
yfiles.graphml.OutputHandlerBase.prototype.writeValue = function(context) {};

/**
 * Callback method that performs the actual writing of the data.
 * @protected
 * @abstract
 * @param {?} context The context.
 * @param {TData} data The data.
 * @return {void}
 */
yfiles.graphml.OutputHandlerBase.prototype.writeValueCore = function(context, data) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.QueryOutputHandlersEventArgs = function() {};
 /** @type {yfiles.graphml.KeyScope} */
yfiles.graphml.QueryOutputHandlersEventArgs.prototype.scope;
 /** @type {?<?>} */
yfiles.graphml.QueryOutputHandlersEventArgs.prototype.handlers;
 /** @type {?} */
yfiles.graphml.QueryOutputHandlersEventArgs.prototype.context;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.QueryOutputHandlersEventArgs.$class;

/**
 * Adds the given output handler to the set of registered output handlers for the given scope.
 * @param {?} handler The handler to add.
 * @return {void}
 */
yfiles.graphml.QueryOutputHandlersEventArgs.prototype.addOutputHandler = function(handler) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.XmlWriter = function() {};
 /** @type {boolean} */
yfiles.graphml.XmlWriter.prototype.indent;
 /** @type {?} */
yfiles.graphml.XmlWriter.prototype.namespaceManager;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.XmlWriter.$class;

/**
 *
 * @protected
 * @param {boolean} addEndTag
 * @return {void}
 */
yfiles.graphml.XmlWriter.prototype.closeCurrentElement = function(addEndTag) {};

/**
 * Factory method that creates the namespace manager for this instance.
 * @protected
 * @return {?} A new manager instance.
 */
yfiles.graphml.XmlWriter.prototype.createNamespaceManager = function() {};

/**
 *
 * @return {void}
 */
yfiles.graphml.XmlWriter.prototype.flushDocument = function() {};

/**
 *
 * @return {string}
 */
yfiles.graphml.XmlWriter.prototype.getXmlString = function() {};

/**
 *
 * @param {string} prefix
 * @param {string} localName
 * @param {string} ns
 * @param {string} value
 * @return {?}
 */
yfiles.graphml.XmlWriter.prototype.writeAttributeNS = function(prefix, localName, ns, value) {};

/**
 *
 * @param {string} content
 * @return {?}
 */
yfiles.graphml.XmlWriter.prototype.writeCData = function(content) {};

/**
 *
 * @param {string} comment
 * @return {?}
 */
yfiles.graphml.XmlWriter.prototype.writeComment = function(comment) {};

/**
 *
 * @param {!Document} fragment
 * @return {?}
 */
yfiles.graphml.XmlWriter.prototype.writeDocumentFragment = function(fragment) {};

/**
 *
 * @return {void}
 */
yfiles.graphml.XmlWriter.prototype.writeEndDocument = function() {};

/**
 *
 * @return {?}
 */
yfiles.graphml.XmlWriter.prototype.writeEndElement = function() {};

/**
 *
 * @param {string} target
 * @param {string} data
 * @return {?}
 */
yfiles.graphml.XmlWriter.prototype.writeProcessingInstruction = function(target, data) {};

/**
 *
 * @return {?}
 */
yfiles.graphml.XmlWriter.prototype.writeStartDocument = function() {};

/**
 *
 *
 * @param {string} prefix_or_localName
 * @param {string} localName_or_ns
 * @param {string=} ns
 * @return {?}
 */
yfiles.graphml.XmlWriter.prototype.writeStartElement = function(prefix_or_localName, localName_or_ns, ns) {};

/**
 *
 * @param {string} s
 * @return {?}
 */
yfiles.graphml.XmlWriter.prototype.writeString = function(s) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.IReferenceHandle = function() {};
 /** @type {yfiles.graphml.GraphMLReferenceType} */
yfiles.graphml.IReferenceHandle.prototype.referenceType;
 /** @type {!Object} */
yfiles.graphml.IReferenceHandle.prototype.subject;
 /** @type {string} */
yfiles.graphml.IReferenceHandle.prototype.id;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IReferenceHandle;

/** @const */
yfiles.graphml.SharingState = {};
/** @const {number} */
yfiles.graphml.SharingState.UNSHARED;
/** @const {number} */
yfiles.graphml.SharingState.FIRST_SEEN;
/** @const {number} */
yfiles.graphml.SharingState.DUPLICATE;
/**
 * @record
 * @struct
 */
yfiles.graphml.IReferenceHandler = function() {};
 /** @type {?<?>} */
yfiles.graphml.IReferenceHandler.prototype.internalHandles;

/**
 * Gets the reference handle for a given subject.
 * @see yfiles.graphml.IReferenceHandle
 * @see yfiles.graphml.IReferenceHandle#subject
 * @abstract
 * @param {?} context The current write context.
 * @param {!Object} subject The subject.
 * @return {?} A handle for the resource <code>subject</code>, or <code>null</code> if the resource is not registered.
 */
yfiles.graphml.IReferenceHandler.prototype.getHandle = function(context, subject) {};

/**
 * Unregister a shared resource.
 * <p>
 * This allows to explicitly mark a resource as unshared even if it is referenced multiple times in the object graph. If a
 * resource has already been registered with {\@link yfiles.graphml.IReferenceHandler#registerResource}, it will be unmarked. In
 * addition, subsequent calls to {\@link yfiles.graphml.IReferenceHandler#registerResource} for the same reference won't mark the
 * resource as shared again.
 * </p>
 * @see yfiles.graphml.IReferenceHandler#registerResource
 * @see yfiles.graphml.GraphMLAttribute#shareable
 * @abstract
 * @param {?} context The current write context.
 * @param {!Object} subject The resource to register.
 * @return {void}
 */
yfiles.graphml.IReferenceHandler.prototype.markAsUnshared = function(context, subject) {};

/**
 * Register a shared resource.
 * @abstract
 * @param {?} context The current write context.
 * @param {!Object} subject The resource to register.
 * @return {yfiles.graphml.SharingState} <code>true</code> iff the resource needs to be serialized; otherwise the resource is either a duplicate resource or is declared
 * externally and does not need any additional handling.
 */
yfiles.graphml.IReferenceHandler.prototype.registerResource = function(context, subject) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IReferenceHandler;

/** @const */
yfiles.graphml.GraphMLReferenceType = {};
/** @const {number} */
yfiles.graphml.GraphMLReferenceType.INTERNAL;
/** @const {number} */
yfiles.graphml.GraphMLReferenceType.EXTERNAL;
/**
 * @record
 * @struct
 */
yfiles.graphml.ResolveReferenceEventArgs = function() {};
 /** @type {string} */
yfiles.graphml.ResolveReferenceEventArgs.prototype.referenceId;
 /** @type {!Object} */
yfiles.graphml.ResolveReferenceEventArgs.prototype.value;
 /** @type {boolean} */
yfiles.graphml.ResolveReferenceEventArgs.prototype.handled;
 /** @type {?} */
yfiles.graphml.ResolveReferenceEventArgs.prototype.context;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.ResolveReferenceEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.QueryReferenceIdEventArgs = function() {};
 /** @type {string} */
yfiles.graphml.QueryReferenceIdEventArgs.prototype.referenceId;
 /** @type {yfiles.graphml.GraphMLReferenceType} */
yfiles.graphml.QueryReferenceIdEventArgs.prototype.referenceType;
 /** @type {!Object} */
yfiles.graphml.QueryReferenceIdEventArgs.prototype.value;
 /** @type {boolean} */
yfiles.graphml.QueryReferenceIdEventArgs.prototype.handled;
 /** @type {?} */
yfiles.graphml.QueryReferenceIdEventArgs.prototype.context;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.QueryReferenceIdEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.GraphMLParseValueSerializerContext = function() {};
 /** @type {!Object} */
yfiles.graphml.GraphMLParseValueSerializerContext.prototype.owner;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLParseValueSerializerContext.$class;

/**
 *
 *
 * @param {!yfiles.graphml.Property|!yfiles.lang.Class} property_or_type
 * @return {!yfiles.graphml.ValueSerializer}
 */
yfiles.graphml.GraphMLParseValueSerializerContext.prototype.getValueSerializerFor = function(property_or_type) {};

/**
 * Returns the wrapped {\@link yfiles.graphml.IParseContext} for this serviceType, otherwise <code>null</code>
 * @param {!yfiles.lang.Class} serviceType The serviceType
 * @return {!Object} the wrapped {\@link } for this serviceType, otherwise <code>null</code>
 */
yfiles.graphml.GraphMLParseValueSerializerContext.prototype.lookup = function(serviceType) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.GraphMLWriteValueSerializerContext = function() {};
 /** @type {!Object} */
yfiles.graphml.GraphMLWriteValueSerializerContext.prototype.owner;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.GraphMLWriteValueSerializerContext.$class;

/**
 *
 *
 * @param {!yfiles.graphml.Property|!yfiles.lang.Class} property_or_type
 * @return {!yfiles.graphml.ValueSerializer}
 */
yfiles.graphml.GraphMLWriteValueSerializerContext.prototype.getValueSerializerFor = function(property_or_type) {};

/**
 * Returns the wrapped {\@link yfiles.graphml.IWriteContext} for this serviceType, otherwise <code>null</code>
 * @param {!yfiles.lang.Class} serviceType The serviceType
 * @return {!Object} the wrapped {\@link } for this serviceType, otherwise <code>null</code>
 */
yfiles.graphml.GraphMLWriteValueSerializerContext.prototype.lookup = function(serviceType) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.QueryNameEventArgs = function() {};
 /** @type {!yfiles.graphml.XmlName} */
yfiles.graphml.QueryNameEventArgs.prototype.result;
 /** @type {boolean} */
yfiles.graphml.QueryNameEventArgs.prototype.handled;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.QueryNameEventArgs.prototype.type;
 /** @type {?} */
yfiles.graphml.QueryNameEventArgs.prototype.context;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.QueryNameEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.QueryTypeEventArgs = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.QueryTypeEventArgs.prototype.result;
 /** @type {boolean} */
yfiles.graphml.QueryTypeEventArgs.prototype.handled;
 /** @type {!yfiles.graphml.XmlName} */
yfiles.graphml.QueryTypeEventArgs.prototype.xmlName;
 /** @type {?} */
yfiles.graphml.QueryTypeEventArgs.prototype.context;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.QueryTypeEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graphml.XamlReader = function() {};
 /** @type {!yfiles.graphml.XamlReader} */
yfiles.graphml.XamlReader.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.XamlReader.$class;

/**
 * Deserializes the specified element node in the context to an instance.
 * @param {?} context The context.
 * @param {!Element} element The XML element node.
 * @return {!Object} The instance that is described in the XML.
 */
yfiles.graphml.XamlReader.prototype.deserialize = function(context, element) {};
/**
 * @record
 * @struct
 */
yfiles.graphml.IXamlPrefixMapper = function() {};

/**
 * Gets the namespace for the given prefix.
 * @abstract
 * @param {string} prefix The prefix.
 * @return {string} The namespace.
 */
yfiles.graphml.IXamlPrefixMapper.prototype.getNamespaceOfPrefix = function(prefix) {};

/**
 * Gets the prefix of namespace.
 * @abstract
 * @param {string} ns The namespace.
 * @return {string} The prefix to use.
 */
yfiles.graphml.IXamlPrefixMapper.prototype.getPrefixOfNamespace = function(ns) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graphml.IXamlPrefixMapper;
/**
 * @record
 * @struct
 */
yfiles.graphml.XamlSerializer = function() {};
 /** @type {!yfiles.graphml.XamlSerializer} */
yfiles.graphml.XamlSerializer.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.graphml.XamlSerializer.$class;

/**
 * Serialize the given object to a {\@link yfiles.graphml.IXmlWriter}
 * <p>
 * This implementation already provides the toplevel XML element with an appropriate tag name.
 * </p>
 * @param {?} context The current write context
 * @param {!Object} subject The actual object
 * @return {void}
 */
yfiles.graphml.XamlSerializer.prototype.serialize = function(context, subject) {};
/** @const */
yfiles.view = {};
/**
 * @record
 * @struct
 */
yfiles.view.Animator = function() {};
 /** @type {boolean} */
yfiles.view.Animator.prototype.allowUserInteraction;
 /** @type {!yfiles.view.CanvasComponent} */
yfiles.view.Animator.prototype.canvasComponent;
 /** @type {boolean} */
yfiles.view.Animator.prototype.autoInvalidation;
 /** @type {!yfiles.lang.Class} */
yfiles.view.Animator.$class;

/**
 * Animates the given animation instance and triggers the callback upon completion.
 * Starts animating the given animation for the specified duration.
 * @param {?|function(number): void} animation_or_callback The animation to perform. / The callback to use for the animation.
 * @param {!yfiles.lang.TimeSpan=} duration The duration in milliseconds that the animation should last.
 * @return {!Promise<?>}
 */
yfiles.view.Animator.prototype.animate = function(animation_or_callback, duration) {};

/**
 * Stops all running animations.
 * @return {void}
 */
yfiles.view.Animator.prototype.destroy = function() {};

/**
 * Invalidates the control if {\@link yfiles.view.Animator#autoInvalidation} is set to <code>true</code>.
 * <p>
 * This implementation calls {\@link yfiles.view.CanvasComponent#updateVisual }.
 * </p>
 * @protected
 * @param {!yfiles.view.CanvasComponent} canvas The control.
 * @return {void}
 */
yfiles.view.Animator.prototype.invalidateComponent = function(canvas) {};
/**
 * @record
 * @struct
 */
yfiles.view.IAnimation = function() {};
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.view.IAnimation.prototype.preferredDuration;

/**
 * Does the animation according to the relative animation time.
 * <p>
 * The animation starts with the time 0 and ends with time 1.
 * </p>
 * @abstract
 * @param {number} time the animation time [0,1]
 * @return {void}
 */
yfiles.view.IAnimation.prototype.animate = function(time) {};

/**
 * Cleans up after an animation has finished.
 * @abstract
 * @return {void}
 */
yfiles.view.IAnimation.prototype.cleanup = function() {};

/**
 * Creates an eased animation for the given base animation.
 * <p>
 * The animation speed linearly increases upto a <code>easeIn</code> and linearly decreases from
 * <code>easeOut</code>. Between those two points, the animation speed is constant.
 * </p>
 * <p>
 * The duration of the ease in and ease out is determined by a mapping [0,1] → [0,1]. The mapping has to be increasing to
 * preserve the order of the frames in the decorated animation. In general, we consider continuously differentiable
 * functions <i>f</i> where integral of <i>f</i>′ equals 1 a suitable choice for the mapping.
 * </p>
 * Creates an eased animation for the given base animation.
 * <p>
 * The animation speed linearly increases upto a <code>easeIn</code> and linearly decreases from
 * <code>easeOut</code>. Between those two points, the animation speed is constant.
 * </p>
 * <p>
 * The duration of the ease in and ease out is determined by a mapping [0,1] → [0,1]. The mapping has to be increasing to
 * preserve the order of the frames in the decorated animation. In general, we consider continuously differentiable
 * functions <i>f</i> where integral of <i>f</i>′ equals 1 a suitable choice for the mapping.
 * </p>
 * @param {number|{easeIn: number, easeOut: number}=} easeIn_or_options
 * @param {number=} easeOut
 * @return {?}
 */
yfiles.view.IAnimation.prototype.createEasedAnimation = function(easeIn_or_options, easeOut) {};

/**
 * Initializes the animation.
 * <p>
 * Call this method once before subsequent calls to {\@link yfiles.view.IAnimation#animate}.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.view.IAnimation.prototype.initialize = function() {};
 /** @type {{createEdgeSegmentAnimation: function(?, ?, !Array<?>, !yfiles.geometry.Point, !yfiles.geometry.Point, !yfiles.lang.TimeSpan): ?, createGraphAnimation: function(?, ?<?, ?>, ?<?, !Array<?>>, ?<?, ?>, ?<?, ?>, !yfiles.lang.TimeSpan): ?, createLabelAnimation: function(?, ?, ?, !yfiles.lang.TimeSpan): ?, createLayoutAnimation: function(?, !yfiles.layout.CopiedLayoutGraph, !yfiles.lang.TimeSpan): ?, createNodeAnimation: function(?, ?, ?, !yfiles.lang.TimeSpan): ?, createParallelAnimation: function(?<?>, boolean): ?, createPathAnimation: function(!yfiles.geometry.GeneralPath, ?, !yfiles.lang.TimeSpan): ?, createPortAnimation: function(?, ?, ?, !yfiles.lang.TimeSpan): ?, createTableAnimation: function(?, !Array<number>, !Array<number>): ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IAnimation;
/**
 * @record
 * @struct
 */
yfiles.view.ViewportAnimation = function() {};
 /** @type {!yfiles.geometry.Rect} */
yfiles.view.ViewportAnimation.prototype.targetBounds;
 /** @type {boolean} */
yfiles.view.ViewportAnimation.prototype.considerViewportLimiter;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.view.ViewportAnimation.prototype.preferredDuration;
 /** @type {number} */
yfiles.view.ViewportAnimation.prototype.maximumTargetZoom;
 /** @type {yfiles.view.ScrollBarVisibility} */
yfiles.view.ViewportAnimation.prototype.scrollBarVisibility;
 /** @type {!yfiles.geometry.Insets} */
yfiles.view.ViewportAnimation.prototype.targetViewMargins;
 /** @type {!yfiles.lang.Class} */
yfiles.view.ViewportAnimation.$class;

/**
 *
 * @param {number} time
 * @return {void}
 */
yfiles.view.ViewportAnimation.prototype.animate = function(time) {};

/**
 * Effectively applies the center point value.
 * @protected
 * @param {!yfiles.geometry.Point} focus
 * @return {void}
 */
yfiles.view.ViewportAnimation.prototype.applyCenterPoint = function(focus) {};

/**
 * Effectively applies the view point value.
 * @protected
 * @param {!yfiles.geometry.Point} focus
 * @return {void}
 */
yfiles.view.ViewportAnimation.prototype.applyViewPoint = function(focus) {};

/**
 * Effectively applies the zoom value.
 * @protected
 * @param {number} value
 * @return {void}
 */
yfiles.view.ViewportAnimation.prototype.applyZoom = function(value) {};

/**
 * Cancels this viewport animation so that subsequent calls to {\@link yfiles.view.ViewportAnimation#animate} or {\@link yfiles.view.ViewportAnimation#cleanup}
 * won't affect the viewport anymore.
 * @return {void}
 */
yfiles.view.ViewportAnimation.prototype.cancel = function() {};

/**
 * Cleans up after the animation.
 * @return {void}
 */
yfiles.view.ViewportAnimation.prototype.cleanup = function() {};

/**
 * Initializes this animation.
 * <p>
 * This has to be called once before any calls to {\@link yfiles.view.ViewportAnimation#animate}. An instance of {\@link yfiles.view.ViewportAnimation}
 * can be reused after an animation by setting new {\@link yfiles.view.ViewportAnimation#targetBounds} or a new {\@link yfiles.view.ViewportAnimation#preferredDuration} and calling Initialize() again.
 * </p>
 * @return {void}
 */
yfiles.view.ViewportAnimation.prototype.initialize = function() {};

/** @const */
yfiles.view.ScrollBarVisibility = {};
/** @const {number} */
yfiles.view.ScrollBarVisibility.NEVER;
/** @const {number} */
yfiles.view.ScrollBarVisibility.AS_NEEDED;
/** @const {number} */
yfiles.view.ScrollBarVisibility.ALWAYS;

/** @const */
yfiles.view.MouseButtons = {};
/** @const {number} */
yfiles.view.MouseButtons.NONE;
/** @const {number} */
yfiles.view.MouseButtons.LEFT;
/** @const {number} */
yfiles.view.MouseButtons.RIGHT;
/** @const {number} */
yfiles.view.MouseButtons.MIDDLE;
/** @const {number} */
yfiles.view.MouseButtons.X1;
/** @const {number} */
yfiles.view.MouseButtons.X2;

/** @const */
yfiles.view.MouseWheelBehaviors = {};
/** @const {number} */
yfiles.view.MouseWheelBehaviors.NONE;
/** @const {number} */
yfiles.view.MouseWheelBehaviors.ZOOM;
/** @const {number} */
yfiles.view.MouseWheelBehaviors.SCROLL;
/** @const {number} */
yfiles.view.MouseWheelBehaviors.ONLY_WHEN_FOCUSED;
/**
 * @record
 * @struct
 */
yfiles.view.PrepareRenderContextEventArgs = function() {};
 /** @type {?} */
yfiles.view.PrepareRenderContextEventArgs.prototype.context;
 /** @type {!yfiles.lang.Class} */
yfiles.view.PrepareRenderContextEventArgs.$class;

/** @const */
yfiles.view.SizeChangedDetectionMode = {};
/** @const {number} */
yfiles.view.SizeChangedDetectionMode.NONE;
/** @const {number} */
yfiles.view.SizeChangedDetectionMode.SENSOR;
/** @const {number} */
yfiles.view.SizeChangedDetectionMode.TIMER;
/** @const {number} */
yfiles.view.SizeChangedDetectionMode.AUTO;
/**
 * @record
 * @struct
 */
yfiles.view.SizeChangedEventArgs = function() {};
 /** @type {!HTMLElement} */
yfiles.view.SizeChangedEventArgs.prototype.source;
 /** @type {!yfiles.geometry.Size} */
yfiles.view.SizeChangedEventArgs.prototype.oldSize;
 /** @type {!yfiles.lang.Class} */
yfiles.view.SizeChangedEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.view.CanvasComponent = function() {};
 /** @type {!yfiles.view.DropTarget} */
yfiles.view.CanvasComponent.prototype.dropTarget;
 /** @type {!HTMLDivElement} */
yfiles.view.CanvasComponent.prototype.div;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.captureAllKeyboardInput;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.captureAllPointerInput;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.mouseCaptureEnabled;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.hasMouseCapture;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.focused;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.rightToLeft;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.preventFocusScrolling;
 /** @type {!yfiles.view.SvgDefsManager} */
yfiles.view.CanvasComponent.prototype.svgDefsManager;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.useGlassPane;
 /** @type {!yfiles.view.ViewportLimiter} */
yfiles.view.CanvasComponent.prototype.viewportLimiter;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.editable;
 /** @type {yfiles.view.MouseWheelBehaviors} */
yfiles.view.CanvasComponent.prototype.mouseWheelBehavior;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.view.CanvasComponent.prototype.centerZoomEventRecognizer;
 /** @type {yfiles.view.ScrollBarVisibility} */
yfiles.view.CanvasComponent.prototype.verticalScrollBarPolicy;
 /** @type {yfiles.view.ScrollBarVisibility} */
yfiles.view.CanvasComponent.prototype.horizontalScrollBarPolicy;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.animateScrollCommands;
 /** @type {!yfiles.geometry.Rect} */
yfiles.view.CanvasComponent.prototype.contentRect;
 /** @type {!yfiles.geometry.Insets} */
yfiles.view.CanvasComponent.prototype.fitContentViewMargins;
 /** @type {?<!yfiles.view.TouchDevice>} */
yfiles.view.CanvasComponent.prototype.currentTouchDevices;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.isTouchDeviceDown;
 /** @type {!yfiles.view.TouchEventArgs} */
yfiles.view.CanvasComponent.prototype.lastTouchEvent;
 /** @type {!yfiles.view.MouseEventArgs} */
yfiles.view.CanvasComponent.prototype.lastMouseEvent;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.CanvasComponent.prototype.lastEventLocation;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.inputMode;
 /** @type {number} */
yfiles.view.CanvasComponent.prototype.hitTestRadius;
 /** @type {number} */
yfiles.view.CanvasComponent.prototype.zoom;
 /** @type {number} */
yfiles.view.CanvasComponent.prototype.minimumZoom;
 /** @type {number} */
yfiles.view.CanvasComponent.prototype.maximumZoom;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.CanvasComponent.prototype.viewPoint;
 /** @type {!yfiles.geometry.Size} */
yfiles.view.CanvasComponent.prototype.innerSize;
 /** @type {!yfiles.geometry.Size} */
yfiles.view.CanvasComponent.prototype.size;
 /** @type {!yfiles.geometry.Rect} */
yfiles.view.CanvasComponent.prototype.viewport;
 /** @type {!yfiles.graph.LookupChain} */
yfiles.view.CanvasComponent.prototype.inputModeContextLookupChain;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.canvasContext;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.CanvasComponent.prototype.center;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.autoDrag;
 /** @type {yfiles.view.VisualCachingPolicy} */
yfiles.view.CanvasComponent.prototype.visualCaching;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.rootGroup;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.contentGroup;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.highlightGroup;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.focusGroup;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.selectionGroup;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.inputModeGroup;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.backgroundGroup;
 /** @type {yfiles.view.ShapeRenderingType} */
yfiles.view.CanvasComponent.prototype.shapeRendering;
 /** @type {yfiles.view.ImageRenderingType} */
yfiles.view.CanvasComponent.prototype.imageRendering;
 /** @type {!HTMLElement} */
yfiles.view.CanvasComponent.prototype.overlayPanel;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.view.CanvasComponent.prototype.dragTime;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.view.CanvasComponent.prototype.doubleClickTime;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.view.CanvasComponent.prototype.doubleTapTime;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.view.CanvasComponent.prototype.longPressTime;
 /** @type {!yfiles.geometry.Size} */
yfiles.view.CanvasComponent.prototype.dragSize;
 /** @type {!yfiles.geometry.Size} */
yfiles.view.CanvasComponent.prototype.doubleClickSize;
 /** @type {!yfiles.geometry.Size} */
yfiles.view.CanvasComponent.prototype.doubleTapSize;
 /** @type {number} */
yfiles.view.CanvasComponent.prototype.mouseWheelZoomFactor;
 /** @type {number} */
yfiles.view.CanvasComponent.prototype.mouseWheelScrollFactor;
 /** @type {!yfiles.geometry.Insets} */
yfiles.view.CanvasComponent.prototype.autoDragInsets;
 /** @type {?} */
yfiles.view.CanvasComponent.prototype.inputModeContext;
 /** @type {boolean} */
yfiles.view.CanvasComponent.prototype.navigationCommandsEnabled;
 /** @type {?<string, !Object>} */
yfiles.view.CanvasComponent.prototype.resources;
 /** @type {number} */
yfiles.view.CanvasComponent.sizeChangedTimerInterval;
 /** @type {yfiles.view.SizeChangedDetectionMode} */
yfiles.view.CanvasComponent.prototype.sizeChangedDetection;
 /** @type {!yfiles.lang.Class} */
yfiles.view.CanvasComponent.$class;

/**
 * Scrolls to the provided view point and zoom level in an animated fashion.
 * @param {!yfiles.geometry.Point} viewPoint The new {\@link #viewPoint}
 * @param {number} zoom The new zoom level.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.animateScrollTo = function(viewPoint, zoom) {};

/**
 * Cleans up the Div element by removing any connection from the element to the Control instance.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.cleanUp = function() {};

/**
 * Helper method that ensures that the view port limit as returned by the {\@link yfiles.view.CanvasComponent#viewportLimiter} are obeyed.
 * <p>
 * This method will {\@link yfiles.view.CanvasComponent#zoomTo} the limited bounds if necessary.
 * </p>
 * @see yfiles.view.CanvasComponent#viewportLimiter
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.coerceViewportLimits = function() {};

/**
 * Compares two {\@link yfiles.view.ICanvasObject} instances that are live in this canvas.
 * <p>
 * The comparison will yield values greater than zero if and only if the second object is rendered after the first one.
 * </p>
 * @param {?} canvasObject1 the first object to compare
 * @param {?} canvasObject2 the second object to compare
 * @return {number} 0 if canvasObject1 ==
 * canvasObject2
 * <br />
 * >0 if canvasObject1 is painted before canvasObject2 &lt;0 if canvasObject1 is painted after canvasObject2
 */
yfiles.view.CanvasComponent.prototype.compareRenderOrder = function(canvasObject1, canvasObject2) {};

/**
 * Factory method for the BackgroundGroup property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.CanvasComponent#backgroundGroup} property.
 * </p>
 * @protected
 * @return {?} a new instance of ICanvasObjectGroup
 */
yfiles.view.CanvasComponent.prototype.createBackgroundGroup = function() {};

/**
 * Factory method for the ContentGroup property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.CanvasComponent#contentGroup} property.
 * </p>
 * @protected
 * @return {?} a new instance of ICanvasObjectGroup
 */
yfiles.view.CanvasComponent.prototype.createContentGroup = function() {};

/**
 * Factory method for the {\@link yfiles.view.CanvasComponent#focusGroup} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.CanvasComponent#focusGroup} property.
 * </p>
 * @protected
 * @return {?} a new instance of ICanvasObjectGroup
 */
yfiles.view.CanvasComponent.prototype.createFocusGroup = function() {};

/**
 * Factory method for the HighlightGroup property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.CanvasComponent#highlightGroup} property.
 * </p>
 * @protected
 * @return {?} a new instance of ICanvasObjectGroup
 */
yfiles.view.CanvasComponent.prototype.createHighlightGroup = function() {};

/**
 * Factory method for the {\@link yfiles.view.CanvasComponent#inputModeContext} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.CanvasComponent#inputModeContext} property.
 * </p>
 * @protected
 * @return {?} a new instance of {\@link #inputModeContext} that has this instance set as it's {\@link #canvasComponent} and uses this instance's {\@link #inputModeContextLookup}
 * callback to satisfy requests.
 */
yfiles.view.CanvasComponent.prototype.createInputModeContext = function() {};

/**
 * Factory method for the InputModeGroup property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.CanvasComponent#inputModeGroup} property.
 * </p>
 * @protected
 * @return {?} a new instance of ICanvasObjectGroup
 */
yfiles.view.CanvasComponent.prototype.createInputModeGroup = function() {};

/**
 * Creates an appropriate {\@link yfiles.view.IRenderContext render context} that can be used to {\@link yfiles.view.IVisualCreator#createVisual create visuals} using {\@link yfiles.view.IVisualCreator}
 * implementations.
 * <p>
 * This method is a convenience method to obtain a context for special visual creator implementations and normally needs
 * not be used by application developers.
 * </p>
 * @return {?} A new context instance that is bound to this instance.
 */
yfiles.view.CanvasComponent.prototype.createRenderContext = function() {};

/**
 * Factory method for the SelectionGroup property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.CanvasComponent#selectionGroup} property.
 * </p>
 * @protected
 * @return {?} a new instance of ICanvasObjectGroup
 */
yfiles.view.CanvasComponent.prototype.createSelectionGroup = function() {};

/**
 * Ensures that the provided bounds are visible in this control by adjusting the viewport correspondingly.
 * @param {!yfiles.geometry.Rect} bounds The bounds to make visible.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.ensureVisible = function(bounds) {};

/**
 * Exports the graphical content for this {\@link yfiles.view.CanvasComponent}.
 * <p>
 * This method will create the visual content using the world coordinate system.
 * </p>
 * @param {?} context The context to use.
 * @return {!Element} A composite Visual that represents the contents of this control.
 */
yfiles.view.CanvasComponent.prototype.exportContent = function(context) {};

/**
 * Fires the size changed event.
 * @param {!yfiles.geometry.Size} oldSize
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.fireSizeChanged = function(oldSize) {};

/**
 * Adjusts the view port to fully encompass the {\@link yfiles.view.CanvasComponent#contentRect}.
 * <p>
 * The zoom level will not be greater than <code>1.0d</code>. If the view port is limited by the {\@link yfiles.view.CanvasComponent#viewportLimiter} the zoom level might be greater than <code>1.0d</code>
 * to respect the limits.
 * </p>
 * @see yfiles.view.CanvasComponent#updateContentRect
 * @see yfiles.view.CanvasComponent#zoom
 * @see yfiles.view.CanvasComponent#zoomTo
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.fitContent = function() {};

/**
 * Focuses the {\@link yfiles.view.CanvasComponent#div} element that is backing this instance.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.focus = function() {};

/**
 * Convenience method that calculates the bounds for a given canvas object in the scene graph.
 * <p>
 * This method queries the descriptor for the {\@link yfiles.view.IBoundsProvider} for the user object and returns the result.
 * </p>
 * @param {?} canvasObject the canvas object to query the bounds from
 * @return {!yfiles.geometry.Rect} the non-<code>null</code> bounds
 */
yfiles.view.CanvasComponent.prototype.getBounds = function(canvasObject) {};

/**
 * Returns the top most canvas object instance that is hit at the given coordinate set.
 * <p>
 * This will return the canvas object that is painted last at the given position.
 * </p>
 * @param {!yfiles.geometry.Point} location the coordinates of the query in the world coordinate system
 * @return {?}
 */
yfiles.view.CanvasComponent.prototype.getCanvasObject = function(location) {};

/**
 * Enumerates over all possible {\@link yfiles.view.ICanvasObject} instances in the tree below the given group.
 * Returns a list of all canvas objects in hit order at the given world coordinate location.
 * <p>
 * The order of the elements in the list is the natural hit test order, i.e. elements painted on top of others will be
 * reported first in the list.
 * </p>
 * Enumerates over all possible {\@link yfiles.view.ICanvasObject} instances in the tree.
 * @param {?|!yfiles.geometry.Point=} group_or_location the coordinates of the query in the world coordinate system
 * @return {?<?>} An enumerable for all {\@link }s in the tree below the given group. / an enumerable of canvas object that are hit in reverse painting order / An enumerable for all {\@link }s in the tree.
 */
yfiles.view.CanvasComponent.prototype.getCanvasObjects = function(group_or_location) {};

/**
 * Gets the {\@link yfiles.view.CanvasComponent} instance that is associated with the given DOM element, or null.
 * @param {!Element} element
 * @return {!yfiles.view.CanvasComponent}
 */
yfiles.view.CanvasComponent.getComponent = function(element) {};

/**
 * Gets the {\@link yfiles.view.Visual} that is currently visualizing the given {\@link yfiles.view.ICanvasObject}.
 * <p>
 * Note that depending on the current state of the viewport and the control no such instance may be available and instead
 * this method will yield <code>null</code>. However if a visual is currently being displayed for the given canvas object, it will be
 * returned. This method should be used with care. Manipulation of the given instance should normally be done through the
 * corresponding {\@link yfiles.view.IVisualCreator} that created the visual in the first place. This method rather serves as a
 * utility method for UI testing frameworks and similar use cases.
 * </p>
 * @param {?} canvasObject The canvas object.
 * @return {!yfiles.view.Visual} The {\@link } that is currently used by the <code>canvasObject</code>.
 */
yfiles.view.CanvasComponent.prototype.getVisual = function(canvasObject) {};

/**
 * Convenience method that retrieves the {\@link yfiles.view.IVisualCreator} for a given {\@link yfiles.view.ICanvasObject}.
 * @see yfiles.view.ICanvasObjectDescriptor#getVisualCreator
 * @see yfiles.view.VoidVisualCreator#INSTANCE
 * @param {?} canvasObject the canvas object to query the visual creator implementation from
 * @return {?} an instance of the visual creator interface
 */
yfiles.view.CanvasComponent.prototype.getVisualCreator = function(canvasObject) {};

/**
 * Converts view coordinates from the document's coordinate system to the control's coordinate system.
 * @param {!yfiles.geometry.Point} localPoint The coordinates to convert.
 * @return {!yfiles.geometry.Point} The coordinates in the control's coordinate system.
 */
yfiles.view.CanvasComponent.prototype.globalToLocal = function(localPoint) {};

/**
 * Assures that the {\@link yfiles.view.CanvasComponent#contentRect content rectangle} encompasses the given rectangle.
 * <p>
 * Note that this will not change the view port, it will only change the scroll bars if necessary.
 * </p>
 * @param {!yfiles.geometry.Rect} rectangle the rectangle that should be included in the content rectangle
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.growContentRect = function(rectangle) {};

/**
 * Enumerates all hit elements in the canvas below the given group that are accepted by a given filter using a specific {\@link yfiles.view.ICanvasContext}
 * as the argument to the {\@link yfiles.input.IHitTestable#isHit} method.
 * <p>
 * Hit testing is performed using the {\@link yfiles.view.ICanvasObjectDescriptor#getHitTestable} instance returned for each visible
 * {\@link yfiles.view.ICanvasObject} in the current scene graph. The enumeration is performed lazily.
 * </p>
 * @see yfiles.input.IHitTestable
 * Enumerates all hit elements in the canvas below the given group that are accepted by a given filter using a specific {\@link yfiles.view.ICanvasContext}
 * as the argument to the {\@link yfiles.input.IHitTestable#isHit} method.
 * <p>
 * Hit testing is performed using the {\@link yfiles.view.ICanvasObjectDescriptor#getHitTestable} instance returned for each visible
 * {\@link yfiles.view.ICanvasObject} in the current scene graph. The enumeration is performed lazily.
 * </p>
 * @see yfiles.input.IHitTestable
 * Enumerates all hit elements in the canvas below the given group that are accepted by a given filter.
 * <p>
 * Hit testing is performed using the {\@link yfiles.view.ICanvasObjectDescriptor#getHitTestable} instance returned for each visible
 * {\@link yfiles.view.ICanvasObject} in the current scene graph. The enumeration is performed lazily.
 * </p>
 * @see yfiles.input.IHitTestable
 * @see yfiles.view.CanvasComponent#hitTestRadius
 * Enumerates all hit elements in the canvas below the given group that are accepted by a given filter.
 * <p>
 * Hit testing is performed using the {\@link yfiles.view.ICanvasObjectDescriptor#getHitTestable} instance returned for each visible
 * {\@link yfiles.view.ICanvasObject} in the current scene graph. The enumeration is performed lazily.
 * </p>
 * @see yfiles.input.IHitTestable
 * @see yfiles.view.CanvasComponent#hitTestRadius
 * @param {?|{context: ?, location: !yfiles.geometry.Point, root: ?, filter: function(?): boolean}|!yfiles.geometry.Point|{location: !yfiles.geometry.Point, root: ?, filter: function(?): boolean}} context_or_options_or_location The context instance to pass to {\@link #isHit}. / the coordinates to perform the hit test at
 * @param {!yfiles.geometry.Point|?=} location_or_root the coordinates to perform the hit test at
 * @param {?|function(?): boolean=} root_or_filter
 * @param {function(?): boolean=} filter
 * @return {?<?>} a live enumeration of the elements that are hit
 */
yfiles.view.CanvasComponent.prototype.hitElementsAt = function(context_or_options_or_location, location_or_root, root_or_filter, filter) {};

/**
 * Callback that is used by the default implementation of {\@link yfiles.view.CanvasComponent#inputModeContext} to resolve {\@link yfiles.graph.ILookup#lookup} calls.
 * @see yfiles.input.IInputModeContext
 * @protected
 * @param {!yfiles.lang.Class} type The Type to query
 * @return {!Object} The result of the query.
 */
yfiles.view.CanvasComponent.prototype.inputModeContextLookup = function(type) {};

/**
 * Invalidates this instance and marks it as in need for an update.
 * <p>
 * Calling this method is fast and will only mark the control for a future, asynchronously executed call to UpdateVisual.
 * </p>
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.invalidate = function() {};

/**
 * Convenience method that calculates the hit tests a given canvas object in the scene graph.
 * <p>
 * This method queries the descriptor for the {\@link yfiles.input.IHitTestable} for the user object and returns the result of the
 * hit test query. If there is no <code>IHitTestable</code> returned by the descriptor this method returns <code>false</code>.
 * </p>
 * @param {?} canvasObject the canvas object to query the bounds from
 * @param {!yfiles.geometry.Point} location the coordinates of the query in the world coordinate system
 * @return {boolean} whether the canvas object is hit at the given coordinates
 */
yfiles.view.CanvasComponent.prototype.isHit = function(canvasObject, location) {};

/**
 * Converts view coordinates from the control's coordinate system to the document's coordinate system.
 * @param {!yfiles.geometry.Point} localPoint The coordinates to convert.
 * @return {!yfiles.geometry.Point} The coordinates in the document's coordinate system.
 */
yfiles.view.CanvasComponent.prototype.localToGlobal = function(localPoint) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.view.CanvasComponent.prototype.lookup = function(type) {};

/**
 * This method will be called when the mouse wheel was turned and if the {\@link yfiles.view.CanvasComponent#mouseWheelBehavior} property is set to
 * {\@link yfiles.view.MouseWheelBehaviors#SCROLL}.
 * <p>
 * This method will scroll the view in vertical direction. If the Shift key modifier has been pressed this method will
 * scroll in horizontal direction.
 * </p>
 * @see yfiles.view.CanvasComponent#mouseWheelBehavior
 * @see yfiles.view.CanvasComponent#mouseWheelScrollFactor
 * @protected
 * @param {!yfiles.view.MouseEventArgs} evt the event describing the action
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.mouseWheelScroll = function(evt) {};

/**
 * This method will be called when the mouse wheel was turned and if the {\@link yfiles.view.CanvasComponent#mouseWheelBehavior} property is set to
 * {\@link yfiles.view.MouseWheelBehaviors#ZOOM}.
 * <p>
 * This method will adjust the current zoom level. If the Control key modifier has been pressed this method will keep the
 * world coordinates at the current mouse position, i.e. the zoom will not necessarily be into the center of the canvas.
 * </p>
 * @see yfiles.view.CanvasComponent#mouseWheelBehavior
 * @protected
 * @param {!yfiles.view.MouseEventArgs} evt the event describing the action
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.mouseWheelZoom = function(evt) {};

/**
 * Raises the {\@link yfiles.view.CanvasComponent#addPrepareRenderContextListener PrepareRenderContext}.
 * @see yfiles.view.CanvasComponent#addPrepareRenderContextListener
 * @protected
 * @param {!yfiles.view.PrepareRenderContextEventArgs} evt The event arguments to raise.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.raisePrepareRenderContextEvent = function(evt) {};

/**
 * Raises the {\@link yfiles.view.CanvasComponent#addUpdatedVisualListener UpdatedVisual}.
 * @see yfiles.view.CanvasComponent#addUpdatedVisualListener
 * @protected
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.raiseUpdatedVisualEvent = function() {};

/**
 * Raises the {\@link yfiles.view.CanvasComponent#addUpdatingVisualListener UpdatingVisual}.
 * @see yfiles.view.CanvasComponent#addUpdatingVisualListener
 * @protected
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.raiseUpdatingVisualEvent = function() {};

/**
 * Adds a callback to the invocation chain and triggers the chain's execution.
 * <p>
 * Therefore, the given callback will be executed in sequence with previously added actions, e.g. the
 * {\@link yfiles.view.CanvasComponent}'s invalidation.
 * </p>
 * @param {!Function} callback The function that should be executed.
 * @param {...!Object} args The arguments with which the function should be called.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.schedule = function(callback, args) {};

/**
 * Sets the content rectangle.
 * <p>
 * The content rectangle is the space in world coordinates that the user should at least be able to scroll to. I.e. if the
 * area currently visible in the control does not encompass the content rect, the scrollbars will be made visible, unless
 * they are disabled.
 * </p>
 * @see yfiles.view.CanvasComponent#contentRect
 * @see yfiles.view.CanvasComponent#horizontalScrollBarPolicy
 * @see yfiles.view.CanvasComponent#verticalScrollBarPolicy
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.setContentRect = function(x, y, w, h) {};

/**
 * Stops the mouse capture and returns to normal event capturing.
 * <p>
 * When {\@link yfiles.view.CanvasComponent#mouseCaptureEnabled} is set to <code>true</code> and a mouse down event is received, the control starts capturing all mouse events by registering
 * handlers on the document element. Mouse capturing is normally stopped when the mouse button is released. Mouse capture
 * can be manually stopped by calling this function.
 * </p>
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.stopMouseCapture = function() {};

/**
 * Converts world coordinates to view coordinates expressed in the control's coordinate system.
 * @param {!yfiles.geometry.Point} worldPoint the coordinates in the world coordinate system
 * @return {!yfiles.geometry.Point} returns the coordinates in pixels relative to the controls upper left corner
 */
yfiles.view.CanvasComponent.prototype.toViewCoordinates = function(worldPoint) {};

/**
 * Converts view coordinates (expressed in the control's coordinate system) to world coordinates.
 * @param {!yfiles.geometry.Point} viewPoint the coordinates in pixels relative to the controls upper left corner
 * @return {!yfiles.geometry.Point} returns the coordinates in the world coordinate system
 */
yfiles.view.CanvasComponent.prototype.toWorldCoordinates = function(viewPoint) {};

/**
 * Updates the {\@link yfiles.view.CanvasComponent#contentRect} to encompass the bounds by all elements in the current scene graph plus the given margins.
 * <p>
 * This method will traverse all {\@link yfiles.view.ICanvasObject#visible visible} elements in the scene graph and query their {\@link yfiles.view.ICanvasObjectDescriptor#getBoundsProvider bounds} The resulting bounds will be
 * set to the content rectangle plus the provided <code>margins</code>.
 * </p>
 * @see yfiles.view.IBoundsProvider
 * @see yfiles.view.CanvasComponent#contentRect
 * Updates the {\@link yfiles.view.CanvasComponent#contentRect} to encompass the bounds by all elements in the current scene graph plus the given margins.
 * <p>
 * This method will traverse all {\@link yfiles.view.ICanvasObject#visible visible} elements in the scene graph and query their {\@link yfiles.view.ICanvasObjectDescriptor#getBoundsProvider bounds} The resulting bounds will be
 * set to the content rectangle plus the provided <code>margins</code>.
 * </p>
 * @see yfiles.view.IBoundsProvider
 * @see yfiles.view.CanvasComponent#contentRect
 * @param {!yfiles.geometry.Insets|{margins: !yfiles.geometry.Insets, group: ?}=} margins_or_options
 * @param {?=} group
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.updateContentRect = function(margins_or_options, group) {};

/**
 * Updates the visual tree that displays the contents of this control.
 * <p>
 * Calling this method will synchronously update the visual tree and the SVG DOM and Canvas rendering.
 * </p>
 * <p>
 * This method will determine the {\@link yfiles.view.ICanvasObject#dirty} canvas objects using the {\@link yfiles.view.ICanvasObjectDescriptor#isDirty} method and will {\@link yfiles.view.IVisualCreator#createVisual create}
 * or {\@link yfiles.view.IVisualCreator#updateVisual update} the visuals that make up the visual tree.
 * </p>
 * <p>
 * Note that most of the time this method does not need to be called by client code. Instead calling {\@link yfiles.view.CanvasComponent#invalidate}
 * will ultimately trigger the execution of this method. However invalidation calls will be coalesced and the actual
 * execution of the update will be delayed until the next event dispatch.
 * </p>
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.updateVisual = function() {};

/**
 * Sets the zoom level and view port center to the given values.
 * Sets the zoom level and view port center so that the given rectangle in world coordinates fits the viewport.
 * @param {!yfiles.geometry.Point|!yfiles.geometry.Rect} center_or_bounds the new center of the view port in world coordinates / The coordinates of the rectangle to zoom to.
 * @param {number=} zoom the new zoom level
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.zoomTo = function(center_or_bounds, zoom) {};

/**
 * Adds the given listener for the <code>ContentRectChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#contentRect content rectangle} has been changed.
 * @see yfiles.view.CanvasComponent#removeContentRectChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addContentRectChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ContentRectChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#contentRect content rectangle} has been changed.
 * @see yfiles.view.CanvasComponent#addContentRectChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeContentRectChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>FitContentViewMarginsChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#fitContentViewMargins margins for the fit content operation}
 * have been changed.
 * @see yfiles.view.CanvasComponent#removeFitContentViewMarginsChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addFitContentViewMarginsChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>FitContentViewMarginsChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#fitContentViewMargins margins for the fit content operation}
 * have been changed.
 * @see yfiles.view.CanvasComponent#addFitContentViewMarginsChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeFitContentViewMarginsChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseLeave</code> event that occurs when the mouse has exited the canvas.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * If the mouse leaves this canvas control with the mouse button pressed, this event is deferred until the mouse button is
 * released. Thus, this event will not interfere with the typical mouse button event cycle.
 * </p>
 * @see yfiles.view.CanvasComponent#removeMouseLeaveListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseLeaveListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseLeave</code> event that occurs when the mouse has exited the canvas.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * If the mouse leaves this canvas control with the mouse button pressed, this event is deferred until the mouse button is
 * released. Thus, this event will not interfere with the typical mouse button event cycle.
 * </p>
 * @see yfiles.view.CanvasComponent#addMouseLeaveListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseLeaveListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseEnter</code> event that occurs when the mouse has entered the canvas.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * If the mouse enters this canvas control with a mouse button pressed, this event is fired instantly but the current
 * button state reported by the {\@link yfiles.view.MouseEventArgs} does not include this button unless the browser supports the
 * property <code>MouseEvent.buttons</code>. See the Known Issues for more details.
 * </p>
 * @see yfiles.view.CanvasComponent#removeMouseEnterListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseEnterListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseEnter</code> event that occurs when the mouse has entered the canvas.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * If the mouse enters this canvas control with a mouse button pressed, this event is fired instantly but the current
 * button state reported by the {\@link yfiles.view.MouseEventArgs} does not include this button unless the browser supports the
 * property <code>MouseEvent.buttons</code>. See the Known Issues for more details.
 * </p>
 * @see yfiles.view.CanvasComponent#addMouseEnterListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseEnterListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseMove</code> event that occurs when the mouse has been moved in world coordinates.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * Move elements are delivered if no mouse button is pressed. This event will be fired, too, if the mouse does not move but
 * the world coordinates to which the current mouse position maps change. E.g. this will happen if the zoom level or the
 * view point is changed.
 * </p>
 * @see yfiles.view.CanvasComponent#removeMouseMoveListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseMoveListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseMove</code> event that occurs when the mouse has been moved in world coordinates.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * Move elements are delivered if no mouse button is pressed. This event will be fired, too, if the mouse does not move but
 * the world coordinates to which the current mouse position maps change. E.g. this will happen if the zoom level or the
 * view point is changed.
 * </p>
 * @see yfiles.view.CanvasComponent#addMouseMoveListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseMoveListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseDown</code> event that occurs when a mouse button has been pressed.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeMouseDownListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseDownListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseDown</code> event that occurs when a mouse button has been pressed.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addMouseDownListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseDownListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseDrag</code> event that occurs when the mouse is being moved while at least one of the
 * mouse buttons is pressed.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeMouseDragListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseDragListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseDrag</code> event that occurs when the mouse is being moved while at least one of the
 * mouse buttons is pressed.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addMouseDragListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseDragListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseUp</code> event that occurs when the mouse button has been released.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeMouseUpListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseUpListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseUp</code> event that occurs when the mouse button has been released.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addMouseUpListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseUpListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseLostCapture</code> event that occurs when the mouse capture has been lost.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeMouseLostCaptureListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseLostCaptureListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseLostCapture</code> event that occurs when the mouse capture has been lost.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addMouseLostCaptureListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseLostCaptureListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseWheel</code> event that occurs when the mouse wheel has turned.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeMouseWheelListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseWheelListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseWheel</code> event that occurs when the mouse wheel has turned.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addMouseWheelListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseWheelListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseClick</code> event that occurs when the user clicked the mouse.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * This happens if press and release happens at the same position.
 * </p>
 * @see yfiles.view.CanvasComponent#removeMouseClickListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseClickListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseClick</code> event that occurs when the user clicked the mouse.
 * <p>
 * This event delivers {\@link yfiles.view.MouseEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * This happens if press and release happens at the same position.
 * </p>
 * @see yfiles.view.CanvasComponent#addMouseClickListener
 * @param {function(!Object, !yfiles.view.MouseEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseClickListener = function(listener) {};

/**
 * Adds the given listener for the <code>KeyDown</code> event that occurs when keys are being pressed.
 * <p>
 * This event delivers {\@link yfiles.view.KeyEventArgs}.
 * </p>
 * @see yfiles.view.CanvasComponent#removeKeyDownListener
 * @param {function(!Object, !yfiles.view.KeyEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addKeyDownListener = function(listener) {};

/**
 * Removes the given listener for the <code>KeyDown</code> event that occurs when keys are being pressed.
 * <p>
 * This event delivers {\@link yfiles.view.KeyEventArgs}.
 * </p>
 * @see yfiles.view.CanvasComponent#addKeyDownListener
 * @param {function(!Object, !yfiles.view.KeyEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeKeyDownListener = function(listener) {};

/**
 * Adds the given listener for the <code>KeyPressed</code> event that occurs when keys are being typed.
 * <p>
 * This event delivers {\@link yfiles.view.KeyEventArgs}.
 * </p>
 * @see yfiles.view.CanvasComponent#removeKeyPressedListener
 * @param {function(!Object, !yfiles.view.KeyEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addKeyPressedListener = function(listener) {};

/**
 * Removes the given listener for the <code>KeyPressed</code> event that occurs when keys are being typed.
 * <p>
 * This event delivers {\@link yfiles.view.KeyEventArgs}.
 * </p>
 * @see yfiles.view.CanvasComponent#addKeyPressedListener
 * @param {function(!Object, !yfiles.view.KeyEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeKeyPressedListener = function(listener) {};

/**
 * Adds the given listener for the <code>KeyUp</code> event that occurs when keys are being released.
 * <p>
 * This event delivers {\@link yfiles.view.KeyEventArgs}.
 * </p>
 * @see yfiles.view.CanvasComponent#removeKeyUpListener
 * @param {function(!Object, !yfiles.view.KeyEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addKeyUpListener = function(listener) {};

/**
 * Removes the given listener for the <code>KeyUp</code> event that occurs when keys are being released.
 * <p>
 * This event delivers {\@link yfiles.view.KeyEventArgs}.
 * </p>
 * @see yfiles.view.CanvasComponent#addKeyUpListener
 * @param {function(!Object, !yfiles.view.KeyEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeKeyUpListener = function(listener) {};

/**
 * Adds the given listener for the <code>EditableChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#editable} property has been changed.
 * @see yfiles.view.CanvasComponent#removeEditableChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addEditableChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EditableChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#editable} property has been changed.
 * @see yfiles.view.CanvasComponent#addEditableChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeEditableChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ViewportChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#viewport} property has been changed.
 * @see yfiles.view.CanvasComponent#removeViewportChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addViewportChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ViewportChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#viewport} property has been changed.
 * @see yfiles.view.CanvasComponent#addViewportChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeViewportChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>TouchDown</code> event that occurs when a finger has been put on the touch screen.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeTouchDownListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addTouchDownListener = function(listener) {};

/**
 * Removes the given listener for the <code>TouchDown</code> event that occurs when a finger has been put on the touch screen.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addTouchDownListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeTouchDownListener = function(listener) {};

/**
 * Adds the given listener for the <code>TouchUp</code> event that occurs when a finger has been removed from the touch screen.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeTouchUpListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addTouchUpListener = function(listener) {};

/**
 * Removes the given listener for the <code>TouchUp</code> event that occurs when a finger has been removed from the touch screen.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addTouchUpListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeTouchUpListener = function(listener) {};

/**
 * Adds the given listener for the <code>TouchMove</code> event that occurs when a finger has been moved on the touch screen.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeTouchMoveListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addTouchMoveListener = function(listener) {};

/**
 * Removes the given listener for the <code>TouchMove</code> event that occurs when a finger has been moved on the touch screen.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addTouchMoveListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeTouchMoveListener = function(listener) {};

/**
 * Adds the given listener for the <code>TouchEnter</code> event that occurs when a finger on the touch screen has entered the canvas.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeTouchEnterListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addTouchEnterListener = function(listener) {};

/**
 * Removes the given listener for the <code>TouchEnter</code> event that occurs when a finger on the touch screen has entered the
 * canvas.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addTouchEnterListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeTouchEnterListener = function(listener) {};

/**
 * Adds the given listener for the <code>TouchLeave</code> event that occurs when a finger on the touch screen has exited the canvas.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeTouchLeaveListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addTouchLeaveListener = function(listener) {};

/**
 * Removes the given listener for the <code>TouchLeave</code> event that occurs when a finger on the touch screen has exited the
 * canvas.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addTouchLeaveListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeTouchLeaveListener = function(listener) {};

/**
 * Adds the given listener for the <code>TouchLostCapture</code> event that occurs when the touch capture has been lost.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#removeTouchLostCaptureListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addTouchLostCaptureListener = function(listener) {};

/**
 * Removes the given listener for the <code>TouchLostCapture</code> event that occurs when the touch capture has been lost.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * @see yfiles.view.CanvasComponent#addTouchLostCaptureListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeTouchLostCaptureListener = function(listener) {};

/**
 * Adds the given listener for the <code>TouchClick</code> event that occurs when the user performed a tap gesture with a finger on the
 * touch screen.
 * <p>
 * An event that delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points when the
 * user performed a tap gesture with a finger on the touch screen.
 * </p>
 * <p>
 * This happens if down and up happens at the same position.
 * </p>
 * @see yfiles.view.CanvasComponent#removeTouchClickListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addTouchClickListener = function(listener) {};

/**
 * Removes the given listener for the <code>TouchClick</code> event that occurs when the user performed a tap gesture with a finger on
 * the touch screen.
 * <p>
 * An event that delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points when the
 * user performed a tap gesture with a finger on the touch screen.
 * </p>
 * <p>
 * This happens if down and up happens at the same position.
 * </p>
 * @see yfiles.view.CanvasComponent#addTouchClickListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeTouchClickListener = function(listener) {};

/**
 * Adds the given listener for the <code>TouchLongPress</code> event that occurs when the user performed a long press gesture with a
 * finger on the touch screen.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * This happens if the finger is held in the same position for the duration specified in {\@link yfiles.view.CanvasComponent#longPressTime} after a
 * {\@link yfiles.view.CanvasComponent#addTouchDownListener TouchDown}.
 * </p>
 * @see yfiles.view.CanvasComponent#removeTouchLongPressListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addTouchLongPressListener = function(listener) {};

/**
 * Removes the given listener for the <code>TouchLongPress</code> event that occurs when the user performed a long press gesture with a
 * finger on the touch screen.
 * <p>
 * This event delivers {\@link yfiles.view.TouchEventArgs} in world coordinates using double precision floating points.
 * </p>
 * <p>
 * This happens if the finger is held in the same position for the duration specified in {\@link yfiles.view.CanvasComponent#longPressTime} after a
 * {\@link yfiles.view.CanvasComponent#addTouchDownListener TouchDown}.
 * </p>
 * @see yfiles.view.CanvasComponent#addTouchLongPressListener
 * @param {function(!Object, !yfiles.view.TouchEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeTouchLongPressListener = function(listener) {};

/**
 * Adds the given listener for the <code>InputModeChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#inputMode} property is changed.
 * @see yfiles.view.CanvasComponent#inputMode
 * @see yfiles.view.CanvasComponent#removeInputModeChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addInputModeChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>InputModeChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#inputMode} property is changed.
 * @see yfiles.view.CanvasComponent#inputMode
 * @see yfiles.view.CanvasComponent#addInputModeChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeInputModeChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>HitTestRadiusChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#hitTestRadius} property changes.
 * @see yfiles.view.CanvasComponent#removeHitTestRadiusChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addHitTestRadiusChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>HitTestRadiusChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#hitTestRadius} property changes.
 * @see yfiles.view.CanvasComponent#addHitTestRadiusChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeHitTestRadiusChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ZoomChanged</code> event that occurs when the value of the {\@link yfiles.view.CanvasComponent#zoom} property has been changed.
 * @see yfiles.view.CanvasComponent#removeZoomChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addZoomChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ZoomChanged</code> event that occurs when the value of the {\@link yfiles.view.CanvasComponent#zoom} property has been changed.
 * @see yfiles.view.CanvasComponent#addZoomChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeZoomChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GotFocus</code> event that occurs when the Control got the focus.
 * @see yfiles.view.CanvasComponent#removeGotFocusListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addGotFocusListener = function(listener) {};

/**
 * Removes the given listener for the <code>GotFocus</code> event that occurs when the Control got the focus.
 * @see yfiles.view.CanvasComponent#addGotFocusListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeGotFocusListener = function(listener) {};

/**
 * Adds the given listener for the <code>LostFocus</code> event that occurs when the Control lost the focus.
 * @see yfiles.view.CanvasComponent#removeLostFocusListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addLostFocusListener = function(listener) {};

/**
 * Removes the given listener for the <code>LostFocus</code> event that occurs when the Control lost the focus.
 * @see yfiles.view.CanvasComponent#addLostFocusListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeLostFocusListener = function(listener) {};

/**
 * Adds the given listener for the <code>AutoDragChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#autoDrag} property is changed.
 * @see yfiles.view.CanvasComponent#removeAutoDragChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addAutoDragChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>AutoDragChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#autoDrag} property is changed.
 * @see yfiles.view.CanvasComponent#addAutoDragChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeAutoDragChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>UpdatedVisual</code> event that occurs after the {\@link yfiles.view.CanvasComponent#updateVisual visual tree has been updated}.
 * @see yfiles.view.CanvasComponent#removeUpdatedVisualListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addUpdatedVisualListener = function(listener) {};

/**
 * Removes the given listener for the <code>UpdatedVisual</code> event that occurs after the {\@link yfiles.view.CanvasComponent#updateVisual visual tree has been updated}.
 * @see yfiles.view.CanvasComponent#addUpdatedVisualListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeUpdatedVisualListener = function(listener) {};

/**
 * Adds the given listener for the <code>UpdatingVisual</code> event.
 * <br />
 * Event that will be triggered before the {\@link yfiles.view.CanvasComponent#updateVisual visual tree is updated}.
 * @see yfiles.view.CanvasComponent#removeUpdatingVisualListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addUpdatingVisualListener = function(listener) {};

/**
 * Removes the given listener for the <code>UpdatingVisual</code> event.
 * <br />
 * Event that will be triggered before the {\@link yfiles.view.CanvasComponent#updateVisual visual tree is updated}.
 * @see yfiles.view.CanvasComponent#addUpdatingVisualListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeUpdatingVisualListener = function(listener) {};

/**
 * Adds the given listener for the <code>ContentGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#contentGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#removeContentGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addContentGroupChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ContentGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#contentGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#addContentGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeContentGroupChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>FocusGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#focusGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#removeFocusGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addFocusGroupChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>FocusGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#focusGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#addFocusGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeFocusGroupChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>HighlightGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#highlightGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#removeHighlightGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addHighlightGroupChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>HighlightGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#highlightGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#addHighlightGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeHighlightGroupChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>SelectionGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#selectionGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#removeSelectionGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addSelectionGroupChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>SelectionGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#selectionGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#addSelectionGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeSelectionGroupChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>InputModeGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#inputModeGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#removeInputModeGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addInputModeGroupChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>InputModeGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#inputModeGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#addInputModeGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeInputModeGroupChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>BackgroundGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#backgroundGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#removeBackgroundGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addBackgroundGroupChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>BackgroundGroupChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#backgroundGroup} property has been changed.
 * @see yfiles.view.CanvasComponent#addBackgroundGroupChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeBackgroundGroupChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseWheelZoomFactorChanged</code> event that occurs when the value of the {\@link yfiles.view.CanvasComponent#mouseWheelZoomFactor} property has been
 * changed.
 * @see yfiles.view.CanvasComponent#removeMouseWheelZoomFactorChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseWheelZoomFactorChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseWheelZoomFactorChanged</code> event that occurs when the value of the {\@link yfiles.view.CanvasComponent#mouseWheelZoomFactor} property has
 * been changed.
 * @see yfiles.view.CanvasComponent#addMouseWheelZoomFactorChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseWheelZoomFactorChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>MouseWheelScrollFactorChanged</code> event that occurs when the value of the {\@link yfiles.view.CanvasComponent#mouseWheelScrollFactor} property has been
 * changed.
 * @see yfiles.view.CanvasComponent#removeMouseWheelScrollFactorChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addMouseWheelScrollFactorChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>MouseWheelScrollFactorChanged</code> event that occurs when the value of the {\@link yfiles.view.CanvasComponent#mouseWheelScrollFactor} property has
 * been changed.
 * @see yfiles.view.CanvasComponent#addMouseWheelScrollFactorChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeMouseWheelScrollFactorChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PrepareRenderContext</code> event.
 * <br />
 * Event that will be triggered before the visual tree is painted to prepare the {\@link yfiles.view.IRenderContext}.
 * @see yfiles.view.CanvasComponent#removePrepareRenderContextListener
 * @param {function(!Object, !yfiles.view.PrepareRenderContextEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addPrepareRenderContextListener = function(listener) {};

/**
 * Removes the given listener for the <code>PrepareRenderContext</code> event.
 * <br />
 * Event that will be triggered before the visual tree is painted to prepare the {\@link yfiles.view.IRenderContext}.
 * @see yfiles.view.CanvasComponent#addPrepareRenderContextListener
 * @param {function(!Object, !yfiles.view.PrepareRenderContextEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removePrepareRenderContextListener = function(listener) {};

/**
 * Adds the given listener for the <code>InputModeContextChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#inputModeContext} property has been changed.
 * @see yfiles.view.CanvasComponent#removeInputModeContextChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addInputModeContextChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>InputModeContextChanged</code> event that occurs when the {\@link yfiles.view.CanvasComponent#inputModeContext} property has been changed.
 * @see yfiles.view.CanvasComponent#addInputModeContextChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeInputModeContextChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>SizeChanged</code> event that occurs when the size of this Control is changed.
 * @see yfiles.view.CanvasComponent#sizeChangedDetection
 * @see yfiles.view.SizeChangedDetectionMode
 * @see yfiles.view.CanvasComponent#removeSizeChangedListener
 * @param {function(!Object, !yfiles.view.SizeChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.addSizeChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>SizeChanged</code> event that occurs when the size of this Control is changed.
 * @see yfiles.view.CanvasComponent#sizeChangedDetection
 * @see yfiles.view.SizeChangedDetectionMode
 * @see yfiles.view.CanvasComponent#addSizeChangedListener
 * @param {function(!Object, !yfiles.view.SizeChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.CanvasComponent.prototype.removeSizeChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.view.SvgExport = function() {};
 /** @type {!yfiles.geometry.Rect} */
yfiles.view.SvgExport.prototype.worldBounds;
 /** @type {number} */
yfiles.view.SvgExport.prototype.scale;
 /** @type {number} */
yfiles.view.SvgExport.prototype.zoom;
 /** @type {!yfiles.geometry.Insets} */
yfiles.view.SvgExport.prototype.margins;
 /** @type {number} */
yfiles.view.SvgExport.prototype.viewWidth;
 /** @type {number} */
yfiles.view.SvgExport.prototype.viewHeight;
 /** @type {boolean} */
yfiles.view.SvgExport.prototype.copyDefsElements;
 /** @type {boolean} */
yfiles.view.SvgExport.prototype.encodeImagesBase64;
 /** @type {boolean} */
yfiles.view.SvgExport.prototype.inlineSvgImages;
 /** @type {!yfiles.lang.Class} */
yfiles.view.SvgExport.$class;

/**
 * Calculates the value to set the {\@link yfiles.view.SvgExport#scale} to in order to achieve the given target height (without {\@link yfiles.view.SvgExport#margins}).
 * <p>
 * This method returns 1.0 if the {\@link yfiles.view.SvgExport#worldBounds} height is zero or negative.
 * </p>
 * @param {number} height the height of the target image
 * @return {number} the scale value to use
 */
yfiles.view.SvgExport.prototype.calculateScaleForHeight = function(height) {};

/**
 * Calculates the value to set the {\@link yfiles.view.SvgExport#scale} to in order to achieve the given target width (without {\@link yfiles.view.SvgExport#margins}).
 * <p>
 * This method returns 1.0 if the {\@link yfiles.view.SvgExport#worldBounds} width is zero or negative.
 * </p>
 * @param {number} width the width of the target image
 * @return {number} the scale value to use
 */
yfiles.view.SvgExport.prototype.calculateScaleForWidth = function(width) {};

/**
 * Returns an initialized {\@link yfiles.view.IRenderContext} and changes the given transform and the clip bounds such that a part
 * of the given {\@link yfiles.view.CanvasComponent} instance can be exported to an image.
 * @param {!yfiles.view.CanvasComponent} canvas The {\@link } instance to export.
 * @return {?} An {\@link } to use.
 */
yfiles.view.SvgExport.prototype.createRenderContext = function(canvas) {};

/**
 * Encodes the given SVG document as Data URI.
 * <p>
 * This method escapes non-Latin1 characters, does a base64 encoding, and returns the result as data URI.
 * </p>
 * @param {string} svgXml A string containing the SVG document.
 * @return {string} A data URI of the SVG document.
 */
yfiles.view.SvgExport.encodeSvgDataUrl = function(svgXml) {};

/**
 * Exports the contents of the {\@link yfiles.view.CanvasComponent} to a single, standalone SVG element.
 * <p>
 * The asynchronous version of this method,
 * {\@link yfiles.view.SvgExport#exportSvgAsync}, is capable of encoding and inlining images that are embedded in the SVG.
 * </p>
 * @param {!yfiles.view.CanvasComponent} canvas The canvas to be exported.
 * @return {!Element} An SVG element with the canvas contents.
 */
yfiles.view.SvgExport.prototype.exportSvg = function(canvas) {};

/**
 * Exports the contents of the {\@link yfiles.view.CanvasComponent} to a single, standalone SVG element.
 * <p>
 * In addition, images are inlined into the SVG using base64 encoding if {\@link yfiles.view.SvgExport#encodeImagesBase64} is set to <code>true</code>. Image inlining can be controlled
 * for each image individually by overwriting the predicate method {\@link yfiles.view.SvgExport#shouldEncodeImageBase64}.
 * </p>
 * <p>
 * SVG image elements are replaced with a copy of the referenced SVG element if {\@link yfiles.view.SvgExport#inlineSvgImages} is set to <code>true</code>. Image encoding can be
 * controlled for each image individually by overwriting the predicate method {\@link yfiles.view.SvgExport#shouldInlineSvgImage}.
 * </p>
 * @param {!yfiles.view.CanvasComponent} canvas The canvas to be exported.
 * @return {!Promise<!Element>}
 */
yfiles.view.SvgExport.prototype.exportSvgAsync = function(canvas) {};

/**
 * Serializes the given SVG element to a string.
 * <p>
 * This method adds SVG namespace and xlink namespace declarations and replaces <code>href</code> with <code>xlink:href</code>.
 * </p>
 * @param {!Element} svg The SVG element to export.
 * @return {string} A string representation of the SVG.
 */
yfiles.view.SvgExport.exportSvgString = function(svg) {};

/**
 * Returns a suitable clip to use for the visual for this exporter.
 * @return {!yfiles.geometry.Rect} The clip.
 */
yfiles.view.SvgExport.prototype.getClip = function() {};

/**
 * Prepares the imported SVG element before it is placed in the DOM as a replacement for the original image.
 * <p>
 * This method can be used to modify the element is placed in the DOM. This specific implementation copies the values of
 * the x, y, width, height and preserveAspectRatio attributes from the original image element to the imported SVG element.
 * In addition, the SVG is wrapped in a <code>g</code> element to support the <code>transform</code> of the original image.
 * </p>
 * @see yfiles.view.SvgExport#inlineSvgImages
 * @see yfiles.view.SvgExport#exportSvgAsync
 * @see yfiles.view.SvgExport#shouldInlineSvgImage
 * @protected
 * @param {!Element} importedSvg The root element of the SVG file that's referenced by the original image element.
 * @param {!SVGImageElement} originalImage The original image element that will be replaced.
 * @return {!Element} The element that's actually placed in the DOM as a replacement of the <code>originalImage</code>.
 */
yfiles.view.SvgExport.prototype.prepareInlinedImage = function(importedSvg, originalImage) {};

/**
 * Specifies whether or not an image should be encoded to base64.
 * <p>
 * This implementation returns the value of {\@link yfiles.view.SvgExport#encodeImagesBase64} for all values of <code>image</code>.
 * </p>
 * @protected
 * @param {!SVGImageElement} image The image to be encoded.
 * @return {boolean} Whether the given image should be encoded.
 */
yfiles.view.SvgExport.prototype.shouldEncodeImageBase64 = function(image) {};

/**
 * Specifies whether or not an SVG image should be inlined.
 * <p>
 * This implementation returns the value of {\@link yfiles.view.SvgExport#inlineSvgImages} for all values of <code>image</code>.
 * </p>
 * @protected
 * @param {!SVGImageElement} image The image to be inlined.
 * @return {boolean} Whether the given image should be inlined.
 */
yfiles.view.SvgExport.prototype.shouldInlineSvgImage = function(image) {};
/**
 * @record
 * @struct
 */
yfiles.view.SvgDefsManager = function() {};
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.view.SvgDefsManager.prototype.cleanupTimerInterval;
 /** @type {string} */
yfiles.view.SvgDefsManager.prototype.customPrefix;
 /** @type {!SVGDefsElement} */
yfiles.view.SvgDefsManager.prototype.defs;
 /** @type {!yfiles.lang.Class} */
yfiles.view.SvgDefsManager.$class;

/**
 * Triggers the clean up for svg defs on the provided control.
 * @param {!yfiles.view.CanvasComponent} canvas
 * @return {void}
 */
yfiles.view.SvgDefsManager.prototype.cleanupDefs = function(canvas) {};

/**
 * Generates an ID that is globally unique among all {\@link yfiles.view.SvgDefsManager} instances.
 * <p>
 * This ID should be used for the "id" attribute of DOM nodes.
 * </p>
 * @return {string} A globally unique ID.
 */
yfiles.view.SvgDefsManager.prototype.generateUniqueDefsId = function() {};
/**
 * @record
 * @struct
 */
yfiles.view.GraphComponent = function() {};
 /** @type {?} */
yfiles.view.GraphComponent.prototype.currentItem;
 /** @type {!yfiles.view.SelectionIndicatorManager<?>} */
yfiles.view.GraphComponent.prototype.selectionIndicatorManager;
 /** @type {!yfiles.view.HighlightIndicatorManager<?>} */
yfiles.view.GraphComponent.prototype.highlightIndicatorManager;
 /** @type {!yfiles.view.FocusIndicatorManager<?>} */
yfiles.view.GraphComponent.prototype.focusIndicatorManager;
 /** @type {!yfiles.view.GraphModelManager} */
yfiles.view.GraphComponent.prototype.graphModelManager;
 /** @type {?} */
yfiles.view.GraphComponent.prototype.graph;
 /** @type {?} */
yfiles.view.GraphComponent.prototype.selection;
 /** @type {!yfiles.graph.GraphClipboard} */
yfiles.view.GraphComponent.prototype.clipboard;
 /** @type {!yfiles.lang.Class} */
yfiles.view.GraphComponent.$class;

/**
 * Factory method for the {\@link yfiles.view.GraphComponent#focusIndicatorManager} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.GraphComponent#focusIndicatorManager} property.
 * </p>
 * @protected
 * @return {!yfiles.view.FocusIndicatorManager<?>} a new instance of {\@link }.
 */
yfiles.view.GraphComponent.prototype.createFocusIndicatorManager = function() {};

/**
 * Factory method for the Graph property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.GraphComponent#graph} property.
 * </p>
 * @protected
 * @return {?} a new instance of {\@link }
 */
yfiles.view.GraphComponent.prototype.createGraph = function() {};

/**
 * Creates the default instance to use if no custom instance has been set.
 * @protected
 * @return {!yfiles.graph.GraphClipboard} A default {\@link } instance.
 */
yfiles.view.GraphComponent.prototype.createGraphClipboard = function() {};

/**
 * Factory method for the {\@link yfiles.view.GraphComponent#graphModelManager} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.GraphComponent#graphModelManager} property.
 * </p>
 * @protected
 * @return {!yfiles.view.GraphModelManager} a new instance of {\@link }.
 */
yfiles.view.GraphComponent.prototype.createGraphModelManager = function() {};

/**
 * Factory method for the {\@link yfiles.view.GraphComponent#highlightIndicatorManager} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.GraphComponent#highlightIndicatorManager} property.
 * </p>
 * @protected
 * @return {!yfiles.view.HighlightIndicatorManager<?>} a new instance of {\@link #highlightIndicatorManager}.
 */
yfiles.view.GraphComponent.prototype.createHighlightIndicatorManager = function() {};

/**
 * Factory method for the Selection property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.GraphComponent#selection} property.
 * </p>
 * @protected
 * @return {?} a new instance of {\@link }
 */
yfiles.view.GraphComponent.prototype.createSelection = function() {};

/**
 * Factory method for the {\@link yfiles.view.GraphComponent#selectionIndicatorManager} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.view.GraphComponent#selectionIndicatorManager} property.
 * </p>
 * @protected
 * @return {!yfiles.view.SelectionIndicatorManager<?>} a new instance of {\@link }
 */
yfiles.view.GraphComponent.prototype.createSelectionIndicatorManager = function() {};

/**
 * {\@link yfiles.view.CanvasComponent#updateContentRect Updates the content rectangle} for the {\@link yfiles.view.CanvasComponent#contentGroup} considering the provided insets and
 * {\@link yfiles.view.CanvasComponent#fitContent adjusts the viewport to encompass the contents}.
 * @param {!yfiles.geometry.Insets=} insets
 * @return {void}
 */
yfiles.view.GraphComponent.prototype.fitGraphBounds = function(insets) {};

/**
 * Convenience method that runs a layouter on the graph of a given graph control and animates the transition.
 * <p>
 * An event is called once the animation has finished.
 * </p>
 * <p>
 * The implementation simply delegates to a properly configured instance of {\@link yfiles.layout.LayoutExecutor}. In addition to
 * the default configuration, it enables {\@link yfiles.layout.LayoutExecutor#animateViewport}, {\@link yfiles.layout.LayoutExecutor#easedAnimation}, and {\@link yfiles.layout.LayoutExecutor#updateContentRect}. For more fine-grained control of the animation, use {\@link yfiles.layout.LayoutExecutor}
 * directly.
 * </p>
 * Convenience method that runs a layouter on the graph of a given graph control and animates the transition.
 * <p>
 * An event is called once the animation has finished.
 * </p>
 * <p>
 * The implementation simply delegates to a properly configured instance of {\@link yfiles.layout.LayoutExecutor}. In addition to
 * the default configuration, it enables {\@link yfiles.layout.LayoutExecutor#animateViewport}, {\@link yfiles.layout.LayoutExecutor#easedAnimation}, and {\@link yfiles.layout.LayoutExecutor#updateContentRect}. For more fine-grained control of the animation, use {\@link yfiles.layout.LayoutExecutor}
 * directly.
 * </p>
 * @param {?|{layout: ?, morphDuration: !yfiles.lang.TimeSpan, layoutData: !yfiles.layout.LayoutData}} layout_or_options
 * @param {!yfiles.lang.TimeSpan=} morphDuration
 * @param {!yfiles.layout.LayoutData=} layoutData
 * @return {!Promise<!Object>}
 */
yfiles.view.GraphComponent.prototype.morphLayout = function(layout_or_options, morphDuration, layoutData) {};

/**
 * Adds the given listener for the <code>CurrentItemChanged</code> event that occurs when the {\@link yfiles.view.GraphComponent#currentItem} property has changed its value.
 * @see yfiles.view.GraphComponent#removeCurrentItemChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.GraphComponent.prototype.addCurrentItemChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>CurrentItemChanged</code> event that occurs when the {\@link yfiles.view.GraphComponent#currentItem} property has changed its value.
 * @see yfiles.view.GraphComponent#addCurrentItemChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.GraphComponent.prototype.removeCurrentItemChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphChanged</code> event that occurs when the {\@link yfiles.view.GraphComponent#graph} property has been changed.
 * @see yfiles.view.GraphComponent#removeGraphChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.GraphComponent.prototype.addGraphChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphChanged</code> event that occurs when the {\@link yfiles.view.GraphComponent#graph} property has been changed.
 * @see yfiles.view.GraphComponent#addGraphChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.GraphComponent.prototype.removeGraphChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.view.GraphOverviewComponent = function() {};
 /** @type {boolean} */
yfiles.view.GraphOverviewComponent.prototype.svgRendering;
 /** @type {?} */
yfiles.view.GraphOverviewComponent.prototype.graphVisualCreator;
 /** @type {!yfiles.input.OverviewInputMode} */
yfiles.view.GraphOverviewComponent.prototype.overviewInputMode;
 /** @type {?} */
yfiles.view.GraphOverviewComponent.prototype.graph;
 /** @type {!yfiles.view.GraphComponent} */
yfiles.view.GraphOverviewComponent.prototype.graphComponent;
 /** @type {!yfiles.lang.Class} */
yfiles.view.GraphOverviewComponent.$class;

/**
 * Factory method that creates the {\@link yfiles.view.IVisualCreator} that renders the preview of the graph in a HTML canvas
 * element.
 * @protected
 * @param {?} graph The graph to draw.
 * @return {?} An {\@link } that creates HTML canvas rendering.
 */
yfiles.view.GraphOverviewComponent.prototype.createCanvasVisualCreator = function(graph) {};

/**
 * Factory method that creates the {\@link yfiles.view.IVisualCreator} that renders the preview of the graph in SVG.
 * @protected
 * @param {?} graph The graph to draw.
 * @return {?} An {\@link } that creates SVG.
 */
yfiles.view.GraphOverviewComponent.prototype.createSvgVisualCreator = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.view.GridInfo = function() {};
 /** @type {number} */
yfiles.view.GridInfo.prototype.horizontalSpacing;
 /** @type {number} */
yfiles.view.GridInfo.prototype.verticalSpacing;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.GridInfo.prototype.origin;
 /** @type {!yfiles.lang.Class} */
yfiles.view.GridInfo.$class;
/**
 * @record
 * @struct
 */
yfiles.view.ICanvasContext = function() {};
 /** @type {number} */
yfiles.view.ICanvasContext.prototype.zoom;
 /** @type {number} */
yfiles.view.ICanvasContext.prototype.hitTestRadius;
 /** @type {!yfiles.view.CanvasComponent} */
yfiles.view.ICanvasContext.prototype.canvasComponent;

/**
 * Adds an element to the defs section of the document, if it has not been added yet.
 * @abstract
 * @param {?} defsSupport The instance that is used to create and update the element and to query if the element is still referenced
 * @return {string} The id of the element with which it can be referenced using an url reference.
 */
yfiles.view.ICanvasContext.prototype.getDefsId = function(defsSupport) {};
 /** @type {{createCanvasContext: ?, DEFAULT: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.ICanvasContext;
/**
 * @record
 * @struct
 */
yfiles.view.ICanvasObject = function() {};
 /** @type {boolean} */
yfiles.view.ICanvasObject.prototype.visible;
 /** @type {boolean} */
yfiles.view.ICanvasObject.prototype.dirty;
 /** @type {?} */
yfiles.view.ICanvasObject.prototype.group;
 /** @type {!Object} */
yfiles.view.ICanvasObject.prototype.userObject;
 /** @type {?} */
yfiles.view.ICanvasObject.prototype.descriptor;
 /** @type {?} */
yfiles.view.ICanvasObject.prototype.nextSibling;
 /** @type {?} */
yfiles.view.ICanvasObject.prototype.previousSibling;

/**
 * Moves this instance exactly behind the reference item in the referenced item's group rendering list, so that it will be
 * rendered directly above the given reference.
 * <p>
 * This method returns the current instance so that calls can be chained, e.g. <code>object.Above(other).Raise()</code>.
 * </p>
 * <p>
 * Observe that this instance will move into the referenced item's group if needed.
 * </p>
 * @abstract
 * @param {?} reference
 * @return {?} <code>this</code> so that calls can be chained.
 */
yfiles.view.ICanvasObject.prototype.above = function(reference) {};

/**
 * Moves this instance exactly before the reference item in the referenced item's group rendering list, so that it will be
 * rendered directly behind the given reference.
 * <p>
 * This method returns the current instance so that calls can be chained, e.g. <code>object.Below(other).Lower()</code>.
 * </p>
 * <p>
 * Observe that this instance will move into the referenced item's group if needed.
 * </p>
 * @abstract
 * @param {?} reference
 * @return {?} <code>this</code> so that calls can be chained.
 */
yfiles.view.ICanvasObject.prototype.below = function(reference) {};

/**
 * Moves this instance one step closer to the beginning of the group rendering list, so that it will be rendered behind its
 * current predecessor.
 * <p>
 * As a convenience, this method returns the current instance so that calls can be conveniently chained, e.g.
 * <code>object.Lower().Lower()</code>
 * </p>
 * @abstract
 * @return {?} <code>this</code> so that calls can be chained.
 */
yfiles.view.ICanvasObject.prototype.lower = function() {};

/**
 * Moves this instance one step closer to the end of the group rendering list, so that it will be rendered on top of its
 * current successor.
 * <p>
 * As a convenience, this method returns the current instance so that calls can be conveniently chained, e.g.
 * <code>object.Raise().Raise().Raise()</code>
 * </p>
 * @abstract
 * @return {?} <code>this</code> so that calls can be chained.
 */
yfiles.view.ICanvasObject.prototype.raise = function() {};

/**
 * Removes this item from the scene graph it currently belongs to.
 * @abstract
 * @return {void}
 */
yfiles.view.ICanvasObject.prototype.remove = function() {};

/**
 * Moves this instance to the beginning of the group rendering list, so that it will be rendered behind all other items in
 * the same group.
 * <p>
 * As a convenience, this method returns the current instance so that calls can be conveniently chained, e.g.
 * <code>object.ToBack().Raise().Raise()</code>
 * </p>
 * @abstract
 * @return {?} <code>this</code> so that calls can be chained.
 */
yfiles.view.ICanvasObject.prototype.toBack = function() {};

/**
 * Moves this instance to the end of the group rendering list, so that it will be rendered in front of all other items in
 * the same group.
 * <p>
 * As a convenience, this method returns the current instance so that calls can be conveniently chained, e.g.
 * <code>object.ToFront().Lower()</code>
 * </p>
 * @abstract
 * @return {?} <code>this</code> so that calls can be chained.
 */
yfiles.view.ICanvasObject.prototype.toFront = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.ICanvasObject;
/**
 * @record
 * @struct
 */
yfiles.view.ICanvasObjectDescriptor = function() {};

/**
 * Returns an implementation of {\@link yfiles.view.IBoundsProvider} that can determine the visible bounds of the rendering of the
 * user object.
 * <p>
 * This method may always return the same instance. By contract, clients will not cache instances returned, but will always
 * call this method before the methods on the instance will be called. This contract enables the use of the fly-weight
 * design pattern. Implementations of this class can always return the same instance and reconfigure this instance upon
 * each call to this method.
 * </p>
 * @abstract
 * @param {!Object} forUserObject the user object to query the bounds for
 * @return {?} an implementation or <code>null</code> if the bounds are not known, in which case the bounds are treated as infinite
 */
yfiles.view.ICanvasObjectDescriptor.prototype.getBoundsProvider = function(forUserObject) {};

/**
 * Returns an implementation of {\@link yfiles.input.IHitTestable} that can determine whether the rendering of the user object has
 * been hit at a given coordinate.
 * <p>
 * This method may always return the same instance. By contract, clients will not cache instances returned, but will always
 * call this method before the methods on the instance will be called. This contract enables the use of the fly-weight
 * design pattern. Implementations of this class can always return the same instance and reconfigure this instance upon
 * each call to this method.
 * </p>
 * @abstract
 * @param {!Object} forUserObject the user object to do the hit testing for
 * @return {?} an implementation or <code>null</code> if the rendering cannot be hit tested
 */
yfiles.view.ICanvasObjectDescriptor.prototype.getHitTestable = function(forUserObject) {};

/**
 * Returns an implementation of {\@link yfiles.view.IVisibilityTestable} that can determine if the rendering of the user object
 * would be visible in a given context.
 * <p>
 * This method may always return the same instance. By contract clients will not cache instances returned but will always
 * call this method before the methods on the instance will be called. This contract enables the use of the fly-weight
 * design pattern. Implementations of this class can always return the same instance and reconfigure this instance upon
 * each call to this method.
 * </p>
 * @abstract
 * @param {!Object} forUserObject the user object to query the bounds for
 * @return {?} an implementation or <code>null</code> if the bounds are not known, in which case the bounds are treated as infinite
 */
yfiles.view.ICanvasObjectDescriptor.prototype.getVisibilityTestable = function(forUserObject) {};

/**
 * Returns an implementation of {\@link yfiles.view.IVisualCreator} that will create the {\@link yfiles.view.Visual} tree for the user
 * object.
 * <p>
 * This method may always return the same instance. By contract, clients will not cache instances returned, but will always
 * call this method before the methods on the instance will be called. This contract enables the use of the fly-weight
 * design pattern. Implementations of this class can always return the same instance and reconfigure this instance upon
 * each call to this method.
 * </p>
 * @abstract
 * @param {!Object} forUserObject the user object to create a Visual for
 * @return {?} an implementation or <code>null</code> if nothing shall be rendered
 */
yfiles.view.ICanvasObjectDescriptor.prototype.getVisualCreator = function(forUserObject) {};

/**
 * Determines whether the given canvas object is deemed dirty and needs updating.
 * @abstract
 * @param {?} context The context that will be used for the update.
 * @param {?} canvasObject The object to check.
 * @return {boolean} Whether an update is needed.
 */
yfiles.view.ICanvasObjectDescriptor.prototype.isDirty = function(context, canvasObject) {};
 /** @type {{VOID: ?, DYNAMIC_DIRTY_INSTANCE: ?, ALWAYS_DIRTY_INSTANCE: ?, DYNAMIC_DIRTY_LOOKUP: ?, ALWAYS_DIRTY_LOOKUP: ?, VISUAL: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.ICanvasObjectDescriptor;
/**
 * @record
 * @struct
 */
yfiles.view.ICanvasObjectGroup = function() {};
 /** @type {?} */
yfiles.view.ICanvasObjectGroup.prototype.firstChild;
 /** @type {?} */
yfiles.view.ICanvasObjectGroup.prototype.lastChild;

/**
 * Adds a child element to the scene graph as a child of this group.
 * <p>
 * The descriptor will be queried for the various rendering related implementations for the given <code>userObject</code> at rendering
 * time.
 * </p>
 * @see yfiles.view.ICanvasObjectDescriptor
 * @see yfiles.view.ICanvasObjectDescriptor#DYNAMIC_DIRTY_INSTANCE
 * @abstract
 * @param {!Object} userObject The user object to associate with this child element. This object will be passed to the <code>descriptor</code>'s methods.
 * @param {?} descriptor An implementation of the {\@link } interface that will be passed the <code>userObject</code> to provide the
 * various implementations that are used during rendering.
 * @return {?} A handle that can be used to control the rendering order and to later {\@link #remove remove} the element from the scene graph, again.
 */
yfiles.view.ICanvasObjectGroup.prototype.addChild = function(userObject, descriptor) {};

/**
 * Adds a new {\@link yfiles.view.ICanvasObjectGroup} to this group in the current scene graph.
 * <p>
 * This can be used to build groups of {\@link yfiles.view.ICanvasObject} instances that can be moved within the scene graph or
 * whose {\@link yfiles.view.ICanvasObject#visible visibility} can be controlled easily. The group will have a <code>null</code> {\@link yfiles.view.ICanvasObject#userObject}.
 * </p>
 * @abstract
 * @return {?} A handle to the newly created group that can be used to control the rendering order and to later {\@link #remove remove} the group from
 * the scene graph, again.
 */
yfiles.view.ICanvasObjectGroup.prototype.addGroup = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.ICanvasObjectGroup;
/**
 * @record
 * @struct
 */
yfiles.view.IHighlightIndicatorInstaller = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IHighlightIndicatorInstaller;
/**
 * @record
 * @struct
 */
yfiles.view.IFocusIndicatorInstaller = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IFocusIndicatorInstaller;

/** @const */
yfiles.view.BridgeCrossingStyle = {};
/** @const {number} */
yfiles.view.BridgeCrossingStyle.GAP;
/** @const {number} */
yfiles.view.BridgeCrossingStyle.RECTANGLE;
/** @const {number} */
yfiles.view.BridgeCrossingStyle.RECTANGLE_SCALED;
/** @const {number} */
yfiles.view.BridgeCrossingStyle.TWO_SIDES;
/** @const {number} */
yfiles.view.BridgeCrossingStyle.TWO_SIDES_SCALED;
/** @const {number} */
yfiles.view.BridgeCrossingStyle.ARC;
/** @const {number} */
yfiles.view.BridgeCrossingStyle.ARC_SCALED;
/** @const {number} */
yfiles.view.BridgeCrossingStyle.CUSTOM;

/** @const */
yfiles.view.BridgeOrientationStyle = {};
/** @const {number} */
yfiles.view.BridgeOrientationStyle.FLOW_RIGHT;
/** @const {number} */
yfiles.view.BridgeOrientationStyle.FLOW_LEFT;
/** @const {number} */
yfiles.view.BridgeOrientationStyle.POSITIVE;
/** @const {number} */
yfiles.view.BridgeOrientationStyle.NEGATIVE;
/** @const {number} */
yfiles.view.BridgeOrientationStyle.LEFT;
/** @const {number} */
yfiles.view.BridgeOrientationStyle.RIGHT;
/** @const {number} */
yfiles.view.BridgeOrientationStyle.UP;
/** @const {number} */
yfiles.view.BridgeOrientationStyle.DOWN;

/** @const */
yfiles.view.BridgeCrossingPolicy = {};
/** @const {number} */
yfiles.view.BridgeCrossingPolicy.HORIZONTAL_BRIDGES_VERTICAL;
/** @const {number} */
yfiles.view.BridgeCrossingPolicy.VERTICAL_BRIDGES_HORIZONTAL;
/** @const {number} */
yfiles.view.BridgeCrossingPolicy.MORE_HORIZONTAL_BRIDGES_LESS_HORIZONTAL;
/** @const {number} */
yfiles.view.BridgeCrossingPolicy.MORE_VERTICAL_BRIDGES_LESS_VERTICAL;
/**
 * @record
 * @struct
 */
yfiles.view.BridgeManager = function() {};
 /** @type {?} */
yfiles.view.BridgeManager.prototype.defaultBridgeCreator;
 /** @type {boolean} */
yfiles.view.BridgeManager.prototype.considerCurves;
 /** @type {number} */
yfiles.view.BridgeManager.prototype.zoomThreshold;
 /** @type {yfiles.view.BridgeCrossingPolicy} */
yfiles.view.BridgeManager.prototype.bridgeCrossingPolicy;
 /** @type {!yfiles.view.CanvasComponent} */
yfiles.view.BridgeManager.prototype.canvasComponent;
 /** @type {yfiles.view.BridgeCrossingStyle} */
yfiles.view.BridgeManager.prototype.defaultBridgeCrossingStyle;
 /** @type {number} */
yfiles.view.BridgeManager.prototype.defaultBridgeWidth;
 /** @type {number} */
yfiles.view.BridgeManager.prototype.clipMargin;
 /** @type {number} */
yfiles.view.BridgeManager.prototype.defaultBridgeHeight;
 /** @type {yfiles.view.BridgeOrientationStyle} */
yfiles.view.BridgeManager.prototype.defaultBridgeOrientationStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.view.BridgeManager.$class;

/**
 * Core method that will add bridges to a {\@link yfiles.geometry.GeneralPath} using the {\@link yfiles.view.IBridgeCreator} callback to
 * determine the type of the bridges.
 * <p>
 * This method may return <code>path</code> itself if no crossings have been determined. Otherwise it will return a new path instance
 * that has the bridges added at the corresponding places.
 * </p>
 * @param {?} context The context to use.
 * @param {!yfiles.geometry.GeneralPath} path The path to calculate the bridged variant for.
 * @param {?} callback The callback or <code>null</code> that determines the appearance of the bridges.
 * @return {!yfiles.geometry.GeneralPath} The path that might have been augmented by the bridges.
 */
yfiles.view.BridgeManager.prototype.addBridges = function(context, path, callback) {};

/**
 * Adds another {\@link yfiles.view.IObstacleProvider} to query for obstacles.
 * <p>
 * The {\@link yfiles.view.IObstacleProvider#getObstacles} method will be invoked during construction of the obstacles.
 * </p>
 * @see yfiles.view.BridgeManager#registerObstacles
 * @see yfiles.view.BridgeManager#removeObstacleProvider
 * @param {?} provider The provider instance to use for later queries.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.addObstacleProvider = function(provider) {};

/**
 * Disposes of this instance by resetting the {\@link yfiles.view.BridgeManager#canvasComponent} property to <code>null</code>.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.dispose = function() {};

/**
 * Gets a hash code that describes the current state of the obstacles.
 * <p>
 * This method can be used to get a concise, digest snapshot of the current obstacle locations. Storing that result and
 * comparing it to another snapshot later allows to determine quickly whether obstacles have changed since the last call.
 * This is helpful, e.g. in implementations of {\@link yfiles.styles.IEdgeStyle} that support bridges to not recreate the edge path
 * (including bridges) in {\@link yfiles.view.IVisualCreator#updateVisual} if no obstacles changed.
 * </p>
 * @param {?} context The context to inspect.
 * @return {number} A hash of the state of the obstacles.
 */
yfiles.view.BridgeManager.prototype.getObstacleHash = function(context) {};

/**
 * Implementation that will be called by the default value of the {\@link yfiles.view.BridgeManager#defaultBridgeCreator} to satisfy requests to
 * {\@link yfiles.view.IBridgeCreator#createCustomBridge}.
 * <p>
 * This implementation will insert a gap style bridge by first creating a {\@link yfiles.geometry.GeneralPath#lineTo line} to <code>start</code> and then {\@link yfiles.geometry.GeneralPath#moveTo moving} to <code>end</code>.
 * </p>
 * @see yfiles.view.IBridgeCreator#createCustomBridge
 * @param {?} context The context for the call.
 * @param {!yfiles.geometry.GeneralPath} path The path to append the next segment to.
 * @param {!yfiles.geometry.Point} start The coordinates of the starting point of the bridge.
 * @param {!yfiles.geometry.Point} end The coordinates of the ending point of the bridge.
 * @param {number} gapLength The distance between the starting point and the end point.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.insertDefaultCustomBridge = function(context, path, start, end, gapLength) {};

/**
 * Installs this manager for the specified {\@link yfiles.view.BridgeManager#canvasComponent}.
 * @protected
 * @param {!yfiles.view.CanvasComponent} canvas The {\@link #canvasComponent}.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.install = function(canvas) {};

/**
 * Convenience method that can be called to dynamically register an obstacle path with the context during the rendering.
 * <p>
 * Normally all obstacles will be registered initially by method
 * {\@link yfiles.view.BridgeManager#registerObstacles}. This method can be called during the rendering phase to register additional
 * obstacles at a later point in time.
 * </p>
 * @see yfiles.view.BridgeManager#registerObstacleLine
 * @param {?} context The context to register the obstacles with.
 * @param {!yfiles.geometry.GeneralPath} path The path that describes the obstacles.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.registerObstacle = function(context, path) {};

/**
 * Convenience method that can be called to dynamically register a single obstacle cubic curve with the context during the
 * rendering.
 * <p>
 * Normally all obstacles will be registered initially by method
 * {\@link yfiles.view.BridgeManager#registerObstacles}. This method can be called during the rendering phase to register additional
 * obstacles at a later point in time.
 * </p>
 * @see yfiles.view.BridgeManager#registerObstacleLine
 * @param {?} context The context to register the obstacles with.
 * @param {!yfiles.geometry.Point} p1 The coordinates of the starting point of the line.
 * @param {!yfiles.geometry.Point} cp1 The coordinates of the first control point of the curve.
 * @param {!yfiles.geometry.Point} cp2 The coordinates of the second control point of the curve.
 * @param {!yfiles.geometry.Point} p2 The coordinates of the ending point of the line.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.registerObstacleCubicCurve = function(context, p1, cp1, cp2, p2) {};

/**
 * Convenience method that can be called to dynamically register a single obstacle line with the context during the
 * rendering.
 * <p>
 * Normally all obstacles will be registered initially by method
 * {\@link yfiles.view.BridgeManager#registerObstacles}. This method can be called during the rendering phase to register additional
 * obstacles at a later point in time.
 * </p>
 * @see yfiles.view.BridgeManager#registerObstacleLine
 * @param {?} context The context to register the obstacles with.
 * @param {!yfiles.geometry.Point} p1 The coordinates of the first point of the line.
 * @param {!yfiles.geometry.Point} p2 The coordinates of the second point of the line.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.registerObstacleLine = function(context, p1, p2) {};

/**
 * Convenience method that can be called to dynamically register a single obstacle quadratic curve with the context during
 * the rendering.
 * <p>
 * Normally all obstacles will be registered initially by method
 * {\@link yfiles.view.BridgeManager#registerObstacles}. This method can be called during the rendering phase to register additional
 * obstacles at a later point in time.
 * </p>
 * @see yfiles.view.BridgeManager#registerObstacleLine
 * @param {?} context The context to register the obstacles with.
 * @param {!yfiles.geometry.Point} p1 The coordinates of the starting point of the line.
 * @param {!yfiles.geometry.Point} cp The coordinates of the control point of the curve.
 * @param {!yfiles.geometry.Point} p2 The coordinates of the ending point of the line.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.registerObstacleQuadCurve = function(context, p1, cp, p2) {};

/**
 * Called to initialize the context with the obstacles.
 * @see yfiles.view.BridgeManager#registerObstacle
 * @see yfiles.view.BridgeManager#registerObstacleLine
 * @protected
 * @param {?} context The context that will be used to store the obstacles with.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.registerObstacles = function(context) {};

/**
 * Removes a previously {\@link yfiles.view.BridgeManager#addObstacleProvider added} {\@link yfiles.view.IObstacleProvider} from the list of registered providers.
 * @see yfiles.view.BridgeManager#addObstacleProvider
 * @param {?} provider The provider instance to remove from this instance.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.removeObstacleProvider = function(provider) {};

/**
 * Reverts the {\@link yfiles.view.BridgeManager#install} method.
 * @protected
 * @param {!yfiles.view.CanvasComponent} canvas The {\@link #canvasComponent}.
 * @return {void}
 */
yfiles.view.BridgeManager.prototype.uninstall = function(canvas) {};
/**
 * @record
 * @struct
 */
yfiles.view.IBridgeCreator = function() {};

/**
 * Callback that will be used by the {\@link yfiles.view.BridgeManager} if the {\@link yfiles.view.IBridgeCreator#getCrossingStyle} method
 * yields {\@link yfiles.view.BridgeCrossingStyle#CUSTOM} to actually insert a bridge into the given {\@link yfiles.geometry.GeneralPath}.
 * <p>
 * When this method is called the {\@link yfiles.geometry.GeneralPath}'s {\@link yfiles.geometry.GeneralPath#lastCoordinate last} coordinates are not yet at <code>start</code>. So most
 * implementation should first {\@link yfiles.geometry.GeneralPath#moveTo} that location. Also at the end of the call,
 * implementation should make sure that the GeneralPath's end is at <code>end</code>. The <code>gapLength</code> is provided for convenience so that
 * the distance between <code>startPoint</code> and <code>endPoint</code> does not need to be calculated if it is needed for the drawing.
 * </p>
 * @abstract
 * @param {?} context The context for the call.
 * @param {!yfiles.geometry.GeneralPath} path The path to append the bridge segment to.
 * @param {!yfiles.geometry.Point} start The coordinates of the starting point of the bridge.
 * @param {!yfiles.geometry.Point} end The coordinates of the ending point of the bridge.
 * @param {number} gapLength The distance between the starting point and the end point.
 * @return {void}
 */
yfiles.view.IBridgeCreator.prototype.createCustomBridge = function(context, path, start, end, gapLength) {};

/**
 * Gets the height of the bridge for the given {\@link yfiles.view.IRenderContext}.
 * <p>
 * The height is the default height that will be used for drawing the non-{\@link yfiles.view.BridgeCrossingStyle#CUSTOM custom} {\@link yfiles.view.BridgeCrossingStyle}s.
 * </p>
 * @abstract
 * @param {?} context The context where the bridge will be created for.
 * @return {number} The non-negative preferred basic unscaled height of the bridge.
 */
yfiles.view.IBridgeCreator.prototype.getBridgeHeight = function(context) {};

/**
 * Gets the width of the bridge for the given {\@link yfiles.view.IRenderContext}.
 * <p>
 * The width is the preferred length of the segment that will be removed from the original segment if it crosses an
 * obstacle. That bridge will be made larger if multiple obstacle bridges would otherwise overlap. The bridge will be
 * automatically made smaller if it happens to be near the end of a segment and would otherwise extend beyond the end of
 * the segment.
 * </p>
 * @abstract
 * @param {?} context The context where the bridge will be created for.
 * @return {number} The positive preferred width of the bridge.
 */
yfiles.view.IBridgeCreator.prototype.getBridgeWidth = function(context) {};

/**
 * Gets the {\@link yfiles.view.BridgeCrossingStyle} to use in the given {\@link yfiles.view.IRenderContext}.
 * @abstract
 * @param {?} context The context in which the crossing will be used.
 * @return {yfiles.view.BridgeCrossingStyle} The style to use, or {\@link #CUSTOM} in order to let {\@link } call
 * {\@link #createCustomBridge}.
 */
yfiles.view.IBridgeCreator.prototype.getCrossingStyle = function(context) {};

/**
 * Gets the {\@link yfiles.view.BridgeOrientationStyle} to use in the given {\@link yfiles.view.IRenderContext}.
 * @abstract
 * @param {?} context The context in which the style will be used..
 * @return {yfiles.view.BridgeOrientationStyle} The style to use. Any value can be returned and will be ignored if the {\@link #getCrossingStyle crossing style} is set to
 * {\@link #CUSTOM}.
 */
yfiles.view.IBridgeCreator.prototype.getOrientationStyle = function(context) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IBridgeCreator;
/**
 * @record
 * @struct
 */
yfiles.view.IObstacleProvider = function() {};

/**
 * Returns a path representing obstacles that would need bridges.
 * <p>
 * For performance reasons the implementation should only return a non-<code>null</code> {\@link yfiles.geometry.GeneralPath} if it might be {\@link yfiles.view.IVisibilityTestable#isVisible visible}
 * in the provided {\@link yfiles.view.IRenderContext#clip}.
 * </p>
 * @abstract
 * @param {?} context The context for which the obstacles are queried.
 * @return {!yfiles.geometry.GeneralPath} A path that describes the obstacles or <code>null</code> if there are no obstacles for the given context.
 */
yfiles.view.IObstacleProvider.prototype.getObstacles = function(context) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IObstacleProvider;
/**
 * @record
 * @struct
 */
yfiles.view.CollectionModelManager = function() {};
 /** @type {boolean} */
yfiles.view.CollectionModelManager.prototype.enabled;
 /** @type {?<T>} */
yfiles.view.CollectionModelManager.prototype.model;
 /** @type {!yfiles.lang.Class} */
yfiles.view.CollectionModelManager.$class;

/**
 * Called when this mode gets {\@link yfiles.view.CollectionModelManager.<T>#enabled disabled}.
 * @protected
 * @return {void}
 */
yfiles.view.CollectionModelManager.prototype.onDisabled = function() {};

/**
 * Called when this mode gets {\@link yfiles.view.CollectionModelManager.<T>#enabled enabled}.
 * @protected
 * @return {void}
 */
yfiles.view.CollectionModelManager.prototype.onEnabled = function() {};
/**
 * @record
 * @struct
 */
yfiles.view.ItemModelManager = function() {};
 /** @type {?<T>} */
yfiles.view.ItemModelManager.prototype.comparer;
 /** @type {?} */
yfiles.view.ItemModelManager.prototype.descriptor;
 /** @type {?} */
yfiles.view.ItemModelManager.prototype.canvasObjectGroup;
 /** @type {!yfiles.lang.Class} */
yfiles.view.ItemModelManager.$class;

/**
 * Registers and {\@link yfiles.view.ItemModelManager.<T>#install installs} the given <code>item</code> into the canvas.
 * @param {T} item The item to install.
 * @return {void}
 */
yfiles.view.ItemModelManager.prototype.addItem = function(item) {};

/**
 * {\@link yfiles.view.ItemModelManager.<T>#addItem Adds} all items to the canvas.
 * <p>
 * This is useful to initialize this manager with an existing collection of items.
 * </p>
 * @param {?<T>} items The items to add.
 * @return {void}
 */
yfiles.view.ItemModelManager.prototype.addItems = function(items) {};

/**
 * Retrieves the canvas object that has been registered for the given item or <code>null</code>.
 * @see yfiles.view.ItemModelManager.<T>#install
 * @param {T} item The item to retrieve the canvas object for.
 * @return {?} A canvas object instance or <code>null</code>.
 */
yfiles.view.ItemModelManager.prototype.getCanvasObject = function(item) {};

/**
 * Gets the {\@link yfiles.view.ICanvasObjectGroup} used to {\@link yfiles.view.ItemModelManager.<T>#install} the <code>item</code> in the canvas.
 * <p>
 * The default implementation simply returns the value of {\@link yfiles.view.ItemModelManager.<T>#canvasObjectGroup}.
 * </p>
 * @protected
 * @param {T} item The item to get the group for.
 * @return {?} The {\@link } used to {\@link #install} an item in the canvas.
 */
yfiles.view.ItemModelManager.prototype.getCanvasObjectGroup = function(item) {};

/**
 * Returns the {\@link yfiles.view.ICanvasObjectDescriptor} used to {\@link yfiles.view.ItemModelManager.<T>#install} the <code>item</code> in the canvas.
 * <p>
 * The default implementation simply returns the value of {\@link yfiles.view.ItemModelManager.<T>#descriptor}.
 * </p>
 * @protected
 * @param {T} item The item to get the descriptor for.
 * @return {?} The {\@link } used to {\@link #install} an item in the canvas.
 */
yfiles.view.ItemModelManager.prototype.getDescriptor = function(item) {};

/**
 * Tries to find the item managed by this instance that is associated with the given canvas object.
 * @param {?} canvasObject The canvas object to query the corresponding model item for.
 * @return {T} The item or <code>null</code> if no such item could be found.
 */
yfiles.view.ItemModelManager.prototype.getItem = function(canvasObject) {};

/**
 * Installs a member of the collection into the canvas using the {\@link yfiles.view.ItemModelManager.<T>#descriptor}.
 * @protected
 * @param {T} item The member to install.
 * @return {?} The canvas object that has been returned by the installer.
 */
yfiles.view.ItemModelManager.prototype.install = function(item) {};

/**
 * Event handler for item creation events that adds the item to this manager.
 * <p>
 * This method is intended to be used to delegate item creation events from observable collections:
 * </p>
 * <p>
 * This method calls {\@link yfiles.view.ItemModelManager.<T>#addItem} with {\@link yfiles.collections.ItemEventArgs.<T>#item}.
 * </p>
 * @param {!Object} source The instance that raised the event.
 * @param {!yfiles.collections.ItemEventArgs<T>} evt The event arguments.
 * @return {void}
 */
yfiles.view.ItemModelManager.prototype.itemAddedHandler = function(source, evt) {};

/**
 * Event handler for item change events that updates the visual representation for that item.
 * <p>
 * This method is intended to be used to delegate item change events from observable collections:
 * </p>
 * <p>
 * This is necessary if the group the canvas object should be added to might change after the item change. This might
 * happen, e.g. after changing an edge's port in a grouped graph.
 * </p>
 * @param {!Object} source The event source.
 * @param {!yfiles.collections.ItemEventArgs<T>} evt The item event args which indicate the change.
 * @return {void}
 */
yfiles.view.ItemModelManager.prototype.itemChangedHandler = function(source, evt) {};

/**
 * Event handler for item removal events that removes the item from this manager.
 * <p>
 * This method is intended to be used to delegate item removal events from observable collections:
 * </p>
 * <p>
 * This method calls {\@link yfiles.view.ItemModelManager.<T>#removeItem} with {\@link yfiles.collections.ItemEventArgs.<T>#item}.
 * </p>
 * @param {!Object} source The instance that raised the event.
 * @param {!yfiles.collections.ItemEventArgs<T>} evt The event arguments.
 * @return {void}
 */
yfiles.view.ItemModelManager.prototype.itemRemovedHandler = function(source, evt) {};

/**
 * Deregisters and uninstalls the given <code>item</code> from the canvas.
 * @param {T} item The item to uninstall.
 * @return {void}
 */
yfiles.view.ItemModelManager.prototype.removeItem = function(item) {};

/**
 * {\@link yfiles.view.ItemModelManager.<T>#removeItem Removes} all items from the canvas.
 * <p>
 * This method can be used to clean up this manager before disposing it.
 * </p>
 * @param {?<T>} items The items to remove.
 * @return {void}
 */
yfiles.view.ItemModelManager.prototype.removeItems = function(items) {};

/**
 * This method may be called to update the visual representation of the given item in the canvas.
 * <p>
 * If no visual representation is registered, yet, {\@link yfiles.view.ItemModelManager.<T>#install} will be called.
 * </p>
 * @param {T} item The item to update.
 * @return {void}
 */
yfiles.view.ItemModelManager.prototype.update = function(item) {};
/**
 * @record
 * @struct
 */
yfiles.view.DefaultSelectionModel = function() {};
 /** @type {function(T): boolean} */
yfiles.view.DefaultSelectionModel.prototype.isInDomain;
 /** @type {?<T>} */
yfiles.view.DefaultSelectionModel.prototype.selection;
 /** @type {number} */
yfiles.view.DefaultSelectionModel.prototype.size;
 /** @type {!yfiles.lang.Class} */
yfiles.view.DefaultSelectionModel.$class;

/**
 *
 * @return {void}
 */
yfiles.view.DefaultSelectionModel.prototype.clear = function() {};

/**
 *
 * @return {?<T>}
 */
yfiles.view.DefaultSelectionModel.prototype.getEnumerator = function() {};

/**
 * Determines whether an item is selected by checking for the containment in the {\@link yfiles.view.DefaultSelectionModel.<T>#selection}.
 * @param {T} item The item to check
 * @return {boolean} Whether the item is selected.
 */
yfiles.view.DefaultSelectionModel.prototype.isSelected = function(item) {};

/**
 * Event handler for domain item removal events that removes the item from this model.
 * <p>
 * This method is intended to be used to delegate item removal events from the respective domain collection:
 * </p>
 * <p>
 * This method calls {\@link yfiles.view.DefaultSelectionModel.<T>#removeDomainItem} with {\@link yfiles.collections.ItemEventArgs.<T>#item}.
 * </p>
 * @param {!Object} source The instance that raised the event.
 * @param {!yfiles.collections.ItemEventArgs<T>} evt The event arguments.
 * @return {void}
 */
yfiles.view.DefaultSelectionModel.prototype.itemRemovedFromDomainHandler = function(source, evt) {};

/**
 * Called when an item gets selected or deselected.
 * <p>
 * Triggers the {\@link yfiles.view.DefaultSelectionModel.<T>#addItemSelectionChangedListener ItemSelectionChanged} event.
 * </p>
 * @protected
 * @param {T} o The item.
 * @param {boolean} selected Whether or not the item is selected after the change.
 * @return {void}
 */
yfiles.view.DefaultSelectionModel.prototype.onItemSelectionChanged = function(o, selected) {};

/**
 * Removes the given <code>item</code> from the selection in response to the item being removed from the domain.
 * @param {T} item The item to remove from the considered items.
 * @return {void}
 */
yfiles.view.DefaultSelectionModel.prototype.removeDomainItem = function(item) {};

/**
 * Sets the selection state of the item.
 * @param {T} item
 * @param {boolean} selected
 * @return {void}
 */
yfiles.view.DefaultSelectionModel.prototype.setSelected = function(item, selected) {};

/**
 *
 * @param {function(!Object, !yfiles.view.ItemSelectionChangedEventArgs<T>): void} listener
 * @return {void}
 */
yfiles.view.DefaultSelectionModel.prototype.addItemSelectionChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.view.ItemSelectionChangedEventArgs<T>): void} listener
 * @return {void}
 */
yfiles.view.DefaultSelectionModel.prototype.removeItemSelectionChangedListener = function(listener) {};

/** @const */
yfiles.view.ShowFocusPolicy = {};
/** @const {number} */
yfiles.view.ShowFocusPolicy.ALWAYS;
/** @const {number} */
yfiles.view.ShowFocusPolicy.WHEN_FOCUSED;
/**
 * @record
 * @struct
 */
yfiles.view.FocusIndicatorManager = function() {};
 /** @type {T} */
yfiles.view.FocusIndicatorManager.prototype.focusedItem;
 /** @type {yfiles.view.ShowFocusPolicy} */
yfiles.view.FocusIndicatorManager.prototype.showFocusPolicy;
 /** @type {boolean} */
yfiles.view.FocusIndicatorManager.prototype.focused;
 /** @type {!yfiles.lang.Class} */
yfiles.view.FocusIndicatorManager.$class;

/**
 * Called when the {\@link yfiles.view.FocusIndicatorManager.<T>#focused} property has changed.
 * @see yfiles.view.FocusIndicatorManager.<T>#focused
 * @protected
 * @return {void}
 */
yfiles.view.FocusIndicatorManager.prototype.onFocusedChanged = function() {};

/**
 * Callback method that is triggered when the focused item has changed.
 * <p>
 * This method raises the {\@link yfiles.view.FocusIndicatorManager.<T>#addPropertyChangedListener PropertyChanged} event. Subclasses overriding this method should make sure to invoke
 * the super class implementation.
 * </p>
 * @see yfiles.view.FocusIndicatorManager.<T>#focusedItem
 * @see yfiles.view.FocusIndicatorManager.<T>#addPropertyChangedListener
 * @protected
 * @param {!yfiles.lang.PropertyChangedEventArgs} evt a description of the event
 * @return {void}
 */
yfiles.view.FocusIndicatorManager.prototype.onPropertyChanged = function(evt) {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when the {\@link yfiles.view.FocusIndicatorManager.<T>#focusedItem} property has been changed.
 * @see yfiles.view.FocusIndicatorManager.<T>#removePropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.FocusIndicatorManager.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when the {\@link yfiles.view.FocusIndicatorManager.<T>#focusedItem} property has been changed.
 * @see yfiles.view.FocusIndicatorManager.<T>#addPropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.FocusIndicatorManager.prototype.removePropertyChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.view.HighlightIndicatorManager = function() {};
 /** @type {?<T>} */
yfiles.view.HighlightIndicatorManager.prototype.selectionModel;
 /** @type {!yfiles.lang.Class} */
yfiles.view.HighlightIndicatorManager.$class;

/**
 * Adds another highlight.
 * @param {T} item The item to highlight.
 * @return {void}
 */
yfiles.view.HighlightIndicatorManager.prototype.addHighlight = function(item) {};

/**
 * Removes all highlights.
 * @return {void}
 */
yfiles.view.HighlightIndicatorManager.prototype.clearHighlights = function() {};

/**
 * Removes an item from the current highlight selection.
 * @param {T} item The item whose highlight decorator will be removed.
 * @return {void}
 */
yfiles.view.HighlightIndicatorManager.prototype.removeHighlight = function(item) {};
/**
 * @record
 * @struct
 */
yfiles.view.ICanvasObjectInstaller = function() {};

/**
 * This the main method of the interface that performs the installation of an item's visual representation in the {\@link yfiles.view.CanvasComponent canvas} by
 * adding {\@link yfiles.view.ICanvasObject}s.
 * @abstract
 * @param {?} context The context that contains the information required to install the visual representation.
 * @param {?} group The canvas object group to add the newly generated {\@link } to.
 * @param {!Object} item The item to install.
 * @return {?} The newly generated {\@link } for the item's visual representation. <code>null</code> if nothing was installed.
 */
yfiles.view.ICanvasObjectInstaller.prototype.addCanvasObject = function(context, group, item) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.ICanvasObjectInstaller;
/**
 * @record
 * @struct
 */
yfiles.view.ISelectionIndicatorInstaller = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.ISelectionIndicatorInstaller;
/**
 * @record
 * @struct
 */
yfiles.view.ISelectionModel = function() {};
 /** @type {number} */
yfiles.view.ISelectionModel.prototype.size;

/**
 * Clears the selection.
 * <p>
 * This is a convenience method that will set the selection state of all elements to unselected.
 * </p>
 * @see yfiles.view.ISelectionModel.<T>#addItemSelectionChangedListener
 * @abstract
 * @return {void}
 */
yfiles.view.ISelectionModel.prototype.clear = function() {};

/**
 * Determines whether an item is currently selected.
 * @abstract
 * @param {T} item The item to check.
 * @return {boolean} Whether it is currently selected.
 */
yfiles.view.ISelectionModel.prototype.isSelected = function(item) {};

/**
 * Sets the selection state of an item.
 * <p>
 * If the state changes, this will trigger the {\@link yfiles.view.ISelectionModel.<T>#addItemSelectionChangedListener ItemSelectionChanged} event.
 * </p>
 * @abstract
 * @param {T} item The item to set the selection state for.
 * @param {boolean} selected Whether to select the object.
 * @return {void}
 */
yfiles.view.ISelectionModel.prototype.setSelected = function(item, selected) {};

/**
 * Adds the given listener for the <code>ItemSelectionChanged</code> event that occurs when an item changed its selection state from
 * selected to unselected or vice versa.
 * @see yfiles.view.ISelectionModel.<T>#setSelected
 * @see yfiles.view.ISelectionModel.<T>#removeItemSelectionChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.view.ItemSelectionChangedEventArgs<T>): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.ISelectionModel.prototype.addItemSelectionChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemSelectionChanged</code> event that occurs when an item changed its selection state from
 * selected to unselected or vice versa.
 * @see yfiles.view.ISelectionModel.<T>#setSelected
 * @see yfiles.view.ISelectionModel.<T>#addItemSelectionChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.view.ItemSelectionChangedEventArgs<T>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.ISelectionModel.prototype.removeItemSelectionChangedListener = function(listener) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.ISelectionModel;
/**
 * @record
 * @struct
 */
yfiles.view.ItemSelectionChangedEventArgs = function() {};
 /** @type {boolean} */
yfiles.view.ItemSelectionChangedEventArgs.prototype.itemSelected;
 /** @type {!yfiles.lang.Class} */
yfiles.view.ItemSelectionChangedEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.view.ModelManager = function() {};
 /** @type {!yfiles.view.CanvasComponent} */
yfiles.view.ModelManager.prototype.canvasComponent;
 /** @type {boolean} */
yfiles.view.ModelManager.prototype.enabled;
 /** @type {!yfiles.lang.Class} */
yfiles.view.ModelManager.$class;

/**
 * Installs an itemm and adds it to this managers set of managed items.
 * <p>
 * If {\@link yfiles.view.ModelManager.<T>#enabled} is set to false the item will not be installed.
 * </p>
 * @protected
 * @param {T} item The item to add.
 * @return {?} The newly created canvas object or <code>null</code> if nothing was installed.
 */
yfiles.view.ModelManager.prototype.add = function(item) {};

/**
 * Callback used by {\@link yfiles.view.ModelManager.<T>#install} to retrieve the canvas object group for a given item.
 * <p>
 * Returning <code>null</code> will cause {\@link yfiles.view.ModelManager.<T>#install} not to install anything.
 * </p>
 * @protected
 * @abstract
 * @param {T} item The item to find a canvas object group for.
 * @return {?} An {\@link } or <code>null</code>
 */
yfiles.view.ModelManager.prototype.getCanvasObjectGroup = function(item) {};

/**
 * Callback used by {\@link yfiles.view.ModelManager.<T>#install} to retrieve the installer for a given item.
 * <p>
 * Implementations may use the {\@link yfiles.graph.ILookup#lookup} of the item.
 * </p>
 * <p>
 * Returning <code>null</code> will cause {\@link yfiles.view.ModelManager.<T>#install} not to install anything.
 * </p>
 * @protected
 * @abstract
 * @param {T} item The item to find an installer for.
 * @return {?} An installer or <code>null</code>
 */
yfiles.view.ModelManager.prototype.getInstaller = function(item) {};

/**
 * Installs a member of the collection into the canvas using the {\@link yfiles.view.ICanvasObjectDescriptor} which is returned by
 * {\@link yfiles.view.ModelManager.<T>#getInstaller}.
 * @protected
 * @param {T} item The member to install.
 * @return {?} The canvas object that has been returned by the installer.
 */
yfiles.view.ModelManager.prototype.install = function(item) {};

/**
 * Called when this mode gets {\@link yfiles.view.ModelManager.<T>#enabled disabled}.
 * @protected
 * @abstract
 * @return {void}
 */
yfiles.view.ModelManager.prototype.onDisabled = function() {};

/**
 * Called when this mode gets {\@link yfiles.view.ModelManager.<T>#enabled enabled}.
 * @protected
 * @abstract
 * @return {void}
 */
yfiles.view.ModelManager.prototype.onEnabled = function() {};

/**
 * Uninstalls the provided item and removes it from this managers set of managed items.
 * @protected
 * @param {T} item The item to remove.
 * @return {void}
 */
yfiles.view.ModelManager.prototype.remove = function(item) {};

/**
 * Simple implementation that removes the given {\@link yfiles.view.ICanvasObject}.
 * @see yfiles.view.ICanvasObject#remove
 * @protected
 * @param {?} canvasObject The canvas objects that have been associated with the descriptor.
 * @return {void}
 */
yfiles.view.ModelManager.prototype.unInstall = function(canvasObject) {};
/**
 * @record
 * @struct
 */
yfiles.view.SelectionIndicatorManager = function() {};
 /** @type {?<T>} */
yfiles.view.SelectionIndicatorManager.prototype.selectionModel;
 /** @type {?<T>} */
yfiles.view.SelectionIndicatorManager.prototype.model;
 /** @type {!yfiles.lang.Class} */
yfiles.view.SelectionIndicatorManager.$class;

/**
 * Adds an item to the current selection.
 * @param {T} item The item whose selection decorator will added.
 * @return {?}
 */
yfiles.view.SelectionIndicatorManager.prototype.addSelection = function(item) {};

/**
 * Removes an item from the current selection.
 * @param {T} item The item whose selection decorator will be removed.
 * @return {void}
 */
yfiles.view.SelectionIndicatorManager.prototype.removeSelection = function(item) {};
/**
 * @record
 * @struct
 */
yfiles.view.SvgVisualGroup = function() {};
 /** @type {!yfiles.geometry.Matrix} */
yfiles.view.SvgVisualGroup.prototype.transform;
 /** @type {?<!yfiles.view.SvgVisual>} */
yfiles.view.SvgVisualGroup.prototype.children;
 /** @type {!yfiles.lang.Class} */
yfiles.view.SvgVisualGroup.$class;

/**
 * Adds another {\@link yfiles.view.SvgVisual} to the children collection of this instance.
 * @param {!yfiles.view.SvgVisual} child The child to add.
 * @return {void}
 */
yfiles.view.SvgVisualGroup.prototype.add = function(child) {};

/**
 * Removes a previously added {\@link yfiles.view.SvgVisual} from the children collection of this instance.
 * @param {!yfiles.view.SvgVisual} child The child to remove.
 * @return {void}
 */
yfiles.view.SvgVisualGroup.prototype.remove = function(child) {};
/**
 * @record
 * @struct
 */
yfiles.view.GridVisualCreator = function() {};
 /** @type {yfiles.view.GridStyle} */
yfiles.view.GridVisualCreator.prototype.gridStyle;
 /** @type {!yfiles.view.GridInfo} */
yfiles.view.GridVisualCreator.prototype.gridInfo;
 /** @type {boolean} */
yfiles.view.GridVisualCreator.prototype.visible;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.GridVisualCreator.prototype.stroke;
 /** @type {number} */
yfiles.view.GridVisualCreator.prototype.visibilityThreshold;
 /** @type {!yfiles.lang.Class} */
yfiles.view.GridVisualCreator.$class;

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.view.GridVisualCreator.prototype.createVisual = function(context) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.view.GridVisualCreator.prototype.updateVisual = function(context, oldVisual) {};

/** @const */
yfiles.view.GridStyle = {};
/** @const {number} */
yfiles.view.GridStyle.DOTS;
/** @const {number} */
yfiles.view.GridStyle.CROSSES;
/** @const {number} */
yfiles.view.GridStyle.LINES;
/**
 * @record
 * @struct
 */
yfiles.view.IBoundsProvider = function() {};

/**
 * Returns a tight rectangular area where the whole rendering would fit into.
 * <p>
 * If calculating the bounds is too expensive or the rendering is not bound to a certain area, this method may return
 * {\@link yfiles.geometry.Rect#INFINITE}. If nothing is rendered, this method should return an empty rectangle, where either or
 * both the width and height is non-positive or {\@link yfiles.geometry.Rect#EMPTY}.
 * </p>
 * @abstract
 * @param {?} context the context to calculate the bounds for
 * @return {!yfiles.geometry.Rect} the bounds or {\@link #EMPTY} to indicate an unbound area
 */
yfiles.view.IBoundsProvider.prototype.getBounds = function(context) {};
 /** @type {{fromRectangle: function(?): ?, EMPTY: ?, UNBOUNDED: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IBoundsProvider;
/**
 * @record
 * @struct
 */
yfiles.view.IVisibilityTestable = function() {};

/**
 * Determines whether an element might intersect the visible region for a given context.
 * <p>
 * Conservative implementations can always return <code>true</code>.
 * </p>
 * @abstract
 * @param {?} context The context to determine the visibility for.
 * @param {!yfiles.geometry.Rect} rectangle The visible region clip.
 * @return {boolean} <code>false</code> if and only if it is safe not to paint the element because it would not affect the given clipping region.
 */
yfiles.view.IVisibilityTestable.prototype.isVisible = function(context, rectangle) {};
 /** @type {{ALWAYS: ?, NEVER: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IVisibilityTestable;

/** @const */
yfiles.view.VisualCachingPolicy = {};
/** @const {number} */
yfiles.view.VisualCachingPolicy.NEVER;
/** @const {number} */
yfiles.view.VisualCachingPolicy.ALWAYS;
/**
 * @record
 * @struct
 */
yfiles.view.IRenderContext = function() {};
 /** @type {!yfiles.geometry.Rect} */
yfiles.view.IRenderContext.prototype.clip;
 /** @type {!yfiles.geometry.Matrix} */
yfiles.view.IRenderContext.prototype.viewTransform;
 /** @type {!Element} */
yfiles.view.IRenderContext.prototype.defsElement;
 /** @type {!yfiles.view.SvgDefsManager} */
yfiles.view.IRenderContext.prototype.svgDefsManager;

/**
 * Notifies the context that the <code>visual</code> has been removed from the visual tree.
 * <p>
 * This has to be done in a {\@link yfiles.view.IVisualCreator}'s {\@link yfiles.view.IVisualCreator#updateVisual} method if a
 * {\@link yfiles.view.IVisualCreator}'s {\@link yfiles.view.IVisualCreator#createVisual} is called or a previously added visual will be
 * removed or replaced. Calling this method will call a previously {\@link yfiles.view.IRenderContext#setDisposeCallback registered} dispose visual callback that the <code>visual</code> has
 * been removed and needs to free its resources.
 * </p>
 * <p>
 * If the <code>visual</code> has not been registered previously this method will do nothing.
 * </p>
 * @see yfiles.view.IRenderContext#setDisposeCallback
 * @see yfiles.view.IVisualCreator
 * @see yfiles.view.IVisualCreator#updateVisual
 * @param {!yfiles.view.Visual} visual The visual which has been removed.
 * @return {void}
 */
yfiles.view.IRenderContext.prototype.childVisualRemoved = function(visual) {};

/**
 * Registers a visual if children have registered themselves for disposal.
 * <p>
 * This is necessary for visual creators which delegate to another visual creator to create one or more child visuals, like
 * style decorators.
 * </p>
 * <p>
 * Implementors have to add a call to this method at the end of their {\@link yfiles.view.IVisualCreator#createVisual} and {\@link yfiles.view.IVisualCreator#updateVisual}
 * methods.
 * </p>
 * <p>
 * The registered <code>callback</code> has to call {\@link yfiles.view.IRenderContext#childVisualRemoved} on all child visuals of the <code>visual</code>.
 * </p>
 * @param {!yfiles.view.Visual} visual The visual to be registered. This is the visual which is returned by the {\@link #createVisual} or {\@link #updateVisual}
 * method which calls this method.
 * @param {function(?, !yfiles.view.Visual, boolean): !yfiles.view.Visual} callback A dispose visual callback which calls {\@link #childVisualRemoved} on all child visuals of the
 * registered <code>visual</code>.
 * @return {void}
 */
yfiles.view.IRenderContext.prototype.registerForChildrenIfNecessary = function(visual, callback) {};

/**
 * Registers a <code>callback</code> which will be called when the <code>visual</code> will be removed from the visual tree.
 * <p>
 * This applies to a {\@link yfiles.view.IVisualCreator}'s {\@link yfiles.view.IVisualCreator#createVisual} method if the created <code>visual</code>
 * allocates resources which should be freed after the visual is no longer used. In this case the visual has to be
 * registered together with a dispose visual callback which can free the allocated resources. The callback will be called
 * by the framework when the visual is removed from the visual tree.
 * </p>
 * <p>
 * The callback can also be used to support caching for temporarily removed visuals. See dispose visual callback.
 * </p>
 * @see yfiles.view.IVisualCreator
 * @see yfiles.view.IVisualCreator#createVisual
 * @param {!yfiles.view.Visual} visual The visual which needs to be disposed after removal.
 * @param {function(?, !yfiles.view.Visual, boolean): !yfiles.view.Visual} callback A callback which will dispose the <code>visual</code>.
 * @return {void}
 */
yfiles.view.IRenderContext.prototype.setDisposeCallback = function(visual, callback) {};

/**
 * Converts the given set of world coordinates to a coordinate pair that can be used to render within the {\@link yfiles.view.IRenderContext#viewTransform}.
 * @see yfiles.view.IRenderContext#viewTransform
 * @abstract
 * @param {!yfiles.geometry.Point} worldPoint The coordinates in the world coordinate system.
 * @return {!yfiles.geometry.Point} The coordinates in the view coordinate system.
 */
yfiles.view.IRenderContext.prototype.toViewCoordinates = function(worldPoint) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IRenderContext;
/**
 * @record
 * @struct
 */
yfiles.view.IVisualCreator = function() {};

/**
 * This method is called by the framework to create a {\@link yfiles.view.Visual} that will be included into the
 * {\@link yfiles.view.IRenderContext}.
 * <p>
 * {\@link yfiles.view.CanvasComponent} uses this interface through the {\@link yfiles.view.ICanvasObjectDescriptor} to populate the visual
 * canvas object tree.
 * </p>
 * @see yfiles.view.IVisualCreator#updateVisual
 * @abstract
 * @param {?} context The context that describes where the visual will be used.
 * @return {!yfiles.view.Visual} The visual to include in the canvas object visual tree. This may be <code>null</code>.
 */
yfiles.view.IVisualCreator.prototype.createVisual = function(context) {};

/**
 * This method updates or replaces a previously created {\@link yfiles.view.Visual} for inclusion in the
 * {\@link yfiles.view.IRenderContext}.
 * <p>
 * The {\@link yfiles.view.CanvasComponent} uses this method to give implementations a chance to update an existing Visual that has
 * previously been created by the same instance during a call to {\@link yfiles.view.IVisualCreator#createVisual}. Implementation
 * may update the <code>oldVisual</code> and return that same reference, or create a new visual and return the new instance or <code>null</code>.
 * </p>
 * @see yfiles.view.IVisualCreator#createVisual
 * @see yfiles.view.ICanvasObjectDescriptor
 * @see yfiles.view.CanvasComponent
 * @abstract
 * @param {?} context The context that describes where the visual will be used in.
 * @param {!yfiles.view.Visual} oldVisual The visual instance that had been returned the last time the {\@link #createVisual} method was called
 * on this instance.
 * @return {!yfiles.view.Visual} <code>oldVisual</code>, if this instance modified the visual, or a new visual that should replace the existing one in the canvas
 * object visual tree.
 */
yfiles.view.IVisualCreator.prototype.updateVisual = function(context, oldVisual) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IVisualCreator;
/**
 * @record
 * @struct
 */
yfiles.view.VoidVisualCreator = function() {};
 /** @type {?} */
yfiles.view.VoidVisualCreator.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.view.VoidVisualCreator.$class;

/**
 * Returns <code>null</code>.
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.view.VoidVisualCreator.prototype.createVisual = function(context) {};

/**
 * Returns <code>null</code>.
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.view.VoidVisualCreator.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.view.OrientedRectangleIndicatorInstaller = function() {};
 /** @type {string} */
yfiles.view.OrientedRectangleIndicatorInstaller.SELECTION_TEMPLATE_KEY;
 /** @type {string} */
yfiles.view.OrientedRectangleIndicatorInstaller.FOCUS_TEMPLATE_KEY;
 /** @type {string} */
yfiles.view.OrientedRectangleIndicatorInstaller.HIGHLIGHT_TEMPLATE_KEY;
 /** @type {?} */
yfiles.view.OrientedRectangleIndicatorInstaller.prototype.template;
 /** @type {!yfiles.lang.Class} */
yfiles.view.OrientedRectangleIndicatorInstaller.$class;

/**
 *
 * @param {?} context
 * @param {?} group
 * @param {!Object} item
 * @return {?}
 */
yfiles.view.OrientedRectangleIndicatorInstaller.prototype.addCanvasObject = function(context, group, item) {};

/**
 * Factory method that returns an {\@link yfiles.geometry.IOrientedRectangle} for a given user object.
 * <p>
 * This method is called for the object to {\@link yfiles.view.ICanvasObjectGroup#addChild add} to the
 * {\@link yfiles.view.ICanvasObjectGroup}, if there are no fixed bounds set on this instance (i.e. the parameterless constructor
 * was used to instantiate this class).
 * </p>
 * <p>
 * This implementation returns null for every given object.
 * </p>
 * @protected
 * @param {!Object} item
 * @return {?} An {\@link } for the given item that is {\@link #addChild added} to the {\@link }.
 */
yfiles.view.OrientedRectangleIndicatorInstaller.prototype.getRectangle = function(item) {};
/**
 * @record
 * @struct
 */
yfiles.view.PointSelectionIndicatorInstaller = function() {};
 /** @type {!yfiles.view.Stroke} */
yfiles.view.PointSelectionIndicatorInstaller.prototype.stroke;
 /** @type {!yfiles.view.Fill} */
yfiles.view.PointSelectionIndicatorInstaller.prototype.fill;
 /** @type {!yfiles.lang.Class} */
yfiles.view.PointSelectionIndicatorInstaller.$class;

/**
 *
 * @param {?} context
 * @param {?} group
 * @param {!Object} item
 * @return {?}
 */
yfiles.view.PointSelectionIndicatorInstaller.prototype.addCanvasObject = function(context, group, item) {};

/**
 * Factory method that retrieves the center for a given user object.
 * <p>
 * This implementation simply returns the value provided to the constructor.
 * </p>
 * @protected
 * @param {!Object} userObject
 * @return {?}
 */
yfiles.view.PointSelectionIndicatorInstaller.prototype.getCenterPoint = function(userObject) {};
/**
 * @record
 * @struct
 */
yfiles.view.RectangleIndicatorInstaller = function() {};
 /** @type {string} */
yfiles.view.RectangleIndicatorInstaller.SELECTION_TEMPLATE_KEY;
 /** @type {string} */
yfiles.view.RectangleIndicatorInstaller.FOCUS_TEMPLATE_KEY;
 /** @type {string} */
yfiles.view.RectangleIndicatorInstaller.HIGHLIGHT_TEMPLATE_KEY;
 /** @type {?} */
yfiles.view.RectangleIndicatorInstaller.prototype.template;
 /** @type {!yfiles.lang.Class} */
yfiles.view.RectangleIndicatorInstaller.$class;

/**
 *
 * @param {?} context
 * @param {?} group
 * @param {!Object} item
 * @return {?}
 */
yfiles.view.RectangleIndicatorInstaller.prototype.addCanvasObject = function(context, group, item) {};

/**
 * Factory method that returns an {\@link yfiles.geometry.IRectangle} for a given user object.
 * <p>
 * This method is called for the object to {\@link yfiles.view.ICanvasObjectGroup#addChild add} to the
 * {\@link yfiles.view.ICanvasObjectGroup}, if there are no fixed bounds set on this instance (i.e. the parameterless constructor
 * was used to instantiate this class).
 * </p>
 * <p>
 * This implementation returns null for every given object.
 * </p>
 * @protected
 * @param {!Object} userObject
 * @return {?} An {\@link } for the given item that is {\@link #addChild added} to the {\@link }.
 */
yfiles.view.RectangleIndicatorInstaller.prototype.getRectangle = function(userObject) {};
/**
 * @record
 * @struct
 */
yfiles.view.ViewportLimiter = function() {};
 /** @type {boolean} */
yfiles.view.ViewportLimiter.prototype.honorBothDimensions;
 /** @type {!yfiles.geometry.Rect} */
yfiles.view.ViewportLimiter.prototype.bounds;
 /** @type {!yfiles.lang.Class} */
yfiles.view.ViewportLimiter.$class;

/**
 * Gets the to bounds that should be honored for the upcoming call.
 * <p>
 * This method is used as callback by {\@link yfiles.view.ViewportLimiter#limitViewport} for each request. The default
 * implementation just yields {\@link yfiles.view.ViewportLimiter#bounds}.
 * </p>
 * @protected
 * @param {!yfiles.view.CanvasComponent} canvas The canvas control.
 * @param {!yfiles.geometry.Rect} suggestedViewport The suggested viewport.
 * @return {!yfiles.geometry.Rect} The bounds to honor or <code>null</code>.
 */
yfiles.view.ViewportLimiter.prototype.getCurrentBounds = function(canvas, suggestedViewport) {};

/**
 * Inspects the desired or suggested new viewport for the given control and returns a valid viewport to use.
 * @param {!yfiles.view.CanvasComponent} canvas The canvas control on which the viewport should be applied.
 * @param {!yfiles.geometry.Rect} suggestedViewport The suggested viewport.
 * @return {!yfiles.geometry.Rect} The viewport that should be used.
 */
yfiles.view.ViewportLimiter.prototype.limitViewport = function(canvas, suggestedViewport) {};

/** @const */
yfiles.view.DragDropKeyStates = {};
/** @const {number} */
yfiles.view.DragDropKeyStates.POINTER_DOWN;
/** @const {number} */
yfiles.view.DragDropKeyStates.NONE;
/** @const {number} */
yfiles.view.DragDropKeyStates.SHIFT_KEY;
/** @const {number} */
yfiles.view.DragDropKeyStates.CONTROL_KEY;
/** @const {number} */
yfiles.view.DragDropKeyStates.ALT_KEY;
/**
 * @record
 * @struct
 */
yfiles.view.DefaultPortCandidateDescriptor = function() {};
 /** @type {string} */
yfiles.view.DefaultPortCandidateDescriptor.CANDIDATE_DRAWING_VALID_NON_FOCUSED_KEY;
 /** @type {string} */
yfiles.view.DefaultPortCandidateDescriptor.CANDIDATE_DRAWING_VALID_FOCUSED_KEY;
 /** @type {string} */
yfiles.view.DefaultPortCandidateDescriptor.CANDIDATE_DRAWING_INVALID_NON_FOCUSED_KEY;
 /** @type {string} */
yfiles.view.DefaultPortCandidateDescriptor.CANDIDATE_DRAWING_INVALID_FOCUSED_KEY;
 /** @type {boolean} */
yfiles.view.DefaultPortCandidateDescriptor.prototype.currentCandidate;
 /** @type {number} */
yfiles.view.DefaultPortCandidateDescriptor.prototype.size;
 /** @type {!yfiles.lang.Class} */
yfiles.view.DefaultPortCandidateDescriptor.$class;

/**
 *
 * @param {!Object} forUserObject
 * @return {?}
 */
yfiles.view.DefaultPortCandidateDescriptor.prototype.getBoundsProvider = function(forUserObject) {};

/**
 *
 * @param {!Object} forUserObject
 * @return {?}
 */
yfiles.view.DefaultPortCandidateDescriptor.prototype.getHitTestable = function(forUserObject) {};

/**
 *
 * @param {!Object} forUserObject
 * @return {?}
 */
yfiles.view.DefaultPortCandidateDescriptor.prototype.getVisibilityTestable = function(forUserObject) {};

/**
 *
 * @param {!Object} forUserObject
 * @return {?}
 */
yfiles.view.DefaultPortCandidateDescriptor.prototype.getVisualCreator = function(forUserObject) {};

/**
 *
 * @param {?} context
 * @param {?} canvasObject
 * @return {boolean}
 */
yfiles.view.DefaultPortCandidateDescriptor.prototype.isDirty = function(context, canvasObject) {};

/**
 * Sets the {\@link yfiles.view.IVisualTemplate} to use for the given {\@link string} by this instance.
 * <p>
 * This method can be used to reconfigure the visualization for the various keys that are declared by this class.
 * </p>
 * @param {string} resourceKey The key to reconfigure. This is one of
 * {\@link #CANDIDATE_DRAWING_VALID_NON_FOCUSED_KEY},
 * {\@link #CANDIDATE_DRAWING_INVALID_NON_FOCUSED_KEY},
 * {\@link #CANDIDATE_DRAWING_INVALID_FOCUSED_KEY},
 * {\@link #CANDIDATE_DRAWING_VALID_FOCUSED_KEY}.
 * @param {?} template The template to use instead of the default.
 * @return {void}
 */
yfiles.view.DefaultPortCandidateDescriptor.prototype.setTemplate = function(resourceKey, template) {};
/**
 * @record
 * @struct
 */
yfiles.view.GraphModelManager = function() {};
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.nodeGroup;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.edgeGroup;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.edgeLabelGroup;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.nodeLabelGroup;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.portGroup;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.edgeDescriptor;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.portDescriptor;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.edgeLabelDescriptor;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.nodeLabelDescriptor;
 /** @type {boolean} */
yfiles.view.GraphModelManager.prototype.useHierarchicEdgeNesting;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.nodeDescriptor;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.contentGroup;
 /** @type {?<?>} */
yfiles.view.GraphModelManager.prototype.comparer;
 /** @type {?<?>} */
yfiles.view.GraphModelManager.prototype.hitTester;
 /** @type {?} */
yfiles.view.GraphModelManager.prototype.graph;
 /** @type {boolean} */
yfiles.view.GraphModelManager.prototype.useHierarchicNodeNesting;
 /** @type {?} */
yfiles.view.GraphModelManager.DEFAULT_NODE_DESCRIPTOR;
 /** @type {?} */
yfiles.view.GraphModelManager.DEFAULT_EDGE_DESCRIPTOR;
 /** @type {?} */
yfiles.view.GraphModelManager.DEFAULT_PORT_DESCRIPTOR;
 /** @type {?} */
yfiles.view.GraphModelManager.DEFAULT_LABEL_DESCRIPTOR;
 /** @type {!yfiles.lang.Class} */
yfiles.view.GraphModelManager.$class;

/**
 * Compares two items with respect to their visibility order.
 * @see yfiles.view.GraphModelManager#comparer
 * @param {?} item1 the first item to compare
 * @param {?} item2 the second item to compare
 * @return {number} an integer value indicating the relative rendering order of the two items
 */
yfiles.view.GraphModelManager.prototype.compare = function(item1, item2) {};

/**
 * Factory method that creates the {\@link yfiles.view.GraphModelManager#contentGroup}
 * <p>
 * The default implementation will just add another group to the {\@link yfiles.view.CanvasComponent}.
 * </p>
 * @protected
 * @return {?} The group to use for adding the content.
 */
yfiles.view.GraphModelManager.prototype.createContentGroup = function() {};

/**
 * Factory method for the {\@link yfiles.view.GraphModelManager#edgeGroup} property.
 * <p>
 * This method will be called upon first access to the property.
 * </p>
 * @protected
 * @return {?} a new group that has been added to the {\@link #contentGroup}
 */
yfiles.view.GraphModelManager.prototype.createEdgeGroup = function() {};

/**
 * Factory method for the {\@link yfiles.view.GraphModelManager#edgeLabelGroup} property.
 * <p>
 * This method will be called upon first access to the property.
 * </p>
 * @protected
 * @return {?} a new group that has been added to the {\@link #contentGroup}
 */
yfiles.view.GraphModelManager.prototype.createEdgeLabelGroup = function() {};

/**
 * Gets a {\@link yfiles.input.IHitTester.<T>} that can be used to enumerate hits on the canvas at a given world coordinate position.
 * <p>
 * This enumerator will enumerate hits in the order so that the visually topmost element will be reported first.
 * </p>
 * Type parameter <code>T</code>.
 * @template T
 * @param {!yfiles.lang.Class} itemType
 * @return {?<T>}
 */
yfiles.view.GraphModelManager.prototype.createHitTester = function(itemType) {};

/**
 * Factory method for the {\@link yfiles.view.GraphModelManager#nodeGroup} property.
 * <p>
 * This method will be called upon first access to the property.
 * </p>
 * @protected
 * @return {?} a new group that has been added to the {\@link #contentGroup}
 */
yfiles.view.GraphModelManager.prototype.createNodeGroup = function() {};

/**
 * Factory method for the {\@link yfiles.view.GraphModelManager#nodeLabelGroup} property.
 * <p>
 * This method will be called upon first access to the property.
 * </p>
 * @protected
 * @return {?} a new group that has been added to the {\@link #contentGroup}
 */
yfiles.view.GraphModelManager.prototype.createNodeLabelGroup = function() {};

/**
 * Factory method for the {\@link yfiles.view.GraphModelManager#portGroup} property.
 * <p>
 * This method will be called upon first access to the property.
 * </p>
 * @protected
 * @return {?} a new group that has been added to the {\@link #contentGroup}
 */
yfiles.view.GraphModelManager.prototype.createPortGroup = function() {};

/**
 * Retrieves the {\@link yfiles.view.ICanvasObject} for a given model item managed by this instance.
 * @see yfiles.view.ItemModelManager.<T>#getCanvasObject
 * @param {?} item the item
 * @return {?} the canvas object for the given item or <code>null</code>
 */
yfiles.view.GraphModelManager.prototype.getCanvasObject = function(item) {};

/**
 * Retrieves the Canvas Object group to use for the given label.
 * <p>
 * This implementation is called by the default {\@link yfiles.view.GraphModelManager#nodeLabelDescriptor} and {\@link yfiles.view.GraphModelManager#edgeLabelDescriptor} instances.
 * </p>
 * @protected
 * Retrieves the Canvas Object group to use for the given port.
 * <p>
 * This implementation is called by the default {\@link yfiles.view.GraphModelManager#portDescriptor} instance.
 * </p>
 * @protected
 * Retrieves the Canvas Object group to use for the given edge.
 * <p>
 * This implementation is called by the default {\@link yfiles.view.GraphModelManager#edgeDescriptor} instance.
 * </p>
 * @protected
 * Retrieves the Canvas Object group to use for the given node.
 * <p>
 * This implementation is called by the default {\@link yfiles.view.GraphModelManager#nodeDescriptor} instance.
 * </p>
 * @protected
 * @param {?} label_or_port_or_edge_or_node The label that will be installed in the canvas. / The port that will be installed in the canvas. / The edge that will be installed in the canvas. / The node that will be installed in the canvas.
 * @return {?} The group to use.
 */
yfiles.view.GraphModelManager.prototype.getCanvasObjectGroup = function(label_or_port_or_edge_or_node) {};

/**
 * Retrieves the corresponding {\@link yfiles.graph.IModelItem} for the given canvas object.
 * @param {?} canvasObject the instance to use for the query
 * @return {?} The item that is associated with the object or <code>null</code>.
 */
yfiles.view.GraphModelManager.prototype.getModelItem = function(canvasObject) {};

/**
 * Enumerates hits on the canvas at a given world coordinate position for a given context.
 * <p>
 * The instance returned will enumerate hits in the order so that the topmost visual element will be reported first. The
 * enumeration is performed lazily.
 * </p>
 * Enumerates hits on the canvas at a given world coordinate position.
 * <p>
 * The instance returned will enumerate hits in the order so that the topmost visual element will be reported first. The
 * enumeration is performed lazily.
 * </p>
 * @param {?|!yfiles.geometry.Point} context_or_location The context to provide to {\@link #isHit} / the world coordinates to perform the hit test
 * @param {!yfiles.geometry.Point=} location the world coordinates to perform the hit test
 * @param {?=} root The group to search the subtree of.
 * @return {?<?>} an enumerable that will enumerate the hits at the given coordinates
 */
yfiles.view.GraphModelManager.prototype.hitElementsAt = function(context_or_location, location, root) {};

/**
 * Called when the {\@link yfiles.view.GraphModelManager#graph} property changes.
 * <p>
 * This method registers the collections of the graph instance with the {\@link yfiles.view.CollectionModelManager.<T> mechanism} that manages the mapping between the
 * elements and the
 * {\@link yfiles.view.ICanvasObject}s. Subclasses should call the base method if they want to use the default mechanisms.
 * </p>
 * @protected
 * @param {?} oldGraph The old graph instance.
 * @param {?} newGraph The new graph instance.
 * @return {void}
 */
yfiles.view.GraphModelManager.prototype.onGraphChanged = function(oldGraph, newGraph) {};

/**
 * Enumerates hits on the canvas at a given world coordinate position in a given context.
 * <p>
 * The instance returned will enumerate hits in the order so that the topmost visual element will be reported first. The
 * enumeration is performed lazily.
 * </p>
 * Type parameter <code>T</code>.
 * Enumerates hits on the canvas at a given world coordinate position.
 * <p>
 * The instance returned will enumerate hits in the order so that the topmost visual element will be reported first. The
 * enumeration is performed lazily.
 * </p>
 * Type parameter <code>T</code>.
 * @template T
 * @param {!yfiles.lang.Class} modelItemType_or_itemType
 * @param {?|!yfiles.geometry.Point} context_or_location The context to provide to {\@link #isHit} / the world coordinates to perform the hit test
 * @param {!yfiles.geometry.Point=} location the world coordinates to perform the hit test
 * @param {?=} root The group to search the subtree of.
 * @return {?<T>} an enumerable that will enumerate the hits at the given coordinates
 */
yfiles.view.GraphModelManager.prototype.typedHitElementsAt = function(modelItemType_or_itemType, context_or_location, location, root) {};

/**
 * {\@link yfiles.view.CollectionModelManager.<T>#update Updates} the visual representation of the given item.
 * @see yfiles.view.CollectionModelManager.<T>#update
 * @param {?} item The item to update the visual representation
 * @return {void}
 */
yfiles.view.GraphModelManager.prototype.update = function(item) {};
/**
 * @record
 * @struct
 */
yfiles.view.GraphObstacleProvider = function() {};
 /** @type {boolean} */
yfiles.view.GraphObstacleProvider.prototype.queryEdges;
 /** @type {boolean} */
yfiles.view.GraphObstacleProvider.prototype.queryNodes;
 /** @type {!yfiles.lang.Class} */
yfiles.view.GraphObstacleProvider.$class;

/**
 * Helper method that retrieves the {\@link yfiles.graph.IGraph} to use from the <code>context</code>
 * <p>
 * This implementation uses the {\@link yfiles.graph.ILookup#lookup} of the {\@link yfiles.view.ICanvasContext#canvasComponent} to query the {\@link yfiles.graph.IGraph} implementation.
 * </p>
 * @protected
 * @param {?} context The context to retrieve the implementation from.
 * @return {?} The {\@link } instance to query or <code>null</code>.
 */
yfiles.view.GraphObstacleProvider.prototype.getGraph = function(context) {};

/**
 * Iterates over all {\@link yfiles.graph.IGraph#edges} and {\@link yfiles.graph.IGraph#nodes} to query an {\@link yfiles.view.IObstacleProvider} from the {\@link yfiles.graph.IModelItem}'s
 * {\@link yfiles.graph.ILookup#lookup}.
 * <p>
 * This method will depending on the {\@link yfiles.view.GraphObstacleProvider#queryEdges} and {\@link yfiles.view.GraphObstacleProvider#queryNodes} property query the items for an implementation of {\@link yfiles.view.IObstacleProvider}
 * and concatenate all resulting {\@link yfiles.geometry.GeneralPath} obstacles into one path that will then be returned.
 * </p>
 * @param {?} context The context where the obstacles are queried for.
 * @return {!yfiles.geometry.GeneralPath} A path that is the concatenated path of all obstacles for the given context.
 */
yfiles.view.GraphObstacleProvider.prototype.getObstacles = function(context) {};
/**
 * @record
 * @struct
 */
yfiles.view.GraphSelection = function() {};
 /** @type {?<?>} */
yfiles.view.GraphSelection.prototype.selectedNodes;
 /** @type {?<?>} */
yfiles.view.GraphSelection.prototype.selectedEdges;
 /** @type {?<?>} */
yfiles.view.GraphSelection.prototype.selectedLabels;
 /** @type {?<?>} */
yfiles.view.GraphSelection.prototype.selectedPorts;
 /** @type {?<?>} */
yfiles.view.GraphSelection.prototype.selectedBends;
 /** @type {number} */
yfiles.view.GraphSelection.prototype.size;
 /** @type {?} */
yfiles.view.GraphSelection.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.view.GraphSelection.$class;

/**
 *
 * @return {void}
 */
yfiles.view.GraphSelection.prototype.clear = function() {};

/**
 * Factory method that creates the {\@link yfiles.view.DefaultSelectionModel.<T>} to use for the bends.
 * @protected
 * @return {!yfiles.view.DefaultSelectionModel<?>}
 */
yfiles.view.GraphSelection.prototype.createBendSelectionModel = function() {};

/**
 * Factory method that creates the {\@link yfiles.view.DefaultSelectionModel.<T>} to use for the edges.
 * @protected
 * @return {!yfiles.view.DefaultSelectionModel<?>}
 */
yfiles.view.GraphSelection.prototype.createEdgeSelectionModel = function() {};

/**
 * Factory method that creates the {\@link yfiles.view.DefaultSelectionModel.<T>} to use for the labels.
 * @protected
 * @return {!yfiles.view.DefaultSelectionModel<?>}
 */
yfiles.view.GraphSelection.prototype.createLabelSelectionModel = function() {};

/**
 * Factory method that creates the {\@link yfiles.view.DefaultSelectionModel.<T>} to use for the nodes.
 * @protected
 * @return {!yfiles.view.DefaultSelectionModel<?>}
 */
yfiles.view.GraphSelection.prototype.createNodeSelectionModel = function() {};

/**
 * Factory method that creates the {\@link yfiles.view.DefaultSelectionModel.<T>} to use for the ports.
 * @protected
 * @return {!yfiles.view.DefaultSelectionModel<?>}
 */
yfiles.view.GraphSelection.prototype.createPortSelectionModel = function() {};

/**
 * Returns an enumerator that iterates through the collection of all selected elements.
 * @return {?<?>} An {\@link } object that can be used to iterate through all selected elements.
 */
yfiles.view.GraphSelection.prototype.getEnumerator = function() {};

/**
 *
 * @param {?} item
 * @return {boolean}
 */
yfiles.view.GraphSelection.prototype.isSelected = function(item) {};

/**
 * Raises the {\@link yfiles.view.GraphSelection#addItemSelectionChangedListener ItemSelectionChanged} event
 * @protected
 * @param {!yfiles.view.ItemSelectionChangedEventArgs<?>} evt The parameters for the event
 * @return {void}
 */
yfiles.view.GraphSelection.prototype.onItemSelectionChanged = function(evt) {};

/**
 *
 * @param {?} item
 * @param {boolean} selected
 * @return {void}
 */
yfiles.view.GraphSelection.prototype.setSelected = function(item, selected) {};

/**
 *
 * @param {function(!Object, !yfiles.view.ItemSelectionChangedEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.view.GraphSelection.prototype.addItemSelectionChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.view.ItemSelectionChangedEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.view.GraphSelection.prototype.removeItemSelectionChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.view.IGraphSelection = function() {};
 /** @type {?<?>} */
yfiles.view.IGraphSelection.prototype.selectedNodes;
 /** @type {?<?>} */
yfiles.view.IGraphSelection.prototype.selectedLabels;
 /** @type {?<?>} */
yfiles.view.IGraphSelection.prototype.selectedEdges;
 /** @type {?<?>} */
yfiles.view.IGraphSelection.prototype.selectedPorts;
 /** @type {?<?>} */
yfiles.view.IGraphSelection.prototype.selectedBends;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IGraphSelection;
/**
 * @record
 * @struct
 */
yfiles.view.EdgeDecorationInstaller = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.view.EdgeDecorationInstaller.$class;

/**
 * Installs a rendering for the <code>item</code> if it is an {\@link yfiles.graph.IEdge} that will use the {\@link yfiles.view.EdgeDecorationInstaller#getBendDrawing}
 * and {\@link yfiles.view.EdgeDecorationInstaller#getStroke} to render the path and bends.
 * @param {?} context The canvas context.
 * @param {?} group The {\@link } to add the new canvas object to.
 * @param {!Object} item The item to install.
 * @return {?} The canvas object representing the item.
 */
yfiles.view.EdgeDecorationInstaller.prototype.addCanvasObject = function(context, group, item) {};

/**
 * Callback method that retrieves the drawing of the bend for the context.
 * <p>
 * This implementation will use the {\@link yfiles.view.EdgeSelectionIndicatorInstaller#BEND_TEMPLATE_KEY} resource to find a {\@link yfiles.view.IVisualTemplate}
 * instance. If <code>null</code> is yielded, a default drawing will be used.
 * </p>
 * @protected
 * @abstract
 * @param {!yfiles.view.CanvasComponent} canvas The canvas for which the drawing shall be returned.
 * @param {?} edge The edge for which the rendering will be used.
 * @return {?} The drawing instance to use for the rendering of the bends in the given context.
 */
yfiles.view.EdgeDecorationInstaller.prototype.getBendDrawing = function(canvas, edge) {};

/**
 * Callback method that retrieves the {\@link yfiles.view.Stroke} for the context.
 * <p>
 * This implementation will use the {\@link yfiles.view.EdgeSelectionIndicatorInstaller#STROKE_KEY} resource to find a {\@link yfiles.view.Stroke}
 * instance. If <code>null</code> is yielded, a default {\@link yfiles.view.Stroke} will be used.
 * </p>
 * @protected
 * @abstract
 * @param {!yfiles.view.CanvasComponent} canvas The canvas for which the {\@link } shall be returned.
 * @param {?} edge The edge for which the rendering will be used.
 * @return {!yfiles.view.Stroke} The {\@link } instance to use for the rendering of the edge in the given context.
 */
yfiles.view.EdgeDecorationInstaller.prototype.getStroke = function(canvas, edge) {};
/**
 * @record
 * @struct
 */
yfiles.view.EdgeSelectionIndicatorInstaller = function() {};
 /** @type {string} */
yfiles.view.EdgeSelectionIndicatorInstaller.STROKE_KEY;
 /** @type {string} */
yfiles.view.EdgeSelectionIndicatorInstaller.BEND_TEMPLATE_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.view.EdgeSelectionIndicatorInstaller.$class;
/**
 * @record
 * @struct
 */
yfiles.view.EdgeFocusIndicatorInstaller = function() {};
 /** @type {string} */
yfiles.view.EdgeFocusIndicatorInstaller.STROKE_KEY;
 /** @type {string} */
yfiles.view.EdgeFocusIndicatorInstaller.BEND_TEMPLATE_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.view.EdgeFocusIndicatorInstaller.$class;
/**
 * @record
 * @struct
 */
yfiles.view.EdgeHighlightIndicatorInstaller = function() {};
 /** @type {string} */
yfiles.view.EdgeHighlightIndicatorInstaller.STROKE_KEY;
 /** @type {string} */
yfiles.view.EdgeHighlightIndicatorInstaller.BEND_TEMPLATE_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.view.EdgeHighlightIndicatorInstaller.$class;
/**
 * @record
 * @struct
 */
yfiles.view.EdgeStyleDecorationInstaller = function() {};
 /** @type {yfiles.view.StyleDecorationZoomPolicy} */
yfiles.view.EdgeStyleDecorationInstaller.prototype.zoomPolicy;
 /** @type {?} */
yfiles.view.EdgeStyleDecorationInstaller.prototype.edgeStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.view.EdgeStyleDecorationInstaller.$class;

/**
 * Installs a rendering for the <code>item</code> if it is an {\@link yfiles.graph.IEdge}.
 * @param {?} context The canvas context.
 * @param {?} group The canvas object group to add the newly created {\@link } to.
 * @param {!Object} item The item to install.
 * @return {?} The canvas object representing the item.
 */
yfiles.view.EdgeStyleDecorationInstaller.prototype.addCanvasObject = function(context, group, item) {};
/**
 * @record
 * @struct
 */
yfiles.view.GraphOverviewCanvasVisualCreator = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.view.GraphOverviewCanvasVisualCreator.$class;

/**
 * Callback that paints the specified <code>edge</code>.
 * @protected
 * @param {?} renderContext
 * @param {!CanvasRenderingContext2D} ctx
 * @param {?} edge
 * @return {void}
 */
yfiles.view.GraphOverviewCanvasVisualCreator.prototype.paintEdge = function(renderContext, ctx, edge) {};

/**
 * Callback method that paints the specified <code>node</code>.
 * @protected
 * @param {?} renderContext
 * @param {!CanvasRenderingContext2D} ctx
 * @param {?} node
 * @return {void}
 */
yfiles.view.GraphOverviewCanvasVisualCreator.prototype.paintGroupNode = function(renderContext, ctx, node) {};

/**
 * Callback method that paints the specified <code>node</code>.
 * @protected
 * @param {?} renderContext
 * @param {!CanvasRenderingContext2D} ctx
 * @param {?} node
 * @return {void}
 */
yfiles.view.GraphOverviewCanvasVisualCreator.prototype.paintNode = function(renderContext, ctx, node) {};
/**
 * @record
 * @struct
 */
yfiles.view.LabelStyleDecorationInstaller = function() {};
 /** @type {yfiles.view.StyleDecorationZoomPolicy} */
yfiles.view.LabelStyleDecorationInstaller.prototype.zoomPolicy;
 /** @type {!yfiles.geometry.Insets} */
yfiles.view.LabelStyleDecorationInstaller.prototype.margins;
 /** @type {?} */
yfiles.view.LabelStyleDecorationInstaller.prototype.labelStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.view.LabelStyleDecorationInstaller.$class;

/**
 * Installs a rendering for the <code>item</code> if it is an {\@link yfiles.graph.ILabel}.
 * @param {?} context The canvas context.
 * @param {?} group The canvas object group to add the newly created canvas object to.
 * @param {!Object} item The item to install.
 * @return {?} The canvas object representing the item.
 */
yfiles.view.LabelStyleDecorationInstaller.prototype.addCanvasObject = function(context, group, item) {};
/**
 * @record
 * @struct
 */
yfiles.view.NodeStyleDecorationInstaller = function() {};
 /** @type {yfiles.view.StyleDecorationZoomPolicy} */
yfiles.view.NodeStyleDecorationInstaller.prototype.zoomPolicy;
 /** @type {!yfiles.geometry.Insets} */
yfiles.view.NodeStyleDecorationInstaller.prototype.margins;
 /** @type {?} */
yfiles.view.NodeStyleDecorationInstaller.prototype.nodeStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.view.NodeStyleDecorationInstaller.$class;

/**
 * Installs a rendering for the <code>item</code> if it is an {\@link yfiles.graph.INode}.
 * @param {?} context The canvas context.
 * @param {?} group The canvas object group to add the newly created canvas object to.
 * @param {!Object} item The item to install.
 * @return {?} The canvas object representing the item.
 */
yfiles.view.NodeStyleDecorationInstaller.prototype.addCanvasObject = function(context, group, item) {};

/** @const */
yfiles.view.StyleDecorationZoomPolicy = {};
/** @const {number} */
yfiles.view.StyleDecorationZoomPolicy.VIEW_COORDINATES;
/** @const {number} */
yfiles.view.StyleDecorationZoomPolicy.WORLD_COORDINATES;
/** @const {number} */
yfiles.view.StyleDecorationZoomPolicy.MIXED;
/**
 * @record
 * @struct
 */
yfiles.view.Fill = function() {};
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.ALICE_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.ANTIQUE_WHITE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.AQUA;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.AQUAMARINE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.AZURE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.BEIGE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.BISQUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.BLACK;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.BLANCHED_ALMOND;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.BLUE_VIOLET;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.BROWN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.BURLY_WOOD;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.CADET_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.CHARTREUSE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.CHOCOLATE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.CORAL;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.CORNFLOWER_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.CORNSILK;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.CRIMSON;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.CYAN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_CYAN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_GOLDENROD;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_GRAY;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_KHAKI;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_MAGENTA;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_OLIVE_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_ORANGE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_ORCHID;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_RED;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_SALMON;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_SEA_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_SLATE_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_SLATE_GRAY;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_TURQUOISE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DARK_VIOLET;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DEEP_PINK;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DEEP_SKY_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DIM_GRAY;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.DODGER_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.FIREBRICK;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.FLORAL_WHITE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.FOREST_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.FUCHSIA;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.GAINSBORO;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.GHOST_WHITE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.GOLD;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.GOLDENROD;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.GRAY;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.GREEN_YELLOW;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.HONEYDEW;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.HOT_PINK;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.INDIAN_RED;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.INDIGO;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.IVORY;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.KHAKI;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LAVENDER;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LAVENDER_BLUSH;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LAWN_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LEMON_CHIFFON;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_CORAL;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_CYAN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_GOLDENROD_YELLOW;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_GRAY;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_PINK;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_SALMON;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_SEA_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_SKY_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_SLATE_GRAY;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_STEEL_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIGHT_YELLOW;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIME;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LIME_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.LINEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MAGENTA;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MAROON;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MEDIUM_AQUAMARINE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MEDIUM_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MEDIUM_ORCHID;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MEDIUM_PURPLE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MEDIUM_SEA_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MEDIUM_SLATE_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MEDIUM_SPRING_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MEDIUM_TURQUOISE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MEDIUM_VIOLET_RED;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MIDNIGHT_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MINT_CREAM;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MISTY_ROSE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.MOCCASIN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.NAVAJO_WHITE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.NAVY;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.OLD_LACE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.OLIVE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.OLIVE_DRAB;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.ORANGE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.ORANGE_RED;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.ORCHID;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PALE_GOLDENROD;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PALE_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PALE_TURQUOISE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PALE_VIOLET_RED;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PAPAYA_WHIP;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PEACH_PUFF;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PERU;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PINK;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PLUM;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.POWDER_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.PURPLE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.RED;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.ROSY_BROWN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.ROYAL_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SADDLE_BROWN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SALMON;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SANDY_BROWN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SEA_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SEA_SHELL;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SIENNA;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SILVER;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SKY_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SLATE_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SLATE_GRAY;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SNOW;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.SPRING_GREEN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.STEEL_BLUE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.TAN;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.TEAL;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.THISTLE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.TOMATO;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.TRANSPARENT;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.TURQUOISE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.VIOLET;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.WHEAT;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.WHITE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.WHITE_SMOKE;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.YELLOW;
 /** @type {!yfiles.view.Fill} */
yfiles.view.Fill.YELLOW_GREEN;
 /** @type {!yfiles.lang.Class} */
yfiles.view.Fill.$class;

/**
 * Assigns the fill defined by this instance to the given <code>element</code>.
 * <p>
 * If this {\@link yfiles.view.Fill} is a gradient and implements the {\@link yfiles.view.ISvgDefsCreator} interface, it will be added to the
 * <code>defs</code> section of the SVG document. The fill of the given element will be set to a reference to the gradient element.
 * </p>
 * @param {!SVGElement} element The element whose fill should be set.
 * @param {?} context The context.
 * @return {void}
 */
yfiles.view.Fill.prototype.applyTo = function(element, context) {};

/**
 * Clones this instance by returning a {\@link Object#memberwiseClone} or this in case this instance is already {\@link yfiles.view.Fill#isFrozen frozen}.
 * @return {!Object} An instance of the same type as this instance.
 */
yfiles.view.Fill.prototype.clone = function() {};

/**
 * Freezes this instance.
 * <p>
 * Freezing an object makes it immutable, which can result in performance enhancements.
 * </p>
 * @return {void}
 */
yfiles.view.Fill.prototype.freeze = function() {};

/**
 * Determines if this instance is frozen.
 * @return {boolean}
 */
yfiles.view.Fill.prototype.isFrozen = function() {};
/**
 * @record
 * @struct
 */
yfiles.view.Color = function() {};
 /** @type {number} */
yfiles.view.Color.prototype.r;
 /** @type {number} */
yfiles.view.Color.prototype.g;
 /** @type {number} */
yfiles.view.Color.prototype.b;
 /** @type {number} */
yfiles.view.Color.prototype.a;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.ALICE_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.ANTIQUE_WHITE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.AQUA;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.AQUAMARINE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.AZURE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.BEIGE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.BISQUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.BLACK;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.BLANCHED_ALMOND;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.BLUE_VIOLET;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.BROWN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.BURLY_WOOD;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.CADET_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.CHARTREUSE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.CHOCOLATE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.CORAL;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.CORNFLOWER_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.CORNSILK;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.CRIMSON;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.CYAN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_CYAN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_GOLDENROD;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_GRAY;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_KHAKI;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_MAGENTA;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_OLIVE_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_ORANGE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_ORCHID;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_RED;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_SALMON;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_SEA_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_SLATE_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_SLATE_GRAY;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_TURQUOISE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DARK_VIOLET;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DEEP_PINK;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DEEP_SKY_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DIM_GRAY;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.DODGER_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.FIREBRICK;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.FLORAL_WHITE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.FOREST_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.FUCHSIA;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.GAINSBORO;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.GHOST_WHITE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.GOLD;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.GOLDENROD;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.GRAY;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.GREEN_YELLOW;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.HONEYDEW;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.HOT_PINK;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.INDIAN_RED;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.INDIGO;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.IVORY;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.KHAKI;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LAVENDER;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LAVENDER_BLUSH;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LAWN_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LEMON_CHIFFON;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_CORAL;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_CYAN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_GOLDENROD_YELLOW;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_GRAY;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_PINK;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_SALMON;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_SEA_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_SKY_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_SLATE_GRAY;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_STEEL_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIGHT_YELLOW;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIME;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LIME_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.LINEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MAGENTA;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MAROON;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MEDIUM_AQUAMARINE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MEDIUM_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MEDIUM_ORCHID;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MEDIUM_PURPLE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MEDIUM_SEA_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MEDIUM_SLATE_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MEDIUM_SPRING_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MEDIUM_TURQUOISE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MEDIUM_VIOLET_RED;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MIDNIGHT_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MINT_CREAM;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MISTY_ROSE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.MOCCASIN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.NAVAJO_WHITE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.NAVY;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.OLD_LACE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.OLIVE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.OLIVE_DRAB;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.ORANGE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.ORANGE_RED;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.ORCHID;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PALE_GOLDENROD;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PALE_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PALE_TURQUOISE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PALE_VIOLET_RED;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PAPAYA_WHIP;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PEACH_PUFF;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PERU;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PINK;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PLUM;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.POWDER_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.PURPLE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.RED;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.ROSY_BROWN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.ROYAL_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SADDLE_BROWN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SALMON;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SANDY_BROWN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SEA_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SEA_SHELL;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SIENNA;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SILVER;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SKY_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SLATE_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SLATE_GRAY;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SNOW;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.SPRING_GREEN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.STEEL_BLUE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.TAN;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.TEAL;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.THISTLE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.TOMATO;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.TRANSPARENT;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.TURQUOISE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.VIOLET;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.WHEAT;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.WHITE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.WHITE_SMOKE;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.YELLOW;
 /** @type {!yfiles.view.Color} */
yfiles.view.Color.YELLOW_GREEN;
 /** @type {!yfiles.lang.Class} */
yfiles.view.Color.$class;

/**
 * Creates a new color instance from ARGB values.
 * <p>
 * All values must be between 0 and 255.
 * </p>
 * @param {number} a The alpha value.
 * @param {number} r The red value.
 * @param {number} g The green value.
 * @param {number} b The blue value.
 * @return {!yfiles.view.Color} A new color instance with the given values.
 */
yfiles.view.Color.fromArgb = function(a, r, g, b) {};
/**
 * @record
 * @struct
 */
yfiles.view.ColorExtension = function() {};
 /** @type {string} */
yfiles.view.ColorExtension.prototype.value;
 /** @type {!yfiles.lang.Class} */
yfiles.view.ColorExtension.$class;
/**
 * @record
 * @struct
 */
yfiles.view.Cursor = function() {};
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.NONE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.DEFAULT;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.POINTER;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.HELP;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.PROGRESS;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.TEXT;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.WAIT;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.CROSSHAIR;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.MOVE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.E_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.N_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.NE_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.NW_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.S_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.SE_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.SW_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.W_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.NS_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.NWSE_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.NESW_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.EW_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.COL_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.ROW_RESIZE;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.AUTO;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.CONTEXT_MENU;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.CELL;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.VERTICAL_TEXT;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.ALIAS;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.COPY;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.NO_DROP;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.NOT_ALLOWED;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.ALL_SCROLL;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.ZOOM_IN;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.ZOOM_OUT;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.GRAB;
 /** @type {!yfiles.view.Cursor} */
yfiles.view.Cursor.GRABBING;
 /** @type {!yfiles.lang.Class} */
yfiles.view.Cursor.$class;

/**
 * Returns the CSS text representation for the cursor and its alternatives.
 * @return {string} The CSS text representation for the cursor.
 */
yfiles.view.Cursor.prototype.getSystemCursor = function() {};
/**
 * @record
 * @struct
 */
yfiles.view.DashStyle = function() {};
 /** @type {!yfiles.collections.List<number>} */
yfiles.view.DashStyle.prototype.dashes;
 /** @type {number} */
yfiles.view.DashStyle.prototype.offset;
 /** @type {!yfiles.view.DashStyle} */
yfiles.view.DashStyle.DASH;
 /** @type {!yfiles.view.DashStyle} */
yfiles.view.DashStyle.DASH_DOT;
 /** @type {!yfiles.view.DashStyle} */
yfiles.view.DashStyle.DASH_DOT_DOT;
 /** @type {!yfiles.view.DashStyle} */
yfiles.view.DashStyle.DOT;
 /** @type {!yfiles.view.DashStyle} */
yfiles.view.DashStyle.SOLID;
 /** @type {!yfiles.lang.Class} */
yfiles.view.DashStyle.$class;

/**
 * Clones this instance by returning a {\@link Object#memberwiseClone} or this in case this instance is already {\@link yfiles.view.DashStyle#isFrozen frozen}.
 * @return {!Object} An instance of the same type as this instance.
 */
yfiles.view.DashStyle.prototype.clone = function() {};

/**
 * Freezes this instance.
 * <p>
 * Freezing an object makes it immutable, which can result in performance enhancements.
 * </p>
 * @return {void}
 */
yfiles.view.DashStyle.prototype.freeze = function() {};

/**
 * Determines if this instance is frozen.
 * @return {boolean}
 */
yfiles.view.DashStyle.prototype.isFrozen = function() {};
/**
 * @record
 * @struct
 */
yfiles.view.IVisualTemplate = function() {};

/**
 * This method is called by the framework to create a {\@link yfiles.view.SvgVisual} with the given <code>bounds</code>.
 * <p>
 * {\@link yfiles.view.CanvasComponent} uses this interface through the {\@link yfiles.view.ICanvasObjectDescriptor} to populate the visual
 * canvas object tree.
 * </p>
 * @see yfiles.view.IVisualTemplate#updateVisual
 * @abstract
 * @param {?} context The context that describes where the visual will be used.
 * @param {!yfiles.geometry.Rect} bounds The initial bounds to use for the visual.
 * @param {!Object} dataObject The data object to visualize.
 * @return {!yfiles.view.SvgVisual} The visual to include in the canvas object visual tree. This may be <code>null</code>.
 */
yfiles.view.IVisualTemplate.prototype.createVisual = function(context, bounds, dataObject) {};

/**
 * This method updates or replaces a previously created {\@link yfiles.view.SvgVisual} for inclusion in the
 * {\@link yfiles.view.IRenderContext}.
 * <p>
 * The {\@link yfiles.view.CanvasComponent} uses this method to give implementations a chance to update an existing Visual that has
 * previously been created by the same instance during a call to {\@link yfiles.view.IVisualTemplate#createVisual}. Implementation
 * may update the <code>oldVisual</code> and return that same reference, or create a new visual and return the new instance or <code>null</code>.
 * </p>
 * @abstract
 * @param {?} context The context that describes where the visual will be used in.
 * @param {!yfiles.view.SvgVisual} oldVisual The visual instance that had been returned the last time the {\@link #createVisual} method was called
 * on this instance.
 * @param {!yfiles.geometry.Rect} bounds The initial bounds to use for the visual.
 * @param {!Object} dataObject The data object to visualize.
 * @return {!yfiles.view.SvgVisual} <code>oldVisual</code>, if this instance modified the visual, or a new visual that should replace the existing one in the canvas
 * object visual tree.
 */
yfiles.view.IVisualTemplate.prototype.updateVisual = function(context, oldVisual, bounds, dataObject) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IVisualTemplate;
/**
 * @record
 * @struct
 */
yfiles.view.DragDropItem = function() {};
 /** @type {!Array<string>} */
yfiles.view.DragDropItem.prototype.types;
 /** @type {!yfiles.lang.Class} */
yfiles.view.DragDropItem.$class;

/**
 * Gets the data item for the given format.
 * @see yfiles.view.DragDropItem#setData
 * @param {string} format The format.
 * @return {!Object} The data item that is stored for this format, or <code>null</code> if no such item exists.
 */
yfiles.view.DragDropItem.prototype.getData = function(format) {};

/**
 * Sets the data item for the given format.
 * @see yfiles.view.DragDropItem#getData
 * @param {string} format The format.
 * @param {!Object} data The data item.
 * @return {void}
 */
yfiles.view.DragDropItem.prototype.setData = function(format, data) {};

/** @const */
yfiles.view.DragDropEffects = {};
/** @const {number} */
yfiles.view.DragDropEffects.NONE;
/** @const {number} */
yfiles.view.DragDropEffects.COPY;
/** @const {number} */
yfiles.view.DragDropEffects.MOVE;
/** @const {number} */
yfiles.view.DragDropEffects.LINK;
/** @const {number} */
yfiles.view.DragDropEffects.COPY_LINK;
/** @const {number} */
yfiles.view.DragDropEffects.LINK_MOVE;
/** @const {number} */
yfiles.view.DragDropEffects.COPY_MOVE;
/** @const {number} */
yfiles.view.DragDropEffects.UNINITIALIZED;
/** @const {number} */
yfiles.view.DragDropEffects.ALL;
/**
 * @record
 * @struct
 */
yfiles.view.DragEventArgs = function() {};
 /** @type {yfiles.view.DragDropEffects} */
yfiles.view.DragEventArgs.prototype.dropEffect;
 /** @type {yfiles.view.DragDropKeyStates} */
yfiles.view.DragEventArgs.prototype.keyStates;
 /** @type {!yfiles.view.DragDropItem} */
yfiles.view.DragEventArgs.prototype.item;
 /** @type {yfiles.view.DragDropEffects} */
yfiles.view.DragEventArgs.prototype.effectAllowed;
 /** @type {boolean} */
yfiles.view.DragEventArgs.prototype.handled;
 /** @type {!yfiles.lang.Class} */
yfiles.view.DragEventArgs.$class;

/**
 * Gets the position of the current drag operation in the coordinates system of the provided element.
 * @param {!HTMLElement} element The element for which the coordinates should be used.
 * @return {!yfiles.geometry.Point} The position in the coordinates system of <code>element</code>
 */
yfiles.view.DragEventArgs.prototype.getPosition = function(element) {};

/** @const */
yfiles.view.GradientSpreadMethod = {};
/** @const {number} */
yfiles.view.GradientSpreadMethod.PAD;
/** @const {number} */
yfiles.view.GradientSpreadMethod.REFLECT;
/** @const {number} */
yfiles.view.GradientSpreadMethod.REPEAT;
/**
 * @record
 * @struct
 */
yfiles.view.GradientStop = function() {};
 /** @type {!yfiles.view.Color} */
yfiles.view.GradientStop.prototype.color;
 /** @type {number} */
yfiles.view.GradientStop.prototype.offset;
 /** @type {!yfiles.lang.Class} */
yfiles.view.GradientStop.$class;

/**
 * Clones this instance by returning a {\@link Object#memberwiseClone} or this in case this instance is already {\@link yfiles.view.GradientStop#isFrozen frozen}.
 * @return {!Object} An instance of the same type as this instance.
 */
yfiles.view.GradientStop.prototype.clone = function() {};

/**
 * Freezes this instance.
 * <p>
 * Freezing an object makes it immutable, which can result in performance enhancements.
 * </p>
 * @return {void}
 */
yfiles.view.GradientStop.prototype.freeze = function() {};

/**
 * Determines if this instance is frozen.
 * @return {boolean}
 */
yfiles.view.GradientStop.prototype.isFrozen = function() {};
/**
 * @record
 * @struct
 */
yfiles.view.ISvgDefsCreator = function() {};

/**
 * Checks if the specified node references the element represented by this object.
 * @abstract
 * @param {?} context The current canvas context.
 * @param {!Node} node The SVG node.
 * @param {string} id The defs id that has been stored for this instance by the provided context.
 * @return {boolean} <code>true</code> if <code>node</code> references the element represented by this instance.
 */
yfiles.view.ISvgDefsCreator.prototype.accept = function(context, node, id) {};

/**
 * Creates the element that is put into the defs section of the SVG element.
 * @abstract
 * @param {?} context The canvas context that can be used to register brushes etc.
 * @return {!SVGElement} An {\@link } that can be put into the defs section of the SVG element.
 */
yfiles.view.ISvgDefsCreator.prototype.createDefsElement = function(context) {};

/**
 * Updates the defs element with the current gradient data.
 * @abstract
 * @param {?} context
 * @param {!SVGElement} oldElement
 * @return {void}
 */
yfiles.view.ISvgDefsCreator.prototype.updateDefsElement = function(context, oldElement) {};
 /** @type {{isAttributeReference: function(!Element, string, string): boolean, isUseReference: function(!Node, string): boolean, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.ISvgDefsCreator;

/** @const */
yfiles.view.ImageRenderingType = {};
/** @const {number} */
yfiles.view.ImageRenderingType.AUTO;
/** @const {number} */
yfiles.view.ImageRenderingType.OPTIMIZE_SPEED;
/** @const {number} */
yfiles.view.ImageRenderingType.OPTIMIZE_QUALITY;
/** @const {number} */
yfiles.view.ImageRenderingType.INHERIT;

/** @const */
yfiles.view.Key = {};
/** @const {number} */
yfiles.view.Key.ESCAPE;
/** @const {number} */
yfiles.view.Key.DELETE;
/** @const {number} */
yfiles.view.Key.SHIFT;
/** @const {number} */
yfiles.view.Key.CTRL;
/** @const {number} */
yfiles.view.Key.ENTER;
/** @const {number} */
yfiles.view.Key.SPACE;
/** @const {number} */
yfiles.view.Key.NONE;
/** @const {number} */
yfiles.view.Key.ALT;
/** @const {number} */
yfiles.view.Key.PAGE_UP;
/** @const {number} */
yfiles.view.Key.PAGE_DOWN;
/** @const {number} */
yfiles.view.Key.INSERT;
/** @const {number} */
yfiles.view.Key.BACK;
/** @const {number} */
yfiles.view.Key.ADD;
/** @const {number} */
yfiles.view.Key.SUBTRACT;
/** @const {number} */
yfiles.view.Key.F1;
/** @const {number} */
yfiles.view.Key.F2;
/** @const {number} */
yfiles.view.Key.F3;
/** @const {number} */
yfiles.view.Key.F4;
/** @const {number} */
yfiles.view.Key.F5;
/** @const {number} */
yfiles.view.Key.F6;
/** @const {number} */
yfiles.view.Key.F7;
/** @const {number} */
yfiles.view.Key.F8;
/** @const {number} */
yfiles.view.Key.F9;
/** @const {number} */
yfiles.view.Key.F10;
/** @const {number} */
yfiles.view.Key.F11;
/** @const {number} */
yfiles.view.Key.F12;
/** @const {number} */
yfiles.view.Key.ARROW_LEFT;
/** @const {number} */
yfiles.view.Key.ARROW_UP;
/** @const {number} */
yfiles.view.Key.ARROW_RIGHT;
/** @const {number} */
yfiles.view.Key.ARROW_DOWN;
/** @const {number} */
yfiles.view.Key.D0;
/** @const {number} */
yfiles.view.Key.D1;
/** @const {number} */
yfiles.view.Key.D2;
/** @const {number} */
yfiles.view.Key.D3;
/** @const {number} */
yfiles.view.Key.D4;
/** @const {number} */
yfiles.view.Key.D5;
/** @const {number} */
yfiles.view.Key.D6;
/** @const {number} */
yfiles.view.Key.D7;
/** @const {number} */
yfiles.view.Key.D8;
/** @const {number} */
yfiles.view.Key.D9;
/** @const {number} */
yfiles.view.Key.A;
/** @const {number} */
yfiles.view.Key.B;
/** @const {number} */
yfiles.view.Key.C;
/** @const {number} */
yfiles.view.Key.D;
/** @const {number} */
yfiles.view.Key.E;
/** @const {number} */
yfiles.view.Key.F;
/** @const {number} */
yfiles.view.Key.G;
/** @const {number} */
yfiles.view.Key.H;
/** @const {number} */
yfiles.view.Key.I;
/** @const {number} */
yfiles.view.Key.J;
/** @const {number} */
yfiles.view.Key.K;
/** @const {number} */
yfiles.view.Key.L;
/** @const {number} */
yfiles.view.Key.M;
/** @const {number} */
yfiles.view.Key.N;
/** @const {number} */
yfiles.view.Key.O;
/** @const {number} */
yfiles.view.Key.P;
/** @const {number} */
yfiles.view.Key.Q;
/** @const {number} */
yfiles.view.Key.R;
/** @const {number} */
yfiles.view.Key.S;
/** @const {number} */
yfiles.view.Key.T;
/** @const {number} */
yfiles.view.Key.U;
/** @const {number} */
yfiles.view.Key.V;
/** @const {number} */
yfiles.view.Key.W;
/** @const {number} */
yfiles.view.Key.X;
/** @const {number} */
yfiles.view.Key.Y;
/** @const {number} */
yfiles.view.Key.Z;
/** @const {number} */
yfiles.view.Key.TAB;
/** @const {number} */
yfiles.view.Key.PAUSE;
/** @const {number} */
yfiles.view.Key.HOME;
/** @const {number} */
yfiles.view.Key.END;
/** @const {number} */
yfiles.view.Key.N0;
/** @const {number} */
yfiles.view.Key.N1;
/** @const {number} */
yfiles.view.Key.N2;
/** @const {number} */
yfiles.view.Key.N3;
/** @const {number} */
yfiles.view.Key.N4;
/** @const {number} */
yfiles.view.Key.N5;
/** @const {number} */
yfiles.view.Key.N6;
/** @const {number} */
yfiles.view.Key.N7;
/** @const {number} */
yfiles.view.Key.N8;
/** @const {number} */
yfiles.view.Key.N9;
/** @const {number} */
yfiles.view.Key.MULTIPLY;
/** @const {number} */
yfiles.view.Key.CAPS;
/** @const {number} */
yfiles.view.Key.DECIMAL;
/** @const {number} */
yfiles.view.Key.DIVIDE;
/** @const {number} */
yfiles.view.Key.SEMICOLON;
/** @const {number} */
yfiles.view.Key.EQUAL;
/** @const {number} */
yfiles.view.Key.COMMA;
/** @const {number} */
yfiles.view.Key.DASH;
/** @const {number} */
yfiles.view.Key.PERIOD;
/** @const {number} */
yfiles.view.Key.ACCENT;
/** @const {number} */
yfiles.view.Key.OPEN_BRACKET;
/** @const {number} */
yfiles.view.Key.BACK_SLASH;
/** @const {number} */
yfiles.view.Key.CLOSE_BRACKET;
/** @const {number} */
yfiles.view.Key.SINGLE_QUOTE;

/** @const */
yfiles.view.KeyEventType = {};
/** @const {number} */
yfiles.view.KeyEventType.NONE;
/** @const {number} */
yfiles.view.KeyEventType.PRESSED;
/** @const {number} */
yfiles.view.KeyEventType.TYPED;
/** @const {number} */
yfiles.view.KeyEventType.RELEASED;
/**
 * @record
 * @struct
 */
yfiles.view.KeyEventArgs = function() {};
 /** @type {!Event} */
yfiles.view.KeyEventArgs.prototype.originalEvent;
 /** @type {!Node} */
yfiles.view.KeyEventArgs.prototype.originalSource;
 /** @type {yfiles.view.KeyEventType} */
yfiles.view.KeyEventArgs.prototype.eventType;
 /** @type {yfiles.view.Key} */
yfiles.view.KeyEventArgs.prototype.key;
 /** @type {number} */
yfiles.view.KeyEventArgs.prototype.charCode;
 /** @type {yfiles.view.ModifierKeys} */
yfiles.view.KeyEventArgs.prototype.modifiers;
 /** @type {boolean} */
yfiles.view.KeyEventArgs.prototype.alt;
 /** @type {boolean} */
yfiles.view.KeyEventArgs.prototype.shift;
 /** @type {boolean} */
yfiles.view.KeyEventArgs.prototype.control;
 /** @type {boolean} */
yfiles.view.KeyEventArgs.prototype.meta;
 /** @type {boolean} */
yfiles.view.KeyEventArgs.prototype.defaultPrevented;
 /** @type {!yfiles.lang.Class} */
yfiles.view.KeyEventArgs.$class;

/**
 * Sets this event's {\@link yfiles.view.KeyEventArgs#defaultPrevented} property to <code>true</code> signalling that the event has been properly handled and any default behaviors should
 * be prevented.
 * <p>
 * This will call the corresponding method on the {\@link yfiles.view.KeyEventArgs#originalEvent original native event}.
 * </p>
 * @see yfiles.view.KeyEventArgs#defaultPrevented
 * @return {void}
 */
yfiles.view.KeyEventArgs.prototype.preventDefault = function() {};
/**
 * @record
 * @struct
 */
yfiles.view.LinearGradient = function() {};
 /** @type {yfiles.view.GradientSpreadMethod} */
yfiles.view.LinearGradient.prototype.spreadMethod;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.LinearGradient.prototype.startPoint;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.LinearGradient.prototype.endPoint;
 /** @type {!yfiles.collections.List<!yfiles.view.GradientStop>} */
yfiles.view.LinearGradient.prototype.gradientStops;
 /** @type {!yfiles.lang.Class} */
yfiles.view.LinearGradient.$class;

/**
 *
 * @param {?} context
 * @param {!Node} item
 * @param {string} id
 * @return {boolean}
 */
yfiles.view.LinearGradient.prototype.accept = function(context, item, id) {};

/**
 * Creates a new SVG gradient that corresponds to this gradient brush.
 * @param {?} context
 * @return {!SVGElement} A new SVG gradient that corresponds to this gradient brush
 */
yfiles.view.LinearGradient.prototype.createDefsElement = function(context) {};

/**
 * Creates a new SVG gradient that corresponds to this gradient brush.
 * @return {!SVGElement} A new SVG gradient that corresponds to this gradient brush
 */
yfiles.view.LinearGradient.prototype.toSvgGradient = function() {};

/**
 * Updates the SVG gradient within the <code>defs</code> section of the SVG document if it has changed.
 * @param {?} context The context.
 * @param {!SVGElement} oldElement The old element.
 * @return {void}
 */
yfiles.view.LinearGradient.prototype.updateDefsElement = function(context, oldElement) {};

/**
 * Updates the SVG gradient within the <code>defs</code> section of the SVG document if it has changed.
 * @param {!SVGElement} oldElement The old element.
 * @param {?} context The context.
 * @return {void}
 */
yfiles.view.LinearGradient.prototype.updateSvgGradient = function(oldElement, context) {};

/** @const */
yfiles.view.ModifierKeys = {};
/** @const {number} */
yfiles.view.ModifierKeys.NONE;
/** @const {number} */
yfiles.view.ModifierKeys.CONTROL;
/** @const {number} */
yfiles.view.ModifierKeys.SHIFT;
/** @const {number} */
yfiles.view.ModifierKeys.ALT;
/** @const {number} */
yfiles.view.ModifierKeys.WINDOWS;
/**
 * @record
 * @struct
 */
yfiles.view.PatternFill = function() {};
 /** @type {!yfiles.view.SvgVisual} */
yfiles.view.PatternFill.prototype.content;
 /** @type {!yfiles.geometry.Rect} */
yfiles.view.PatternFill.prototype.viewBox;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.PatternFill.prototype.origin;
 /** @type {!yfiles.geometry.Size} */
yfiles.view.PatternFill.prototype.size;
 /** @type {!yfiles.lang.Class} */
yfiles.view.PatternFill.$class;

/**
 *
 * @param {?} context
 * @param {!Node} node
 * @param {string} id
 * @return {boolean}
 */
yfiles.view.PatternFill.prototype.accept = function(context, node, id) {};

/**
 *
 * @param {?} context
 * @return {!SVGElement}
 */
yfiles.view.PatternFill.prototype.createDefsElement = function(context) {};

/**
 *
 * @param {?} context
 * @param {!SVGElement} oldElement
 * @return {void}
 */
yfiles.view.PatternFill.prototype.updateDefsElement = function(context, oldElement) {};
/**
 * @record
 * @struct
 */
yfiles.view.Stroke = function() {};
 /** @type {!yfiles.view.Fill} */
yfiles.view.Stroke.prototype.fill;
 /** @type {yfiles.view.LineCap} */
yfiles.view.Stroke.prototype.lineCap;
 /** @type {yfiles.view.LineJoin} */
yfiles.view.Stroke.prototype.lineJoin;
 /** @type {!yfiles.view.DashStyle} */
yfiles.view.Stroke.prototype.dashStyle;
 /** @type {number} */
yfiles.view.Stroke.prototype.miterLimit;
 /** @type {number} */
yfiles.view.Stroke.prototype.thickness;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.ALICE_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.ANTIQUE_WHITE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.AQUA;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.AQUAMARINE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.AZURE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.BEIGE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.BISQUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.BLACK;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.BLANCHED_ALMOND;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.BLUE_VIOLET;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.BROWN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.BURLY_WOOD;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.CADET_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.CHARTREUSE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.CHOCOLATE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.CORAL;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.CORNFLOWER_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.CORNSILK;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.CRIMSON;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.CYAN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_CYAN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_GOLDENROD;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_GRAY;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_KHAKI;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_MAGENTA;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_OLIVE_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_ORANGE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_ORCHID;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_RED;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_SALMON;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_SEA_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_SLATE_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_SLATE_GRAY;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_TURQUOISE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DARK_VIOLET;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DEEP_PINK;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DEEP_SKY_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DIM_GRAY;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.DODGER_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.FIREBRICK;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.FLORAL_WHITE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.FOREST_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.FUCHSIA;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.GAINSBORO;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.GHOST_WHITE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.GOLD;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.GOLDENROD;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.GRAY;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.GREEN_YELLOW;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.HONEYDEW;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.HOT_PINK;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.INDIAN_RED;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.INDIGO;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.IVORY;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.KHAKI;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LAVENDER;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LAVENDER_BLUSH;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LAWN_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LEMON_CHIFFON;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_CORAL;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_CYAN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_GOLDENROD_YELLOW;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_GRAY;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_PINK;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_SALMON;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_SEA_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_SKY_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_SLATE_GRAY;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_STEEL_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIGHT_YELLOW;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIME;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LIME_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.LINEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MAGENTA;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MAROON;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MEDIUM_AQUAMARINE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MEDIUM_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MEDIUM_ORCHID;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MEDIUM_PURPLE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MEDIUM_SEA_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MEDIUM_SLATE_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MEDIUM_SPRING_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MEDIUM_TURQUOISE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MEDIUM_VIOLET_RED;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MIDNIGHT_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MINT_CREAM;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MISTY_ROSE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.MOCCASIN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.NAVAJO_WHITE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.NAVY;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.OLD_LACE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.OLIVE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.OLIVE_DRAB;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.ORANGE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.ORANGE_RED;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.ORCHID;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PALE_GOLDENROD;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PALE_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PALE_TURQUOISE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PALE_VIOLET_RED;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PAPAYA_WHIP;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PEACH_PUFF;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PERU;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PINK;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PLUM;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.POWDER_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.PURPLE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.RED;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.ROSY_BROWN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.ROYAL_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SADDLE_BROWN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SALMON;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SANDY_BROWN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SEA_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SEA_SHELL;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SIENNA;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SILVER;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SKY_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SLATE_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SLATE_GRAY;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SNOW;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.SPRING_GREEN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.STEEL_BLUE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.TAN;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.TEAL;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.THISTLE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.TOMATO;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.TRANSPARENT;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.TURQUOISE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.VIOLET;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.WHEAT;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.WHITE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.WHITE_SMOKE;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.YELLOW;
 /** @type {!yfiles.view.Stroke} */
yfiles.view.Stroke.YELLOW_GREEN;
 /** @type {!yfiles.lang.Class} */
yfiles.view.Stroke.$class;

/**
 * Assigns the stroke defined by this instance to the given <code>element</code>.
 * @param {!SVGElement} element The element whose stroke should be set.
 * @param {?} context The context.
 * @return {void}
 */
yfiles.view.Stroke.prototype.applyTo = function(element, context) {};

/**
 * Clones this instance by returning a {\@link Object#memberwiseClone} or this in case this instance is already {\@link yfiles.view.Stroke#isFrozen frozen}.
 * @return {!Object} An instance of the same type as this instance.
 */
yfiles.view.Stroke.prototype.clone = function() {};

/**
 * Clones the current value of this instance to a new unfrozen {\@link yfiles.view.Stroke}.
 * @return {!yfiles.view.Stroke}
 */
yfiles.view.Stroke.prototype.cloneCurrentValue = function() {};

/**
 * Freezes this instance.
 * <p>
 * Freezing an object makes it immutable, which can result in performance enhancements.
 * </p>
 * @return {void}
 */
yfiles.view.Stroke.prototype.freeze = function() {};

/**
 * Determines if this instance is frozen.
 * @return {boolean}
 */
yfiles.view.Stroke.prototype.isFrozen = function() {};

/** @const */
yfiles.view.LineCap = {};
/** @const {number} */
yfiles.view.LineCap.SQUARE;
/** @const {number} */
yfiles.view.LineCap.FLAT;
/** @const {number} */
yfiles.view.LineCap.ROUND;

/** @const */
yfiles.view.LineJoin = {};
/** @const {number} */
yfiles.view.LineJoin.BEVEL;
/** @const {number} */
yfiles.view.LineJoin.ROUND;
/** @const {number} */
yfiles.view.LineJoin.MITER;
/**
 * @record
 * @struct
 */
yfiles.view.RadialGradient = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.view.RadialGradient.prototype.center;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.RadialGradient.prototype.gradientOrigin;
 /** @type {number} */
yfiles.view.RadialGradient.prototype.radiusX;
 /** @type {number} */
yfiles.view.RadialGradient.prototype.radiusY;
 /** @type {yfiles.view.GradientSpreadMethod} */
yfiles.view.RadialGradient.prototype.spreadMethod;
 /** @type {!yfiles.collections.List<!yfiles.view.GradientStop>} */
yfiles.view.RadialGradient.prototype.gradientStops;
 /** @type {!yfiles.lang.Class} */
yfiles.view.RadialGradient.$class;

/**
 *
 * @param {?} context
 * @param {!Node} item
 * @param {string} id
 * @return {boolean}
 */
yfiles.view.RadialGradient.prototype.accept = function(context, item, id) {};

/**
 * Creates a new SVG gradient that corresponds to this gradient brush.
 * @param {?} context
 * @return {!SVGElement} A new SVG gradient that corresponds to this gradient brush
 */
yfiles.view.RadialGradient.prototype.createDefsElement = function(context) {};

/**
 * Creates a new SVG gradient that corresponds to this gradient brush.
 * @return {!SVGElement} A new SVG gradient that corresponds to this gradient brush
 */
yfiles.view.RadialGradient.prototype.toSvgGradient = function() {};

/**
 * Updates the SVG gradient within the <code>defs</code> section of the SVG document if it has changed.
 * @param {?} context The context.
 * @param {!SVGElement} oldElement The old element.
 * @return {void}
 */
yfiles.view.RadialGradient.prototype.updateDefsElement = function(context, oldElement) {};

/**
 * Updates the SVG gradient within the <code>defs</code> section of the SVG document if it has changed.
 * @param {!SVGElement} oldElement The old element.
 * @param {?} context The context.
 * @return {void}
 */
yfiles.view.RadialGradient.prototype.updateSvgGradient = function(oldElement, context) {};
/**
 * @record
 * @struct
 */
yfiles.view.HtmlCanvasVisual = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.view.HtmlCanvasVisual.$class;

/**
 * Paints onto the context using HTML5 Canvas operations.
 * <p>
 * Implementations should not destroy the context's state, but should make sure to restore the state to the previously
 * active state. This is especially true for the transformation and clip.
 * </p>
 * @abstract
 * @param {?} renderContext The render context of the {\@link }
 * @param {!CanvasRenderingContext2D} ctx The HTML5 Canvas context to use for rendering.
 * @return {void}
 */
yfiles.view.HtmlCanvasVisual.prototype.paint = function(renderContext, ctx) {};

/** @const */
yfiles.view.ShapeRenderingType = {};
/** @const {number} */
yfiles.view.ShapeRenderingType.AUTO;
/** @const {number} */
yfiles.view.ShapeRenderingType.OPTIMIZE_SPEED;
/** @const {number} */
yfiles.view.ShapeRenderingType.CRISP_EDGES;
/** @const {number} */
yfiles.view.ShapeRenderingType.GEOMETRIC_PRECISION;
/** @const {number} */
yfiles.view.ShapeRenderingType.INHERIT;
/**
 * @record
 * @struct
 */
yfiles.view.SolidColorFill = function() {};
 /** @type {!yfiles.view.Color} */
yfiles.view.SolidColorFill.prototype.color;
 /** @type {!yfiles.lang.Class} */
yfiles.view.SolidColorFill.$class;
/**
 * @record
 * @struct
 */
yfiles.view.SvgVisual = function() {};
 /** @type {!SVGElement} */
yfiles.view.SvgVisual.prototype.svgElement;
 /** @type {!yfiles.lang.Class} */
yfiles.view.SvgVisual.$class;

/**
 * Sets the transform to a scale transform using the given parameters.
 * <p>
 * This implementation uses caching and the baseVal property of the <code>transform</code> attribute if possible and thus performs
 * better than using the plain DOM API.
 * </p>
 * @param {!Element} transformable The SVG element that should be translated.
 * @param {number} scaleX The vertical scale.
 * @param {number} scaleY The horizontal scale.
 * @return {void}
 */
yfiles.view.SvgVisual.setScale = function(transformable, scaleX, scaleY) {};

/**
 * Sets the transform to a translate transform using the given parameters.
 * <p>
 * This implementation uses caching and the baseVal property of the <code>transform</code> attribute if possible and thus performs
 * better than using the plain DOM API.
 * </p>
 * @param {!Element} transformable The SVG element that should be translated.
 * @param {number} dx The offset on the x-axis.
 * @param {number} dy The offset on the y-axis.
 * @return {void}
 */
yfiles.view.SvgVisual.setTranslate = function(transformable, dx, dy) {};

/** @const */
yfiles.view.HorizontalTextAlignment = {};
/** @const {number} */
yfiles.view.HorizontalTextAlignment.CENTER;
/** @const {number} */
yfiles.view.HorizontalTextAlignment.LEFT;
/** @const {number} */
yfiles.view.HorizontalTextAlignment.RIGHT;

/** @const */
yfiles.view.TextDecoration = {};
/** @const {number} */
yfiles.view.TextDecoration.NONE;
/** @const {number} */
yfiles.view.TextDecoration.UNDERLINE;
/** @const {number} */
yfiles.view.TextDecoration.OVERLINE;
/** @const {number} */
yfiles.view.TextDecoration.LINE_THROUGH;
/** @const {number} */
yfiles.view.TextDecoration.BLINK;

/** @const */
yfiles.view.TextDecorations = {};
/** @const {number} */
yfiles.view.TextDecorations.NONE;
/** @const {number} */
yfiles.view.TextDecorations.UNDERLINE;
/** @const {number} */
yfiles.view.TextDecorations.OVERLINE;
/** @const {number} */
yfiles.view.TextDecorations.STRIKETHROUGH;

/** @const */
yfiles.view.TextWrapping = {};
/** @const {number} */
yfiles.view.TextWrapping.NONE;
/** @const {number} */
yfiles.view.TextWrapping.CHARACTER;
/** @const {number} */
yfiles.view.TextWrapping.CHARACTER_ELLIPSIS;
/** @const {number} */
yfiles.view.TextWrapping.WORD;
/** @const {number} */
yfiles.view.TextWrapping.WORD_ELLIPSIS;
/**
 * @record
 * @struct
 */
yfiles.view.ToolTip = function() {};
 /** @type {!HTMLDivElement} */
yfiles.view.ToolTip.prototype.div;
 /** @type {boolean} */
yfiles.view.ToolTip.prototype.isOpen;
 /** @type {number} */
yfiles.view.ToolTip.prototype.verticalOffset;
 /** @type {number} */
yfiles.view.ToolTip.prototype.horizontalOffset;
 /** @type {!yfiles.geometry.Size} */
yfiles.view.ToolTip.prototype.desiredSize;
 /** @type {!Object} */
yfiles.view.ToolTip.prototype.content;
 /** @type {!yfiles.lang.Class} */
yfiles.view.ToolTip.$class;

/**
 * Creates the {\@link HTMLDivElement HTML element} in which the content is displayed.
 * <p>
 * This implementation creates a simple HTML <code>div</code> element with the CSS class <code>yfiles-tooltip</code>.
 * </p>
 * @protected
 * @return {!HTMLDivElement} A HTML div element.
 */
yfiles.view.ToolTip.prototype.createToolTip = function() {};

/**
 * Sets the content to the HTML element that is displayed as tool tip.
 * <p>
 * This implementation adds a <code>string</code> as <code>innerHTML</code> of the Div. A <code>HTMLElement</code> is added as child to the Div.
 * </p>
 * <p>
 * Subclasses which intend to use a more complex element as tool tip have to override this method to set the content
 * properly.
 * </p>
 * @protected
 * @param {!Object} oldContent The content to remove.
 * @param {!Object} newContent The content to add.
 * @return {void}
 */
yfiles.view.ToolTip.prototype.onContentChanged = function(oldContent, newContent) {};
/**
 * @record
 * @struct
 */
yfiles.view.Font = function() {};
 /** @type {number} */
yfiles.view.Font.prototype.fontSize;
 /** @type {string} */
yfiles.view.Font.prototype.fontFamily;
 /** @type {yfiles.view.FontStyle} */
yfiles.view.Font.prototype.fontStyle;
 /** @type {yfiles.view.FontWeight} */
yfiles.view.Font.prototype.fontWeight;
 /** @type {number} */
yfiles.view.Font.prototype.lineSpacing;
 /** @type {yfiles.view.TextDecoration} */
yfiles.view.Font.prototype.textDecoration;
 /** @type {!yfiles.lang.Class} */
yfiles.view.Font.$class;

/**
 * Assigns the text properties of this instance to the given text element.
 * @param {!SVGTextElement} textElement The text element to assign set the {\@link } on.
 * @return {void}
 */
yfiles.view.Font.prototype.applyTo = function(textElement) {};

/**
 * Creates a copy with the values of this instance or optionally the explicitly specified values.
 * Creates a copy with the values of this instance or optionally the explicitly specified values.
 * @param {string|{fontFamily: string, fontSize: number, fontStyle: yfiles.view.FontStyle, fontWeight: yfiles.view.FontWeight, lineSpacing: number, textDecoration: yfiles.view.TextDecoration}=} fontFamily_or_options
 * @param {number=} fontSize
 * @param {yfiles.view.FontStyle=} fontStyle
 * @param {yfiles.view.FontWeight=} fontWeight
 * @param {number=} lineSpacing
 * @param {yfiles.view.TextDecoration=} textDecoration
 * @return {!yfiles.view.Font} A new {\@link } instance.
 */
yfiles.view.Font.prototype.createCopy = function(fontFamily_or_options, fontSize, fontStyle, fontWeight, lineSpacing, textDecoration) {};

/** @const */
yfiles.view.FontStyle = {};
/** @const {number} */
yfiles.view.FontStyle.NORMAL;
/** @const {number} */
yfiles.view.FontStyle.ITALIC;
/** @const {number} */
yfiles.view.FontStyle.OBLIQUE;
/** @const {number} */
yfiles.view.FontStyle.INHERIT;

/** @const */
yfiles.view.FontWeight = {};
/** @const {number} */
yfiles.view.FontWeight.NORMAL;
/** @const {number} */
yfiles.view.FontWeight.BOLD;
/** @const {number} */
yfiles.view.FontWeight.BOLDER;
/** @const {number} */
yfiles.view.FontWeight.LIGHTER;
/** @const {number} */
yfiles.view.FontWeight.ITEM100;
/** @const {number} */
yfiles.view.FontWeight.ITEM200;
/** @const {number} */
yfiles.view.FontWeight.ITEM300;
/** @const {number} */
yfiles.view.FontWeight.ITEM400;
/** @const {number} */
yfiles.view.FontWeight.ITEM500;
/** @const {number} */
yfiles.view.FontWeight.ITEM600;
/** @const {number} */
yfiles.view.FontWeight.ITEM700;
/** @const {number} */
yfiles.view.FontWeight.ITEM800;
/** @const {number} */
yfiles.view.FontWeight.ITEM900;
/** @const {number} */
yfiles.view.FontWeight.INHERIT;

/** @const */
yfiles.view.VerticalTextAlignment = {};
/** @const {number} */
yfiles.view.VerticalTextAlignment.CENTER;
/** @const {number} */
yfiles.view.VerticalTextAlignment.TOP;
/** @const {number} */
yfiles.view.VerticalTextAlignment.BOTTOM;
/**
 * @record
 * @struct
 */
yfiles.view.Visual = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.view.Visual.$class;

/** @const */
yfiles.view.MouseEventTypes = {};
/** @const {number} */
yfiles.view.MouseEventTypes.NONE;
/** @const {number} */
yfiles.view.MouseEventTypes.MOVE;
/** @const {number} */
yfiles.view.MouseEventTypes.DRAG;
/** @const {number} */
yfiles.view.MouseEventTypes.DOWN;
/** @const {number} */
yfiles.view.MouseEventTypes.UP;
/** @const {number} */
yfiles.view.MouseEventTypes.ENTER;
/** @const {number} */
yfiles.view.MouseEventTypes.LEAVE;
/** @const {number} */
yfiles.view.MouseEventTypes.WHEEL;
/** @const {number} */
yfiles.view.MouseEventTypes.CLICK;
/** @const {number} */
yfiles.view.MouseEventTypes.LOST_CAPTURE;
/**
 * @record
 * @struct
 */
yfiles.view.MouseEventArgs = function() {};
 /** @type {yfiles.view.MouseEventTypes} */
yfiles.view.MouseEventArgs.prototype.eventType;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.MouseEventArgs.prototype.location;
 /** @type {number} */
yfiles.view.MouseEventArgs.prototype.clickCount;
 /** @type {number} */
yfiles.view.MouseEventArgs.prototype.wheelDelta;
 /** @type {number} */
yfiles.view.MouseEventArgs.prototype.scrollAmount;
 /** @type {yfiles.view.MouseWheelDeltaMode} */
yfiles.view.MouseEventArgs.prototype.deltaMode;
 /** @type {yfiles.view.ModifierKeys} */
yfiles.view.MouseEventArgs.prototype.changedModifiers;
 /** @type {yfiles.view.MouseButtons} */
yfiles.view.MouseEventArgs.prototype.changedButtons;
 /** @type {yfiles.view.ModifierKeys} */
yfiles.view.MouseEventArgs.prototype.modifiers;
 /** @type {yfiles.view.MouseButtons} */
yfiles.view.MouseEventArgs.prototype.buttons;
 /** @type {!Event} */
yfiles.view.MouseEventArgs.prototype.originalEvent;
 /** @type {boolean} */
yfiles.view.MouseEventArgs.prototype.defaultPrevented;
 /** @type {!yfiles.lang.Class} */
yfiles.view.MouseEventArgs.$class;

/**
 * Sets this event's {\@link yfiles.view.MouseEventArgs#defaultPrevented} property to <code>true</code> signalling that the event has been properly handled and any default behaviors should
 * be prevented.
 * <p>
 * This will call the corresponding method on the {\@link yfiles.view.MouseEventArgs#originalEvent original native event}.
 * </p>
 * @see yfiles.view.MouseEventArgs#defaultPrevented
 * @return {void}
 */
yfiles.view.MouseEventArgs.prototype.preventDefault = function() {};

/** @const */
yfiles.view.MouseWheelDeltaMode = {};
/** @const {number} */
yfiles.view.MouseWheelDeltaMode.LINES;
/** @const {number} */
yfiles.view.MouseWheelDeltaMode.PAGE;

/** @const */
yfiles.view.TouchEventTypes = {};
/** @const {number} */
yfiles.view.TouchEventTypes.NONE;
/** @const {number} */
yfiles.view.TouchEventTypes.MOVE;
/** @const {number} */
yfiles.view.TouchEventTypes.DOWN;
/** @const {number} */
yfiles.view.TouchEventTypes.UP;
/** @const {number} */
yfiles.view.TouchEventTypes.ENTER;
/** @const {number} */
yfiles.view.TouchEventTypes.LEAVE;
/** @const {number} */
yfiles.view.TouchEventTypes.TAP;
/** @const {number} */
yfiles.view.TouchEventTypes.LONG_PRESS;
/** @const {number} */
yfiles.view.TouchEventTypes.LOST_CAPTURE;
/**
 * @record
 * @struct
 */
yfiles.view.TouchEventArgs = function() {};
 /** @type {yfiles.view.TouchEventTypes} */
yfiles.view.TouchEventArgs.prototype.eventType;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.TouchEventArgs.prototype.location;
 /** @type {!yfiles.view.TouchDevice} */
yfiles.view.TouchEventArgs.prototype.device;
 /** @type {number} */
yfiles.view.TouchEventArgs.prototype.tapCount;
 /** @type {!Event} */
yfiles.view.TouchEventArgs.prototype.originalEvent;
 /** @type {boolean} */
yfiles.view.TouchEventArgs.prototype.defaultPrevented;
 /** @type {!yfiles.lang.Class} */
yfiles.view.TouchEventArgs.$class;

/**
 * Sets this event's {\@link yfiles.view.TouchEventArgs#defaultPrevented} property to <code>true</code> signalling that the event has been properly handled and any default behaviors should
 * be prevented.
 * <p>
 * This will call the corresponding method on the {\@link yfiles.view.TouchEventArgs#originalEvent original native event}.
 * </p>
 * @see yfiles.view.TouchEventArgs#defaultPrevented
 * @return {void}
 */
yfiles.view.TouchEventArgs.prototype.preventDefault = function() {};
/**
 * @record
 * @struct
 */
yfiles.view.TouchDevice = function() {};
 /** @type {number} */
yfiles.view.TouchDevice.prototype.deviceIndex;
 /** @type {boolean} */
yfiles.view.TouchDevice.prototype.isPrimaryDevice;
 /** @type {!yfiles.geometry.Point} */
yfiles.view.TouchDevice.prototype.lastViewCoordinate;
 /** @type {!Date} */
yfiles.view.TouchDevice.prototype.lastEventTimeJS;
 /** @type {boolean} */
yfiles.view.TouchDevice.prototype.isDown;
 /** @type {!yfiles.lang.Class} */
yfiles.view.TouchDevice.$class;
/**
 * @record
 * @struct
 */
yfiles.view.QueryContinueDragEventArgs = function() {};
 /** @type {yfiles.view.DragAction} */
yfiles.view.QueryContinueDragEventArgs.prototype.action;
 /** @type {boolean} */
yfiles.view.QueryContinueDragEventArgs.prototype.escapePressed;
 /** @type {yfiles.view.DragDropKeyStates} */
yfiles.view.QueryContinueDragEventArgs.prototype.keyStates;
 /** @type {boolean} */
yfiles.view.QueryContinueDragEventArgs.prototype.handled;
 /** @type {!yfiles.lang.Class} */
yfiles.view.QueryContinueDragEventArgs.$class;

/** @const */
yfiles.view.DragAction = {};
/** @const {number} */
yfiles.view.DragAction.CONTINUE;
/** @const {number} */
yfiles.view.DragAction.DROP;
/** @const {number} */
yfiles.view.DragAction.CANCEL;
/**
 * @record
 * @struct
 */
yfiles.view.DragSource = function() {};
 /** @type {!HTMLElement} */
yfiles.view.DragSource.prototype.source;
 /** @type {boolean} */
yfiles.view.DragSource.prototype.allowDrag;
 /** @type {!Object} */
yfiles.view.DragSource.prototype.item;
 /** @type {yfiles.view.DragDropEffects} */
yfiles.view.DragSource.prototype.effectAllowed;
 /** @type {!yfiles.lang.Class} */
yfiles.view.DragSource.$class;

/**
 * Cleans up by removing the association with the {\@link yfiles.view.DragSource#source} element.
 * @return {void}
 */
yfiles.view.DragSource.prototype.cleanUp = function() {};

/**
 * Raises the {\@link yfiles.view.DragSource#addQueryContinueDragListener QueryContinueDrag} event.
 * <p>
 * If the event is not {\@link yfiles.view.QueryContinueDragEventArgs#handled handled}, a default logic will be applied: the drag operation is canceled if the left mouse button is
 * released or escape has been pressed, otherwise the drag will be {\@link yfiles.view.DragAction#CONTINUE continued}.
 * </p>
 * @param {!yfiles.view.QueryContinueDragEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.view.DragSource.prototype.onQueryContinueDrag = function(evt) {};

/**
 * Initiates a new drag operation using the provided drag data and effects.
 * <p>
 * If <code>useCssCursors</code> is enabled, the following CSS classes are assigned to elements hovered during a drag operation,
 * depending on the allowed drag-drop operations for these elements:
 * </p>
 * <ul>
 * <li><code>yfiles-cursor-dragdrop-move</code></li>
 * <li><code>yfiles-cursor-dragdrop-link</code></li>
 * <li><code>yfiles-cursor-dragdrop-all</code></li>
 * <li><code>yfiles-cursor-dragdrop-no-drop</code></li>
 * </ul>
 * Initiates a new drag operation using the provided drag data and effects.
 * <p>
 * If <code>useCssCursors</code> is enabled, the following CSS classes are assigned to elements hovered during a drag operation,
 * depending on the allowed drag-drop operations for these elements:
 * </p>
 * <ul>
 * <li><code>yfiles-cursor-dragdrop-move</code></li>
 * <li><code>yfiles-cursor-dragdrop-link</code></li>
 * <li><code>yfiles-cursor-dragdrop-all</code></li>
 * <li><code>yfiles-cursor-dragdrop-no-drop</code></li>
 * </ul>
 * @param {!yfiles.view.DragDropItem|{dragData: !yfiles.view.DragDropItem, dragDropEffects: yfiles.view.DragDropEffects, useCssCursors: boolean}} dragData_or_options The data to use for the drag.
 * @param {yfiles.view.DragDropEffects=} dragDropEffects
 * @param {boolean=} useCssCursors
 * @return {void}
 */
yfiles.view.DragSource.prototype.startDrag = function(dragData_or_options, dragDropEffects, useCssCursors) {};

/**
 * Adds the given listener for the <code>QueryContinueDrag</code> event that occurs when the state of the {\@link yfiles.view.DragDropKeyStates}
 * has changed to query the source whether the drag operation should be continued.
 * <p>
 * Handlers should adjust the {\@link yfiles.view.QueryContinueDragEventArgs#handled} and {\@link yfiles.view.QueryContinueDragEventArgs#action} properties accordingly.
 * </p>
 * @see yfiles.view.DragSource#removeQueryContinueDragListener
 * @param {function(!Object, !yfiles.view.QueryContinueDragEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.DragSource.prototype.addQueryContinueDragListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryContinueDrag</code> event that occurs when the state of the {\@link yfiles.view.DragDropKeyStates}
 * has changed to query the source whether the drag operation should be continued.
 * <p>
 * Handlers should adjust the {\@link yfiles.view.QueryContinueDragEventArgs#handled} and {\@link yfiles.view.QueryContinueDragEventArgs#action} properties accordingly.
 * </p>
 * @see yfiles.view.DragSource#addQueryContinueDragListener
 * @param {function(!Object, !yfiles.view.QueryContinueDragEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.DragSource.prototype.removeQueryContinueDragListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.view.DropTarget = function() {};
 /** @type {boolean} */
yfiles.view.DropTarget.prototype.allowDrop;
 /** @type {!yfiles.lang.Class} */
yfiles.view.DropTarget.$class;

/**
 * Gets the {\@link yfiles.view.DropTarget} instance associated with the given element.
 * @see yfiles.view.DropTarget#setDropTarget
 * @param {!Element} element The element to get the drop target instance of.
 * @return {!yfiles.view.DropTarget} The associated instance or <code>null</code>.
 */
yfiles.view.DropTarget.getDropTarget = function(element) {};

/**
 * Sets the drop target for the given element.
 * @see yfiles.view.DropTarget#getDropTarget
 * @param {!Element} element The element or <code>null</code> to register the drop target instance with.
 * @param {!yfiles.view.DropTarget} dropTarget The instance to attach to the element, <code>null</code> to remove the association from the element.
 * @return {void}
 */
yfiles.view.DropTarget.setDropTarget = function(element, dropTarget) {};

/**
 * Adds the given listener for the <code>DragEnter</code> event that occurs when a drag enters the drop target.
 * <p>
 * The handler may adjust the {\@link yfiles.view.DragEventArgs#dropEffect} and call {\@link yfiles.view.DragEventArgs#handled}.
 * </p>
 * @see yfiles.view.DropTarget#removeDragEnterListener
 * @param {function(!Object, !yfiles.view.DragEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.DropTarget.prototype.addDragEnterListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragEnter</code> event that occurs when a drag enters the drop target.
 * <p>
 * The handler may adjust the {\@link yfiles.view.DragEventArgs#dropEffect} and call {\@link yfiles.view.DragEventArgs#handled}.
 * </p>
 * @see yfiles.view.DropTarget#addDragEnterListener
 * @param {function(!Object, !yfiles.view.DragEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.DropTarget.prototype.removeDragEnterListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragLeave</code> event that occurs when a drag leaves the drop target.
 * <p>
 * The handler may adjust the {\@link yfiles.view.DragEventArgs#dropEffect} and call {\@link yfiles.view.DragEventArgs#handled}.
 * </p>
 * @see yfiles.view.DropTarget#removeDragLeaveListener
 * @param {function(!Object, !yfiles.view.DragEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.DropTarget.prototype.addDragLeaveListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragLeave</code> event that occurs when a drag leaves the drop target.
 * <p>
 * The handler may adjust the {\@link yfiles.view.DragEventArgs#dropEffect} and call {\@link yfiles.view.DragEventArgs#handled}.
 * </p>
 * @see yfiles.view.DropTarget#addDragLeaveListener
 * @param {function(!Object, !yfiles.view.DragEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.DropTarget.prototype.removeDragLeaveListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragOver</code> event that occurs when a drag is being performed over the drop target.
 * <p>
 * The handler may adjust the {\@link yfiles.view.DragEventArgs#dropEffect} and call {\@link yfiles.view.DragEventArgs#handled}.
 * </p>
 * @see yfiles.view.DropTarget#removeDragOverListener
 * @param {function(!Object, !yfiles.view.DragEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.DropTarget.prototype.addDragOverListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragOver</code> event that occurs when a drag is being performed over the drop target.
 * <p>
 * The handler may adjust the {\@link yfiles.view.DragEventArgs#dropEffect} and call {\@link yfiles.view.DragEventArgs#handled}.
 * </p>
 * @see yfiles.view.DropTarget#addDragOverListener
 * @param {function(!Object, !yfiles.view.DragEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.DropTarget.prototype.removeDragOverListener = function(listener) {};

/**
 * Adds the given listener for the <code>Drop</code> event that occurs when the drop operation is performed on the drop target.
 * <p>
 * The handler may adjust the {\@link yfiles.view.DragEventArgs#dropEffect} and call {\@link yfiles.view.DragEventArgs#handled}.
 * </p>
 * @see yfiles.view.DropTarget#removeDropListener
 * @param {function(!Object, !yfiles.view.DragEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.view.DropTarget.prototype.addDropListener = function(listener) {};

/**
 * Removes the given listener for the <code>Drop</code> event that occurs when the drop operation is performed on the drop target.
 * <p>
 * The handler may adjust the {\@link yfiles.view.DragEventArgs#dropEffect} and call {\@link yfiles.view.DragEventArgs#handled}.
 * </p>
 * @see yfiles.view.DropTarget#addDropListener
 * @param {function(!Object, !yfiles.view.DragEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.view.DropTarget.prototype.removeDropListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.view.TableAnimation = function() {};
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.view.TableAnimation.prototype.preferredDuration;
 /** @type {!yfiles.lang.Class} */
yfiles.view.TableAnimation.$class;

/**
 *
 * @param {number} time
 * @return {void}
 */
yfiles.view.TableAnimation.prototype.animate = function(time) {};

/**
 *
 * @return {void}
 */
yfiles.view.TableAnimation.prototype.cleanup = function() {};

/**
 * Create the animation for a single {\@link yfiles.graph.IStripe}
 * @protected
 * @param {?} stripe The stripe
 * @param {number} targetSize The target size of the stripe
 * @return {?} An animation that morphs the stripe size
 */
yfiles.view.TableAnimation.prototype.createStripeAnimation = function(stripe, targetSize) {};

/**
 *
 * @return {void}
 */
yfiles.view.TableAnimation.prototype.initialize = function() {};
/**
 * @record
 * @struct
 */
yfiles.view.IStripeSelection = function() {};
 /** @type {?<?>} */
yfiles.view.IStripeSelection.prototype.selectedRows;
 /** @type {?<?>} */
yfiles.view.IStripeSelection.prototype.selectedColumns;
 /** @type {boolean} */
yfiles.view.IStripeSelection.prototype.allowMixedSelection;
 /** @type {boolean} */
yfiles.view.IStripeSelection.prototype.allowCrossTableSelection;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.view.IStripeSelection;
/**
 * @record
 * @struct
 */
yfiles.view.StripeSelection = function() {};
 /** @type {boolean} */
yfiles.view.StripeSelection.prototype.allowMixedSelection;
 /** @type {boolean} */
yfiles.view.StripeSelection.prototype.allowCrossTableSelection;
 /** @type {?<?>} */
yfiles.view.StripeSelection.prototype.selectedRows;
 /** @type {?<?>} */
yfiles.view.StripeSelection.prototype.selectedColumns;
 /** @type {number} */
yfiles.view.StripeSelection.prototype.size;
 /** @type {!yfiles.lang.Class} */
yfiles.view.StripeSelection.$class;

/**
 *
 * @return {void}
 */
yfiles.view.StripeSelection.prototype.clear = function() {};

/**
 *
 * @return {?<?>}
 */
yfiles.view.StripeSelection.prototype.getEnumerator = function() {};

/**
 * Return whether <code>stripe</code> is currently selected
 * @param {?} stripe The stripe to test
 * @return {boolean} <code>true</code> iff <code>stripe</code> is currently selected
 */
yfiles.view.StripeSelection.prototype.isSelected = function(stripe) {};

/**
 * Raises the {\@link yfiles.view.StripeSelection#addItemSelectionChangedListener ItemSelectionChanged} event
 * @protected
 * @param {!yfiles.view.ItemSelectionChangedEventArgs<?>} evt The parameters for the event
 * @return {void}
 */
yfiles.view.StripeSelection.prototype.onItemSelectionChanged = function(evt) {};

/**
 *
 * @param {?} item
 * @param {boolean} selected
 * @return {void}
 */
yfiles.view.StripeSelection.prototype.setSelected = function(item, selected) {};

/**
 *
 * @param {function(!Object, !yfiles.view.ItemSelectionChangedEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.view.StripeSelection.prototype.addItemSelectionChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.view.ItemSelectionChangedEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.view.StripeSelection.prototype.removeItemSelectionChangedListener = function(listener) {};
/** @const */
yfiles.input = {};

/** @const */
yfiles.input.GridSnapTypes = {};
/** @const {number} */
yfiles.input.GridSnapTypes.NONE;
/** @const {number} */
yfiles.input.GridSnapTypes.HORIZONTAL_LINES;
/** @const {number} */
yfiles.input.GridSnapTypes.VERTICAL_LINES;
/** @const {number} */
yfiles.input.GridSnapTypes.LINES;
/** @const {number} */
yfiles.input.GridSnapTypes.GRID_POINTS;
/** @const {number} */
yfiles.input.GridSnapTypes.ALL;
/**
 * @record
 * @struct
 */
yfiles.input.IHitTester = function() {};

/**
 * Yields an enumerable that enumerates the hits for a given world coordinate.
 * @abstract
 * @param {?} context The context in which to perform the hit testing.
 * @param {!yfiles.geometry.Point} location the coordinates in the world coordinate system
 * @return {?<T>} an enumerable that yields hits for the given coordinates
 */
yfiles.input.IHitTester.prototype.enumerateHits = function(context, location) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IHitTester;
/**
 * @record
 * @struct
 */
yfiles.input.INodeHitTester = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.INodeHitTester;
/**
 * @record
 * @struct
 */
yfiles.input.ILabelHitTester = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.ILabelHitTester;
/**
 * @record
 * @struct
 */
yfiles.input.ILabelOwnerHitTester = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.ILabelOwnerHitTester;
/**
 * @record
 * @struct
 */
yfiles.input.IPortHitTester = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IPortHitTester;
/**
 * @record
 * @struct
 */
yfiles.input.IEdgeHitTester = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IEdgeHitTester;
/**
 * @record
 * @struct
 */
yfiles.input.IBendHitTester = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IBendHitTester;
/**
 * @record
 * @struct
 */
yfiles.input.InputModeBase = function() {};
 /** @type {boolean} */
yfiles.input.InputModeBase.prototype.installed;
 /** @type {?} */
yfiles.input.InputModeBase.prototype.inputModeContext;
 /** @type {number} */
yfiles.input.InputModeBase.prototype.priority;
 /** @type {boolean} */
yfiles.input.InputModeBase.prototype.enabled;
 /** @type {boolean} */
yfiles.input.InputModeBase.prototype.active;
 /** @type {boolean} */
yfiles.input.InputModeBase.prototype.exclusive;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.InputModeBase.prototype.controller;
 /** @type {!yfiles.lang.Class} */
yfiles.input.InputModeBase.$class;

/**
 * Cancels the editing of this mode by first disabling and afterwards reenabling the installed {\@link yfiles.input.InputModeBase#controller}.
 * <p>
 * This implementation disables and reenables the {\@link yfiles.input.InputModeBase#controller} and fires the {\@link yfiles.input.InputModeBase#onCanceled} event afterwards.
 * Classes that need to perform clean-up should override the {\@link yfiles.input.InputModeBase#onConcurrencyControllerDeactivated}
 * method and invoke <b>base.OnConcurrencyControllerDeactivated</b> as the last statement.
 * </p>
 * @see yfiles.input.InputModeBase#onCanceled
 * @see yfiles.input.InputModeBase#addCanceledListener
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.cancel = function() {};

/**
 * Determines whether this instance can request the mutex.
 * <p>
 * This will return true, iff a {\@link yfiles.input.InputModeBase#controller} has been injected and the helper allows requesting the mutex.
 * </p>
 * @protected
 * @return {boolean} Whether a call to {\@link #requestMutex} would currently succeed.
 */
yfiles.input.InputModeBase.prototype.canRequestMutex = function() {};

/**
 * Creates an implementation of {\@link yfiles.input.IInputModeContext} that is specific to this mode.
 * <p>
 * This is needed for events that are triggered by this InputMode to signalize where the event is coming from. A common
 * usage for this is for example in {\@link yfiles.input.IHitTestable#isHit} calls.
 * </p>
 * <p>
 * The result can be given to {\@link yfiles.input.IHitTestable#isHit} or {\@link yfiles.view.CanvasComponent#hitElementsAt} to let
 * implementations of {\@link yfiles.input.IHitTestable} get access to the current {\@link yfiles.input.IInputModeContext}. This can be done
 * by looking up {\@link yfiles.input.IInputModeContext} from the {\@link yfiles.view.ICanvasContext}'s {\@link yfiles.graph.ILookup#lookup} method or
 * simply downcasting.
 * </p>
 * @see yfiles.view.CanvasComponent#hitElementsAt
 * @see yfiles.input.IHitTestable#isHit
 * @see yfiles.input.IInputModeContext
 * @protected
 * @return {?} A readily configured {\@link }.
 */
yfiles.input.InputModeBase.prototype.createChildInputModeContext = function() {};

/**
 * Helper method that yields a suitably configured {\@link yfiles.input.InputModeEventArgs} for this input mode.
 * @protected
 * @param {?} context An input mode context that is available in the {\@link }.
 * <p>
 * Can be <code>null</code> in which case a new context for this instance is created automatically.
 * </p>
 * @return {!yfiles.input.InputModeEventArgs} An input mode event argument that is configured for this instance.
 */
yfiles.input.InputModeBase.prototype.createInputModeEventArgs = function(context) {};

/**
 * Determines whether this instance owns the input mutex.
 * <p>
 * If no {\@link yfiles.input.InputModeBase#controller} had been associated with this instance upon the call to {\@link yfiles.input.InputModeBase#requestMutex} this method will
 * return <code>false</code>.
 * </p>
 * @protected
 * @return {boolean} Whether this instance has the input mutex.
 */
yfiles.input.InputModeBase.prototype.hasMutex = function() {};

/**
 * Performs one-time initialization of this instance.
 * <p>
 * This method should not be invoked by subclasses. This will be done automatically upon first {\@link yfiles.input.InputModeBase#install installation} of this mode.
 * </p>
 * <p>
 * This code will be executed only once per instance. The {\@link yfiles.input.InputModeBase#inputModeContext} property will be <code>null</code> when this code is executed. This method
 * should not be used to install this mode into a specific canvas. Subclasses should always call <code>base.Initialize()</code> first.
 * </p>
 * @see yfiles.input.InputModeBase#install
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.initialize = function() {};

/**
 * Installs this mode into a {\@link yfiles.view.CanvasComponent} using the provided {\@link yfiles.input.IInputModeContext}.
 * <p>
 * Subclasses should override this method and call<code>base.Install(context)</code>, first. One-time initialization should be performed
 * in the {\@link yfiles.input.InputModeBase#initialize} method. This implementation will call the {\@link yfiles.input.InputModeBase#initialize}
 * method the first time this mode gets installed. The initialization will be surrounded by calls to {\@link yfiles.input.InputModeBase#onInitializing}
 * and {\@link yfiles.input.InputModeBase#onInitialized} to trigger the corresponding events.
 * </p>
 * @see yfiles.input.InputModeBase#inputModeContext
 * @see yfiles.view.CanvasComponent#inputMode
 * @param {?} context the context to install this mode into
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.install = function(context, controller) {};

/**
 * Event dispatch method that will dispatch the {\@link yfiles.input.InputModeBase#addCanceledListener Canceled}
 * event.
 * <p>
 * This method is called by subclasses when the editing process has been {\@link yfiles.input.InputModeBase#cancel}ed.
 * </p>
 * @see yfiles.input.InputModeBase#initialize
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.onCanceled = function(evt) {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Event dispatch method that will dispatch the {\@link yfiles.input.InputModeBase#addInitializedListener Initialized}
 * event.
 * <p>
 * This method will be called by {\@link yfiles.input.InputModeBase#install} for the first installation directly after {\@link yfiles.input.InputModeBase#initialize}
 * has returned.
 * </p>
 * @see yfiles.input.InputModeBase#initialize
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.onInitialized = function(evt) {};

/**
 * Event dispatch method that will dispatch the {\@link yfiles.input.InputModeBase#addInitializingListener Initializing}
 * event.
 * <p>
 * This method will be called by {\@link yfiles.input.InputModeBase#install} for the first installation directly before {\@link yfiles.input.InputModeBase#initialize}
 * is invoked.
 * </p>
 * @see yfiles.input.InputModeBase#initialize
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.onInitializing = function(evt) {};

/**
 * Called when this instance obtains the mutex.
 * <p>
 * If no {\@link yfiles.input.InputModeBase#controller} had been associated with this instance upon the call to {\@link yfiles.input.InputModeBase#requestMutex} this method will
 * not be called.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.onMutexObtained = function() {};

/**
 * Called when this instance released the mutex.
 * <p>
 * If no {\@link yfiles.input.InputModeBase#controller} had been associated with this instance upon the call to {\@link yfiles.input.InputModeBase#requestMutex} this method will
 * not be called.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.onMutexReleased = function() {};

/**
 * Event dispatch method that will dispatch the {\@link yfiles.input.InputModeBase#addStoppedListener Stopped}
 * event.
 * <p>
 * This method will be called by {\@link yfiles.input.InputModeBase#tryStop} or can be called by subclasses during a {\@link yfiles.input.InputModeBase#tryStop}
 * operation.
 * </p>
 * @see yfiles.input.InputModeBase#tryStop
 * @see yfiles.input.InputModeBase#addStoppedListener
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.onStopped = function(evt) {};

/**
 * Releases previously captured keyboard input.
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.releaseKeyboard = function() {};

/**
 * Releases the mutex that is currently owned by this instance.
 * <p>
 * This will trigger the {\@link yfiles.input.InputModeBase#onMutexReleased} method if this instance previously owned the mutex.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.releaseMutex = function() {};

/**
 * Releases previously captured mouse and touch input.
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.releasePointer = function() {};

/**
 * Requests capturing of all keyboard input that happens in the {\@link yfiles.view.CanvasComponent}.
 * <p>
 * This sets the CaptureAllKeyboardInput property to
 * <code>true</code>, which will prevent visuals inside the canvas from stealing key strokes.
 * </p>
 * @see yfiles.input.InputModeBase#releaseKeyboard
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.requestKeyboard = function() {};

/**
 * Requests the mutex from the current {\@link yfiles.input.InputModeBase#controller}.
 * <p>
 * This implementation will call the {\@link yfiles.input.InputModeBase#onMutexObtained} method if the mutex has been successfully
 * obtained. If the mutex cannot be obtained this method will trigger an exception.
 * </p>
 * @throws {yfiles.lang.Exception} If the mutex could not be obtained.
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.requestMutex = function() {};

/**
 * Requests capturing of all mouse and touch input that happens in the {\@link yfiles.view.CanvasComponent}.
 * <p>
 * This sets the {\@link yfiles.view.CanvasComponent#captureAllPointerInput} property to <code>true</code>, which will prevent visuals inside the canvas from stealing mouse input.
 * </p>
 * @see yfiles.input.InputModeBase#releasePointer
 * @protected
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.requestPointer = function() {};

/**
 * Tries to stop the editing.
 * <p>
 * This implementation returns if this instance does not currently {\@link yfiles.input.InputModeBase#hasMutex have the input mutex}.
 * </p>
 * <p>
 * This implementation calls {\@link yfiles.input.InputModeBase#onStopped}. Subclasses that want to prevent a stop or need to do
 * special clean up should do this here if the base class implementation of {\@link yfiles.input.InputModeBase#tryStop} returns
 * <code>true</code>. A typical implementation should follow this idiom if it wants to stop:
 * </p>
 * <p>
 * and if it doesn't want to stop simply return <code>false</code> immediately.
 * </p>
 * <p>
 * Calling this method raises the {\@link yfiles.input.InputModeBase#addStoppedListener Stopped} event.
 * </p>
 * @see yfiles.input.InputModeBase#onStopped
 * @return {boolean} <code>true</code> iff this instance does not {\@link #hasMutex own the mutex}.
 */
yfiles.input.InputModeBase.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the canvas.
 * <p>
 * Subclasses should always call <code>base.Uninstall(context)</code> as the last statement.
 * </p>
 * @param {?} context The context to remove this mode from. This is the same instance that has been passed to
 * {\@link #install}.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>Initializing</code> event that occurs before the call to {\@link yfiles.input.InputModeBase#initialize}
 * <p>
 * Clients can use this event to perform configuration of the instance shortly before the initialization begins.
 * </p>
 * @see yfiles.input.InputModeBase#install
 * @see yfiles.input.InputModeBase#removeInitializingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.addInitializingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Initializing</code> event that occurs before the call to
 * {\@link yfiles.input.InputModeBase#initialize}
 * <p>
 * Clients can use this event to perform configuration of the instance shortly before the initialization begins.
 * </p>
 * @see yfiles.input.InputModeBase#install
 * @see yfiles.input.InputModeBase#addInitializingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.removeInitializingListener = function(listener) {};

/**
 * Adds the given listener for the <code>Initialized</code> event that occurs after the call to {\@link yfiles.input.InputModeBase#initialize}
 * <p>
 * Clients can use this event to perform post configuration steps of the instance shortly after the initialization has been
 * performed.
 * </p>
 * @see yfiles.input.InputModeBase#install
 * @see yfiles.input.InputModeBase#removeInitializedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.addInitializedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Initialized</code> event that occurs after the call to
 * {\@link yfiles.input.InputModeBase#initialize}
 * <p>
 * Clients can use this event to perform post configuration steps of the instance shortly after the initialization has been
 * performed.
 * </p>
 * @see yfiles.input.InputModeBase#install
 * @see yfiles.input.InputModeBase#addInitializedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.removeInitializedListener = function(listener) {};

/**
 * Adds the given listener for the <code>Canceled</code> event that occurs after the call to {\@link yfiles.input.InputModeBase#cancel}
 * <p>
 * Clients can use this event to perform post cleanup steps of the instance shortly after the mode has been canceled.
 * </p>
 * @see yfiles.input.InputModeBase#onCanceled
 * @see yfiles.input.InputModeBase#cancel
 * @see yfiles.input.InputModeBase#tryStop
 * @see yfiles.input.InputModeBase#addStoppedListener
 * @see yfiles.input.InputModeBase#removeCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.addCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>Canceled</code> event that occurs after the call to {\@link yfiles.input.InputModeBase#cancel}
 * <p>
 * Clients can use this event to perform post cleanup steps of the instance shortly after the mode has been canceled.
 * </p>
 * @see yfiles.input.InputModeBase#onCanceled
 * @see yfiles.input.InputModeBase#cancel
 * @see yfiles.input.InputModeBase#tryStop
 * @see yfiles.input.InputModeBase#addStoppedListener
 * @see yfiles.input.InputModeBase#addCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.removeCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>Stopped</code> event that occurs after the call to {\@link yfiles.input.InputModeBase#tryStop}
 * <p>
 * Clients can use this event to perform post cleanup steps of the instance shortly after the mode has been stopped.
 * </p>
 * @see yfiles.input.InputModeBase#onStopped
 * @see yfiles.input.InputModeBase#cancel
 * @see yfiles.input.InputModeBase#tryStop
 * @see yfiles.input.InputModeBase#addCanceledListener
 * @see yfiles.input.InputModeBase#removeStoppedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.addStoppedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Stopped</code> event that occurs after the call to {\@link yfiles.input.InputModeBase#tryStop}
 * <p>
 * Clients can use this event to perform post cleanup steps of the instance shortly after the mode has been stopped.
 * </p>
 * @see yfiles.input.InputModeBase#onStopped
 * @see yfiles.input.InputModeBase#cancel
 * @see yfiles.input.InputModeBase#tryStop
 * @see yfiles.input.InputModeBase#addCanceledListener
 * @see yfiles.input.InputModeBase#addStoppedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.InputModeBase.prototype.removeStoppedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.ClickEventArgs = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.input.ClickEventArgs.prototype.location;
 /** @type {yfiles.view.ModifierKeys} */
yfiles.input.ClickEventArgs.prototype.modifiers;
 /** @type {boolean} */
yfiles.input.ClickEventArgs.prototype.handled;
 /** @type {yfiles.view.MouseButtons} */
yfiles.input.ClickEventArgs.prototype.mouseButtons;
 /** @type {number} */
yfiles.input.ClickEventArgs.prototype.clickCount;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ClickEventArgs.$class;

/** @const */
yfiles.input.DoubleClickPolicy = {};
/** @const {number} */
yfiles.input.DoubleClickPolicy.DOUBLE_CLICK_ONLY;
/** @const {number} */
yfiles.input.DoubleClickPolicy.INITIAL_SINGLE_AND_DOUBLE_CLICK;
/** @const {number} */
yfiles.input.DoubleClickPolicy.BOTH_SINGLE_CLICKS_AND_DOUBLE_CLICK;
/**
 * @record
 * @struct
 */
yfiles.input.ClickInputMode = function() {};
 /** @type {number} */
yfiles.input.ClickInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.ClickInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.ClickInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.ClickInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.ClickInputMode.prototype.controller;
 /** @type {yfiles.input.DoubleClickPolicy} */
yfiles.input.ClickInputMode.prototype.doubleClickPolicy;
 /** @type {?} */
yfiles.input.ClickInputMode.prototype.validClickHitTestable;
 /** @type {boolean} */
yfiles.input.ClickInputMode.prototype.requestMutexOnClick;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.ClickInputMode.prototype.validClickHitCursor;
 /** @type {yfiles.view.MouseButtons} */
yfiles.input.ClickInputMode.prototype.activeButtons;
 /** @type {boolean} */
yfiles.input.ClickInputMode.prototype.swallowFocusClick;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.ClickInputMode.prototype.clickLocation;
 /** @type {yfiles.view.ModifierKeys} */
yfiles.input.ClickInputMode.prototype.modifiers;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ClickInputMode.$class;

/**
 * Cancels the editing of this mode.
 * <p>
 * This implementation {\@link yfiles.input.ConcurrencyController#releaseMutex releases} the mutex if it is currently owned by this instance and calls
 * {\@link yfiles.input.ClickInputMode#onCanceled}.
 * </p>
 * @see yfiles.input.ClickInputMode#onCanceled
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.cancel = function() {};

/**
 * Creates the event recognizer that is used to recognize the clicks for this instance.
 * @protected
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean}
 */
yfiles.input.ClickInputMode.prototype.createClickRecognizer = function() {};

/**
 * Creates the event recognizer that is used to recognize the press event for this instance.
 * @protected
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean}
 */
yfiles.input.ClickInputMode.prototype.createPressRecognizer = function() {};

/**
 * Creates the event recognizer that is used to recognize the release event for this instance.
 * @protected
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean}
 */
yfiles.input.ClickInputMode.prototype.createReleaseRecognizer = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.install = function(context, controller) {};

/**
 * Determines whether the given event is a press event that occurred at an invalid location.
 * @see yfiles.input.ClickInputMode#validClickHitTestable
 * @protected
 * @param {!Object} eventSource
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean}
 */
yfiles.input.ClickInputMode.prototype.isInvalidPress = function(eventSource, evt) {};

/**
 * Determines whether the given event is a valid click event.
 * @see yfiles.input.ClickInputMode#validClickHitTestable
 * @protected
 * @param {!Object} src
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean}
 */
yfiles.input.ClickInputMode.prototype.isValidClick = function(src, evt) {};

/**
 * Determines whether the given event is a valid press event.
 * @protected
 * @param {!Object} eventSource
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean}
 */
yfiles.input.ClickInputMode.prototype.isValidPress = function(eventSource, evt) {};

/**
 * Determines whether the given event is a valid release event.
 * @see yfiles.input.ClickInputMode#validClickHitTestable
 * @protected
 * @param {!Object} src
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean}
 */
yfiles.input.ClickInputMode.prototype.isValidRelease = function(src, evt) {};

/**
 * Called after {\@link yfiles.input.ClickInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onCanceled = function() {};

/**
 * Called once this mode has recognized a click gesture.
 * <p>
 * This method will trigger the {\@link yfiles.input.ClickInputMode#addClickedListener Clicked} event.
 * </p>
 * @protected
 * @param {!yfiles.input.ClickEventArgs} evt The arguments.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onClicked = function(evt) {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Called once this mode has recognized a double-click gesture.
 * <p>
 * This method will trigger the {\@link yfiles.input.ClickInputMode#addDoubleClickedListener DoubleClicked} event.
 * </p>
 * @protected
 * @param {!yfiles.input.ClickEventArgs} evt The arguments.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onDoubleClicked = function(evt) {};

/**
 * Called once this mode has recognized a left click gesture.
 * <p>
 * This method will trigger the {\@link yfiles.input.ClickInputMode#addLeftClickedListener LeftClicked} event.
 * </p>
 * @protected
 * @param {!yfiles.input.ClickEventArgs} evt The arguments.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onLeftClicked = function(evt) {};

/**
 * Called once this mode has recognized a left double-click gesture.
 * <p>
 * This method will trigger the {\@link yfiles.input.ClickInputMode#addLeftDoubleClickedListener LeftDoubleClicked}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.ClickEventArgs} evt The arguments.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onLeftDoubleClicked = function(evt) {};

/**
 * Called once this mode has recognized a right click gesture.
 * <p>
 * This method will trigger the {\@link yfiles.input.ClickInputMode#addRightClickedListener RightClicked} event.
 * </p>
 * @protected
 * @param {!yfiles.input.ClickEventArgs} evt The arguments.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onRightClicked = function(evt) {};

/**
 * Called once this mode has recognized a double-click gesture.
 * <p>
 * This method will trigger the {\@link yfiles.input.ClickInputMode#addRightDoubleClickedListener RightDoubleClicked}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.ClickEventArgs} evt The arguments.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onRightDoubleClicked = function(evt) {};

/**
 * Called after {\@link yfiles.input.ClickInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.onStopped = function() {};

/**
 * Prevents a double-click event from being issued if the next click would do so and sends only a single click instead.
 * <p>
 * The intention is for "breaking" a double click if an input mode using {\@link yfiles.input.ClickInputMode} performs actions that
 * would lead to surprising behavior if the next click would lead to a double-click. Examples of this are
 * {\@link yfiles.input.GraphEditorInputMode}'s selection cycling where several clicks in short succession may occur, as well as
 * creating a node by clicking on the canvas and selecting it immediately afterwards with another click.
 * </p>
 * <p>
 * This method's effect is very short-lived. It really only prevents a double-click event for the very next click that this
 * input mode handles. The internal flag set by this method is re-set on every click received. This also means that if you
 * call this method and the next click is just a regular single-click the flag is cleared nonetheless.
 * </p>
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.preventNextDoubleClick = function() {};

/**
 * Returns and resets the flag set by {\@link yfiles.input.ClickInputMode#preventNextDoubleClick}.
 * <p>
 * To ensure that the flag really acts just once, this method resets the flag and returns its value prior to the reset.
 * </p>
 * @protected
 * @return {boolean}
 */
yfiles.input.ClickInputMode.prototype.queryAndResetPreventNextDoubleClick = function() {};

/**
 *
 * @return {boolean}
 */
yfiles.input.ClickInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>Clicked</code> event that occurs once a click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#removeClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.addClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Clicked</code> event that occurs once a click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#addClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.removeClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LeftClicked</code> event that occurs once a left click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#removeLeftClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.addLeftClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LeftClicked</code> event that occurs once a left click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#addLeftClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.removeLeftClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>RightClicked</code> event that occurs once a right click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#removeRightClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.addRightClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>RightClicked</code> event that occurs once a right click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#addRightClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.removeRightClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DoubleClicked</code> event that occurs once a double-click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#removeDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.addDoubleClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DoubleClicked</code> event that occurs once a double-click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#addDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.removeDoubleClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LeftDoubleClicked</code> event that occurs once a left double-click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#removeLeftDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.addLeftDoubleClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LeftDoubleClicked</code> event that occurs once a left double-click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#addLeftDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.removeLeftDoubleClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>RightDoubleClicked</code> event that occurs once a right double-click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#removeRightDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.addRightDoubleClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>RightDoubleClicked</code> event that occurs once a right double-click has been detected.
 * @see yfiles.input.ClickEventArgs
 * @see yfiles.input.ClickInputMode#doubleClickPolicy
 * @see yfiles.input.ClickInputMode#addRightDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ClickInputMode.prototype.removeRightDoubleClickedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.CollectSnapResultsEventArgs = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.input.CollectSnapResultsEventArgs.prototype.originalLocation;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.CollectSnapResultsEventArgs.prototype.newLocation;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.CollectSnapResultsEventArgs.prototype.delta;
 /** @type {number} */
yfiles.input.CollectSnapResultsEventArgs.prototype.snapDistance;
 /** @type {!yfiles.lang.Class} */
yfiles.input.CollectSnapResultsEventArgs.$class;

/**
 * Adds a {\@link yfiles.input.SnapResult} to the collection of snap results.
 * <p>
 * <code>null</code> values will be discarded.
 * </p>
 * @param {!yfiles.input.SnapResult} snapResult The result to add.
 * @return {void}
 */
yfiles.input.CollectSnapResultsEventArgs.prototype.addSnapResult = function(snapResult) {};
/**
 * @record
 * @struct
 */
yfiles.input.ConcurrencyController = function() {};
 /** @type {?} */
yfiles.input.ConcurrencyController.prototype.mutexOwner;
 /** @type {boolean} */
yfiles.input.ConcurrencyController.prototype.enabled;
 /** @type {boolean} */
yfiles.input.ConcurrencyController.prototype.active;
 /** @type {boolean} */
yfiles.input.ConcurrencyController.prototype.exclusive;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.ConcurrencyController.prototype.preferredCursor;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ConcurrencyController.$class;

/**
 * Determines if the mutex can be successfully requested currently.
 * <p>
 * This will return <code>true</code>, iff this instance is {\@link yfiles.input.ConcurrencyController#active} and doesn't hold the mutex.
 * </p>
 * @return {boolean} Whether a call to {\@link #requestMutex} would currently succeed.
 */
yfiles.input.ConcurrencyController.prototype.canRequestMutex = function() {};

/**
 * Determines whether this instance owns the input mutex.
 * <p>
 * The instance owns the input mutex if it has successfully {\@link yfiles.input.ConcurrencyController#requestMutex requested} the mutex in the past and not yet {\@link yfiles.input.ConcurrencyController#releaseMutex released} it.
 * </p>
 * @return {boolean} Whether this instance has the input mutex.
 */
yfiles.input.ConcurrencyController.prototype.hasMutex = function() {};

/**
 * Triggers a {\@link yfiles.input.ConcurrencyController#addPriorityChangedListener PriorityChanged} event with
 * {\@link yfiles.lang.EventArgs#EMPTY}.
 * <p>
 * This method should be called by the associated mode if its {\@link yfiles.input.IInputMode#priority} has changed.
 * </p>
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.onPriorityChanged = function() {};

/**
 * Releases the input mutex.
 * <p>
 * Modes should call this method when they have finished editing the contents exclusively. This will reactivate those modes
 * whose controller that had been {\@link yfiles.input.ConcurrencyController#active deactivated} at the time the mutex has been requested.
 * </p>
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.releaseMutex = function() {};

/**
 * Can be called to request an input mutex for the input mode.
 * <p>
 * Modes should call this method to request exclusive editing for a canvas control. {\@link yfiles.input.ConcurrencyController#canRequestMutex}
 * should be called before requesting the mutex. If the mutex cannot be obtained, this method will trigger an exception.
 * </p>
 * @throws {yfiles.lang.Exception} If the mutex could not be obtained.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.requestMutex = function() {};

/**
 * Adds the given listener for the <code>MutexObtained</code> event that occurs when the mutex has been successfully obtained.
 * <p>
 * This event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.input.ConcurrencyController#removeMutexObtainedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.addMutexObtainedListener = function(listener) {};

/**
 * Removes the given listener for the <code>MutexObtained</code> event that occurs when the mutex has been successfully obtained.
 * <p>
 * This event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.input.ConcurrencyController#addMutexObtainedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.removeMutexObtainedListener = function(listener) {};

/**
 * Adds the given listener for the <code>MutexReleased</code> event that occurs when the mutex has been released.
 * <p>
 * This event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.input.ConcurrencyController#removeMutexReleasedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.addMutexReleasedListener = function(listener) {};

/**
 * Removes the given listener for the <code>MutexReleased</code> event that occurs when the mutex has been released.
 * <p>
 * This event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.input.ConcurrencyController#addMutexReleasedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.removeMutexReleasedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ActiveChanged</code> event that occurs the {\@link yfiles.input.ConcurrencyController#active} property changes.
 * <p>
 * This event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.input.ConcurrencyController#removeActiveChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.addActiveChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ActiveChanged</code> event that occurs the {\@link yfiles.input.ConcurrencyController#active} property changes.
 * <p>
 * This event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.input.ConcurrencyController#addActiveChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.removeActiveChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PreferredCursorChanged</code> event that occurs when the {\@link yfiles.input.ConcurrencyController#preferredCursor} property changes.
 * <p>
 * {\@link yfiles.input.MultiplexingInputMode} listens to property changes of the controller of its sub modes. properties. This
 * event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.input.ConcurrencyController#removePreferredCursorChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.addPreferredCursorChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PreferredCursorChanged</code> event that occurs when the {\@link yfiles.input.ConcurrencyController#preferredCursor} property changes.
 * <p>
 * {\@link yfiles.input.MultiplexingInputMode} listens to property changes of the controller of its sub modes. properties. This
 * event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.input.ConcurrencyController#addPreferredCursorChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.removePreferredCursorChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PriorityChanged</code> event that occurs when {\@link yfiles.input.ConcurrencyController#onPriorityChanged}
 * is called by the associated mode.
 * <p>
 * {\@link yfiles.input.MultiplexingInputMode} listens to priority changes of the controller of its sub modes.
 * </p>
 * @see yfiles.input.ConcurrencyController#removePriorityChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.addPriorityChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PriorityChanged</code> event that occurs when {\@link yfiles.input.ConcurrencyController#onPriorityChanged}
 * is called by the associated mode.
 * <p>
 * {\@link yfiles.input.MultiplexingInputMode} listens to priority changes of the controller of its sub modes.
 * </p>
 * @see yfiles.input.ConcurrencyController#addPriorityChangedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ConcurrencyController.prototype.removePriorityChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.PopulateMenuEventArgs = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.input.PopulateMenuEventArgs.prototype.queryLocation;
 /** @type {boolean} */
yfiles.input.PopulateMenuEventArgs.prototype.handled;
 /** @type {boolean} */
yfiles.input.PopulateMenuEventArgs.prototype.showMenu;
 /** @type {!yfiles.lang.Class} */
yfiles.input.PopulateMenuEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.ContextMenuInputMode = function() {};
 /** @type {number} */
yfiles.input.ContextMenuInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.ContextMenuInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.ContextMenuInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.ContextMenuInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.ContextMenuInputMode.prototype.controller;
 /** @type {?} */
yfiles.input.ContextMenuInputMode.prototype.validMenuLocationHitTestable;
 /** @type {boolean} */
yfiles.input.ContextMenuInputMode.prototype.swallowCloseClick;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ContextMenuInputMode.$class;

/**
 * Cancels the display of the context menu and requests that the context menu is closed.
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.cancel = function() {};

/**
 * Creates an {\@link yfiles.input.IInputModeContext} for use with the {\@link yfiles.input.ContextMenuInputMode#addPopulateMenuListener PopulateMenu}
 * call in the upcoming query.
 * @protected
 * @return {?} An instance of {\@link }.
 */
yfiles.input.ContextMenuInputMode.prototype.createPopulateMenuContext = function() {};

/**
 * Installs this mode in the canvas.
 * @param {?} context The context to install this mode into.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.install = function(context, controller) {};

/**
 * This method must be called by custom code to indicate that the menu has been closed.
 * <p>
 * Since this input mode cannot know when the user has closed a context menu, this callback should be used to allow the
 * instance to adjust the internal state.
 * </p>
 * @see yfiles.input.ContextMenuInputMode#addCloseMenuListener
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.menuClosed = function() {};

/**
 * Called after {\@link yfiles.input.ContextMenuInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.onCanceled = function() {};

/**
 * Called when the menu is closed and triggers the {\@link yfiles.input.ContextMenuInputMode#addCloseMenuListener CloseMenu}
 * event.
 * @protected
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.onCloseMenu = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * This will populate the context menu for the given world coordinate.
 * <p>
 * This implementation will trigger the {\@link yfiles.input.ContextMenuInputMode#addPopulateMenuListener PopulateMenu}
 * event and will use the {\@link yfiles.input.PopulateMenuEventArgs#showMenu} value as the return value. If the event will not be handled, this method will return <code>true</code> if the
 * menu already contains elements.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} location The location in the world coordinate system for which the context menu has been invoked.
 * @return {boolean} Whether to show the context menu.
 */
yfiles.input.ContextMenuInputMode.prototype.onMenuOpening = function(location) {};

/**
 * Raises the {\@link yfiles.input.ContextMenuInputMode#addPopulateMenuListener PopulateMenu} event.
 * @protected
 * @param {!yfiles.input.PopulateMenuEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.onPopulateMenu = function(evt) {};

/**
 * Called after {\@link yfiles.input.ContextMenuInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.onStopped = function() {};

/**
 * This method must be called by custom code to inform this input mode that a context menu is about to be opened by a user
 * gesture.
 * <p>
 * Since this input mode does not know when the user wants to open a context menu, this method must be called to possibly
 * cancel the request and, otherwise, update the internal state of this mode.
 * </p>
 * @see yfiles.input.ContextMenuInputMode#menuClosed
 * @see yfiles.input.ContextMenuInputMode#addCloseMenuListener
 * @param {!yfiles.geometry.Point=} queryLocation
 * @return {boolean}
 */
yfiles.input.ContextMenuInputMode.prototype.shouldOpenMenu = function(queryLocation) {};

/**
 * Stops the display of the context menu and requests that the context menu is closed.
 * @return {boolean}
 */
yfiles.input.ContextMenuInputMode.prototype.tryStop = function() {};

/**
 * Removes the menu from the context and replaces it with the old instance.
 * @param {?} context The context to uninstall this mode from.
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>PopulateMenu</code> event that occurs when the context menu is about to be shown.
 * <p>
 * Handlers of the event can populate their context menu, set the {\@link yfiles.input.PopulateMenuEventArgs#showMenu} and set or respect the {\@link yfiles.input.PopulateMenuEventArgs#handled} property. Note that all handlers
 * will be called, even if one of them sets the {\@link yfiles.input.PopulateMenuEventArgs#handled} property to
 * <code>true</code>. Every handler should query this property and decide carefully what to do.
 * </p>
 * @see yfiles.input.ContextMenuInputMode#removePopulateMenuListener
 * @param {function(!Object, !yfiles.input.PopulateMenuEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.addPopulateMenuListener = function(listener) {};

/**
 * Removes the given listener for the <code>PopulateMenu</code> event that occurs when the context menu is about to be shown.
 * <p>
 * Handlers of the event can populate their context menu, set the {\@link yfiles.input.PopulateMenuEventArgs#showMenu} and set or respect the {\@link yfiles.input.PopulateMenuEventArgs#handled} property. Note that all handlers
 * will be called, even if one of them sets the {\@link yfiles.input.PopulateMenuEventArgs#handled} property to
 * <code>true</code>. Every handler should query this property and decide carefully what to do.
 * </p>
 * @see yfiles.input.ContextMenuInputMode#addPopulateMenuListener
 * @param {function(!Object, !yfiles.input.PopulateMenuEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.removePopulateMenuListener = function(listener) {};

/**
 * Adds the given listener for the <code>CloseMenu</code> event that occurs when this instance requests closing an open context menu.
 * <p>
 * Custom context menus must be closed in response to this event.
 * </p>
 * @see yfiles.input.ContextMenuInputMode#menuClosed
 * @see yfiles.input.ContextMenuInputMode#removeCloseMenuListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.addCloseMenuListener = function(listener) {};

/**
 * Removes the given listener for the <code>CloseMenu</code> event that occurs when this instance requests closing an open context
 * menu.
 * <p>
 * Custom context menus must be closed in response to this event.
 * </p>
 * @see yfiles.input.ContextMenuInputMode#menuClosed
 * @see yfiles.input.ContextMenuInputMode#addCloseMenuListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ContextMenuInputMode.prototype.removeCloseMenuListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.DropInputMode = function() {};
 /** @type {number} */
yfiles.input.DropInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.DropInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.DropInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.DropInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.DropInputMode.prototype.controller;
 /** @type {yfiles.view.DragDropEffects} */
yfiles.input.DropInputMode.prototype.dragDropEffect;
 /** @type {?} */
yfiles.input.DropInputMode.prototype.validDropHitTestable;
 /** @type {!yfiles.view.DragEventArgs} */
yfiles.input.DropInputMode.prototype.lastDragEventArgs;
 /** @type {?} */
yfiles.input.DropInputMode.prototype.mousePosition;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.DropInputMode.prototype.dropLocation;
 /** @type {!Object} */
yfiles.input.DropInputMode.prototype.dropData;
 /** @type {boolean} */
yfiles.input.DropInputMode.prototype.captureMouseInputDuringDrag;
 /** @type {!yfiles.lang.Class} */
yfiles.input.DropInputMode.$class;

/**
 * Callback that adjusts the effect accordingly.
 * @protected
 * @param {!yfiles.view.DragEventArgs} evt
 * @return {boolean}
 */
yfiles.input.DropInputMode.prototype.adjustEffect = function(evt) {};

/**
 * Cleanly cancels this mode.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.cancel = function() {};

/**
 * Helper method that yields a suitably configured {\@link yfiles.input.InputModeEventArgs} for this input mode.
 * @protected
 * @return {!yfiles.input.InputModeEventArgs} An input mode event argument that is configured for this instance.
 */
yfiles.input.DropInputMode.prototype.createInputModeEventArgs = function() {};

/**
 * Installs this mode into the given canvas.
 * <p>
 * Clients should not call this method as this is handled by the framework.
 * </p>
 * @see yfiles.view.CanvasComponent
 * @param {?} context the context to install this mode into
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.install = function(context, controller) {};

/**
 * Called after {\@link yfiles.input.DropInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Called once a drag has been dropped on the canvas.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.onDragDropped = function(evt) {};

/**
 * Called once a drag has entered the canvas.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.onDragEntered = function(evt) {};

/**
 * Called whenever a drag is over the canvas.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.onDraggedOver = function(evt) {};

/**
 * Called once a drag has left the canvas.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.onDragLeft = function(evt) {};

/**
 * Called after {\@link yfiles.input.DropInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.onStopped = function() {};

/**
 * This method updates the {\@link yfiles.input.DropInputMode#mousePosition} according to the coordinates passed in.
 * <p>
 * It is called prior to the {\@link yfiles.input.DropInputMode#onDragEntered}, {\@link yfiles.input.DropInputMode#onDraggedOver}, {\@link yfiles.input.DropInputMode#onDragDropped}
 * and {\@link yfiles.input.DropInputMode#onDragLeft} methods.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} location The current location of the mouse in world coordinates.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.setDragLocation = function(location) {};

/**
 * Overridden to only return <code>true</code> if this instance does not currently {\@link yfiles.input.ConcurrencyController#hasMutex have the input mutex}.
 * @return {boolean} <code>true</code> iff this instance does not {\@link #hasMutex own the mutex}.
 */
yfiles.input.DropInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the canvas.
 * <p>
 * Clients should not call this method as this is handled by the framework.
 * </p>
 * @param {?} context the context
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>DragEntered</code> event that occurs when a drag operation enters the {\@link yfiles.view.CanvasComponent}
 * into which this instance is installed.
 * <p>
 * No event is raised
 * </p>
 * <ul>
 * <li>if this instance is not {\@link yfiles.input.DropInputMode#enabled},</li>
 * <li>if another concurrent input mode is active or</li>
 * <li>the data from the drag operation does not conform to the expected format.</li>
 * </ul>
 * <p>
 * To get additional data for the event, clients should use the sender which is set to the sending
 * {\@link yfiles.input.DropInputMode}. The {\@link yfiles.lang.EventArgs} provide no useful data.
 * </p>
 * @see yfiles.input.DropInputMode#removeDragEnteredListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.addDragEnteredListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragEntered</code> event that occurs when a drag operation enters the {\@link yfiles.view.CanvasComponent}
 * into which this instance is installed.
 * <p>
 * No event is raised
 * </p>
 * <ul>
 * <li>if this instance is not {\@link yfiles.input.DropInputMode#enabled},</li>
 * <li>if another concurrent input mode is active or</li>
 * <li>the data from the drag operation does not conform to the expected format.</li>
 * </ul>
 * <p>
 * To get additional data for the event, clients should use the sender which is set to the sending
 * {\@link yfiles.input.DropInputMode}. The {\@link yfiles.lang.EventArgs} provide no useful data.
 * </p>
 * @see yfiles.input.DropInputMode#addDragEnteredListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.removeDragEnteredListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragOver</code> event that occurs when a drag operation drags over the {\@link yfiles.view.CanvasComponent}
 * into which this instance is installed.
 * <p>
 * No event is raised
 * </p>
 * <ul>
 * <li>if this instance is not {\@link yfiles.input.DropInputMode#enabled},</li>
 * <li>if another concurrent input mode is active or</li>
 * <li>the data from the drag operation does not conform to the expected format.</li>
 * </ul>
 * <p>
 * To get additional data for the event, clients should use the sender which is set to the sending
 * {\@link yfiles.input.DropInputMode}. The {\@link yfiles.lang.EventArgs} provide no useful data.
 * </p>
 * @see yfiles.input.DropInputMode#removeDragOverListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.addDragOverListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragOver</code> event that occurs when a drag operation drags over the {\@link yfiles.view.CanvasComponent}
 * into which this instance is installed.
 * <p>
 * No event is raised
 * </p>
 * <ul>
 * <li>if this instance is not {\@link yfiles.input.DropInputMode#enabled},</li>
 * <li>if another concurrent input mode is active or</li>
 * <li>the data from the drag operation does not conform to the expected format.</li>
 * </ul>
 * <p>
 * To get additional data for the event, clients should use the sender which is set to the sending
 * {\@link yfiles.input.DropInputMode}. The {\@link yfiles.lang.EventArgs} provide no useful data.
 * </p>
 * @see yfiles.input.DropInputMode#addDragOverListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.removeDragOverListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragLeft</code> event that occurs when a drag operation leaves the {\@link yfiles.view.CanvasComponent}
 * into which this instance is installed.
 * <p>
 * No event is raised
 * </p>
 * <ul>
 * <li>if this instance is not {\@link yfiles.input.DropInputMode#enabled},</li>
 * <li>if another concurrent input mode is active or</li>
 * <li>the data from the drag operation does not conform to the expected format.</li>
 * </ul>
 * <p>
 * To get additional data for the event, clients should use the sender which is set to the sending
 * {\@link yfiles.input.DropInputMode}. The {\@link yfiles.lang.EventArgs} provide no useful data.
 * </p>
 * @see yfiles.input.DropInputMode#removeDragLeftListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.addDragLeftListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragLeft</code> event that occurs when a drag operation leaves the {\@link yfiles.view.CanvasComponent}
 * into which this instance is installed.
 * <p>
 * No event is raised
 * </p>
 * <ul>
 * <li>if this instance is not {\@link yfiles.input.DropInputMode#enabled},</li>
 * <li>if another concurrent input mode is active or</li>
 * <li>the data from the drag operation does not conform to the expected format.</li>
 * </ul>
 * <p>
 * To get additional data for the event, clients should use the sender which is set to the sending
 * {\@link yfiles.input.DropInputMode}. The {\@link yfiles.lang.EventArgs} provide no useful data.
 * </p>
 * @see yfiles.input.DropInputMode#addDragLeftListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.removeDragLeftListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragDropped</code> event that occurs when a drag operation is dropped onto the {\@link yfiles.view.CanvasComponent}
 * into which this instance is installed.
 * <p>
 * No event is raised
 * </p>
 * <ul>
 * <li>if this instance is not {\@link yfiles.input.DropInputMode#enabled},</li>
 * <li>if another concurrent input mode is active or</li>
 * <li>the data from the drag operation does not conform to the expected format.</li>
 * </ul>
 * <p>
 * To get additional data for the event, clients should use the sender which is set to the sending
 * {\@link yfiles.input.DropInputMode}. The {\@link yfiles.lang.EventArgs} provide no useful data.
 * </p>
 * @see yfiles.input.DropInputMode#removeDragDroppedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.addDragDroppedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragDropped</code> event that occurs when a drag operation is dropped onto the {\@link yfiles.view.CanvasComponent}
 * into which this instance is installed.
 * <p>
 * No event is raised
 * </p>
 * <ul>
 * <li>if this instance is not {\@link yfiles.input.DropInputMode#enabled},</li>
 * <li>if another concurrent input mode is active or</li>
 * <li>the data from the drag operation does not conform to the expected format.</li>
 * </ul>
 * <p>
 * To get additional data for the event, clients should use the sender which is set to the sending
 * {\@link yfiles.input.DropInputMode}. The {\@link yfiles.lang.EventArgs} provide no useful data.
 * </p>
 * @see yfiles.input.DropInputMode#addDragDroppedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.DropInputMode.prototype.removeDragDroppedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.FocusGuardInputMode = function() {};
 /** @type {number} */
yfiles.input.FocusGuardInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.FocusGuardInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.FocusGuardInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.FocusGuardInputMode.prototype.controller;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.FocusGuardInputMode.prototype.guardCursor;
 /** @type {!yfiles.lang.Class} */
yfiles.input.FocusGuardInputMode.$class;

/**
 *
 * @return {void}
 */
yfiles.input.FocusGuardInputMode.prototype.cancel = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.FocusGuardInputMode.prototype.install = function(context, controller) {};

/**
 * Called after {\@link yfiles.input.FocusGuardInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.FocusGuardInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.FocusGuardInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.FocusGuardInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Called after {\@link yfiles.input.FocusGuardInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.FocusGuardInputMode.prototype.onStopped = function() {};

/**
 *
 * @return {boolean}
 */
yfiles.input.FocusGuardInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.FocusGuardInputMode.prototype.uninstall = function(context) {};
/**
 * @record
 * @struct
 */
yfiles.input.HandleInputMode = function() {};
 /** @type {number} */
yfiles.input.HandleInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.HandleInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.HandleInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.HandleInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.HandleInputMode.prototype.controller;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_DEFAULT_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_MOVE_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_RESIZE_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_ROTATE_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_SHEAR_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_INVISIBLE_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_INVISIBLE_VARIANT2_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_INVISIBLE_VARIANT3_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_INVISIBLE_VARIANT4_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_DEFAULT_VARIANT2_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_MOVE_VARIANT2_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_RESIZE_VARIANT2_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_ROTATE_VARIANT2_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_SHEAR_VARIANT2_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_DEFAULT_VARIANT3_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_MOVE_VARIANT3_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_RESIZE_VARIANT3_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_ROTATE_VARIANT3_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_SHEAR_VARIANT3_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_DEFAULT_VARIANT4_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_MOVE_VARIANT4_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_RESIZE_VARIANT4_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_ROTATE_VARIANT4_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_SHEAR_VARIANT4_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_WARP_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_WARP_VARIANT2_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_WARP_VARIANT3_KEY;
 /** @type {string} */
yfiles.input.HandleInputMode.HANDLE_DRAWING_WARP_VARIANT4_KEY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.HandleInputMode.prototype.disableSnappingRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.HandleInputMode.prototype.enableSnappingRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.HandleInputMode.prototype.pressedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.HandleInputMode.prototype.draggedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.HandleInputMode.prototype.cancelRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.HandleInputMode.prototype.releasedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.HandleInputMode.prototype.pressedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.HandleInputMode.prototype.draggedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.HandleInputMode.prototype.releasedRecognizerTouch;
 /** @type {?<?>} */
yfiles.input.HandleInputMode.prototype.handles;
 /** @type {!yfiles.input.SnapContext} */
yfiles.input.HandleInputMode.prototype.snapContext;
 /** @type {?} */
yfiles.input.HandleInputMode.prototype.currentHandle;
 /** @type {?<?>} */
yfiles.input.HandleInputMode.prototype.affectedItems;
 /** @type {!yfiles.lang.Class} */
yfiles.input.HandleInputMode.$class;

/**
 * Adds a handle to the collection of handles managed by this instance.
 * Factory method that creates and {\@link yfiles.input.HandleInputMode#addHandle adds} a handle to this mode by wrapping a given {\@link yfiles.geometry.IMutablePoint} instance.
 * <p>
 * The <code>cursor</code> and <code>type</code> are used to initialize the {\@link yfiles.input.IHandle} instance.
 * </p>
 * Factory method that creates and {\@link yfiles.input.HandleInputMode#addHandle adds} a handle to this mode by wrapping a given {\@link yfiles.geometry.IMutablePoint} instance.
 * <p>
 * The <code>cursor</code> and <code>type</code> are used to initialize the {\@link yfiles.input.IHandle} instance.
 * </p>
 * @param {?|{location: ?, cursor: !yfiles.view.Cursor, type: yfiles.input.HandleTypes}} handle_or_location_or_options The handle to add. / The point to use as a handle.
 * @param {!yfiles.view.Cursor=} cursor
 * @param {yfiles.input.HandleTypes=} type
 * @return {void|?} The handle created.
 */
yfiles.input.HandleInputMode.prototype.addHandle = function(handle_or_location_or_options, cursor, type) {};

/**
 * Callback method that is invoked when this mode gets "armed".
 * <p>
 * This happens when the mouse pointer hovers over a handle. This changes the mouse cursor to the <code>handle</code>'s {\@link yfiles.input.IHandle#cursor}.
 * </p>
 * @protected
 * @param {?} handle
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.arm = function(handle) {};

/**
 * Method that can be used to initialize the dragging of a given handle by hand.
 * <p>
 * This will simulate the user having initialized a drag of the given handle.
 * </p>
 * @param {?} handle The handle to be dragged.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.beginDragging = function(handle) {};

/**
 *
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.cancel = function() {};

/**
 * Creates an {\@link yfiles.input.IInputModeContext} for use with the {\@link yfiles.input.IHandle} interface for the upcoming drag
 * operation.
 * @protected
 * @return {?} An instance of {\@link }.
 */
yfiles.input.HandleInputMode.prototype.createHandleInputModeContext = function() {};

/**
 * Helper method that yields a suitably configured {\@link yfiles.input.InputModeEventArgs} for this input mode.
 * @protected
 * @return {!yfiles.input.InputModeEventArgs} An input mode event argument that is configured for this instance.
 */
yfiles.input.HandleInputMode.prototype.createInputModeEventArgs = function() {};

/**
 * Callback that creates the {\@link yfiles.view.Visual} for the given handle.
 * @protected
 * @param {?} context
 * @param {?} handle The handle to create a visual representation for.
 * @return {!yfiles.view.SvgVisual} The {\@link }.
 */
yfiles.input.HandleInputMode.prototype.createVisual = function(context, handle) {};

/**
 * Callback method that is invoked when this mode gets "disarmed".
 * <p>
 * This happens when the mouse stops hovering over a handle. This resets the mouse cursor
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.disarm = function() {};

/**
 * Finds the closest hit handle for the given world coordinate pair.
 * <p>
 * The default implementation compares the manhatten distance of the handles to find the closest handle.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} location The coordinates in the world coordinate system.
 * @return {?} The closest handle that has been hit or <code>null</code>
 */
yfiles.input.HandleInputMode.prototype.getClosestHitHandle = function(location) {};

/**
 * Finds the closest hit handle for the given world coordinate pair.
 * @protected
 * @param {!yfiles.geometry.Point} location The coordinates in the world coordinate system.
 * @return {?} The closest handle that has been hit or <code>null</code>
 */
yfiles.input.HandleInputMode.prototype.getClosestHitHandleTouch = function(location) {};

/**
 * Determines whether a given handle has been visually hit by the mouse at the given world coordinates.
 * <p>
 * This implementation uses the manhatten distance as a metric to determine if the handle was hit.
 * </p>
 * @protected
 * @param {?} handle The handle to check
 * @param {!yfiles.geometry.Point} location The view coordinates to check.
 * @param {!yfiles.geometry.Point} distance The distance of the handle to the location. In the default implementation, this is a tuple representing the x- and
 * y-distance of the handle to the location.
 * @return {boolean} Whether the handle has been hit.
 */
yfiles.input.HandleInputMode.prototype.handleIsHit = function(handle, location, distance) {};

/**
 * Determines whether a given handle has been visually hit by the touch device at the given world coordinates.
 * @protected
 * @param {?} handle The handle to check
 * @param {!yfiles.geometry.Point} location The world coordinates to check.
 * @param {!yfiles.geometry.Point} distance The distance of the handle to the touch location. In the default implementation, this is a tuple representing the x- and
 * y-distance of the handle to the touch location.
 * @return {boolean} Whether the handle has been hit.
 */
yfiles.input.HandleInputMode.prototype.handleIsHitTouch = function(handle, location, distance) {};

/**
 * Installs the visual representation of the handles into the canvas into the {\@link yfiles.view.CanvasComponent#inputModeGroup}.
 * @param {?} context
 * @param {!yfiles.input.ConcurrencyController} controller
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.install = function(context, controller) {};

/**
 * Convenience method that invalidates the canvas this mode is currently installed in.
 * @protected
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.invalidate = function() {};

/**
 * Event recognizer callback used to determine whether the mouse is currently hovering over a handle.
 * @see yfiles.input.HandleInputMode#getClosestHitHandle
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean} Whether the mouse is hovering over handle.
 */
yfiles.input.HandleInputMode.prototype.isHovering = function(sender, evt) {};

/**
 * Called after {\@link yfiles.input.HandleInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Triggers the {\@link yfiles.input.HandleInputMode#addDragCanceledListener DragCanceled} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onDragCanceled = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.HandleInputMode#addDragCancelingListener DragCanceling} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onDragCanceling = function(evt) {};

/**
 * Callback triggered once the drag has been finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.HandleInputMode#addDragFinishedListener DragFinished} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onDragFinished = function(evt) {};

/**
 * Callback triggered before the drag will be finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.HandleInputMode#addDragFinishingListener DragFinishing} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onDragFinishing = function(evt) {};

/**
 * Callback triggered at the end of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.HandleInputMode#addDraggedListener Dragged} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onDragged = function(evt) {};

/**
 * Callback triggered at the start of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.HandleInputMode#addDraggingListener Dragging} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onDragging = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.HandleInputMode#addDragStartedListener DragStarted} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onDragStarted = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.HandleInputMode#addDragStartingListener DragStarting} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onDragStarting = function(evt) {};

/**
 * Called after {\@link yfiles.input.HandleInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.onStopped = function() {};

/**
 * Removes a handle from the collection of handles managed by this instance.
 * @param {?} handle The handle to remove.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.removeHandle = function(handle) {};

/**
 *
 * @return {boolean}
 */
yfiles.input.HandleInputMode.prototype.tryStop = function() {};

/**
 * Removes the {\@link yfiles.view.ICanvasObject} that displays the handles from the canvas.
 * @param {?} context
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.HandleInputMode#removeDragFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.addDragFinishingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.HandleInputMode#addDragFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.removeDragFinishingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragFinished</code> event that occurs once the drag has been finished.
 * @see yfiles.input.HandleInputMode#removeDragFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.addDragFinishedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinished</code> event that occurs once the drag has been finished.
 * @see yfiles.input.HandleInputMode#addDragFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.removeDragFinishedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.HandleInputMode#removeDragStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.addDragStartingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.HandleInputMode#addDragStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.removeDragStartingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.HandleInputMode#removeDragStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.addDragStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.HandleInputMode#addDragStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.removeDragStartedListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.HandleInputMode#removeDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.addDraggingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.HandleInputMode#addDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.removeDraggingListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.HandleInputMode#removeDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.addDraggedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.HandleInputMode#addDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.removeDraggedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.HandleInputMode#removeDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.addDragCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.HandleInputMode#addDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.removeDragCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.HandleInputMode#removeDragCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.addDragCancelingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.HandleInputMode#addDragCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.HandleInputMode.prototype.removeDragCancelingListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.IDragHandler = function() {};
 /** @type {?} */
yfiles.input.IDragHandler.prototype.location;

/**
 * Called by clients to indicate that the dragging has been canceled by the user.
 * <p>
 * This method may be called after the initial {\@link yfiles.input.IDragHandler#initializeDrag} and zero or more invocations of
 * {\@link yfiles.input.IDragHandler#handleMove}. Implementations should reset the position of the items they modify to their
 * initial state. Alternatively to this method the {\@link yfiles.input.IDragHandler#dragFinished} method might be called.
 * </p>
 * @abstract
 * @param {?} context The context to retrieve information about the drag from.
 * @param {!yfiles.geometry.Point} originalLocation The value of the coordinate of the {\@link #location} property at the time of {\@link #initializeDrag}.
 * @return {void}
 */
yfiles.input.IDragHandler.prototype.cancelDrag = function(context, originalLocation) {};

/**
 * Called by clients to indicate that the repositioning has just been finished.
 * <p>
 * This method may be called after the initial {\@link yfiles.input.IDragHandler#initializeDrag} and zero or more invocations of
 * {\@link yfiles.input.IDragHandler#handleMove}. Alternatively to this method the {\@link yfiles.input.IDragHandler#cancelDrag} method might
 * be called.
 * </p>
 * @abstract
 * @param {?} context The context to retrieve information about the drag from.
 * @param {!yfiles.geometry.Point} originalLocation The value of the {\@link #location} property at the time of {\@link #initializeDrag}.
 * @param {!yfiles.geometry.Point} newLocation The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the
 * implementation the {\@link #location} may or may not be modified to reflect the new value. This is the same value as delivered in the last
 * invocation of {\@link #handleMove}
 * @return {void}
 */
yfiles.input.IDragHandler.prototype.dragFinished = function(context, originalLocation, newLocation) {};

/**
 * Called by clients to indicate that the element has been dragged and its position should be updated.
 * <p>
 * This method may be called more than once after an initial {\@link yfiles.input.IDragHandler#initializeDrag} and will the final
 * call will be followed by either one {\@link yfiles.input.IDragHandler#dragFinished} or one {\@link yfiles.input.IDragHandler#cancelDrag}
 * call.
 * </p>
 * @abstract
 * @param {?} context The context to retrieve information about the drag from.
 * @param {!yfiles.geometry.Point} originalLocation The value of the {\@link #location} property at the time of {\@link #initializeDrag}.
 * @param {!yfiles.geometry.Point} newLocation The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the
 * implementation the {\@link #location} may or may not be modified to reflect the new value.
 * @return {void}
 */
yfiles.input.IDragHandler.prototype.handleMove = function(context, originalLocation, newLocation) {};

/**
 * Called by clients to indicate that the element is going to be dragged.
 * <p>
 * This call will be followed by one or more calls to {\@link yfiles.input.IDragHandler#handleMove}, and a final {\@link yfiles.input.IDragHandler#dragFinished}
 * or {\@link yfiles.input.IDragHandler#cancelDrag}.
 * </p>
 * @abstract
 * @param {?} context The context to retrieve information about the drag from.
 * @return {void}
 */
yfiles.input.IDragHandler.prototype.initializeDrag = function(context) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IDragHandler;

/** @const */
yfiles.input.SnapPolicy = {};
/** @const {number} */
yfiles.input.SnapPolicy.NO_SNAPPING;
/** @const {number} */
yfiles.input.SnapPolicy.TO_NEAREST;
/** @const {number} */
yfiles.input.SnapPolicy.TO_GREATER;
/** @const {number} */
yfiles.input.SnapPolicy.TO_SMALLER;
/**
 * @record
 * @struct
 */
yfiles.input.IGridConstraintProvider = function() {};
 /** @type {number} */
yfiles.input.IGridConstraintProvider.prototype.horizontalGridWidth;
 /** @type {number} */
yfiles.input.IGridConstraintProvider.prototype.verticalGridWidth;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.IGridConstraintProvider.prototype.gridOrigin;

/**
 * Performs the actual snapping to grid coordinates.
 * @abstract
 * @param {?} context The context in which the snapping should occur.
 * @param {T} item The item of which the coordinates should be snapped.
 * @param {?} location The coordinates to snap.
 * @param {yfiles.input.SnapPolicy} xSnapPolicy The policy for the x coordinate.
 * @param {yfiles.input.SnapPolicy} ySnapPolicy The policy for the y coordinate.
 * @return {boolean} Whether the point has been snapped.
 */
yfiles.input.IGridConstraintProvider.prototype.snapToGrid = function(context, item, location, xSnapPolicy, ySnapPolicy) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IGridConstraintProvider;
/**
 * @record
 * @struct
 */
yfiles.input.GridConstraintProvider = function() {};
 /** @type {!yfiles.view.GridInfo} */
yfiles.input.GridConstraintProvider.prototype.gridInfo;
 /** @type {number} */
yfiles.input.GridConstraintProvider.prototype.horizontalGridWidth;
 /** @type {number} */
yfiles.input.GridConstraintProvider.prototype.verticalGridWidth;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.GridConstraintProvider.prototype.gridOrigin;
 /** @type {!yfiles.lang.Class} */
yfiles.input.GridConstraintProvider.$class;

/**
 *
 * @param {?} context
 * @param {T} item
 * @param {?} location
 * @param {yfiles.input.SnapPolicy} xSnapPolicy
 * @param {yfiles.input.SnapPolicy} ySnapPolicy
 * @return {boolean}
 */
yfiles.input.GridConstraintProvider.prototype.snapToGrid = function(context, item, location, xSnapPolicy, ySnapPolicy) {};

/** @const */
yfiles.input.HandleTypes = {};
/** @const {number} */
yfiles.input.HandleTypes.INVISIBLE;
/** @const {number} */
yfiles.input.HandleTypes.DEFAULT;
/** @const {number} */
yfiles.input.HandleTypes.RESIZE;
/** @const {number} */
yfiles.input.HandleTypes.ROTATE;
/** @const {number} */
yfiles.input.HandleTypes.MOVE;
/** @const {number} */
yfiles.input.HandleTypes.SHEAR;
/** @const {number} */
yfiles.input.HandleTypes.WARP;
/** @const {number} */
yfiles.input.HandleTypes.TYPE_MASK;
/** @const {number} */
yfiles.input.HandleTypes.VARIANT1;
/** @const {number} */
yfiles.input.HandleTypes.VARIANT2;
/** @const {number} */
yfiles.input.HandleTypes.VARIANT3;
/** @const {number} */
yfiles.input.HandleTypes.VARIANT4;
/** @const {number} */
yfiles.input.HandleTypes.VARIANT_MASK;
/** @const {number} */
yfiles.input.HandleTypes.OFFSET_NORTH;
/** @const {number} */
yfiles.input.HandleTypes.OFFSET_EAST;
/** @const {number} */
yfiles.input.HandleTypes.OFFSET_SOUTH;
/** @const {number} */
yfiles.input.HandleTypes.OFFSET_WEST;
/** @const {number} */
yfiles.input.HandleTypes.OFFSET_MASK;

/** @const */
yfiles.input.HandlePositions = {};
/** @const {number} */
yfiles.input.HandlePositions.NONE;
/** @const {number} */
yfiles.input.HandlePositions.NORTH_WEST;
/** @const {number} */
yfiles.input.HandlePositions.NORTH;
/** @const {number} */
yfiles.input.HandlePositions.NORTH_EAST;
/** @const {number} */
yfiles.input.HandlePositions.WEST;
/** @const {number} */
yfiles.input.HandlePositions.CENTER;
/** @const {number} */
yfiles.input.HandlePositions.EAST;
/** @const {number} */
yfiles.input.HandlePositions.SOUTH_WEST;
/** @const {number} */
yfiles.input.HandlePositions.SOUTH;
/** @const {number} */
yfiles.input.HandlePositions.SOUTH_EAST;
/** @const {number} */
yfiles.input.HandlePositions.CORNERS;
/** @const {number} */
yfiles.input.HandlePositions.HORIZONTAL;
/** @const {number} */
yfiles.input.HandlePositions.VERTICAL;
/** @const {number} */
yfiles.input.HandlePositions.BORDER;
/** @const {number} */
yfiles.input.HandlePositions.ALL;
/**
 * @record
 * @struct
 */
yfiles.input.IHandle = function() {};
 /** @type {yfiles.input.HandleTypes} */
yfiles.input.IHandle.prototype.type;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.IHandle.prototype.cursor;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IHandle;
/**
 * @record
 * @struct
 */
yfiles.input.IHandleProvider = function() {};

/**
 * Returns a collection of zero or more {\@link yfiles.input.IHandle} implementations that are associated with this instance.
 * @abstract
 * @param {?} context
 * @return {?<?>} A collection of handles.
 */
yfiles.input.IHandleProvider.prototype.getHandles = function(context) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IHandleProvider;
/**
 * @record
 * @struct
 */
yfiles.input.IReshapeHandleProvider = function() {};

/**
 * Returns a bitwise combination of all of the {\@link yfiles.input.HandlePositions} this interface can provide an implementation
 * for.
 * <p>
 * Client code will use this method to query the available positions and may then call for each of the positions the {\@link yfiles.input.IReshapeHandleProvider#getHandle}
 * method to retrieve an implementation.
 * </p>
 * @abstract
 * @param {?} context The context for which the handles are queried.
 * @return {yfiles.input.HandlePositions} A bitwise combination of all positions the {\@link #getHandle} method can be queried for.
 */
yfiles.input.IReshapeHandleProvider.prototype.getAvailableHandles = function(context) {};

/**
 * Returns an implementation of an {\@link yfiles.input.IHandle} for the given position, that can be used to reshape an object.
 * <p>
 * This method may be called for each possible single position contained in the set as returned by
 * {\@link yfiles.input.IReshapeHandleProvider#getAvailableHandles}.
 * </p>
 * @abstract
 * @param {?} context The context for which the handles are queried.
 * @param {yfiles.input.HandlePositions} position The single position a handle implementation should be returned for.
 * @return {?} An implementation of {\@link } for the given position.
 */
yfiles.input.IReshapeHandleProvider.prototype.getHandle = function(context, position) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IReshapeHandleProvider;
/**
 * @record
 * @struct
 */
yfiles.input.IInputMode = function() {};
 /** @type {?} */
yfiles.input.IInputMode.prototype.inputModeContext;
 /** @type {number} */
yfiles.input.IInputMode.prototype.priority;

/**
 * Called by the client to unconditionally cancel all editing.
 * <p>
 * This will be called prior to the uninstalling of this instance.
 * </p>
 * <p>
 * In order to stop an active input mode manually, client code should use the following idiom:
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.input.IInputMode.prototype.cancel = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * <br />
 * When this instance gets {\@link yfiles.input.IInputMode#uninstall uninstalled} from the context the same context instance will be passed to it.
 * <br />
 * Implementations may hold a reference to the <code>context</code> instance and use it while they are being installed.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @abstract
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link } for this mode.
 * @return {void}
 */
yfiles.input.IInputMode.prototype.install = function(context, controller) {};

/**
 * Called by the client in order to stop a current editing progress.
 * <p>
 * This should stop the current edit, if one is in progress and possibly commit all of the changes. If stopping is not
 * possible, this method can return <code>false</code>
 * </p>
 * @see yfiles.input.IInputMode#cancel
 * @abstract
 * @return {boolean} <code>true</code> if and only if the editing has been stopped or there was no edit in progress
 */
yfiles.input.IInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * @abstract
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.IInputMode.prototype.uninstall = function(context) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IInputMode;
/**
 * @record
 * @struct
 */
yfiles.input.IInputModeContext = function() {};
 /** @type {?} */
yfiles.input.IInputModeContext.prototype.parentInputMode;
 /** @type {?} */
yfiles.input.IInputModeContext.prototype.graph;

/**
 * Tries to call {\@link yfiles.graph.IGraph#invalidateDisplays} on the {\@link yfiles.input.IInputModeContext#graph graph} obtains from the {\@link yfiles.input.IInputModeContext}.
 * <p>
 * If the graph instance cannot be found, {\@link yfiles.view.CanvasComponent#invalidate} will be called instead.
 * </p>
 * @return {void}
 */
yfiles.input.IInputModeContext.prototype.invalidateDisplays = function() {};
 /** @type {{createInputModeContext: ?, EMPTY: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IInputModeContext;
/**
 * @record
 * @struct
 */
yfiles.input.IModelItemCollector = function() {};

/**
 * Adds a model item to this collector instance.
 * @abstract
 * @param {?} item The model item to add.
 * @return {void}
 */
yfiles.input.IModelItemCollector.prototype.add = function(item) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IModelItemCollector;
/**
 * @record
 * @struct
 */
yfiles.input.IPositionHandler = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IPositionHandler;
/**
 * @record
 * @struct
 */
yfiles.input.IReshapeHandler = function() {};
 /** @type {?} */
yfiles.input.IReshapeHandler.prototype.bounds;

/**
 * Called by clients to indicate that the reshaping has been canceled by the user.
 * <p>
 * This method may be called after the initial {\@link yfiles.input.IReshapeHandler#initializeReshape} and zero or more invocations
 * of {\@link yfiles.input.IReshapeHandler#handleReshape}. Implementations should reset the bounds of the items they modify to their
 * initial state. Alternatively to this method the {\@link yfiles.input.IReshapeHandler#reshapeFinished} method might be called.
 * </p>
 * @abstract
 * @param {?} context The context to retrieve information about the reshaping from.
 * @param {!yfiles.geometry.Rect} originalBounds The value of the coordinate of the {\@link #bounds} property at the time of {\@link #initializeReshape}.
 * @return {void}
 */
yfiles.input.IReshapeHandler.prototype.cancelReshape = function(context, originalBounds) {};

/**
 * Called by clients to indicate that the element has been dragged and its position should be updated.
 * <p>
 * This method may be called more than once after an initial {\@link yfiles.input.IReshapeHandler#initializeReshape} and will the
 * final call will be followed by either one {\@link yfiles.input.IReshapeHandler#reshapeFinished} or one {\@link yfiles.input.IReshapeHandler#cancelReshape}
 * call.
 * </p>
 * @abstract
 * @param {?} context The context to retrieve information about the reshaping from.
 * @param {!yfiles.geometry.Rect} originalBounds The value of the {\@link #bounds} property at the time of {\@link #initializeReshape}.
 * @param {!yfiles.geometry.Rect} newBounds The coordinates of the bounds in the world coordinate system that the client wants the shape to be at. Depending on the
 * implementation the {\@link #bounds} may or may not be modified to reflect the new value.
 * @return {void}
 */
yfiles.input.IReshapeHandler.prototype.handleReshape = function(context, originalBounds, newBounds) {};

/**
 * Called by clients to indicate that the element is going to be reshaped.
 * <p>
 * This call will be followed by one or more calls to {\@link yfiles.input.IReshapeHandler#handleReshape}, and a final {\@link yfiles.input.IReshapeHandler#reshapeFinished}
 * or {\@link yfiles.input.IReshapeHandler#cancelReshape}.
 * </p>
 * @abstract
 * @param {?} context The context to retrieve information about the drag from.
 * @return {void}
 */
yfiles.input.IReshapeHandler.prototype.initializeReshape = function(context) {};

/**
 * Called by clients to indicate that the reshaping has just been finished.
 * <p>
 * This method may be called after the initial {\@link yfiles.input.IReshapeHandler#initializeReshape} and zero or more invocations
 * of {\@link yfiles.input.IReshapeHandler#handleReshape}. Alternatively to this method the {\@link yfiles.input.IReshapeHandler#cancelReshape}
 * method might be called.
 * </p>
 * @abstract
 * @param {?} context The context to retrieve information about the drag from.
 * @param {!yfiles.geometry.Rect} originalBounds The value of the coordinate of the {\@link #bounds} property at the time of {\@link #initializeReshape}.
 * @param {!yfiles.geometry.Rect} newBounds The coordinates of the bounds in the world coordinate system that the client wants the shape to be at. Depending on the
 * implementation the {\@link #bounds} may or may not be modified to reflect the new value. This is the same value as delivered in the last
 * invocation of {\@link #handleReshape}
 * @return {void}
 */
yfiles.input.IReshapeHandler.prototype.reshapeFinished = function(context, originalBounds, newBounds) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IReshapeHandler;
/**
 * @record
 * @struct
 */
yfiles.input.InputModeEventArgs = function() {};
 /** @type {?} */
yfiles.input.InputModeEventArgs.prototype.context;
 /** @type {!yfiles.lang.Class} */
yfiles.input.InputModeEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.KeyboardInputMode = function() {};
 /** @type {number} */
yfiles.input.KeyboardInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.KeyboardInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.KeyboardInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.KeyboardInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.KeyboardInputMode.prototype.controller;
 /** @type {!yfiles.lang.Class} */
yfiles.input.KeyboardInputMode.$class;

/**
 * Adds a command and associated execution handlers to this instance.
 * <p>
 * The command will not be allowed to execute if this mode is {\@link yfiles.input.KeyboardInputMode#enabled disabled} or {\@link yfiles.input.ConcurrencyController#active inactive}.
 * </p>
 * Adds a command and associated execution handlers to this instance.
 * <p>
 * The command will not be allowed to execute if this mode is {\@link yfiles.input.KeyboardInputMode#enabled disabled} or {\@link yfiles.input.ConcurrencyController#active inactive}.
 * </p>
 * @param {?|{command: ?, execute: function(?, !Object, !Object): boolean, canExecute: function(?, !Object, !Object): boolean}} command_or_options The command to register handlers with.
 * @param {function(?, !Object, !Object): boolean=} execute
 * @param {function(?, !Object, !Object): boolean=} canExecute
 * @return {!yfiles.input.KeyboardInputModeBinding} A token for the newly created command binding that can used to later {\@link #remove remove} this binding from this instance again.
 */
yfiles.input.KeyboardInputMode.prototype.addCommandBinding = function(command_or_options, execute, canExecute) {};

/**
 * Adds an event handler for a specific key press gesture to this mode.
 * <p>
 * Using this registration method, the command will not be allowed to execute if this mode is {\@link yfiles.input.KeyboardInputMode#enabled disabled} or {\@link yfiles.input.ConcurrencyController#active inactive}.
 * </p>
 * @param {yfiles.view.Key} key The key constant that should be recognized.
 * @param {yfiles.view.ModifierKeys} modifiers The modifiers that should be recognized when the key is pressed.
 * @param {?} command The command to execute.
 * @param {!Object=} commandParameter
 * @return {!yfiles.input.KeyboardInputModeBinding} A token for the newly created command binding that can used to later {\@link #remove remove} this binding from this instance again.
 */
yfiles.input.KeyboardInputMode.prototype.addKeyBinding = function(key, modifiers, command, commandParameter) {};

/**
 * Adds a given handler to this instance that will be triggered if the event recognizer recognizes a {\@link yfiles.view.KeyEventArgs key event} that has
 * been triggered by the {\@link yfiles.view.CanvasComponent}.
 * @param {function(!Object, !yfiles.lang.EventArgs): boolean} recognizer An event recognizer that will be fed with all key events.
 * @param {?} command The command to invoke if the recognizer matches a key event.
 * @param {!Object=} commandParameter
 * @return {!yfiles.input.KeyboardInputModeBinding} The newly constructed binding on which {\@link #remove} can be called to remove the
 * resulting binding from this instance.
 */
yfiles.input.KeyboardInputMode.prototype.addRecognizerBinding = function(recognizer, command, commandParameter) {};

/**
 *
 * @return {void}
 */
yfiles.input.KeyboardInputMode.prototype.cancel = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.KeyboardInputMode.prototype.install = function(context, controller) {};

/**
 * Called after {\@link yfiles.input.KeyboardInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.KeyboardInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Enables the registered commands and can be overridden in subclasses to perform additional actions after the mode has
 * been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.KeyboardInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Disables the registered commands and can be overridden in subclasses to perform additional actions after the mode has
 * been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.KeyboardInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Called after {\@link yfiles.input.KeyboardInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.KeyboardInputMode.prototype.onStopped = function() {};

/**
 * Removes all previously registered commands from this instance.
 * <p>
 * This effectively disables the command for the instance managed by this mode.
 * </p>
 * @see yfiles.input.KeyboardInputMode#addKeyBinding
 * @see yfiles.input.KeyboardInputMode#addRecognizerBinding
 * @param {?} command The command to remove from all registered bindings.
 * @return {void}
 */
yfiles.input.KeyboardInputMode.prototype.removeCommand = function(command) {};

/**
 * Overridden to only return <code>true</code> if this instance does not currently {\@link yfiles.input.ConcurrencyController#hasMutex have the input mutex}.
 * @return {boolean} <code>true</code> iff this instance does not {\@link #hasMutex own the mutex}.
 */
yfiles.input.KeyboardInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.KeyboardInputMode.prototype.uninstall = function(context) {};
/**
 * @record
 * @struct
 */
yfiles.input.KeyboardInputModeBinding = function() {};
 /** @type {?} */
yfiles.input.KeyboardInputModeBinding.prototype.command;
 /** @type {!yfiles.lang.Class} */
yfiles.input.KeyboardInputModeBinding.$class;

/**
 * Removes the binding represented by this instance from the {\@link yfiles.input.KeyboardInputMode} it has been created for.
 * <p>
 * Once this method has been called, the instance can be
 * </p>
 * @return {void}
 */
yfiles.input.KeyboardInputModeBinding.prototype.remove = function() {};
/**
 * @record
 * @struct
 */
yfiles.input.MarqueeSelectionInputMode = function() {};
 /** @type {number} */
yfiles.input.MarqueeSelectionInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.MarqueeSelectionInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.MarqueeSelectionInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.MarqueeSelectionInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.MarqueeSelectionInputMode.prototype.controller;
 /** @type {!yfiles.geometry.Rect} */
yfiles.input.MarqueeSelectionInputMode.prototype.selectionRectangle;
 /** @type {?} */
yfiles.input.MarqueeSelectionInputMode.prototype.template;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MarqueeSelectionInputMode.prototype.cancelRecognizer;
 /** @type {string} */
yfiles.input.MarqueeSelectionInputMode.MARQUEE_RECTANGLE_TEMPLATE_KEY;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.MarqueeSelectionInputMode.prototype.marqueeCursor;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MarqueeSelectionInputMode.prototype.pressedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MarqueeSelectionInputMode.prototype.draggedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MarqueeSelectionInputMode.prototype.releasedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MarqueeSelectionInputMode.prototype.pressedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MarqueeSelectionInputMode.prototype.draggedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MarqueeSelectionInputMode.prototype.releasedRecognizerTouch;
 /** @type {!yfiles.lang.Class} */
yfiles.input.MarqueeSelectionInputMode.$class;

/**
 * Cancels any pending marquee selection.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.cancel = function() {};

/**
 * Helper method that yields a suitably configured {\@link yfiles.input.InputModeEventArgs} for this input mode.
 * @protected
 * @return {!yfiles.input.MarqueeSelectionEventArgs} An input mode event argument that is configured for this instance.
 */
yfiles.input.MarqueeSelectionInputMode.prototype.createInputModeEventArgs = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.install = function(context, controller) {};

/**
 * Called after {\@link yfiles.input.MarqueeSelectionInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Triggers the {\@link yfiles.input.MarqueeSelectionInputMode#addDragCanceledListener DragCanceled}
 * event.
 * @protected
 * @param {!yfiles.input.MarqueeSelectionEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onDragCanceled = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.MarqueeSelectionInputMode#addDragCancelingListener DragCanceling}
 * event.
 * @protected
 * @param {!yfiles.input.MarqueeSelectionEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onDragCanceling = function(evt) {};

/**
 * Callback triggered once the drag has been finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.MarqueeSelectionInputMode#addDragFinishedListener DragFinished}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.MarqueeSelectionEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onDragFinished = function(evt) {};

/**
 * Callback triggered before the drag will be finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.MarqueeSelectionInputMode#addDragFinishingListener DragFinishing}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.MarqueeSelectionEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onDragFinishing = function(evt) {};

/**
 * Callback triggered at the end of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.MarqueeSelectionInputMode#addDraggedListener Dragged}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.MarqueeSelectionEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onDragged = function(evt) {};

/**
 * Callback triggered at the start of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.MarqueeSelectionInputMode#addDraggingListener Dragging}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.MarqueeSelectionEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onDragging = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.MarqueeSelectionInputMode#addDragStartedListener DragStarted}
 * event.
 * @protected
 * @param {!yfiles.input.MarqueeSelectionEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onDragStarted = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.MarqueeSelectionInputMode#addDragStartingListener DragStarting}
 * event.
 * @protected
 * @param {!yfiles.input.MarqueeSelectionEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onDragStarting = function(evt) {};

/**
 * Called after {\@link yfiles.input.MarqueeSelectionInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.onStopped = function() {};

/**
 *
 * @return {boolean}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.MarqueeSelectionInputMode#removeDraggingListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.addDraggingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.MarqueeSelectionInputMode#addDraggingListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.removeDraggingListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.MarqueeSelectionInputMode#removeDraggedListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.addDraggedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.MarqueeSelectionInputMode#addDraggedListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.removeDraggedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.MarqueeSelectionInputMode#removeDragCanceledListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.addDragCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.MarqueeSelectionInputMode#addDragCanceledListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.removeDragCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.MarqueeSelectionInputMode#removeDragCancelingListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.addDragCancelingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.MarqueeSelectionInputMode#addDragCancelingListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.removeDragCancelingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.MarqueeSelectionInputMode#removeDragFinishingListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.addDragFinishingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.MarqueeSelectionInputMode#addDragFinishingListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.removeDragFinishingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragFinished</code> event that occurs the drag has been finished.
 * @see yfiles.input.MarqueeSelectionInputMode#removeDragFinishedListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.addDragFinishedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinished</code> event that occurs the drag has been finished.
 * @see yfiles.input.MarqueeSelectionInputMode#addDragFinishedListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.removeDragFinishedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.MarqueeSelectionInputMode#removeDragStartingListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.addDragStartingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.MarqueeSelectionInputMode#addDragStartingListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.removeDragStartingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.MarqueeSelectionInputMode#removeDragStartedListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.addDragStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.MarqueeSelectionInputMode#addDragStartedListener
 * @param {function(!Object, !yfiles.input.MarqueeSelectionEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MarqueeSelectionInputMode.prototype.removeDragStartedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.MarqueeSelectionEventArgs = function() {};
 /** @type {!yfiles.geometry.Rect} */
yfiles.input.MarqueeSelectionEventArgs.prototype.rectangle;
 /** @type {!yfiles.lang.Class} */
yfiles.input.MarqueeSelectionEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.ToolTipQueryEventArgs = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.input.ToolTipQueryEventArgs.prototype.queryLocation;
 /** @type {!Object} */
yfiles.input.ToolTipQueryEventArgs.prototype.toolTip;
 /** @type {boolean} */
yfiles.input.ToolTipQueryEventArgs.prototype.handled;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ToolTipQueryEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.MouseHoverInputMode = function() {};
 /** @type {number} */
yfiles.input.MouseHoverInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.MouseHoverInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.MouseHoverInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.MouseHoverInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.MouseHoverInputMode.prototype.controller;
 /** @type {?} */
yfiles.input.MouseHoverInputMode.prototype.validHoverLocationHitTestable;
 /** @type {!yfiles.view.ToolTip} */
yfiles.input.MouseHoverInputMode.prototype.toolTip;
 /** @type {boolean} */
yfiles.input.MouseHoverInputMode.prototype.showing;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.MouseHoverInputMode.prototype.toolTipLocationOffset;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.input.MouseHoverInputMode.prototype.duration;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.input.MouseHoverInputMode.prototype.delay;
 /** @type {!yfiles.geometry.Size} */
yfiles.input.MouseHoverInputMode.prototype.mouseHoverSize;
 /** @type {boolean} */
yfiles.input.MouseHoverInputMode.prototype.closeOnClick;
 /** @type {!yfiles.lang.Class} */
yfiles.input.MouseHoverInputMode.$class;

/**
 * Adjust the calculated tooltip position.
 * <p>
 * This default implementation of this method moves the tooltip into the visible area if it extends beyond the document
 * bounds.
 * </p>
 * @see yfiles.input.MouseHoverInputMode#getToolTipLocation
 * @protected
 * @param {!yfiles.geometry.Point} originalPosition The calculated tooltip position relative to the document root
 * @return {!yfiles.geometry.Point} The adjusted tooltip location
 */
yfiles.input.MouseHoverInputMode.prototype.adjustTooltipPosition = function(originalPosition) {};

/**
 *
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.cancel = function() {};

/**
 * Creates an {\@link yfiles.input.IInputModeContext} for use with the {\@link yfiles.input.MouseHoverInputMode#addQueryToolTipListener QueryToolTip}
 * event for the upcoming text query operation.
 * @protected
 * @return {?} An instance of {\@link }.
 */
yfiles.input.MouseHoverInputMode.prototype.createHoverInputModeContext = function() {};

/**
 * Factory method that creates the {\@link yfiles.input.MouseHoverInputMode#toolTip}.
 * @protected
 * @return {!yfiles.view.ToolTip} A simple {\@link #toolTip}.
 */
yfiles.input.MouseHoverInputMode.prototype.createToolTip = function() {};

/**
 * Callback method that provides a text for the given location or <code>null</code>.
 * @see yfiles.input.MouseHoverInputMode#addQueryToolTipListener
 * @see yfiles.input.MouseHoverInputMode#createHoverInputModeContext
 * @protected
 * @param {!yfiles.geometry.Point} location The location to find a text for.
 * @return {!Object} A string or <code>null</code> to indicate that no tool tip should be shown.
 */
yfiles.input.MouseHoverInputMode.prototype.getToolTipContent = function(location) {};

/**
 * Finds the position in canvas view coordinates to display the tool tip at for the given world coordinates.
 * <p>
 * This method adds the {\@link yfiles.input.MouseHoverInputMode#toolTipLocationOffset} after converting the given location to view coordinates.
 * </p>
 * @see yfiles.input.MouseHoverInputMode#toolTipLocationOffset
 * @protected
 * @param {!yfiles.geometry.Point} location The position in world coordinates.
 * @return {!yfiles.geometry.Point} The position in view coordinates.
 */
yfiles.input.MouseHoverInputMode.prototype.getToolTipLocation = function(location) {};

/**
 * Immediately hides the tool tip.
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.hide = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.install = function(context, controller) {};

/**
 * Called after {\@link yfiles.input.MouseHoverInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Called when the tooltip should be hidden.
 * @protected
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.onHide = function() {};

/**
 * Raises the {\@link yfiles.input.MouseHoverInputMode#addQueryToolTipListener QueryToolTip} event.
 * @protected
 * @param {!yfiles.input.ToolTipQueryEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.onQueryToolTip = function(evt) {};

/**
 * Triggered when the mouse hovers over the given coordinates.
 * <p>
 * This method will call {\@link yfiles.input.MouseHoverInputMode#getToolTipContent} to query the content and will display the {\@link yfiles.input.MouseHoverInputMode#toolTip} at
 * the location returned by {\@link yfiles.input.MouseHoverInputMode#getToolTipLocation} if the content is not <code>null</code>.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} location
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.onShow = function(location) {};

/**
 * Called after {\@link yfiles.input.MouseHoverInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.onStopped = function() {};

/**
 * Immediately shows the tool tip at the given location.
 * @param {!yfiles.geometry.Point} location The location in the world coordinate system.
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.show = function(location) {};

/**
 * Overridden to only return <code>true</code> if this instance does not currently {\@link yfiles.input.ConcurrencyController#hasMutex have the input mutex}.
 * @return {boolean} <code>true</code> iff this instance does not {\@link #hasMutex own the mutex}.
 */
yfiles.input.MouseHoverInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>QueryToolTip</code> event that occurs when this mode queries the tool tip for a certain query
 * location.
 * <p>
 * Handlers should set the {\@link yfiles.input.ToolTipQueryEventArgs#toolTip} property or set/respect the {\@link yfiles.input.ToolTipQueryEventArgs#handled} property accordingly.
 * </p>
 * @see yfiles.input.MouseHoverInputMode#removeQueryToolTipListener
 * @param {function(!Object, !yfiles.input.ToolTipQueryEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.addQueryToolTipListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryToolTip</code> event that occurs when this mode queries the tool tip for a certain
 * query location.
 * <p>
 * Handlers should set the {\@link yfiles.input.ToolTipQueryEventArgs#toolTip} property or set/respect the {\@link yfiles.input.ToolTipQueryEventArgs#handled} property accordingly.
 * </p>
 * @see yfiles.input.MouseHoverInputMode#addQueryToolTipListener
 * @param {function(!Object, !yfiles.input.ToolTipQueryEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MouseHoverInputMode.prototype.removeQueryToolTipListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.MoveInputMode = function() {};
 /** @type {boolean} */
yfiles.input.MoveInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.MoveInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.MoveInputMode.prototype.controller;
 /** @type {number} */
yfiles.input.MoveInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.MoveInputMode.prototype.exclusive;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.disableSnappingRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.enableSnappingRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.pressedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.hoverRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.draggedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.cancelRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.releasedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.pressedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.draggedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveInputMode.prototype.releasedRecognizerTouch;
 /** @type {?} */
yfiles.input.MoveInputMode.prototype.hitTestable;
 /** @type {?} */
yfiles.input.MoveInputMode.prototype.positionHandler;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.MoveInputMode.prototype.moveCursor;
 /** @type {!yfiles.input.SnapContext} */
yfiles.input.MoveInputMode.prototype.snapContext;
 /** @type {boolean} */
yfiles.input.MoveInputMode.prototype.isDragging;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.MoveInputMode.prototype.initialLocation;
 /** @type {?<?>} */
yfiles.input.MoveInputMode.prototype.affectedItems;
 /** @type {!yfiles.lang.Class} */
yfiles.input.MoveInputMode.$class;

/**
 * Callback that is called when this mode is "armed".
 * <p>
 * This happens when the mouse {\@link yfiles.input.MoveInputMode#hoverRecognizer hovers} over the item(s) to move. This implementation sets the mouse cursor to {\@link yfiles.input.MoveInputMode#moveCursor}.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.arm = function() {};

/**
 * Cancels the editing of this mode.
 * <p>
 * This implementation {\@link yfiles.input.ConcurrencyController#releaseMutex releases} the mutex if it is currently owned by this instance and calls
 * {\@link yfiles.input.MoveInputMode#onCanceled}.
 * </p>
 * @see yfiles.input.MoveInputMode#onCanceled
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.cancel = function() {};

/**
 * Creates an {\@link yfiles.input.IInputModeContext} for use with the {\@link yfiles.input.IPositionHandler} interface for the upcoming drag
 * operation.
 * @protected
 * @return {?} An instance of {\@link }.
 */
yfiles.input.MoveInputMode.prototype.createPositionHandlerInputModeContext = function() {};

/**
 * Callback that is called when this mode is "disarmed".
 * <p>
 * This happens when the mouse stops hovering over the item(s). This implementation resets the mouse cursor again.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.disarm = function() {};

/**
 * Simulates the start of a drag and puts the state machine into the dragging state.
 * <p>
 * Subsequent moves of input devices will behave as if the dragging has been successfully initiated at <code>location</code>.
 * </p>
 * @param {!yfiles.geometry.Point} location The location where the drag had been initialized.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.doStartDrag = function(location) {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.install = function(context, controller) {};

/**
 * Determines whether the given location is a valid start location for the move gesture.
 * <p>
 * This implementation delegates to the {\@link yfiles.input.MoveInputMode#hitTestable}. During this callback it is possible to reset or reconfigure the {\@link yfiles.input.MoveInputMode#positionHandler}.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} location The location in the world coordinate system.
 * @return {boolean} <code>true</code> if at the given location it is valid to start the move gesture; otherwise, <code>false</code>.
 */
yfiles.input.MoveInputMode.prototype.isValidStartLocation = function(location) {};

/**
 * Called after {\@link yfiles.input.MoveInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Triggers the {\@link yfiles.input.MoveInputMode#addDragCanceledListener DragCanceled} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onDragCanceled = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.MoveInputMode#addDragCancelingListener DragCanceling} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onDragCanceling = function(evt) {};

/**
 * Callback triggered once the drag has been finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.MoveInputMode#addDragFinishedListener DragFinished} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onDragFinished = function(evt) {};

/**
 * Callback triggered before the drag will be finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.MoveInputMode#addDragFinishingListener DragFinishing} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onDragFinishing = function(evt) {};

/**
 * Callback triggered at the end of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.MoveInputMode#addDraggedListener Dragged} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onDragged = function(evt) {};

/**
 * Callback triggered at the start of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.MoveInputMode#addDraggingListener Dragging} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onDragging = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.MoveInputMode#addDragStartedListener DragStarted} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onDragStarted = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.MoveInputMode#addDragStartingListener DragStarting} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onDragStarting = function(evt) {};

/**
 * Raises the {\@link yfiles.input.MoveInputMode#addQueryPositionHandlerListener QueryPositionHandler} event.
 * @protected
 * @param {!yfiles.input.QueryPositionHandlerEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onQueryPositionHandler = function(evt) {};

/**
 * Called after {\@link yfiles.input.MoveInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.onStopped = function() {};

/**
 *
 * @return {boolean}
 */
yfiles.input.MoveInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>QueryPositionHandler</code> event that occurs when a drag is recognized for the
 * {\@link yfiles.input.MoveInputMode}.
 * <p>
 * If the event args are {\@link yfiles.input.QueryPositionHandlerEventArgs#handled}, the {\@link yfiles.input.IPositionHandler} that is carried with the event args is used to actually move
 * the items. Otherwise the pre-set {\@link yfiles.input.MoveInputMode#positionHandler} property is used.
 * </p>
 * @see yfiles.input.MoveInputMode#removeQueryPositionHandlerListener
 * @param {function(!Object, !yfiles.input.QueryPositionHandlerEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.addQueryPositionHandlerListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryPositionHandler</code> event that occurs when a drag is recognized for the
 * {\@link yfiles.input.MoveInputMode}.
 * <p>
 * If the event args are {\@link yfiles.input.QueryPositionHandlerEventArgs#handled}, the {\@link yfiles.input.IPositionHandler} that is carried with the event args is used to actually move
 * the items. Otherwise the pre-set {\@link yfiles.input.MoveInputMode#positionHandler} property is used.
 * </p>
 * @see yfiles.input.MoveInputMode#addQueryPositionHandlerListener
 * @param {function(!Object, !yfiles.input.QueryPositionHandlerEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.removeQueryPositionHandlerListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.MoveInputMode#removeDragFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.addDragFinishingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.MoveInputMode#addDragFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.removeDragFinishingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragFinished</code> event that occurs once the drag has been finished.
 * @see yfiles.input.MoveInputMode#removeDragFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.addDragFinishedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinished</code> event that occurs once the drag has been finished.
 * @see yfiles.input.MoveInputMode#addDragFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.removeDragFinishedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.MoveInputMode#removeDragStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.addDragStartingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.MoveInputMode#addDragStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.removeDragStartingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.MoveInputMode#removeDragStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.addDragStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.MoveInputMode#addDragStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.removeDragStartedListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.MoveInputMode#removeDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.addDraggingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.MoveInputMode#addDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.removeDraggingListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.MoveInputMode#removeDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.addDraggedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.MoveInputMode#addDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.removeDraggedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.MoveInputMode#removeDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.addDragCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.MoveInputMode#addDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.removeDragCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.MoveInputMode#removeDragCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.addDragCancelingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.MoveInputMode#addDragCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveInputMode.prototype.removeDragCancelingListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.QueryPositionHandlerEventArgs = function() {};
 /** @type {?} */
yfiles.input.QueryPositionHandlerEventArgs.prototype.positionHandler;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.QueryPositionHandlerEventArgs.prototype.queryLocation;
 /** @type {boolean} */
yfiles.input.QueryPositionHandlerEventArgs.prototype.handled;
 /** @type {!yfiles.lang.Class} */
yfiles.input.QueryPositionHandlerEventArgs.$class;

/** @const */
yfiles.input.InertiaPolicies = {};
/** @const {number} */
yfiles.input.InertiaPolicies.NEVER;
/** @const {number} */
yfiles.input.InertiaPolicies.MOUSE;
/** @const {number} */
yfiles.input.InertiaPolicies.TOUCH;
/** @const {number} */
yfiles.input.InertiaPolicies.ALWAYS;
/**
 * @record
 * @struct
 */
yfiles.input.MoveViewportInputMode = function() {};
 /** @type {number} */
yfiles.input.MoveViewportInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.MoveViewportInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.MoveViewportInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.MoveViewportInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.MoveViewportInputMode.prototype.controller;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveViewportInputMode.prototype.primaryDownRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveViewportInputMode.prototype.primaryMoveRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveViewportInputMode.prototype.primaryUpRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveViewportInputMode.prototype.secondaryDownRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveViewportInputMode.prototype.secondaryMoveRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveViewportInputMode.prototype.secondaryUpRecognizer;
 /** @type {number} */
yfiles.input.MoveViewportInputMode.prototype.inertiaFactor;
 /** @type {number} */
yfiles.input.MoveViewportInputMode.prototype.inertiaThreshold;
 /** @type {number} */
yfiles.input.MoveViewportInputMode.prototype.inertiaDamping;
 /** @type {yfiles.input.InertiaPolicies} */
yfiles.input.MoveViewportInputMode.prototype.inertia;
 /** @type {boolean} */
yfiles.input.MoveViewportInputMode.prototype.allowPinchZoom;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.MoveViewportInputMode.prototype.dragCursor;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveViewportInputMode.prototype.pressedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveViewportInputMode.prototype.draggedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MoveViewportInputMode.prototype.releasedRecognizer;
 /** @type {!yfiles.lang.Class} */
yfiles.input.MoveViewportInputMode.$class;

/**
 * Called to prepare moving the viewport when the mouse is pressed.
 * <p>
 * This will set the mouse cursor to {\@link yfiles.input.MoveViewportInputMode#dragCursor}.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.arm = function() {};

/**
 * Cancels navigation.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.cancel = function() {};

/**
 * Called after moving the viewport is finished or canceled.
 * <p>
 * This will reset the mouse cursor.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.disarm = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.install = function(context, controller) {};

/**
 * Called after {\@link yfiles.input.MoveViewportInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Triggers the {\@link yfiles.input.MoveViewportInputMode#addDragCanceledListener DragCanceled} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onDragCanceled = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.MoveViewportInputMode#addDragCancelingListener DragCanceling} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onDragCanceling = function(evt) {};

/**
 * Callback triggered once the drag has been finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.MoveViewportInputMode#addDragFinishedListener DragFinished}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onDragFinished = function(evt) {};

/**
 * Callback triggered before the drag will be finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.MoveViewportInputMode#addDragFinishingListener DragFinishing}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onDragFinishing = function(evt) {};

/**
 * Callback triggered at the end of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.MoveViewportInputMode#addDraggedListener Dragged}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onDragged = function(evt) {};

/**
 * Callback triggered at the start of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.MoveViewportInputMode#addDraggingListener Dragging}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onDragging = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.MoveViewportInputMode#addDragStartedListener DragStarted} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onDragStarted = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.MoveViewportInputMode#addDragStartingListener DragStarting} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onDragStarting = function(evt) {};

/**
 * Called after {\@link yfiles.input.MoveViewportInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.onStopped = function() {};

/**
 *
 * @return {boolean}
 */
yfiles.input.MoveViewportInputMode.prototype.tryStop = function() {};

/**
 *
 * @param {?} context
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.MoveViewportInputMode#removeDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.addDraggingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.MoveViewportInputMode#addDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.removeDraggingListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.MoveViewportInputMode#removeDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.addDraggedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.MoveViewportInputMode#addDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.removeDraggedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.MoveViewportInputMode#removeDragFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.addDragFinishingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.MoveViewportInputMode#addDragFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.removeDragFinishingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragFinished</code> event that occurs once the drag has been finished.
 * @see yfiles.input.MoveViewportInputMode#removeDragFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.addDragFinishedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinished</code> event that occurs once the drag has been finished.
 * @see yfiles.input.MoveViewportInputMode#addDragFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.removeDragFinishedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.MoveViewportInputMode#removeDragStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.addDragStartingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.MoveViewportInputMode#addDragStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.removeDragStartingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.MoveViewportInputMode#removeDragStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.addDragStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.MoveViewportInputMode#addDragStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.removeDragStartedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.MoveViewportInputMode#removeDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.addDragCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.MoveViewportInputMode#addDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.removeDragCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.MoveViewportInputMode#removeDragCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.addDragCancelingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.MoveViewportInputMode#addDragCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.MoveViewportInputMode.prototype.removeDragCancelingListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.MultiplexingInputMode = function() {};
 /** @type {boolean} */
yfiles.input.MultiplexingInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.MultiplexingInputMode.prototype.enabled;
 /** @type {number} */
yfiles.input.MultiplexingInputMode.prototype.priority;
 /** @type {?} */
yfiles.input.MultiplexingInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.MultiplexingInputMode.prototype.controller;
 /** @type {?} */
yfiles.input.MultiplexingInputMode.prototype.mutexOwner;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.MultiplexingInputMode.prototype.defaultCursor;
 /** @type {!yfiles.lang.Class} */
yfiles.input.MultiplexingInputMode.$class;

/**
 * Adds the given <code>mode</code>.
 * <p>
 * The input modes will be ordered according to their {\@link yfiles.input.IInputMode#priority}: Input modes with lower priority will be {\@link yfiles.input.IInputMode#install installed} earlier.
 * </p>
 * <p>
 * Input modes will run exclusively if the {\@link yfiles.input.ConcurrencyController#exclusive} property of their {\@link yfiles.input.IInputMode#install installed controller} is set to <code>true</code>. Otherwise they can not
 * and will not be deactivated if another {\@link yfiles.input.IInputMode} acquires the mutex.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If the same <code>mode</code> has is already added to this instance.
 * @param {?} mode The input mode to add to this mode.
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.add = function(mode) {};

/**
 * Adjusts the cursor of the {\@link yfiles.view.CanvasComponent} according to the current input mutex owner or the first mode in
 * the list whose {\@link yfiles.input.ConcurrencyController} returns a non-null {\@link yfiles.input.ConcurrencyController#preferredCursor}.
 * <p>
 * This method will set {\@link yfiles.input.MultiplexingInputMode#defaultCursor} as the current cursor if no other {\@link yfiles.input.ConcurrencyController#preferredCursor} has been specified.
 * </p>
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.adjustCursor = function() {};

/**
 * Cancels all modes.
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.cancel = function() {};

/**
 * Callback method that will be used by the {\@link yfiles.input.MultiplexingInputMode#createChildInputModeContext child context's} {\@link yfiles.graph.ILookup#lookup} method.
 * @see yfiles.input.MultiplexingInputMode#createChildInputModeContext
 * @protected
 * @param {!yfiles.lang.Class} type The type argument passed to {\@link #lookup}.
 * @return {!Object} The result of the lookup query, or <code>null</code>.
 */
yfiles.input.MultiplexingInputMode.prototype.childInputModeContextLookup = function(type) {};

/**
 * Yields an {\@link yfiles.input.IInputModeContext} for the child modes of this mode.
 * <p>
 * This method is called during {\@link yfiles.input.MultiplexingInputMode#install installation} to create a new context for the child modes and can be used by client code to
 * obtain a suitable context object. The {\@link yfiles.input.MultiplexingInputMode#inputModeContext} property is already set, when this method is called. {\@link yfiles.graph.ILookup#lookup}
 * calls for the created context will be resolved by this instance's {\@link yfiles.input.MultiplexingInputMode#childInputModeContextLookup}
 * method.
 * </p>
 * @protected
 * @return {?} A new instance that delegates to the {\@link #inputModeContext parent's context.}
 */
yfiles.input.MultiplexingInputMode.prototype.createChildInputModeContext = function() {};

/**
 * Helper method that yields a suitably configured {\@link yfiles.input.InputModeEventArgs} for this input mode.
 * @protected
 * @param {?} context An input mode context that is available in the {\@link }.
 * <p>
 * Can be <code>null</code> in which case a new context for this instance is created automatically.
 * </p>
 * @return {!yfiles.input.InputModeEventArgs} An input mode event argument that is configured for this instance.
 */
yfiles.input.MultiplexingInputMode.prototype.createInputModeEventArgs = function(context) {};

/**
 * Returns a list of all modes managed by this instance in sorted order.
 * @return {?<?>} A list of the modes.
 */
yfiles.input.MultiplexingInputMode.prototype.getSortedModes = function() {};

/**
 * Performs one-time initialization of this instance.
 * <p>
 * This method should not be invoked by subclasses. This will be done automatically upon first {\@link yfiles.input.MultiplexingInputMode#install installation} of this mode.
 * </p>
 * <p>
 * This code will be executed only once per instance. The {\@link yfiles.input.MultiplexingInputMode#inputModeContext} property will be <code>null</code> when this code is executed. This method
 * should not be used to install this mode into a specific canvas. Subclasses should always call <code>base.Initialize()</code> first.
 * </p>
 * @see yfiles.input.MultiplexingInputMode#install
 * @protected
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.initialize = function() {};

/**
 *
 * @param {?} context
 * @param {!yfiles.input.ConcurrencyController} controller
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.install = function(context, controller) {};

/**
 * Convenience method for subclass implementations that invalidates the canvas this mode is currently installed in.
 * @protected
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.invalidate = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * This implementation reenabled previously disabled concurrent child modes.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * This implementation sets the {\@link yfiles.input.ConcurrencyController#preferredCursor} property to <code>null</code> and {\@link yfiles.input.ConcurrencyController#releaseMutex releases} the mutex if the mutex is currently owned by this instance.
 * Also, all concurrent child modes will be disabled.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Removes the given mode from this compound mode.
 * @param {?} mode The mode to remove.
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.remove = function(mode) {};

/**
 * Called when the {\@link yfiles.input.IInputMode#priority} of an {\@link yfiles.input.MultiplexingInputMode#add installed} sub mode has changed.
 * <p>
 * This implementation {\@link yfiles.input.MultiplexingInputMode#uninstall uninstalls} all sub modes and then re-{\@link yfiles.input.MultiplexingInputMode#install installs} them according to their new priorities.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.subModePriorityChanged = function() {};

/**
 * Tries to stop all modes.
 * @return {boolean}
 */
yfiles.input.MultiplexingInputMode.prototype.tryStop = function() {};

/**
 *
 * @param {?} context
 * @return {void}
 */
yfiles.input.MultiplexingInputMode.prototype.uninstall = function(context) {};
/**
 * @record
 * @struct
 */
yfiles.input.OverviewInputMode = function() {};
 /** @type {boolean} */
yfiles.input.OverviewInputMode.prototype.autoInvalidate;
 /** @type {string} */
yfiles.input.OverviewInputMode.VIEWPORT_TEMPLATE_KEY;
 /** @type {!yfiles.input.HandleInputMode} */
yfiles.input.OverviewInputMode.prototype.handleInputMode;
 /** @type {!yfiles.input.MoveInputMode} */
yfiles.input.OverviewInputMode.prototype.moveInputMode;
 /** @type {!yfiles.input.ClickInputMode} */
yfiles.input.OverviewInputMode.prototype.clickInputMode;
 /** @type {!yfiles.input.TapInputMode} */
yfiles.input.OverviewInputMode.prototype.tapInputMode;
 /** @type {!yfiles.input.KeyboardInputMode} */
yfiles.input.OverviewInputMode.prototype.keyboardInputMode;
 /** @type {?<?>} */
yfiles.input.OverviewInputMode.prototype.availableCommands;
 /** @type {!yfiles.view.CanvasComponent} */
yfiles.input.OverviewInputMode.prototype.canvasComponent;
 /** @type {?} */
yfiles.input.OverviewInputMode.prototype.template;
 /** @type {boolean} */
yfiles.input.OverviewInputMode.prototype.autoMouseWheelZoom;
 /** @type {!yfiles.geometry.Insets} */
yfiles.input.OverviewInputMode.prototype.margins;
 /** @type {!yfiles.lang.Class} */
yfiles.input.OverviewInputMode.$class;

/**
 * Factory method for the {\@link yfiles.input.OverviewInputMode#clickInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.OverviewInputMode#clickInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.ClickInputMode} a new instance of ClickInputMode
 */
yfiles.input.OverviewInputMode.prototype.createClickInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.OverviewInputMode#handleInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.OverviewInputMode#handleInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.HandleInputMode} a new instance of {\@link }
 */
yfiles.input.OverviewInputMode.prototype.createHandleInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.OverviewInputMode#keyboardInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.OverviewInputMode#keyboardInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.KeyboardInputMode} a new instance of {\@link }.
 */
yfiles.input.OverviewInputMode.prototype.createKeyboardInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.OverviewInputMode#moveInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.OverviewInputMode#moveInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.MoveInputMode} a new instance of MoveInputMode
 */
yfiles.input.OverviewInputMode.prototype.createMoveInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.OverviewInputMode#tapInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.OverviewInputMode#tapInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.TapInputMode} a new instance of TapInputMode
 */
yfiles.input.OverviewInputMode.prototype.createTapInputMode = function() {};

/**
 * Callback method that is used by {\@link yfiles.input.OverviewInputMode#createKeyboardInputMode} to determine which of the
 * built-in {\@link yfiles.input.ICommand}s to install.
 * <p>
 * This implementation unconditionally returns <code>true</code>, subclasses may override this method to adjust the behavior.
 * </p>
 * @protected
 * @param {?} command The command to install.
 * @return {boolean} Whether to install this command.
 */
yfiles.input.OverviewInputMode.prototype.shouldInstallCommand = function(command) {};

/**
 * Updates the {\@link yfiles.view.CanvasComponent#zoom zoom} and {\@link yfiles.view.CanvasComponent#viewPoint viewpoint} of the overview control.
 * <p>
 * This method is called when the {\@link yfiles.view.CanvasComponent#contentRect graph bounds} of the {\@link yfiles.input.OverviewInputMode#canvasComponent } have changed. The {\@link yfiles.input.OverviewInputMode#margins margins} should be respected.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.OverviewInputMode.prototype.updateVisibleArea = function() {};
/**
 * @record
 * @struct
 */
yfiles.input.PopulateItemContextMenuEventArgs = function() {};
 /** @type {TModelItem} */
yfiles.input.PopulateItemContextMenuEventArgs.prototype.item;
 /** @type {!yfiles.lang.Class} */
yfiles.input.PopulateItemContextMenuEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.QueryItemToolTipEventArgs = function() {};
 /** @type {TModelItem} */
yfiles.input.QueryItemToolTipEventArgs.prototype.item;
 /** @type {!yfiles.lang.Class} */
yfiles.input.QueryItemToolTipEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.RectangleReshapeHandleProvider = function() {};
 /** @type {?} */
yfiles.input.RectangleReshapeHandleProvider.prototype.rectangle;
 /** @type {!yfiles.lang.Class} */
yfiles.input.RectangleReshapeHandleProvider.$class;
/**
 * @record
 * @struct
 */
yfiles.input.ReshapeHandleProviderBase = function() {};
 /** @type {?} */
yfiles.input.ReshapeHandleProviderBase.prototype.minimumSize;
 /** @type {?} */
yfiles.input.ReshapeHandleProviderBase.prototype.minimumEnclosedArea;
 /** @type {?} */
yfiles.input.ReshapeHandleProviderBase.prototype.maximumSize;
 /** @type {yfiles.input.HandlePositions} */
yfiles.input.ReshapeHandleProviderBase.prototype.handlePositions;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ReshapeHandleProviderBase.$class;

/**
 * Returns the {\@link yfiles.input.ReshapeHandleProviderBase#handlePositions} property.
 * @param {?} context
 * @return {yfiles.input.HandlePositions} A bitwise combination of all handle positions this instance provides a handle for if queried in
 * {\@link #getHandle}.
 */
yfiles.input.ReshapeHandleProviderBase.prototype.getAvailableHandles = function(context) {};

/**
 * Provides a {\@link yfiles.input.IHandle} that uses the rectangle and reshapeable instance bound to this instance to perform the
 * actual reshaping.
 * <p>
 * This method may be called for each possible single position contained in the set as returned by
 * {\@link yfiles.input.ReshapeHandleProviderBase#getAvailableHandles}.
 * </p>
 * @abstract
 * @param {?} context The context for which the handles are queried.
 * @param {yfiles.input.HandlePositions} position The position to provide an instance for.
 * @return {?} A handle implementation.
 */
yfiles.input.ReshapeHandleProviderBase.prototype.getHandle = function(context, position) {};
/**
 * @record
 * @struct
 */
yfiles.input.SelectionEventArgs = function() {};
 /** @type {?<T>} */
yfiles.input.SelectionEventArgs.prototype.selection;
 /** @type {!yfiles.lang.Class} */
yfiles.input.SelectionEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.SnapContext = function() {};
 /** @type {boolean} */
yfiles.input.SnapContext.prototype.visualizeSnapResults;
 /** @type {boolean} */
yfiles.input.SnapContext.prototype.isInitializing;
 /** @type {?} */
yfiles.input.SnapContext.prototype.currentInputModeContext;
 /** @type {?<!yfiles.input.SnapResult>} */
yfiles.input.SnapContext.prototype.snapResults;
 /** @type {boolean} */
yfiles.input.SnapContext.prototype.isInitialized;
 /** @type {number} */
yfiles.input.SnapContext.prototype.snapDistance;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.SnapContext.prototype.originalLocation;
 /** @type {boolean} */
yfiles.input.SnapContext.prototype.enabled;
 /** @type {!yfiles.lang.Class} */
yfiles.input.SnapContext.$class;

/**
 * Called when a drag has been canceled.
 * <p>
 * Clears all temporary lists and sets {\@link yfiles.input.SnapContext#isInitialized} back to false, as well as performs {\@link yfiles.input.SnapContext#cleanUp} and finally
 * triggers the {\@link yfiles.input.SnapContext#addCleanedUpListener CleanedUp} event.
 * </p>
 * @return {void}
 */
yfiles.input.SnapContext.prototype.cancelDrag = function() {};

/**
 * Performs clean up procedures.
 * <p>
 * This is called in response to {\@link yfiles.input.SnapContext#cancelDrag} and {\@link yfiles.input.SnapContext#dragFinished} as well as
 * initially during {\@link yfiles.input.SnapContext#initializeDrag}.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.SnapContext.prototype.cleanUp = function() {};

/**
 * Helper method used by {\@link yfiles.input.SnapContext#createSnapResultsModelManager} to create the {\@link yfiles.view.ICanvasObjectDescriptor}
 * for the {\@link yfiles.input.SnapResult} type.
 * @return {?} An instance that can install {\@link }s in a {\@link }.
 */
yfiles.input.SnapContext.prototype.createSnapResultCanvasObjectDescriptor = function() {};

/**
 * Helper method that creates the a {\@link yfiles.view.CollectionModelManager.<T>} that can be used to present the current {\@link yfiles.input.SnapResult}s in the provided
 * {\@link yfiles.view.CanvasComponent}.
 * @param {!yfiles.view.CanvasComponent} canvas The control to initialize the {\@link } with.
 * @return {!yfiles.view.CollectionModelManager<!yfiles.input.SnapResult>} The model manager that manages the visual representation of the {\@link }s.
 */
yfiles.input.SnapContext.prototype.createSnapResultsModelManager = function(canvas) {};

/**
 * Called when a drag has been successfully finished.
 * <p>
 * Clears all temporary lists and sets {\@link yfiles.input.SnapContext#isInitialized} back to false. Also the {\@link yfiles.input.SnapContext#cleanUp} method is invoked and the
 * {\@link yfiles.input.SnapContext#addCleanedUpListener CleanedUp} event is triggered.
 * </p>
 * @param {!yfiles.geometry.Point} newLocation The current mouse location.
 * @param {boolean} snappingDisabled If set to <code>true</code> snapping is temporarily disabled. This will remove the snap line visualizations and return a {\@link }
 * with the unchanged coordinates and the {\@link #NOT_SNAPPED} {\@link #snapType}.
 * @return {!yfiles.input.SnapState} A {\@link } that specifies the adjusted coordinates and how they have been adjusted. The unchanged
 * coordinates if snapping has been temporarily disabled by setting <code>snappingDisabled</code> to <code>true</code>.
 */
yfiles.input.SnapContext.prototype.dragFinished = function(newLocation, snappingDisabled) {};

/**
 * This method needs to be called by the client {\@link yfiles.input.IInputMode} that {\@link yfiles.input.SnapContext#initializeDrag initialized} this instance after it has
 * performed the actual move operation with the adjusted coordinates after a call to {\@link yfiles.input.SnapContext#handleMove}.
 * <p>
 * Most of the client code implementations will just call this method with the exact values returned by
 * {\@link yfiles.input.SnapContext#handleMove}. This method does not need to be called if snapping has been temporarily disabled by
 * calling {\@link yfiles.input.SnapContext#handleMove} with its <code>snappingDisabled</code> parameter set to <code>true</code>.
 * </p>
 * @param {!yfiles.geometry.Point} mouseLocation The actual mouse location.
 * @param {!yfiles.input.SnapState} finalSnapState The final snap state that contains the location that has been used by the client code for the move and how it has been
 * snapped.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.dragged = function(mouseLocation, finalSnapState) {};

/**
 * Collects a list of snap lines.
 * <p>
 * Snap lines represent possible horizontal or vertical lines to which a moved item can "snap".
 * </p>
 * <p>
 * This method is called at the start of {\@link yfiles.input.MoveInputMode}'s or
 * {\@link yfiles.input.HandleInputMode}'s gesture after all items to be moved or reshaped have been added.
 * </p>
 * @return {void}
 */
yfiles.input.SnapContext.prototype.dragInitialized = function() {};

/**
 * Handles a move.
 * <p>
 * This method returns the adjusted (mouse) coordinates. It also manages the collection of {\@link yfiles.input.SnapResult}s. If
 * snapping should be temporarily (for a mouse move) disabled, <code>snappingDisabled</code> has to be set to <code>true</code>.
 * </p>
 * @param {!yfiles.geometry.Point} newLocation The current mouse location.
 * @param {boolean} snappingDisabled If set to <code>true</code> snapping is temporarily disabled. This will remove the snap line visualizations and return a {\@link }
 * with the unchanged coordinates and the {\@link #snapType} {\@link #NOT_SNAPPED}.
 * @return {!yfiles.input.SnapState} The adjusted coordinates and how they have been adjusted. The unchanged coordinates if snapping has been temporarily
 * disabled by setting <code>snappingDisabled</code> to <code>true</code>.
 */
yfiles.input.SnapContext.prototype.handleMove = function(newLocation, snappingDisabled) {};

/**
 * Called by {\@link yfiles.input.IInputMode} implementations when an interactive drag is started.
 * <p>
 * Updates {\@link yfiles.input.SnapContext#isInitializing}, {\@link yfiles.input.SnapContext#originalLocation}, and {\@link yfiles.input.SnapContext#currentInputModeContext} and then triggers the {\@link yfiles.input.SnapContext#addInitializingListener Initializing} event.
 * </p>
 * @throws {Stubs.Exceptions.InvalidOperationError} If this context is already {\@link yfiles.input.SnapContext#isInitialized initialized}.
 * @param {?} context The context in which the interactive drag is started.
 * @param {!yfiles.geometry.Point} originalLocation The original location of the mouse.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.initializeDrag = function(context, originalLocation) {};

/**
 * Raises the {\@link yfiles.input.SnapContext#cleanUp} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.onCleanUp = function(evt) {};

/**
 * Raises the {\@link yfiles.input.SnapContext#addCollectSnapResultsListener CollectSnapResults} event.
 * @protected
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.onCollectSnapResults = function(evt) {};

/**
 * Raises the {\@link yfiles.input.SnapContext#addInitializedListener Initialized} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.onInitialized = function(evt) {};

/**
 * Raises the {\@link yfiles.input.SnapContext#addInitializingListener Initializing} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.onInitializing = function(evt) {};

/**
 * Chooses the current {\@link yfiles.input.SnapResult}s from a temporary list.
 * <p>
 * Chooses from a list of possible results the most important ones. Also maintains the collection of snap results.
 * </p>
 * @protected
 * @param {!yfiles.collections.List<!yfiles.input.SnapResult>} snapResults A temporary list of suggested {\@link }s.
 * @param {!yfiles.geometry.Point} originalLocation The point in world coordinates where the mouse move started.
 * @param {!yfiles.geometry.Point} newLocation The current mouse location.
 * @return {!yfiles.input.SnapState} The adjusted coordinates and how they have been adjusted.
 */
yfiles.input.SnapContext.prototype.processSnapResults = function(snapResults, originalLocation, newLocation) {};

/**
 * Helper method that wraps the given <code>context</code> so that a {\@link yfiles.graph.ILookup#lookup} query on the wrapped context for the {\@link yfiles.input.SnapContext}
 * type yields this instance.
 * @param {?} context The context to wrap and delegate all calls to.
 * @return {?} A modified instance that yields this instance if it is queried for the {\@link } type.
 */
yfiles.input.SnapContext.prototype.wrapContext = function(context) {};

/**
 * Adds the given listener for the <code>CollectSnapResults</code> event that occurs while {\@link yfiles.input.IDragHandler#handleMove moving} items and handles.
 * <p>
 * The moving model items must register for this event, preferably in the {\@link yfiles.input.IDragHandler#initializeDrag} method
 * of the {\@link yfiles.input.IDragHandler}.
 * </p>
 * <p>
 * The event handler has to add {\@link yfiles.input.SnapResult}s for the moving object to the list. The
 * {\@link yfiles.input.IDragHandler}s of the moved items have to take care themselves whether to add a handler to the list
 * depending on the their settings.
 * </p>
 * @see yfiles.input.SnapContext#removeCollectSnapResultsListener
 * @param {function(!Object, !yfiles.input.CollectSnapResultsEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.addCollectSnapResultsListener = function(listener) {};

/**
 * Removes the given listener for the <code>CollectSnapResults</code> event that occurs while {\@link yfiles.input.IDragHandler#handleMove moving} items and handles.
 * <p>
 * The moving model items must register for this event, preferably in the {\@link yfiles.input.IDragHandler#initializeDrag} method
 * of the {\@link yfiles.input.IDragHandler}.
 * </p>
 * <p>
 * The event handler has to add {\@link yfiles.input.SnapResult}s for the moving object to the list. The
 * {\@link yfiles.input.IDragHandler}s of the moved items have to take care themselves whether to add a handler to the list
 * depending on the their settings.
 * </p>
 * @see yfiles.input.SnapContext#addCollectSnapResultsListener
 * @param {function(!Object, !yfiles.input.CollectSnapResultsEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.removeCollectSnapResultsListener = function(listener) {};

/**
 * Adds the given listener for the <code>CleanedUp</code> event that occurs when this instance has been cleaned up.
 * @see yfiles.input.SnapContext#cleanUp
 * @see yfiles.input.SnapContext#removeCleanedUpListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.addCleanedUpListener = function(listener) {};

/**
 * Removes the given listener for the <code>CleanedUp</code> event that occurs when this instance has been cleaned up.
 * @see yfiles.input.SnapContext#cleanUp
 * @see yfiles.input.SnapContext#addCleanedUpListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.removeCleanedUpListener = function(listener) {};

/**
 * Adds the given listener for the <code>Initialized</code> event that occurs when this instance has been initialized.
 * @see yfiles.input.SnapContext#initializeDrag
 * @see yfiles.input.SnapContext#removeInitializedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.addInitializedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Initialized</code> event that occurs when this instance has been initialized.
 * @see yfiles.input.SnapContext#initializeDrag
 * @see yfiles.input.SnapContext#addInitializedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.removeInitializedListener = function(listener) {};

/**
 * Adds the given listener for the <code>Initializing</code> event that occurs when this instance is about to be initialized.
 * @see yfiles.input.SnapContext#initializeDrag
 * @see yfiles.input.SnapContext#removeInitializingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.addInitializingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Initializing</code> event that occurs when this instance is about to be initialized.
 * @see yfiles.input.SnapContext#initializeDrag
 * @see yfiles.input.SnapContext#addInitializingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.SnapContext.prototype.removeInitializingListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.SnapResult = function() {};
 /** @type {number} */
yfiles.input.SnapResult.prototype.weight;
 /** @type {!Object} */
yfiles.input.SnapResult.prototype.tag;
 /** @type {!yfiles.input.SnapResult} */
yfiles.input.SnapResult.NULL_RESULT;
 /** @type {!yfiles.lang.Class} */
yfiles.input.SnapResult.$class;

/**
 * Factory method that creates a {\@link yfiles.input.SnapResult} to which a {\@link yfiles.graph.ILabel} will snap, based on the given
 * <code>snapLine</code>.
 * @param {?} layoutParameter The {\@link } which represents the position to snap to.
 * @param {number} weight The weight of this result. The higher the weight, the more important it is.
 * @param {!yfiles.geometry.Point} delta The value to add to the mouse coordinates to snap to this result.
 * @param {!Object} tag The tag associated with this result. If more than one result uses the same tag (not <code>null</code>), only the one with the highest
 * {\@link #weight} will be rendered.
 * @param {!yfiles.input.SnapLine} snapLine The snap line this class would snap to or <code>null</code> if it doesn't snap to a <code>SnapLine</code>.
 * @param {!yfiles.geometry.Point} snappedCoordinates The coordinates at the moved item at which the drawn snap line should end.
 * @param {!Object} movedObject The moved object for which this result is created.
 * @return {!yfiles.input.SnapResult}
 */
yfiles.input.SnapResult.createLabelSnapResult = function(layoutParameter, weight, delta, tag, snapLine, snappedCoordinates, movedObject) {};

/**
 * Factory method that creates a {\@link yfiles.input.SnapResult} that snaps to a given location.
 * @param {!yfiles.geometry.Point} location The location to snap to.
 * @param {number} weight The weight to assign to the result.
 * @param {!Object} tag The tag associated with this result. If more than one result uses the same tag (not <code>null</code>), only the one with the highest
 * {\@link #weight} will be rendered.
 * @param {?} visualCreator The visual creator to use.
 * @param {yfiles.input.SnapTypes} snapType The type of the snapping operation to apply.
 * @return {!yfiles.input.SnapResult} A result that snaps to the provided location using the provided mode.
 */
yfiles.input.SnapResult.createPointSnapResult = function(location, weight, tag, visualCreator, snapType) {};

/**
 * Factory method that creates a {\@link yfiles.input.SnapResult} which snaps to a given size through a resize operation.
 * @param {number} weight The weight of this result. The higher the weight, the more important it is.
 * @param {number} delta The value to add to the mouse coordinates to snap to this result.
 * @param {!Object} tag The tag associated with this result. If more than one result uses the same tag (not <code>null</code>), only the one with the highest
 * {\@link #weight} will be rendered.
 * @param {?<?>} rectangles The rectangles that have the same width or height as the node will. The rectangle are used for visualization and should
 * include all objects for which a visualization should be displayed. Typically, these are all objects which have the same
 * size and the object which is currently reshaped.
 * @param {number} size The target size to which the resized object will snap.
 * @param {boolean} horizontal Indicates whether width or height should snap. <code>true</code> if the width should snap.
 * @return {!yfiles.input.SnapResult}
 */
yfiles.input.SnapResult.createResizeSnapResult = function(weight, delta, tag, rectangles, size, horizontal) {};

/**
 * Factory method that creates a {\@link yfiles.input.SnapResult} which represents a {\@link yfiles.input.SnapLine} to which the current
 * moved item will potentially snap.
 * @param {number} weight The weight of this result. The higher the weight, the more important it is.
 * @param {!yfiles.geometry.Point} delta The value to add to the mouse coordinates to snap to this result.
 * @param {!Object} tag The tag associated with this result. If more than one result uses the same tag (not <code>null</code>), only the one with the highest
 * {\@link #weight} will be rendered.
 * @param {!yfiles.input.SnapLine} snapLine The snap line this class would snap to or <code>null</code> if it doesn't snap to a <code>SnapLine</code>.
 * @param {!yfiles.geometry.Point} snappedLocation The coordinates at the moved item at which the drawn snap line should end.
 * @param {!Object} movedObject The moved object for which this result is created.
 * @return {!yfiles.input.SnapResult}
 */
yfiles.input.SnapResult.createSnapLineSnapResult = function(weight, delta, tag, snapLine, snappedLocation, movedObject) {};

/**
 * Returns a {\@link yfiles.view.IVisualCreator} instance that can be used to create a {\@link yfiles.view.Visual} for this result.
 * @see yfiles.view.VoidVisualCreator#INSTANCE
 * @abstract
 * @return {?} A visual creator which creates a {\@link } which depicts this snap result.
 */
yfiles.input.SnapResult.prototype.getVisualCreator = function() {};

/**
 * Checks whether this instance is still snapped given the final mouse location.
 * <p>
 * This implementation simply returns <code>false</code>.
 * </p>
 * @param {!yfiles.geometry.Point} unsnappedLocation The unsnapped location.
 * @param {!yfiles.input.SnapState} finalSnapState The final snap state that has been used by the client.
 * @return {boolean} Whether the location are still snapped for this instance.
 */
yfiles.input.SnapResult.prototype.isSnapped = function(unsnappedLocation, finalSnapState) {};

/**
 * Core method that performs the actual snapping.
 * <p>
 * This implementation does nothing.
 * </p>
 * @param {!yfiles.geometry.Point} unsnappedLocation The location prior to the snapping.
 * @param {!yfiles.input.SnapState} currentSnapState The currently snapped location and the state of the snapping. This instance can be modified by subclasses.
 * @return {void}
 */
yfiles.input.SnapResult.prototype.snap = function(unsnappedLocation, currentSnapState) {};

/** @const */
yfiles.input.SnapTypes = {};
/** @const {number} */
yfiles.input.SnapTypes.SNAPPED_X;
/** @const {number} */
yfiles.input.SnapTypes.SNAPPED_Y;
/** @const {number} */
yfiles.input.SnapTypes.SNAPPED_X_Y;
/** @const {number} */
yfiles.input.SnapTypes.NOT_SNAPPED;
/**
 * @record
 * @struct
 */
yfiles.input.SnapState = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.input.SnapState.prototype.location;
 /** @type {yfiles.input.SnapTypes} */
yfiles.input.SnapState.prototype.snapType;
 /** @type {!yfiles.lang.Class} */
yfiles.input.SnapState.$class;

/**
 * Sets the {\@link yfiles.input.SnapState#location} to the given point and adjusts the {\@link yfiles.input.SnapState#snapType} accordingly.
 * @param {!yfiles.geometry.Point} newLocation The new location.
 * @return {void}
 */
yfiles.input.SnapState.prototype.snapTo = function(newLocation) {};

/**
 * Modifies the X property of the {\@link yfiles.input.SnapState#location} and adjusts the {\@link yfiles.input.SnapState#snapType} accordingly.
 * @param {number} newX The new X.
 * @return {void}
 */
yfiles.input.SnapState.prototype.snapX = function(newX) {};

/**
 * Modifies the Y property of the {\@link yfiles.input.SnapState#location} and adjusts the {\@link yfiles.input.SnapState#snapType} accordingly.
 * @param {number} newY The new Y.
 * @return {void}
 */
yfiles.input.SnapState.prototype.snapY = function(newY) {};
/**
 * @record
 * @struct
 */
yfiles.input.TapEventArgs = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.input.TapEventArgs.prototype.location;
 /** @type {boolean} */
yfiles.input.TapEventArgs.prototype.handled;
 /** @type {!yfiles.lang.Class} */
yfiles.input.TapEventArgs.$class;

/** @const */
yfiles.input.TapHandlingPolicy = {};
/** @const {number} */
yfiles.input.TapHandlingPolicy.DOUBLE_TAP_ONLY;
/** @const {number} */
yfiles.input.TapHandlingPolicy.INITIAL_SINGLE_AND_DOUBLE_TAP;
/** @const {number} */
yfiles.input.TapHandlingPolicy.BOTH_SINGLE_TAPS_AND_DOUBLE_TAP;
/**
 * @record
 * @struct
 */
yfiles.input.TapInputMode = function() {};
 /** @type {number} */
yfiles.input.TapInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.TapInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.TapInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.TapInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.TapInputMode.prototype.controller;
 /** @type {yfiles.input.TapHandlingPolicy} */
yfiles.input.TapInputMode.prototype.tapHandlingPolicy;
 /** @type {?} */
yfiles.input.TapInputMode.prototype.validTapHitTestable;
 /** @type {boolean} */
yfiles.input.TapInputMode.prototype.requestMutexOnTap;
 /** @type {boolean} */
yfiles.input.TapInputMode.prototype.swallowFocusTap;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.TapInputMode.prototype.tapLocation;
 /** @type {!yfiles.lang.Class} */
yfiles.input.TapInputMode.$class;

/**
 * Cancels the editing of this mode.
 * <p>
 * This implementation {\@link yfiles.input.ConcurrencyController#releaseMutex releases} the mutex if it is currently owned by this instance and calls
 * {\@link yfiles.input.TapInputMode#onCanceled}.
 * </p>
 * @see yfiles.input.TapInputMode#onCanceled
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.cancel = function() {};

/**
 * Creates the event recognizer that is used to recognize the press event for this instance.
 * @protected
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean}
 */
yfiles.input.TapInputMode.prototype.createPressRecognizer = function() {};

/**
 * Creates the event recognizer that is used to recognize the release event for this instance.
 * @protected
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean}
 */
yfiles.input.TapInputMode.prototype.createReleaseRecognizer = function() {};

/**
 * Creates the event recognizer that is used to recognize the taps for this instance.
 * @protected
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean}
 */
yfiles.input.TapInputMode.prototype.createTapRecognizer = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link } for this mode.
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.install = function(context, controller) {};

/**
 * Determines whether the given event is a press event that occurred at an invalid location.
 * @see yfiles.input.TapInputMode#validTapHitTestable
 * @protected
 * @param {!Object} eventSource
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean}
 */
yfiles.input.TapInputMode.prototype.isInvalidPress = function(eventSource, evt) {};

/**
 * Determines whether the given event is a valid press event.
 * @protected
 * @param {!Object} eventSource
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean}
 */
yfiles.input.TapInputMode.prototype.isValidPress = function(eventSource, evt) {};

/**
 * Determines whether the given event is a valid release event.
 * @protected
 * @param {!Object} eventSource
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean}
 */
yfiles.input.TapInputMode.prototype.isValidRelease = function(eventSource, evt) {};

/**
 * Determines whether the given event is a valid tap event.
 * @protected
 * @param {!Object} eventSource
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean}
 */
yfiles.input.TapInputMode.prototype.isValidTap = function(eventSource, evt) {};

/**
 * Called after {\@link yfiles.input.TapInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Called once this mode has recognized a double-tap gesture.
 * <p>
 * This method will trigger the {\@link yfiles.input.TapInputMode#addDoubleTappedListener DoubleTapped} event.
 * </p>
 * @protected
 * @param {!yfiles.input.TapEventArgs} evt The arguments.
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.onDoubleTapped = function(evt) {};

/**
 * Called after {\@link yfiles.input.TapInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.onStopped = function() {};

/**
 * Called once this mode has recognized a tap gesture.
 * <p>
 * This method will trigger the {\@link yfiles.input.TapInputMode#addTappedListener Tapped} event.
 * </p>
 * @protected
 * @param {!yfiles.input.TapEventArgs} evt The arguments.
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.onTapped = function(evt) {};

/**
 * Prevents a double-tap event from being issued if the next tap would do so and sends only a single tap instead.
 * <p>
 * The intention is for "breaking" a double tap if an input mode using {\@link yfiles.input.TapInputMode} performs actions that
 * would lead to surprising behavior if the next tap would lead to a double-tap. Examples of this are
 * {\@link yfiles.input.GraphEditorInputMode}'s selection cycling where several taps in short succession may occur, as well as
 * creating a node by tapping on the canvas and selecting it immediately afterwards with another tap.
 * </p>
 * <p>
 * This method's effect is very short-lived. It really only prevents a double-tap event for the very next tap that this
 * input mode handles. The internal flag set by this method is re-set on every tap received. This also means that if you
 * call this method and the next tap is just a regular single-tap the flag is cleared nonetheless.
 * </p>
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.preventNextDoubleTap = function() {};

/**
 * Returns and resets the flag set by {\@link yfiles.input.TapInputMode#preventNextDoubleTap}.
 * <p>
 * To ensure that the flag really acts just once, this method resets the flag and returns its value prior to the reset.
 * </p>
 * @protected
 * @return {boolean}
 */
yfiles.input.TapInputMode.prototype.queryAndResetPreventNextDoubleTap = function() {};

/**
 *
 * @return {boolean}
 */
yfiles.input.TapInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>Tapped</code> event that occurs once a tap has been detected.
 * @see yfiles.input.TapEventArgs
 * @see yfiles.input.TapInputMode#tapHandlingPolicy
 * @see yfiles.input.TapInputMode#removeTappedListener
 * @param {function(!Object, !yfiles.input.TapEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.addTappedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Tapped</code> event that occurs once a tap has been detected.
 * @see yfiles.input.TapEventArgs
 * @see yfiles.input.TapInputMode#tapHandlingPolicy
 * @see yfiles.input.TapInputMode#addTappedListener
 * @param {function(!Object, !yfiles.input.TapEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.removeTappedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DoubleTapped</code> event that occurs once a double-tap has been detected.
 * @see yfiles.input.TapEventArgs
 * @see yfiles.input.TapInputMode#tapHandlingPolicy
 * @see yfiles.input.TapInputMode#removeDoubleTappedListener
 * @param {function(!Object, !yfiles.input.TapEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.addDoubleTappedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DoubleTapped</code> event that occurs once a double-tap has been detected.
 * @see yfiles.input.TapEventArgs
 * @see yfiles.input.TapInputMode#tapHandlingPolicy
 * @see yfiles.input.TapInputMode#addDoubleTappedListener
 * @param {function(!Object, !yfiles.input.TapEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TapInputMode.prototype.removeDoubleTappedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.TextEditorInputMode = function() {};
 /** @type {number} */
yfiles.input.TextEditorInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.TextEditorInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.TextEditorInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.TextEditorInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.TextEditorInputMode.prototype.controller;
 /** @type {boolean} */
yfiles.input.TextEditorInputMode.prototype.autoCommitOnFocusLost;
 /** @type {boolean} */
yfiles.input.TextEditorInputMode.prototype.autoFocusCanvasOnEditorClosed;
 /** @type {boolean} */
yfiles.input.TextEditorInputMode.prototype.autoStartEditing;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TextEditorInputMode.prototype.lineBreakRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TextEditorInputMode.prototype.cancelRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TextEditorInputMode.prototype.stopRecognizer;
 /** @type {boolean} */
yfiles.input.TextEditorInputMode.prototype.editing;
 /** @type {?} */
yfiles.input.TextEditorInputMode.prototype.location;
 /** @type {?} */
yfiles.input.TextEditorInputMode.prototype.upVector;
 /** @type {?} */
yfiles.input.TextEditorInputMode.prototype.anchor;
 /** @type {!HTMLDivElement} */
yfiles.input.TextEditorInputMode.prototype.editorContainer;
 /** @type {string} */
yfiles.input.TextEditorInputMode.prototype.editorText;
 /** @type {boolean} */
yfiles.input.TextEditorInputMode.prototype.autoFlipTextBox;
 /** @type {boolean} */
yfiles.input.TextEditorInputMode.prototype.rotateTextBox;
 /** @type {!yfiles.lang.Class} */
yfiles.input.TextEditorInputMode.$class;

/**
 * Adjusts the position of the text box in the {\@link yfiles.view.CanvasComponent}.
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.adjustPosition = function() {};

/**
 * Adjusts the size of the text box in the {\@link yfiles.input.TextEditorInputMode#editorContainer}.
 * @protected
 * @param {!yfiles.geometry.Size} maxSize The suggested maximum size to use.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.adjustSize = function(maxSize) {};

/**
 * Calculates the maximum size for this instance.
 * <p>
 * The result is passed to {\@link yfiles.input.TextEditorInputMode#adjustSize}.
 * </p>
 * <p>
 * This implementation makes sure the textbox does not exceed the bounds of the canvas.
 * </p>
 * @see yfiles.input.TextEditorInputMode#adjustSize
 * @protected
 * @return {!yfiles.geometry.Size} The maximum size for the textbox.
 */
yfiles.input.TextEditorInputMode.prototype.calculateMaxTextBoxSize = function() {};

/**
 * Cancels editing of the text box.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.cancel = function() {};

/**
 * Resets the contents of the text box.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.clear = function() {};

/**
 * Starts interactive text editing.
 * @return {!Promise<string>} A Promise that will fulfill with the edited text or fulfill with <code>null</code> if editing is cancelled.
 */
yfiles.input.TextEditorInputMode.prototype.edit = function() {};

/**
 * Adjusts the {\@link yfiles.view.CanvasComponent#viewport} of the {\@link yfiles.view.CanvasComponent} such that the text box is in the visible area.
 * <p>
 * Called once when the editing starts.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.ensureVisible = function() {};

/**
 * Returns the bounds of the text area in world coordinates.
 * @protected
 * @return {!yfiles.geometry.Rect}
 */
yfiles.input.TextEditorInputMode.prototype.getTextBoxBounds = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.install = function(context, controller) {};

/**
 * Installs the text box in the canvas and puts focus into it.
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.installTextBox = function() {};

/**
 * Called when editing starts.
 * <p>
 * Requests the input mutex, and installs the text box.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onBeginEditing = function() {};

/**
 * Called after {\@link yfiles.input.TextEditorInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onCanceled = function() {};

/**
 * Called when editing gets canceled.
 * <p>
 * Removes the text box and releases the input mutex.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onCancelEditing = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Raises the {\@link yfiles.input.TextEditorInputMode#addEditingCanceledListener EditingCanceled} event.
 * @protected
 * @param {!yfiles.input.TextEventArgs} evt The event argument
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onEditingCanceled = function(evt) {};

/**
 * Raises the {\@link yfiles.input.TextEditorInputMode#addEditingStartedListener EditingStarted} event.
 * @protected
 * @param {!yfiles.input.TextEventArgs} evt The event argument.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onEditingStarted = function(evt) {};

/**
 * Called when editing is stopped.
 * <p>
 * Triggers the {\@link yfiles.input.TextEditorInputMode#addTextEditedListener TextEdited} event, removes the
 * box and releases the input mutex.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onStopEditing = function() {};

/**
 * Called after {\@link yfiles.input.TextEditorInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onStopped = function() {};

/**
 * Raises the {\@link yfiles.input.TextEditorInputMode#addTextEditedListener TextEdited} event.
 * @protected
 * @param {!yfiles.input.TextEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.onTextEdited = function(evt) {};

/**
 * Stops editing and returns <code>true</code>.
 * @return {boolean} <code>base.Stop()</code>
 */
yfiles.input.TextEditorInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.uninstall = function(context) {};

/**
 * Removes the text box.
 * @protected
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.uninstallTextBox = function() {};

/**
 * Adds the given listener for the <code>TextEdited</code> event that occurs once the text has been edited.
 * @see yfiles.input.TextEditorInputMode#removeTextEditedListener
 * @param {function(!Object, !yfiles.input.TextEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.addTextEditedListener = function(listener) {};

/**
 * Removes the given listener for the <code>TextEdited</code> event that occurs once the text has been edited.
 * @see yfiles.input.TextEditorInputMode#addTextEditedListener
 * @param {function(!Object, !yfiles.input.TextEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.removeTextEditedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EditingCanceled</code> event that occurs if the editing has not been finished.
 * @see yfiles.input.TextEditorInputMode#removeEditingCanceledListener
 * @param {function(!Object, !yfiles.input.TextEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.addEditingCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>EditingCanceled</code> event that occurs if the editing has not been finished.
 * @see yfiles.input.TextEditorInputMode#addEditingCanceledListener
 * @param {function(!Object, !yfiles.input.TextEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.removeEditingCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>EditingStarted</code> event that occurs when text editing is started.
 * @see yfiles.input.TextEditorInputMode#removeEditingStartedListener
 * @param {function(!Object, !yfiles.input.TextEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.addEditingStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EditingStarted</code> event that occurs when text editing is started.
 * @see yfiles.input.TextEditorInputMode#addEditingStartedListener
 * @param {function(!Object, !yfiles.input.TextEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TextEditorInputMode.prototype.removeEditingStartedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.TextEventArgs = function() {};
 /** @type {string} */
yfiles.input.TextEventArgs.prototype.text;
 /** @type {!yfiles.lang.Class} */
yfiles.input.TextEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.WaitInputMode = function() {};
 /** @type {number} */
yfiles.input.WaitInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.WaitInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.WaitInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.WaitInputMode.prototype.controller;
 /** @type {boolean} */
yfiles.input.WaitInputMode.prototype.waiting;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.WaitInputMode.prototype.waitCursor;
 /** @type {!yfiles.lang.Class} */
yfiles.input.WaitInputMode.$class;

/**
 *
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.cancel = function() {};

/**
 * Returns if this mode can request the mutex when {\@link yfiles.input.WaitInputMode#waiting} is set to <code>true</code>.
 * @return {boolean} if this mode can request the mutex when {\@link #waiting} is set to <code>true</code>.
 */
yfiles.input.WaitInputMode.prototype.canStartWaiting = function() {};

/**
 * Called when waiting is finished.
 * <p>
 * This will reset the {\@link yfiles.input.ConcurrencyController#preferredCursor} and {\@link yfiles.input.ConcurrencyController#releaseMutex the mutex is released.}
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.endWaiting = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.install = function(context, controller) {};

/**
 * Called after {\@link yfiles.input.WaitInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Called after {\@link yfiles.input.WaitInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.onStopped = function() {};

/**
 * Raises the {\@link yfiles.input.WaitInputMode#addWaitingEndedListener WaitingEnded} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.onWaitingEnded = function(evt) {};

/**
 * Raises the {\@link yfiles.input.WaitInputMode#addWaitingStartedListener WaitingStarted} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.onWaitingStarted = function(evt) {};

/**
 * This will initiate the waiting process by trying to
 * {\@link yfiles.input.ConcurrencyController#requestMutex}request the input mutex.
 * <p>
 * This will set the {\@link yfiles.input.ConcurrencyController#preferredCursor} to {\@link yfiles.input.WaitInputMode#waitCursor}.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.startWaiting = function() {};

/**
 *
 * @return {boolean}
 */
yfiles.input.WaitInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>WaitingStarted</code> event that occurs when the waiting started.
 * @see yfiles.input.WaitInputMode#removeWaitingStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.addWaitingStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>WaitingStarted</code> event that occurs when the waiting started.
 * @see yfiles.input.WaitInputMode#addWaitingStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.removeWaitingStartedListener = function(listener) {};

/**
 * Adds the given listener for the <code>WaitingEnded</code> event that occurs when the waiting ended.
 * @see yfiles.input.WaitInputMode#removeWaitingEndedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.addWaitingEndedListener = function(listener) {};

/**
 * Removes the given listener for the <code>WaitingEnded</code> event that occurs when the waiting ended.
 * @see yfiles.input.WaitInputMode#addWaitingEndedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.WaitInputMode.prototype.removeWaitingEndedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.ConstrainedPositionHandler = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.input.ConstrainedPositionHandler.$class;
/**
 * @record
 * @struct
 */
yfiles.input.ConstrainedHandle = function() {};
 /** @type {yfiles.input.HandleTypes} */
yfiles.input.ConstrainedHandle.prototype.type;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.ConstrainedHandle.prototype.cursor;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ConstrainedHandle.$class;
/**
 * @record
 * @struct
 */
yfiles.input.ConstrainedReshapeHandler = function() {};
 /** @type {?} */
yfiles.input.ConstrainedReshapeHandler.prototype.wrappedHandler;
 /** @type {?} */
yfiles.input.ConstrainedReshapeHandler.prototype.bounds;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ConstrainedReshapeHandler.$class;

/**
 * Cancels the move operation and calls {\@link yfiles.input.ConstrainedReshapeHandler#onCanceled}
 * @param {?} context The context to retrieve information about the drag from.
 * @param {!yfiles.geometry.Rect} originalBounds The value of the coordinate of the {\@link #bounds} property at the time of {\@link #initializeReshape}.
 * @return {void}
 */
yfiles.input.ConstrainedReshapeHandler.prototype.cancelReshape = function(context, originalBounds) {};

/**
 * Callback that needs to implement the constraints for the new bounds.
 * @protected
 * @abstract
 * @param {?} context The context in which the reshape will be performed.
 * @param {!yfiles.geometry.Rect} originalBounds The value of the {\@link #bounds} property at the time of {\@link #initializeReshape}.
 * @param {!yfiles.geometry.Rect} newBounds The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the
 * implementation the {\@link #bounds} may or may not be modified to reflect the new value.
 * @return {!yfiles.geometry.Rect} The constrained value of <code>newBounds</code>.
 */
yfiles.input.ConstrainedReshapeHandler.prototype.constrainNewBounds = function(context, originalBounds, newBounds) {};

/**
 * Handles the reshape operation and subsequently calls {\@link yfiles.input.ConstrainedReshapeHandler#onReshaped}
 * <p>
 * This method will use the {\@link yfiles.input.ConstrainedReshapeHandler#constrainNewBounds} callback to let subclasses constrain
 * the reshaping.
 * </p>
 * @param {?} context The context in which the reshape will be performed.
 * @param {!yfiles.geometry.Rect} originalBounds The value of the {\@link #bounds} property at the time of {\@link #initializeReshape}.
 * @param {!yfiles.geometry.Rect} newBounds The coordinates in the world coordinate system that the client wants to reshape the item to. Depending on the
 * implementation the {\@link #bounds} may or may not be modified to reflect the new value.
 * @return {void}
 */
yfiles.input.ConstrainedReshapeHandler.prototype.handleReshape = function(context, originalBounds, newBounds) {};

/**
 * Initializes the reshape operation and subsequently calls {\@link yfiles.input.ConstrainedReshapeHandler#onInitialized}
 * @param {?} context The context in which the drag will be performed.
 * @return {void}
 */
yfiles.input.ConstrainedReshapeHandler.prototype.initializeReshape = function(context) {};

/**
 * Called when the {\@link yfiles.input.ConstrainedReshapeHandler#cancelReshape} method has been called.
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} originalBounds The original bounds.
 * @return {void}
 */
yfiles.input.ConstrainedReshapeHandler.prototype.onCanceled = function(context, originalBounds) {};

/**
 * Called when the {\@link yfiles.input.ConstrainedReshapeHandler#reshapeFinished} method has been called.
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} originalBounds The original bounds.
 * @param {!yfiles.geometry.Rect} newBounds The new bounds.
 * @return {void}
 */
yfiles.input.ConstrainedReshapeHandler.prototype.onFinished = function(context, originalBounds, newBounds) {};

/**
 * Called when the {\@link yfiles.input.ConstrainedReshapeHandler#initializeReshape} method has been called.
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} originalBounds The original bounds.
 * @return {void}
 */
yfiles.input.ConstrainedReshapeHandler.prototype.onInitialized = function(context, originalBounds) {};

/**
 * Called when the {\@link yfiles.input.ConstrainedReshapeHandler#handleReshape} operation has been performed.
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} originalBounds The original Bounds.
 * @param {!yfiles.geometry.Rect} newBounds The new Bounds.
 * @return {void}
 */
yfiles.input.ConstrainedReshapeHandler.prototype.onReshaped = function(context, originalBounds, newBounds) {};

/**
 * Handles the finish operation and invokes {\@link yfiles.input.ConstrainedReshapeHandler#onFinished}
 * @param {?} context The context to retrieve information about the drag from.
 * @param {!yfiles.geometry.Rect} originalBounds The value of the {\@link #bounds} property at the time of {\@link #initializeReshape}.
 * @param {!yfiles.geometry.Rect} newBounds The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the
 * implementation the {\@link #bounds} may or may not be modified to reflect the new value. This is the same value as delivered in the last
 * invocation of {\@link #handleReshape}
 * @return {void}
 */
yfiles.input.ConstrainedReshapeHandler.prototype.reshapeFinished = function(context, originalBounds, newBounds) {};
/**
 * @record
 * @struct
 */
yfiles.input.ConstrainedDragHandler = function() {};
 /** @type {TWrapped} */
yfiles.input.ConstrainedDragHandler.prototype.wrappedHandler;
 /** @type {?} */
yfiles.input.ConstrainedDragHandler.prototype.location;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ConstrainedDragHandler.$class;

/**
 * Cancels the move operation and calls {\@link yfiles.input.ConstrainedDragHandler.<TWrapped>#onCanceled}
 * @param {?} context The context to retrieve information about the drag from.
 * @param {!yfiles.geometry.Point} originalLocation The value of the coordinate of the {\@link #location} property at the time of {\@link #initializeDrag}.
 * @return {void}
 */
yfiles.input.ConstrainedDragHandler.prototype.cancelDrag = function(context, originalLocation) {};

/**
 * Callback that needs to implement the constraints for the new location.
 * @protected
 * @abstract
 * @param {?} context The context in which the drag will be performed.
 * @param {!yfiles.geometry.Point} originalLocation The value of the {\@link #location} property at the time of {\@link #initializeDrag}.
 * @param {!yfiles.geometry.Point} newLocation The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the
 * implementation the {\@link #location} may or may not be modified to reflect the new value.
 * @return {!yfiles.geometry.Point} The constrained value of <code>newLocation</code>.
 */
yfiles.input.ConstrainedDragHandler.prototype.constrainNewLocation = function(context, originalLocation, newLocation) {};

/**
 * Handles the finish operation and invokes {\@link yfiles.input.ConstrainedDragHandler.<TWrapped>#onFinished}
 * @param {?} context The context to retrieve information about the drag from.
 * @param {!yfiles.geometry.Point} originalLocation The value of the {\@link #location} property at the time of {\@link #initializeDrag}.
 * @param {!yfiles.geometry.Point} newLocation The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the
 * implementation the {\@link #location} may or may not be modified to reflect the new value. This is the same value as delivered in the last
 * invocation of {\@link #handleMove}
 * @return {void}
 */
yfiles.input.ConstrainedDragHandler.prototype.dragFinished = function(context, originalLocation, newLocation) {};

/**
 * Handles the move operation and subsequently calls {\@link yfiles.input.ConstrainedDragHandler.<TWrapped>#onMoved}
 * <p>
 * This method will use the {\@link yfiles.input.ConstrainedDragHandler.<TWrapped>#constrainNewLocation} callback to let subclasses constrain the movement.
 * </p>
 * @param {?} context The context in which the drag will be performed.
 * @param {!yfiles.geometry.Point} originalLocation The value of the {\@link #location} property at the time of {\@link #initializeDrag}.
 * @param {!yfiles.geometry.Point} newLocation The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the
 * implementation the {\@link #location} may or may not be modified to reflect the new value.
 * @return {void}
 */
yfiles.input.ConstrainedDragHandler.prototype.handleMove = function(context, originalLocation, newLocation) {};

/**
 * Initializes the drag operation and subsequently calls {\@link yfiles.input.ConstrainedDragHandler.<TWrapped>#onInitialized}
 * @param {?} context The context in which the drag will be performed.
 * @return {void}
 */
yfiles.input.ConstrainedDragHandler.prototype.initializeDrag = function(context) {};

/**
 * Called when the {\@link yfiles.input.ConstrainedDragHandler.<TWrapped>#cancelDrag} method has been called.
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Point} originalLocation The original location.
 * @return {void}
 */
yfiles.input.ConstrainedDragHandler.prototype.onCanceled = function(context, originalLocation) {};

/**
 * Called when the {\@link yfiles.input.ConstrainedDragHandler.<TWrapped>#dragFinished} method has been called.
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Point} originalLocation The original location.
 * @param {!yfiles.geometry.Point} newLocation The new location.
 * @return {void}
 */
yfiles.input.ConstrainedDragHandler.prototype.onFinished = function(context, originalLocation, newLocation) {};

/**
 * Called when the {\@link yfiles.input.ConstrainedDragHandler.<TWrapped>#initializeDrag} method has been called.
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Point} originalLocation The original location.
 * @return {void}
 */
yfiles.input.ConstrainedDragHandler.prototype.onInitialized = function(context, originalLocation) {};

/**
 * Called when the {\@link yfiles.input.ConstrainedDragHandler.<TWrapped>#handleMove} operation has been performed.
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Point} originalLocation The original location.
 * @param {!yfiles.geometry.Point} newLocation The new location.
 * @return {void}
 */
yfiles.input.ConstrainedDragHandler.prototype.onMoved = function(context, originalLocation, newLocation) {};
/**
 * @record
 * @struct
 */
yfiles.input.IHitTestable = function() {};

/**
 * Determines if something has been hit at the given coordinates in the world coordinate system.
 * <p>
 * Implementations should inspect the {\@link yfiles.view.ICanvasContext#hitTestRadius} and take the value into account when performing hit tests. This allows the user to
 * hit elements even if the zoom level is very small and allows for accurate hit tests at greater zoom levels.
 * </p>
 * @abstract
 * @param {?} context the context the hit test is performed in
 * @param {!yfiles.geometry.Point} location the coordinates in world coordinate system
 * @return {boolean} whether something has been hit
 */
yfiles.input.IHitTestable.prototype.isHit = function(context, location) {};
 /** @type {{create: function(function(?, !yfiles.geometry.Point): boolean): ?, NEVER: ?, ALWAYS: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IHitTestable;
/**
 * @record
 * @struct
 */
yfiles.input.IMarqueeTestable = function() {};

/**
 * This callback returns <code>true</code> if the corresponding item is considered to intersect the given rectangular box.
 * <p>
 * This method may return <code>false</code> if the item cannot be selected using a selection marquee or optionally if the item is only
 * partially contained within the box.
 * </p>
 * <p>
 * Implementations should respect the {\@link yfiles.view.ICanvasContext#hitTestRadius} if marquee selections should behave differently on different zoom levels.
 * </p>
 * @abstract
 * @param {?} context the current input mode context
 * @param {!yfiles.geometry.Rect} rectangle the box describing the marquee's bounds
 * @return {boolean} <code>true</code> if the item is considered to be captured by the marquee
 */
yfiles.input.IMarqueeTestable.prototype.isInBox = function(context, rectangle) {};
 /** @type {{ALWAYS: ?, NEVER: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IMarqueeTestable;
/**
 * @record
 * @struct
 */
yfiles.input.RectangleHandle = function() {};
 /** @type {yfiles.input.HandlePositions} */
yfiles.input.RectangleHandle.prototype.position;
 /** @type {?} */
yfiles.input.RectangleHandle.prototype.rectangle;
 /** @type {?} */
yfiles.input.RectangleHandle.prototype.minimumSize;
 /** @type {?} */
yfiles.input.RectangleHandle.prototype.minimumEnclosedArea;
 /** @type {?} */
yfiles.input.RectangleHandle.prototype.maximumSize;
 /** @type {?} */
yfiles.input.RectangleHandle.prototype.location;
 /** @type {yfiles.input.HandleTypes} */
yfiles.input.RectangleHandle.prototype.type;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.RectangleHandle.prototype.cursor;
 /** @type {number} */
yfiles.input.RectangleHandle.prototype.x;
 /** @type {number} */
yfiles.input.RectangleHandle.prototype.y;
 /** @type {!yfiles.lang.Class} */
yfiles.input.RectangleHandle.$class;

/**
 * Delegates the original values to {\@link yfiles.input.RectangleHandle#set}
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @return {void}
 */
yfiles.input.RectangleHandle.prototype.cancelDrag = function(context, originalLocation) {};

/**
 * This implementation does nothing.
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.RectangleHandle.prototype.dragFinished = function(context, originalLocation, newLocation) {};

/**
 * Delegates to {\@link yfiles.input.RectangleHandle#set}.
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.RectangleHandle.prototype.handleMove = function(context, originalLocation, newLocation) {};

/**
 * This implementation does nothing.
 * @param {?} context
 * @return {void}
 */
yfiles.input.RectangleHandle.prototype.initializeDrag = function(context) {};

/**
 * Delegates the work to the reshapeable.
 * @param {!yfiles.geometry.Point} delta
 * @return {void}
 */
yfiles.input.RectangleHandle.prototype.moveBy = function(delta) {};

/**
 * Delegates to {\@link yfiles.input.RectangleHandle#moveBy}.
 * @param {number} x
 * @param {number} y
 * @return {void}
 */
yfiles.input.RectangleHandle.prototype.set = function(x, y) {};
/**
 * @record
 * @struct
 */
yfiles.input.ReshapeHandlerHandle = function() {};
 /** @type {?} */
yfiles.input.ReshapeHandlerHandle.prototype.reshapeHandler;
 /** @type {?} */
yfiles.input.ReshapeHandlerHandle.prototype.minimumSize;
 /** @type {?} */
yfiles.input.ReshapeHandlerHandle.prototype.minimumEnclosedArea;
 /** @type {?} */
yfiles.input.ReshapeHandlerHandle.prototype.maximumSize;
 /** @type {?} */
yfiles.input.ReshapeHandlerHandle.prototype.location;
 /** @type {yfiles.input.HandleTypes} */
yfiles.input.ReshapeHandlerHandle.prototype.type;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.ReshapeHandlerHandle.prototype.cursor;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ReshapeHandlerHandle.$class;

/**
 * Delegates the cancel request to the {\@link yfiles.input.IReshapeHandler}.
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @return {void}
 */
yfiles.input.ReshapeHandlerHandle.prototype.cancelDrag = function(context, originalLocation) {};

/**
 * Delegates the finish request to the {\@link yfiles.input.IReshapeHandler}.
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.ReshapeHandlerHandle.prototype.dragFinished = function(context, originalLocation, newLocation) {};

/**
 * Delegates the move request to the {\@link yfiles.input.IReshapeHandler#handleReshape} method.
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.ReshapeHandlerHandle.prototype.handleMove = function(context, originalLocation, newLocation) {};

/**
 * This implementation does nothing.
 * @param {?} context
 * @return {void}
 */
yfiles.input.ReshapeHandlerHandle.prototype.initializeDrag = function(context) {};
/**
 * @record
 * @struct
 */
yfiles.input.CollectGraphSnapLinesEventArgs = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.input.CollectGraphSnapLinesEventArgs.$class;

/**
 * Adds a snap line all elements will snap to.
 * @see yfiles.input.GraphSnapContext#additionalSnapLines
 * @param {!yfiles.input.OrthogonalSnapLine} snapLine The snap line to add to the list of lines that all elements snap to by default.
 * @return {void}
 */
yfiles.input.CollectGraphSnapLinesEventArgs.prototype.addAdditionalSnapLine = function(snapLine) {};

/**
 * Adds a snap line for nodes.
 * @see yfiles.input.GraphSnapContext#fixedNodeSnapLines
 * @param {!yfiles.input.OrthogonalSnapLine} snapLine The snap line to add to the list of lines that nodes snap to by default.
 * @return {void}
 */
yfiles.input.CollectGraphSnapLinesEventArgs.prototype.addFixedNodeSnapLine = function(snapLine) {};

/**
 * Adds a snap line for edge segments and bends.
 * @see yfiles.input.GraphSnapContext#fixedSegmentSnapLines
 * @param {!yfiles.input.OrthogonalSnapLine} snapLine The snap line to add to the list of lines that segments snap to by default.
 * @return {void}
 */
yfiles.input.CollectGraphSnapLinesEventArgs.prototype.addFixedSegmentSnapLine = function(snapLine) {};

/**
 * Adds a snap line for ports.
 * @see yfiles.input.GraphSnapContext#fixedPortSnapLines
 * @param {!yfiles.input.OrthogonalSnapLine} snapLine The snap line to add to the list of lines that ports snap to by default.
 * @return {void}
 */
yfiles.input.CollectGraphSnapLinesEventArgs.prototype.addPortSnapLine = function(snapLine) {};
/**
 * @record
 * @struct
 */
yfiles.input.GraphInputMode = function() {};
 /** @type {?} */
yfiles.input.GraphInputMode.prototype.graph;
 /** @type {?} */
yfiles.input.GraphInputMode.prototype.graphSelection;
 /** @type {!Array<yfiles.graph.GraphItemTypes>} */
yfiles.input.GraphInputMode.prototype.clickHitTestOrder;
 /** @type {!Array<yfiles.graph.GraphItemTypes>} */
yfiles.input.GraphInputMode.prototype.doubleClickHitTestOrder;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.GraphInputMode.prototype.detailSelectionRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.GraphInputMode.prototype.cyclicSelectionRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.GraphInputMode.prototype.multiSelectionRecognizer;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphInputMode.prototype.clickableItems;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphInputMode.prototype.focusableItems;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphInputMode.prototype.selectableItems;
 /** @type {function(?): boolean} */
yfiles.input.GraphInputMode.prototype.selectablePredicate;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphInputMode.prototype.clickSelectableItems;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphInputMode.prototype.marqueeSelectableItems;
 /** @type {boolean} */
yfiles.input.GraphInputMode.prototype.ignoreVoidStyles;
 /** @type {!yfiles.input.ContextMenuInputMode} */
yfiles.input.GraphInputMode.prototype.contextMenuInputMode;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphInputMode.prototype.contextMenuItems;
 /** @type {!yfiles.input.MouseHoverInputMode} */
yfiles.input.GraphInputMode.prototype.mouseHoverInputMode;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphInputMode.prototype.toolTipItems;
 /** @type {!yfiles.input.ClickInputMode} */
yfiles.input.GraphInputMode.prototype.clickInputMode;
 /** @type {!yfiles.input.TapInputMode} */
yfiles.input.GraphInputMode.prototype.tapInputMode;
 /** @type {!yfiles.input.MarqueeSelectionInputMode} */
yfiles.input.GraphInputMode.prototype.marqueeSelectionInputMode;
 /** @type {!yfiles.input.NavigationInputMode} */
yfiles.input.GraphInputMode.prototype.navigationInputMode;
 /** @type {!yfiles.input.WaitInputMode} */
yfiles.input.GraphInputMode.prototype.waitInputMode;
 /** @type {!yfiles.input.ItemHoverInputMode} */
yfiles.input.GraphInputMode.prototype.itemHoverInputMode;
 /** @type {!yfiles.input.MoveViewportInputMode} */
yfiles.input.GraphInputMode.prototype.moveViewportInputMode;
 /** @type {!yfiles.input.KeyboardInputMode} */
yfiles.input.GraphInputMode.prototype.keyboardInputMode;
 /** @type {?<?>} */
yfiles.input.GraphInputMode.prototype.availableCommands;
 /** @type {boolean} */
yfiles.input.GraphInputMode.prototype.allowClipboardOperations;
 /** @type {!yfiles.lang.Class} */
yfiles.input.GraphInputMode.$class;

/**
 * Clears the selection on the current {\@link yfiles.input.GraphInputMode#graphSelection}.
 * <p>
 * This implementation may be overridden for customizations. All it does is call {\@link yfiles.view.ISelectionModel.<T>#clear}.
 * </p>
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.clearSelection = function() {};

/**
 * Actually performs the click on the given item.
 * <p>
 * This will raise the {\@link yfiles.input.GraphInputMode#addItemLeftClickedListener ItemLeftClicked}, {\@link yfiles.input.GraphInputMode#addItemRightClickedListener ItemRightClicked}
 * (depending on the button), and {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked} events. If
 * either event is unhandled by all its event handlers the item will be {\@link yfiles.input.GraphInputMode#setSelected selected} and {\@link yfiles.input.GraphInputMode#setCurrentItem focused}. Before selection
 * {\@link yfiles.input.GraphInputMode#clearSelection the current selection will be cleared}, unless the {\@link yfiles.input.GraphInputMode#multiSelectionRecognizer} is triggered.
 * </p>
 * @protected
 * @param {?} item The item that has been clicked.
 * @param {!yfiles.input.ClickEventArgs} evt The original event arguments for the click. Setting its {\@link #handled} property to <code>true</code> will indicate that the click was handled. By
 * default this happens when the clicked item is either selected or focused.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.click = function(item, evt) {};

/**
 * Clears the selection on click if {\@link yfiles.view.CanvasComponent#lastMouseEvent the click} is not recognized by {\@link yfiles.input.GraphInputMode#multiSelectionRecognizer}.
 * <p>
 * This method is only called if no item has been hit and at least one item is currently selected.
 * </p>
 * <p>
 * This will use the {\@link yfiles.input.GraphInputMode#clearSelection} method to deselect all items.
 * </p>
 * @protected
 * @param {?} context The context where the click appeared
 * @return {boolean} Whether the selection has been cleared by this method.
 */
yfiles.input.GraphInputMode.prototype.clickClearSelection = function(context) {};

/**
 * Copies the currently selected elements to the clipboard.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.copy = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphInputMode#clickInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphInputMode#clickInputMode} property.
 * </p>
 * <p>
 * This implementation {\@link yfiles.input.ClickInputMode#activeButtons activates} both {\@link yfiles.view.MouseButtons#LEFT} and {\@link yfiles.view.MouseButtons#RIGHT}
 * </p>
 * @protected
 * @return {!yfiles.input.ClickInputMode} a new instance of ClickInputMode
 */
yfiles.input.GraphInputMode.prototype.createClickInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphInputMode#contextMenuInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphInputMode#contextMenuInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.ContextMenuInputMode} a new instance of ContextMenuInputMode
 */
yfiles.input.GraphInputMode.prototype.createContextMenuInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphInputMode#itemHoverInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphInputMode#itemHoverInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.ItemHoverInputMode} a new instance of {\@link #itemHoverInputMode} with the {\@link #hoverItems} property set to {\@link #NONE}.
 */
yfiles.input.GraphInputMode.prototype.createItemHoverInputMode = function() {};

/**
 * Factory method that creates the {\@link yfiles.input.GraphInputMode#keyboardInputMode} instance.
 * @protected
 * @return {!yfiles.input.KeyboardInputMode}
 */
yfiles.input.GraphInputMode.prototype.createKeyboardInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphInputMode#marqueeSelectionInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphInputMode#marqueeSelectionInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.MarqueeSelectionInputMode} a new instance of MarqueeSelectionInputMode
 */
yfiles.input.GraphInputMode.prototype.createMarqueeSelectionInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.MouseHoverInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.MouseHoverInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.MouseHoverInputMode} a new instance of {\@link }
 */
yfiles.input.GraphInputMode.prototype.createMouseHoverInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphInputMode#moveViewportInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphInputMode#moveViewportInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.MoveViewportInputMode} a new instance of {\@link #moveViewportInputMode}
 */
yfiles.input.GraphInputMode.prototype.createMoveViewportInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphInputMode#navigationInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphInputMode#navigationInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.NavigationInputMode} a new instance of NavigationInputMode
 */
yfiles.input.GraphInputMode.prototype.createNavigationInputMode = function() {};

/**
 * Helper method that yields a suitably configured {\@link yfiles.input.SelectionEventArgs.<T>} using the {\@link yfiles.input.GraphInputMode#graphSelection} for this input mode.
 * @protected
 * @param {?} context An input mode context that is available in the {\@link }.
 * <p>
 * Can be <code>null</code> in which case a new context for this instance is created automatically.
 * </p>
 * @return {!yfiles.input.SelectionEventArgs<?>} A selection event argument that is configured for this instance.
 */
yfiles.input.GraphInputMode.prototype.createSelectionEventArgs = function(context) {};

/**
 * Factory method for the {\@link yfiles.input.GraphInputMode#tapInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphInputMode#tapInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.TapInputMode} a new instance of TapInputMode
 */
yfiles.input.GraphInputMode.prototype.createTapInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphInputMode#waitInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphInputMode#waitInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.WaitInputMode} a new instance of {\@link #waitInputMode}
 */
yfiles.input.GraphInputMode.prototype.createWaitInputMode = function() {};

/**
 * Actually performs a double-click on the given item.
 * <p>
 * This will raise the {\@link yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener ItemLeftDoubleClicked} and {\@link yfiles.input.GraphInputMode#addItemRightDoubleClickedListener ItemRightDoubleClicked}
 * (depending on the button), and {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked}
 * events.
 * </p>
 * @protected
 * @param {?} item The item that has been double-clicked.
 * @param {!yfiles.input.ClickEventArgs} evt The original event arguments for the click. Setting its {\@link #handled} property to <code>true</code> will indicate that the double-click was
 * handled and events on other items in the same location are no longer raised.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.doubleClick = function(item, evt) {};

/**
 * Actually performs a double-tap on the given item.
 * <p>
 * This will raise the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked} event.
 * </p>
 * @protected
 * @param {?} item The item that has been double-tapped.
 * @param {!yfiles.input.TapEventArgs} evt The original event arguments for the tap. Setting its {\@link #handled} property to <code>true</code> will indicate that the double-tap was handled
 * and events on other items in the same location are no longer raised.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.doubleTap = function(item, evt) {};

/**
 * Used as a callback to find the items hit underneath a certain point.
 * <p>
 * This implementation uses the {\@link yfiles.input.GraphEditorInputMode#hitTester} to determine the hit items.
 * </p>
 * Used as a callback to find the items hit underneath a certain point.
 * <p>
 * This implementation uses the {\@link yfiles.input.GraphEditorInputMode#hitTester} to determine the hit items.
 * </p>
 * @param {?|!yfiles.geometry.Point} context_or_location The context to use for to the {\@link #isHit} callback. / The location to test.
 * @param {!yfiles.geometry.Point|!Array<yfiles.graph.GraphItemTypes>} location_or_tests The location to test. / An array of {\@link } values that encode for which model items the hit test should be performed for
 * prioritizing.
 * @param {!Array<yfiles.graph.GraphItemTypes>|function(?): boolean=} tests_or_filter An array of {\@link } values that encode for which model items the hit test should be performed for
 * prioritizing.
 * @param {function(?): boolean=} filter
 * @return {?<?>} An enumerable over the items that have been found for the location.
 */
yfiles.input.GraphInputMode.prototype.findItems = function(context_or_location, location_or_tests, tests_or_filter, filter) {};

/**
 * Called by {\@link yfiles.input.GraphInputMode#click} to query the <code>item</code> for an {\@link yfiles.input.IClickListener} in its {\@link yfiles.graph.ILookup#lookup}
 * and handle it appropriately.
 * <p>
 * This method will query the {\@link yfiles.input.IClickListener} and check whether it was {\@link yfiles.input.IClickListener#getHitTestable hit} by the click, and if so, will invoke
 * {\@link yfiles.input.IClickListener#onClicked} and return <code>true</code>.
 * </p>
 * @see yfiles.input.IClickListener
 * @see yfiles.input.GraphInputMode#click
 * @protected
 * @param {?} context The context for the click.
 * @param {?} item The item that has been clicked.
 * @param {!yfiles.geometry.Point} location The click location.
 * @return {boolean} Whether the action has been invoked and handling should be stopped.
 */
yfiles.input.GraphInputMode.prototype.handleClickListener = function(context, item, location) {};

/**
 * Performs marquee-selection with the given rectangle.
 * <p>
 * It delegates directly to the {\@link yfiles.input.GraphInputMode#onMarqueeSelect} overload internally.
 * </p>
 * @param {!yfiles.geometry.Rect} marqueeRectangle The selection rectangle.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.marqueeSelect = function(marqueeRectangle) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addCanvasClickedListener CanvasClicked} event.
 * <p>
 * This implementation will stop the event propagation as soon as an event handler has set the {\@link yfiles.input.ClickEventArgs#handled} property to <code>true</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.ClickEventArgs} evt The {\@link } instance that contains the information about the click.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onCanvasClicked = function(evt) {};

/**
 * Called when the {\@link yfiles.input.GraphInputMode#clickInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.ClickInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.ClickInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onClickInputModeChanged = function(oldMode, newMode) {};

/**
 * Called when the {\@link yfiles.input.ContextMenuInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.ContextMenuInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.ContextMenuInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onContextMenuInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked} event.
 * <p>
 * This implementation will stop the event propagation as soon as an event handler has set the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.ItemClickedEventArgs<?>} evt The {\@link } instance that contains the item that has been clicked.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onItemClicked = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked} event.
 * <p>
 * This implementation will stop the event propagation as soon as an event handler has set the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.ItemClickedEventArgs<?>} evt The {\@link } instance that contains the item that has been double clicked.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onItemDoubleClicked = function(evt) {};

/**
 * Called when the {\@link yfiles.input.GraphInputMode#itemHoverInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.ItemHoverInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.ItemHoverInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onItemHoverInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addItemLeftClickedListener ItemLeftClicked} event.
 * <p>
 * This implementation will stop the event propagation as soon as an event handler has set the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.ItemClickedEventArgs<?>} evt The {\@link } instance that contains the item that has been clicked.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onItemLeftClicked = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener ItemLeftDoubleClicked} event.
 * <p>
 * This implementation will stop the event propagation as soon as an event handler has set the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.ItemClickedEventArgs<?>} evt The {\@link } instance that contains the item that has been double clicked.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onItemLeftDoubleClicked = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addItemRightClickedListener ItemRightClicked} event.
 * <p>
 * This implementation will stop the event propagation as soon as an event handler has set the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.ItemClickedEventArgs<?>} evt The {\@link } instance that contains the item that has been clicked.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onItemRightClicked = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addItemRightDoubleClickedListener ItemRightDoubleClicked} event.
 * <p>
 * This implementation will stop the event propagation as soon as an event handler has set the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.ItemClickedEventArgs<?>} evt The {\@link } instance that contains the item that has been double clicked.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onItemRightDoubleClicked = function(evt) {};

/**
 * Called when the {\@link yfiles.input.GraphInputMode#keyboardInputMode} changed.
 * @protected
 * @param {!yfiles.input.KeyboardInputMode} oldMode The old {\@link #keyboardInputMode}.
 * @param {!yfiles.input.KeyboardInputMode} newMode The new {\@link #keyboardInputMode}.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onKeyboardInputModeChanged = function(oldMode, newMode) {};

/**
 * Performs marquee-selection with the given rectangle.
 * <p>
 * This method is called internally when either the {\@link yfiles.input.GraphInputMode#marqueeSelect} method is called or the user
 * performs a marquee-selection gesture via {\@link yfiles.input.GraphInputMode#marqueeSelectionInputMode}.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} marqueeRectangle The selection rectangle.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onMarqueeSelect = function(context, marqueeRectangle) {};

/**
 * Called when the {\@link yfiles.input.GraphInputMode#marqueeSelectionInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.MarqueeSelectionInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.MarqueeSelectionInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onMarqueeSelectionInputModeChanged = function(oldMode, newMode) {};

/**
 * Selects the given elements in the editor inside the provided marquee-selection rectangle.
 * <p>
 * This implementation iterates over the items and queries them for an implementation of {\@link yfiles.input.IMarqueeTestable}
 * using their {\@link yfiles.graph.ILookup#lookup}. This instance will be used to determine whether the item should be selected.
 * </p>
 * <p>
 * This method is, in the default implementation, only called with individual item types in <code>items</code>.
 * </p>
 * @see yfiles.input.GraphInputMode#setSelected
 * @see yfiles.input.GraphInputMode#onMarqueeSelect
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} marqueeRectangle The rectangle in world coordinates.
 * @param {?<?>} items The items to iterate over.
 * @param {function(?): boolean} predicate The predicate that determines whether the provided item should be tested at all. May be <code>null</code>.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onMarqueeSelectItems = function(context, marqueeRectangle, items, predicate) {};

/**
 * Called when the {\@link yfiles.input.MouseHoverInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.MouseHoverInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.MouseHoverInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onMouseHoverInputModeChanged = function(oldMode, newMode) {};

/**
 * Called when the {\@link yfiles.input.GraphInputMode#moveViewportInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.MoveViewportInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.MoveViewportInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onMoveViewportInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addMultiSelectionFinishedListener MultiSelectionFinished} event.
 * @protected
 * @param {!yfiles.input.SelectionEventArgs<?>} evt
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onMultiSelectionFinished = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addMultiSelectionStartedListener MultiSelectionStarted} event.
 * @protected
 * @param {!yfiles.input.SelectionEventArgs<?>} evt
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onMultiSelectionStarted = function(evt) {};

/**
 * Called when the {\@link yfiles.input.GraphInputMode#navigationInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.NavigationInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.NavigationInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onNavigationInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addPopulateItemContextMenuListener PopulateItemContextMenu} event.
 * @protected
 * @param {!yfiles.input.PopulateItemContextMenuEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onPopulateItemContextMenu = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphInputMode#addQueryItemToolTipListener QueryItemToolTip} event.
 * @protected
 * @param {!yfiles.input.QueryItemToolTipEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onQueryItemToolTip = function(evt) {};

/**
 * Called when the {\@link yfiles.input.GraphInputMode#tapInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.TapInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.TapInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onTapInputModeChanged = function(oldMode, newMode) {};

/**
 * Called when the {\@link yfiles.input.GraphInputMode#waitInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.WaitInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.WaitInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.onWaitInputModeChanged = function(oldMode, newMode) {};

/**
 * Clears the current selection and selects all nodes and bends in this graph.
 * <p>
 * By default, this method will be called in response to a Ctrl+A key press recognized by {\@link yfiles.input.GraphInputMode#keyboardInputMode}.
 * </p>
 * @see yfiles.input.GraphInputMode#clearSelection
 * @see yfiles.input.GraphInputMode#setSelected
 * @see yfiles.input.ICommand#SELECT_ALL
 * @see yfiles.input.GraphInputMode#selectableItems
 * @see yfiles.input.GraphInputMode#ignoreVoidStyles
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.selectAll = function() {};

/**
 * Callback that is used by this instance to set the current item on the {\@link yfiles.input.NavigationInputMode#setCurrentItem NavigationInputMode}
 * @param {?} item The item to set as the new "current" item.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.setCurrentItem = function(item) {};

/**
 * Uses the {\@link yfiles.input.GraphInputMode#graphSelection} to select the given item.
 * @param {?} item The item to set the selection state on.
 * @param {boolean} selected The new selection state.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.setSelected = function(item, selected) {};

/**
 * Callback predicate method that is used to determine whether the given <code>item</code> can be {\@link yfiles.input.GraphInputMode#click clicked}.
 * <p>
 * This implementation uses the {\@link yfiles.input.GraphInputMode#clickableItems} value to determine whether the item should be clicked. Note that this method will not be
 * called for items that don't match {\@link yfiles.input.GraphInputMode#clickableItems} for performance reasons.
 * </p>
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} Whether the item should be {\@link #click clicked} in response to a detected mouse click.
 */
yfiles.input.GraphInputMode.prototype.shouldClick = function(item) {};

/**
 * Callback predicate method that is used to determine whether the given <code>item</code> should be selected when
 * {\@link yfiles.input.GraphInputMode#click clicked with the primary mouse button}.
 * <p>
 * This implementation uses the {\@link yfiles.input.GraphInputMode#clickSelectableItems} value to determine whether the item should be selected. Note that this method will not be
 * called for items that don't match {\@link yfiles.input.GraphInputMode#clickSelectableItems} and {\@link yfiles.input.GraphInputMode#selectableItems} for performance reasons.
 * </p>
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} Whether the item should be selected in response to a detected mouse click with the primary button.
 */
yfiles.input.GraphInputMode.prototype.shouldClickSelect = function(item) {};

/**
 * Callback predicate method that is used to determine whether the given <code>item</code> can be {\@link yfiles.input.GraphInputMode#doubleClick double clicked}.
 * <p>
 * This implementation uses the {\@link yfiles.input.GraphInputMode#shouldClick} method to determine whether the item should be
 * double clicked. Note that this method will not be called for items that don't match {\@link yfiles.input.GraphInputMode#clickableItems} for performance reasons.
 * </p>
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} Whether the item should be {\@link #doubleClick double clicked} in response to a detected mouse click.
 */
yfiles.input.GraphInputMode.prototype.shouldDoubleClick = function(item) {};

/**
 * Callback that determines whether the provided {\@link yfiles.graph.IModelItem} should be {\@link yfiles.input.GraphInputMode#setCurrentItem set to the current item}.
 * <p>
 * This implementation uses the {\@link yfiles.input.GraphInputMode#focusableItems} property to determine whether the item can be set to the current item. It also honors the
 * {\@link yfiles.input.GraphInputMode#ignoreVoidStyles} property.
 * </p>
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} Whether to set the item as the current item.
 */
yfiles.input.GraphInputMode.prototype.shouldFocus = function(item) {};

/**
 * Callback method that is used to determine which of the built-in {\@link yfiles.input.ICommand}s to install.
 * <p>
 * This implementation unconditionally returns <code>true</code>, subclasses may override this method to adjust the behavior.
 * </p>
 * @protected
 * @param {?} command The command to install.
 * @return {boolean} Whether to install this command.
 */
yfiles.input.GraphInputMode.prototype.shouldInstallCommand = function(command) {};

/**
 * Callback method used by {\@link yfiles.input.GraphInputMode#marqueeSelect} that takes {\@link yfiles.input.GraphInputMode#marqueeSelectableItems} and {\@link yfiles.input.GraphInputMode#shouldSelectItem}
 * into account.
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} Whether to possibly marquee select the item.
 */
yfiles.input.GraphInputMode.prototype.shouldMarqueeSelect = function(item) {};

/**
 * Determines whether for the given item a context menu should be queried.
 * <p>
 * This implementation uses the {\@link yfiles.input.GraphInputMode#contextMenuItems} property to determine whether a context menu should be queried for the given item.
 * </p>
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} Whether to raise a {\@link #addPopulateItemContextMenuListener PopulateItemContextMenu} event for
 * the given item.
 */
yfiles.input.GraphInputMode.prototype.shouldPopulateContextMenu = function(item) {};

/**
 * Determines whether for the given item a tool tip should be queried.
 * <p>
 * This implementation uses the {\@link yfiles.input.GraphInputMode#toolTipItems} property to determine whether tool tip should be queried for the given item.
 * </p>
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} Whether to raise a {\@link #addQueryItemToolTipListener QueryItemToolTip} event for the
 * given item.
 */
yfiles.input.GraphInputMode.prototype.shouldQueryToolTip = function(item) {};

/**
 * Callback predicate method that is used as a broad classification whether an item can generally be selected.
 * <p>
 * This implementation uses and honors the {\@link yfiles.input.GraphInputMode#selectableItems}, {\@link yfiles.input.GraphInputMode#ignoreVoidStyles} and {\@link yfiles.input.GraphInputMode#selectablePredicate} properties. This method is by default also called by {\@link yfiles.input.GraphInputMode#shouldClickSelect}
 * and {\@link yfiles.input.GraphInputMode#shouldMarqueeSelect}, so turning selection off here also turns it off in other places.
 * </p>
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} <code>true</code> if the item is selectable in general, <code>false</code> if not.
 */
yfiles.input.GraphInputMode.prototype.shouldSelectItem = function(item) {};

/**
 * Actually performs the tap on the given item.
 * <p>
 * This will raise the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked} event. If the event
 * is unhandled by all its event handlers the item will be {\@link yfiles.input.GraphInputMode#setSelected selected} and {\@link yfiles.input.GraphInputMode#setCurrentItem focused}. Before selection
 * {\@link yfiles.input.GraphInputMode#clearSelection the current selection will be cleared}.
 * </p>
 * @protected
 * @param {?} item The item that has been tapped.
 * @param {!yfiles.input.TapEventArgs} evt The original event arguments for the tap. Setting its {\@link #handled} property to <code>true</code> will indicate that the tap was handled. By
 * default this happens when the tapped item is either selected or focused.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.tap = function(item, evt) {};

/**
 * Adds the given listener for the <code>PopulateItemContextMenu</code> event that occurs when the {\@link yfiles.input.ContextMenuInputMode context menu} over an item is about to
 * be opened to determine the contents of the Menu.
 * <p>
 * This method will only be called for items that match the {\@link yfiles.input.GraphInputMode#contextMenuItems} type.
 * </p>
 * @see yfiles.input.GraphInputMode#removePopulateItemContextMenuListener
 * @param {function(!Object, !yfiles.input.PopulateItemContextMenuEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addPopulateItemContextMenuListener = function(listener) {};

/**
 * Removes the given listener for the <code>PopulateItemContextMenu</code> event that occurs when the {\@link yfiles.input.ContextMenuInputMode context menu} over an item is about
 * to be opened to determine the contents of the Menu.
 * <p>
 * This method will only be called for items that match the {\@link yfiles.input.GraphInputMode#contextMenuItems} type.
 * </p>
 * @see yfiles.input.GraphInputMode#addPopulateItemContextMenuListener
 * @param {function(!Object, !yfiles.input.PopulateItemContextMenuEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removePopulateItemContextMenuListener = function(listener) {};

/**
 * Adds the given listener for the <code>QueryItemToolTip</code> event that occurs when the mouse is {\@link yfiles.input.MouseHoverInputMode hovering} over an item to determine
 * the tool tip to display.
 * <p>
 * This method will only be called for items that match the {\@link yfiles.input.GraphInputMode#toolTipItems} type.
 * </p>
 * @see yfiles.input.GraphInputMode#removeQueryItemToolTipListener
 * @param {function(!Object, !yfiles.input.QueryItemToolTipEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addQueryItemToolTipListener = function(listener) {};

/**
 * Removes the given listener for the <code>QueryItemToolTip</code> event that occurs when the mouse is {\@link yfiles.input.MouseHoverInputMode hovering} over an item to
 * determine the tool tip to display.
 * <p>
 * This method will only be called for items that match the {\@link yfiles.input.GraphInputMode#toolTipItems} type.
 * </p>
 * @see yfiles.input.GraphInputMode#addQueryItemToolTipListener
 * @param {function(!Object, !yfiles.input.QueryItemToolTipEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeQueryItemToolTipListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemClicked</code> event that occurs when an item has been clicked.
 * <p>
 * If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore.
 * </p>
 * <p>
 * This event will also be raised for {\@link yfiles.input.GraphInputMode#tap taps}.
 * </p>
 * <p>
 * Button-specific events ({\@link yfiles.input.GraphInputMode#addItemLeftClickedListener ItemLeftClicked} and
 * {\@link yfiles.input.GraphInputMode#addItemRightClickedListener ItemRightClicked}) will be raised before this event.
 * If one of those is marked {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} this event will not be raised anymore.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightClickedListener
 * @see yfiles.input.GraphInputMode#removeItemClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addItemClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemClicked</code> event that occurs when an item has been clicked.
 * <p>
 * If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore.
 * </p>
 * <p>
 * This event will also be raised for {\@link yfiles.input.GraphInputMode#tap taps}.
 * </p>
 * <p>
 * Button-specific events ({\@link yfiles.input.GraphInputMode#addItemLeftClickedListener ItemLeftClicked} and
 * {\@link yfiles.input.GraphInputMode#addItemRightClickedListener ItemRightClicked}) will be raised before this event.
 * If one of those is marked {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} this event will not be raised anymore.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightClickedListener
 * @see yfiles.input.GraphInputMode#addItemClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeItemClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemLeftClicked</code> event that occurs when an item has been left clicked.
 * <p>
 * This event will be raised before the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked}
 * event. If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore. This also means
 * that the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked} event will not be raised in that
 * case.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener
 * @see yfiles.input.GraphInputMode#removeItemLeftClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addItemLeftClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemLeftClicked</code> event that occurs when an item has been left clicked.
 * <p>
 * This event will be raised before the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked}
 * event. If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore. This also means
 * that the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked} event will not be raised in that
 * case.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeItemLeftClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemRightClicked</code> event that occurs when an item has been right clicked.
 * <p>
 * This event will be raised before the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked}
 * event. If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore. This also means
 * that the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked} event will not be raised in that
 * case.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightDoubleClickedListener
 * @see yfiles.input.GraphInputMode#removeItemRightClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addItemRightClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemRightClicked</code> event that occurs when an item has been right clicked.
 * <p>
 * This event will be raised before the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked}
 * event. If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore. This also means
 * that the {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked} event will not be raised in that
 * case.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeItemRightClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemDoubleClicked</code> event that occurs when an item has been double clicked.
 * <p>
 * If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore.
 * </p>
 * <p>
 * Depending on the value of the {\@link yfiles.input.ClickInputMode#doubleClickPolicy} property of {\@link yfiles.input.GraphInputMode#clickInputMode} this event may be preceded by no, one, or two {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked}
 * events (as well as the corresponding button-specific event).
 * </p>
 * <p>
 * Button-specific events ({\@link yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener ItemLeftDoubleClicked} and
 * {\@link yfiles.input.GraphInputMode#addItemRightDoubleClickedListener ItemRightDoubleClicked}) will be raised before this
 * event. If one of those is marked {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} this event will not be raised anymore.
 * </p>
 * @see yfiles.input.GraphInputMode#addItemClickedListener
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightDoubleClickedListener
 * @see yfiles.input.GraphInputMode#removeItemDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addItemDoubleClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemDoubleClicked</code> event that occurs when an item has been double clicked.
 * <p>
 * If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore.
 * </p>
 * <p>
 * Depending on the value of the {\@link yfiles.input.ClickInputMode#doubleClickPolicy} property of {\@link yfiles.input.GraphInputMode#clickInputMode} this event may be preceded by no, one, or two {\@link yfiles.input.GraphInputMode#addItemClickedListener ItemClicked}
 * events (as well as the corresponding button-specific event).
 * </p>
 * <p>
 * Button-specific events ({\@link yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener ItemLeftDoubleClicked} and
 * {\@link yfiles.input.GraphInputMode#addItemRightDoubleClickedListener ItemRightDoubleClicked}) will be raised before this
 * event. If one of those is marked {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} this event will not be raised anymore.
 * </p>
 * @see yfiles.input.GraphInputMode#addItemClickedListener
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeItemDoubleClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemLeftDoubleClicked</code> event that occurs when an item has been left double clicked.
 * <p>
 * This event will be raised before the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked}
 * event. If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore. This also means
 * that the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked} event will not be raised
 * in that case.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightDoubleClickedListener
 * @see yfiles.input.GraphInputMode#removeItemLeftDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addItemLeftDoubleClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemLeftDoubleClicked</code> event that occurs when an item has been left double clicked.
 * <p>
 * This event will be raised before the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked}
 * event. If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore. This also means
 * that the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked} event will not be raised
 * in that case.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeItemLeftDoubleClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ItemRightDoubleClicked</code> event that occurs when an item has been right double clicked.
 * <p>
 * This event will be raised before the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked}
 * event. If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore. This also means
 * that the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked} event will not be raised
 * in that case.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener
 * @see yfiles.input.GraphInputMode#removeItemRightDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addItemRightDoubleClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemRightDoubleClicked</code> event that occurs when an item has been right double clicked.
 * <p>
 * This event will be raised before the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked}
 * event. If one of the event handlers sets the {\@link yfiles.input.ItemClickedEventArgs.<T>#handled} property to <code>true</code> the event will not be propagated anymore. This also means
 * that the {\@link yfiles.input.GraphInputMode#addItemDoubleClickedListener ItemDoubleClicked} event will not be raised
 * in that case.
 * </p>
 * @see yfiles.input.GraphInputMode#clickableItems
 * @see yfiles.input.GraphInputMode#addItemDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemLeftDoubleClickedListener
 * @see yfiles.input.GraphInputMode#addItemRightDoubleClickedListener
 * @param {function(!Object, !yfiles.input.ItemClickedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeItemRightDoubleClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>CanvasClicked</code> event that occurs when the empty canvas area has been clicked.
 * <p>
 * If one of the event handlers sets the {\@link yfiles.input.ClickEventArgs#handled} property to <code>true</code> the event will not be propagated anymore.
 * </p>
 * @see yfiles.input.GraphInputMode#addItemClickedListener
 * @see yfiles.input.GraphInputMode#removeCanvasClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addCanvasClickedListener = function(listener) {};

/**
 * Removes the given listener for the <code>CanvasClicked</code> event that occurs when the empty canvas area has been clicked.
 * <p>
 * If one of the event handlers sets the {\@link yfiles.input.ClickEventArgs#handled} property to <code>true</code> the event will not be propagated anymore.
 * </p>
 * @see yfiles.input.GraphInputMode#addItemClickedListener
 * @see yfiles.input.GraphInputMode#addCanvasClickedListener
 * @param {function(!Object, !yfiles.input.ClickEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeCanvasClickedListener = function(listener) {};

/**
 * Adds the given listener for the <code>MultiSelectionStarted</code> event that occurs when a single or multi select operation has been
 * started.
 * <p>
 * The event is <b>not</b> triggered for the individual selection operations that constitute a multi selection operation.
 * </p>
 * @see yfiles.input.GraphInputMode#removeMultiSelectionStartedListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addMultiSelectionStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>MultiSelectionStarted</code> event that occurs when a single or multi select operation has
 * been started.
 * <p>
 * The event is <b>not</b> triggered for the individual selection operations that constitute a multi selection operation.
 * </p>
 * @see yfiles.input.GraphInputMode#addMultiSelectionStartedListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeMultiSelectionStartedListener = function(listener) {};

/**
 * Adds the given listener for the <code>MultiSelectionFinished</code> event that occurs when a single or multi select operation has
 * been finished.
 * <p>
 * The event is <b>not</b> triggered for the individual selection operations that constitute a multi selection operation.
 * </p>
 * @see yfiles.input.GraphInputMode#removeMultiSelectionFinishedListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.addMultiSelectionFinishedListener = function(listener) {};

/**
 * Removes the given listener for the <code>MultiSelectionFinished</code> event that occurs when a single or multi select operation has
 * been finished.
 * <p>
 * The event is <b>not</b> triggered for the individual selection operations that constitute a multi selection operation.
 * </p>
 * @see yfiles.input.GraphInputMode#addMultiSelectionFinishedListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphInputMode.prototype.removeMultiSelectionFinishedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.GraphViewerInputMode = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.input.GraphViewerInputMode.$class;
/**
 * @record
 * @struct
 */
yfiles.input.IClickListener = function() {};

/**
 * Gets an {\@link yfiles.input.IHitTestable} that can be used to check if {\@link yfiles.input.IClickListener#onClicked} should be invoked.
 * @abstract
 * @return {?} A hit testable that can determine whether {\@link #onClicked} should be invoked by a given click.
 */
yfiles.input.IClickListener.prototype.getHitTestable = function() {};

/**
 * Called by the framework to indicate that the {\@link yfiles.graph.IModelItem} has been clicked by the user at the specified
 * location.
 * <p>
 * This method is called by {\@link yfiles.input.GraphInputMode#click} for the
 * {\@link yfiles.graph.IModelItem}s that yielded an instance of this interface.
 * </p>
 * @abstract
 * @param {?} context The context to use for the click operation.
 * @param {!yfiles.geometry.Point} location The location of the click
 * @return {void}
 */
yfiles.input.IClickListener.prototype.onClicked = function(context, location) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IClickListener;
/**
 * @record
 * @struct
 */
yfiles.input.IEdgePortHandleProvider = function() {};

/**
 * Gets an {\@link yfiles.input.IHandle} implementation for one end of the provided <code>edge</code>.
 * @abstract
 * @param {?} context The context in which the handle will be used.
 * @param {?} edge The edge for which an handle is needed.
 * @param {boolean} sourceHandle if set to <code>true</code> the handle for the source side/port should be returned.
 * @return {?} The handle to use for the provided side or <code>null</code>.
 */
yfiles.input.IEdgePortHandleProvider.prototype.getHandle = function(context, edge, sourceHandle) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IEdgePortHandleProvider;
/**
 * @record
 * @struct
 */
yfiles.input.IEditLabelHelper = function() {};

/**
 * Helper method that will be called when trying to add a label to an {\@link yfiles.graph.ILabelOwner}.
 * <p>
 * Implementations of this method can set the {\@link yfiles.graph.ILabel#style}, {\@link yfiles.graph.ILabel#layoutParameter}, {\@link yfiles.graph.ILabel#preferredSize}, and {\@link yfiles.graph.ITagOwner#tag} for newly-added labels by setting the appropriate properties on
 * <code>args</code>.
 * </p>
 * <p>
 * Setting the {\@link yfiles.input.LabelEditingEventArgs#cancel} property on <code>args</code> to <code>true</code> will disallow label creation.
 * </p>
 * @see yfiles.input.IEditLabelHelper#onLabelEditing
 * @abstract
 * @param {!yfiles.input.LabelEditingEventArgs} evt The original event arguments.
 * @return {void}
 */
yfiles.input.IEditLabelHelper.prototype.onLabelAdding = function(evt) {};

/**
 * Helper method that will be called when trying to edit a label.
 * <p>
 * This method can be called for editing labels for an {\@link yfiles.graph.ILabelOwner}, in which case the {\@link yfiles.input.LabelEditingEventArgs#label} property on <code>args</code> will
 * be <code>null</code>, but the {\@link yfiles.input.LabelEditingEventArgs#owner} property will be non-<code>null</code>. It can also be called for editing a specific label, in which case the {\@link yfiles.input.LabelEditingEventArgs#label}
 * property on <code>args</code> will be non-<code>null</code>, and the {\@link yfiles.input.LabelEditingEventArgs#owner} property will be set to the label's owner.
 * </p>
 * <p>
 * Implementations of this method can set a specific label to be edited, by setting the {\@link yfiles.input.LabelEditingEventArgs#label} property of the <code>args</code> to an
 * existing label instance. This label does not need to belong to the same owner that is queried for. Setting the {\@link yfiles.input.LabelEditingEventArgs#label} property
 * to <code>null</code> will not edit an existing label, but instead add a new one on the {\@link yfiles.graph.ILabelOwner} set in the {\@link yfiles.input.LabelEditingEventArgs#owner}
 * property.
 * </p>
 * <p>
 * When a new label is added, the properties {\@link yfiles.input.LabelEditingEventArgs#style}, {\@link yfiles.input.LabelEditingEventArgs#layoutParameter}, {\@link yfiles.input.LabelEditingEventArgs#preferredSize}, and {\@link yfiles.input.LabelEditingEventArgs#tag} are used for the newly-created label, just as in
 * {\@link yfiles.input.IEditLabelHelper#onLabelAdding}.
 * </p>
 * <p>
 * Setting the {\@link yfiles.input.LabelEditingEventArgs#cancel} property on <code>args</code> to <code>true</code> will disallow label editing and creation.
 * </p>
 * @see yfiles.input.IEditLabelHelper#onLabelAdding
 * @abstract
 * @param {!yfiles.input.LabelEditingEventArgs} evt The original event arguments.
 * @return {void}
 */
yfiles.input.IEditLabelHelper.prototype.onLabelEditing = function(evt) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IEditLabelHelper;
/**
 * @record
 * @struct
 */
yfiles.input.ILabelSnapContextHelper = function() {};

/**
 * Called during {\@link yfiles.input.IDragHandler#initializeDrag initialization} of a <code>label</code> dragging to add {\@link yfiles.input.SnapLine snap lines} to which the label can potentially snap to the
 * <code>snapContext</code>.
 * @abstract
 * @param {!yfiles.input.LabelSnapContext} snapContext The snap context which manages the snap lines and the settings. Note that implementations should not change the state of
 * the context explicitly.
 * @param {?} inputModeContext The context of the input mode that handles the dragging.
 * @param {?} label The label that is dragged.
 * @return {void}
 */
yfiles.input.ILabelSnapContextHelper.prototype.addSnapLines = function(snapContext, inputModeContext, label) {};

/**
 * Called while the given <code>label</code> is {\@link yfiles.input.IDragHandler#handleMove dragged} to add {\@link yfiles.input.SnapResult snap results} for the {\@link yfiles.input.SnapLine snap lines} provided by the <code>context</code>.
 * @abstract
 * @param {!yfiles.input.LabelSnapContext} context The snap context which manages the snap lines and the settings.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The event argument to obtain the necessary information from and {\@link #addSnapResult add results to}.
 * @param {?} suggestedLayout The {\@link #layout layout} of the label that would be used without snapping.
 * @param {?} label The label that is dragged.
 * @return {void}
 */
yfiles.input.ILabelSnapContextHelper.prototype.collectSnapResults = function(context, evt, suggestedLayout, label) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.ILabelSnapContextHelper;
/**
 * @record
 * @struct
 */
yfiles.input.INodeSizeConstraintProvider = function() {};

/**
 * Returns the maximum size allowed for the given <code>node</code>.
 * @abstract
 * @param {?} node The node to return the maximum size for.
 * @return {!yfiles.geometry.Size} The maximum size or {\@link #INFINITE} if there is no constraint on the size.
 */
yfiles.input.INodeSizeConstraintProvider.prototype.getMaximumSize = function(node) {};

/**
 * Returns the minimum area that needs to be enclosed by the given <code>node</code>.
 * @abstract
 * @param {?} node The node to return the area for.
 * @return {!yfiles.geometry.Rect} The area to enclose or {\@link #EMPTY} if there is no constraint on the size due to an enclosed area.
 */
yfiles.input.INodeSizeConstraintProvider.prototype.getMinimumEnclosedArea = function(node) {};

/**
 * Returns the minimum size allowed for the given <code>node</code>.
 * @abstract
 * @param {?} node The node to return the minimum size for.
 * @return {!yfiles.geometry.Size} The minimum size or {\@link #EMPTY} if there is no constraint on the size.
 */
yfiles.input.INodeSizeConstraintProvider.prototype.getMinimumSize = function(node) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.INodeSizeConstraintProvider;
/**
 * @record
 * @struct
 */
yfiles.input.NodeSizeConstraintProvider = function() {};
 /** @type {?} */
yfiles.input.NodeSizeConstraintProvider.prototype.maximumSize;
 /** @type {?} */
yfiles.input.NodeSizeConstraintProvider.prototype.minimumEnclosedArea;
 /** @type {?} */
yfiles.input.NodeSizeConstraintProvider.prototype.minimumSize;
 /** @type {!yfiles.lang.Class} */
yfiles.input.NodeSizeConstraintProvider.$class;

/**
 *
 * @param {?} node
 * @return {!yfiles.geometry.Size}
 */
yfiles.input.NodeSizeConstraintProvider.prototype.getMaximumSize = function(node) {};

/**
 *
 * @param {?} node
 * @return {!yfiles.geometry.Rect}
 */
yfiles.input.NodeSizeConstraintProvider.prototype.getMinimumEnclosedArea = function(node) {};

/**
 *
 * @param {?} node
 * @return {!yfiles.geometry.Size}
 */
yfiles.input.NodeSizeConstraintProvider.prototype.getMinimumSize = function(node) {};
/**
 * @record
 * @struct
 */
yfiles.input.IOrthogonalEdgeHelper = function() {};

/**
 * Callback method that is invoked after the provided edge has been edited orthogonally.
 * <p>
 * This callback can be used to remove unused bends and finalize the orthogonal edge editing gesture.
 * </p>
 * @abstract
 * @param {?} context The input mode context which edited the edge.
 * @param {?} graph The graph to use for modifying the edge instance.
 * @param {?} edge The edge to clean up the path.
 * @return {void}
 */
yfiles.input.IOrthogonalEdgeHelper.prototype.cleanUpEdge = function(context, graph, edge) {};

/**
 * Gets the declared orientation of the given segment at the provided edge.
 * <p>
 * The orientation cannot always be inferred from the current geometry: If a segment has a zero length it is unclear what
 * orientation it should have, also a segment could be accidentally orthogonally oriented, while in fact it is considered
 * {\@link yfiles.input.SegmentOrientation#NON_ORTHOGONAL}.
 * </p>
 * @abstract
 * @param {?} context The input mode context in which the orientation is needed.
 * @param {?} edge The edge to inspect.
 * @param {number} segmentIndex The index of the segment.
 * @return {yfiles.input.SegmentOrientation} The declared orientation of the segment.
 */
yfiles.input.IOrthogonalEdgeHelper.prototype.getSegmentOrientation = function(context, edge, segmentIndex) {};

/**
 * Determines whether the provided edge should be edited orthogonally in the specified input mode context.
 * <p>
 * If this method returns <code>false</code>, the other methods will not be queried at all.
 * </p>
 * @abstract
 * @param {?} context The input mode context in which the edge is about to be edited.
 * @param {?} edge The edge to inspect.
 * @return {boolean} <code>true</code> if the edge should be orthogonally edited in the specified input mode context; <code>false</code> otherwise.
 */
yfiles.input.IOrthogonalEdgeHelper.prototype.shouldEditOrthogonally = function(context, edge) {};

/**
 * Determines whether this end of the provided edge can be moved in the input mode context.
 * <p>
 * This information is required to determine whether an edge's first or last segment needs to be split or the adjacent edge
 * end can be moved along with the other end of the segment.
 * </p>
 * @abstract
 * @param {?} context The input mode context in which the segment is edited.
 * @param {?} edge The edge to inspect.
 * @param {boolean} sourceEnd if set to <code>true</code> the source end of the edge is queried, otherwise the target end.
 * @return {boolean} <code>true</code> if the end of the edge can be moved for the specified input mode context; <code>false</code> otherwise, in which case the
 * corresponding segment needs to be split to keep the segment orientation orthogonal.
 */
yfiles.input.IOrthogonalEdgeHelper.prototype.shouldMoveEndImplicitly = function(context, edge, sourceEnd) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IOrthogonalEdgeHelper;
/**
 * @record
 * @struct
 */
yfiles.input.IReparentNodeHandler = function() {};

/**
 * Determines whether the current gesture that can be determined through the context is a reparent gesture.
 * @abstract
 * @param {?} context The context that provides information about the user input.
 * @param {?} node The node that will possibly be reparented.
 * @return {boolean} Whether this is a reparenting gesture.
 */
yfiles.input.IReparentNodeHandler.prototype.isReparentGesture = function(context, node) {};

/**
 * Determines whether the provided node may be reparented to a <code>newParent</code>.
 * @abstract
 * @param {?} context The context that provides information about the user input.
 * @param {?} node The node that will be reparented.
 * @param {?} newParent The potential new parent or <code>null</code>. Can be a group or a non-group node.
 * @return {boolean} Whether <code>newParent</code> is a valid new parent for <code>node</code>.
 */
yfiles.input.IReparentNodeHandler.prototype.isValidParent = function(context, node, newParent) {};

/**
 * Performs the actual reparenting after the reparent gesture has been finalized.
 * <p>
 * Implementations should {\@link yfiles.graph.IGraph#setParent set the parent} of <code>node</code> to <code>newParent</code>.
 * </p>
 * @abstract
 * @param {?} context The context that provides information about the user input.
 * @param {?} node The node that will be reparented.
 * @param {?} newParent The potential new parent or <code>null</code>. Can be a group or a non-group node.
 * @return {void}
 */
yfiles.input.IReparentNodeHandler.prototype.reparent = function(context, node, newParent) {};

/**
 * Determines whether the user may detach the given node from its current parent in order to reparent it.
 * @abstract
 * @param {?} context The context that provides information about the user input.
 * @param {?} node The node that is about to be detached from its current parent.
 * @return {boolean} Whether the node may be detached and reparented.
 */
yfiles.input.IReparentNodeHandler.prototype.shouldReparent = function(context, node) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IReparentNodeHandler;
/**
 * @record
 * @struct
 */
yfiles.input.ISnapLineProvider = function() {};

/**
 * Called by the {\@link yfiles.input.GraphSnapContext} when a {\@link yfiles.input.GraphSnapContext#initializeDrag drag} is about to start.
 * @abstract
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} item The item to add snap lines for.
 * @return {void}
 */
yfiles.input.ISnapLineProvider.prototype.addSnapLines = function(context, evt, item) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.ISnapLineProvider;
/**
 * @record
 * @struct
 */
yfiles.input.ItemClickedEventArgs = function() {};
 /** @type {boolean} */
yfiles.input.ItemClickedEventArgs.prototype.handled;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.ItemClickedEventArgs.prototype.location;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ItemClickedEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.ItemHoverInputMode = function() {};
 /** @type {number} */
yfiles.input.ItemHoverInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.ItemHoverInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.ItemHoverInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.ItemHoverInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.ItemHoverInputMode.prototype.controller;
 /** @type {?} */
yfiles.input.ItemHoverInputMode.prototype.currentHoverItem;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.ItemHoverInputMode.prototype.hoverItems;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.ItemHoverInputMode.prototype.hoverCursor;
 /** @type {boolean} */
yfiles.input.ItemHoverInputMode.prototype.discardInvalidItems;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ItemHoverInputMode.$class;

/**
 *
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.cancel = function() {};

/**
 * Gets the items that have been hit at the given location.
 * @protected
 * @param {!yfiles.geometry.Point} location The location in world coordinates to query.
 * @return {?<?>} An enumerable over all items that have been hit at the given location.
 */
yfiles.input.ItemHoverInputMode.prototype.getHitItemsAt = function(location) {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.install = function(context, controller) {};

/**
 * Determines whether the given item is a valid item to be considered for hovering.
 * <p>
 * This implementation checks whether the item is covered by the {\@link yfiles.input.ItemHoverInputMode#hoverItems} set, only.
 * </p>
 * @see yfiles.input.ItemHoverInputMode#discardInvalidItems
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} <code>true</code> if it is valid to report a hover over the specified item; <code>false</code> otherwise.
 */
yfiles.input.ItemHoverInputMode.prototype.isValidHoverItem = function(item) {};

/**
 * Called after {\@link yfiles.input.ItemHoverInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Raises the {\@link yfiles.input.ItemHoverInputMode#addHoveredItemChangedListener HoveredItemChanged} event.
 * @protected
 * @param {!yfiles.input.HoveredItemChangedEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.onHoveredItemChanged = function(evt) {};

/**
 * Called after {\@link yfiles.input.ItemHoverInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.onStopped = function() {};

/**
 * Overridden to only return <code>true</code> if this instance does not currently {\@link yfiles.input.ConcurrencyController#hasMutex have the input mutex}.
 * @return {boolean} <code>true</code> iff this instance does not {\@link #hasMutex own the mutex}.
 */
yfiles.input.ItemHoverInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.uninstall = function(context) {};

/**
 * Forces a reevaluation of the item that the mouse is currently hovering over or at a specific location.
 * <p>
 * This method may be called by code that is aware of the fact that the visualization has changed, but the mouse may not
 * have been moved. By default this implementation will only re-query the items at the mouse location when the mouse has
 * moved. This method can be called to force a reevaluation in other cases.
 * </p>
 * @param {!yfiles.geometry.Point=} location
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.updateHover = function(location) {};

/**
 * Adds the given listener for the <code>HoveredItemChanged</code> event that occurs when the item that is being hovered over with the
 * mouse changes.
 * <p>
 * This event is also fired when the mouse pointer leaves an item.
 * </p>
 * @see yfiles.input.ItemHoverInputMode#removeHoveredItemChangedListener
 * @param {function(!Object, !yfiles.input.HoveredItemChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.addHoveredItemChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>HoveredItemChanged</code> event that occurs when the item that is being hovered over with
 * the mouse changes.
 * <p>
 * This event is also fired when the mouse pointer leaves an item.
 * </p>
 * @see yfiles.input.ItemHoverInputMode#addHoveredItemChangedListener
 * @param {function(!Object, !yfiles.input.HoveredItemChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ItemHoverInputMode.prototype.removeHoveredItemChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.HoveredItemChangedEventArgs = function() {};
 /** @type {?} */
yfiles.input.HoveredItemChangedEventArgs.prototype.oldItem;
 /** @type {!yfiles.lang.Class} */
yfiles.input.HoveredItemChangedEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.LabelEditingEventArgs = function() {};
 /** @type {?} */
yfiles.input.LabelEditingEventArgs.prototype.label;
 /** @type {boolean} */
yfiles.input.LabelEditingEventArgs.prototype.cancel;
 /** @type {boolean} */
yfiles.input.LabelEditingEventArgs.prototype.handled;
 /** @type {?} */
yfiles.input.LabelEditingEventArgs.prototype.owner;
 /** @type {?} */
yfiles.input.LabelEditingEventArgs.prototype.style;
 /** @type {!yfiles.geometry.Size} */
yfiles.input.LabelEditingEventArgs.prototype.preferredSize;
 /** @type {?} */
yfiles.input.LabelEditingEventArgs.prototype.layoutParameter;
 /** @type {!Object} */
yfiles.input.LabelEditingEventArgs.prototype.tag;
 /** @type {function(?, !yfiles.input.TextEditorInputMode, ?): void} */
yfiles.input.LabelEditingEventArgs.prototype.textEditorInputModeConfigurator;
 /** @type {!yfiles.lang.Class} */
yfiles.input.LabelEditingEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.LabelSnapContext = function() {};
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.collectInitialLocationSnapLines;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.collectNodeShapeSnapLines;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.collectOwnNodeDistanceSnapLines;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.collectSameOwnerNodeDistanceSnapLines;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.collectAllNodeDistanceSnapLines;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.collectEdgePathSnapLines;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.collectOwnEdgeDistanceSnapLines;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.collectSameOwnerEdgeDistanceSnapLines;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.collectAllEdgeDistanceSnapLines;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.snapNodeLabels;
 /** @type {boolean} */
yfiles.input.LabelSnapContext.prototype.snapEdgeLabels;
 /** @type {number} */
yfiles.input.LabelSnapContext.prototype.snapLineExtension;
 /** @type {?<!yfiles.input.SnapLine>} */
yfiles.input.LabelSnapContext.prototype.snapLines;
 /** @type {!yfiles.lang.Class} */
yfiles.input.LabelSnapContext.$class;

/**
 * Adds the given <code>snapLine</code> to the {\@link yfiles.input.LabelSnapContext#snapLines snap line} collection of this context.
 * @see yfiles.input.GraphSnapContext#additionalSnapLines
 * @param {!yfiles.input.SnapLine} snapLine The snap line to add.
 * @return {void}
 */
yfiles.input.LabelSnapContext.prototype.addSnapLine = function(snapLine) {};

/**
 * Raises the {\@link yfiles.input.LabelSnapContext#addCollectSnapLinesListener CollectSnapLines} event.
 * @protected
 * @param {!yfiles.input.CollectLabelSnapLineEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.LabelSnapContext.prototype.onCollectSnapLines = function(evt) {};

/**
 * Adds the given listener for the <code>CollectSnapLines</code> event that occurs every time this instance has been {\@link yfiles.input.SnapContext#dragInitialized initialized} to
 * collect {\@link yfiles.input.SnapLine}s.
 * <p>
 * Event handlers should add snap lines to the caller using the methods provided by
 * {\@link yfiles.input.CollectLabelSnapLineEventArgs}.
 * </p>
 * @see yfiles.input.LabelSnapContext#removeCollectSnapLinesListener
 * @param {function(!Object, !yfiles.input.CollectLabelSnapLineEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.LabelSnapContext.prototype.addCollectSnapLinesListener = function(listener) {};

/**
 * Removes the given listener for the <code>CollectSnapLines</code> event that occurs every time this instance has been {\@link yfiles.input.SnapContext#dragInitialized initialized} to
 * collect {\@link yfiles.input.SnapLine}s.
 * <p>
 * Event handlers should add snap lines to the caller using the methods provided by
 * {\@link yfiles.input.CollectLabelSnapLineEventArgs}.
 * </p>
 * @see yfiles.input.LabelSnapContext#addCollectSnapLinesListener
 * @param {function(!Object, !yfiles.input.CollectLabelSnapLineEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.LabelSnapContext.prototype.removeCollectSnapLinesListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.CollectLabelSnapLineEventArgs = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.input.CollectLabelSnapLineEventArgs.$class;

/**
 * Adds the given snap line to the snap line collection of this class.
 * @param {!yfiles.input.OrthogonalSnapLine} snapLine the snap line to add.
 * @return {void}
 */
yfiles.input.CollectLabelSnapLineEventArgs.prototype.addSnapLine = function(snapLine) {};
/**
 * @record
 * @struct
 */
yfiles.input.NavigationInputMode = function() {};
 /** @type {number} */
yfiles.input.NavigationInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.NavigationInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.NavigationInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.NavigationInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.NavigationInputMode.prototype.controller;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.NavigationInputMode.prototype.navigableItems;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.NavigationInputMode.prototype.selectableItems;
 /** @type {yfiles.input.NodeAlignmentPolicy} */
yfiles.input.NavigationInputMode.prototype.autoGroupNodeAlignmentPolicy;
 /** @type {!yfiles.view.GraphComponent} */
yfiles.input.NavigationInputMode.prototype.graphComponent;
 /** @type {?<?>} */
yfiles.input.NavigationInputMode.prototype.availableCommands;
 /** @type {boolean} */
yfiles.input.NavigationInputMode.prototype.useCurrentItemForCommands;
 /** @type {?} */
yfiles.input.NavigationInputMode.prototype.graphSelection;
 /** @type {?} */
yfiles.input.NavigationInputMode.prototype.graph;
 /** @type {boolean} */
yfiles.input.NavigationInputMode.prototype.allowEnterGroup;
 /** @type {boolean} */
yfiles.input.NavigationInputMode.prototype.allowCollapseGroup;
 /** @type {boolean} */
yfiles.input.NavigationInputMode.prototype.allowExpandGroup;
 /** @type {boolean} */
yfiles.input.NavigationInputMode.prototype.allowExitGroup;
 /** @type {boolean} */
yfiles.input.NavigationInputMode.prototype.fitContentAfterGroupActions;
 /** @type {!yfiles.lang.Class} */
yfiles.input.NavigationInputMode.$class;

/**
 * Callback that adjusts the {\@link yfiles.view.CanvasComponent#contentRect} to encompass all elements.
 * <p>
 * This implementation will try to delegate to {\@link yfiles.input.GraphEditorInputMode#adjustContentRect} if it can find the {\@link yfiles.input.GraphEditorInputMode}
 * in the {\@link yfiles.input.NavigationInputMode#inputModeContext}, otherwise the {\@link yfiles.input.ICommand#FIT_GRAPH_BOUNDS} is executed.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.adjustContentRect = function() {};

/**
 * Adjust the group node location according to the value of {\@link yfiles.input.NavigationInputMode#autoGroupNodeAlignmentPolicy}.
 * @protected
 * @param {boolean} collapse <code>true</code> iff the node has just been collapsed.
 * @param {?} groupNode The node that has changed its state.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.adjustGroupNodeLocation = function(collapse, groupNode) {};

/**
 *
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.cancel = function() {};

/**
 * Clears the selection in the {\@link yfiles.input.NavigationInputMode#graphComponent}.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.clearSelection = function() {};

/**
 * {\@link yfiles.graph.IFoldingView#collapse Collapses} the given group node to hide the contents of the group node from this {\@link yfiles.graph.IFoldingView}.
 * @see yfiles.graph.FoldingManager
 * @see yfiles.input.NavigationInputMode#allowCollapseGroup
 * @param {?} groupNode The group node to collapse.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.collapseGroup = function(groupNode) {};

/**
 * Performs CollapseGroup for all {\@link yfiles.view.IGraphSelection#selectedNodes}.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.collapseSelection = function() {};

/**
 * This method allows for entering a group node so that the currently displayed {\@link yfiles.graph.IFoldingView}'s {\@link yfiles.graph.IFoldingView#localRoot} will be reset
 * to the provided node.
 * <p>
 * It is possible to both use a local group node that is part of the currently displayed {\@link yfiles.input.NavigationInputMode#graph} as the <code>node</code> argument, as well as
 * an item that belongs to the {\@link yfiles.graph.FoldingManager#masterGraph} to allow for switching to group nodes which are currently not being displayed in this
 * view.
 * </p>
 * @see yfiles.input.NavigationInputMode#shouldEnterGroup
 * @see yfiles.input.NavigationInputMode#allowEnterGroup
 * @see yfiles.graph.FoldingManager
 * @param {?} node The node that needs to be either part of the current graph, or part of the {\@link #masterGraph}.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.enterGroup = function(node) {};

/**
 * Performs {\@link yfiles.input.NavigationInputMode#enterGroup} for the first valid {\@link yfiles.view.IGraphSelection#selectedNodes}.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.enterSelectedGroup = function() {};

/**
 * Exits the current {\@link yfiles.graph.IFoldingView#localRoot} of the currently displayed {\@link yfiles.graph.IFoldingView view} and shows the contents of the parent container.
 * <p>
 * This method will also {\@link yfiles.input.GraphInputMode#clearSelection clear the selection} and {\@link yfiles.input.GraphInputMode#setSelected select} the exited group node.
 * </p>
 * @see yfiles.graph.FoldingManager
 * @see yfiles.input.NavigationInputMode#allowExitGroup
 * @see yfiles.input.NavigationInputMode#shouldExitGroup
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.exitGroup = function() {};

/**
 * {\@link yfiles.graph.IFoldingView#expand Expands} the given group node to show the contents of the collapsed group node in this {\@link yfiles.graph.IFoldingView}.
 * @see yfiles.graph.FoldingManager
 * @see yfiles.input.NavigationInputMode#allowExpandGroup
 * @param {?} groupNode The group node to expand
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.expandGroup = function(groupNode) {};

/**
 * Performs {\@link yfiles.input.NavigationInputMode#expandGroup} for all {\@link yfiles.view.IGraphSelection#selectedNodes}.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.expandSelection = function() {};

/**
 * Moves the focus into the given direction, extending the selection to the new element.
 * @param {yfiles.input.MoveFocusDirection} direction The direction to move the focus and extend the selection.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.extendSelectionTo = function(direction) {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.install = function(context, controller) {};

/**
 * Moves the focus into the given direction, not changing the current selection.
 * @param {yfiles.input.MoveFocusDirection} direction The direction to move the focus.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.moveFocusTo = function(direction) {};

/**
 * Moves the focus into the given direction, setting the selection to the new element.
 * @param {yfiles.input.MoveFocusDirection} direction The direction to move the focus and selection.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.moveTo = function(direction) {};

/**
 * Called after {\@link yfiles.input.NavigationInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Raises the {\@link yfiles.input.NavigationInputMode#addGroupCollapsedListener GroupCollapsed} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onGroupCollapsed = function(evt) {};

/**
 * Raises the {\@link yfiles.input.NavigationInputMode#addGroupCollapsingListener GroupCollapsing} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onGroupCollapsing = function(evt) {};

/**
 * Raises the {\@link yfiles.input.NavigationInputMode#addGroupEnteredListener GroupEntered} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onGroupEntered = function(evt) {};

/**
 * Raises the {\@link yfiles.input.NavigationInputMode#addGroupEnteringListener GroupEntering} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onGroupEntering = function(evt) {};

/**
 * Raises the {\@link yfiles.input.NavigationInputMode#addGroupExitedListener GroupExited} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onGroupExited = function(evt) {};

/**
 * Raises the {\@link yfiles.input.NavigationInputMode#addGroupExitingListener GroupExiting} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onGroupExiting = function(evt) {};

/**
 * Raises the {\@link yfiles.input.NavigationInputMode#addGroupExpandedListener GroupExpanded} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onGroupExpanded = function(evt) {};

/**
 * Raises the {\@link yfiles.input.NavigationInputMode#addGroupExpandingListener GroupExpanding} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onGroupExpanding = function(evt) {};

/**
 * Callback that actually sets the current item property.
 * @protected
 * @param {!yfiles.view.GraphComponent} graphComponent The {\@link #graphComponent} to set the current item of.
 * @param {?} item The item to set.
 * @return {boolean} Whether the operation was actually performed.
 */
yfiles.input.NavigationInputMode.prototype.onSetCurrentItem = function(graphComponent, item) {};

/**
 * Called after {\@link yfiles.input.NavigationInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.onStopped = function() {};

/**
 * Selects the {\@link yfiles.view.GraphComponent#currentItem} current item.
 * <p>
 * This method delegates to {\@link yfiles.input.NavigationInputMode#selectItem}.
 * </p>
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.selectCurrentItem = function() {};

/**
 * Callback that selects the given item.
 * @see yfiles.input.NavigationInputMode#clearSelection
 * @protected
 * @param {!yfiles.view.GraphComponent} graphComponent The {\@link #graphComponent}.
 * @param {?} item The item to select.
 * @param {boolean} extendSelection if set to <code>true</code> the current selection is extended otherwise it is cleared beforehand.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.selectItem = function(graphComponent, item, extendSelection) {};

/**
 * Sets the "current" item to the given one.
 * @see yfiles.input.NavigationInputMode#onSetCurrentItem
 * @param {?} item The item to set as the current item.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.setCurrentItem = function(item) {};

/**
 * Sets the {\@link yfiles.input.NavigationInputMode#graphComponent} to use for the various actions.
 * <p>
 * This will register or unregister the commands for the control. This method is called in response to {\@link yfiles.input.NavigationInputMode#install}
 * and {\@link yfiles.input.NavigationInputMode#uninstall}.
 * </p>
 * @protected
 * @param {!yfiles.view.GraphComponent} graphComponent The control to use or <code>null</code>.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.setGraphComponent = function(graphComponent) {};

/**
 * Predicate method that decides whether it is allowed to collapse the given group node.
 * <p>
 * This implementation returns the value of {\@link yfiles.input.NavigationInputMode#allowCollapseGroup}.
 * </p>
 * @protected
 * @param {?} groupNode
 * @return {boolean} Whether to collapse the given group or not.
 */
yfiles.input.NavigationInputMode.prototype.shouldCollapseGroup = function(groupNode) {};

/**
 * Predicate method that decides whether it is allowed to {\@link yfiles.input.NavigationInputMode#enterGroup enter} the specific group node.
 * <p>
 * This implementation yields the value of {\@link yfiles.input.NavigationInputMode#allowEnterGroup}.
 * </p>
 * @protected
 * @param {?} node The group node to enter.
 * @return {boolean} Whether to enter the group or not.
 */
yfiles.input.NavigationInputMode.prototype.shouldEnterGroup = function(node) {};

/**
 * Predicate method that decides whether it is allowed to {\@link yfiles.input.NavigationInputMode#exitGroup exit} the current group node.
 * <p>
 * This implementation yields the value of {\@link yfiles.input.NavigationInputMode#allowExitGroup}.
 * </p>
 * @protected
 * @return {boolean} Whether to exit the current group or not.
 */
yfiles.input.NavigationInputMode.prototype.shouldExitGroup = function() {};

/**
 * Predicate method that decides whether it is allowed to {\@link yfiles.input.NavigationInputMode#expandGroup expand} the given group node.
 * <p>
 * This implementation yields the value of {\@link yfiles.input.NavigationInputMode#allowExpandGroup}.
 * </p>
 * @protected
 * @param {?} node
 * @return {boolean} Whether to expand the given group or not.
 */
yfiles.input.NavigationInputMode.prototype.shouldExpandGroup = function(node) {};

/**
 * Callback predicate method that determines whether a given model item should be navigated to.
 * <p>
 * This implementation uses the {\@link yfiles.input.NavigationInputMode#navigableItems} property to determine whether the <code>item</code> can be navigated to.
 * </p>
 * @protected
 * @param {?} item The model item.
 * @return {boolean} Whether the item should be considered for navigational commands.
 */
yfiles.input.NavigationInputMode.prototype.shouldNavigateTo = function(item) {};

/**
 * Determines whether the input mode should try to request the mutex when a command is executed.
 * <p>
 * This resets the state of any other input mode, unless it currently possesses the mutex.
 * </p>
 * <p>
 * The value of this method is queried for {\@link yfiles.input.ICommand#COLLAPSE_GROUP}, {\@link yfiles.input.ICommand#EXPAND_GROUP},
 * {\@link yfiles.input.ICommand#TOGGLE_EXPANSION_STATE}, {\@link yfiles.input.ICommand#ENTER_GROUP} and {\@link yfiles.input.ICommand#EXIT_GROUP}.
 * </p>
 * @protected
 * @return {boolean} whether the input mode should request the mutex.
 */
yfiles.input.NavigationInputMode.prototype.shouldRequestMutex = function() {};

/**
 * Callback predicate method that determines whether a given model item should be selected.
 * <p>
 * This implementation uses the {\@link yfiles.input.NavigationInputMode#selectableItems} property to determine whether the <code>item</code> should be selected.
 * </p>
 * @protected
 * @param {?} item The model item.
 * @return {boolean} Whether the item should be selected by the navigational commands.
 */
yfiles.input.NavigationInputMode.prototype.shouldSelect = function(item) {};

/**
 * Predicate method that decides whether it is allowed to {\@link yfiles.input.NavigationInputMode#toggleExpansionState toggle} the collapsed state of the given group node.
 * <p>
 * This implementation uses {\@link yfiles.input.NavigationInputMode#shouldExpandGroup} and {\@link yfiles.input.NavigationInputMode#shouldCollapseGroup}
 * respectively.
 * </p>
 * @protected
 * @param {?} node
 * @return {boolean} Whether to expand the given group or not.
 */
yfiles.input.NavigationInputMode.prototype.shouldToggleExpansionState = function(node) {};

/**
 * Toggles the {\@link yfiles.graph.IFoldingView#isExpanded expanded/collapsed} state for the given group node in the {\@link yfiles.graph.IFoldingView}.
 * @see yfiles.graph.FoldingManager
 * @param {?} groupNode The group node to toggle the state for.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.toggleExpansionState = function(groupNode) {};

/**
 * Overridden to only return <code>true</code> if this instance does not currently {\@link yfiles.input.ConcurrencyController#hasMutex have the input mutex}.
 * @return {boolean} <code>true</code> iff this instance does not {\@link #hasMutex own the mutex}.
 */
yfiles.input.NavigationInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>GroupCollapsing</code> event that occurs before a group will be Collapsed.
 * @see yfiles.input.NavigationInputMode#removeGroupCollapsingListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.addGroupCollapsingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupCollapsing</code> event that occurs before a group will be Collapsed.
 * @see yfiles.input.NavigationInputMode#addGroupCollapsingListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.removeGroupCollapsingListener = function(listener) {};

/**
 * Adds the given listener for the <code>GroupCollapsed</code> event that occurs whenever a group has been Collapsed.
 * @see yfiles.input.NavigationInputMode#removeGroupCollapsedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.addGroupCollapsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupCollapsed</code> event that occurs whenever a group has been Collapsed.
 * @see yfiles.input.NavigationInputMode#addGroupCollapsedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.removeGroupCollapsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GroupExpanding</code> event that occurs before a group will be {\@link yfiles.input.NavigationInputMode#expandGroup Expanded}.
 * @see yfiles.input.NavigationInputMode#removeGroupExpandingListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.addGroupExpandingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupExpanding</code> event that occurs before a group will be {\@link yfiles.input.NavigationInputMode#expandGroup Expanded}.
 * @see yfiles.input.NavigationInputMode#addGroupExpandingListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.removeGroupExpandingListener = function(listener) {};

/**
 * Adds the given listener for the <code>GroupExpanded</code> event that occurs whenever a group has been {\@link yfiles.input.NavigationInputMode#expandGroup Expanded}.
 * @see yfiles.input.NavigationInputMode#removeGroupExpandedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.addGroupExpandedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupExpanded</code> event that occurs whenever a group has been {\@link yfiles.input.NavigationInputMode#expandGroup Expanded}.
 * @see yfiles.input.NavigationInputMode#addGroupExpandedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.removeGroupExpandedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GroupEntering</code> event that occurs before a group will be {\@link yfiles.input.NavigationInputMode#enterGroup Entered}.
 * @see yfiles.input.NavigationInputMode#removeGroupEnteringListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.addGroupEnteringListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupEntering</code> event that occurs before a group will be {\@link yfiles.input.NavigationInputMode#enterGroup Entered}.
 * @see yfiles.input.NavigationInputMode#addGroupEnteringListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.removeGroupEnteringListener = function(listener) {};

/**
 * Adds the given listener for the <code>GroupEntered</code> event that occurs whenever a group has been {\@link yfiles.input.NavigationInputMode#enterGroup Entered}.
 * @see yfiles.input.NavigationInputMode#removeGroupEnteredListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.addGroupEnteredListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupEntered</code> event that occurs whenever a group has been {\@link yfiles.input.NavigationInputMode#enterGroup Entered}.
 * @see yfiles.input.NavigationInputMode#addGroupEnteredListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.removeGroupEnteredListener = function(listener) {};

/**
 * Adds the given listener for the <code>GroupExiting</code> event that occurs before a group will be {\@link yfiles.input.NavigationInputMode#exitGroup Exited}.
 * @see yfiles.input.NavigationInputMode#removeGroupExitingListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.addGroupExitingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupExiting</code> event that occurs before a group will be {\@link yfiles.input.NavigationInputMode#exitGroup Exited}.
 * @see yfiles.input.NavigationInputMode#addGroupExitingListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.removeGroupExitingListener = function(listener) {};

/**
 * Adds the given listener for the <code>GroupExited</code> event that occurs whenever a group has been {\@link yfiles.input.NavigationInputMode#exitGroup Exited}.
 * @see yfiles.input.NavigationInputMode#removeGroupExitedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.addGroupExitedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupExited</code> event that occurs whenever a group has been {\@link yfiles.input.NavigationInputMode#exitGroup Exited}.
 * @see yfiles.input.NavigationInputMode#addGroupExitedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.NavigationInputMode.prototype.removeGroupExitedListener = function(listener) {};

/** @const */
yfiles.input.MoveFocusDirection = {};
/** @const {number} */
yfiles.input.MoveFocusDirection.NONE;
/** @const {number} */
yfiles.input.MoveFocusDirection.LEFT;
/** @const {number} */
yfiles.input.MoveFocusDirection.RIGHT;
/** @const {number} */
yfiles.input.MoveFocusDirection.UP;
/** @const {number} */
yfiles.input.MoveFocusDirection.DOWN;
/** @const {number} */
yfiles.input.MoveFocusDirection.PARENT;
/** @const {number} */
yfiles.input.MoveFocusDirection.CHILD;

/** @const */
yfiles.input.NodeAlignmentPolicy = {};
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.NONE;
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.CENTER;
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.TOP_LEFT;
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.BOTTOM_LEFT;
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.TOP_RIGHT;
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.BOTTOM_RIGHT;
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.TOP_CENTER;
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.BOTTOM_CENTER;
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.CENTER_LEFT;
/** @const {number} */
yfiles.input.NodeAlignmentPolicy.CENTER_RIGHT;

/** @const */
yfiles.input.OrthogonalEdgeEditingPolicy = {};
/** @const {number} */
yfiles.input.OrthogonalEdgeEditingPolicy.AUTO;
/** @const {number} */
yfiles.input.OrthogonalEdgeEditingPolicy.ALWAYS;
/** @const {number} */
yfiles.input.OrthogonalEdgeEditingPolicy.NEVER;

/** @const */
yfiles.input.SegmentOrientation = {};
/** @const {number} */
yfiles.input.SegmentOrientation.HORIZONTAL;
/** @const {number} */
yfiles.input.SegmentOrientation.VERTICAL;
/** @const {number} */
yfiles.input.SegmentOrientation.NON_ORTHOGONAL;
/**
 * @record
 * @struct
 */
yfiles.input.GraphSnapContext = function() {};
 /** @type {?<?>} */
yfiles.input.GraphSnapContext.prototype.fixedNodes;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.collectEdgeSnapLines;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.collectNodeSizes;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.collectNodeSnapLines;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.collectPortSnapLines;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.snapBendAdjacentSegments;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.snapPortAdjacentSegments;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.snapSegmentsToSnapLines;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.snapBendsToSnapLines;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.snapNodesToSnapLines;
 /** @type {number} */
yfiles.input.GraphSnapContext.prototype.nodeToNodeDistance;
 /** @type {number} */
yfiles.input.GraphSnapContext.prototype.nodeToEdgeDistance;
 /** @type {number} */
yfiles.input.GraphSnapContext.prototype.edgeToEdgeDistance;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.snapOrthogonalMovement;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.collectNodePairCenterSnapLines;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.collectNodePairSnapLines;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.collectNodePairSegmentSnapLines;
 /** @type {yfiles.input.GridSnapTypes} */
yfiles.input.GraphSnapContext.prototype.gridSnapType;
 /** @type {number} */
yfiles.input.GraphSnapContext.prototype.gridSnapDistance;
 /** @type {?<?>} */
yfiles.input.GraphSnapContext.prototype.nodeGridConstraintProvider;
 /** @type {?<?>} */
yfiles.input.GraphSnapContext.prototype.bendGridConstraintProvider;
 /** @type {?<?>} */
yfiles.input.GraphSnapContext.prototype.portGridConstraintProvider;
 /** @type {number} */
yfiles.input.GraphSnapContext.prototype.snapLineExtension;
 /** @type {boolean} */
yfiles.input.GraphSnapContext.prototype.cropSnapLines;
 /** @type {?<!yfiles.input.OrthogonalSnapLine>} */
yfiles.input.GraphSnapContext.prototype.fixedNodeSnapLines;
 /** @type {?<!yfiles.input.OrthogonalSnapLine>} */
yfiles.input.GraphSnapContext.prototype.fixedSegmentSnapLines;
 /** @type {?<!yfiles.input.OrthogonalSnapLine>} */
yfiles.input.GraphSnapContext.prototype.fixedPortSnapLines;
 /** @type {?<!yfiles.input.OrthogonalSnapLine>} */
yfiles.input.GraphSnapContext.prototype.additionalSnapLines;
 /** @type {!yfiles.lang.Class} */
yfiles.input.GraphSnapContext.$class;

/**
 * Adds {\@link yfiles.input.MovementInfo} representing an {\@link yfiles.graph.IBend} that will be considered for the next drag gesture.
 * <p>
 * The default {\@link yfiles.input.IHandle} of an {\@link yfiles.graph.IBend} calls this method in its {\@link yfiles.input.IDragHandler#initializeDrag}
 * method so snap results are calculated when this bend is repositioned. Custom {\@link yfiles.input.IHandle} implementations can
 * add infos created by {\@link yfiles.input.GraphSnapContext#getMovementInfo}.
 * </p>
 * @param {!yfiles.input.MovementInfo} info The {\@link } representing the bend to be moved. Can be created with
 * {\@link #getMovementInfo}.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.addBendToBeMoved = function(info) {};

/**
 * Adds {\@link yfiles.input.MovementInfo} representing the end of an {\@link yfiles.graph.IEdge} that will be considered for the next drag
 * gesture.
 * <p>
 * The {\@link yfiles.input.IHandle} returned by the default {\@link yfiles.input.IEdgePortHandleProvider} of an {\@link yfiles.graph.IEdge} calls
 * this method in its {\@link yfiles.input.IDragHandler#initializeDrag} method so snap results are calculated when reparenting this
 * edge end. Custom {\@link yfiles.input.IHandle} implementations can call {\@link yfiles.input.GraphSnapContext#getMovementInfos} and add
 * the first or last {\@link yfiles.input.MovementInfo} of the returned list.
 * </p>
 * @param {!yfiles.input.MovementInfo} info The {\@link } representing the edge end to be reparented. Can be created with
 * {\@link #getMovementInfos}.
 * @param {boolean} sourceEnd <code>true</code> if the <code>info</code> represents the source end of the edge.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.addEdgeEndToBeMoved = function(info, sourceEnd) {};

/**
 * Adds an item which will be reshaped.
 * @param {?} item The item to be reshaped.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.addItemToBeReshaped = function(item) {};

/**
 * Adds {\@link yfiles.input.MovementInfo} representing an {\@link yfiles.graph.INode} that will be considered for the next drag gesture.
 * <p>
 * The default {\@link yfiles.input.IPositionHandler} of an {\@link yfiles.graph.INode} calls this method in its {\@link yfiles.input.IDragHandler#initializeDrag}
 * method so snap results are calculated when this node is repositioned. Custom {\@link yfiles.input.IPositionHandler}
 * implementations can add infos created by {\@link yfiles.input.GraphSnapContext#getMovementInfo}.
 * </p>
 * @param {!yfiles.input.MovementInfo} info The {\@link } representing the node to be moved. Can be created with
 * {\@link #getMovementInfo}.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.addNodeToBeMoved = function(info) {};

/**
 * Adds an orthogonally moved segment to this context for which this instance will automatically collect
 * {\@link yfiles.input.SnapResult}s and provide a default visualization.
 * <p>
 * This method can be called during initialization to collect orthogonal segments that should be tested against {\@link yfiles.input.GraphSnapContext#fixedSegmentSnapLines} and {\@link yfiles.input.GraphSnapContext#additionalSnapLines}.
 * </p>
 * @param {!yfiles.input.MovementInfo} start The starting point of the manipulated segment.
 * @param {!yfiles.input.MovementInfo} end The end point of the manipulated segment.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.addOrthogonalSegment = function(start, end) {};

/**
 * Adds {\@link yfiles.input.MovementInfo} representing an {\@link yfiles.graph.IPort} that will be considered for the next drag gesture.
 * <p>
 * The default {\@link yfiles.input.IHandle} of an {\@link yfiles.graph.IPort} calls this method in its {\@link yfiles.input.IDragHandler#initializeDrag}
 * method so snap results are calculated for this port. Custom {\@link yfiles.input.IHandle} implementations can add infos created
 * by {\@link yfiles.input.GraphSnapContext#getMovementInfo}.
 * </p>
 * @param {!yfiles.input.MovementInfo} info The {\@link } representing the port to be moved. Can be created with
 * {\@link #getMovementInfo}.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.addPortToBeMoved = function(info) {};

/**
 * Adds an entry for the same-height-snapping.
 * <p>
 * During {\@link yfiles.input.SnapContext#isInitializing initialization} this method can be used to register entries that can later be retrieved using the {\@link yfiles.input.GraphSnapContext#findSameHeightEntries}
 * method. The rectangle will be used to obtain the height value and will also be used for the visualization of the snap
 * result.
 * </p>
 * @see yfiles.input.GraphSnapContext#addSameWidthEntry
 * @param {!yfiles.geometry.Rect} rectangle The rectangle to obtain the height value from. This rectangle will be used for the snap result visualization.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.addSameHeightEntry = function(rectangle) {};

/**
 * Adds an entry for the same-width-snapping.
 * <p>
 * During {\@link yfiles.input.SnapContext#isInitializing initialization} this method can be used to register entries that can later be retrieved using the {\@link yfiles.input.GraphSnapContext#findSameWidthEntries}
 * method. The rectangle will be used to obtain the width value and will also be used for the visualization of the snap
 * result.
 * </p>
 * @see yfiles.input.GraphSnapContext#addSameHeightEntry
 * @param {!yfiles.geometry.Rect} rectangle The rectangle to obtain the width value from. This rectangle will be used for the snap result visualization.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.addSameWidthEntry = function(rectangle) {};

/**
 * Collects the {\@link yfiles.input.OrthogonalSnapLine}s for the nodes which are not moving.
 * <p>
 * Delegates to the {\@link yfiles.input.ISnapLineProvider} implementation in the lookup of the {\@link yfiles.graph.INode}.
 * </p>
 * @protected
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.collectFixedNodeSnapLines = function(evt) {};

/**
 * Collects the {\@link yfiles.input.OrthogonalSnapLine}s for the ports which are not moving.
 * <p>
 * Delegates to the {\@link yfiles.input.ISnapLineProvider} implementation in the lookup of the {\@link yfiles.graph.IPort}.
 * </p>
 * @protected
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.collectFixedPortSnapLines = function(evt) {};

/**
 * Collects snap lines for edge segments.
 * <p>
 * Delegates to the {\@link yfiles.input.ISnapLineProvider} implementation in the lookup of the {\@link yfiles.graph.IEdge}. This
 * implementation should then make us of {\@link yfiles.input.GraphSnapContext#getMovementInfos} to determine what segments are
 * fixed.
 * </p>
 * @protected
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.collectFixedSegmentSnapLines = function(evt) {};

/**
 * Collects all node widths and heights in the collections {\@link yfiles.input.GraphSnapContext#findSameWidthEntries} and
 * {\@link yfiles.input.GraphSnapContext#findSameHeightEntries}.
 * <p>
 * This method will only be called if {\@link yfiles.input.GraphSnapContext#collectNodeSizes} is enabled and delegates to {\@link yfiles.input.GraphSnapContext#addSameHeightEntry} and
 * {\@link yfiles.input.GraphSnapContext#addSameWidthEntry}.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.collectSameSizeEntries = function() {};

/**
 * Finds pairs of nodes that are visually adjacent to create {\@link yfiles.input.GraphSnapContext#collectNodePairCenterSnapLines center} and {\@link yfiles.input.GraphSnapContext#collectNodePairSnapLines same distance} snap lines.
 * @protected
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.collectVisibleNodePairs = function() {};

/**
 * Finds the entries ({\@link yfiles.geometry.Rect}s) that have been registered using the {\@link yfiles.input.GraphSnapContext#addSameHeightEntry}
 * previously that best match the given constraints.
 * @param {number} size The size to find the closest set of identical sizes.
 * @param {number} maxSize The maximum allowed size.
 * @param {number} minSize The minimum allowed size.
 * @return {?<!yfiles.geometry.Rect>} The set of rectangles that have been added previously using {\@link #addSameHeightEntry}.
 */
yfiles.input.GraphSnapContext.prototype.findSameHeightEntries = function(size, maxSize, minSize) {};

/**
 * Finds the entries ({\@link yfiles.geometry.Rect}s) that have been registered using the {\@link yfiles.input.GraphSnapContext#addSameWidthEntry}
 * previously that best match the given constraints.
 * @param {number} size The size to find the closest set of identical sizes.
 * @param {number} maxSize The maximum allowed size.
 * @param {number} minSize The minimum allowed size.
 * @return {?<!yfiles.geometry.Rect>} The set of rectangles that have been added previously using {\@link #addSameWidthEntry}.
 */
yfiles.input.GraphSnapContext.prototype.findSameWidthEntries = function(size, maxSize, minSize) {};

/**
 * Gets a subset of {\@link yfiles.input.GraphSnapContext#additionalSnapLines} that matches the given <code>orientation</code>, <code>snapType</code> and intersects with the provided <code>area</code>.
 * @param {yfiles.input.SnapLineOrientation} orientation The orientation of the lines to return.
 * @param {yfiles.input.SnapLineSnapTypes} snapType The snap type to be included.
 * @param {!yfiles.geometry.Rect} area The area to test for intersection.
 * @return {?<!yfiles.input.OrthogonalSnapLine>} An enumerable of the snap lines that match the provided criteria.
 */
yfiles.input.GraphSnapContext.prototype.getAdditionalSnapLines = function(orientation, snapType, area) {};

/**
 * Gets a subset of {\@link yfiles.input.GraphSnapContext#fixedNodeSnapLines} that matches the given <code>orientation</code>, <code>snapType</code> and intersects with the provided <code>area</code>.
 * @param {yfiles.input.SnapLineOrientation} orientation The orientation of the lines to return.
 * @param {yfiles.input.SnapLineSnapTypes} snapType The snap type to be included.
 * @param {!yfiles.geometry.Rect} area The area to test for intersection.
 * @return {?<!yfiles.input.OrthogonalSnapLine>} An enumerable of the snap lines that match the provided criteria.
 */
yfiles.input.GraphSnapContext.prototype.getFixedNodeSnapLines = function(orientation, snapType, area) {};

/**
 * Gets a subset of {\@link yfiles.input.GraphSnapContext#fixedPortSnapLines} that matches the given <code>orientation</code>, <code>snapType</code> and intersects with the provided <code>area</code>.
 * @param {yfiles.input.SnapLineOrientation} orientation The orientation of the lines to return.
 * @param {yfiles.input.SnapLineSnapTypes} snapType The snap type to be included.
 * @param {!yfiles.geometry.Rect} area The area to test for intersection.
 * @return {?<!yfiles.input.OrthogonalSnapLine>} An enumerable of the snap lines that match the provided criteria.
 */
yfiles.input.GraphSnapContext.prototype.getFixedPortSnapLines = function(orientation, snapType, area) {};

/**
 * Gets a subset of {\@link yfiles.input.GraphSnapContext#fixedSegmentSnapLines} that matches the given <code>orientation</code>, <code>snapType</code> and intersects with the provided <code>area</code>.
 * @param {yfiles.input.SnapLineOrientation} orientation The orientation of the lines to return.
 * @param {yfiles.input.SnapLineSnapTypes} snapType The snap type to be included.
 * @param {!yfiles.geometry.Rect} area The area to test for intersection.
 * @return {?<!yfiles.input.OrthogonalSnapLine>} An enumerable of the snap lines that match the provided criteria.
 */
yfiles.input.GraphSnapContext.prototype.getFixedSegmentSnapLines = function(orientation, snapType, area) {};

/**
 * Gets the movement info for the given port.
 * <p>
 * This is either the info passed to {\@link yfiles.input.GraphSnapContext#addNodeToBeMoved} or another, dynamically created
 * instance, if no specific one had been registered.
 * </p>
 * Gets the movement info for the given node.
 * <p>
 * This is either the info passed to {\@link yfiles.input.GraphSnapContext#addNodeToBeMoved} or another, dynamically created
 * instance, if no specific one had been registered.
 * </p>
 * Gets the movement info for the given bend.
 * <p>
 * This is either the info passed to {\@link yfiles.input.GraphSnapContext#addBendToBeMoved} or a dynamically created instance if no
 * specific one had been registered.
 * </p>
 * @param {?} port_or_node_or_bend The port to obtain the info for. / The node to obtain the info for. / The bend to obtain the info for.
 * @return {!yfiles.input.MovementInfo} An instance of {\@link } that describes the movement of the port. / An instance of {\@link } that describes the movement of the node. / An instance of {\@link } that describes the movement of the bend.
 */
yfiles.input.GraphSnapContext.prototype.getMovementInfo = function(port_or_node_or_bend) {};

/**
 * Gets the {\@link yfiles.input.MovementInfo movement information} for the provided edge.
 * <p>
 * The result describes the shape of the edge and the reshaping behavior of the geometry. The first element in the
 * enumerable is the source end of the edge, followed by bend like elements and the target side. Note that it cannot in
 * general be assumed {\@link yfiles.input.MovementInfo#movedItem} of the first and last element is either a {\@link yfiles.graph.IPort} or {\@link yfiles.graph.IEdge}, also items in
 * between may not necessarily be bound to {\@link yfiles.graph.IBend}s and therefore their {\@link yfiles.input.MovementInfo#movedItem} can be of a different type than
 * {\@link yfiles.graph.IBend}.
 * </p>
 * @param {?} edge The edge to obtain the movement information of.
 * @return {?<!yfiles.input.MovementInfo>} An {\@link } of {\@link }s items that describe the geometry of the edge being modified.
 */
yfiles.input.GraphSnapContext.prototype.getMovementInfos = function(edge) {};

/**
 * Raises the {\@link yfiles.input.GraphSnapContext#addCollectSnapLinesListener CollectSnapLines} event.
 * @protected
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.onCollectSnapLines = function(evt) {};

/**
 * Adds the given listener for the <code>CollectSnapLines</code> event that occurs every time this instance has been {\@link yfiles.input.SnapContext#dragInitialized initialized} to
 * collect {\@link yfiles.input.OrthogonalSnapLine}s.
 * <p>
 * Event handlers should add snap lines to the caller using the methods provided by
 * {\@link yfiles.input.CollectGraphSnapLinesEventArgs}.
 * </p>
 * @see yfiles.input.GraphSnapContext#removeCollectSnapLinesListener
 * @param {function(!Object, !yfiles.input.CollectGraphSnapLinesEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.addCollectSnapLinesListener = function(listener) {};

/**
 * Removes the given listener for the <code>CollectSnapLines</code> event that occurs every time this instance has been {\@link yfiles.input.SnapContext#dragInitialized initialized} to
 * collect {\@link yfiles.input.OrthogonalSnapLine}s.
 * <p>
 * Event handlers should add snap lines to the caller using the methods provided by
 * {\@link yfiles.input.CollectGraphSnapLinesEventArgs}.
 * </p>
 * @see yfiles.input.GraphSnapContext#addCollectSnapLinesListener
 * @param {function(!Object, !yfiles.input.CollectGraphSnapLinesEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphSnapContext.prototype.removeCollectSnapLinesListener = function(listener) {};

/** @const */
yfiles.input.MoveTypes = {};
/** @const {number} */
yfiles.input.MoveTypes.FIXED;
/** @const {number} */
yfiles.input.MoveTypes.LINEAR_MOVE_X;
/** @const {number} */
yfiles.input.MoveTypes.LINEAR_MOVE_Y;
/** @const {number} */
yfiles.input.MoveTypes.LINEAR_MOVE;
/** @const {number} */
yfiles.input.MoveTypes.ARBITRARY_MOVE_X;
/** @const {number} */
yfiles.input.MoveTypes.ARBITRARY_MOVE_Y;
/** @const {number} */
yfiles.input.MoveTypes.ARBITRARY_MOVE;
/** @const {number} */
yfiles.input.MoveTypes.MOVEMENT_X;
/** @const {number} */
yfiles.input.MoveTypes.MOVEMENT_Y;
/**
 * @record
 * @struct
 */
yfiles.input.MovementInfo = function() {};
 /** @type {?} */
yfiles.input.MovementInfo.prototype.movedItem;
 /** @type {!yfiles.input.MovementInfo} */
yfiles.input.MovementInfo.prototype.horizontalAnchor;
 /** @type {!yfiles.input.MovementInfo} */
yfiles.input.MovementInfo.prototype.verticalAnchor;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.MovementInfo.prototype.originalLocation;
 /** @type {?} */
yfiles.input.MovementInfo.prototype.currentLocation;
 /** @type {yfiles.input.MoveTypes} */
yfiles.input.MovementInfo.prototype.moveType;
 /** @type {boolean} */
yfiles.input.MovementInfo.prototype.isVerticallyFixed;
 /** @type {boolean} */
yfiles.input.MovementInfo.prototype.isHorizontallyFixed;
 /** @type {!yfiles.lang.Class} */
yfiles.input.MovementInfo.$class;

/**
 * Gets the new x coordinate of the element if the mouse has been moved by <code>dx</code> during the gesture.
 * <p>
 * This takes the {\@link yfiles.input.MovementInfo#moveType} and {\@link yfiles.input.MovementInfo#originalLocation} into account.
 * </p>
 * @param {number} dx The delta x coordinate.
 * @return {number} The new x coordinate.
 */
yfiles.input.MovementInfo.prototype.getX = function(dx) {};

/**
 * Gets the new y coordinate of the element if the mouse has been moved by <code>dy</code> during the gesture.
 * <p>
 * This takes the {\@link yfiles.input.MovementInfo#moveType} and {\@link yfiles.input.MovementInfo#originalLocation} into account.
 * </p>
 * @param {number} dy The delta y coordinate.
 * @return {number} The new y coordinate.
 */
yfiles.input.MovementInfo.prototype.getY = function(dy) {};

/**
 * Determines whether this instances moves synchronized with the provided info.
 * @see yfiles.input.MovementInfo#horizontalAnchor
 * @param {!yfiles.input.MovementInfo} info The info to check.
 * @return {boolean} Whether this info and the given info move horizontally synchronized.
 */
yfiles.input.MovementInfo.prototype.movesHorizontallySynchronizedWith = function(info) {};

/**
 * Determines whether this instances moves synchronized with the provided info.
 * @see yfiles.input.MovementInfo#verticalAnchor
 * @param {!yfiles.input.MovementInfo} info The info to check.
 * @return {boolean} Whether this info and the given info move vertically synchronized.
 */
yfiles.input.MovementInfo.prototype.movesVerticallySynchronizedWith = function(info) {};
/**
 * @record
 * @struct
 */
yfiles.input.SnapLine = function() {};
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_FIXED_LINE_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_EDGE_SEGMENT_KEY;
 /** @type {string} */
yfiles.input.SnapLine.GRID_LINE_FIXED_LINE_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_VARIABLE_LINE_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_BLANK_VARIABLE_LINE_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_EXTENDED_VARIABLE_LINE_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_FIXED_DISTANCE_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_CENTER_BETWEEN_BOUNDS_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_CENTER_BETWEEN_CENTERS_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_EQUAL_DISTANCE_BETWEEN_BOUNDS_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_EQUAL_DISTANCE_BETWEEN_CENTERS_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_EQUAL_WIDTH_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_EQUAL_HEIGHT_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_TO_GRID_KEY;
 /** @type {string} */
yfiles.input.SnapLine.SNAP_LINE_STROKE_KEY;
 /** @type {yfiles.input.SnapLineSnapTypes} */
yfiles.input.SnapLine.prototype.snapType;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.SnapLine.prototype.coordinates;
 /** @type {!Object} */
yfiles.input.SnapLine.prototype.tag;
 /** @type {number} */
yfiles.input.SnapLine.prototype.weight;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.SnapLine.prototype.from;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.SnapLine.prototype.to;
 /** @type {string} */
yfiles.input.SnapLine.prototype.resourceKey;
 /** @type {!yfiles.lang.Class} */
yfiles.input.SnapLine.$class;
/**
 * @record
 * @struct
 */
yfiles.input.OrthogonalSnapLine = function() {};
 /** @type {yfiles.input.SnapLineOrientation} */
yfiles.input.OrthogonalSnapLine.prototype.orientation;
 /** @type {!yfiles.lang.Class} */
yfiles.input.OrthogonalSnapLine.$class;
/**
 * @record
 * @struct
 */
yfiles.input.NodeBasedSnapLine = function() {};
 /** @type {?} */
yfiles.input.NodeBasedSnapLine.prototype.node;
 /** @type {!yfiles.lang.Class} */
yfiles.input.NodeBasedSnapLine.$class;
/**
 * @record
 * @struct
 */
yfiles.input.NodePairBasedSnapLine = function() {};
 /** @type {?} */
yfiles.input.NodePairBasedSnapLine.prototype.firstNode;
 /** @type {?} */
yfiles.input.NodePairBasedSnapLine.prototype.secondNode;
 /** @type {!yfiles.lang.Class} */
yfiles.input.NodePairBasedSnapLine.$class;
/**
 * @record
 * @struct
 */
yfiles.input.PointBasedSnapLine = function() {};
 /** @type {?} */
yfiles.input.PointBasedSnapLine.prototype.point;
 /** @type {!yfiles.lang.Class} */
yfiles.input.PointBasedSnapLine.$class;
/**
 * @record
 * @struct
 */
yfiles.input.EdgeSegmentSnapLine = function() {};
 /** @type {?} */
yfiles.input.EdgeSegmentSnapLine.prototype.edge;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.EdgeSegmentSnapLine.prototype.direction;
 /** @type {number} */
yfiles.input.EdgeSegmentSnapLine.prototype.distance;
 /** @type {number} */
yfiles.input.EdgeSegmentSnapLine.prototype.segmentIndex;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.EdgeSegmentSnapLine.prototype.segmentSource;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.EdgeSegmentSnapLine.prototype.segmentTarget;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.EdgeSegmentSnapLine.prototype.sourceMarker;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.EdgeSegmentSnapLine.prototype.targetMarker;
 /** @type {!yfiles.lang.Class} */
yfiles.input.EdgeSegmentSnapLine.$class;

/** @const */
yfiles.input.SnapLineOrientation = {};
/** @const {number} */
yfiles.input.SnapLineOrientation.HORIZONTAL;
/** @const {number} */
yfiles.input.SnapLineOrientation.VERTICAL;

/** @const */
yfiles.input.SnapLineSnapTypes = {};
/** @const {number} */
yfiles.input.SnapLineSnapTypes.NONE;
/** @const {number} */
yfiles.input.SnapLineSnapTypes.TOP;
/** @const {number} */
yfiles.input.SnapLineSnapTypes.BOTTOM;
/** @const {number} */
yfiles.input.SnapLineSnapTypes.LEFT;
/** @const {number} */
yfiles.input.SnapLineSnapTypes.RIGHT;
/** @const {number} */
yfiles.input.SnapLineSnapTypes.CENTER;
/** @const {number} */
yfiles.input.SnapLineSnapTypes.VERTICAL;
/** @const {number} */
yfiles.input.SnapLineSnapTypes.HORIZONTAL;
/** @const {number} */
yfiles.input.SnapLineSnapTypes.ALL;
/**
 * @record
 * @struct
 */
yfiles.input.DefaultPortCandidate = function() {};
 /** @type {yfiles.input.PortCandidateValidity} */
yfiles.input.DefaultPortCandidate.prototype.validity;
 /** @type {!Object} */
yfiles.input.DefaultPortCandidate.prototype.candidateTag;
 /** @type {!Object} */
yfiles.input.DefaultPortCandidate.prototype.portTag;
 /** @type {?} */
yfiles.input.DefaultPortCandidate.prototype.locationParameter;
 /** @type {?} */
yfiles.input.DefaultPortCandidate.prototype.model;
 /** @type {?} */
yfiles.input.DefaultPortCandidate.prototype.style;
 /** @type {?} */
yfiles.input.DefaultPortCandidate.prototype.owner;
 /** @type {?} */
yfiles.input.DefaultPortCandidate.prototype.port;
 /** @type {!yfiles.lang.Class} */
yfiles.input.DefaultPortCandidate.$class;

/**
 * Actually creates the {\@link yfiles.graph.IPort} instance.
 * <p>
 * This method is called in response to a call to {\@link yfiles.input.DefaultPortCandidate#createPort} on this instance and the
 * instances created by {\@link yfiles.input.DefaultPortCandidate#getPortCandidateAt}.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {?} graph The graph to add the port to.
 * @param {?} locationParameter The parameter to use.
 * @param {?} style The style to use.
 * @param {!Object} tag The tag to use.
 * @return {?} The newly created port.
 */
yfiles.input.DefaultPortCandidate.prototype.createInstance = function(context, graph, locationParameter, style, tag) {};

/**
 * This implementation will throw a {\@link yfiles.lang.Exception} if the validity is {\@link yfiles.input.PortCandidateValidity#DYNAMIC}.
 * <p>
 * This implementation will delegate to the {\@link yfiles.input.DefaultPortCandidate#createInstance} method.
 * </p>
 * @param {?} context
 * @return {?}
 */
yfiles.input.DefaultPortCandidate.prototype.createPort = function(context) {};

/**
 * Returns a candidate that is derived from this instance that best fits the provided <code>location</code>.
 * <p>
 * The returned implementation will finally call {\@link yfiles.input.DefaultPortCandidate#createInstance} using the newly
 * calculated {\@link yfiles.input.DefaultPortCandidate#locationParameter}.
 * </p>
 * @see yfiles.input.DefaultPortCandidate#validity
 * @param {?} context The input mode context for which a concrete candidate is queried.
 * @param {!yfiles.geometry.Point} location The location for which a candidate should be returned.
 * @return {?} A {\@link } implementation whose {\@link #validity} is guaranteed to be non-{\@link #DYNAMIC}.
 */
yfiles.input.DefaultPortCandidate.prototype.getPortCandidateAt = function(context, location) {};

/**
 * Sets the instance that will be returned by {\@link yfiles.input.DefaultPortCandidate#port} and {\@link yfiles.input.DefaultPortCandidate#createPort}.
 * @param {?} port A port that already exists in the graph or <code>null</code>.
 * @return {void}
 */
yfiles.input.DefaultPortCandidate.prototype.setInstance = function(port) {};
/**
 * @record
 * @struct
 */
yfiles.input.GroupingNodePositionHandler = function() {};
 /** @type {?} */
yfiles.input.GroupingNodePositionHandler.prototype.location;
 /** @type {!yfiles.lang.Class} */
yfiles.input.GroupingNodePositionHandler.$class;

/**
 *
 * @param {?} inputModeContext
 * @param {!yfiles.geometry.Point} originalLocation
 * @return {void}
 */
yfiles.input.GroupingNodePositionHandler.prototype.cancelDrag = function(inputModeContext, originalLocation) {};

/**
 *
 * @param {?} inputModeContext
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.GroupingNodePositionHandler.prototype.dragFinished = function(inputModeContext, originalLocation, newLocation) {};

/**
 *
 * @param {?} inputModeContext
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.GroupingNodePositionHandler.prototype.handleMove = function(inputModeContext, originalLocation, newLocation) {};

/**
 *
 * @param {?} inputModeContext
 * @return {void}
 */
yfiles.input.GroupingNodePositionHandler.prototype.initializeDrag = function(inputModeContext) {};

/**
 * Sets a temporary visual parent for the node during reparenting.
 * <p>
 * This is used to show the grouping hierarchy level a node would end in after finishing the reparenting gesture. Override
 * this method with an empty implementation to not change the z-order of the dragged node during the gesture.
 * </p>
 * @param {?} inputModeContext The current {\@link }.
 * @param {?} node The node being reparented.
 * @param {?} parent The temporary parent for the node.
 * @return {void}
 */
yfiles.input.GroupingNodePositionHandler.prototype.setCurrentParent = function(inputModeContext, node, parent) {};
/**
 * @record
 * @struct
 */
yfiles.input.IBendCreator = function() {};

/**
 * Creates a bend at the given graph for the given edge at the position supplied.
 * @abstract
 * @param {?} context The context for which the bend should be created.
 * @param {?} graph The graph, the edge belongs to.
 * @param {?} edge The edge.
 * @param {!yfiles.geometry.Point} location The preferred coordinates of the bend.
 * @return {number} The index of the bend in the edges' {\@link #bends} or <code>-1</code> if no bend has been created.
 */
yfiles.input.IBendCreator.prototype.createBend = function(context, graph, edge, location) {};
 /** @type {{NO_BENDS: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IBendCreator;
/**
 * @record
 * @struct
 */
yfiles.input.IBendSelectionTester = function() {};

/**
 * Returns the bends within the given rectangle.
 * @abstract
 * @param {?} context The input mode context to use for querying the position.
 * @param {!yfiles.geometry.Rect} rectangle A rectangle in world coordinates.
 * @return {?<?>} The bends inside of <code>rectangle</code>.
 */
yfiles.input.IBendSelectionTester.prototype.getBendsInBox = function(context, rectangle) {};

/**
 * Returns the bend at the given world coordinate position.
 * @abstract
 * @param {?} context The input mode context to use for querying the position.
 * @param {!yfiles.geometry.Point} location A location in world coordinates.
 * @return {?} The bend at the position or <code>null</code> if there is no bend.
 */
yfiles.input.IBendSelectionTester.prototype.getHitBend = function(context, location) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IBendSelectionTester;
/**
 * @record
 * @struct
 */
yfiles.input.IContainsBendTester = function() {};

/**
 * Determines whether the provided <code>bend</code> is deemed to lie within the shape this test is implemented for.
 * <p>
 * This method is used to determine which bends of edges that connect child nodes are moved when the parent node is moved.
 * If an implementation of {\@link yfiles.input.IContainsBendTester} is present in the node's {\@link yfiles.graph.ILookup#lookup}, this
 * method is called with the bend and the bend will be moved together with the parent node iff <code>true</code> is returned. If no
 * implemention is provided, only bends that lie inside the bounds of the parent node are moved.
 * </p>
 * @abstract
 * @param {?} context The input mode context to use.
 * @param {?} bend The bend to test
 * @return {boolean} <code>true</code> iff the bend is contained within the shape.
 */
yfiles.input.IContainsBendTester.prototype.contains = function(context, bend) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IContainsBendTester;
/**
 * @record
 * @struct
 */
yfiles.input.INodeSnapResultProvider = function() {};

/**
 * Called when a node is {\@link yfiles.input.IDragHandler#handleMove dragged} to add {\@link yfiles.input.SnapResult}s for
 * {\@link yfiles.input.OrthogonalSnapLine}s to which this node can potentially snap.
 * @abstract
 * @param {!yfiles.input.GraphSnapContext} context The snap context which manages the snap lines and the settings.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The event argument to obtain the necessary information from and {\@link #addSnapResult add results to}.
 * @param {!yfiles.geometry.Rect} suggestedLayout The {\@link #layout layout} of the node if the node would not snap.
 * @param {?} node The node that is being moved.
 * @return {void}
 */
yfiles.input.INodeSnapResultProvider.prototype.collectSnapResults = function(context, evt, suggestedLayout, node) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.INodeSnapResultProvider;
/**
 * @record
 * @struct
 */
yfiles.input.IEdgeSnapResultProvider = function() {};

/**
 * Called to during the snapping operation whenever {\@link yfiles.input.SnapContext#addCollectSnapResultsListener snap results are collected}.
 * <p>
 * This method will be called for each collection of the results.
 * </p>
 * @abstract
 * @param {!yfiles.input.GraphSnapContext} context The context that is using this instance.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The event argument to obtain the necessary information from and {\@link #addSnapResult add results to}.
 * @param {?<!yfiles.input.MovementInfo>} movementInfos The movement infos that describe the <code>edge</code>.
 * @param {?} edge The edge for which the {\@link }s should be {\@link #addSnapResult collected}.
 * @return {void}
 */
yfiles.input.IEdgeSnapResultProvider.prototype.collectSnapResults = function(context, evt, movementInfos, edge) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IEdgeSnapResultProvider;
/**
 * @record
 * @struct
 */
yfiles.input.IBendSnapResultProvider = function() {};

/**
 * Called when a node is {\@link yfiles.input.IDragHandler#handleMove dragged} to add {\@link yfiles.input.SnapResult}s for
 * {\@link yfiles.input.OrthogonalSnapLine}s to which this bend can potentially snap.
 * @abstract
 * @param {!yfiles.input.GraphSnapContext} context The snap context which manages the snap lines and the settings.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The event argument to obtain the necessary information from and {\@link #addSnapResult add results to}.
 * @param {!yfiles.geometry.Point} suggestedLocation The {\@link #location location} of the bend if the bend would not snap.
 * @param {?} bend The bend that is being moved.
 * @return {void}
 */
yfiles.input.IBendSnapResultProvider.prototype.collectSnapResults = function(context, evt, suggestedLocation, bend) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IBendSnapResultProvider;
/**
 * @record
 * @struct
 */
yfiles.input.IPortSnapResultProvider = function() {};

/**
 * Called when a node is {\@link yfiles.input.IDragHandler#handleMove dragged} to add {\@link yfiles.input.SnapResult}s for
 * {\@link yfiles.input.OrthogonalSnapLine}s to which this bend can potentially snap.
 * @abstract
 * @param {!yfiles.input.GraphSnapContext} context The snap context which manages the snap lines and the settings.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The event argument to obtain the necessary information from and {\@link #addSnapResult add results to}.
 * @param {!yfiles.geometry.Point} suggestedLocation The {\@link #location location} of the bend if the bend would not snap.
 * @param {?} port The port that is being moved
 * @return {void}
 */
yfiles.input.IPortSnapResultProvider.prototype.collectSnapResults = function(context, evt, suggestedLocation, port) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IPortSnapResultProvider;
/**
 * @record
 * @struct
 */
yfiles.input.INodeReshapeSnapResultProvider = function() {};

/**
 * Called when a node's handle is {\@link yfiles.input.IDragHandler#handleMove dragged} to add {\@link yfiles.input.SnapResult}s for
 * {\@link yfiles.input.OrthogonalSnapLine}s or sizes to which this node can potentially snap during resizing.
 * @abstract
 * @param {!yfiles.input.GraphSnapContext} context The snap context which manages the snap lines and the settings.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The event argument to obtain the context from and add the results to.
 * @param {?} node The node that is being reshaped.
 * @param {!yfiles.input.ReshapeRectangleContext} reshapeContext Carries information about the reshape operation.
 * @return {void}
 */
yfiles.input.INodeReshapeSnapResultProvider.prototype.collectSnapResults = function(context, evt, node, reshapeContext) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.INodeReshapeSnapResultProvider;
/**
 * @record
 * @struct
 */
yfiles.input.ReshapeRectangleContext = function() {};
 /** @type {!yfiles.geometry.Rect} */
yfiles.input.ReshapeRectangleContext.prototype.initialBounds;
 /** @type {?} */
yfiles.input.ReshapeRectangleContext.prototype.minimumSize;
 /** @type {?} */
yfiles.input.ReshapeRectangleContext.prototype.maximumSize;
 /** @type {?} */
yfiles.input.ReshapeRectangleContext.prototype.minimumEnclosedArea;
 /** @type {yfiles.input.HandlePositions} */
yfiles.input.ReshapeRectangleContext.prototype.reshapePosition;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.ReshapeRectangleContext.prototype.topLeftChangeFactor;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.ReshapeRectangleContext.prototype.bottomRightChangeFactor;
 /** @type {!yfiles.geometry.Size} */
yfiles.input.ReshapeRectangleContext.prototype.sizeChangeFactor;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ReshapeRectangleContext.$class;
/**
 * @record
 * @struct
 */
yfiles.input.IPortCandidate = function() {};
 /** @type {!Object} */
yfiles.input.IPortCandidate.prototype.candidateTag;
 /** @type {yfiles.input.PortCandidateValidity} */
yfiles.input.IPortCandidate.prototype.validity;
 /** @type {?} */
yfiles.input.IPortCandidate.prototype.locationParameter;
 /** @type {?} */
yfiles.input.IPortCandidate.prototype.owner;
 /** @type {?} */
yfiles.input.IPortCandidate.prototype.port;

/**
 * If the client decides to use this port candidate, this method will serve as a factory to create the instance.
 * <p>
 * If this candidate wraps an existing port, it may return that {\@link yfiles.input.IPortCandidate#port instance}. If this instance's {\@link yfiles.input.IPortCandidate#validity} is {\@link yfiles.input.PortCandidateValidity#DYNAMIC}
 * this method may throw an {\@link yfiles.lang.Exception}.
 * </p>
 * @throws {Stubs.Exceptions.NotSupportedError} If the {\@link yfiles.input.IPortCandidate#validity} is {\@link yfiles.input.PortCandidateValidity#DYNAMIC}.
 * @see yfiles.input.IInputModeContext#graph
 * @see yfiles.input.IPortCandidate#port
 * @see yfiles.input.IPortCandidate#getPortCandidateAt
 * @abstract
 * @param {?} context The input mode context for which the port will be created. Implementations can depend on it providing an {\@link }
 * instance in the lookup of the instance.
 * @return {?} The port instance to use if this candidate has been chosen. This method may not return <code>null</code>.
 */
yfiles.input.IPortCandidate.prototype.createPort = function(context) {};

/**
 * Returns a candidate that is derived from this instance that best fits the provided <code>location</code>.
 * <p>
 * This method needs to be called by clients if the {\@link yfiles.input.IPortCandidate#validity} of this instance is {\@link yfiles.input.PortCandidateValidity#DYNAMIC}. In
 * that case calling this method must return an instance whose validity is not {\@link yfiles.input.PortCandidateValidity#DYNAMIC}.
 * </p>
 * @see yfiles.input.IPortCandidate#validity
 * @abstract
 * @param {?} context The input mode context for which a concrete candidate is queried.
 * @param {!yfiles.geometry.Point} location The location for which a candidate should be returned.
 * @return {?} A {\@link } implementation whose {\@link #validity} is guaranteed to be non-{\@link #DYNAMIC}.
 */
yfiles.input.IPortCandidate.prototype.getPortCandidateAt = function(context, location) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IPortCandidate;

/** @const */
yfiles.input.PortCandidateValidity = {};
/** @const {number} */
yfiles.input.PortCandidateValidity.VALID;
/** @const {number} */
yfiles.input.PortCandidateValidity.INVALID;
/** @const {number} */
yfiles.input.PortCandidateValidity.DYNAMIC;
/**
 * @record
 * @struct
 */
yfiles.input.IPortCandidateProvider = function() {};

/**
 * Returns all port candidates that apply for the provided opposite port candidate.
 * <p>
 * The enumerable may both contain {\@link yfiles.input.PortCandidateValidity valid, invalid, and dynamic} port candidates.
 * </p>
 * @abstract
 * Returns all source port candidates that belong to the context of this provider.
 * <p>
 * The enumerable may both contain {\@link yfiles.input.PortCandidateValidity valid, invalid, and dynamic} port candidates.
 * </p>
 * @abstract
 * @param {?} context The context for which the candidates should be provided.
 * @param {?=} target The opposite port candidate.
 * @return {?<?>} An enumerable over all port candidates that are associated with the given opposite port. / An enumerable over all source port candidates that are associated with the current context.
 */
yfiles.input.IPortCandidateProvider.prototype.getSourcePortCandidates = function(context, target) {};

/**
 * Returns all port candidates that apply for the provided opposite port candidate.
 * <p>
 * The enumerable may both contain {\@link yfiles.input.PortCandidateValidity valid, invalid, and dynamic} port candidates.
 * </p>
 * @abstract
 * Returns all target port candidates that belong to the context of this provider.
 * <p>
 * The enumerable may both contain {\@link yfiles.input.PortCandidateValidity valid, invalid, and dynamic} port candidates.
 * </p>
 * @abstract
 * @param {?} context The context for which the candidates should be provided.
 * @param {?=} source The opposite port candidate.
 * @return {?<?>} An enumerable over all port candidates that are associated with the given opposite port. / An enumerable over all target port candidates that are associated with the current context.
 */
yfiles.input.IPortCandidateProvider.prototype.getTargetPortCandidates = function(context, source) {};
 /** @type {{combine: ?, fromCandidates: ?, fromExistingPorts: function(?): ?, fromNodeCenter: function(?): !yfiles.input.PortCandidateProviderBase, fromPortDefaults: function(?): ?, fromShapeGeometry: ?, fromUnoccupiedPorts: function(?): ?, NO_CANDIDATES: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IPortCandidateProvider;
/**
 * @record
 * @struct
 */
yfiles.input.IEdgeReconnectionPortCandidateProvider = function() {};

/**
 * Returns all source port candidates that may be used for the edge.
 * <p>
 * The enumerable may both contain {\@link yfiles.input.PortCandidateValidity valid, invalid, and dynamic} port candidates.
 * </p>
 * @abstract
 * @param {?} context The context for which the candidates should be provided.
 * @return {?<?>} An enumerable over all source port candidates that are associated with the current context edge.
 */
yfiles.input.IEdgeReconnectionPortCandidateProvider.prototype.getSourcePortCandidates = function(context) {};

/**
 * Returns all source port candidates that may be used for the edge.
 * <p>
 * The enumerable may both contain {\@link yfiles.input.PortCandidateValidity valid, invalid, and dynamic} port candidates.
 * </p>
 * @abstract
 * @param {?} context The context for which the candidates should be provided.
 * @return {?<?>} An enumerable over all target port candidates that are associated with the current context edge.
 */
yfiles.input.IEdgeReconnectionPortCandidateProvider.prototype.getTargetPortCandidates = function(context) {};
 /** @type {{fromSourceAndTarget: function(?): ?, ALL_NODE_CANDIDATES: ?, ALL_NODE_AND_EDGE_CANDIDATES: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IEdgeReconnectionPortCandidateProvider;
/**
 * @record
 * @struct
 */
yfiles.input.IPortSelectionTester = function() {};

/**
 * Returns the port at the given world coordinate position or <code>null</code> if there is no such port.
 * @abstract
 * @param {?} context The input mode context to use for querying the position.
 * @param {!yfiles.geometry.Point} location The coordinates of the position in the world coordinate system.
 * @return {?} The port at the position or <code>null</code>.
 */
yfiles.input.IPortSelectionTester.prototype.getHitPort = function(context, location) {};

/**
 * Returns the ports for the given marquee rectangle.
 * @abstract
 * @param {?} context The input mode context to use for querying the position.
 * @param {!yfiles.geometry.Rect} rectangle The marquee selection box in the world coordinate system.
 * @return {?<?>} An enumerable over the ports inside the marquee selection box.
 */
yfiles.input.IPortSelectionTester.prototype.getPortsInBox = function(context, rectangle) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IPortSelectionTester;
/**
 * @record
 * @struct
 */
yfiles.input.INodeInsetsProvider = function() {};

/**
 * Returns the insets for the given <code>node</code>.
 * @abstract
 * @param {?} node The node to yield insets for.
 * @return {!yfiles.geometry.Insets} The insets for the node.
 */
yfiles.input.INodeInsetsProvider.prototype.getInsets = function(node) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.INodeInsetsProvider;
/**
 * @record
 * @struct
 */
yfiles.input.ICommand = function() {};

/**
 * Determines whether this command be executed with respect to the given parameter and target.
 * @abstract
 * Determines whether this command be executed with respect to the given parameter and target.
 * @abstract
 * @param {!Object|{parameter: !Object, target: !Object}=} parameter_or_options
 * @param {!Object=} target
 * @return {boolean} Whether {\@link #execute} can be called with the given <code>parameter</code> and <code>target</code>.
 */
yfiles.input.ICommand.prototype.canExecute = function(parameter_or_options, target) {};

/**
 * Executes this command with respect to the given parameter and target.
 * @abstract
 * Executes this command with respect to the given parameter and target.
 * @abstract
 * @param {!Object|{parameter: !Object, target: !Object}=} parameter_or_options
 * @param {!Object=} target
 * @return {void}
 */
yfiles.input.ICommand.prototype.execute = function(parameter_or_options, target) {};

/**
 * Adds the given listener for the <code>CanExecuteChanged</code> event that occurs when the result of a call to {\@link yfiles.input.ICommand#canExecute}
 * may yield a different result.
 * @see yfiles.input.ICommand#removeCanExecuteChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ICommand.prototype.addCanExecuteChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>CanExecuteChanged</code> event that occurs when the result of a call to {\@link yfiles.input.ICommand#canExecute}
 * may yield a different result.
 * @see yfiles.input.ICommand#addCanExecuteChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ICommand.prototype.removeCanExecuteChangedListener = function(listener) {};
 /** @type {{createCommand: function(string): ?, invalidateRequerySuggested: function(): void, SELECT_ITEM: ?, TOGGLE_ITEM_SELECTION: ?, DESELECT_ITEM: ?, EDIT_LABEL: ?, ADD_LABEL: ?, GROUP_SELECTION: ?, ADJUST_GROUP_NODE_SIZE: ?, UNGROUP_SELECTION: ?, DESELECT_ALL: ?, EXPAND_GROUP: ?, COLLAPSE_GROUP: ?, TOGGLE_EXPANSION_STATE: ?, ENTER_GROUP: ?, EXIT_GROUP: ?, BEGIN_EDGE_CREATION: ?, DUPLICATE: ?, REVERSE_EDGE: ?, PRINT: ?, CLOSE: ?, HELP: ?, PROPERTIES: ?, NEW: ?, OPEN: ?, SELECT_ALL: ?, DELETE: ?, SAVE: ?, CUT: ?, COPY: ?, PASTE: ?, UNDO: ?, REDO: ?, PRINT_PREVIEW: ?, SCROLL_PAGE_UP: ?, SCROLL_PAGE_DOWN: ?, SCROLL_PAGE_LEFT: ?, SCROLL_PAGE_RIGHT: ?, MOVE_LEFT: ?, MOVE_RIGHT: ?, MOVE_UP: ?, MOVE_DOWN: ?, MOVE_TO_PAGE_UP: ?, MOVE_TO_PAGE_DOWN: ?, MOVE_FOCUS_BACK: ?, MOVE_FOCUS_FORWARD: ?, MOVE_FOCUS_UP: ?, MOVE_FOCUS_DOWN: ?, MOVE_FOCUS_PAGE_UP: ?, MOVE_FOCUS_PAGE_DOWN: ?, EXTEND_SELECTION_LEFT: ?, EXTEND_SELECTION_RIGHT: ?, EXTEND_SELECTION_UP: ?, EXTEND_SELECTION_DOWN: ?, SELECT_TO_PAGE_UP: ?, SELECT_TO_PAGE_DOWN: ?, INCREASE_ZOOM: ?, DECREASE_ZOOM: ?, ZOOM: ?, SET_CURRENT_ITEM: ?, FIT_GRAPH_BOUNDS: ?, ZOOM_TO_CURRENT_ITEM: ?, FIT_CONTENT: ?, UPDATE_CONTENT_RECT: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.ICommand;
/**
 * @record
 * @struct
 */
yfiles.input.EventRecognizers = function() {};
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.EventRecognizers.ALWAYS;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.EventRecognizers.NEVER;
 /** @type {!yfiles.lang.Class} */
yfiles.input.EventRecognizers.$class;

/**
 * Creates an instance that is the logical 'and' combination of the provided recognizers.
 * @param {...function(!Object, !yfiles.lang.EventArgs): boolean} recognizers The recognizers to perform the logical operation on.
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean} An instance that is the result of the logical 'and' operation of the provided instances.
 */
yfiles.input.EventRecognizers.createAndRecognizer = function(recognizers) {};

/**
 * Creates an instance that is the logical 'or' combination of the provided recognizers.
 * @param {...function(!Object, !yfiles.lang.EventArgs): boolean} recognizers The recognizers to perform the logical operation on.
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean} An instance that is the result of the logical 'or' operation of the provided instances.
 */
yfiles.input.EventRecognizers.createOrRecognizer = function(recognizers) {};

/**
 * Creates an event recognizer instance that yields the boolean inverse of the given event recognizer.
 * @param {function(!Object, !yfiles.lang.EventArgs): boolean} recognizer The recognizer to invert.
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean} An implementation that performs the logical negation for the argument.
 */
yfiles.input.EventRecognizers.inverse = function(recognizer) {};
/**
 * @record
 * @struct
 */
yfiles.input.KeyEventRecognizers = function() {};
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.ESCAPE_TYPED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.KEY_PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.KEY_TYPED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.KEY_RELEASED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.ESCAPE_PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.DELETE_PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.ESCAPE_RELEASED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.SHIFT_PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.ALT_PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.CONTROL_PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.META_PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.SHIFT_DOWN;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.SHIFT_UP;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.CTRL_DOWN;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.KeyEventRecognizers.CTRL_UP;
 /** @type {!yfiles.lang.Class} */
yfiles.input.KeyEventRecognizers.$class;

/**
 * Creates an event recognizer for a given key and type using a given set of modifiers.
 * @param {yfiles.view.KeyEventType} type The type of the event.
 * @param {yfiles.view.Key} value The key that is subject of the event.
 * @param {yfiles.view.ModifierKeys=} modifiers
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean}
 */
yfiles.input.KeyEventRecognizers.create = function(type, value, modifiers) {};

/**
 * Creates an event recognizer that matches key presses.
 * @param {yfiles.view.Key} key The key to create the recognizer for.
 * @param {yfiles.view.ModifierKeys=} modifiers
 * @return {function(!Object, !yfiles.lang.EventArgs): boolean} An event recognizer that uses the gesture.
 */
yfiles.input.KeyEventRecognizers.createKeyPress = function(key, modifiers) {};
/**
 * @record
 * @struct
 */
yfiles.input.MouseEventRecognizers = function() {};
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.MOVED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.MOVED_OR_DRAGGED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.RELEASED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.LOST_CAPTURE;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.LOST_CAPTURE_DURING_DRAG;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.LEFT_CLICKED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.CLICKED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.MULTI_CLICKED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.RIGHT_CLICKED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.MIDDLE_CLICKED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.LEFT_DOUBLE_CLICKED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.RIGHT_DOUBLE_CLICKED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.MIDDLE_DOUBLE_CLICKED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.LEFT_PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.LEFT_RELEASED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.RIGHT_PRESSED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.RIGHT_RELEASED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.DRAGGED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.LEFT_DRAGGED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.EXITED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.ENTERED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.RIGHT_DRAGGED;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.MouseEventRecognizers.MIDDLE_DRAGGED;
 /** @type {!yfiles.lang.Class} */
yfiles.input.MouseEventRecognizers.$class;
/**
 * @record
 * @struct
 */
yfiles.input.TouchEventRecognizers = function() {};
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_MOVED_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.LOST_CAPTURE;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.LOST_CAPTURE_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.LOST_CAPTURE_SECONDARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_DOWN_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_UP_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_TAPPED_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_DOUBLE_TAPPED_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_MULTI_TAPPED_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_EXITED_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_ENTERED_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_LONG_PRESSED_PRIMARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_MOVED_SECONDARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_DOWN_SECONDARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_UP_SECONDARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_TAPPED_SECONDARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_DOUBLE_TAPPED_SECONDARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_MULTI_TAPPED_SECONDARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_EXITED_SECONDARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_ENTERED_SECONDARY;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TouchEventRecognizers.TOUCH_LONG_PRESSED_SECONDARY;
 /** @type {!yfiles.lang.Class} */
yfiles.input.TouchEventRecognizers.$class;
/**
 * @record
 * @struct
 */
yfiles.input.CreateBendInputMode = function() {};
 /** @type {number} */
yfiles.input.CreateBendInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.CreateBendInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.CreateBendInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.CreateBendInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.CreateBendInputMode.prototype.controller;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.CreateBendInputMode.prototype.armedCursor;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateBendInputMode.prototype.pressedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateBendInputMode.prototype.draggedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateBendInputMode.prototype.releasedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateBendInputMode.prototype.prepareRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateBendInputMode.prototype.movedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateBendInputMode.prototype.releasedRecognizerTouch;
 /** @type {?} */
yfiles.input.CreateBendInputMode.prototype.beginHitTestable;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.CreateBendInputMode.prototype.location;
 /** @type {?} */
yfiles.input.CreateBendInputMode.prototype.graph;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateBendInputMode.prototype.splitOrthogonalSegmentRecognizer;
 /** @type {boolean} */
yfiles.input.CreateBendInputMode.prototype.splitOrthogonalSegment;
 /** @type {boolean} */
yfiles.input.CreateBendInputMode.prototype.useExistingBend;
 /** @type {!yfiles.lang.Class} */
yfiles.input.CreateBendInputMode.$class;

/**
 * Called when a bend creation gesture can be started at the current mouse pointer location.
 * <p>
 * This implementation sets the {\@link yfiles.input.ConcurrencyController#preferredCursor} to {\@link yfiles.input.CreateBendInputMode#armedCursor}.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.arm = function() {};

/**
 * Cancels the editing of this mode.
 * <p>
 * This implementation {\@link yfiles.input.ConcurrencyController#releaseMutex releases} the mutex if it is currently owned by this instance and calls
 * {\@link yfiles.input.CreateBendInputMode#onCanceled}.
 * </p>
 * @see yfiles.input.CreateBendInputMode#onCanceled
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.cancel = function() {};

/**
 * Creates the bend.
 * <p>
 * The bend is created using the hit edge's {\@link yfiles.input.IBendCreator} implementation, as obtained from the edge's
 * {\@link yfiles.graph.ILookup#lookup}.
 * </p>
 * @see yfiles.input.CreateBendInputMode#createInputModeContext
 * @protected
 * @param {?} edge The hit edge.
 * @param {!yfiles.geometry.Point} location The coordinates of the hit.
 * @return {?} The created bend or <code>null</code>.
 */
yfiles.input.CreateBendInputMode.prototype.createBend = function(edge, location) {};

/**
 * Creates an {\@link yfiles.input.IInputModeContext} for use with the upcoming {\@link yfiles.input.IBendCreator#createBend} call in
 * {\@link yfiles.input.CreateBendInputMode#createBend}.
 * @protected
 * @return {?} An instance of {\@link }.
 */
yfiles.input.CreateBendInputMode.prototype.createInputModeContext = function() {};

/**
 * Called when a bend creation gesture can no longer be started at the current mouse pointer location.
 * <p>
 * This implementation sets the {\@link yfiles.input.ConcurrencyController#preferredCursor} back to <code>null</code>.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.disarm = function() {};

/**
 * Updates the {\@link yfiles.input.CreateBendInputMode#splitOrthogonalSegment} property and then delegates to {\@link yfiles.input.CreateBendInputMode#createBend}.
 * <p>
 * This method triggers the {\@link yfiles.input.CreateBendInputMode#addBendCreatedListener BendCreated} event
 * if a bend is created.
 * </p>
 * @protected
 * @param {?} edge The edge to create a bend for.
 * @param {!yfiles.geometry.Point} dragLocation The location at which the user initiated the gesture.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.dragSegment = function(edge, dragLocation) {};

/**
 * Finds the edge at the given coordinate.
 * @protected
 * @param {!yfiles.geometry.Point} location The coordinates.
 * @return {?} The edge that has been hit.
 */
yfiles.input.CreateBendInputMode.prototype.getEdge = function(location) {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.install = function(context, controller) {};

/**
 * Determines whether the current location is valid to begin a bend creation gesture.
 * @protected
 * @param {!Object} source
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean}
 */
yfiles.input.CreateBendInputMode.prototype.isValidBegin = function(source, evt) {};

/**
 * Triggers the {\@link yfiles.input.CreateBendInputMode#addBendCreatedListener BendCreated} event.
 * @protected
 * @param {!yfiles.graph.BendEventArgs} evt
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.onBendCreated = function(evt) {};

/**
 * Called after {\@link yfiles.input.CreateBendInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Triggers the {\@link yfiles.input.CreateBendInputMode#addDragCanceledListener DragCanceled} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.onDragCanceled = function(evt) {};

/**
 * Callback triggered at the end of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.CreateBendInputMode#addDraggedListener Dragged} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.onDragged = function(evt) {};

/**
 * Callback triggered at the start of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.CreateBendInputMode#addDraggingListener Dragging} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.onDragging = function(evt) {};

/**
 * Called after {\@link yfiles.input.CreateBendInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.onStopped = function() {};

/**
 *
 * @return {boolean}
 */
yfiles.input.CreateBendInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>BendCreated</code> event that occurs once a bend creation gesture has been recognized.
 * @see yfiles.input.CreateBendInputMode#removeBendCreatedListener
 * @param {function(!Object, !yfiles.graph.BendEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.addBendCreatedListener = function(listener) {};

/**
 * Removes the given listener for the <code>BendCreated</code> event that occurs once a bend creation gesture has been recognized.
 * @see yfiles.input.CreateBendInputMode#addBendCreatedListener
 * @param {function(!Object, !yfiles.graph.BendEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.removeBendCreatedListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.CreateBendInputMode#removeDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.addDraggingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.CreateBendInputMode#addDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.removeDraggingListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.CreateBendInputMode#removeDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.addDraggedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.CreateBendInputMode#addDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.removeDraggedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.CreateBendInputMode#removeDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.addDragCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.CreateBendInputMode#addDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateBendInputMode.prototype.removeDragCanceledListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.EditLabelHelper = function() {};
 /** @type {?} */
yfiles.input.EditLabelHelper.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.input.EditLabelHelper.$class;

/**
 * Determines the label model parameter to use for the label, depending on the <code>owner</code>.
 * <p>
 * This method will obtain the default parameter instances from the {\@link yfiles.input.EditLabelHelper#graph} considering the type of the current <code>owner</code>.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {?} owner The label's owner.
 * @return {?} The layout parameter to use or <code>null</code>.
 */
yfiles.input.EditLabelHelper.prototype.getLabelParameter = function(context, owner) {};

/**
 * Determines the style to use for the label, depending on the <code>owner</code>.
 * <p>
 * This method will obtain the default style instances from the {\@link yfiles.input.EditLabelHelper#graph} considering the type of the current <code>owner</code>.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {?} owner The label's owner.
 * @return {?} The style to use or <code>null</code>.
 */
yfiles.input.EditLabelHelper.prototype.getLabelStyle = function(context, owner) {};

/**
 * Gets the preferred size for the label.
 * <p>
 * This implementation yields <code>null</code> to indicate that the preferred size should be calculated after the text has been
 * entered.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {?} label The label to get the preferred size from.
 * @return {!yfiles.geometry.Size} The size to use or <code>null</code>.
 */
yfiles.input.EditLabelHelper.prototype.getPreferredSize = function(context, label) {};

/**
 * Helper method that will be called for {\@link yfiles.graph.ILabelOwner}s.
 * <p>
 * This method delegates to {\@link yfiles.input.EditLabelHelper#getLabelParameter}, {\@link yfiles.input.EditLabelHelper#getLabelStyle}, and
 * {\@link yfiles.input.EditLabelHelper#getPreferredSize} to set the appropriate properties on <code>args</code> and sets the {\@link yfiles.input.LabelEditingEventArgs#handled} property to
 * <code>true</code>. Label creation thus is always possible.
 * </p>
 * @param {!yfiles.input.LabelEditingEventArgs} evt The original event arguments.
 * @return {void}
 */
yfiles.input.EditLabelHelper.prototype.onLabelAdding = function(evt) {};

/**
 * Helper method that will be called for {\@link yfiles.graph.ILabelOwner}s.
 * <p>
 * This method returns the first of the {\@link yfiles.graph.ILabelOwner#labels} that belong to the {\@link yfiles.input.LabelEditingEventArgs#owner}, if set. Otherwise, it delegates to
 * {\@link yfiles.input.EditLabelHelper#getLabelParameter}, {\@link yfiles.input.EditLabelHelper#getLabelStyle}, and {\@link yfiles.input.EditLabelHelper#getPreferredSize}
 * to set the appropriate properties on <code>args</code>.
 * </p>
 * <p>
 * The arguments are always set as {\@link yfiles.input.LabelEditingEventArgs#handled}, so label editing is always possible.
 * </p>
 * @param {!yfiles.input.LabelEditingEventArgs} evt The original event arguments.
 * @return {void}
 */
yfiles.input.EditLabelHelper.prototype.onLabelEditing = function(evt) {};
/**
 * @record
 * @struct
 */
yfiles.input.CreateEdgeInputMode = function() {};
 /** @type {number} */
yfiles.input.CreateEdgeInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.CreateEdgeInputMode.prototype.controller;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.CreateEdgeInputMode.prototype.validBeginCursor;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.CreateEdgeInputMode.prototype.validBendCursor;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.CreateEdgeInputMode.prototype.validEndCursor;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.disableSnappingRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.enableSnappingRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.toggleSegmentOrientationRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.finishRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.prepareRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.draggedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.endPointMovedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.createBendRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.cancelRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.removeBendRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.portCandidateResolutionRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.finishRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.prepareRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.draggedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.createBendRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.cancelRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.removeBendRecognizerTouch;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.showPortCandidates;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.allowEdgeToEdgeConnections;
 /** @type {number} */
yfiles.input.CreateEdgeInputMode.prototype.snapDistance;
 /** @type {!yfiles.input.SnapContext} */
yfiles.input.CreateEdgeInputMode.prototype.snapContext;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.candidateDescriptor;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.closestCandidateDescriptor;
 /** @type {number} */
yfiles.input.CreateEdgeInputMode.prototype.orthogonalSnapDistance;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.forceSnapToCandidate;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.useHitItemsCandidatesOnly;
 /** @type {yfiles.input.OrthogonalEdgeEditingPolicy} */
yfiles.input.CreateEdgeInputMode.prototype.orthogonalEdgeCreation;
 /** @type {number} */
yfiles.input.CreateEdgeInputMode.prototype.preferredMinimalEdgeDistance;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.resolveSourcePortCandidates;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.resolveTargetPortCandidates;
 /** @type {number} */
yfiles.input.CreateEdgeInputMode.prototype.nodeBorderWidthRatio;
 /** @type {function(?, ?, ?, ?, ?): ?} */
yfiles.input.CreateEdgeInputMode.prototype.edgeCreator;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.allowSelfloops;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.cancelGestureOnInvalidTarget;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.allowCreateBend;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.dummyEdge;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.dummyEdgeGraph;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.edgeDefaults;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.sourcePortCandidate;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.targetPortCandidate;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.cancelEditImplicitly;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.snapToTargetCandidate;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.beginHitTestable;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.endHitTestable;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.validBendHitTestable;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.CreateEdgeInputMode.prototype.startPoint;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.dragPoint;
 /** @type {boolean} */
yfiles.input.CreateEdgeInputMode.prototype.isCreationInProgress;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.CreateEdgeInputMode.prototype.enforceBendCreationRecognizer;
 /** @type {?} */
yfiles.input.CreateEdgeInputMode.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.input.CreateEdgeInputMode.$class;

/**
 * Cancels the editing of this mode.
 * <p>
 * This implementation {\@link yfiles.input.ConcurrencyController#releaseMutex releases} the mutex if it is currently owned by this instance and calls
 * {\@link yfiles.input.CreateEdgeInputMode#onCanceled}.
 * </p>
 * @see yfiles.input.CreateEdgeInputMode#onCanceled
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.cancel = function() {};

/**
 * Creates the dummy edge that will be displayed by the input mode during the creation.
 * @protected
 * @return {?} An {\@link } implementation that can be used as a dummy.
 */
yfiles.input.CreateEdgeInputMode.prototype.createDummyEdge = function() {};

/**
 * Factory method that will create the dummy graph to hold the preview of the {\@link yfiles.input.CreateEdgeInputMode#dummyEdge}.
 * <p>
 * Note that the instance returned by this instance must accept any port as valid source and target ports for it's {\@link yfiles.graph.IGraph#setEdgePorts}
 * method. This will allow the preview edge to be connected to the actual {\@link yfiles.input.CreateEdgeInputMode#graph}.
 * </p>
 * @protected
 * @return {?} A graph instance that will be rendered as a preview.
 */
yfiles.input.CreateEdgeInputMode.prototype.createDummyEdgeGraph = function() {};

/**
 * Callback used by {\@link yfiles.input.CreateEdgeInputMode#createEdge} if both {\@link yfiles.input.CreateEdgeInputMode#sourcePortCandidate} and {\@link yfiles.input.CreateEdgeInputMode#targetPortCandidate} have been set.
 * <p>
 * This method will first {\@link yfiles.input.IPortCandidate#createPort create the new ports} if necessary and then create the edge via the {\@link yfiles.input.CreateEdgeInputMode#edgeCreator} callback to the ports. After
 * the ports are created the corresponding {\@link yfiles.input.CreateEdgeInputMode#addPortAddedListener PortAdded}
 * events are triggered. If the edge creation is canceled by the creator callback, newly created ports will be removed
 * again.
 * </p>
 * @protected
 * Callback at the end of the edge creation process.
 * <p>
 * This method will actually create the edge using the {\@link yfiles.input.CreateEdgeInputMode#createEdge} method. This method will
 * ultimately call {\@link yfiles.input.CreateEdgeInputMode#onEdgeCreated}.
 * </p>
 * @protected
 * @param {?=} graph The graph to create the edge for.
 * @param {?=} sourcePortCandidate The candidate to use for the source.
 * @param {?=} targetPortCandidate The candidate to use for the target.
 * @return {?} The edge created or <code>null</code>.
 */
yfiles.input.CreateEdgeInputMode.prototype.createEdge = function(graph, sourcePortCandidate, targetPortCandidate) {};

/**
 * Creates an {\@link yfiles.input.IInputModeContext} for use with the port candidates queries for the upcoming edge creation
 * operation and the actual edge creation
 * @protected
 * @return {?} An instance of {\@link } that is configured for this mode.
 */
yfiles.input.CreateEdgeInputMode.prototype.createEdgeCreationInputModeContext = function() {};

/**
 * Synthetically starts the interactive edge creation process using the provided {\@link yfiles.input.IPortCandidate} as the source
 * port.
 * <p>
 * This instance needs to be {\@link yfiles.input.IInputMode#install installed} and {\@link yfiles.input.CreateEdgeInputMode#enabled} and it needs to be able to {\@link yfiles.input.ConcurrencyController#canRequestMutex request the input mutex} in order to proceed. If any
 * of these conditions are not satisfied, this method will throw an {\@link yfiles.lang.Exception}.
 * </p>
 * @param {?} sourcePortCandidate The source port candidate to use for the edge creation.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.doStartEdgeCreation = function(sourcePortCandidate) {};

/**
 * Finds the closest {\@link yfiles.input.PortCandidateValidity#VALID} candidate given a number of
 * {\@link yfiles.input.IPortCandidate}s and a location in world coordinates.
 * @protected
 * @param {?<?>} candidates The candidates to find the closest from.
 * @param {!yfiles.geometry.Point} location The location of the mouse in world coordinates.
 * @return {?} The candidate to use or <code>null</code> if no candidate satisfies the needs
 */
yfiles.input.CreateEdgeInputMode.prototype.getClosestCandidate = function(candidates, location) {};

/**
 * Finds the closest candidate given a number of {\@link yfiles.input.IPortCandidate}s and a location in world coordinates.
 * @protected
 * @param {?<?>} candidates The candidates to find the closest from.
 * @param {!yfiles.geometry.Point} location The location of the pointer in world coordinates.
 * @return {?} The candidate to use or <code>null</code> if no candidate satisfies the needs
 */
yfiles.input.CreateEdgeInputMode.prototype.getClosestSourceCandidate = function(candidates, location) {};

/**
 * Finds the closest target candidate given a number of {\@link yfiles.input.IPortCandidate}s and a location in world coordinates.
 * @protected
 * @param {?<?>} candidates The candidates to find the closest from.
 * @param {!yfiles.geometry.Point} location The location of the mouse in world coordinates.
 * @return {?} The candidate to use or <code>null</code> if no candidate satisfies the needs or {\@link #enforceBendCreationRecognizer} yields <code>true</code>.
 */
yfiles.input.CreateEdgeInputMode.prototype.getClosestTargetCandidate = function(candidates, location) {};

/**
 * Gets the snap lines lines that are induced by the current dummy edge.
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The graph snap context.
 * @param {?} provider The dummy edge segment snap line provider.
 * @return {?<!yfiles.input.OrthogonalSnapLine>} The snap lines induced by the current dummy edge.
 */
yfiles.input.CreateEdgeInputMode.prototype.getDummyEdgeSnapLines = function(context, provider) {};

/**
 * Calculates direction of first edge segment of the DummyNode.
 * <p>
 * An edge starting in an border will always be orthogonal to the border's outer line. An edge starting in a corner will
 * point the way the user dragged the mouse. An edge starting in the inner of the node will be directed the way dragged
 * unless another edge that is close to the new edge ({\@link yfiles.input.CreateEdgeInputMode#preferredMinimalEdgeDistance}) already went that way.
 * </p>
 * @protected
 * @return {yfiles.input.EdgeSegmentDirection} A {\@link } defining the direction of the first edge segment.
 */
yfiles.input.CreateEdgeInputMode.prototype.getFirstSegmentDirection = function() {};

/**
 * Retrieves the port owner at a given position in world coordinates.
 * <p>
 * If there is a {\@link yfiles.input.IHitTester.<T>} for type {\@link yfiles.graph.INode} in the lookup of this mode's {\@link yfiles.input.CreateEdgeInputMode#inputModeContext} then this instance will be used for the query.
 * 
 * <br />
 * Otherwise this implementation calls the {\@link yfiles.styles.INodeStyleRenderer#getHitTestable} method of the nodes to find hit
 * nodes and uses an {\@link yfiles.collections.IComparer.<T>} to determine the first hit node.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} location The position in world coordinates.
 * @return {?} The node or <code>null</code> if no suitable node was found.
 */
yfiles.input.CreateEdgeInputMode.prototype.getPortOwner = function(location) {};

/**
 * Retrieves the port owners from the graph in the order of their importance.
 * <p>
 * This implementation only considers nodes in the graph unless {\@link yfiles.input.CreateEdgeInputMode#allowEdgeToEdgeConnections} is set to
 * <code>true</code>, in which case edges are also added to the enumerable.
 * </p>
 * @protected
 * @return {?<?>} An enumerable over all {\@link }s in this graph
 */
yfiles.input.CreateEdgeInputMode.prototype.getPortOwners = function() {};

/**
 * Finds the source {\@link yfiles.graph.IPortOwner port owner} at the specified location.
 * <p>
 * This always is the source {\@link yfiles.graph.INode node} if {\@link yfiles.input.CreateEdgeInputMode#allowEdgeToEdgeConnections} is set to <code>false</code>.
 * <br />
 * This default implementation simply delegates to {\@link yfiles.input.CreateEdgeInputMode#getPortOwner}.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} sourceLocation The location of the mouse at the beginning of the gesture.
 * @return {?} The port owner to use for the source node or <code>null</code>.
 */
yfiles.input.CreateEdgeInputMode.prototype.getSource = function(sourceLocation) {};

/**
 * Finds the best matching source port {\@link yfiles.input.IPortCandidate} given a provider and the current location.
 * <p>
 * The <code>resolveCandidates</code> parameter determines whether dynamic port candidates should be {\@link yfiles.input.CreateEdgeInputMode#resolveCandidates resolved} with respect to <code>location</code>
 * or simply be discarded.
 * </p>
 * @see yfiles.input.CreateEdgeInputMode#resolveSourcePortCandidates
 * @see yfiles.input.CreateEdgeInputMode#portCandidateResolutionRecognizer
 * @protected
 * Finds the best matching source {\@link yfiles.input.IPortCandidate port candidate} based on the given location.
 * <p>
 * This implementation will use the {\@link yfiles.input.CreateEdgeInputMode#getSource port owner} to look up the {\@link yfiles.input.IPortCandidateProvider port candidate provider} and finally delegate to
 * {\@link yfiles.input.CreateEdgeInputMode#getSourcePortCandidate}.
 * </p>
 * @see yfiles.input.CreateEdgeInputMode#getSource
 * @see yfiles.input.CreateEdgeInputMode#getSourcePortCandidateProvider
 * @see yfiles.input.CreateEdgeInputMode#getSourcePortCandidate
 * @protected
 * @param {?|!yfiles.geometry.Point} provider_or_location The provider for the candidates. / The location where the gesture was initiated.
 * @param {!yfiles.geometry.Point=} location The location where the gesture was initiated.
 * @param {boolean=} resolveCandidates Determines whether {\@link #DYNAMIC} ports should be resolved with respect to the <code>location</code> or
 * not.
 * @return {?} The candidate to use or <code>null</code>.
 */
yfiles.input.CreateEdgeInputMode.prototype.getSourcePortCandidate = function(provider_or_location, location, resolveCandidates) {};

/**
 * Retrieves the port candidate provider instance given a source port owner.
 * <p>
 * This implementations uses the <code>sourceOwner</code>'s {\@link yfiles.graph.ILookup#lookup} to retrieve an {\@link yfiles.input.IPortCandidateProvider}
 * implementation.
 * </p>
 * @protected
 * @param {?} sourceOwner The {\@link } to find the candidates for.
 * @return {?} A provider instance or <code>null</code>.
 */
yfiles.input.CreateEdgeInputMode.prototype.getSourcePortCandidateProvider = function(sourceOwner) {};

/**
 * Finds the target {\@link yfiles.graph.IPortOwner port owner} at the specified location.
 * <p>
 * This always is a target {\@link yfiles.graph.INode node} if {\@link yfiles.input.CreateEdgeInputMode#allowEdgeToEdgeConnections} is set to <code>false</code>.
 * <br />
 * This default implementation simply delegates to {\@link yfiles.input.CreateEdgeInputMode#getPortOwner}.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} targetLocation The location of the pointer at the beginning of the gesture.
 * @return {?} The port owner or <code>null</code>.
 */
yfiles.input.CreateEdgeInputMode.prototype.getTarget = function(targetLocation) {};

/**
 * Retrieves the port candidate provider instance given a source port candidate and a possible target item.
 * <p>
 * This implementations uses the <code>targetOwner</code>'s {\@link yfiles.graph.ILookup#lookup} to retrieve an {\@link yfiles.input.IPortCandidateProvider}
 * implementation.
 * </p>
 * @protected
 * Retrieves the {\@link yfiles.input.IPortCandidateProvider} instance that provides the possible candidates for the target of the
 * edge given the current source candidate.
 * <p>
 * This implementation queries all nodes in the graph for {\@link yfiles.input.CreateEdgeInputMode#getTargetPortCandidateProvider their provider} and returns a composite unless {\@link yfiles.input.CreateEdgeInputMode#useHitItemsCandidatesOnly} is set to <code>true</code> in
 * which case the {\@link yfiles.input.CreateEdgeInputMode#getTargetPortCandidateProvider} is queried using the current {\@link yfiles.input.CreateEdgeInputMode#getTarget target}.
 * </p>
 * @protected
 * @param {?} sourcePortCandidate The current source port candidate. / The source candidate that has been chosen for the edge creation.
 * @param {?|!yfiles.geometry.Point} targetOwner_or_location The {\@link } to find the candidates for. / The location of the mouse.
 * @param {!yfiles.geometry.Point=} location The location of the mouse.
 * @return {?} A provider instance or <code>null</code>. / The provider to get the port candidates from.
 */
yfiles.input.CreateEdgeInputMode.prototype.getTargetPortCandidateProvider = function(sourcePortCandidate, targetOwner_or_location, location) {};

/**
 * Retrieves the target port candidates for a given location in world coordinates.
 * <p>
 * The <code>resolveCandidates</code> parameter determines whether dynamic port candidates should be {\@link yfiles.input.CreateEdgeInputMode#resolveCandidates resolved} with respect to <code>location</code>
 * or simply be discarded. This implementation delegates to {\@link yfiles.input.CreateEdgeInputMode#getTargetPortCandidateProvider}
 * or returns an empty enumerable if no provider has been found.
 * </p>
 * @see yfiles.input.CreateEdgeInputMode#sourcePortCandidate
 * @see yfiles.input.CreateEdgeInputMode#resolveTargetPortCandidates
 * @see yfiles.input.CreateEdgeInputMode#portCandidateResolutionRecognizer
 * @protected
 * @param {!yfiles.geometry.Point} location The location of the mouse in world coordinates.
 * @param {boolean} resolveCandidates Determines whether {\@link #DYNAMIC} ports should be resolved with respect to the <code>location</code> or
 * not.
 * @return {?<?>} A possibly empty enumeration over all target port candidates.
 */
yfiles.input.CreateEdgeInputMode.prototype.getTargetPortCandidates = function(location, resolveCandidates) {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.install = function(context, controller) {};

/**
 * Called after {\@link yfiles.input.CreateEdgeInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController} property of the installed {\@link yfiles.input.ConcurrencyController} has
 * been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Called by {\@link yfiles.input.CreateEdgeInputMode#createEdge} after the edge has been finalized.
 * <p>
 * This method will trigger the {\@link yfiles.input.CreateEdgeInputMode#addEdgeCreatedListener EdgeCreated}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.graph.EdgeEventArgs} evt The event argument holding the edge.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onEdgeCreated = function(evt) {};

/**
 * Raises the {\@link yfiles.input.CreateEdgeInputMode#addEdgeCreationStartedListener EdgeCreationStarted} event when
 * the gesture for creating an edge has been initialized.
 * @protected
 * @param {!yfiles.graph.EdgeEventArgs} evt The {\@link } instance containing the dummy edge that will be used during edge creation.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onEdgeCreationStarted = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.CreateEdgeInputMode#addGestureCanceledListener GestureCanceled} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onGestureCanceled = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.CreateEdgeInputMode#addGestureCancelingListener GestureCanceling} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onGestureCanceling = function(evt) {};

/**
 * Callback triggered once the drag has been finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.CreateEdgeInputMode#addGestureFinishedListener GestureFinished}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onGestureFinished = function(evt) {};

/**
 * Callback triggered before the drag will be finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.CreateEdgeInputMode#addGestureFinishingListener GestureFinishing}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onGestureFinishing = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.CreateEdgeInputMode#addGestureStartedListener GestureStarted} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onGestureStarted = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.CreateEdgeInputMode#addGestureStartingListener GestureStarting} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onGestureStarting = function(evt) {};

/**
 * Callback triggered at the end of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.CreateEdgeInputMode#addMovedListener Moved} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onMoved = function(evt) {};

/**
 * Callback triggered at the start of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.CreateEdgeInputMode#addMovingListener Moving} event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onMoving = function(evt) {};

/**
 * Raises the {\@link yfiles.input.CreateEdgeInputMode#addPortAddedListener PortAdded} event if the mode has
 * {\@link yfiles.graph.IGraph#addPort added a port} for the source or target node to complete the edge creation.
 * @see yfiles.input.CreateEdgeInputMode#addPortAddedListener
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the port that has been added.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onPortAdded = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.CreateEdgeInputMode#addSourcePortCandidateChangedListener SourcePortCandidateChanged}
 * event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onSourcePortCandidateChanged = function(evt) {};

/**
 * Called after {\@link yfiles.input.CreateEdgeInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onStopped = function() {};

/**
 * Triggers the {\@link yfiles.input.CreateEdgeInputMode#addTargetPortCandidateChangedListener TargetPortCandidateChanged}
 * event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.onTargetPortCandidateChanged = function(evt) {};

/**
 * Returns an enumerable over the given candidates where no instance has {\@link yfiles.input.PortCandidateValidity#DYNAMIC} {\@link yfiles.input.IPortCandidate#validity}.
 * <p>
 * If the location has a value, method {\@link yfiles.input.IPortCandidate#getPortCandidateAt} is used to resolve the dynamic
 * candidate to a real candidate, otherwise that candidate is discarded.
 * </p>
 * @protected
 * @param {?<?>} candidates The candidates to possibly resolve.
 * @param {!yfiles.geometry.Point} location The location to resolve dynamic candidates against or <code>null</code> if they should be discarded instead.
 * @return {?<?>} An enumerable of non-{\@link #DYNAMIC} port candidates.
 */
yfiles.input.CreateEdgeInputMode.prototype.resolveCandidates = function(candidates, location) {};

/**
 *
 * @return {boolean}
 */
yfiles.input.CreateEdgeInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.uninstall = function(context) {};

/**
 * Updates the {\@link yfiles.input.CreateEdgeInputMode#dummyEdge} to reflect the current source port candidate.
 * <p>
 * This implementation creates a self loop of the dummy edge if the <code>sourcePortCandidate</code> is the same as the owner of the {\@link yfiles.input.CreateEdgeInputMode#targetPortCandidate}.
 * </p>
 * @protected
 * @param {?} sourcePortCandidate The new owner target port candidate.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.updateDummyEdgeSourcePort = function(sourcePortCandidate) {};

/**
 * Updates the {\@link yfiles.input.CreateEdgeInputMode#dummyEdge} to reflect the current target port candidate.
 * <p>
 * This implementation creates a self loop of the dummy edge if the <code>targetPortCandidate</code> is the same as the owner of the {\@link yfiles.input.CreateEdgeInputMode#sourcePortCandidate}.
 * </p>
 * @protected
 * @param {?} targetPortCandidate The new owner target port candidate.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.updateDummyEdgeTargetPort = function(targetPortCandidate) {};

/**
 * Updates the drag point.
 * <p>
 * This method is called when the current target location for the creation gesture is changed.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} location The new coordinates.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.updateTargetLocation = function(location) {};

/**
 * Adds the given listener for the <code>SourcePortCandidateChanged</code> event that occurs when the value of the {\@link yfiles.input.CreateEdgeInputMode#sourcePortCandidate} property changes.
 * @see yfiles.input.CreateEdgeInputMode#removeSourcePortCandidateChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addSourcePortCandidateChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>SourcePortCandidateChanged</code> event that occurs when the value of the {\@link yfiles.input.CreateEdgeInputMode#sourcePortCandidate} property
 * changes.
 * @see yfiles.input.CreateEdgeInputMode#addSourcePortCandidateChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeSourcePortCandidateChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>TargetPortCandidateChanged</code> event that occurs when the value of the {\@link yfiles.input.CreateEdgeInputMode#targetPortCandidate} property changes.
 * @see yfiles.input.CreateEdgeInputMode#removeTargetPortCandidateChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addTargetPortCandidateChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>TargetPortCandidateChanged</code> event that occurs when the value of the {\@link yfiles.input.CreateEdgeInputMode#targetPortCandidate} property
 * changes.
 * @see yfiles.input.CreateEdgeInputMode#addTargetPortCandidateChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeTargetPortCandidateChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeCreated</code> event that occurs after an edge has been created by this mode.
 * @see yfiles.input.CreateEdgeInputMode#onEdgeCreated
 * @see yfiles.input.CreateEdgeInputMode#removeEdgeCreatedListener
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addEdgeCreatedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeCreated</code> event that occurs after an edge has been created by this mode.
 * @see yfiles.input.CreateEdgeInputMode#onEdgeCreated
 * @see yfiles.input.CreateEdgeInputMode#addEdgeCreatedListener
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeEdgeCreatedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortAdded</code> event that occurs when this instance {\@link yfiles.graph.IGraph#addPort adds a port} to the source or target node
 * during completion of the edge creation gesture.
 * @see yfiles.input.CreateEdgeInputMode#removePortAddedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addPortAddedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortAdded</code> event that occurs when this instance {\@link yfiles.graph.IGraph#addPort adds a port} to the source or target
 * node during completion of the edge creation gesture.
 * @see yfiles.input.CreateEdgeInputMode#addPortAddedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removePortAddedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GestureFinishing</code> event that occurs before the gesture will be finished.
 * @see yfiles.input.CreateEdgeInputMode#removeGestureFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addGestureFinishingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GestureFinishing</code> event that occurs before the gesture will be finished.
 * @see yfiles.input.CreateEdgeInputMode#addGestureFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeGestureFinishingListener = function(listener) {};

/**
 * Adds the given listener for the <code>GestureFinished</code> event that occurs once the gesture has been finished.
 * @see yfiles.input.CreateEdgeInputMode#removeGestureFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addGestureFinishedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GestureFinished</code> event that occurs once the gesture has been finished.
 * @see yfiles.input.CreateEdgeInputMode#addGestureFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeGestureFinishedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GestureStarting</code> event that occurs once the gesture is starting.
 * @see yfiles.input.CreateEdgeInputMode#removeGestureStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addGestureStartingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GestureStarting</code> event that occurs once the gesture is starting.
 * @see yfiles.input.CreateEdgeInputMode#addGestureStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeGestureStartingListener = function(listener) {};

/**
 * Adds the given listener for the <code>GestureStarted</code> event that occurs once the gesture is initialized and has started.
 * @see yfiles.input.CreateEdgeInputMode#removeGestureStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addGestureStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GestureStarted</code> event that occurs once the gesture is initialized and has started.
 * @see yfiles.input.CreateEdgeInputMode#addGestureStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeGestureStartedListener = function(listener) {};

/**
 * Adds the given listener for the <code>Moving</code> event that occurs at the start of every drag or move.
 * @see yfiles.input.CreateEdgeInputMode#removeMovingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addMovingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Moving</code> event that occurs at the start of every drag or move.
 * @see yfiles.input.CreateEdgeInputMode#addMovingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeMovingListener = function(listener) {};

/**
 * Adds the given listener for the <code>Moved</code> event that occurs at the end of every drag or move.
 * @see yfiles.input.CreateEdgeInputMode#removeMovedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addMovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Moved</code> event that occurs at the end of every drag or move.
 * @see yfiles.input.CreateEdgeInputMode#addMovedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeMovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GestureCanceled</code> event that occurs when the gesture has been canceled.
 * @see yfiles.input.CreateEdgeInputMode#removeGestureCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addGestureCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>GestureCanceled</code> event that occurs when the gesture has been canceled.
 * @see yfiles.input.CreateEdgeInputMode#addGestureCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeGestureCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>GestureCanceling</code> event that occurs before the gesture will be canceled.
 * @see yfiles.input.CreateEdgeInputMode#removeGestureCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addGestureCancelingListener = function(listener) {};

/**
 * Removes the given listener for the <code>GestureCanceling</code> event that occurs before the gesture will be canceled.
 * @see yfiles.input.CreateEdgeInputMode#addGestureCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeGestureCancelingListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeCreationStarted</code> event that occurs when the edge creation has started.
 * <p>
 * The edge that is stored in the {\@link yfiles.collections.ItemEventArgs.<T>#item} property is the {\@link yfiles.input.CreateEdgeInputMode#dummyEdge} that is used during creation.
 * </p>
 * @see yfiles.input.CreateEdgeInputMode#removeEdgeCreationStartedListener
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.addEdgeCreationStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeCreationStarted</code> event that occurs when the edge creation has started.
 * <p>
 * The edge that is stored in the {\@link yfiles.collections.ItemEventArgs.<T>#item} property is the {\@link yfiles.input.CreateEdgeInputMode#dummyEdge} that is used during creation.
 * </p>
 * @see yfiles.input.CreateEdgeInputMode#addEdgeCreationStartedListener
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.CreateEdgeInputMode.prototype.removeEdgeCreationStartedListener = function(listener) {};

/** @const */
yfiles.input.EdgeSegmentDirection = {};
/** @const {number} */
yfiles.input.EdgeSegmentDirection.NORTH;
/** @const {number} */
yfiles.input.EdgeSegmentDirection.EAST;
/** @const {number} */
yfiles.input.EdgeSegmentDirection.SOUTH;
/** @const {number} */
yfiles.input.EdgeSegmentDirection.WEST;

/** @const */
yfiles.input.AdjustContentRectPolicy = {};
/** @const {number} */
yfiles.input.AdjustContentRectPolicy.NEVER;
/** @const {number} */
yfiles.input.AdjustContentRectPolicy.UNION;
/** @const {number} */
yfiles.input.AdjustContentRectPolicy.ALWAYS;
/**
 * @record
 * @struct
 */
yfiles.input.GraphEditorInputMode = function() {};
 /** @type {!yfiles.input.OrthogonalEdgeEditingContext} */
yfiles.input.GraphEditorInputMode.prototype.orthogonalEdgeEditingContext;
 /** @type {yfiles.input.OrthogonalEdgeEditingPolicy} */
yfiles.input.GraphEditorInputMode.prototype.orthogonalBendRemoval;
 /** @type {?} */
yfiles.input.GraphEditorInputMode.prototype.reparentNodeHandler;
 /** @type {?<?>} */
yfiles.input.GraphEditorInputMode.prototype.hitTester;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphEditorInputMode.prototype.pasteSelectableItems;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.smartPasteSelection;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphEditorInputMode.prototype.movableItems;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphEditorInputMode.prototype.deletableItems;
 /** @type {function(?): boolean} */
yfiles.input.GraphEditorInputMode.prototype.deletablePredicate;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphEditorInputMode.prototype.labelEditableItems;
 /** @type {!yfiles.input.HandleInputMode} */
yfiles.input.GraphEditorInputMode.prototype.handleInputMode;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.input.GraphEditorInputMode.prototype.showHandleItems;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.useCurrentItemForCommands;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.GraphEditorInputMode.prototype.pasteDelta;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowEditLabel;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowEditLabelOnDoubleClick;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowAddLabel;
 /** @type {!yfiles.input.MoveInputMode} */
yfiles.input.GraphEditorInputMode.prototype.moveInputMode;
 /** @type {yfiles.input.AdjustContentRectPolicy} */
yfiles.input.GraphEditorInputMode.prototype.adjustContentRectPolicy;
 /** @type {!yfiles.geometry.Insets} */
yfiles.input.GraphEditorInputMode.prototype.contentRectMargins;
 /** @type {!yfiles.view.GraphComponent} */
yfiles.input.GraphEditorInputMode.prototype.graphComponent;
 /** @type {!yfiles.input.SnapContext} */
yfiles.input.GraphEditorInputMode.prototype.snapContext;
 /** @type {!yfiles.input.SnapContext} */
yfiles.input.GraphEditorInputMode.prototype.labelSnapContext;
 /** @type {!yfiles.input.MoveLabelInputMode} */
yfiles.input.GraphEditorInputMode.prototype.moveLabelInputMode;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowGroupingOperations;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowGroupSelection;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowAdjustGroupNodeSize;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowUngroupSelection;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowClearSelection;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowPaste;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowDuplicate;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowUndoOperations;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowReparentNodes;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowReparentToNonGroupNodes;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowCreateNode;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowCreateBend;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowCreateEdge;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.allowReverseEdge;
 /** @type {function(?, ?, !yfiles.geometry.Point, ?): ?} */
yfiles.input.GraphEditorInputMode.prototype.nodeCreator;
 /** @type {!yfiles.input.TextEditorInputMode} */
yfiles.input.GraphEditorInputMode.prototype.textEditorInputMode;
 /** @type {!yfiles.input.CreateEdgeInputMode} */
yfiles.input.GraphEditorInputMode.prototype.createEdgeInputMode;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.autoRemoveEmptyLabels;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.autoSelectSelfloopBends;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.hideLabelDuringEditing;
 /** @type {!yfiles.input.CreateBendInputMode} */
yfiles.input.GraphEditorInputMode.prototype.createBendInputMode;
 /** @type {!yfiles.input.NodeDropInputMode} */
yfiles.input.GraphEditorInputMode.prototype.nodeDropInputMode;
 /** @type {boolean} */
yfiles.input.GraphEditorInputMode.prototype.waiting;
 /** @type {!yfiles.lang.Class} */
yfiles.input.GraphEditorInputMode.$class;

/**
 * Adds a new label to the given item interactively.
 * <p>
 * This will activate the {\@link yfiles.input.GraphEditorInputMode#textEditorInputMode} to let the user interactively enter the label's text and unless the user cancels label creation
 * the returned {\@link yfiles.graphml.Future.<T>} will contain the label.
 * </p>
 * <p>
 * The text that the user enters may be {\@link yfiles.input.GraphEditorInputMode#addValidateLabelTextListener validated} before the label is actually added.
 * </p>
 * <p>
 * This method works nearly identical to {\@link yfiles.input.GraphEditorInputMode#createLabel}. The only difference is when either
 * the {\@link yfiles.input.GraphEditorInputMode#addLabelAddingListener LabelAdding} event is handled, or <code>owner</code>
 * has an
 * {\@link yfiles.input.IEditLabelHelper}, and via those instead of adding a label an existing one should be edited. This method
 * will edit that label instead of adding a new one.
 * </p>
 * @param {?} owner The item to add a label to.
 * @return {!Promise<?>} A Promise that fulfills with the edited label instance. It will fulfill with <code>null</code> if {\@link #addEditingCanceledListener editing was canceled} or the text
 * did not {\@link #addValidateLabelTextListener validate}.
 */
yfiles.input.GraphEditorInputMode.prototype.addLabel = function(owner) {};

/**
 * Updates the {\@link yfiles.view.CanvasComponent#contentRect} using {\@link yfiles.view.CanvasComponent#updateContentRect} and {\@link yfiles.input.GraphEditorInputMode#contentRectMargins}
 * <p>
 * This method is called whenever the content changes and takes the {\@link yfiles.input.GraphEditorInputMode#adjustContentRectPolicy} into account.
 * </p>
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.adjustContentRect = function() {};

/**
 * {\@link yfiles.graph.IGraph#adjustGroupNodeLayout Adjusts the size} of the group nodes in the enumerable.
 * <p>
 * This action is executed in response to the {\@link yfiles.input.ICommand#ADJUST_GROUP_NODE_SIZE} if {\@link yfiles.input.GraphEditorInputMode#allowAdjustGroupNodeSize} is set to <code>true</code>.
 * </p>
 * @protected
 * @param {?<?>} nodes The nodes to adjust their sizes.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.adjustGroupNodeSize = function(nodes) {};

/**
 * {\@link yfiles.graph.IGraph#adjustGroupNodeLayout Adjusts the size} of the selected group nodes.
 * <p>
 * This method delegates to {\@link yfiles.input.GraphEditorInputMode#adjustGroupNodeSize} with the {\@link yfiles.view.IGraphSelection#selectedNodes currently selected nodes}.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#adjustGroupNodeSize
 * @see yfiles.input.ICommand#ADJUST_GROUP_NODE_SIZE
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.adjustGroupNodeSizes = function() {};

/**
 * Adjusts the node's {\@link yfiles.graph.INode#layout} to adhere to possible {\@link yfiles.input.INodeSizeConstraintProvider size constraints}.
 * <p>
 * This method will use the {\@link yfiles.input.INodeSizeConstraintProvider} for {\@link yfiles.graph.INode} that can be found in their {\@link yfiles.graph.ILookup}
 * to make sure they are still valid. The actual work of this method will be delegated to
 * {\@link yfiles.input.GraphEditorInputMode#setNodeLayout}.
 * </p>
 * @param {?} node The node to possibly adjust the size of.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.adjustToSizeConstraints = function(node) {};

/**
 * Creates a node on click.
 * <p>
 * This method is only called if no item has been and {\@link yfiles.input.GraphInputMode#clickClearSelection} returned <code>false</code>.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#shouldClickCreateNode
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Point} location The location of the click.
 * @return {boolean} <code>true</code> if a node was successfully created, otherwise <code>false</code>.
 */
yfiles.input.GraphEditorInputMode.prototype.clickCreateNode = function(context, location) {};

/**
 * Closes the label editor if it is currently open.
 * @param {boolean} cancel Whether to cancel the editor and discard changes.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.closeLabelEditor = function(cancel) {};

/**
 * Factory method for the {\@link yfiles.input.GraphEditorInputMode#createBendInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphEditorInputMode#createBendInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.CreateBendInputMode} a new instance of <code>CreateBendInputMode</code>
 */
yfiles.input.GraphEditorInputMode.prototype.createCreateBendInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphEditorInputMode#createEdgeInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphEditorInputMode#createEdgeInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.CreateEdgeInputMode} a new instance of CreateEdgeInputMode
 */
yfiles.input.GraphEditorInputMode.prototype.createCreateEdgeInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphEditorInputMode#handleInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphEditorInputMode#handleInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.HandleInputMode} a new instance of HandleInputMode
 */
yfiles.input.GraphEditorInputMode.prototype.createHandleInputMode = function() {};

/**
 * Interactively creates a new label for the provided label owner.
 * <p>
 * This method will invoke the text editor that will let the user edit the text of the label. If the user commits the label
 * text the label will be added to the label owner.
 * </p>
 * <p>
 * The text that the user enters may be {\@link yfiles.input.GraphEditorInputMode#addValidateLabelTextListener validated} before the label is actually added.
 * </p>
 * <p>
 * This method works nearly identical to {\@link yfiles.input.GraphEditorInputMode#addLabel}. The only difference is when either the
 * {\@link yfiles.input.GraphEditorInputMode#addLabelAddingListener LabelAdding} event is handled, or <code>owner</code>
 * has an
 * {\@link yfiles.input.IEditLabelHelper}, and via those instead of adding a label an existing one should be edited. This method
 * will do nothing instead of editing an existing label or adding a new one in that case.
 * </p>
 * @param {?} owner The item to create a new label for.
 * @return {!Promise<?>} A Promise that fulfills with the edited label instance. It will fulfill with <code>null</code> if {\@link #addEditingCanceledListener editing was canceled} or the text
 * did not {\@link #addValidateLabelTextListener validate}.
 */
yfiles.input.GraphEditorInputMode.prototype.createLabel = function(owner) {};

/**
 * Factory method for the {\@link yfiles.input.GraphEditorInputMode#moveInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.MoveInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.MoveInputMode} a new instance of MoveInputMode
 */
yfiles.input.GraphEditorInputMode.prototype.createMoveInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphEditorInputMode#moveLabelInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphEditorInputMode#moveLabelInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.MoveLabelInputMode} a new instance of {\@link }
 */
yfiles.input.GraphEditorInputMode.prototype.createMoveLabelInputMode = function() {};

/**
 * Helper method that can be used to create a {\@link yfiles.input.MoveInputMode} instance that can be used to move unselected model
 * items.
 * <p>
 * In order to use this mode, the created instance should be installed in a {\@link yfiles.input.GraphEditorInputMode} like this but
 * using a smaller {\@link yfiles.input.IInputMode#priority priority} value than the {\@link yfiles.input.IInputMode#priority priority} of the mode that is {\@link yfiles.input.GraphEditorInputMode#moveInputMode installed by default}.
 * </p>
 * @param {function(!Object, !yfiles.lang.EventArgs): boolean} recognizer Use this instance to make this mode work under certain conditions only. <code>null</code> for default behavior, one of the {\@link }
 * constants, e.g. for alternate behavior.
 * @return {!yfiles.input.MoveInputMode} A {\@link #moveInputMode} instance that uses the {\@link } instances of the items that are hit at the position of the
 * cursor, regardless of their selection state.
 */
yfiles.input.GraphEditorInputMode.prototype.createMoveUnselectedInputMode = function(recognizer) {};

/**
 * Creates a node given a certain click point.
 * <p>
 * This implementation delegates to the current node creation callback or simply returns <code>null</code> if there is no such callback
 * or {\@link yfiles.input.GraphEditorInputMode#allowCreateNode} yields <code>false</code>. Finally, it tries to {\@link yfiles.input.GraphInputMode#setCurrentItem set the node as the current item}.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#onNodeCreated
 * @see yfiles.input.GraphInputMode#setCurrentItem
 * @param {!yfiles.geometry.Point} location The point where the mouse had been clicked.
 * @return {?} The newly created node or <code>null</code>.
 */
yfiles.input.GraphEditorInputMode.prototype.createNode = function(location) {};

/**
 * Factory method that creates the {\@link yfiles.input.GraphEditorInputMode#nodeDropInputMode} lazily the first time the property is accessed.
 * @protected
 * @return {!yfiles.input.NodeDropInputMode} A plain new instance of the {\@link } type, which is initially {\@link #enabled disabled}.
 */
yfiles.input.GraphEditorInputMode.prototype.createNodeDropInputMode = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphEditorInputMode#reparentNodeHandler} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphEditorInputMode#reparentNodeHandler} property.
 * </p>
 * @protected
 * @return {?} a new instance of {\@link #reparentNodeHandler}
 */
yfiles.input.GraphEditorInputMode.prototype.createReparentNodeHandler = function() {};

/**
 * Factory method for the {\@link yfiles.input.GraphEditorInputMode#textEditorInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.GraphEditorInputMode#textEditorInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.TextEditorInputMode} a new instance of TextEditorInputMode
 */
yfiles.input.GraphEditorInputMode.prototype.createTextEditorInputMode = function() {};

/**
 * Cuts and inserts the currently selected elements to the clipboard.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.cut = function() {};

/**
 * This method deletes the currently selected elements.
 * <p>
 * If the {\@link yfiles.view.GraphSelection} is non-empty this implementation triggers the {\@link yfiles.input.GraphEditorInputMode#addDeletingSelectionListener DeletingSelection}
 * event, possibly a number of {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * events, and a final {\@link yfiles.input.GraphEditorInputMode#deleteSelection} event. Note that {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * will not be called for items that are removed implicitly, e.g. if the event is triggered for a node, its labels, ports,
 * and adjacent edges will not be reported separately.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#addDeletingSelectionListener
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.input.GraphEditorInputMode#addDeletedSelectionListener
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.deleteSelection = function() {};

/**
 * Initiates the {\@link yfiles.input.GraphEditorInputMode#handleInputMode} to drag the given bend.
 * @see yfiles.input.GraphEditorInputMode#onCreateBendInputModeBendCreated
 * @param {?} bend The bend to drag.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.dragBend = function(bend) {};

/**
 * Duplicates the selected elements.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.duplicateSelection = function() {};

/**
 * Starts editing the given label.
 * <p>
 * This implementation uses the {\@link yfiles.input.TextEditorInputMode} to display an editor to edit the label. The text that the
 * user enters may be {\@link yfiles.input.GraphEditorInputMode#addValidateLabelTextListener validated} before the label is actually edited.
 * </p>
 * <p>
 * The label to edit can be a
 * {\@link yfiles.graph.SimpleLabel}, which will be edited as usual, except that the label text changes will be written directly
 * back into the instance.
 * </p>
 * <p>
 * This method will raise the {\@link yfiles.input.GraphEditorInputMode#addLabelEditingListener LabelEditing}
 * event and query the {\@link yfiles.input.IEditLabelHelper} for the label and its owner, but will ignore the result except for the
 * {\@link yfiles.input.LabelEditingEventArgs#textEditorInputModeConfigurator} property on the {\@link yfiles.input.LabelEditingEventArgs}. Thus editing a label via this method cannot be prevented by event
 * handlers or {\@link yfiles.input.IEditLabelHelper}s.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#onLabelTextEdited
 * @param {?} label The label to edit.
 * @return {!Promise<?>} A Promise that fulfills with the edited label instance. It will also fulfill with the instance if editing is {\@link #addEditingCanceledListener editing was canceled}
 * or the text did not {\@link #addValidateLabelTextListener validate} and the edit was reverted automatically.
 */
yfiles.input.GraphEditorInputMode.prototype.editLabel = function(label) {};

/**
 * Starts label editing by executing {\@link yfiles.input.ICommand#EDIT_LABEL }.
 * <p>
 * The method should return whether the request was satisfied.
 * </p>
 * @see yfiles.input.GraphInputMode#doubleClick
 * @see yfiles.input.GraphEditorInputMode#allowEditLabelOnDoubleClick
 * @protected
 * @param {?} item The item whose label or the label itself that should be edited upon the double click gesture.
 * @return {boolean} <code>true</code> iff the request was handled.
 */
yfiles.input.GraphEditorInputMode.prototype.editLabelOnDoubleClick = function(item) {};

/**
 * Creates a new group for all of the currently selected elements.
 * <p>
 * This method will also clear the selection and select the newly created group node.
 * </p>
 * <p>
 * The default shortcut for this is Ctrl+G.
 * </p>
 * @see yfiles.input.ICommand#GROUP_SELECTION
 * @see yfiles.input.GraphInputMode#clearSelection
 * @see yfiles.input.GraphInputMode#setSelected
 * @return {?} The newly created group node or <code>null</code>.
 */
yfiles.input.GraphEditorInputMode.prototype.groupSelection = function() {};

/**
 * Callback that is invoked if the shift+F2 key is pressed and {\@link yfiles.input.GraphEditorInputMode#allowAddLabel} is set to <code>true</code>.
 * <p>
 * This method determines the label owner to add to and delegates to {\@link yfiles.input.GraphEditorInputMode#createLabel}.
 * </p>
 * @protected
 * @return {boolean}
 */
yfiles.input.GraphEditorInputMode.prototype.onAddLabel = function() {};

/**
 * Callback that is called as soon as {\@link yfiles.input.CreateBendInputMode} created a new bend.
 * <p>
 * This method selects the bend and starts the {\@link yfiles.input.GraphEditorInputMode#handleInputMode} using the handle for the newly created bend. The bend is created using the
 * hit edge's {\@link yfiles.input.IBendCreator} implementation, as obtained from the edge's {\@link yfiles.graph.ILookup#lookup} and calls
 * {\@link yfiles.input.GraphEditorInputMode#dragBend}. If the subsequent drag is canceled by the user, this call will remove the
 * bend again.
 * </p>
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.collections.ItemEventArgs<?>} evt
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onCreateBendInputModeBendCreated = function(sender, evt) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#createBendInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.CreateBendInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.CreateBendInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onCreateBendInputModeChanged = function(oldMode, newMode) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#createEdgeInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.CreateEdgeInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.CreateEdgeInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onCreateEdgeInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onDeletedItem = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addDeletedSelectionListener DeletedSelection} event.
 * @protected
 * @param {!yfiles.input.SelectionEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onDeletedSelection = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addDeletingSelectionListener DeletingSelection} event.
 * @protected
 * @param {!yfiles.input.SelectionEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onDeletingSelection = function(evt) {};

/**
 * Callback to be invoked after an edge's source and/or target ports have been changed as the result of an input gesture.
 * <p>
 * Dispatches the {\@link yfiles.input.GraphEditorInputMode#addEdgePortsChangedListener EdgePortsChanged} event.
 * </p>
 * @protected
 * @param {!yfiles.graph.EdgeEventArgs} evt The {\@link } for the
 * {\@link #addEdgePortsChangedListener EdgePortsChanged}.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onEdgePortsChanged = function(evt) {};

/**
 * Callback that is invoked if the F2 key is pressed and {\@link yfiles.input.GraphEditorInputMode#allowEditLabel} is set to <code>true</code>.
 * <p>
 * This method determines the label to edit and delegates to either {\@link yfiles.input.GraphEditorInputMode#editLabel} or {\@link yfiles.input.GraphEditorInputMode#createLabel}
 * if no label could be found.
 * </p>
 * @protected
 * @return {boolean}
 */
yfiles.input.GraphEditorInputMode.prototype.onEditLabel = function() {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#graphComponent} property changes.
 * @protected
 * @param {!yfiles.view.GraphComponent} oldGraphComponent The old control.
 * @param {!yfiles.view.GraphComponent} newGraphComponent The new control.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onGraphComponentChanged = function(oldGraphComponent, newGraphComponent) {};

/**
 * Called when the {\@link yfiles.view.GraphSelection} property changes.
 * <p>
 * This will update the internal state of the modes.
 * </p>
 * @protected
 * @param {?} oldSelection The old selection instance.
 * @param {?} newSelection The new selection instance.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onGraphSelectionChanged = function(oldSelection, newSelection) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#handleInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.HandleInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.HandleInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onHandleInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addLabelAddedListener LabelAdded} event.
 * @protected
 * @param {!yfiles.graph.LabelEventArgs} evt The {\@link } instance that contains the {\@link } that has been added.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onLabelAdded = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addLabelAddingListener LabelAdding} event.
 * <p>
 * Invoking the event handlers stops once one event marks the <code>args</code> as handled.
 * </p>
 * @protected
 * @param {!yfiles.input.LabelEditingEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onLabelAdding = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addLabelEditingListener LabelEditing} event.
 * <p>
 * Invoking the event handlers stops once one event marks the <code>args</code> as handled.
 * </p>
 * @protected
 * @param {!yfiles.input.LabelEditingEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onLabelEditing = function(evt) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#labelSnapContext} property context changed.
 * @protected
 * @param {!yfiles.input.SnapContext} oldContext The old snap context.
 * @param {!yfiles.input.SnapContext} newContext The new snap context.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onLabelSnapContextChanged = function(oldContext, newContext) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addLabelTextChangedListener LabelTextChanged} event.
 * @protected
 * @param {!yfiles.graph.LabelEventArgs} evt The {\@link } instance that contains the {\@link } that has changed the text.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onLabelTextChanged = function(evt) {};

/**
 * Called when the text of a label has been {\@link yfiles.input.GraphEditorInputMode#editLabel edited}.
 * <p>
 * This method {\@link yfiles.input.GraphEditorInputMode#addValidateLabelTextListener validates the label text} and if successful calls {\@link yfiles.input.GraphEditorInputMode#setLabelText}.
 * </p>
 * @protected
 * @param {?} label The label that was edited.
 * @param {string} text The new text.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onLabelTextEdited = function(label, text) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addLabelTextEditingCanceledListener LabelTextEditingCanceled}
 * event.
 * @protected
 * @param {!yfiles.graph.LabelEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onLabelTextEditingCanceled = function(evt) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addLabelTextEditingStartedListener LabelTextEditingStarted}
 * event.
 * @protected
 * @param {!yfiles.graph.LabelEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onLabelTextEditingStarted = function(evt) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#moveInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.MoveInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.MoveInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onMoveInputModeChanged = function(oldMode, newMode) {};

/**
 * Called when {\@link yfiles.input.MoveInputMode#addDragCanceledListener DragCanceled} is triggered.
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.lang.EventArgs} evt
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onMoveInputModeDragCanceled = function(sender, evt) {};

/**
 * Called when {\@link yfiles.input.MoveInputMode#addDragFinishedListener DragFinished} is triggered.
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.lang.EventArgs} evt
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onMoveInputModeDragFinished = function(sender, evt) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#moveLabelInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.MoveLabelInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.MoveLabelInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onMoveLabelInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addNodeCreatedListener NodeCreated} event.
 * <p>
 * Note that if {\@link yfiles.input.NodeDropInputMode#allowFolderNodeAsParent} is set to <code>true</code>, the reported node can actually be part of the {\@link yfiles.graph.IFoldingView master graph}.
 * </p>
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance containing the created node.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onNodeCreated = function(evt) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#nodeDropInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.NodeDropInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.NodeDropInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onNodeDropInputModeChanged = function(oldMode, newMode) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#nodeDropInputMode}'s {\@link yfiles.input.ItemDropInputMode.<T>#addItemCreatedListener ItemCreated} event is triggered.
 * <p>
 * This implementation {\@link yfiles.input.GraphEditorInputMode#adjustContentRect adjusts the content rect}, triggers the {\@link yfiles.input.GraphEditorInputMode#addNodeCreatedListener NodeCreated}
 * event and tries to set the newly created node as the {\@link yfiles.input.GraphInputMode#setCurrentItem current item}.
 * </p>
 * @protected
 * @param {!Object} sender The sender.
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The event argument instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onNodeDropInputModeNodeCreated = function(sender, evt) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addNodeReparentedListener NodeReparented} event.
 * @see yfiles.input.GraphEditorInputMode#reparentNodeHandler
 * @protected
 * @param {!yfiles.graph.NodeEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onNodeReparented = function(evt) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#reparentNodeHandler} property value changes and after initialization of the field.
 * @protected
 * @param {?} oldMode the old value, which may be <code>null</code> the first time
 * @param {?} newMode the new value
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onReparentNodeHandlerChanged = function(oldMode, newMode) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#snapContext} property context changed.
 * @protected
 * @param {!yfiles.input.SnapContext} oldContext The old snap context.
 * @param {!yfiles.input.SnapContext} newContext The new snap context.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onSnapContextChanged = function(oldContext, newContext) {};

/**
 * Called when the {\@link yfiles.input.GraphEditorInputMode#textEditorInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.TextEditorInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.TextEditorInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onTextEditorInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.GraphEditorInputMode#addValidateLabelTextListener ValidateLabelText} event.
 * @protected
 * @param {!yfiles.input.LabelTextValidatingEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.onValidateLabelText = function(evt) {};

/**
 * Pastes the current clipboard contents.
 * @see yfiles.input.GraphEditorInputMode#pasteAtLocation
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.paste = function() {};

/**
 * Pastes the current clipboard contents at the given location.
 * <p>
 * The location is at the center of the bounds of the items that are pasted. This method reconfigures {\@link yfiles.graph.GraphClipboard#pasteDelta} and calls
 * {\@link yfiles.input.GraphEditorInputMode#paste}.
 * </p>
 * @param {!yfiles.geometry.Point} location The location at which the center of the clipboard's contents should be positioned.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.pasteAtLocation = function(location) {};

/**
 * Delegates to the {\@link yfiles.graph.IGraph}'s {\@link yfiles.graph.UndoEngine}'s {\@link yfiles.graph.UndoEngine#redo} method.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.redo = function() {};

/**
 * Trigger a reevaluation of all visible handles
 * <p>
 * This method is called when the {\@link yfiles.input.GraphEditorInputMode#showHandleItems} property is changed.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.requeryHandles = function() {};

/**
 * Reverses the given edges.
 * <p>
 * The edge will only be reversed if {\@link yfiles.input.GraphEditorInputMode#allowReverseEdge} is set to <code>true</code> and {\@link yfiles.input.GraphEditorInputMode#shouldReverseEdge} returns <code>true</code>
 * for the edge. A {\@link yfiles.input.GraphEditorInputMode#addEdgePortsChangedListener EdgePortsChanged} event
 * will be dispatched after the edge has been reversed.
 * </p>
 * @param {?} edge
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.reverseEdge = function(edge) {};

/**
 * Reverses the given edges.
 * <p>
 * The edges will only be reversed if {\@link yfiles.input.GraphEditorInputMode#allowReverseEdge} is set to <code>true</code> and {\@link yfiles.input.GraphEditorInputMode#shouldReverseEdge} returns <code>true</code>
 * for the edge.
 * </p>
 * <p>
 * For each edge a {\@link yfiles.input.GraphEditorInputMode#addEdgePortsChangedListener EdgePortsChanged} event
 * will be dispatched.
 * </p>
 * @see yfiles.input.ICommand#REVERSE_EDGE
 * @param {?<?>} edges
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.reverseEdges = function(edges) {};

/**
 * Reverses the selected edges.
 * <p>
 * This implementation invokes {\@link yfiles.input.GraphEditorInputMode#reverseEdges} providing the {\@link yfiles.view.GraphSelection selected edges}.
 * </p>
 * <p>
 * The edges will only be reversed if {\@link yfiles.input.GraphEditorInputMode#shouldReverseEdge} returns <code>true</code> for each edge.
 * </p>
 * <p>
 * For each edge an {\@link yfiles.input.GraphEditorInputMode#addEdgePortsChangedListener EdgePortsChanged} event
 * will be dispatched.
 * </p>
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.reverseSelectedEdges = function() {};

/**
 * Selects the node and possible bends of selfloop edges.
 * <p>
 * This method delegates to {\@link yfiles.input.GraphInputMode#setSelected} for the node and all adjacent self loop bends.
 * </p>
 * @param {?} node The node to select.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.selectNodeAndSelfloopBends = function(node) {};

/**
 * Sets the label's text after it has been {\@link yfiles.input.GraphEditorInputMode#editLabel edited}.
 * <p>
 * Depending on {\@link yfiles.input.GraphEditorInputMode#autoRemoveEmptyLabels} it will either set the label's text or remove it from the graph. Also this method will query the label's {\@link yfiles.graph.ILabel#owner}
 * for an {\@link yfiles.input.INodeSizeConstraintProvider} if the owner is an {\@link yfiles.graph.INode} and will make sure that the size
 * constraints are still kept if the {\@link yfiles.graph.ILabel#preferredSize} changes due to the edit by calling
 * {\@link yfiles.input.GraphEditorInputMode#adjustToSizeConstraints}.
 * </p>
 * @param {?} label The label to set the text or remove.
 * @param {string} text The new text.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.setLabelText = function(label, text) {};

/**
 * Updates the bounds of the node.
 * <p>
 * This method differs from a simple call to {\@link yfiles.graph.IGraph#setNodeLayout} in a number of ways:
 * </p>
 * <ul>
 * <li>An undo unit is enqueued.</li>
 * <li>
 * The node is reshaped interactively using the {\@link yfiles.input.IReshapeHandler} implementation found in its lookup. This
 * enables correctly adjusting e.g. affected orthogonal edges and parent group nodes.
 * </li>
 * <li>{\@link yfiles.input.GraphEditorInputMode#adjustContentRect} is called.</li>
 * </ul>
 * @param {?} node The node to reshape.
 * @param {!yfiles.geometry.Rect} layout The new node layout.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.setNodeLayout = function(node, layout) {};

/**
 * Predicate that determines whether a label may be added interactively to <code>item</code>
 * <p>
 * This is overridden if the item has a {\@link yfiles.input.IEditLabelHelper} that returns <code>false</code> for its {\@link yfiles.input.IEditLabelHelper#onLabelAdding}
 * method.
 * </p>
 * @protected
 * @param {?} item The item to query
 * @return {boolean} <code>true</code> iff a label may be added
 */
yfiles.input.GraphEditorInputMode.prototype.shouldAddLabel = function(item) {};

/**
 * Specifies whether a node should be created by
 * {\@link yfiles.input.ClickInputMode#addClickedListener Clicked}.
 * <p>
 * This implementation returns false when {\@link yfiles.input.ContextMenuInputMode#swallowCloseClick} is <code>true</code> and the click has closed a context menu.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#clickCreateNode
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Point} clickPoint The location of the click.
 * @return {boolean} Whether {\@link #clickCreateNode} should be called to create a node.
 */
yfiles.input.GraphEditorInputMode.prototype.shouldClickCreateNode = function(context, clickPoint) {};

/**
 * Callback method that determines whether the given item should be deleted during
 * {\@link yfiles.input.GraphEditorInputMode#deleteSelection}.
 * <p>
 * This implementation uses and honors the {\@link yfiles.input.GraphEditorInputMode#deletableItems} and {\@link yfiles.input.GraphEditorInputMode#deletablePredicate} properties.
 * </p>
 * @protected
 * @param {?} item The item.
 * @return {boolean} Whether to delete that item.
 */
yfiles.input.GraphEditorInputMode.prototype.shouldDelete = function(item) {};

/**
 * Callback method that determines whether the label or the labels of the provided item should be edited in response to {\@link yfiles.input.GraphEditorInputMode#onEditLabel}
 * or {\@link yfiles.input.GraphEditorInputMode#onAddLabel}.
 * @protected
 * @param {?} item The item.
 * @return {boolean} Whether to edit the label or the labels for that item.
 */
yfiles.input.GraphEditorInputMode.prototype.shouldEditLabel = function(item) {};

/**
 * Determines whether or not moving the item is allowed.
 * <p>
 * This predicate determines whether an item can be moved by <b>any</b> appropriate input mode, e.g by default it also evaluates to <code>true</code>
 * for {\@link yfiles.graph.ILabel}s which are moved by {\@link yfiles.input.GraphEditorInputMode#moveLabelInputMode} instead of {\@link yfiles.input.GraphEditorInputMode#moveInputMode}.
 * </p>
 * <p>
 * This implementation returns the result of the {\@link yfiles.input.GraphEditorInputMode#movableItems} property for the given item.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#movableItems
 * @see yfiles.input.GraphEditorInputMode#moveInputMode
 * @see yfiles.input.GraphEditorInputMode#moveLabelInputMode
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} Whether or not moving the item is allowed.
 */
yfiles.input.GraphEditorInputMode.prototype.shouldMove = function(item) {};

/**
 * Callback which determines whether the given edge should be reversed by {\@link yfiles.input.GraphEditorInputMode#reverseEdge},
 * {\@link yfiles.input.GraphEditorInputMode#reverseEdges}, or {\@link yfiles.input.GraphEditorInputMode#reverseEdges}.
 * <p>
 * This implementation returns the value of {\@link yfiles.input.GraphEditorInputMode#allowReverseEdge}.
 * </p>
 * @protected
 * @param {?} edge The edge which should be reversed.
 * @return {boolean} <code>true</code> if the edge should be reversed.
 */
yfiles.input.GraphEditorInputMode.prototype.shouldReverseEdge = function(edge) {};

/**
 * Can be overridden to determine which items should be selected after {\@link yfiles.input.GraphEditorInputMode#paste} or
 * {\@link yfiles.input.GraphEditorInputMode#duplicateSelection}.
 * <p>
 * This implementation returns <code>true</code> for the {\@link yfiles.input.GraphEditorInputMode#pasteSelectableItems} items.
 * </p>
 * @protected
 * @param {?} item The item to check.
 * @return {boolean} Whether to select the item after {\@link #paste} or
 * {\@link #duplicateSelection}.
 */
yfiles.input.GraphEditorInputMode.prototype.shouldSelectAfterPaste = function(item) {};

/**
 * Determines whether to show the {\@link yfiles.input.GraphEditorInputMode#handleInputMode handles} for the given item.
 * @protected
 * @param {?} item The item to check
 * @return {boolean} Whether to show the item based on the setting of the corresponding {\@link #showHandleItems}, property.
 */
yfiles.input.GraphEditorInputMode.prototype.shouldShowHandles = function(item) {};

/**
 * Snaps the node to the grid using the {\@link yfiles.input.IGridConstraintProvider.<T>} for {\@link yfiles.graph.INode}s queried from the given context.
 * <p>
 * This method is called by this instance whenever new nodes are created using the UI.
 * </p>
 * @see yfiles.input.MultiplexingInputMode#createChildInputModeContext
 * @param {?} context
 * @param {?} node
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.snapToGrid = function(context, node) {};

/**
 * Delegates to the {\@link yfiles.graph.IGraph}'s {\@link yfiles.graph.UndoEngine}'s {\@link yfiles.graph.UndoEngine#undo} method.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.undo = function() {};

/**
 * Makes each of the currently selected nodes a direct child of the root group.
 * <p>
 * The default shortcut for this is Ctrl+U.
 * </p>
 * @see yfiles.input.ICommand#UNGROUP_SELECTION
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.ungroupSelection = function() {};

/**
 * Adds the given listener for the <code>LabelAdded</code> event that occurs when this mode has triggered the addition of an
 * {\@link yfiles.graph.ILabel}, for instance, in response to {\@link yfiles.input.GraphEditorInputMode#createLabel}.
 * @see yfiles.input.GraphEditorInputMode#removeLabelAddedListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addLabelAddedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelAdded</code> event that occurs when this mode has triggered the addition of an
 * {\@link yfiles.graph.ILabel}, for instance, in response to {\@link yfiles.input.GraphEditorInputMode#createLabel}.
 * @see yfiles.input.GraphEditorInputMode#addLabelAddedListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeLabelAddedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelTextEditingStarted</code> event that occurs when the actual label editing process is about
 * to start.
 * <p>
 * This allows to customize the label editing process.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#addValidateLabelTextListener
 * @see yfiles.input.GraphEditorInputMode#removeLabelTextEditingStartedListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addLabelTextEditingStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelTextEditingStarted</code> event that occurs when the actual label editing process is
 * about to start.
 * <p>
 * This allows to customize the label editing process.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#addValidateLabelTextListener
 * @see yfiles.input.GraphEditorInputMode#addLabelTextEditingStartedListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeLabelTextEditingStartedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelTextEditingCanceled</code> event that occurs when the actual label editing process is
 * canceled.
 * <p>
 * This allows to unconfigure temporary customizations for the actual label editing process.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#addValidateLabelTextListener
 * @see yfiles.input.GraphEditorInputMode#removeLabelTextEditingCanceledListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addLabelTextEditingCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelTextEditingCanceled</code> event that occurs when the actual label editing process is
 * canceled.
 * <p>
 * This allows to unconfigure temporary customizations for the actual label editing process.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#addValidateLabelTextListener
 * @see yfiles.input.GraphEditorInputMode#addLabelTextEditingCanceledListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeLabelTextEditingCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>ValidateLabelText</code> event that occurs when a label that is about to be {\@link yfiles.input.GraphEditorInputMode#addLabel added} or {\@link yfiles.input.GraphEditorInputMode#editLabel edited}.
 * <p>
 * This event that can be used to validate the label text before inserting/updating the actual label.
 * </p>
 * <p>
 * Note that in the case of {\@link yfiles.input.GraphEditorInputMode#addLabel} the {\@link yfiles.input.LabelTextValidatingEventArgs#label} is not part of the current graph but only a
 * dummy instance.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#onValidateLabelText
 * @see yfiles.input.GraphEditorInputMode#removeValidateLabelTextListener
 * @param {function(!Object, !yfiles.input.LabelTextValidatingEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addValidateLabelTextListener = function(listener) {};

/**
 * Removes the given listener for the <code>ValidateLabelText</code> event that occurs when a label that is about to be {\@link yfiles.input.GraphEditorInputMode#addLabel added} or
 * {\@link yfiles.input.GraphEditorInputMode#editLabel edited}.
 * <p>
 * This event that can be used to validate the label text before inserting/updating the actual label.
 * </p>
 * <p>
 * Note that in the case of {\@link yfiles.input.GraphEditorInputMode#addLabel} the {\@link yfiles.input.LabelTextValidatingEventArgs#label} is not part of the current graph but only a
 * dummy instance.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#onValidateLabelText
 * @see yfiles.input.GraphEditorInputMode#addValidateLabelTextListener
 * @param {function(!Object, !yfiles.input.LabelTextValidatingEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeValidateLabelTextListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelTextChanged</code> event that occurs when this mode has triggered the edit of an
 * {\@link yfiles.graph.ILabel}, for instance, in response to {\@link yfiles.input.GraphEditorInputMode#editLabel}.
 * @see yfiles.input.GraphEditorInputMode#removeLabelTextChangedListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addLabelTextChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelTextChanged</code> event that occurs when this mode has triggered the edit of an
 * {\@link yfiles.graph.ILabel}, for instance, in response to {\@link yfiles.input.GraphEditorInputMode#editLabel}.
 * @see yfiles.input.GraphEditorInputMode#addLabelTextChangedListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeLabelTextChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DeletingSelection</code> event that occurs just before the {\@link yfiles.input.GraphEditorInputMode#deleteSelection}
 * method starts its work and will be followed by any number of {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * events and finalized by a {\@link yfiles.input.GraphEditorInputMode#addDeletedSelectionListener DeletedSelection}
 * event.
 * @see yfiles.input.GraphEditorInputMode#deleteSelection
 * @see yfiles.input.GraphEditorInputMode#removeDeletingSelectionListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addDeletingSelectionListener = function(listener) {};

/**
 * Removes the given listener for the <code>DeletingSelection</code> event that occurs just before the {\@link yfiles.input.GraphEditorInputMode#deleteSelection}
 * method starts its work and will be followed by any number of {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * events and finalized by a {\@link yfiles.input.GraphEditorInputMode#addDeletedSelectionListener DeletedSelection}
 * event.
 * @see yfiles.input.GraphEditorInputMode#deleteSelection
 * @see yfiles.input.GraphEditorInputMode#addDeletingSelectionListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeDeletingSelectionListener = function(listener) {};

/**
 * Adds the given listener for the <code>DeletedItem</code> event that occurs when an item has been deleted interactively by this mode.
 * <p>
 * Note that this event will not be triggered for items that are removed implicitly, e.g. if the event is triggered for a
 * node, its labels, ports, and adjacent edges will not necessarily be reported separately. In order to be notified of any
 * removal events, the {\@link yfiles.graph.IGraph} events should be used instead.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#removeDeletedItemListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addDeletedItemListener = function(listener) {};

/**
 * Removes the given listener for the <code>DeletedItem</code> event that occurs when an item has been deleted interactively by this
 * mode.
 * <p>
 * Note that this event will not be triggered for items that are removed implicitly, e.g. if the event is triggered for a
 * node, its labels, ports, and adjacent edges will not necessarily be reported separately. In order to be notified of any
 * removal events, the {\@link yfiles.graph.IGraph} events should be used instead.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeDeletedItemListener = function(listener) {};

/**
 * Adds the given listener for the <code>DeletedSelection</code> event that occurs just before the {\@link yfiles.input.GraphEditorInputMode#deleteSelection}
 * method has deleted the selection after all selected items have been removed.
 * @see yfiles.input.GraphEditorInputMode#deleteSelection
 * @see yfiles.input.GraphEditorInputMode#removeDeletedSelectionListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addDeletedSelectionListener = function(listener) {};

/**
 * Removes the given listener for the <code>DeletedSelection</code> event that occurs just before the {\@link yfiles.input.GraphEditorInputMode#deleteSelection}
 * method has deleted the selection after all selected items have been removed.
 * @see yfiles.input.GraphEditorInputMode#deleteSelection
 * @see yfiles.input.GraphEditorInputMode#addDeletedSelectionListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeDeletedSelectionListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeReparented</code> event that occurs when a node has been reparented interactively.
 * <p>
 * This is triggered whenever the {\@link yfiles.input.GraphEditorInputMode#reparentNodeHandler}'s {\@link yfiles.input.IReparentNodeHandler#reparent} method has been called to reparent a node
 * interactively.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#reparentNodeHandler
 * @see yfiles.input.GraphEditorInputMode#removeNodeReparentedListener
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addNodeReparentedListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeReparented</code> event that occurs when a node has been reparented interactively.
 * <p>
 * This is triggered whenever the {\@link yfiles.input.GraphEditorInputMode#reparentNodeHandler}'s {\@link yfiles.input.IReparentNodeHandler#reparent} method has been called to reparent a node
 * interactively.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#reparentNodeHandler
 * @see yfiles.input.GraphEditorInputMode#addNodeReparentedListener
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeNodeReparentedListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeCreated</code> event that occurs when this mode has created a node in response to user
 * interaction.
 * <p>
 * This event is triggered if the node is created using a click gesture via {\@link yfiles.input.GraphEditorInputMode#createNode},
 * or via a drag and drop operation that was completed by {\@link yfiles.input.GraphEditorInputMode#nodeDropInputMode}. Note that if {\@link yfiles.input.NodeDropInputMode#allowFolderNodeAsParent} is set to <code>true</code>, the reported node can actually be
 * part of the {\@link yfiles.graph.IFoldingView master graph}.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#createNode
 * @see yfiles.input.GraphEditorInputMode#removeNodeCreatedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addNodeCreatedListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeCreated</code> event that occurs when this mode has created a node in response to user
 * interaction.
 * <p>
 * This event is triggered if the node is created using a click gesture via {\@link yfiles.input.GraphEditorInputMode#createNode},
 * or via a drag and drop operation that was completed by {\@link yfiles.input.GraphEditorInputMode#nodeDropInputMode}. Note that if {\@link yfiles.input.NodeDropInputMode#allowFolderNodeAsParent} is set to <code>true</code>, the reported node can actually be
 * part of the {\@link yfiles.graph.IFoldingView master graph}.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#createNode
 * @see yfiles.input.GraphEditorInputMode#addNodeCreatedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeNodeCreatedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgePortsChanged</code> event that occurs after an edge's source and/or target ports have been
 * changed as the result of an input gesture.
 * @see yfiles.graph.EdgeEventArgs
 * @see yfiles.input.GraphEditorInputMode#reverseSelectedEdges
 * @see yfiles.input.GraphEditorInputMode#reverseEdges
 * @see yfiles.input.GraphEditorInputMode#reverseEdge
 * @see yfiles.input.GraphEditorInputMode#removeEdgePortsChangedListener
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addEdgePortsChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgePortsChanged</code> event that occurs after an edge's source and/or target ports have
 * been changed as the result of an input gesture.
 * @see yfiles.graph.EdgeEventArgs
 * @see yfiles.input.GraphEditorInputMode#reverseSelectedEdges
 * @see yfiles.input.GraphEditorInputMode#reverseEdges
 * @see yfiles.input.GraphEditorInputMode#reverseEdge
 * @see yfiles.input.GraphEditorInputMode#addEdgePortsChangedListener
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeEdgePortsChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelAdding</code> event that occurs when a label is about to be added.
 * <p>
 * Event handlers for this event can customize the behavior for adding a new label extensively. Adding a label can be
 * forbidden entirely, or the properties of the added label can be changed, by setting the appropriate properties on the
 * {\@link yfiles.input.LabelEditingEventArgs}. It is even possible to forbid adding a label, but edit an existing one instead.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#removeLabelAddingListener
 * @param {function(!Object, !yfiles.input.LabelEditingEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addLabelAddingListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelAdding</code> event that occurs when a label is about to be added.
 * <p>
 * Event handlers for this event can customize the behavior for adding a new label extensively. Adding a label can be
 * forbidden entirely, or the properties of the added label can be changed, by setting the appropriate properties on the
 * {\@link yfiles.input.LabelEditingEventArgs}. It is even possible to forbid adding a label, but edit an existing one instead.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#addLabelAddingListener
 * @param {function(!Object, !yfiles.input.LabelEditingEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeLabelAddingListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelEditing</code> event that occurs when a label is about to be edited.
 * <p>
 * Event handlers for this event can customize the behavior for editing an existing label. Editing can be forbidden
 * entirely, or redirected to a different label, even on a different owner. In case editing existing labels is unwanted,
 * event handlers can also specify that instead of editing a label, a new one should be added.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#removeLabelEditingListener
 * @param {function(!Object, !yfiles.input.LabelEditingEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.addLabelEditingListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelEditing</code> event that occurs when a label is about to be edited.
 * <p>
 * Event handlers for this event can customize the behavior for editing an existing label. Editing can be forbidden
 * entirely, or redirected to a different label, even on a different owner. In case editing existing labels is unwanted,
 * event handlers can also specify that instead of editing a label, a new one should be added.
 * </p>
 * @see yfiles.input.GraphEditorInputMode#addLabelEditingListener
 * @param {function(!Object, !yfiles.input.LabelEditingEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.GraphEditorInputMode.prototype.removeLabelEditingListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.ItemDropInputMode = function() {};
 /** @type {boolean} */
yfiles.input.ItemDropInputMode.prototype.showPreview;
 /** @type {boolean} */
yfiles.input.ItemDropInputMode.prototype.snappingEnabled;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ItemDropInputMode.prototype.disableSnappingRecognizer;
 /** @type {boolean} */
yfiles.input.ItemDropInputMode.prototype.highlightDropTarget;
 /** @type {!yfiles.input.SnapContext} */
yfiles.input.ItemDropInputMode.prototype.snapContext;
 /** @type {!yfiles.geometry.Point} */
yfiles.input.ItemDropInputMode.prototype.snappedMousePosition;
 /** @type {?} */
yfiles.input.ItemDropInputMode.prototype.dropTarget;
 /** @type {T} */
yfiles.input.ItemDropInputMode.prototype.draggedItem;
 /** @type {function(?, ?, T, ?, !yfiles.geometry.Point): T} */
yfiles.input.ItemDropInputMode.prototype.itemCreator;
 /** @type {?} */
yfiles.input.ItemDropInputMode.prototype.previewGraph;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ItemDropInputMode.$class;

/**
 * Cleanup method that calls {\@link yfiles.input.ItemDropInputMode.<T>#cleanupSnapContext}, {\@link yfiles.input.ItemDropInputMode.<T>#cleanupPreview} and {\@link yfiles.input.ItemDropInputMode.<T>#cleanupDropTarget}.
 * <p>
 * This method should be called for cleanup actions after a drag/drop gesture has been finished or canceled.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.cleanup = function() {};

/**
 * Cleans up the drop target and its highlighting.
 * @protected
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.cleanupDropTarget = function() {};

/**
 * Cleans up the item preview.
 * @protected
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.cleanupPreview = function() {};

/**
 * Cleans up the snap context.
 * @protected
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.cleanupSnapContext = function() {};

/**
 * Callback registered on the {\@link yfiles.input.SnapContext} that collects {\@link yfiles.input.SnapResult}s for the dragged element.
 * <p>
 * The default implementation doesn't collect any snap results.
 * </p>
 * @protected
 * @param {!Object} source The {\@link } this callback is registered at.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The arguments describing the movement {\@link }s shall be collected for.
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.collectSnapResults = function(source, evt) {};

/**
 * Returns the drop target at the specified location.
 * <p>
 * The drop target is highlighted, if {\@link yfiles.input.ItemDropInputMode.<T>#highlightDropTarget} is enabled. Per default, <code>null</code> is returned.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} dragLocation The location to return the drop target for.
 * @return {?} The drop target at the specified location or <code>null</code> if no drop target can be found.
 */
yfiles.input.ItemDropInputMode.prototype.getDropTarget = function(dragLocation) {};

/**
 * Initializes the drop target.
 * @protected
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.initializeDropTarget = function() {};

/**
 * Initializes the item preview.
 * <p>
 * This method is called by {\@link yfiles.input.ItemDropInputMode.<T>#onDragEntered}. If a preview {\@link yfiles.input.ItemDropInputMode.<T>#showPreview shall be displayed}, the {\@link yfiles.input.ItemDropInputMode.<T>#previewGraph preview graph} is initialized and {\@link yfiles.input.ItemDropInputMode.<T>#populatePreviewGraph}
 * is called.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.initializePreview = function() {};

/**
 * Initializes the snapping context.
 * <p>
 * This method is called by {\@link yfiles.input.ItemDropInputMode.<T>#onDragEntered}
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.initializeSnapContext = function() {};

/**
 * Called whenever a new item is created
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<T>} evt
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.onItemCreated = function(evt) {};

/**
 * Subclasses shall fill the specified graph that is used to preview the dragged item.
 * @protected
 * @param {?} previewGraph The preview graph to fill.
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.populatePreviewGraph = function(previewGraph) {};

/**
 * Calls {\@link yfiles.input.ItemDropInputMode.<T>#getDropTarget} for {\@link yfiles.input.ItemDropInputMode.<T>#snappedMousePosition} and sets the returned item as {\@link yfiles.input.ItemDropInputMode.<T>#dropTarget}.
 * <p>
 * If {\@link yfiles.input.ItemDropInputMode.<T>#highlightDropTarget} is enabled, the highlight is updated as well.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} dragLocation The location to update the drop target for.
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.updateDropTarget = function(dragLocation) {};

/**
 * Subclasses shall update the {\@link yfiles.input.ItemDropInputMode.<T>#previewGraph preview graph} so the dragged item is displayed at the specified <code>dragLocation</code>.
 * @protected
 * @param {?} previewGraph The preview graph to update.
 * @param {!yfiles.geometry.Point} dragLocation The current drag location.
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.updatePreview = function(previewGraph, dragLocation) {};

/**
 * Adds the given listener for the <code>ItemCreated</code> event that occurs when a new item gets created by this input mode.
 * @see yfiles.input.ItemDropInputMode.<T>#removeItemCreatedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.addItemCreatedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ItemCreated</code> event that occurs when a new item gets created by this input mode.
 * @see yfiles.input.ItemDropInputMode.<T>#addItemCreatedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<T>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ItemDropInputMode.prototype.removeItemCreatedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.LabelPositionHandler = function() {};
 /** @type {string} */
yfiles.input.LabelPositionHandler.CANDIDATE_TEMPLATE_KEY;
 /** @type {string} */
yfiles.input.LabelPositionHandler.HIGHLIGHT_TEMPLATE_KEY;
 /** @type {?} */
yfiles.input.LabelPositionHandler.prototype.candidateTemplate;
 /** @type {?} */
yfiles.input.LabelPositionHandler.prototype.highlightTemplate;
 /** @type {?} */
yfiles.input.LabelPositionHandler.prototype.graph;
 /** @type {?} */
yfiles.input.LabelPositionHandler.prototype.label;
 /** @type {?} */
yfiles.input.LabelPositionHandler.prototype.location;
 /** @type {boolean} */
yfiles.input.LabelPositionHandler.prototype.useFinder;
 /** @type {!yfiles.lang.Class} */
yfiles.input.LabelPositionHandler.$class;

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @return {void}
 */
yfiles.input.LabelPositionHandler.prototype.cancelDrag = function(context, originalLocation) {};

/**
 * Creates an {\@link yfiles.view.ICanvasObjectDescriptor} to display the given candidate position.
 * @protected
 * @param {?} context The context for which the descriptor is created.
 * @param {boolean} highlight Whether to highlight the paintable. This will be <code>true</code> for the current position and <code>false</code> for the others.
 * @return {?} An implementation that will render the given candidate.
 */
yfiles.input.LabelPositionHandler.prototype.createCandidateDescriptor = function(context, highlight) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.LabelPositionHandler.prototype.dragFinished = function(context, originalLocation, newLocation) {};

/**
 * Calculates a distance value between a candidate rectangle and the mouse location.
 * @protected
 * @param {?} rectangle The rectangle candidate.
 * @param {!yfiles.geometry.Point} location The mouse location.
 * @return {number} A value indicating the closeness of the mouse to the rectangle.
 */
yfiles.input.LabelPositionHandler.prototype.getDistance = function(rectangle, location) {};

/**
 * Callback method that gets the candidates for the given label.
 * @protected
 * @param {?} label The label.
 * @return {?<?>} A possibly empty enumerator over possible label parameter candidates.
 */
yfiles.input.LabelPositionHandler.prototype.getParameterCandidates = function(label) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.LabelPositionHandler.prototype.handleMove = function(context, originalLocation, newLocation) {};

/**
 *
 * @param {?} context
 * @return {void}
 */
yfiles.input.LabelPositionHandler.prototype.initializeDrag = function(context) {};

/**
 * Actually applies the given parameter at the end of the gesture.
 * @protected
 * @param {?} label The label to set the parameter for.
 * @param {?} layoutParameter The new parameter.
 * @return {void}
 */
yfiles.input.LabelPositionHandler.prototype.setLayoutParameter = function(label, layoutParameter) {};

/**
 *
 * @param {!yfiles.geometry.Point} location
 * @return {void}
 */
yfiles.input.LabelPositionHandler.prototype.setPosition = function(location) {};

/**
 * Determines whether to use a {\@link yfiles.graph.ILabelModelParameterFinder} to find the best candidate.
 * <p>
 * This implementation returns <code>true</code> if the {\@link yfiles.input.LabelPositionHandler#useFinder} property is <code>true</code> and the control key is pressed.
 * </p>
 * @protected
 * @param {?} context The context that is currently being used - may be <code>null</code> if the method is called without context.
 * @return {boolean}
 */
yfiles.input.LabelPositionHandler.prototype.useParameterFinder = function(context) {};
/**
 * @record
 * @struct
 */
yfiles.input.LabelSnapContextHelper = function() {};
 /** @type {!yfiles.input.LabelSnapContextHelper} */
yfiles.input.LabelSnapContextHelper.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.input.LabelSnapContextHelper.$class;

/**
 * Adds snap lines to the <code>snapContext</code> that are parallel to the path segments of the owner edge at the given distance.
 * <p>
 * This method is not used by this class to create its snap lines. Instead, it can be called by custom sub-classes to
 * create this kind of snap lines.
 * </p>
 * @protected
 * Adds snap lines to the <code>snapContext</code> that are parallel to the path segments of the owner edge at particular distances.
 * <p>
 * The corresponding settings of the <code>snapContext</code> specify which snap lines are actually created.
 * </p>
 * @protected
 * @param {!yfiles.input.LabelSnapContext} snapContext The snap context which manages the snap lines and the settings. Note that implementations should not change the state of
 * the context explicitly.
 * @param {?} inputModeContext The context of the input mode that handles the dragging.
 * @param {?} label The edge label that is dragged.
 * @param {number=} distance The distance of the added snap lines from the edge path.
 * @return {void}
 */
yfiles.input.LabelSnapContextHelper.prototype.addEdgePathSnapLines = function(snapContext, inputModeContext, label, distance) {};

/**
 * Adds two snap line for the initial center location of the label, one in the direction of the up vector, the other
 * orthogonal to that direction.
 * <p>
 * This method is called by {\@link yfiles.input.LabelSnapContextHelper#addSnapLines} to add the snap lines for the initial position
 * label location.
 * </p>
 * @protected
 * @param {!yfiles.input.LabelSnapContext} snapContext The snap context which manages the snap lines and the settings. Note that implementations should not change the state of
 * the context explicitly.
 * @param {?} inputModeContext The context of the input mode that handles the dragging.
 * @param {?} label The label that is dragged.
 * @return {void}
 */
yfiles.input.LabelSnapContextHelper.prototype.addInitialLocationSnapLines = function(snapContext, inputModeContext, label) {};

/**
 * Adds snap lines to the <code>snapContext</code> that are parallel to the owner node's border at particular distances.
 * <p>
 * The corresponding settings of the <code>snapContext</code> specify which snap lines are actually created.
 * </p>
 * @protected
 * @param {!yfiles.input.LabelSnapContext} snapContext The snap context which manages the snap lines and the settings. Note that implementations should not change the state of
 * the context explicitly.
 * @param {?} inputModeContext The context of the input mode that handles the dragging.
 * @param {?} label The node label that is dragged.
 * @return {void}
 */
yfiles.input.LabelSnapContextHelper.prototype.addNodeShapeSnapLines = function(snapContext, inputModeContext, label) {};

/**
 * Called during {\@link yfiles.input.IDragHandler#initializeDrag initialization} of a <code>label</code> dragging to add {\@link yfiles.input.SnapLine snap lines} to which the label can potentially snap to the
 * <code>snapContext</code>.
 * @param {!yfiles.input.LabelSnapContext} snapContext The snap context which manages the snap lines and the settings. Note that implementations should not change the state of
 * the context explicitly.
 * @param {?} inputModeContext The context of the input mode that handles the dragging.
 * @param {?} label The label that is dragged.
 * @return {void}
 */
yfiles.input.LabelSnapContextHelper.prototype.addSnapLines = function(snapContext, inputModeContext, label) {};

/**
 *
 * @param {!yfiles.input.LabelSnapContext} context
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt
 * @param {?} suggestedLayout
 * @param {?} label
 * @return {void}
 */
yfiles.input.LabelSnapContextHelper.prototype.collectSnapResults = function(context, evt, suggestedLayout, label) {};
/**
 * @record
 * @struct
 */
yfiles.input.LabelTextValidatingEventArgs = function() {};
 /** @type {?} */
yfiles.input.LabelTextValidatingEventArgs.prototype.label;
 /** @type {string} */
yfiles.input.LabelTextValidatingEventArgs.prototype.newText;
 /** @type {boolean} */
yfiles.input.LabelTextValidatingEventArgs.prototype.cancel;
 /** @type {!yfiles.lang.Class} */
yfiles.input.LabelTextValidatingEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.input.MoveLabelInputMode = function() {};
 /** @type {boolean} */
yfiles.input.MoveLabelInputMode.prototype.useLabelModelParameterFinder;
 /** @type {?} */
yfiles.input.MoveLabelInputMode.prototype.movedLabel;
 /** @type {?} */
yfiles.input.MoveLabelInputMode.prototype.graphSelection;
 /** @type {?} */
yfiles.input.MoveLabelInputMode.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.input.MoveLabelInputMode.$class;

/**
 * Creates the hit testable that will be used to determine whether this mode may be activated.
 * <p>
 * This implementation returns an instance that delegates to {\@link yfiles.input.MoveLabelInputMode#isValidLabelHit}.
 * </p>
 * @protected
 * @return {?} A hit testable.
 */
yfiles.input.MoveLabelInputMode.prototype.createLabelHitTestable = function() {};

/**
 * Creates the {\@link yfiles.input.IPositionHandler position handler} for the given label used in {\@link yfiles.input.MoveLabelInputMode#isValidLabelHit}.
 * <p>
 * First, this implementation checks for a position handler in the label's
 * {\@link yfiles.graph.ILookup lookup}. If this fails, it creates a new label position handler for the given label.
 * </p>
 * @protected
 * @param {?} label The label to create a position handler for.
 * @return {?} A position handler for the given label.
 */
yfiles.input.MoveLabelInputMode.prototype.createLabelPositionHandler = function(label) {};

/**
 * Looks for a label that has been hit at the specified position.
 * <p>
 * This implementation checks the {\@link yfiles.input.MoveLabelInputMode#graphSelection} to see if there is exactly one selected label. This label is returned if it is hit by
 * the mouse and {\@link yfiles.input.MoveLabelInputMode#shouldMove} returns <code>true</code>. Otherwise, <code>null</code> is returned.
 * </p>
 * @see yfiles.input.MoveLabelInputMode#isValidLabelHit
 * @see yfiles.input.MoveLabelInputMode#shouldMove
 * @protected
 * @param {?} context The context for the hit test.
 * @param {!yfiles.geometry.Point} location The coordinates for the hit test.
 * @return {?} The label hit at the given location or <code>null</code>.
 */
yfiles.input.MoveLabelInputMode.prototype.getHitLabel = function(context, location) {};

/**
 * Determines whether or not a valid label has been hit at the specified position.
 * <p>
 * This implementation calls {\@link yfiles.input.MoveLabelInputMode#getHitLabel} to find the label at the specified location. If a
 * label is hit, the {\@link yfiles.input.IPositionHandler} is created by
 * {\@link yfiles.input.MoveLabelInputMode#createLabelPositionHandler}.
 * </p>
 * @protected
 * @param {?} context The context for the hit test.
 * @param {!yfiles.geometry.Point} location The coordinates for the hit test.
 * @return {boolean} <code>true</code> if a valid label is hit and the label moving should be started here. Otherwise, <code>false</code>.
 */
yfiles.input.MoveLabelInputMode.prototype.isValidLabelHit = function(context, location) {};

/**
 * Determines whether or not a label is allowed to be moved.
 * <p>
 * This implementation returns <code>false</code> if the parent input mode {\@link yfiles.input.GraphEditorInputMode#shouldMove forbids} moving the label. Overriding implementations should
 * query this implementation as base if this feature is desired.
 * </p>
 * @see yfiles.input.MoveLabelInputMode#getHitLabel
 * @protected
 * @param {?} context The context.
 * @param {?} label The label to be checked.
 * @return {boolean} <code>true</code> if the label is allowed to move.
 */
yfiles.input.MoveLabelInputMode.prototype.shouldMove = function(context, label) {};
/**
 * @record
 * @struct
 */
yfiles.input.NodeDropInputMode = function() {};
 /** @type {function(?): boolean} */
yfiles.input.NodeDropInputMode.prototype.isGroupNodePredicate;
 /** @type {function(?): boolean} */
yfiles.input.NodeDropInputMode.prototype.isValidParentPredicate;
 /** @type {boolean} */
yfiles.input.NodeDropInputMode.prototype.allowFolderNodeAsParent;
 /** @type {boolean} */
yfiles.input.NodeDropInputMode.prototype.allowNonGroupNodeAsParent;
 /** @type {?} */
yfiles.input.NodeDropInputMode.prototype.draggedItem;
 /** @type {!yfiles.lang.Class} */
yfiles.input.NodeDropInputMode.$class;

/**
 * Creates the node in the graph after it's been dropped.
 * <p>
 * This method is called by the {\@link yfiles.input.ItemDropInputMode.<T>#itemCreator} that is set as default on this class.
 * </p>
 * @protected
 * @param {?} context The context for which the node should be created.
 * @param {?} graph The {\@link  Graph} in which to create the item.
 * @param {?} node The node that was dragged and should therefore be created.
 * @param {?} dropTarget The {\@link } on which the node is dropped.
 * @param {!yfiles.geometry.Rect} layout The bounds of the new node.
 * @return {?} a newly created node.
 */
yfiles.input.NodeDropInputMode.prototype.createNode = function(context, graph, node, dropTarget, layout) {};

/**
 * Calculates the layout of the new node.
 * <p>
 * In this implementation the mouse location is used as center of the node. Can be overridden in child class to implement a
 * different layout.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} mouseLocation Current mouse position
 * @param {!yfiles.geometry.Size} size Size of the node
 * @return {!yfiles.geometry.Rect} a {\@link } with the given size and the mouse location as center.
 */
yfiles.input.NodeDropInputMode.prototype.getNodeLayout = function(mouseLocation, size) {};

/**
 * Starts a drag and drop operation for a {\@link yfiles.graph.INode}.
 * <p>
 * This convenience implementation delegates to {\@link yfiles.view.DragSource#startDrag} passing the <code>node</code> to the {\@link yfiles.view.DragDropItem}
 * using the corresponding type.
 * </p>
 * <p>
 * If <code>useCssCursors</code> is enabled, the following CSS classes are assigned to elements hovered during a drag operation,
 * depending on the allowed drag-drop operations for these elements:
 * </p>
 * <ul>
 * <li><code>yfiles-cursor-dragdrop-move</code></li>
 * <li><code>yfiles-cursor-dragdrop-link</code></li>
 * <li><code>yfiles-cursor-dragdrop-all</code></li>
 * <li><code>yfiles-cursor-dragdrop-no-drop</code></li>
 * </ul>
 * @see yfiles.view.DragSource#startDrag
 * @see yfiles.view.DragDropItem
 * Starts a drag and drop operation for a {\@link yfiles.graph.INode}.
 * <p>
 * This convenience implementation delegates to {\@link yfiles.view.DragSource#startDrag} passing the <code>node</code> to the {\@link yfiles.view.DragDropItem}
 * using the corresponding type.
 * </p>
 * <p>
 * If <code>useCssCursors</code> is enabled, the following CSS classes are assigned to elements hovered during a drag operation,
 * depending on the allowed drag-drop operations for these elements:
 * </p>
 * <ul>
 * <li><code>yfiles-cursor-dragdrop-move</code></li>
 * <li><code>yfiles-cursor-dragdrop-link</code></li>
 * <li><code>yfiles-cursor-dragdrop-all</code></li>
 * <li><code>yfiles-cursor-dragdrop-no-drop</code></li>
 * </ul>
 * @see yfiles.view.DragSource#startDrag
 * @see yfiles.view.DragDropItem
 * @param {!HTMLElement|{dragSource: !HTMLElement, node: ?, dragDropEffects: yfiles.view.DragDropEffects, useCssCursors: boolean}} dragSource_or_options The source of the drag operation.
 * @param {?=} node The node to drag.
 * @param {yfiles.view.DragDropEffects=} dragDropEffects
 * @param {boolean=} useCssCursors
 * @return {void}
 */
yfiles.input.NodeDropInputMode.startDrag = function(dragSource_or_options, node, dragDropEffects, useCssCursors) {};
/**
 * @record
 * @struct
 */
yfiles.input.OrthogonalEdgeEditingContext = function() {};
 /** @type {boolean} */
yfiles.input.OrthogonalEdgeEditingContext.prototype.isInitializing;
 /** @type {boolean} */
yfiles.input.OrthogonalEdgeEditingContext.prototype.enabled;
 /** @type {boolean} */
yfiles.input.OrthogonalEdgeEditingContext.prototype.movePorts;
 /** @type {?} */
yfiles.input.OrthogonalEdgeEditingContext.prototype.currentInputModeContext;
 /** @type {boolean} */
yfiles.input.OrthogonalEdgeEditingContext.prototype.isInitialized;
 /** @type {?<?>} */
yfiles.input.OrthogonalEdgeEditingContext.prototype.addedBends;
 /** @type {?<?>} */
yfiles.input.OrthogonalEdgeEditingContext.prototype.transformedPortOwners;
 /** @type {?<?>} */
yfiles.input.OrthogonalEdgeEditingContext.prototype.lockedPortEdges;
 /** @type {!yfiles.lang.Class} */
yfiles.input.OrthogonalEdgeEditingContext.$class;

/**
 * Registers the provided bend with this instance so that it will be considered explicitly moved for this edit.
 * <p>
 * {\@link yfiles.input.IDragHandler} implementations that are being used to explicitly move a bend during the edit should use this
 * method to register their edit while they are being {\@link yfiles.input.IDragHandler#initializeDrag initialized}.
 * </p>
 * @param {!yfiles.input.MovementInfo} movementInfo The movement info that describes the movement of the bend.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.addExplicitlyMovedBend = function(movementInfo) {};

/**
 * Registers the provided bend as being moved implicitly for this edit.
 * <p>
 * The instance will be returned by {\@link yfiles.input.OrthogonalEdgeEditingContext#createImplicitlyMovedBendInfo} and the {\@link yfiles.input.MovementInfo#moveType} will
 * be combined with the requested move type.
 * </p>
 * @param {!yfiles.input.MovementInfo} movementInfo The movement info for the bend.
 * @return {!yfiles.input.MovementInfo} The info that has been registered with this instance.
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.addImplicitlyMovedBend = function(movementInfo) {};

/**
 * Registers the provided end of the edge with this instance so that it will be considered explicitly moved for this edit.
 * <p>
 * {\@link yfiles.input.IDragHandler} implementations that are being used to explicitly move the end of an edge during the edit
 * should use this method to register their edit while they are being {\@link yfiles.input.IDragHandler#initializeDrag initialized}.
 * </p>
 * @see yfiles.input.IEdgePortHandleProvider
 * @param {!yfiles.input.MovementInfo} movementInfo The movement info that describes the movement of the end of the edge. The {\@link #movedItem} must be an {\@link }.
 * @param {boolean} sourceEnd <code>true</code> if the <code>movementInfo</code> represents the source end of the edge.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.addMovedEdgeEnd = function(movementInfo, sourceEnd) {};

/**
 * Registers the provided port with this instance so that it will be considered explicitly moved for this edit.
 * <p>
 * {\@link yfiles.input.IDragHandler} implementations that are being used to explicitly move a bend during the edit should use this
 * method to register their edit while they are being {\@link yfiles.input.IDragHandler#initializeDrag initialized}.
 * </p>
 * @param {!yfiles.input.MovementInfo} movementInfo The movement info that describes the movement of the port.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.addMovedPort = function(movementInfo) {};

/**
 * Adds an {\@link yfiles.graph.IPortOwner} that is being transformed somehow during the edit so that the attached {\@link yfiles.graph.IPortOwner#ports ports} will be
 * moved in an irregular ({\@link yfiles.input.MoveTypes#ARBITRARY_MOVE non-linear}) way.
 * <p>
 * Normally this will be nodes that are being resized or moved in a non-linear way, or edges, whose bends or ports are
 * being changed.
 * </p>
 * @param {?} owner The item that will be transformed.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.addTransformedPortOwner = function(owner) {};

/**
 * Called by client edit code when a drag has been canceled.
 * <p>
 * Resets all internal state lists and sets {\@link yfiles.input.OrthogonalEdgeEditingContext#isInitialized} back to <code>false</code>. Also {\@link yfiles.input.OrthogonalEdgeEditingContext#removeAddedBends temporarily added bends are removed} and {\@link yfiles.input.OrthogonalEdgeEditingContext#addCleanedUpListener CleanedUp}
 * will be triggered.
 * </p>
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.cancelDrag = function() {};

/**
 * Performs clean up procedures.
 * <p>
 * This is called in response to {\@link yfiles.input.OrthogonalEdgeEditingContext#cancelDrag} and {\@link yfiles.input.OrthogonalEdgeEditingContext#dragFinished}
 * as well as initially during {\@link yfiles.input.OrthogonalEdgeEditingContext#initializeDrag}.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.cleanUp = function() {};

/**
 * Cleans up the edge's path after a successfully {\@link yfiles.input.OrthogonalEdgeEditingContext#dragFinished finished drag}.
 * <p>
 * This implementations delegates to the {\@link yfiles.input.IOrthogonalEdgeHelper}'s {\@link yfiles.input.IOrthogonalEdgeHelper#cleanUpEdge}
 * method.
 * </p>
 * @see yfiles.input.OrthogonalEdgeEditingContext#getOrthogonalEdgeHelper
 * @protected
 * @param {?} graph The graph in which the edge resides.
 * @param {?} edge The modified edge.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.cleanUpEdgePath = function(graph, edge) {};

/**
 * Called after a successfully {\@link yfiles.input.OrthogonalEdgeEditingContext#dragFinished finished drag} to clean up artifacts of modified edges.
 * @see yfiles.input.OrthogonalEdgeEditingContext#cleanUpEdgePath
 * @protected
 * @param {?} graph The graph.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.cleanupEdgePaths = function(graph) {};

/**
 * Creates or obtains a previously created {\@link yfiles.input.MovementInfo} for the provided implicitly moved bend.
 * <p>
 * This method is queried by client {\@link yfiles.input.IDragHandler} implementations that have been initialized for the current
 * edit that need to move adjacent bends implicitly. Implementations should pass as the parameters the movement information
 * that controls the vertical or horizontal movement of the bend implicitly.
 * </p>
 * @param {?} bend The implicitly moved bend.
 * @param {!yfiles.input.MovementInfo} horizontalAdjacentInfo The movement info that implicitly constrains the horizontal movement of the bend or <code>null</code>.
 * @param {!yfiles.input.MovementInfo} verticalAdjacentInfo The movement info that implicitly constrains the vertical movement of the bend or <code>null</code>.
 * @return {!yfiles.input.MovementInfo} The info to be used by clients that requested it.
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.createImplicitlyMovedBendInfo = function(bend, horizontalAdjacentInfo, verticalAdjacentInfo) {};

/**
 * Called when a drag has been successfully finished.
 * <p>
 * This method will perform the necessary clean up and {\@link yfiles.input.OrthogonalEdgeEditingContext#cleanupEdgePaths clean up edge paths}.
 * </p>
 * @see yfiles.input.OrthogonalEdgeEditingContext#addCleanedUpListener
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.dragFinished = function() {};

/**
 * Needs to be called by client editing code after {\@link yfiles.input.OrthogonalEdgeEditingContext#initializeDrag} has been called
 * and all {\@link yfiles.input.IDragHandler}s have been initialized.
 * <p>
 * This method will update the {\@link yfiles.input.OrthogonalEdgeEditingContext#isInitializing} and {\@link yfiles.input.OrthogonalEdgeEditingContext#isInitialized} properties accordingly and will {\@link yfiles.input.OrthogonalEdgeEditingContext#prepareEdgePaths prepare} the edge paths. Finally, the {\@link yfiles.input.OrthogonalEdgeEditingContext#addInitializedListener Initialized}
 * event is raised so that registered handlers can perform their post-initialization process.
 * </p>
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.dragInitialized = function() {};

/**
 * Gets the {\@link yfiles.input.MovementInfo movement infos} that describe the orthogonal path of the edge.
 * @protected
 * @param {?} edge The edge to obtain the infos for.
 * @return {?<!yfiles.input.MovementInfo>} An array that contains for the first entry the source end of the edge, then all bends and then as the final entry the
 * target end of the edge. For the bends, this can be be <code>null</code> values if nothing is known about the bend, yet.
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.getMovementInfos = function(edge) {};

/**
 * Callback method that gets the {\@link yfiles.input.IOrthogonalEdgeHelper} instance associated with the given edge.
 * <p>
 * This implementation obtains the helper instance from the {\@link yfiles.graph.ILookup#lookup} of the edge.
 * </p>
 * @see yfiles.input.OrthogonalEdgeHelper
 * @protected
 * @param {?} edge The edge to obtain the helper instance for.
 * @return {?} The helper instance to use or <code>null</code>, in which case the default behavior will be used.
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.getOrthogonalEdgeHelper = function(edge) {};

/**
 * Gets the declared segment orientation for the provided segment at the given edge.
 * <p>
 * This implementation uses the {\@link yfiles.input.OrthogonalEdgeEditingContext#getOrthogonalEdgeHelper GetOrthogonalEdgeHelper()}.{\@link yfiles.input.IOrthogonalEdgeHelper#getSegmentOrientation GetSegmentOrientation} method to yield the orientation.
 * </p>
 * @param {?} edge The edge to determine the orientation of the segment.
 * @param {number} segmentIndex Index of the segment.
 * @return {yfiles.input.SegmentOrientation} The orientation of the segment.
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.getSegmentOrientation = function(edge, segmentIndex) {};

/**
 * Called by client code when a drag is started about to be started.
 * <p>
 * This code needs to be called before any of the {\@link yfiles.input.IDragHandler} implementations are initialized so that they
 * can then register the items they are going to modify with this instance. After this method has been called, the handlers
 * that perform the actual edit need to be initialized and as soon as this has been done, {\@link yfiles.input.OrthogonalEdgeEditingContext#dragInitialized}
 * should be called.
 * </p>
 * @throws {Stubs.Exceptions.InvalidOperationError} If this context is already {\@link yfiles.input.OrthogonalEdgeEditingContext#addInitializedListener Initialized}
 * or currently
 * {\@link yfiles.input.OrthogonalEdgeEditingContext#addInitializingListener Initializing}.
 * @see yfiles.input.OrthogonalEdgeEditingContext#dragInitialized
 * @param {?} context The context in which the edit is going to be performed.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.initializeDrag = function(context) {};

/**
 * Callback that can be used by
 * {\@link yfiles.input.IDragHandler}s and the like to determines whether the given edge is orthogonally edited edge in the
 * specified input mode context.
 * <p>
 * This implementation will always yield <code>false</code> if it is {\@link yfiles.input.OrthogonalEdgeEditingContext#enabled disabled}. Otherwise {\@link yfiles.input.OrthogonalEdgeEditingContext#getOrthogonalEdgeHelper}
 * will be used to delegate the query to {\@link yfiles.input.IOrthogonalEdgeHelper#shouldEditOrthogonally}.
 * </p>
 * @see yfiles.input.OrthogonalEdgeEditingContext#enabled
 * @see yfiles.input.IOrthogonalEdgeHelper#shouldEditOrthogonally
 * @param {?} context The input mode context which is editing the edge.
 * @param {?} edge The edge that will be edited.
 * @return {boolean} <code>true</code> if this edge should be orthogonally edited for the specified input mode context; <code>false</code> otherwise.
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.isOrthogonallyEditedEdge = function(context, edge) {};

/**
 * Locks the movement of the ports of the edges so that {\@link yfiles.input.OrthogonalEdgeEditingContext#shouldMoveEndImplicitly}
 * will yield <code>false</code> for the provided edge during the current edit.
 * <p>
 * This state will be reset after the current edit.
 * </p>
 * @see yfiles.input.OrthogonalEdgeEditingContext#lockedPortEdges
 * @param {?} edge The edge to lock the ports of.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.lockPortMovement = function(edge) {};

/**
 * Raises the {\@link yfiles.input.OrthogonalEdgeEditingContext#addCleanedUpListener CleanedUp}
 * event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.onCleanedUp = function(evt) {};

/**
 * Raises the {\@link yfiles.input.OrthogonalEdgeEditingContext#addInitializedListener Initialized}
 * event.
 * @see yfiles.input.OrthogonalEdgeEditingContext#addInitializedListener
 * @see yfiles.input.OrthogonalEdgeEditingContext#dragInitialized
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.onInitialized = function(evt) {};

/**
 * Raises the {\@link yfiles.input.OrthogonalEdgeEditingContext#addInitializingListener Initializing}
 * event.
 * @see yfiles.input.OrthogonalEdgeEditingContext#addInitializingListener
 * @see yfiles.input.OrthogonalEdgeEditingContext#initializeDrag
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.onInitializing = function(evt) {};

/**
 * Called during {\@link yfiles.input.OrthogonalEdgeEditingContext#dragInitialized} to prepare the edge paths for orthogonal
 * editing.
 * @see yfiles.input.OrthogonalEdgeEditingContext#prepareOrthogonalEdge
 * @protected
 * @param {?} graph The graph that contains the edges to be edited.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.prepareEdgePaths = function(graph) {};

/**
 * Helper method that inspects and prepares an orthogonal edge for the upcoming edit process.
 * <p>
 * This method inspects an edge and possibly inserts new bends into an edge to assure that during editing the orthogonality
 * won't be lost.
 * </p>
 * @protected
 * @param {?} graph The graph to use for modifying the bends.
 * @param {?} edge The edge to inspect.
 * @param {?<yfiles.input.SegmentOrientation>} orientations The orientations of the segments - the array is of length (edge.Bends.Count + 1).
 * @param {?<!yfiles.input.MovementInfo>} infos The {\@link } instances for the source end, the bends, and the target end. This array contains {\@link }
 * instances representing either edge ends or ports at the first and last position and {\@link }s or <code>null</code>
 * entries for the bends. The length thus is (edge.Bends.Count + 2) and <code>null</code> entries indicate that there is no information
 * about the movement (in case the bend will only be moved implicitly later, if at all).
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.prepareOrthogonalEdge = function(graph, edge, orientations, infos) {};

/**
 * Can be used by subclasses during {\@link yfiles.input.OrthogonalEdgeEditingContext#prepareOrthogonalEdge} to register added bends
 * that can later be {\@link yfiles.input.OrthogonalEdgeEditingContext#removeAddedBends removed} in case the operation is canceled.
 * <p>
 * This method will only record the addition of bends if this instance is {\@link yfiles.input.OrthogonalEdgeEditingContext#isInitialized initialized} or {\@link yfiles.input.OrthogonalEdgeEditingContext#addInitializingListener still initializing}.
 * </p>
 * @protected
 * @param {?} bend The bend that has been added to guarantee orthogonality.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.registerAddedBend = function(bend) {};

/**
 * Removes previously {\@link yfiles.input.OrthogonalEdgeEditingContext#registerAddedBend registered} added bends.
 * @see yfiles.input.OrthogonalEdgeEditingContext#addedBends
 * @see yfiles.input.OrthogonalEdgeEditingContext#registerAddedBend
 * @protected
 * @param {?} graph The graph to use for removing the bends.
 * @param {?<?>} addedBends The added bends.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.removeAddedBends = function(graph, addedBends) {};

/**
 * Callback that can be used by {\@link yfiles.input.IDragHandler}s and the like to determines whether the specified end of the
 * provided <code>edge</code> should be moved implicitly.
 * <p>
 * If an item is next to the end of an edge and the last segment should be kept orthogonal, this may only be possible if
 * the end of the edge is moved, too. This can be achieved by moving the edge to another {\@link yfiles.graph.IPort}, or by moving
 * the port instance itself. This depends on the implementation of the {\@link yfiles.input.IEdgePortHandleProvider} for the given
 * edge. This implementation will delegate to the {\@link yfiles.input.IOrthogonalEdgeHelper#shouldMoveEndImplicitly} method of the
 * {\@link yfiles.input.IOrthogonalEdgeHelper} instance returned by {\@link yfiles.input.OrthogonalEdgeEditingContext#getOrthogonalEdgeHelper}
 * unless the side of the edge is connected to an {\@link yfiles.graph.IPortOwner} instance that is marked as {\@link yfiles.input.OrthogonalEdgeEditingContext#addTransformedPortOwner transformed} during the
 * edit.
 * </p>
 * @see yfiles.input.OrthogonalEdgeEditingContext#getOrthogonalEdgeHelper
 * @see yfiles.input.IOrthogonalEdgeHelper#shouldMoveEndImplicitly
 * @see yfiles.input.OrthogonalEdgeEditingContext#movePorts
 * @param {?} edge The edge for which it should be determined whether the edge end can be moved.
 * @param {boolean} sourceSide if set to <code>true</code> the source side of the end is queried, else the target side.
 * @return {boolean} <code>true</code> if the specified side of the edge can be moved; <code>false</code> otherwise, in which case the segment should be split to
 * maintain orthogonality.
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.shouldMoveEndImplicitly = function(edge, sourceSide) {};

/**
 * Adds the given listener for the <code>CleanedUp</code> event that occurs when the recent edit operation has been cleaned up.
 * @see yfiles.input.OrthogonalEdgeEditingContext#cleanUp
 * @see yfiles.input.OrthogonalEdgeEditingContext#onCleanedUp
 * @see yfiles.input.OrthogonalEdgeEditingContext#removeCleanedUpListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.addCleanedUpListener = function(listener) {};

/**
 * Removes the given listener for the <code>CleanedUp</code> event that occurs when the recent edit operation has been cleaned up.
 * @see yfiles.input.OrthogonalEdgeEditingContext#cleanUp
 * @see yfiles.input.OrthogonalEdgeEditingContext#onCleanedUp
 * @see yfiles.input.OrthogonalEdgeEditingContext#addCleanedUpListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.removeCleanedUpListener = function(listener) {};

/**
 * Adds the given listener for the <code>Initializing</code> event that occurs when the edit is about to be initialized.
 * @see yfiles.input.OrthogonalEdgeEditingContext#initializeDrag
 * @see yfiles.input.OrthogonalEdgeEditingContext#onInitializing
 * @see yfiles.input.OrthogonalEdgeEditingContext#removeInitializingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.addInitializingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Initializing</code> event that occurs when the edit is about to be initialized.
 * @see yfiles.input.OrthogonalEdgeEditingContext#initializeDrag
 * @see yfiles.input.OrthogonalEdgeEditingContext#onInitializing
 * @see yfiles.input.OrthogonalEdgeEditingContext#addInitializingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.removeInitializingListener = function(listener) {};

/**
 * Adds the given listener for the <code>Initialized</code> event that occurs when the edit has been initialized.
 * @see yfiles.input.OrthogonalEdgeEditingContext#dragInitialized
 * @see yfiles.input.OrthogonalEdgeEditingContext#onInitialized
 * @see yfiles.input.OrthogonalEdgeEditingContext#removeInitializedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.addInitializedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Initialized</code> event that occurs when the edit has been initialized.
 * @see yfiles.input.OrthogonalEdgeEditingContext#dragInitialized
 * @see yfiles.input.OrthogonalEdgeEditingContext#onInitialized
 * @see yfiles.input.OrthogonalEdgeEditingContext#addInitializedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeEditingContext.prototype.removeInitializedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.OrthogonalEdgeHelper = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.input.OrthogonalEdgeHelper.$class;

/**
 * Returns whether the given bend can be removed.
 * <p>
 * This implementation always returns <code>true</code>.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {?} bend The bend that is designated for removal.
 * @return {boolean}
 */
yfiles.input.OrthogonalEdgeHelper.prototype.canRemoveBend = function(context, bend) {};

/**
 * Callback method that is invoked after the provided edge has been edited orthogonally.
 * <p>
 * The default implementation in this class removes duplicate and collinear bends, as well as segments of zero length.
 * </p>
 * @param {?} context The input mode context which edited the edge.
 * @param {?} graph The graph to use for modifying the edge instance.
 * @param {?} edge The edge to clean up the path.
 * @return {void}
 */
yfiles.input.OrthogonalEdgeHelper.prototype.cleanUpEdge = function(context, graph, edge) {};

/**
 * Gets the orientation of the given segment by looking at the geometry of the segment.
 * <p>
 * If the segment has a zero length, the adjacent segments will be inspected to infer the orientation such that the
 * orientation toggles between {\@link yfiles.input.SegmentOrientation#VERTICAL} and {\@link yfiles.input.SegmentOrientation#HORIZONTAL}.
 * </p>
 * @param {?} context The input mode context in which the orientation is needed.
 * @param {?} edge The edge to inspect.
 * @param {number} segmentIndex The index of the segment.
 * @return {yfiles.input.SegmentOrientation} The declared orientation of the segment.
 */
yfiles.input.OrthogonalEdgeHelper.prototype.getSegmentOrientation = function(context, edge, segmentIndex) {};

/**
 * Determines whether the provided edge should be edited orthogonally in the specified input mode context.
 * <p>
 * If this method returns <code>false</code>, the other methods will not be queried at all.
 * </p>
 * <p>
 * The default implementation in this class always returns <code>true</code>.
 * </p>
 * @param {?} context The input mode context in which the edge is about to be edited.
 * @param {?} edge The edge to inspect.
 * @return {boolean} <code>true</code> if the edge should be orthogonally edited in the specified input mode context; <code>false</code> otherwise.
 */
yfiles.input.OrthogonalEdgeHelper.prototype.shouldEditOrthogonally = function(context, edge) {};

/**
 * Determines whether this end of the provided edge can be moved in the input mode context.
 * <p>
 * This information is required to determine whether an edge's first or last segment needs to be split or the adjacent edge
 * end can be moved along with the other end of the segment.
 * </p>
 * <p>
 * The default implementation in this class always returns <code>false</code>.
 * </p>
 * @param {?} context The input mode context in which the segment is edited.
 * @param {?} edge The edge to inspect.
 * @param {boolean} sourceEnd if set to <code>true</code> the source end of the edge is queried, otherwise the target end.
 * @return {boolean} <code>true</code> if the end of the edge can be moved for the specified input mode context; <code>false</code> otherwise, in which case the
 * corresponding segment needs to be split to keep the segment orientation orthogonal.
 */
yfiles.input.OrthogonalEdgeHelper.prototype.shouldMoveEndImplicitly = function(context, edge, sourceEnd) {};
/**
 * @record
 * @struct
 */
yfiles.input.PortLocationModelParameterHandle = function() {};
 /** @type {?} */
yfiles.input.PortLocationModelParameterHandle.prototype.location;
 /** @type {?} */
yfiles.input.PortLocationModelParameterHandle.prototype.port;
 /** @type {yfiles.input.HandleTypes} */
yfiles.input.PortLocationModelParameterHandle.prototype.type;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.PortLocationModelParameterHandle.prototype.cursor;
 /** @type {!yfiles.lang.Class} */
yfiles.input.PortLocationModelParameterHandle.$class;

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @return {void}
 */
yfiles.input.PortLocationModelParameterHandle.prototype.cancelDrag = function(context, originalLocation) {};

/**
 * Called during the drag to collect snap results.
 * <p>
 * This implementation will delegate to the {\@link yfiles.input.IPortSnapResultProvider} that has been received from the port this
 * instance is bound to.
 * </p>
 * @protected
 * @param {!Object} source The source of the event.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.PortLocationModelParameterHandle.prototype.collectSnapResults = function(source, evt) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.PortLocationModelParameterHandle.prototype.dragFinished = function(context, originalLocation, newLocation) {};

/**
 * Gets the graph to use for {\@link yfiles.graph.IGraph#setPortLocationParameter setting the parameter} from the context.
 * @see yfiles.input.IInputModeContext#graph
 * @protected
 * @param {?} context The input mode context to use.
 * @return {?} The graph or <code>null</code> if the graph could not be obtained.
 */
yfiles.input.PortLocationModelParameterHandle.prototype.getGraph = function(context) {};

/**
 * Determines the type of the movement for the given port.
 * <p>
 * This is used for the {\@link yfiles.input.MovementInfo} that is passed to the {\@link yfiles.input.OrthogonalEdgeEditingContext#addMovedPort}
 * method.
 * </p>
 * @protected
 * @param {?} port The port to determine the move type for.
 * @return {yfiles.input.MoveTypes} This implementation returns {\@link #LINEAR_MOVE} for models of type {\@link }
 * and {\@link #ARBITRARY_MOVE} for all others.
 */
yfiles.input.PortLocationModelParameterHandle.prototype.getMoveType = function(port) {};

/**
 * Callback method that obtains the new parameter for the given location and port.
 * @protected
 * @param {?} port The port to obtain a parameter for.
 * @param {?} model The model to use.
 * @param {!yfiles.geometry.Point} location The new location.
 * @return {?} The new parameter to use.
 */
yfiles.input.PortLocationModelParameterHandle.prototype.getNewParameter = function(port, model, location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.PortLocationModelParameterHandle.prototype.handleMove = function(context, originalLocation, newLocation) {};

/**
 *
 * @param {?} context
 * @return {void}
 */
yfiles.input.PortLocationModelParameterHandle.prototype.initializeDrag = function(context) {};

/**
 * Callback method that applies the parameter.
 * @protected
 * @param {?} graph The graph to use for applying.
 * @param {?} port The port to apply the parameter to.
 * @param {?} locationParameter The new parameter to apply.
 * @return {void}
 */
yfiles.input.PortLocationModelParameterHandle.prototype.setParameter = function(graph, port, locationParameter) {};
/**
 * @record
 * @struct
 */
yfiles.input.ReparentNodeHandler = function() {};
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ReparentNodeHandler.prototype.reparentRecognizer;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ReparentNodeHandler.$class;

/**
 *
 * @param {?} context
 * @param {?} node
 * @return {boolean}
 */
yfiles.input.ReparentNodeHandler.prototype.isReparentGesture = function(context, node) {};

/**
 *
 * @param {?} context
 * @param {?} node
 * @param {?} newParent
 * @return {boolean}
 */
yfiles.input.ReparentNodeHandler.prototype.isValidParent = function(context, node, newParent) {};

/**
 *
 * @param {?} context
 * @param {?} node
 * @param {?} newParent
 * @return {void}
 */
yfiles.input.ReparentNodeHandler.prototype.reparent = function(context, node, newParent) {};

/**
 *
 * @param {?} context
 * @param {?} node
 * @return {boolean}
 */
yfiles.input.ReparentNodeHandler.prototype.shouldReparent = function(context, node) {};
/**
 * @record
 * @struct
 */
yfiles.input.NodeSnapLineProvider = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.input.NodeSnapLineProvider.$class;

/**
 * Callback method that is called by {\@link yfiles.input.NodeSnapLineProvider#addSnapLines} the collect snap lines for the centers
 * of the node.
 * <p>
 * This method is called by {\@link yfiles.input.NodeSnapLineProvider#addSnapLines} and by default used the {\@link yfiles.input.NodeSnapLineProvider#createCenterSnapLine}
 * to add them to the {\@link yfiles.input.CollectGraphSnapLinesEventArgs#addFixedNodeSnapLine fixed node} and {\@link yfiles.input.CollectGraphSnapLinesEventArgs#addFixedSegmentSnapLine fixed segment} collections
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} node The node to add snap lines for.
 * @param {!yfiles.geometry.Rect} layout The layout of the node to use for adding the snap lines.
 * @return {void}
 */
yfiles.input.NodeSnapLineProvider.prototype.addCenterSnapLines = function(context, evt, node, layout) {};

/**
 * Callback method that adds the fixed snap lines around the border of the nodes' <code>layout</code>.
 * <p>
 * This method is called by {\@link yfiles.input.NodeSnapLineProvider#addSnapLines}
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} node The node to add snap lines for.
 * @param {!yfiles.geometry.Rect} layout The layout of the node to use for adding the snap lines.
 * @return {void}
 */
yfiles.input.NodeSnapLineProvider.prototype.addFixedNodeBorderSnapLines = function(context, evt, node, layout) {};

/**
 * Callback method that adds the fixed snap lines around the node for other nodes to snap to using the {\@link yfiles.input.GraphSnapContext#nodeToNodeDistance}.
 * <p>
 * This method is called by {\@link yfiles.input.NodeSnapLineProvider#addSnapLines} and uses the {\@link yfiles.input.GraphSnapContext#nodeToNodeDistance} to determine the location of the
 * segments to add around the <code>layout</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} node The node to add snap lines for.
 * @param {!yfiles.geometry.Rect} layout The layout of the node to use for adding the snap lines.
 * @return {void}
 */
yfiles.input.NodeSnapLineProvider.prototype.addNodeToNodeSnapLines = function(context, evt, node, layout) {};

/**
 * Callback method that adds the fixed snap lines around the node for edge segments to snap to.
 * <p>
 * This method is called by {\@link yfiles.input.NodeSnapLineProvider#addSnapLines} and uses the {\@link yfiles.input.GraphSnapContext#nodeToEdgeDistance} to determine the location of the
 * segments to add around the <code>layout</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} node The node to add snap lines for.
 * @param {!yfiles.geometry.Rect} layout The layout of the node to use for adding the snap lines.
 * @return {void}
 */
yfiles.input.NodeSnapLineProvider.prototype.addNodeToSegmentSnapLines = function(context, evt, node, layout) {};

/**
 * Callback method that is called by {\@link yfiles.input.NodeSnapLineProvider#addSnapLines} the collect snap lines to snap ports to
 * at the provided node.
 * <p>
 * This method is called by {\@link yfiles.input.NodeSnapLineProvider#addSnapLines}
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} node The node to add snap lines for.
 * @param {!yfiles.geometry.Rect} layout The layout of the node to use for adding the snap lines.
 * @return {void}
 */
yfiles.input.NodeSnapLineProvider.prototype.addPortSnapLines = function(context, evt, node, layout) {};

/**
 * Called by the {\@link yfiles.input.GraphSnapContext} when a {\@link yfiles.input.GraphSnapContext#initializeDrag drag} is about to start.
 * <p>
 * This means that the provided <code>item</code>, which can be cast to {\@link yfiles.graph.INode} will not be moved during the edit and thus
 * can contribute to the set of fixed snap lines. This implementation delegates to
 * {\@link yfiles.input.NodeSnapLineProvider#addFixedNodeBorderSnapLines}, {\@link yfiles.input.NodeSnapLineProvider#addPortSnapLines},
 * {\@link yfiles.input.NodeSnapLineProvider#addNodeToNodeSnapLines}, and {\@link yfiles.input.NodeSnapLineProvider#addCenterSnapLines}.
 * </p>
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} item The item to add snap lines for.
 * @return {void}
 */
yfiles.input.NodeSnapLineProvider.prototype.addSnapLines = function(context, evt, item) {};

/**
 * Convenience method that creates a snap line for the center of nodes.
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {?} node The node to add snap lines for.
 * @param {yfiles.input.SnapLineOrientation} orientation The snap line orientation.
 * @param {!yfiles.geometry.Point} location The location of the snap line.
 * @return {!yfiles.input.OrthogonalSnapLine} A snap line that other centers can snap to.
 */
yfiles.input.NodeSnapLineProvider.prototype.createCenterSnapLine = function(context, node, orientation, location) {};
/**
 * @record
 * @struct
 */
yfiles.input.EdgeSnapLineProvider = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.input.EdgeSnapLineProvider.$class;

/**
 * Adds horizontal snap lines for a horizontally oriented fixed segment snap lines.
 * @see yfiles.input.EdgeSnapLineProvider#addVerticalSegmentSnapLines
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} edge The edge to add snap lines for.
 * @param {!yfiles.geometry.Point} segmentStart The start of the segment.
 * @param {!yfiles.geometry.Point} segmentEnd The end of the segment.
 * @return {void}
 */
yfiles.input.EdgeSnapLineProvider.prototype.addHorizontalSegmentSnapLines = function(context, evt, edge, segmentStart, segmentEnd) {};

/**
 * Adds the snap lines for the given model item to the <code>args</code>.
 * <p>
 * This implementation queries the {\@link yfiles.input.GraphSnapContext#getMovementInfos movement information} for the provided edge to determine which edge segments stay fixed.
 * For each fixed segment, it will call {\@link yfiles.input.EdgeSnapLineProvider#addVerticalSegmentSnapLines} or {\@link yfiles.input.EdgeSnapLineProvider#addHorizontalSegmentSnapLines}
 * respectively.
 * </p>
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} item The item to add snap lines for.
 * @return {void}
 */
yfiles.input.EdgeSnapLineProvider.prototype.addSnapLines = function(context, evt, item) {};

/**
 * Adds vertical snap lines for a vertically oriented fixed segment snap lines.
 * @see yfiles.input.EdgeSnapLineProvider#addHorizontalSegmentSnapLines
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context which holds the settings for the snap lines. Note that implementations should not change the state of the
 * context explicitly.
 * @param {!yfiles.input.CollectGraphSnapLinesEventArgs} evt The argument to use for adding snap lines.
 * @param {?} edge The edge to add snap lines for.
 * @param {!yfiles.geometry.Point} segmentStart The start of the segment.
 * @param {!yfiles.geometry.Point} segmentEnd The end of the segment.
 * @return {void}
 */
yfiles.input.EdgeSnapLineProvider.prototype.addVerticalSegmentSnapLines = function(context, evt, edge, segmentStart, segmentEnd) {};
/**
 * @record
 * @struct
 */
yfiles.input.NodeSnapResultProvider = function() {};
 /** @type {?} */
yfiles.input.NodeSnapResultProvider.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.input.NodeSnapResultProvider.$class;

/**
 * Calculates a {\@link yfiles.input.SnapResult} and {\@link yfiles.input.CollectSnapResultsEventArgs#addSnapResult adds it} to the argument.
 * <p>
 * This method delegates to {\@link yfiles.input.NodeSnapResultProvider#addGridSnapResultCore} using {\@link yfiles.input.GraphSnapContext#gridSnapType} and {\@link yfiles.input.SnapPolicy#TO_NEAREST}
 * as the additional arguments. This method snaps the <code>location</code> to the next grid point or grid lines that are determined by
 * {\@link yfiles.input.GraphSnapContext#nodeGridConstraintProvider} or obtained from the {\@link yfiles.input.InputModeEventArgs#context}.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The arguments to add the results to.
 * @param {!yfiles.geometry.Point} location A location in the layout of the suggested layout of the node that will be snapped to a grid point location.
 * @param {?} node The node that is currently being processed.
 * @return {void}
 */
yfiles.input.NodeSnapResultProvider.prototype.addGridSnapResult = function(context, evt, location, node) {};

/**
 * Calculates a {\@link yfiles.input.SnapResult} and {\@link yfiles.input.CollectSnapResultsEventArgs#addSnapResult adds it} to the argument.
 * <p>
 * This method snaps the <code>location</code> to the next grid point or grid lines that are determined by {\@link yfiles.input.GraphSnapContext#nodeGridConstraintProvider} or obtained from the {\@link yfiles.input.InputModeEventArgs#context}.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The arguments to add the results to.
 * @param {!yfiles.geometry.Point} location A location in the layout of the suggested layout of the node that will be snapped to a grid point location.
 * @param {?} node The node that is currently being processed.
 * @param {yfiles.input.GridSnapTypes} gridSnapType The type of snapping that should be performed.
 * @param {yfiles.input.SnapPolicy} xSnapPolicy How to snap the x coordinate.
 * @param {yfiles.input.SnapPolicy} ySnapPolicy How to snap the y coordinate.
 * @return {void}
 */
yfiles.input.NodeSnapResultProvider.prototype.addGridSnapResultCore = function(context, evt, location, node, gridSnapType, xSnapPolicy, ySnapPolicy) {};

/**
 * Collects snap results that snap the node to a grid and {\@link yfiles.input.CollectSnapResultsEventArgs#addSnapResult adds them} to the argument.
 * <p>
 * This implementation simply delegates to {\@link yfiles.input.NodeSnapResultProvider#addGridSnapResult} using the center of the
 * <code>suggestedLayout</code>.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The arguments to add the results to.
 * @param {!yfiles.geometry.Rect} suggestedLayout The layout of the node if it would move without snapping.
 * @param {?} node The node that is currently being processed.
 * @return {void}
 */
yfiles.input.NodeSnapResultProvider.prototype.collectGridSnapResults = function(context, evt, suggestedLayout, node) {};

/**
 * Collects the results for the given layout for all snap lines in question.
 * <p>
 * For each snap line that could be snapped to, this method calls
 * {\@link yfiles.input.NodeSnapResultProvider#collectSnapResultsForSnapLine}.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context for which the results are being queried.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance to which the results should be {\@link #addSnapResult added}.
 * @param {!yfiles.geometry.Rect} suggestedLayout The suggested layout of the node.
 * @param {?} node The node that is being dragged.
 * @return {void}
 */
yfiles.input.NodeSnapResultProvider.prototype.collectSnapLineSnapResults = function(context, evt, suggestedLayout, node) {};

/**
 *
 * @param {!yfiles.input.GraphSnapContext} context
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt
 * @param {!yfiles.geometry.Rect} suggestedLayout
 * @param {?} node
 * @return {void}
 */
yfiles.input.NodeSnapResultProvider.prototype.collectSnapResults = function(context, evt, suggestedLayout, node) {};

/**
 * Verifies whether the node will snap to the given snap line.
 * <p>
 * If the node will snap, a {\@link yfiles.input.SnapResult} for a {\@link yfiles.input.SnapLine} will be created and added to the event
 * argument.
 * </p>
 * @protected
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The arguments to add the results to.
 * @param {!yfiles.input.OrthogonalSnapLine} snapLine The snap line to test snapping for.
 * @param {!yfiles.geometry.Rect} suggestedLayout The layout of the node if it would move without snapping.
 * @param {?} node The node that is currently being processed.
 * @return {void}
 */
yfiles.input.NodeSnapResultProvider.prototype.collectSnapResultsForSnapLine = function(evt, snapLine, suggestedLayout, node) {};
/**
 * @record
 * @struct
 */
yfiles.input.NodeReshapeSnapResultProvider = function() {};
 /** @type {?} */
yfiles.input.NodeReshapeSnapResultProvider.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.input.NodeReshapeSnapResultProvider.$class;

/**
 * Adds a snap result for a location that snaps to a grid line.
 * <p>
 * This method is called by {\@link yfiles.input.NodeReshapeSnapResultProvider#collectGridSnapResults} for each grid line snap.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance containing the event data.
 * @param {?} node The node that is being reshaped.
 * @param {yfiles.input.SnapLineSnapTypes} snapLineType The type of snap line.
 * @param {?} snapLineLocation The point at which the snap line is anchored.
 * @param {number} delta The amount the mouse needs to be moved in order to get to the snapping location.
 * @param {!yfiles.geometry.Point} snappedLocation The location of the mouse that is associated with the grid point.
 * @param {number} from Where the snap line starts.
 * @param {number} to Where the snap line ends.
 * @param {!yfiles.geometry.Point} snapLinePoint A point of interest on the snap line that can be highlighted.
 * @return {void}
 */
yfiles.input.NodeReshapeSnapResultProvider.prototype.addGridLineSnapResult = function(context, evt, node, snapLineType, snapLineLocation, delta, snappedLocation, from, to, snapLinePoint) {};

/**
 * Adds a snap result for a location that snaps to the grid.
 * <p>
 * This method is called by {\@link yfiles.input.NodeReshapeSnapResultProvider#collectGridSnapResults} for each grid snap.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance containing the event data.
 * @param {?} node The node that is being reshaped.
 * @param {?<?>} provider The provider that is associated with the grid snapping.
 * @param {!yfiles.geometry.Point} gridSnappedPoint The point on the grid that should be highlighted.
 * @param {!yfiles.geometry.Point} snappedLocation The location of the mouse that is associated with the grid point.
 * @return {void}
 */
yfiles.input.NodeReshapeSnapResultProvider.prototype.addGridSnapResult = function(context, evt, node, provider, gridSnappedPoint, snappedLocation) {};

/**
 * Adds a snap result for "same size" to the collect event argument.
 * <p>
 * This method is called by {\@link yfiles.input.NodeReshapeSnapResultProvider#collectSameSizeSnapResults} for each result found.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance containing the event data. This will be used to {\@link #addSnapResult add} the result
 * to.
 * @param {?} node The node that is being reshaped.
 * @param {yfiles.input.SnapLineOrientation} orientation The orientation of the result - indicates whether width or height have been snapped.
 * @param {?<!yfiles.geometry.Rect>} rectangles The rectangles that have the same width or height as the node will - this does not yet includes the rectangle of the
 * node being reshaped.
 * @param {number} finalSize The target size to which the node will snap.
 * @param {number} snapDelta The snap delta that the mouse needs to be moved in order to snap.
 * @return {void}
 */
yfiles.input.NodeReshapeSnapResultProvider.prototype.addSameSizeSnapResult = function(context, evt, node, orientation, rectangles, finalSize, snapDelta) {};

/**
 * Adds a snap result for a location that snaps the node's bounds to a snap line.
 * <p>
 * This method is called by {\@link yfiles.input.NodeReshapeSnapResultProvider#collectSnapLineResults} for each snap line snap.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance containing the event data.
 * @param {?} node The node that is being reshaped.
 * @param {!yfiles.input.OrthogonalSnapLine} snapLine The snap line to which the node can be snapped
 * @param {number} delta The amount the mouse needs to be moved in order to get to the snapping location.
 * @param {!yfiles.geometry.Point} snapPoint The point of interest that can be highlighted on the snap line.
 * @return {void}
 */
yfiles.input.NodeReshapeSnapResultProvider.prototype.addSnaplineSnapResult = function(context, evt, node, snapLine, delta, snapPoint) {};

/**
 * Collects the snap results for the grid.
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance containing the event data.
 * @param {?} node The node that is being reshaped.
 * @param {!yfiles.input.ReshapeRectangleContext} reshapeContext The reshape context that describes how the node's layout is reshaped.
 * @param {!yfiles.geometry.Rect} suggestedLayout The suggested layout of the node.
 * @return {void}
 */
yfiles.input.NodeReshapeSnapResultProvider.prototype.collectGridSnapResults = function(context, evt, node, reshapeContext, suggestedLayout) {};

/**
 * Collects the snap results that make the node the same size as other elements.
 * <p>
 * This method ultimately delegates to {\@link yfiles.input.NodeReshapeSnapResultProvider#addSameSizeSnapResult} to add the results
 * to the event argument.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance containing the event data.
 * @param {?} node The node that is being reshaped.
 * @param {!yfiles.input.ReshapeRectangleContext} reshapeContext The reshape context that contains information about the nature of the resize.
 * @param {!yfiles.geometry.Rect} suggestedLayout The layout of the node as it would be if the mouse location would not be snapped.
 * @return {void}
 */
yfiles.input.NodeReshapeSnapResultProvider.prototype.collectSameSizeSnapResults = function(context, evt, node, reshapeContext, suggestedLayout) {};

/**
 * Collects the snap results that makes the node's bounds snap to the {\@link yfiles.input.GraphSnapContext#getFixedNodeSnapLines fixed node snap lines}.
 * <p>
 * This method ultimately delegates to {\@link yfiles.input.NodeReshapeSnapResultProvider#addSnaplineSnapResult} to add the results
 * to the event argument. Method {\@link yfiles.input.NodeReshapeSnapResultProvider#getSnapLines} is used to query the snap lines
 * that will be checked by this method.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The {\@link } instance containing the event data.
 * @param {?} node The node that is being reshaped.
 * @param {!yfiles.input.ReshapeRectangleContext} reshapeContext The reshape context that contains information about the nature of the resize.
 * @param {!yfiles.geometry.Rect} suggestedLayout The layout of the node as it would be if the mouse location would not be snapped.
 * @return {void}
 */
yfiles.input.NodeReshapeSnapResultProvider.prototype.collectSnapLineResults = function(context, evt, node, reshapeContext, suggestedLayout) {};

/**
 * Called when a node is {\@link yfiles.input.IDragHandler#handleMove dragged} to add {\@link yfiles.input.SnapResult}s for
 * {\@link yfiles.input.OrthogonalSnapLine}s or sizes to which this node can potentially snap during resizing.
 * <p>
 * This implementation delegates to the following methods in order:
 * </p>
 * <ul>
 * <li>{\@link yfiles.input.NodeReshapeSnapResultProvider#collectGridSnapResults}</li>
 * <li>{\@link yfiles.input.NodeReshapeSnapResultProvider#collectSameSizeSnapResults}</li>
 * <li>{\@link yfiles.input.NodeReshapeSnapResultProvider#collectSnapLineResults}</li>
 * </ul>
 * @param {!yfiles.input.GraphSnapContext} context The snap context which manages the snap lines and the settings.
 * @param {!yfiles.input.CollectSnapResultsEventArgs} evt The event argument to obtain the context from and add the results to.
 * @param {?} node The node that is being reshaped.
 * @param {!yfiles.input.ReshapeRectangleContext} reshapeContext Carries information about the reshape process.
 * @return {void}
 */
yfiles.input.NodeReshapeSnapResultProvider.prototype.collectSnapResults = function(context, evt, node, reshapeContext) {};

/**
 * Helper method for method {\@link yfiles.input.NodeReshapeSnapResultProvider#collectSnapLineResults} that gets all the {\@link yfiles.input.SnapLine}
 * that should be checked for the currently moved node.
 * <p>
 * This method aggregates the {\@link yfiles.input.GraphSnapContext#getFixedNodeSnapLines fixed nodes' snaplines} and the {\@link yfiles.input.GraphSnapContext#getAdditionalSnapLines additional snap lines} that are relevant to the node.
 * </p>
 * @protected
 * @param {!yfiles.input.GraphSnapContext} context The context in which the snapping is performed.
 * @param {?} node The node that is being reshaped.
 * @param {!yfiles.input.ReshapeRectangleContext} reshapeContext The reshape context that contains information about the nature of the resize.
 * @param {!yfiles.geometry.Rect} suggestedLayout The layout of the node as it would be if the mouse location would not be snapped.
 * @return {?<!yfiles.input.SnapLine>}
 */
yfiles.input.NodeReshapeSnapResultProvider.prototype.getSnapLines = function(context, node, reshapeContext, suggestedLayout) {};
/**
 * @record
 * @struct
 */
yfiles.input.DefaultBendCreator = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.input.DefaultBendCreator.$class;

/**
 *
 * @param {?} context
 * @param {?} graph
 * @param {?} edge
 * @param {!yfiles.geometry.Point} location
 * @return {number}
 */
yfiles.input.DefaultBendCreator.prototype.createBend = function(context, graph, edge, location) {};
/**
 * @record
 * @struct
 */
yfiles.input.PortCandidateProviderBase = function() {};
 /** @type {?} */
yfiles.input.PortCandidateProviderBase.prototype.style;
 /** @type {!Object} */
yfiles.input.PortCandidateProviderBase.prototype.tag;
 /** @type {!yfiles.lang.Class} */
yfiles.input.PortCandidateProviderBase.$class;

/**
 * Convenience method for subclasses that adds all existing {\@link yfiles.graph.IPortOwner#ports} of the <code>owner</code> to the provided list.
 * @protected
 * @param {?} owner The port owner whose ports should be added.
 * @param {?<?>} list The list to add candidates for existing ports to.
 * @return {void}
 */
yfiles.input.PortCandidateProviderBase.prototype.addExistingPorts = function(owner, list) {};

/**
 * Factory method that creates a simple candidate that will use the {\@link yfiles.input.PortCandidateProviderBase#createInstance}
 * method of this instance to delegate {\@link yfiles.input.IPortCandidate#createPort} queries to.
 * @protected
 * @param {?} owner The owner to use for the candidate.
 * @param {?} locationParameter The location of the candidate. This instance is assigned by reference to the candidate.
 * @param {boolean=} valid
 * @return {!yfiles.input.DefaultPortCandidate} A candidate whose {\@link #createPort} method delegates to this instance's
 * {\@link #createInstance}.
 */
yfiles.input.PortCandidateProviderBase.prototype.createCandidate = function(owner, locationParameter, valid) {};

/**
 * Callback method used by the ports created using the factory methods
 * {\@link yfiles.input.PortCandidateProviderBase#createCandidate}.
 * <p>
 * This method can be overridden by subclasses to perform more sophisticated port creation logic.
 * </p>
 * @protected
 * @param {?} context The context in which the instance is created.
 * @param {!yfiles.input.DefaultPortCandidate} candidate The candidate to create a port for.
 * @return {?} The new port.
 */
yfiles.input.PortCandidateProviderBase.prototype.createInstance = function(context, candidate) {};

/**
 * Callback method used by the ports created using the factory methods
 * {\@link yfiles.input.PortCandidateProviderBase#createCandidate}.
 * <p>
 * This method can be overridden by subclasses to perform more sophisticated candidate creation logic.
 * </p>
 * @protected
 * @param {?} context The context in which the instance is created.
 * @param {!yfiles.input.DefaultPortCandidate} candidate The candidate to create a port for.
 * @param {!yfiles.geometry.Point} suggestedLocation The location to get a candidate for.
 * @return {?} The new candidate whose {\@link #validity} may not be {\@link #DYNAMIC}.
 */
yfiles.input.PortCandidateProviderBase.prototype.getPortCandidateAt = function(context, candidate, suggestedLocation) {};

/**
 * Creates an enumeration of possibly port candidates.
 * <p>
 * This method is used as a callback by most of the getter methods in this class. Subclasses should override this method to
 * provide the same candidates for all use-cases.
 * </p>
 * @protected
 * @abstract
 * @param {?} context The context for which the candidates should be provided.
 * @return {?<?>} An enumerable collection of port candidates.
 */
yfiles.input.PortCandidateProviderBase.prototype.getPortCandidates = function(context) {};

/**
 * Convenience implementation that simply delegates to {\@link yfiles.input.PortCandidateProviderBase#getPortCandidates}.
 * Convenience implementation that simply delegates to {\@link yfiles.input.PortCandidateProviderBase#getPortCandidates}.
 * @param {?} context
 * @param {?=} target
 * @return {?<?>}
 */
yfiles.input.PortCandidateProviderBase.prototype.getSourcePortCandidates = function(context, target) {};

/**
 * Convenience implementation that simply delegates to {\@link yfiles.input.PortCandidateProviderBase#getPortCandidates}.
 * Convenience implementation that simply delegates to {\@link yfiles.input.PortCandidateProviderBase#getPortCandidates}.
 * @param {?} context
 * @param {?=} source
 * @return {?<?>}
 */
yfiles.input.PortCandidateProviderBase.prototype.getTargetPortCandidates = function(context, source) {};
/**
 * @record
 * @struct
 */
yfiles.input.PortRelocationHandle = function() {};
 /** @type {boolean} */
yfiles.input.PortRelocationHandle.prototype.showHitPortOwnerCandidatesOnly;
 /** @type {number} */
yfiles.input.PortRelocationHandle.prototype.maximumSnapDistance;
 /** @type {boolean} */
yfiles.input.PortRelocationHandle.prototype.allowEdgeToEdgeConnections;
 /** @type {boolean} */
yfiles.input.PortRelocationHandle.prototype.allowCyclicPortDependencies;
 /** @type {boolean} */
yfiles.input.PortRelocationHandle.prototype.addExistingPort;
 /** @type {yfiles.input.HandleTypes} */
yfiles.input.PortRelocationHandle.prototype.type;
 /** @type {!yfiles.view.Cursor} */
yfiles.input.PortRelocationHandle.prototype.cursor;
 /** @type {boolean} */
yfiles.input.PortRelocationHandle.prototype.resolvePortCandidates;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.PortRelocationHandle.prototype.portCandidateResolutionRecognizer;
 /** @type {boolean} */
yfiles.input.PortRelocationHandle.prototype.sourceEnd;
 /** @type {?} */
yfiles.input.PortRelocationHandle.prototype.edge;
 /** @type {!yfiles.graph.SimpleEdge} */
yfiles.input.PortRelocationHandle.prototype.dummyEdge;
 /** @type {boolean} */
yfiles.input.PortRelocationHandle.prototype.showDummyEdge;
 /** @type {?} */
yfiles.input.PortRelocationHandle.prototype.inputModeContext;
 /** @type {?} */
yfiles.input.PortRelocationHandle.prototype.location;
 /** @type {!yfiles.lang.Class} */
yfiles.input.PortRelocationHandle.$class;

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.cancelDrag = function(context, originalLocation) {};

/**
 * Factory method that creates the {\@link yfiles.view.ICanvasObjectDescriptor} that will be used to paint the "current"
 * {\@link yfiles.input.IPortCandidate}.
 * @protected
 * @return {?} The descriptor to use for the rendering in the {\@link }.
 */
yfiles.input.PortRelocationHandle.prototype.createCurrentPortCandidateDescriptor = function() {};

/**
 * Factory method that creates the dummy edge that will be shown during the drag operation.
 * @see yfiles.input.PortRelocationHandle#showDummyEdge
 * @protected
 * @param {?} edge The edge to be represented by the dummy edge.
 * @return {!yfiles.graph.SimpleEdge} The dummy edge instance to use.
 */
yfiles.input.PortRelocationHandle.prototype.createDummyEdge = function(edge) {};

/**
 * Factory method that creates a dummy paintable for the dummy edge during the drag operation.
 * @see yfiles.input.PortRelocationHandle#showDummyEdge
 * @protected
 * @param {!yfiles.graph.SimpleEdge} dummy The dummy to create a paintable for.
 * @return {?} A paintable that shows the dummy.
 */
yfiles.input.PortRelocationHandle.prototype.createDummyEdgeVisualCreator = function(dummy) {};

/**
 * Factory method that creates the candidate for the existing port.
 * @see yfiles.input.PortRelocationHandle#getPortCandidates
 * @see yfiles.input.PortRelocationHandle#addExistingPort
 * @protected
 * @param {?} port The port to create a candidate for.
 * @return {?} The candidate or <code>null</code>.
 */
yfiles.input.PortRelocationHandle.prototype.createExistingPortCandidate = function(port) {};

/**
 * Factory method that creates the {\@link yfiles.view.ICanvasObjectDescriptor} that will be used to paint the
 * {\@link yfiles.input.IPortCandidate}s.
 * @protected
 * @return {?} The descriptor to use for the rendering in the {\@link }.
 */
yfiles.input.PortRelocationHandle.prototype.createPortCandidateDescriptor = function() {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.dragFinished = function(context, originalLocation, newLocation) {};

/**
 * Finds the closest candidate from the given set of candidates.
 * @protected
 * @param {?} context The context in for which the closest handle candidate is sought.
 * @param {!yfiles.geometry.Point} location The location for which to find a candidate.
 * @param {?<?>} candidates The list of possible candidates.
 * @return {?} The closes candidate or <code>null</code>.
 */
yfiles.input.PortRelocationHandle.prototype.getClosestCandidate = function(context, location, candidates) {};

/**
 * Gets the graph to use from the context.
 * @protected
 * @param {?} context The input mode context.
 * @return {?} A graph instance or <code>null</code>.
 */
yfiles.input.PortRelocationHandle.prototype.getGraph = function(context) {};

/**
 * Callback used during {\@link yfiles.input.PortRelocationHandle#dragFinished} to actually get the new port from the chosen
 * candidate.
 * <p>
 * This implementation returns the result of {\@link yfiles.input.IPortCandidate#createPort} or calls {\@link yfiles.graph.IGraph#addPort} if
 * the result was <code>null</code>.
 * </p>
 * @see yfiles.input.PortRelocationHandle#setPorts
 * @protected
 * @param {?} context
 * @param {?} portCandidate The candidate to get a port instance from.
 * @param {!yfiles.geometry.Point} suggestedLocation The suggested location for the port.
 * @return {?} A non-<code>null</code> port instance.
 */
yfiles.input.PortRelocationHandle.prototype.getPort = function(context, portCandidate, suggestedLocation) {};

/**
 * Gets the possible candidates for the given edge.
 * <p>
 * This implementation uses the {\@link yfiles.input.IEdgeReconnectionPortCandidateProvider} from the edge's {\@link yfiles.graph.ILookup#lookup}
 * to retrieve the candidate sets. If {\@link yfiles.input.PortRelocationHandle#addExistingPort} is enabled, the existing port will be part of the candidates.
 * </p>
 * @protected
 * @param {?} context The context that is used to retrieve the candidates for.
 * @param {?} edge The edge.
 * @param {boolean} sourcePort Whether to look for source port candidates.
 * @return {?<?>} A non-<code>null</code> enumerable over the candidates.
 */
yfiles.input.PortRelocationHandle.prototype.getPortCandidates = function(context, edge, sourcePort) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.handleMove = function(context, originalLocation, newLocation) {};

/**
 * Hides the original edge that during the drag operation.
 * @see yfiles.input.PortRelocationHandle#unhideOriginalEdge
 * @see yfiles.input.PortRelocationHandle#showDummyEdge
 * @protected
 * @param {?} context The context to get the canvas the edge should be hidden from.
 * @param {?} edge The edge to hide.
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.hideOriginalEdge = function(context, edge) {};

/**
 *
 * @param {?} context
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.initializeDrag = function(context) {};

/**
 * Determines whether {\@link yfiles.input.PortRelocationHandle#resolveCandidate port candidate resolution} is enabled for the current gesture.
 * <p>
 * This implementation checks whether the the parent input mode is an instance of {\@link yfiles.input.HandleInputMode}, the {\@link yfiles.input.PortRelocationHandle#portCandidateResolutionRecognizer}
 * recognizes its {\@link yfiles.view.MouseEventArgs}, and the {\@link yfiles.input.HandleInputMode#currentHandle}'s location is equal to this {\@link yfiles.input.PortRelocationHandle#location}.
 * </p>
 * @protected
 * @param {?} context The context to inspect.
 * @return {boolean} <code>true</code> if port candidates may be resolved; <code>false</code> otherwise.
 */
yfiles.input.PortRelocationHandle.prototype.isPortCandidateResolutionEnabled = function(context) {};

/**
 * Tries to {\@link yfiles.input.IPortCandidate#getPortCandidateAt resolve} a dynamic port candidate for the given location.
 * @protected
 * @param {?} context The context in which the candidate is resolved.
 * @param {?} portCandidate The candidate.
 * @param {!yfiles.geometry.Point} location The current location.
 * @return {?} A candidate.
 */
yfiles.input.PortRelocationHandle.prototype.resolveCandidate = function(context, portCandidate, location) {};

/**
 * Updates the closest candidate for visual feedback.
 * @protected
 * @param {?} portCandidate
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.setClosestCandidate = function(portCandidate) {};

/**
 * Callback that is triggered by {\@link yfiles.input.PortRelocationHandle#dragFinished} to actually change the port.
 * @protected
 * @param {?} context The context.
 * @param {?} edge The edge to change ports.
 * @param {boolean} setSourcePort Whether to set the source port. <code>false</code> for target ports.
 * @param {?} portCandidate The candidate that has been chosen.
 * @param {!yfiles.geometry.Point} suggestedLocation The suggested location for the port.
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.setPort = function(context, edge, setSourcePort, portCandidate, suggestedLocation) {};

/**
 * Finally sets the ports for the edge to the new values.
 * @protected
 * @param {?} context The context in which the ports are set.
 * @param {?} edge The edge to set the ports for.
 * @param {?} sourcePort The (possibly) new source port.
 * @param {?} targetPort The (possibly) new target port.
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.setPorts = function(context, edge, sourcePort, targetPort) {};

/**
 * Updates the position of the handle.
 * @protected
 * @param {!yfiles.geometry.Point} location The new location of the handle.
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.setPosition = function(location) {};

/**
 * Updates the dummy edge's visual appearance to reflect the new port candidate.
 * @protected
 * @param {!yfiles.graph.SimpleEdge} dummy The dummy edge.
 * @param {boolean} source Whether to update the source or target port.
 * @param {?} portCandidate The new candidate to indicate.
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.setToPortCandidate = function(dummy, source, portCandidate) {};

/**
 * Unhides the original edge that was hidden during the drag operation.
 * @see yfiles.input.PortRelocationHandle#hideOriginalEdge
 * @see yfiles.input.PortRelocationHandle#showDummyEdge
 * @protected
 * @param {?} edge The edge to unhide.
 * @param {!yfiles.view.CanvasComponent} canvas The canvas the edge was hidden from.
 * @return {void}
 */
yfiles.input.PortRelocationHandle.prototype.unhideOriginalEdge = function(edge, canvas) {};
/**
 * @record
 * @struct
 */
yfiles.input.PortRelocationHandleProvider = function() {};
 /** @type {?} */
yfiles.input.PortRelocationHandleProvider.prototype.graph;
 /** @type {?} */
yfiles.input.PortRelocationHandleProvider.prototype.edge;
 /** @type {!yfiles.lang.Class} */
yfiles.input.PortRelocationHandleProvider.$class;

/**
 * Factory method that creates the handle for this provider.
 * @protected
 * @param {?} graph The graph that contains the edge.
 * @param {?} edge The edge.
 * @param {boolean} sourcePort if set to <code>true</code> the handle for the source port is sought.
 * @return {?} A handle or <code>null</code>.
 */
yfiles.input.PortRelocationHandleProvider.prototype.createPortRelocationHandle = function(graph, edge, sourcePort) {};

/**
 *
 * @param {?} context
 * @return {?<?>}
 */
yfiles.input.PortRelocationHandleProvider.prototype.getHandles = function(context) {};
/**
 * @record
 * @struct
 */
yfiles.input.PortsHandleProvider = function() {};
 /** @type {?} */
yfiles.input.PortsHandleProvider.prototype.portOwner;
 /** @type {!yfiles.lang.Class} */
yfiles.input.PortsHandleProvider.$class;

/**
 * Retrieves the handle implementation from the port's lookup.
 * @protected
 * @param {?} port
 * @return {?}
 */
yfiles.input.PortsHandleProvider.prototype.getHandle = function(port) {};

/**
 * Returns a collection of zero or more {\@link yfiles.input.IHandle} implementations that are associated with the ports of this
 * context.
 * @param {?} context
 * @return {?<?>} A collection of handles.
 */
yfiles.input.PortsHandleProvider.prototype.getHandles = function(context) {};
/**
 * @record
 * @struct
 */
yfiles.input.ResizeStripeInputMode = function() {};
 /** @type {number} */
yfiles.input.ResizeStripeInputMode.prototype.priority;
 /** @type {boolean} */
yfiles.input.ResizeStripeInputMode.prototype.exclusive;
 /** @type {boolean} */
yfiles.input.ResizeStripeInputMode.prototype.enabled;
 /** @type {?} */
yfiles.input.ResizeStripeInputMode.prototype.inputModeContext;
 /** @type {!yfiles.input.ConcurrencyController} */
yfiles.input.ResizeStripeInputMode.prototype.controller;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ResizeStripeInputMode.prototype.pressedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ResizeStripeInputMode.prototype.draggedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ResizeStripeInputMode.prototype.releasedRecognizerTouch;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ResizeStripeInputMode.prototype.pressedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ResizeStripeInputMode.prototype.draggedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ResizeStripeInputMode.prototype.cancelRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ResizeStripeInputMode.prototype.releasedRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ResizeStripeInputMode.prototype.resizeNeighborsRecognizer;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.ResizeStripeInputMode.prototype.ignoreContentRecognizer;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ResizeStripeInputMode.$class;

/**
 * Cancels the editing of this mode.
 * <p>
 * This implementation {\@link yfiles.input.ConcurrencyController#releaseMutex releases} the mutex if it is currently owned by this instance and calls
 * {\@link yfiles.input.ResizeStripeInputMode#onCanceled}.
 * </p>
 * @see yfiles.input.ResizeStripeInputMode#onCanceled
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.cancel = function() {};

/**
 * Installs this mode into the given context that is provided by the canvas.
 * <p>
 * In general a mode can only be installed into a single canvas at all times.
 * </p>
 * <p>
 * This method is called to initialize this instance. Subclasses should override this method to register the corresponding
 * event handler delegates for the various input events they need to register with.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation, first.
 * </p>
 * @see yfiles.input.IInputMode#uninstall
 * @param {?} context The context that this instance shall be installed into. The same instance will be passed to this instance during
 * {\@link #uninstall}. A reference to the context may be kept and queried during the time the mode is
 * installed.
 * @param {!yfiles.input.ConcurrencyController} controller The {\@link #controller} for this mode.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.install = function(context, controller) {};

/**
 * Called to determine whether it is valid to begin the gesture
 * <p>
 * This implementation checks whether a stripe border has been hit at the latest {\@link yfiles.view.MouseEventArgs}
 * </p>
 * @protected
 * @param {!Object} source
 * @param {!yfiles.lang.EventArgs} evt
 * @return {boolean} true iff a stripe border has been hit at the latest {\@link }
 */
yfiles.input.ResizeStripeInputMode.prototype.isValidBegin = function(source, evt) {};

/**
 * Called after {\@link yfiles.input.ResizeStripeInputMode#cancel} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been canceled.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onCanceled = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>true</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been activated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onConcurrencyControllerActivated = function() {};

/**
 * Called after the {\@link yfiles.input.ConcurrencyController#active} property of the installed {\@link yfiles.input.ConcurrencyController} has been set to <code>false</code>.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been deactivated.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onConcurrencyControllerDeactivated = function() {};

/**
 * Triggers the {\@link yfiles.input.ResizeStripeInputMode#addDragCanceledListener DragCanceled} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onDragCanceled = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.ResizeStripeInputMode#addDragCancelingListener DragCanceling} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onDragCanceling = function(evt) {};

/**
 * Callback triggered once the drag has been finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.ResizeStripeInputMode#addDragFinishedListener DragFinished}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onDragFinished = function(evt) {};

/**
 * Callback triggered before the drag will be finalized.
 * <p>
 * This method triggers the {\@link yfiles.input.ResizeStripeInputMode#addDragFinishingListener DragFinishing}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onDragFinishing = function(evt) {};

/**
 * Callback triggered at the end of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.ResizeStripeInputMode#addDraggedListener Dragged}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onDragged = function(evt) {};

/**
 * Callback triggered at the start of each drag.
 * <p>
 * This method triggers the {\@link yfiles.input.ResizeStripeInputMode#addDraggingListener Dragging}
 * event.
 * </p>
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onDragging = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.ResizeStripeInputMode#addDragStartedListener DragStarted} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onDragStarted = function(evt) {};

/**
 * Triggers the {\@link yfiles.input.ResizeStripeInputMode#addDragStartingListener DragStarting} event.
 * @protected
 * @param {!yfiles.input.InputModeEventArgs} evt The event argument that contains context information.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onDragStarting = function(evt) {};

/**
 * Called after {\@link yfiles.input.ResizeStripeInputMode#tryStop} has been called.
 * <p>
 * Can be overridden in subclasses to perform additional actions after the mode has been stopped.
 * </p>
 * <p>
 * This implementation does nothing.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.onStopped = function() {};

/**
 *
 * @return {boolean}
 */
yfiles.input.ResizeStripeInputMode.prototype.tryStop = function() {};

/**
 * Uninstalls this mode from the given context.
 * <p>
 * This code should clean up all changes made to the canvas in the {\@link yfiles.input.IInputMode#install} method. After a mode has
 * been uninstalled it can be installed again into the same or another canvas.
 * </p>
 * <p>
 * Overriding implementations should call the base implementation after their own code.
 * </p>
 * @param {?} context The context to deregister from. This is the same instance that had been passed to {\@link #install} during
 * installation.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.uninstall = function(context) {};

/**
 * Adds the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.ResizeStripeInputMode#removeDragFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.addDragFinishingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinishing</code> event that occurs before the drag will be finished.
 * @see yfiles.input.ResizeStripeInputMode#addDragFinishingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.removeDragFinishingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragFinished</code> event that occurs once the drag has been finished.
 * @see yfiles.input.ResizeStripeInputMode#removeDragFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.addDragFinishedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragFinished</code> event that occurs once the drag has been finished.
 * @see yfiles.input.ResizeStripeInputMode#addDragFinishedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.removeDragFinishedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.ResizeStripeInputMode#removeDragStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.addDragStartingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarting</code> event that occurs once the drag is starting.
 * @see yfiles.input.ResizeStripeInputMode#addDragStartingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.removeDragStartingListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.ResizeStripeInputMode#removeDragStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.addDragStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragStarted</code> event that occurs once the drag is initialized and has started.
 * @see yfiles.input.ResizeStripeInputMode#addDragStartedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.removeDragStartedListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.ResizeStripeInputMode#removeDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.addDraggingListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragging</code> event that occurs at the start of every drag.
 * @see yfiles.input.ResizeStripeInputMode#addDraggingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.removeDraggingListener = function(listener) {};

/**
 * Adds the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.ResizeStripeInputMode#removeDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.addDraggedListener = function(listener) {};

/**
 * Removes the given listener for the <code>Dragged</code> event that occurs at the end of every drag.
 * @see yfiles.input.ResizeStripeInputMode#addDraggedListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.removeDraggedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.ResizeStripeInputMode#removeDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.addDragCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceled</code> event that occurs when the drag has been canceled.
 * @see yfiles.input.ResizeStripeInputMode#addDragCanceledListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.removeDragCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.ResizeStripeInputMode#removeDragCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.addDragCancelingListener = function(listener) {};

/**
 * Removes the given listener for the <code>DragCanceling</code> event that occurs before the drag will be canceled.
 * @see yfiles.input.ResizeStripeInputMode#addDragCancelingListener
 * @param {function(!Object, !yfiles.input.InputModeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ResizeStripeInputMode.prototype.removeDragCancelingListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.IReparentStripeHandler = function() {};

/**
 * Determines whether the provided node may be reparented to a <code>newParent</code>.
 * <p>
 * This method is called to determine whether a {\@link yfiles.input.IReparentStripeHandler#reparent} operation should actually be
 * executed.
 * </p>
 * @abstract
 * @param {?} context The context that provides information about the user input.
 * @param {?} stripe The stripe that will be reparented.
 * @param {?} newParent The potential new parent.
 * @param {number} index The index where the stripe would be {\@link #reparent reparented}
 * @param {yfiles.input.StripeReparentPolicy} reparentPosition Where to place the stripe as a result of the gesture that would be used for the {\@link #reparent }
 * operation.
 * @return {boolean} Whether <code>newParent</code> is a valid new parent for <code>stripe</code> for the given index and gesture.
 */
yfiles.input.IReparentStripeHandler.prototype.isValidParent = function(context, stripe, newParent, index, reparentPosition) {};

/**
 * Performs the actual reparenting after the reparent gesture has been finalized.
 * <p>
 * Implementations should use {\@link yfiles.graph.ITable#setParent} or {\@link yfiles.graph.ITable#setParent} to set the parent of <code>movedStripe</code>
 * to <code>newParent</code>.
 * </p>
 * @abstract
 * @param {?} context The context that provides information about the user input.
 * @param {?} movedStripe The stripe that will be reparented.
 * @param {?} newParent The potential new parent.
 * @param {number} index The index where the stripe should be inserted.
 * @param {yfiles.input.StripeReparentPolicy} reparentPosition Where to place the stripe as a result of the gesture that triggered the reparent operation.
 * @return {void}
 */
yfiles.input.IReparentStripeHandler.prototype.reparent = function(context, movedStripe, newParent, index, reparentPosition) {};

/**
 * Determines whether the user may detach the given stripe from its current parent in order to reparent it.
 * @abstract
 * @param {?} context The context that provides information about the user input.
 * @param {?} stripe The stripe that is about to be detached from its current parent.
 * @return {boolean} Whether the stripe may be detached and reparented.
 */
yfiles.input.IReparentStripeHandler.prototype.shouldReparent = function(context, stripe) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IReparentStripeHandler;
/**
 * @record
 * @struct
 */
yfiles.input.ReparentStripeHandler = function() {};
 /** @type {number} */
yfiles.input.ReparentStripeHandler.prototype.maxRowLevel;
 /** @type {number} */
yfiles.input.ReparentStripeHandler.prototype.maxColumnLevel;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ReparentStripeHandler.$class;

/**
 * Adjust the size of the source or the target stripe.
 * <p>
 * This implementation adjusts the size of <code>stripe</code> to <code>Math.Max(originalStripeSize, originalParentSize)</code> if <code>reparentPosition</code>
 * is an {\@link yfiles.input.StripeReparentPolicy#ADD_CHILD} operation
 * </p>
 * @protected
 * @param {?} context The context that provides information about the user input.
 * @param {?} stripe The stripe that will be reparented.
 * @param {?} newParent The potential new parent.
 * @param {yfiles.input.StripeReparentPolicy} reparentPosition Where to place the stripe as a result of the gesture that triggered the reparent operation.
 * @param {number} index The index where the stripe should be inserted.
 * @param {number} originalStripeSize The original size of <code>stripe</code>
 * @param {number} originalParentSize The original size of <code>newParent</code>
 * @return {void}
 */
yfiles.input.ReparentStripeHandler.prototype.adjustSize = function(context, stripe, newParent, reparentPosition, index, originalStripeSize, originalParentSize) {};

/**
 * Checks the constraints imposed by {\@link yfiles.input.ReparentStripeHandler#maxRowLevel} or {\@link yfiles.input.ReparentStripeHandler#maxColumnLevel} for a valid gesture.
 * @param {?} context The context that provides information about the user input.
 * @param {?} stripe The stripe that will be reparented.
 * @param {?} newParent The potential new parent.
 * @param {number} index The index where the stripe would be {\@link #reparent reparented}
 * @param {yfiles.input.StripeReparentPolicy} reparentPosition Where to place the stripe as a result of the gesture that would be used for the {\@link #reparent }
 * operation.
 * @return {boolean} <code>true</code> iff the resulting nesting depth is smaller than {\@link #maxRowLevel} or {\@link #maxColumnLevel}, or if the nesting depth would not increase by the operation.
 */
yfiles.input.ReparentStripeHandler.prototype.isValidParent = function(context, stripe, newParent, index, reparentPosition) {};

/**
 * Performs the actual reparenting after the reparent gesture has been finalized.
 * <p>
 * This implementation adjusts the size of the moved and/or the target stripe by calling {\@link yfiles.input.ReparentStripeHandler#adjustSize}
 * .
 * </p>
 * @param {?} context The context that provides information about the user input.
 * @param {?} stripe The stripe that will be reparented.
 * @param {?} newParent The potential new parent.
 * @param {number} index The index where the stripe should be inserted.
 * @param {yfiles.input.StripeReparentPolicy} reparentPosition Where to place the stripe as a result of the gesture that triggered the reparent operation.
 * @return {void}
 */
yfiles.input.ReparentStripeHandler.prototype.reparent = function(context, stripe, newParent, index, reparentPosition) {};

/**
 * Determines whether the user may detach the given stripe from its current parent in order to reparent it.
 * @param {?} context The context that provides information about the user input.
 * @param {?} stripe The stripe that is about to be detached from its current parent.
 * @return {boolean} This implementation returns always <code>true</code>.
 */
yfiles.input.ReparentStripeHandler.prototype.shouldReparent = function(context, stripe) {};
/**
 * @record
 * @struct
 */
yfiles.input.ReparentStripeInputMode = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.input.ReparentStripeInputMode.$class;
/**
 * @record
 * @struct
 */
yfiles.input.StripeDropInputMode = function() {};
 /** @type {?} */
yfiles.input.StripeDropInputMode.prototype.draggedItem;
 /** @type {!yfiles.lang.Class} */
yfiles.input.StripeDropInputMode.$class;

/**
 * Create a preview version of the table that is temporarily used to show the dragged stripe.
 * @protected
 * @return {?}
 */
yfiles.input.StripeDropInputMode.prototype.createPreviewTable = function() {};

/**
 * Create a new stripe as the result of a drag and drop gesture.
 * <p>
 * This method is called by the {\@link yfiles.input.ItemDropInputMode.<T>#itemCreator} that is set as default on this class.
 * </p>
 * @protected
 * @param {?} context The context for which the stripe should be created.
 * @param {?} newParent The parent for which to create the stripe.
 * @return {?} a newly created stripe.
 */
yfiles.input.StripeDropInputMode.prototype.createStripe = function(context, newParent) {};

/**
 * Calculates the layout of the new table.
 * <p>
 * In this implementation the mouse location is used as center of the table. Can be overridden in child class to implement
 * a different layout.
 * </p>
 * @protected
 * @param {!yfiles.geometry.Point} location Current mouse position
 * @param {!yfiles.geometry.Size} size Size of the table
 * @return {!yfiles.geometry.Rect} a {\@link } with the given size and the mouse location as center.
 */
yfiles.input.StripeDropInputMode.prototype.getPreviewTableLayout = function(location, size) {};

/**
 * Called whenever a new stripe is created
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt
 * @return {void}
 */
yfiles.input.StripeDropInputMode.prototype.onStripeCreated = function(evt) {};

/**
 * Starts a drag and drop operation for an {\@link yfiles.graph.IStripe}.
 * <p>
 * This convenience implementation delegates to {\@link yfiles.view.DragSource#startDrag} passing the <code>stripe</code> to the {\@link yfiles.view.DragDropItem}
 * using the corresponding type.
 * </p>
 * <p>
 * If <code>useCssCursors</code> is enabled, the following CSS classes are assigned to elements hovered during a drag operation,
 * depending on the allowed drag-drop operations for these elements:
 * </p>
 * <ul>
 * <li><code>yfiles-cursor-dragdrop-move</code></li>
 * <li><code>yfiles-cursor-dragdrop-link</code></li>
 * <li><code>yfiles-cursor-dragdrop-all</code></li>
 * <li><code>yfiles-cursor-dragdrop-no-drop</code></li>
 * </ul>
 * @see yfiles.view.DragSource#startDrag
 * @see yfiles.view.DragDropItem
 * Starts a drag and drop operation for an {\@link yfiles.graph.IStripe}.
 * <p>
 * This convenience implementation delegates to {\@link yfiles.view.DragSource#startDrag} passing the <code>stripe</code> to the {\@link yfiles.view.DragDropItem}
 * using the corresponding type.
 * </p>
 * <p>
 * If <code>useCssCursors</code> is enabled, the following CSS classes are assigned to elements hovered during a drag operation,
 * depending on the allowed drag-drop operations for these elements:
 * </p>
 * <ul>
 * <li><code>yfiles-cursor-dragdrop-move</code></li>
 * <li><code>yfiles-cursor-dragdrop-link</code></li>
 * <li><code>yfiles-cursor-dragdrop-all</code></li>
 * <li><code>yfiles-cursor-dragdrop-no-drop</code></li>
 * </ul>
 * @see yfiles.view.DragSource#startDrag
 * @see yfiles.view.DragDropItem
 * @param {!HTMLElement|{dragSource: !HTMLElement, stripe: ?, dragDropEffects: yfiles.view.DragDropEffects, useCssCursors: boolean}} dragSource_or_options The source of the drag operation.
 * @param {?=} stripe The stripe to drag.
 * @param {yfiles.view.DragDropEffects=} dragDropEffects
 * @param {boolean=} useCssCursors
 * @return {void}
 */
yfiles.input.StripeDropInputMode.startDrag = function(dragSource_or_options, stripe, dragDropEffects, useCssCursors) {};

/**
 * Adds the given listener for the <code>StripeCreated</code> event that occurs when a new stripe gets created by this input mode.
 * @see yfiles.input.StripeDropInputMode#removeStripeCreatedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.StripeDropInputMode.prototype.addStripeCreatedListener = function(listener) {};

/**
 * Removes the given listener for the <code>StripeCreated</code> event that occurs when a new stripe gets created by this input mode.
 * @see yfiles.input.StripeDropInputMode#addStripeCreatedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.StripeDropInputMode.prototype.removeStripeCreatedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.ReparentStripePositionHandler = function() {};
 /** @type {?} */
yfiles.input.ReparentStripePositionHandler.prototype.location;
 /** @type {?} */
yfiles.input.ReparentStripePositionHandler.prototype.movedStripe;
 /** @type {?} */
yfiles.input.ReparentStripePositionHandler.prototype.inputModeContext;
 /** @type {!yfiles.lang.Class} */
yfiles.input.ReparentStripePositionHandler.$class;

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @return {void}
 */
yfiles.input.ReparentStripePositionHandler.prototype.cancelDrag = function(context, originalLocation) {};

/**
 * Create a visualization for the source region of the reparent gesture.
 * <p>
 * The default implementation uses the return value of {\@link yfiles.input.IStripeInputVisualizationHelper#getVisualCreator} with
 * type {\@link yfiles.input.StripeVisualizationType#DRAG_SOURCE}.
 * </p>
 * @see yfiles.input.ReparentStripePositionHandler#updateSourceVisualization
 * @protected
 * @param {?} context The current input mode context
 * @return {?} A canvas object that is used to visualize the target region.
 */
yfiles.input.ReparentStripePositionHandler.prototype.createSourceGhostVisualization = function(context) {};

/**
 * Create a visualization for the target region of the reparent gesture.
 * <p>
 * The default implementation uses the return value of {\@link yfiles.input.IStripeInputVisualizationHelper#getVisualCreator} with
 * type {\@link yfiles.input.StripeVisualizationType#DROP_TARGET}.
 * </p>
 * @see yfiles.input.ReparentStripePositionHandler#updateTargetVisualization
 * @protected
 * @param {?} context The current input mode context
 * @param {?} stripe The stripe for which the visualization should be created.
 * @return {?} A canvas object that is used to visualize the target region.
 */
yfiles.input.ReparentStripePositionHandler.prototype.createTargetGhostVisualization = function(context, stripe) {};

/**
 * Determine the reparent gesture that would result from the given parameters.
 * <p>
 * The target region has already been determined by {\@link yfiles.input.ReparentStripePositionHandler#getTargetSubregion}
 * </p>
 * @protected
 * @param {?} context The current input mode context
 * @param {?} location The current drag location
 * @param {?} sourceStripe The stripe that is moved
 * @param {!yfiles.input.StripeSubregion} targetSubregion The stripe subregion for the target.
 * @param {!yfiles.geometry.Rect} targetBounds The target bounds
 * @return {yfiles.input.StripeReparentPolicy} A {\@link } that specifies the operation to perform.
 */
yfiles.input.ReparentStripePositionHandler.prototype.determineGesture = function(context, location, sourceStripe, targetSubregion, targetBounds) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.ReparentStripePositionHandler.prototype.dragFinished = function(context, originalLocation, newLocation) {};

/**
 * Finds the target stripe subregion at <code>location</code> and its associated owner node.
 * @protected
 * @param {!yfiles.geometry.Point} location The hit location.
 * @return {!yfiles.input.StripeSubregion} A {\@link } that lies at <code>location</code>, or null if no such region could be found.
 */
yfiles.input.ReparentStripePositionHandler.prototype.getTargetSubregion = function(location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} originalLocation
 * @param {!yfiles.geometry.Point} newLocation
 * @return {void}
 */
yfiles.input.ReparentStripePositionHandler.prototype.handleMove = function(context, originalLocation, newLocation) {};

/**
 *
 * @param {?} context
 * @return {void}
 */
yfiles.input.ReparentStripePositionHandler.prototype.initializeDrag = function(context) {};

/**
 * Called whenever a change in the oldTable hierarchy occurs through this position handler
 * @protected
 * @param {!yfiles.graph.StripeEventArgs} evt
 * @return {void}
 */
yfiles.input.ReparentStripePositionHandler.prototype.onStripeChanged = function(evt) {};

/**
 *
 * @param {!yfiles.geometry.Point} location
 * @return {void}
 */
yfiles.input.ReparentStripePositionHandler.prototype.setPosition = function(location) {};

/**
 * Modifies the source visualization itself
 * <p>
 * The default does not change <code>targetVisualization</code>.
 * </p>
 * @protected
 * @param {?} context The current input mode context.
 * @param {?} targetVisualization The canvas object for the target visualization
 * @param {?} targetStripe The target for the reparent gesture
 * @param {yfiles.input.StripeReparentPolicy} reparentPosition Where to place the stripe after reparenting.
 * @return {?}
 */
yfiles.input.ReparentStripePositionHandler.prototype.updateSourceVisualization = function(context, targetVisualization, targetStripe, reparentPosition) {};

/**
 * Modifies the target visualization itself.
 * <p>
 * The default implementation only hides <code>targetVisualization</code> iff <code>reparentPosition</code> is
 * {\@link yfiles.input.StripeReparentPolicy#INVALID}.
 * </p>
 * @protected
 * @param {?} context The current input mode context.
 * @param {?} targetVisualization The canvas object for the target visualization.
 * @param {?} targetStripe The target for the reparent gesture.
 * @param {yfiles.input.StripeReparentPolicy} reparentPosition The mode the describes the results of the reparent gesture.
 * @param {!yfiles.geometry.Rect} targetBounds The current visualization bounds that have been computed with
 * {\@link #updateTargetVisualizationBounds}
 * @return {?}
 */
yfiles.input.ReparentStripePositionHandler.prototype.updateTargetVisualization = function(context, targetVisualization, targetStripe, reparentPosition, targetBounds) {};

/**
 * Updates the visualization bounds for the target visualization depending on the provided values.
 * @protected
 * @param {!yfiles.geometry.Rect} originalTargetBounds The target bounds prior to this method call.
 * @param {yfiles.input.StripeReparentPolicy} reparentPosition Where to place the stripe after the reparenting operations according to the reparent gesture.
 * @param {?} targetStripe The target stripe which has been determined by the input mode.
 * @return {!yfiles.geometry.Rect} Updated bounds for the target visualization.
 */
yfiles.input.ReparentStripePositionHandler.prototype.updateTargetVisualizationBounds = function(originalTargetBounds, reparentPosition, targetStripe) {};

/**
 * Adds the given listener for the <code>StripeChanged</code> event that occurs when a stripe state is changed by this input mode.
 * @see yfiles.input.ReparentStripePositionHandler#removeStripeChangedListener
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.ReparentStripePositionHandler.prototype.addStripeChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>StripeChanged</code> event that occurs when a stripe state is changed by this input mode.
 * @see yfiles.input.ReparentStripePositionHandler#addStripeChangedListener
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.ReparentStripePositionHandler.prototype.removeStripeChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.TableEditorInputMode = function() {};
 /** @type {!yfiles.input.ResizeStripeInputMode} */
yfiles.input.TableEditorInputMode.prototype.resizeStripeInputMode;
 /** @type {?} */
yfiles.input.TableEditorInputMode.prototype.reparentStripeHandler;
 /** @type {!yfiles.input.ReparentStripeInputMode} */
yfiles.input.TableEditorInputMode.prototype.reparentStripeInputMode;
 /** @type {!yfiles.input.StripeDropInputMode} */
yfiles.input.TableEditorInputMode.prototype.stripeDropInputMode;
 /** @type {!yfiles.input.KeyboardInputMode} */
yfiles.input.TableEditorInputMode.prototype.keyboardInputMode;
 /** @type {!yfiles.input.TextEditorInputMode} */
yfiles.input.TableEditorInputMode.prototype.textEditorInputMode;
 /** @type {yfiles.graph.StripeTypes} */
yfiles.input.TableEditorInputMode.prototype.labelEditableItems;
 /** @type {boolean} */
yfiles.input.TableEditorInputMode.prototype.autoRemoveEmptyLabels;
 /** @type {!yfiles.input.ClickInputMode} */
yfiles.input.TableEditorInputMode.prototype.clickInputMode;
 /** @type {yfiles.graph.StripeTypes} */
yfiles.input.TableEditorInputMode.prototype.deletableItems;
 /** @type {yfiles.graph.StripeTypes} */
yfiles.input.TableEditorInputMode.prototype.selectableItems;
 /** @type {yfiles.graph.StripeTypes} */
yfiles.input.TableEditorInputMode.prototype.clickSelectableItems;
 /** @type {boolean} */
yfiles.input.TableEditorInputMode.prototype.allowEditLabel;
 /** @type {boolean} */
yfiles.input.TableEditorInputMode.prototype.allowAddLabel;
 /** @type {function(!Object, !yfiles.lang.EventArgs): boolean} */
yfiles.input.TableEditorInputMode.prototype.multiSelectionRecognizer;
 /** @type {yfiles.input.StripeSubregionTypes} */
yfiles.input.TableEditorInputMode.prototype.clickSelectableRegions;
 /** @type {boolean} */
yfiles.input.TableEditorInputMode.prototype.synchronizeWithGraphSelection;
 /** @type {boolean} */
yfiles.input.TableEditorInputMode.prototype.allowMixedSelection;
 /** @type {?} */
yfiles.input.TableEditorInputMode.prototype.stripeSelection;
 /** @type {!yfiles.lang.Class} */
yfiles.input.TableEditorInputMode.$class;

/**
 * Adds a new label to the given stripe interactively.
 * <p>
 * This will activate the {\@link yfiles.input.TableEditorInputMode#textEditorInputMode} to let the user interactively enter the label's text and unless the user cancels label creation
 * the returned {\@link yfiles.graphml.Future.<T>} will contain the label.
 * </p>
 * <p>
 * The text that the user enters may be {\@link yfiles.input.TableEditorInputMode#addValidateLabelTextListener validated} before the label is actually added.
 * </p>
 * <p>
 * This method is similar to {\@link yfiles.input.TableEditorInputMode#createLabel}. It differs only when either the {\@link yfiles.input.TableEditorInputMode#addLabelAddingListener LabelAdding}
 * event is handled or the <code>owner</code> has an {\@link yfiles.input.IEditLabelHelper} requests editing an existing label instead of
 * creating a new one. In this case, this method will edit that label instead of adding a new one.
 * </p>
 * @param {?} owner The item.
 * @return {!Promise<?>} A future of the label that will be notified of the newly created label or a <code>null</code> if the creation was canceled.
 */
yfiles.input.TableEditorInputMode.prototype.addLabel = function(owner) {};

/**
 * Clears the current selection.
 * @see yfiles.input.TableEditorInputMode#selectableItems
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.clearSelection = function() {};

/**
 * Factory method that creates the {\@link yfiles.input.TableEditorInputMode#keyboardInputMode} instance.
 * @protected
 * @return {!yfiles.input.ClickInputMode}
 */
yfiles.input.TableEditorInputMode.prototype.createClickInputMode = function() {};

/**
 * Factory method that creates the {\@link yfiles.input.TableEditorInputMode#keyboardInputMode} instance.
 * @protected
 * @return {!yfiles.input.KeyboardInputMode}
 */
yfiles.input.TableEditorInputMode.prototype.createKeyboardInputMode = function() {};

/**
 * Interactively creates a new label for the provided stripe.
 * <p>
 * This method will invoke the text editor that will let the user edit the text of the label. If the user commits the label
 * text the label will be added to the label owner.
 * </p>
 * <p>
 * The text that the user enters may be {\@link yfiles.input.TableEditorInputMode#addValidateLabelTextListener validated} before the label is actually added.
 * </p>
 * <p>
 * This method is similar to {\@link yfiles.input.TableEditorInputMode#addLabel}. It differs only when either the {\@link yfiles.input.TableEditorInputMode#addLabelAddingListener LabelAdding}
 * event is handled or the <code>stripe</code> has an {\@link yfiles.input.IEditLabelHelper} requests editing an existing label instead of
 * creating a new one. In both cases, this method will do nothing and neither adds a new label nor edits an existing one.
 * </p>
 * @param {?} stripe The item to create a new label for.
 * @return {!Promise<?>} A future of the label that will be notified of the newly created label or a <code>null</code> if the creation was canceled.
 */
yfiles.input.TableEditorInputMode.prototype.createLabel = function(stripe) {};

/**
 * Factory method for the {\@link yfiles.input.TableEditorInputMode#reparentStripeHandler} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.TableEditorInputMode#reparentStripeHandler} property.
 * </p>
 * @protected
 * @return {?} a new instance of {\@link }
 */
yfiles.input.TableEditorInputMode.prototype.createReparentStripeHandler = function() {};

/**
 * Factory method that creates the {\@link yfiles.input.TableEditorInputMode#reparentStripeInputMode} lazily the first time the property is accessed.
 * @protected
 * @return {!yfiles.input.ReparentStripeInputMode} A plain new instance of the {\@link } type, which is initially {\@link #enabled enabled}.
 */
yfiles.input.TableEditorInputMode.prototype.createReparentStripeInputMode = function() {};

/**
 * Factory method that creates the {\@link yfiles.input.TableEditorInputMode#resizeStripeInputMode} lazily the first time the property is accessed.
 * @protected
 * @return {!yfiles.input.ResizeStripeInputMode} A plain new instance of the {\@link } type, which is initially {\@link #enabled enabled}.
 */
yfiles.input.TableEditorInputMode.prototype.createResizeStripeInputMode = function() {};

/**
 * Factory method that creates the {\@link yfiles.input.TableEditorInputMode#stripeDropInputMode} lazily the first time the property is accessed.
 * @protected
 * @return {!yfiles.input.StripeDropInputMode} A plain new instance of the {\@link } type, which is initially {\@link #enabled disabled}.
 */
yfiles.input.TableEditorInputMode.prototype.createStripeDropInputMode = function() {};

/**
 * Create a new instance of {\@link yfiles.view.IStripeSelection} the first time property {\@link yfiles.input.TableEditorInputMode#stripeSelection} is accessed.
 * <p>
 * By default, the {\@link yfiles.view.IStripeSelection#allowMixedSelection} property is <code>false</code>.
 * </p>
 * @protected
 * @return {?} A new {\@link } instance.
 */
yfiles.input.TableEditorInputMode.prototype.createStripeSelection = function() {};

/**
 * Factory method for the {\@link yfiles.input.TableEditorInputMode#textEditorInputMode} property.
 * <p>
 * This method will be called upon first access to the {\@link yfiles.input.TableEditorInputMode#textEditorInputMode} property.
 * </p>
 * @protected
 * @return {!yfiles.input.TextEditorInputMode} a new instance of {\@link }
 */
yfiles.input.TableEditorInputMode.prototype.createTextEditorInputMode = function() {};

/**
 * This method deletes the currently selected stripes.
 * <p>
 * If the {\@link yfiles.input.TableEditorInputMode#stripeSelection} is non-empty this implementation triggers the {\@link yfiles.input.TableEditorInputMode#addDeletingSelectionListener DeletingSelection}
 * event, possibly a number of {\@link yfiles.input.TableEditorInputMode#addDeletedItemListener DeletedItem}
 * events, and a final {\@link yfiles.input.TableEditorInputMode#deleteSelection} event.
 * </p>
 * @see yfiles.input.TableEditorInputMode#addDeletingSelectionListener
 * @see yfiles.input.TableEditorInputMode#addDeletedItemListener
 * @see yfiles.input.TableEditorInputMode#addDeletedSelectionListener
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.deleteSelection = function() {};

/**
 * Deletes a single stripe
 * @param {?} stripe The stripe to delete.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.deleteStripe = function(stripe) {};

/**
 * Starts editing of the given label.
 * <p>
 * The label must be bound to an {\@link yfiles.graph.IStripe} instance for this call to succeed.
 * </p>
 * <p>
 * This implementation uses the {\@link yfiles.input.TableEditorInputMode#textEditorInputMode} to display an editor to edit the label. The text that the user enters may be {\@link yfiles.input.TableEditorInputMode#addValidateLabelTextListener validated}
 * before the label is actually edited.
 * </p>
 * <p>
 * This method will raise the {\@link yfiles.input.TableEditorInputMode#addLabelEditingListener LabelEditing}
 * event and query the {\@link yfiles.input.IEditLabelHelper} for the label and its owner, but will ignore the result except for the
 * {\@link yfiles.input.LabelEditingEventArgs#textEditorInputModeConfigurator} property on the {\@link yfiles.input.LabelEditingEventArgs}. Thus editing a label via this method cannot be prevented by event
 * handlers or {\@link yfiles.input.IEditLabelHelper}s.
 * </p>
 * @see yfiles.input.TableEditorInputMode#onLabelTextEdited
 * @param {?} label The label to edit.
 * @return {!Promise<?>}
 */
yfiles.input.TableEditorInputMode.prototype.editLabel = function(label) {};

/**
 * Used as a callback to find the items underneath a certain point.
 * @param {!yfiles.geometry.Point} location The location to test.
 * @param {yfiles.graph.StripeTypes} stripeTypes An enumeration value of {\@link } to specify the stripe type.
 * @param {yfiles.input.StripeSubregionTypes} subregionTypes An enumeration value of {\@link } to further restrict the stripe region.
 * @param {function(!yfiles.input.StripeSubregion): boolean=} filter
 * @return {!yfiles.input.StripeSubregion} The stripe subregions that have been found for the location or <code>null</code>.
 */
yfiles.input.TableEditorInputMode.prototype.findStripe = function(location, stripeTypes, subregionTypes, filter) {};

/**
 * Used as a callback to find the items underneath a certain point.
 * @param {!yfiles.geometry.Point} location The location to test.
 * @param {yfiles.graph.StripeTypes} stripeTypes An enumeration value of {\@link } to specify the stripe type.
 * @param {yfiles.input.StripeSubregionTypes} subregionTypes An enumeration value of {\@link } to further restrict the stripe region.
 * @param {function(!yfiles.input.StripeSubregion): boolean=} filter
 * @return {?<!yfiles.input.StripeSubregion>} The stripe subregions that have been found for the location.
 */
yfiles.input.TableEditorInputMode.prototype.findStripes = function(location, stripeTypes, subregionTypes, filter) {};

/**
 * Convenience method that inserts a new stripe as child of <code>owner</code>
 * <p>
 * This method automatically resizes the table node and moves all content in neighboring stripes accordingly. The stripe is
 * created with an initial <code>size</code> and otherwise the default settings of the table where <code>owner</code> belongs to. If <code>size</code> is entered
 * as <code>0</code>, the owners default size is used.
 * </p>
 * @param {?} owner The parent of the new stripe.
 * @param {number} index The index where to insert the new stripe.
 * @param {number=} size
 * @return {?} A new stripe at the given index.
 */
yfiles.input.TableEditorInputMode.prototype.insertChild = function(owner, index, size) {};

/**
 * Callback that is invoked if the shift+F2 key is pressed and {\@link yfiles.input.TableEditorInputMode#allowAddLabel} is set to <code>true</code>.
 * <p>
 * This method determines the label owner to add to and delegates to {\@link yfiles.input.TableEditorInputMode#createLabel}.
 * </p>
 * @protected
 * @return {boolean}
 */
yfiles.input.TableEditorInputMode.prototype.onAddLabel = function() {};

/**
 * Called when the {\@link yfiles.input.TableEditorInputMode#clickInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.ClickInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.ClickInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onClickInputModeChanged = function(oldMode, newMode) {};

/**
 * Callback that gets triggered once {\@link yfiles.input.TableEditorInputMode#clickInputMode} triggers the {\@link yfiles.input.ClickInputMode#addClickedListener Clicked}
 * event.
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.input.ClickEventArgs} evt
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onClickInputModeClicked = function(sender, evt) {};

/**
 * Callback that gets triggered once {\@link yfiles.input.TableEditorInputMode#clickInputMode} triggers the {\@link yfiles.input.ClickInputMode#addDoubleClickedListener DoubleClicked}
 * event.
 * @protected
 * @param {!Object} sender
 * @param {!yfiles.input.ClickEventArgs} evt
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onClickInputModeDoubleClicked = function(sender, evt) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addDeletedItemListener DeletedItem} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The instance containing the event data.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onDeletedItem = function(evt) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addDeletedSelectionListener DeletedSelection} event.
 * @protected
 * @param {!yfiles.input.SelectionEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onDeletedSelection = function(evt) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addDeletingSelectionListener DeletingSelection} event.
 * @protected
 * @param {!yfiles.input.SelectionEventArgs<?>} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onDeletingSelection = function(evt) {};

/**
 * Callback that is invoked if the F2 key is pressed and {\@link yfiles.input.TableEditorInputMode#allowEditLabel} is set to <code>true</code>.
 * <p>
 * This method determines the label to edit and delegates to either {\@link yfiles.input.TableEditorInputMode#editLabel} or {\@link yfiles.input.TableEditorInputMode#createLabel}
 * if no label could be found.
 * </p>
 * @protected
 * @return {boolean}
 */
yfiles.input.TableEditorInputMode.prototype.onEditLabel = function() {};

/**
 * Called when the {\@link yfiles.input.TableEditorInputMode#keyboardInputMode} changed.
 * @protected
 * @param {!yfiles.input.KeyboardInputMode} oldMode The old {\@link #keyboardInputMode}.
 * @param {!yfiles.input.KeyboardInputMode} newMode The new {\@link #keyboardInputMode}.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onKeyboardInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addLabelAddedListener LabelAdded} event.
 * @protected
 * @param {!yfiles.graph.LabelEventArgs} evt The {\@link } instance that contains the {\@link } that has been added.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onLabelAdded = function(evt) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addLabelAddingListener LabelAdding} event.
 * <p>
 * Invoking the event handlers stops once one event marks the <code>args</code> as handled.
 * </p>
 * @protected
 * @param {!yfiles.input.LabelEditingEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onLabelAdding = function(evt) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addLabelEditingListener LabelEditing} event.
 * <p>
 * Invoking the event handlers stops once one event marks the <code>args</code> as handled.
 * </p>
 * @protected
 * @param {!yfiles.input.LabelEditingEventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onLabelEditing = function(evt) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addLabelTextChangedListener LabelTextChanged} event.
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The {\@link } instance that contains the {\@link } that has changed the text.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onLabelTextChanged = function(evt) {};

/**
 * Called when the text of a label has been {\@link yfiles.input.TableEditorInputMode#editLabel edited}.
 * <p>
 * This method {\@link yfiles.input.TableEditorInputMode#addValidateLabelTextListener validates the label text} and if successful sets the label text.
 * </p>
 * @protected
 * @param {?} label The label that was edited.
 * @param {string} text The new text.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onLabelTextEdited = function(label, text) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addLabelTextEditingCanceledListener LabelTextEditingCanceled}
 * event.
 * @protected
 * @param {!yfiles.graph.LabelEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onLabelTextEditingCanceled = function(evt) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addLabelTextEditingStartedListener LabelTextEditingStarted}
 * event.
 * @protected
 * @param {!yfiles.graph.LabelEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onLabelTextEditingStarted = function(evt) {};

/**
 * Called when the {\@link yfiles.input.TableEditorInputMode#reparentStripeHandler} property value changes and after initialization of the field.
 * @protected
 * @param {?} oldHandler the old value, which may be <code>null</code> the first time
 * @param {?} newHandler the new value
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onReparentStripeHandlerChanged = function(oldHandler, newHandler) {};

/**
 * Called when the {\@link yfiles.input.TableEditorInputMode#reparentStripeInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.ReparentStripeInputMode} oldHandler the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.ReparentStripeInputMode} newHandler the new value
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onReparentStripeInputModeChanged = function(oldHandler, newHandler) {};

/**
 * Called when the {\@link yfiles.input.TableEditorInputMode#resizeStripeInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.ResizeStripeInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.ResizeStripeInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onResizeStripeInputModeChanged = function(oldMode, newMode) {};

/**
 * Called when the {\@link yfiles.input.TableEditorInputMode#stripeDropInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.StripeDropInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.StripeDropInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onStripeDropInputModeChanged = function(oldMode, newMode) {};

/**
 * Called when the {\@link yfiles.input.TableEditorInputMode#textEditorInputMode} property value changes and after initialization of the field.
 * @protected
 * @param {!yfiles.input.TextEditorInputMode} oldMode the old value, which may be <code>null</code> the first time
 * @param {!yfiles.input.TextEditorInputMode} newMode the new value
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onTextEditorInputModeChanged = function(oldMode, newMode) {};

/**
 * Raises the {\@link yfiles.input.TableEditorInputMode#addValidateLabelTextListener ValidateLabelText} event.
 * @protected
 * @param {!yfiles.input.LabelTextValidatingEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.onValidateLabelText = function(evt) {};

/**
 * Clears the current selection and selects all stripes in all table instances.
 * <p>
 * By default, this method will be called in response to a Ctrl-A-key press recognized by {\@link yfiles.input.TableEditorInputMode#keyboardInputMode}.
 * </p>
 * @see yfiles.input.ICommand#SELECT_ALL
 * @see yfiles.input.TableEditorInputMode#selectableItems
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.selectAll = function() {};

/**
 * Predicate that determines whether a label may be added interactively to <code>item</code>
 * <p>
 * This is overridden if the item has a {\@link yfiles.input.IEditLabelHelper} that returns <code>false</code> for its {\@link yfiles.input.IEditLabelHelper#onLabelAdding}
 * method.
 * </p>
 * @protected
 * @param {?} item The item to query
 * @return {boolean} <code>true</code> iff a label may be added
 */
yfiles.input.TableEditorInputMode.prototype.shouldAddLabel = function(item) {};

/**
 * Callback method that determines whether the given item should be deleted during
 * {\@link yfiles.input.TableEditorInputMode#deleteSelection}.
 * <p>
 * This implementation deletes an item if it is of one of the {\@link yfiles.input.TableEditorInputMode#deletableItems} type and if it is not the last stripe of a given type in the
 * table (e.g. the only row or the only column).
 * </p>
 * @protected
 * @param {?} stripe The item.
 * @return {boolean} Whether to delete that item.
 */
yfiles.input.TableEditorInputMode.prototype.shouldDelete = function(stripe) {};

/**
 * Callback method that determines whether the label or the labels of the provided item should be edited in response to a
 * command or explicit method call to {\@link yfiles.input.TableEditorInputMode#editLabel} or
 * {\@link yfiles.input.TableEditorInputMode#createLabel}.
 * @protected
 * @param {?} item The item.
 * @return {boolean} Whether to edit the label or the labels for that item.
 */
yfiles.input.TableEditorInputMode.prototype.shouldEditLabel = function(item) {};

/**
 * Callback method that is used by {\@link yfiles.input.TableEditorInputMode#onKeyboardInputModeChanged} to determine which of the
 * built-in {\@link yfiles.input.ICommand}s to install.
 * <p>
 * This implementation unconditionally returns <code>true</code>, subclasses may override this method to adjust the behavior.
 * </p>
 * @protected
 * @param {?} command The command to install.
 * @return {boolean} Whether to install this command.
 */
yfiles.input.TableEditorInputMode.prototype.shouldInstallCommand = function(command) {};

/**
 * Adds the given listener for the <code>LabelAdding</code> event that occurs when a label is about to be added.
 * <p>
 * Event handlers for this event can customize the behavior for adding a new label extensively. Adding a label can be
 * forbidden entirely, or the properties of the added label can be changed, by setting the appropriate properties on the
 * {\@link yfiles.input.LabelEditingEventArgs}. It is even possible to forbid adding a label, but edit an existing one instead.
 * </p>
 * @see yfiles.input.TableEditorInputMode#removeLabelAddingListener
 * @param {function(!Object, !yfiles.input.LabelEditingEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addLabelAddingListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelAdding</code> event that occurs when a label is about to be added.
 * <p>
 * Event handlers for this event can customize the behavior for adding a new label extensively. Adding a label can be
 * forbidden entirely, or the properties of the added label can be changed, by setting the appropriate properties on the
 * {\@link yfiles.input.LabelEditingEventArgs}. It is even possible to forbid adding a label, but edit an existing one instead.
 * </p>
 * @see yfiles.input.TableEditorInputMode#addLabelAddingListener
 * @param {function(!Object, !yfiles.input.LabelEditingEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeLabelAddingListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelEditing</code> event that occurs when a label is about to be edited.
 * <p>
 * Event handlers for this event can customize the behavior for editing an existing label. Editing can be forbidden
 * entirely, or redirected to a different label, even on a different owner. In case editing existing labels is unwanted,
 * event handlers can also specify that instead of editing a label, a new one should be added.
 * </p>
 * @see yfiles.input.TableEditorInputMode#removeLabelEditingListener
 * @param {function(!Object, !yfiles.input.LabelEditingEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addLabelEditingListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelEditing</code> event that occurs when a label is about to be edited.
 * <p>
 * Event handlers for this event can customize the behavior for editing an existing label. Editing can be forbidden
 * entirely, or redirected to a different label, even on a different owner. In case editing existing labels is unwanted,
 * event handlers can also specify that instead of editing a label, a new one should be added.
 * </p>
 * @see yfiles.input.TableEditorInputMode#addLabelEditingListener
 * @param {function(!Object, !yfiles.input.LabelEditingEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeLabelEditingListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelAdded</code> event that occurs when this mode has triggered the addition of an
 * {\@link yfiles.graph.ILabel}, for instance, in response to {\@link yfiles.input.TableEditorInputMode#createLabel}.
 * @see yfiles.input.TableEditorInputMode#removeLabelAddedListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addLabelAddedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelAdded</code> event that occurs when this mode has triggered the addition of an
 * {\@link yfiles.graph.ILabel}, for instance, in response to {\@link yfiles.input.TableEditorInputMode#createLabel}.
 * @see yfiles.input.TableEditorInputMode#addLabelAddedListener
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeLabelAddedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelTextChanged</code> event that occurs when this mode has triggered the edit of an
 * {\@link yfiles.graph.ILabel}, for instance, in response to {\@link yfiles.input.TableEditorInputMode#editLabel}.
 * @see yfiles.input.TableEditorInputMode#removeLabelTextChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addLabelTextChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelTextChanged</code> event that occurs when this mode has triggered the edit of an
 * {\@link yfiles.graph.ILabel}, for instance, in response to {\@link yfiles.input.TableEditorInputMode#editLabel}.
 * @see yfiles.input.TableEditorInputMode#addLabelTextChangedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeLabelTextChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelTextEditingStarted</code> event that occurs when the actual label editing process is about
 * to start.
 * <p>
 * This allows to customize the actual label editing process further.
 * </p>
 * @see yfiles.input.TableEditorInputMode#onValidateLabelText
 * @see yfiles.input.TableEditorInputMode#removeLabelTextEditingStartedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addLabelTextEditingStartedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelTextEditingStarted</code> event that occurs when the actual label editing process is
 * about to start.
 * <p>
 * This allows to customize the actual label editing process further.
 * </p>
 * @see yfiles.input.TableEditorInputMode#onValidateLabelText
 * @see yfiles.input.TableEditorInputMode#addLabelTextEditingStartedListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeLabelTextEditingStartedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelTextEditingCanceled</code> event that occurs when the actual label editing process is
 * canceled.
 * <p>
 * This allows to unconfigure temporary customizations for the actual label editing process.
 * </p>
 * @see yfiles.input.TableEditorInputMode#onValidateLabelText
 * @see yfiles.input.TableEditorInputMode#removeLabelTextEditingCanceledListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addLabelTextEditingCanceledListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelTextEditingCanceled</code> event that occurs when the actual label editing process is
 * canceled.
 * <p>
 * This allows to unconfigure temporary customizations for the actual label editing process.
 * </p>
 * @see yfiles.input.TableEditorInputMode#onValidateLabelText
 * @see yfiles.input.TableEditorInputMode#addLabelTextEditingCanceledListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeLabelTextEditingCanceledListener = function(listener) {};

/**
 * Adds the given listener for the <code>ValidateLabelText</code> event that occurs after label editing to validate the label text for a
 * label that is about to be added or edited.
 * <p>
 * Note that the {\@link yfiles.input.LabelTextValidatingEventArgs#label} may only a dummy instance, i.e. not bound to a live stripe instance.
 * </p>
 * @see yfiles.input.TableEditorInputMode#onValidateLabelText
 * @see yfiles.input.TableEditorInputMode#removeValidateLabelTextListener
 * @param {function(!Object, !yfiles.input.LabelTextValidatingEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addValidateLabelTextListener = function(listener) {};

/**
 * Removes the given listener for the <code>ValidateLabelText</code> event that occurs after label editing to validate the label text
 * for a label that is about to be added or edited.
 * <p>
 * Note that the {\@link yfiles.input.LabelTextValidatingEventArgs#label} may only a dummy instance, i.e. not bound to a live stripe instance.
 * </p>
 * @see yfiles.input.TableEditorInputMode#onValidateLabelText
 * @see yfiles.input.TableEditorInputMode#addValidateLabelTextListener
 * @param {function(!Object, !yfiles.input.LabelTextValidatingEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeValidateLabelTextListener = function(listener) {};

/**
 * Adds the given listener for the <code>DeletingSelection</code> event that occurs just before the {\@link yfiles.input.TableEditorInputMode#deleteSelection}
 * method starts its work and will be followed by any number of {\@link yfiles.input.TableEditorInputMode#addDeletedItemListener DeletedItem}
 * events and finalized by a {\@link yfiles.input.TableEditorInputMode#addDeletedSelectionListener DeletedSelection}
 * event.
 * @see yfiles.input.TableEditorInputMode#deleteSelection
 * @see yfiles.input.TableEditorInputMode#removeDeletingSelectionListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addDeletingSelectionListener = function(listener) {};

/**
 * Removes the given listener for the <code>DeletingSelection</code> event that occurs just before the {\@link yfiles.input.TableEditorInputMode#deleteSelection}
 * method starts its work and will be followed by any number of {\@link yfiles.input.TableEditorInputMode#addDeletedItemListener DeletedItem}
 * events and finalized by a {\@link yfiles.input.TableEditorInputMode#addDeletedSelectionListener DeletedSelection}
 * event.
 * @see yfiles.input.TableEditorInputMode#deleteSelection
 * @see yfiles.input.TableEditorInputMode#addDeletingSelectionListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeDeletingSelectionListener = function(listener) {};

/**
 * Adds the given listener for the <code>DeletedItem</code> event that occurs when an item has been deleted interactively by this mode.
 * @see yfiles.input.TableEditorInputMode#removeDeletedItemListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addDeletedItemListener = function(listener) {};

/**
 * Removes the given listener for the <code>DeletedItem</code> event that occurs when an item has been deleted interactively by this
 * mode.
 * @see yfiles.input.TableEditorInputMode#addDeletedItemListener
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeDeletedItemListener = function(listener) {};

/**
 * Adds the given listener for the <code>DeletedSelection</code> event that occurs just before the {\@link yfiles.input.TableEditorInputMode#deleteSelection}
 * method has deleted the selection after all selected items have been removed.
 * @see yfiles.input.TableEditorInputMode#deleteSelection
 * @see yfiles.input.TableEditorInputMode#removeDeletedSelectionListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.addDeletedSelectionListener = function(listener) {};

/**
 * Removes the given listener for the <code>DeletedSelection</code> event that occurs just before the {\@link yfiles.input.TableEditorInputMode#deleteSelection}
 * method has deleted the selection after all selected items have been removed.
 * @see yfiles.input.TableEditorInputMode#deleteSelection
 * @see yfiles.input.TableEditorInputMode#addDeletedSelectionListener
 * @param {function(!Object, !yfiles.input.SelectionEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.input.TableEditorInputMode.prototype.removeDeletedSelectionListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.input.TableReshapeHandler = function() {};
 /** @type {?} */
yfiles.input.TableReshapeHandler.prototype.coreHandler;
 /** @type {?} */
yfiles.input.TableReshapeHandler.prototype.tableNode;
 /** @type {?} */
yfiles.input.TableReshapeHandler.prototype.table;
 /** @type {?} */
yfiles.input.TableReshapeHandler.prototype.bounds;
 /** @type {!yfiles.lang.Class} */
yfiles.input.TableReshapeHandler.$class;

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} originalBounds
 * @return {void}
 */
yfiles.input.TableReshapeHandler.prototype.cancelReshape = function(context, originalBounds) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} originalBounds
 * @param {!yfiles.geometry.Rect} newBounds
 * @return {void}
 */
yfiles.input.TableReshapeHandler.prototype.handleReshape = function(context, originalBounds, newBounds) {};

/**
 *
 * @param {?} context
 * @return {void}
 */
yfiles.input.TableReshapeHandler.prototype.initializeReshape = function(context) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} originalBounds
 * @param {!yfiles.geometry.Rect} newBounds
 * @return {void}
 */
yfiles.input.TableReshapeHandler.prototype.reshapeFinished = function(context, originalBounds, newBounds) {};

/** @const */
yfiles.input.StripeReparentPolicy = {};
/** @const {number} */
yfiles.input.StripeReparentPolicy.ADD_CHILD;
/** @const {number} */
yfiles.input.StripeReparentPolicy.INSERT_BEFORE;
/** @const {number} */
yfiles.input.StripeReparentPolicy.INSERT_AFTER;
/** @const {number} */
yfiles.input.StripeReparentPolicy.INVALID;
/**
 * @record
 * @struct
 */
yfiles.input.IStripeHitTestHelper = function() {};

/**
 * Return a {\@link yfiles.input.IHitTestable} that should report hits on the far border region of the stripe.
 * <p>
 * The far border is the region that is used for the resize gesture in {\@link yfiles.input.ResizeStripeInputMode} to expand the
 * stripe to the bottom or the right. This is typically the bottom border for an {\@link yfiles.graph.IRow} instance and the right
 * border for an {\@link yfiles.graph.IColumn}.
 * </p>
 * @see yfiles.input.StripeSubregion
 * @see yfiles.input.StripeSubregionTypes#FAR_BORDER
 * @abstract
 * @return {?} a {\@link } that should report hits on the far border region of the stripe.
 */
yfiles.input.IStripeHitTestHelper.prototype.getFarBorderHitTestable = function() {};

/**
 * Return a {\@link yfiles.input.IHitTestable} that should report hits on the leading header region of the stripe.
 * <p>
 * The leading header is the region that is used by default for click selection and as start location for a stripe drag.
 * Typically, this is the area occupied by the left insets for an {\@link yfiles.graph.IRow} instance and by the top insets for an {\@link yfiles.graph.IColumn}
 * instance.
 * </p>
 * @see yfiles.input.StripeSubregion
 * @see yfiles.input.StripeSubregionTypes#HEADER
 * @abstract
 * @return {?} a {\@link } that should report hits on the header region of the stripe.
 */
yfiles.input.IStripeHitTestHelper.prototype.getLeadingHeaderHitTestable = function() {};

/**
 * Return a {\@link yfiles.input.IHitTestable} that should report hits on the near border region of the stripe.
 * <p>
 * The near border is the region that is used for the resize gesture in {\@link yfiles.input.ResizeStripeInputMode} to expand the
 * stripe to the top or the left. This is typically the upper border for an {\@link yfiles.graph.IRow} instance and the left border
 * for an {\@link yfiles.graph.IColumn}.
 * </p>
 * @see yfiles.input.StripeSubregion
 * @see yfiles.input.StripeSubregionTypes#NEAR_BORDER
 * @abstract
 * @return {?} a {\@link } that should report hits on the near border region of the stripe.
 */
yfiles.input.IStripeHitTestHelper.prototype.getNearBorderHitTestable = function() {};

/**
 * Return a {\@link yfiles.input.IHitTestable} that should report hits on the whole stripe.
 * @see yfiles.input.StripeSubregion
 * @see yfiles.input.StripeSubregionTypes#STRIPE
 * @abstract
 * @return {?} a {\@link } that should report hits on the whole stripe.
 */
yfiles.input.IStripeHitTestHelper.prototype.getStripeHitTestable = function() {};

/**
 * Return a {\@link yfiles.input.IHitTestable} that should report hits on the trailing header region of the stripe.
 * <p>
 * The trailing header is the region that is used by default for click selection and as start location for a stripe drag.
 * Typically, this is the area occupied by the right insets for an {\@link yfiles.graph.IRow} instance and by the bottom insets for
 * an {\@link yfiles.graph.IColumn} instance.
 * </p>
 * @see yfiles.input.StripeSubregion
 * @see yfiles.input.StripeSubregionTypes#HEADER
 * @abstract
 * @return {?} a {\@link } that should report hits on the header region of the stripe.
 */
yfiles.input.IStripeHitTestHelper.prototype.getTrailingHeaderHitTestable = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IStripeHitTestHelper;

/** @const */
yfiles.input.StripeSubregionTypes = {};
/** @const {number} */
yfiles.input.StripeSubregionTypes.NONE;
/** @const {number} */
yfiles.input.StripeSubregionTypes.STRIPE;
/** @const {number} */
yfiles.input.StripeSubregionTypes.LEADING_HEADER;
/** @const {number} */
yfiles.input.StripeSubregionTypes.TRAILING_HEADER;
/** @const {number} */
yfiles.input.StripeSubregionTypes.HEADER;
/** @const {number} */
yfiles.input.StripeSubregionTypes.NEAR_BORDER;
/** @const {number} */
yfiles.input.StripeSubregionTypes.FAR_BORDER;
/** @const {number} */
yfiles.input.StripeSubregionTypes.ALL;
/**
 * @record
 * @struct
 */
yfiles.input.StripeSubregion = function() {};
 /** @type {yfiles.input.StripeSubregionTypes} */
yfiles.input.StripeSubregion.prototype.subregionType;
 /** @type {?} */
yfiles.input.StripeSubregion.prototype.stripe;
 /** @type {?} */
yfiles.input.StripeSubregion.prototype.targetTableNode;
 /** @type {!yfiles.lang.Class} */
yfiles.input.StripeSubregion.$class;
/**
 * @record
 * @struct
 */
yfiles.input.DefaultStripeInputVisualizationHelper = function() {};
 /** @type {string} */
yfiles.input.DefaultStripeInputVisualizationHelper.RESIZE_STRIPE_TEMPLATE_KEY;
 /** @type {?} */
yfiles.input.DefaultStripeInputVisualizationHelper.prototype.resizeStripeTemplate;
 /** @type {string} */
yfiles.input.DefaultStripeInputVisualizationHelper.SELECTED_STRIPE_TEMPLATE_KEY;
 /** @type {?} */
yfiles.input.DefaultStripeInputVisualizationHelper.prototype.selectedStripeTemplate;
 /** @type {string} */
yfiles.input.DefaultStripeInputVisualizationHelper.DRAG_SOURCE_STRIPE_TEMPLATE_KEY;
 /** @type {?} */
yfiles.input.DefaultStripeInputVisualizationHelper.prototype.dragSourceStripeTemplate;
 /** @type {string} */
yfiles.input.DefaultStripeInputVisualizationHelper.DROP_TARGET_STRIPE_TEMPLATE_KEY;
 /** @type {?} */
yfiles.input.DefaultStripeInputVisualizationHelper.prototype.dropTargetStripeTemplate;
 /** @type {!yfiles.lang.Class} */
yfiles.input.DefaultStripeInputVisualizationHelper.$class;

/**
 * Provide a {\@link yfiles.view.IVisualTemplate} that is used to visualize <code>type</code>.
 * @protected
 * @param {?} context The input mode context. Allows you to access the {\@link } to retrieve the resources.
 * @param {yfiles.input.StripeVisualizationType} type The visualization type
 * @return {?} A {\@link } that is used to visualize <code>type</code>.
 */
yfiles.input.DefaultStripeInputVisualizationHelper.prototype.findTemplate = function(context, type) {};

/**
 * Return an {\@link yfiles.view.IVisualCreator} that is used to visualize the input operation specified by <code>type</code>.
 * <p>
 * This implementation uses {\@link yfiles.view.IVisualTemplate}s for the actual visualization.
 * </p>
 * @see yfiles.input.DefaultStripeInputVisualizationHelper#resizeStripeTemplate
 * @param {?} context The input mode context which provides further information.
 * @param {?} tableNode The node where the stripe's owner is currently bound to.
 * @param {yfiles.input.StripeVisualizationType} type The actual visualization type
 * @return {?} A {\@link } instance that renders a representation for the current operation.
 */
yfiles.input.DefaultStripeInputVisualizationHelper.prototype.getVisualCreator = function(context, tableNode, type) {};

/** @const */
yfiles.input.StripeVisualizationType = {};
/** @const {number} */
yfiles.input.StripeVisualizationType.SELECTION;
/** @const {number} */
yfiles.input.StripeVisualizationType.DRAG_SOURCE;
/** @const {number} */
yfiles.input.StripeVisualizationType.DROP_TARGET;
/** @const {number} */
yfiles.input.StripeVisualizationType.RESIZE;
/**
 * @record
 * @struct
 */
yfiles.input.IStripeInputVisualizationHelper = function() {};

/**
 * Return an {\@link yfiles.view.IVisualCreator} that is used to visualize the input operation specified by <code>type</code>.
 * @abstract
 * @param {?} context The input mode context which provides further information.
 * @param {?} tableNode The node where the stripe's owner is currently bound to.
 * @param {yfiles.input.StripeVisualizationType} type The actual visualization type
 * @return {?} A {\@link } instance that renders a representation for the current operation.
 */
yfiles.input.IStripeInputVisualizationHelper.prototype.getVisualCreator = function(context, tableNode, type) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.input.IStripeInputVisualizationHelper;
/**
 * @record
 * @struct
 */
yfiles.input.StripeHitTester = function() {};
 /** @type {yfiles.styles.TableRenderingOrder} */
yfiles.input.StripeHitTester.prototype.tableRenderingOrder;
 /** @type {!yfiles.lang.Class} */
yfiles.input.StripeHitTester.$class;

/**
 * Return a collection of hits at <code>location</code>.
 * <p>
 * This implementation returns the hits in the following order:
 * </p>
 * <ol>
 * <li>First all {\@link yfiles.graph.IRow}s or {\@link yfiles.graph.IColumn}s at the given location, in the order specified by the {\@link yfiles.input.StripeHitTester#tableRenderingOrder} property.</li>
 * <li>For each stripe type, the stripes are returned in bottom up order, i.e. children are returned before their parents.</li>
 * <li>
 * For each stripe, the subregions are returned in the order {\@link yfiles.input.StripeSubregionTypes#NEAR_BORDER},
 * {\@link yfiles.input.StripeSubregionTypes#FAR_BORDER}, {\@link yfiles.input.StripeSubregionTypes#LEADING_HEADER},
 * {\@link yfiles.input.StripeSubregionTypes#TRAILING_HEADER},{\@link yfiles.input.StripeSubregionTypes#STRIPE}, e.g. a header hit is always
 * returned before a hit on the whole stripe.
 * </li>
 * </ol>
 * @param {?} context The input mode context to use.
 * @param {!yfiles.geometry.Point} location The location in absolute coordinates.
 * @param {?} node The node where the table instance is currently bound to.
 * @return {?<!yfiles.input.StripeSubregion>} A collection of {\@link }s at <code>location</code>
 */
yfiles.input.StripeHitTester.prototype.enumerateHits = function(context, location, node) {};
/** @const */
yfiles.graph = {};
/**
 * @record
 * @struct
 */
yfiles.graph.IModelItem = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IModelItem;
/**
 * @record
 * @struct
 */
yfiles.graph.BendAnchoredPortLocationModel = function() {};
 /** @type {!yfiles.graph.BendAnchoredPortLocationModel} */
yfiles.graph.BendAnchoredPortLocationModel.INSTANCE;
 /** @type {?} */
yfiles.graph.BendAnchoredPortLocationModel.FIRST_BEND;
 /** @type {?} */
yfiles.graph.BendAnchoredPortLocationModel.LAST_BEND;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.BendAnchoredPortLocationModel.$class;

/**
 * Creates a parameter that indicates the location of the bend with index <code>bendIndex</code> starting from the source side.
 * @param {number} bendIndex The index of the bend counting from the source side.
 * @return {?} A parameter that anchors the port at a bend.
 */
yfiles.graph.BendAnchoredPortLocationModel.prototype.createFromSource = function(bendIndex) {};

/**
 * Creates a parameter that indicates the location of the bend with index <code>bendIndex</code> starting from the target side.
 * @param {number} bendIndex The index of the bend counting from the target side.
 * @return {?} A parameter that anchors the port at a bend.
 */
yfiles.graph.BendAnchoredPortLocationModel.prototype.createFromTarget = function(bendIndex) {};

/**
 *
 * @param {?} owner
 * @param {!yfiles.geometry.Point} location
 * @return {?}
 */
yfiles.graph.BendAnchoredPortLocationModel.prototype.createParameter = function(owner, location) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {?}
 */
yfiles.graph.BendAnchoredPortLocationModel.prototype.getContext = function(port, locationParameter) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {!yfiles.geometry.Point}
 */
yfiles.graph.BendAnchoredPortLocationModel.prototype.getLocation = function(port, locationParameter) {};

/**
 * This implementation has nothing in its lookup and will always yield <code>null</code>
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.BendAnchoredPortLocationModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.CompositeLabelModel = function() {};
 /** @type {?<?>} */
yfiles.graph.CompositeLabelModel.prototype.labelModels;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.CompositeLabelModel.$class;

/**
 * Creates a default parameter that can be used for this model.
 * <p>
 * If {\@link yfiles.graph.CompositeLabelModel#labelModels} is not empty, the default parameter for the first model in that list is returned. Otherwise, the default parameter
 * for {\@link yfiles.graph.FreeLabelModel#createDefaultParameter} is returned.
 * </p>
 * @return {?} a parameter for this model instance
 */
yfiles.graph.CompositeLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Tries to find a parameter that best matches the given layout for the provided label instance.
 * <p>
 * This implementation tests all parameters from all models in {\@link yfiles.graph.CompositeLabelModel#labelModels}.
 * </p>
 * @param {?} label The label to find a parameter for.
 * @param {?} model The model instance to use. This should be the instance this instance has been obtained from.
 * @param {?} layout The anticipated layout for the label.
 * @return {?} A non-<code>null</code> parameter that can be used for the label to approximate the provided layout.
 */
yfiles.graph.CompositeLabelModel.prototype.findBestParameter = function(label, model, layout) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.CompositeLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.CompositeLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 * Returns an enumerator over a set of possible {\@link yfiles.graph.ILabelModelParameter} instances that can be used for the given
 * label and model.
 * <p>
 * This implementation returns all parameters from all models in {\@link yfiles.graph.CompositeLabelModel#labelModels}
 * </p>
 * @param {?} label The label instance to use.
 * @param {?} model The model to provide parameters for.
 * @return {?<?>} A possibly empty enumerator over a set of label model parameters.
 */
yfiles.graph.CompositeLabelModel.prototype.getParameters = function(label, model) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.CompositeLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.SimpleBend = function() {};
 /** @type {?} */
yfiles.graph.SimpleBend.prototype.owner;
 /** @type {?} */
yfiles.graph.SimpleBend.prototype.location;
 /** @type {number} */
yfiles.graph.SimpleBend.prototype.x;
 /** @type {number} */
yfiles.graph.SimpleBend.prototype.y;
 /** @type {!Object} */
yfiles.graph.SimpleBend.prototype.tag;
 /** @type {?} */
yfiles.graph.SimpleBend.prototype.lookupImplementation;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.SimpleBend.$class;

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.SimpleBend.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.SimpleEdge = function() {};
 /** @type {?} */
yfiles.graph.SimpleEdge.prototype.style;
 /** @type {?<?>} */
yfiles.graph.SimpleEdge.prototype.bends;
 /** @type {?} */
yfiles.graph.SimpleEdge.prototype.sourcePort;
 /** @type {?} */
yfiles.graph.SimpleEdge.prototype.targetPort;
 /** @type {?<?>} */
yfiles.graph.SimpleEdge.prototype.ports;
 /** @type {?<?>} */
yfiles.graph.SimpleEdge.prototype.labels;
 /** @type {!Object} */
yfiles.graph.SimpleEdge.prototype.tag;
 /** @type {?} */
yfiles.graph.SimpleEdge.prototype.lookupImplementation;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.SimpleEdge.$class;

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.SimpleEdge.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.DefaultGraph = function() {};
 /** @type {?} */
yfiles.graph.DefaultGraph.DEFAULT_NODE_LOOKUP;
 /** @type {?} */
yfiles.graph.DefaultGraph.DEFAULT_EDGE_LOOKUP;
 /** @type {?} */
yfiles.graph.DefaultGraph.DEFAULT_LABEL_LOOKUP;
 /** @type {?} */
yfiles.graph.DefaultGraph.DEFAULT_PORT_LOOKUP;
 /** @type {?} */
yfiles.graph.DefaultGraph.DEFAULT_BEND_LOOKUP;
 /** @type {?} */
yfiles.graph.DefaultGraph.prototype.mapperRegistry;
 /** @type {boolean} */
yfiles.graph.DefaultGraph.prototype.undoEngineEnabled;
 /** @type {?} */
yfiles.graph.DefaultGraph.prototype.edgeDefaults;
 /** @type {?} */
yfiles.graph.DefaultGraph.prototype.nodeDefaults;
 /** @type {?<?>} */
yfiles.graph.DefaultGraph.prototype.nodes;
 /** @type {?<?>} */
yfiles.graph.DefaultGraph.prototype.labels;
 /** @type {?<?>} */
yfiles.graph.DefaultGraph.prototype.ports;
 /** @type {?<?>} */
yfiles.graph.DefaultGraph.prototype.edges;
 /** @type {?} */
yfiles.graph.DefaultGraph.prototype.groupNodeDefaults;
 /** @type {!Object} */
yfiles.graph.DefaultGraph.prototype.tag;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.DefaultGraph.$class;

/**
 *
 * @param {?} edge
 * @param {!yfiles.geometry.Point} location
 * @param {number=} index
 * @return {?}
 */
yfiles.graph.DefaultGraph.prototype.addBend = function(edge, location, index) {};

/**
 *
 *
 * @param {?|{owner: ?, text: string, layoutParameter: ?, style: ?, preferredSize: !yfiles.geometry.Size, tag: !Object}} owner_or_options
 * @param {string=} text
 * @param {?=} layoutParameter
 * @param {?=} style
 * @param {!yfiles.geometry.Size=} preferredSize
 * @param {!Object=} tag
 * @return {?}
 */
yfiles.graph.DefaultGraph.prototype.addLabel = function(owner_or_options, text, layoutParameter, style, preferredSize, tag) {};

/**
 * Adds the chain element to the lookup for this instance.
 * @param {?} lookup The lookup to decorate the current instance with.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addLookup = function(lookup) {};

/**
 * Add a port to the given port owner using the coordinates as the new initial position of the port anchor.
 * @throws {Stubs.Exceptions.NotSupportedError} If this instance cannot add a port to <code>owner</code>.
 * @throws {Stubs.Exceptions.ArgumentError} If <code>owner</code> is not in this graph.
 * @see yfiles.graph.DefaultGraph#addPortAddedListener
 * Add a port to the given port owner using the coordinates as the new initial position of the port anchor.
 * @throws {Stubs.Exceptions.NotSupportedError} If this instance cannot add a port to <code>owner</code>.
 * @throws {Stubs.Exceptions.ArgumentError} If <code>owner</code> is not in this graph.
 * @see yfiles.graph.DefaultGraph#addPortAddedListener
 * @param {?|{owner: ?, locationParameter: ?, style: ?, tag: !Object}} owner_or_options the owner to add the port instance to.
 * @param {?=} locationParameter
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?} the newly created port
 */
yfiles.graph.DefaultGraph.prototype.addPort = function(owner_or_options, locationParameter, style, tag) {};

/**
 * Determines whether this graph contains the specified item.
 * @param {?} item The item.
 * @return {boolean} <code>true</code> if this graph contains the specified item; otherwise, <code>false</code>.
 */
yfiles.graph.DefaultGraph.prototype.contains = function(item) {};

/**
 *
 *
 * Convenience method that creates and returns an edge that connects to the given node instances using the given style
 * instance.
 * <p>
 * The nodes must be part of this graph at the time of the invocation, and the implementation will choose the {\@link yfiles.graph.IPort}
 * instances to which the edge will be connected. The edge will be a part of this graph after the method returns. This will
 * trigger the corresponding events.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If <code>source</code> or <code>target</code> is not in this graph.
 * @see yfiles.graph.DefaultGraph#addEdgeCreatedListener
 * @see yfiles.graph.DefaultGraph#getNewSourcePort
 * @see yfiles.graph.DefaultGraph#getNewTargetPort
 * @see yfiles.graph.DefaultGraph#createEdge
 * Convenience method that creates and returns an edge that connects to the given node instances using the given style
 * instance.
 * <p>
 * The nodes must be part of this graph at the time of the invocation, and the implementation will choose the {\@link yfiles.graph.IPort}
 * instances to which the edge will be connected. The edge will be a part of this graph after the method returns. This will
 * trigger the corresponding events.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If <code>source</code> or <code>target</code> is not in this graph.
 * @see yfiles.graph.DefaultGraph#addEdgeCreatedListener
 * @see yfiles.graph.DefaultGraph#getNewSourcePort
 * @see yfiles.graph.DefaultGraph#getNewTargetPort
 * @see yfiles.graph.DefaultGraph#createEdge
 * @param {?|{sourcePort: ?, targetPort: ?, style: ?, tag: !Object}|{source: ?, target: ?, style: ?, tag: !Object}} sourcePort_or_options_or_source The source node the created edge will connect to. This implementation queries the {\@link #getNewSourcePort}
 * method to determine which port to use.
 * @param {?=} targetPort_or_target The target node the created edge will connect to. This implementation queries the {\@link #getNewSourcePort}
 * method to determine which port to use.
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?} the newly created edge instance
 */
yfiles.graph.DefaultGraph.prototype.createEdge = function(sourcePort_or_options_or_source, targetPort_or_target, style, tag) {};

/**
 *
 *
 * @param {?|{parent: ?, layout: !yfiles.geometry.Rect, style: ?, tag: !Object}=} parent_or_options
 * @param {!yfiles.geometry.Rect=} layout
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?}
 */
yfiles.graph.DefaultGraph.prototype.createGroupNode = function(parent_or_options, layout, style, tag) {};

/**
 *
 *
 *
 *
 * @param {!yfiles.geometry.Rect|{layout: !yfiles.geometry.Rect, style: ?, tag: !Object}|?|{parent: ?, layout: !yfiles.geometry.Rect, style: ?, tag: !Object}=} layout_or_options_or_parent
 * @param {?|!yfiles.geometry.Rect=} style_or_layout
 * @param {!Object|?=} tag_or_style
 * @param {!Object=} tag
 * @return {?}
 */
yfiles.graph.DefaultGraph.prototype.createNode = function(layout_or_options_or_parent, style_or_layout, tag_or_style, tag) {};

/**
 * Creates an {\@link yfiles.graph.UndoEngine} instance that automatically triggers {\@link yfiles.graph.DefaultGraph#invalidateDisplays}
 * upon each invocation of {\@link yfiles.graph.UndoEngine#undo} and {\@link yfiles.graph.UndoEngine#redo}
 * @protected
 * @return {!yfiles.graph.UndoEngine} An {\@link } instance.
 */
yfiles.graph.DefaultGraph.prototype.createUndoEngine = function() {};

/**
 * Creates the bend addition {\@link yfiles.graph.IUndoUnit undo unit} for the given bend.
 * @protected
 * @param {?} bend The bend that has been added.
 * @param {number} index The index at which the bend has been added.
 * @return {?} The unit that can be used to undo and redo the creation.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForBendAddition = function(bend, index) {};

/**
 * Creates the bend removal {\@link yfiles.graph.IUndoUnit undo unit} for the given bend.
 * @protected
 * @param {?} bend The bend that will be removed.
 * @return {?} The unit that can be used to undo and redo the removal.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForBendRemoval = function(bend) {};

/**
 * Creates the edge creation {\@link yfiles.graph.IUndoUnit undo unit} for the given edge.
 * @protected
 * @param {?} edge The edge that has been created.
 * @return {?} The unit that can be used to undo and redo the creation.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForEdgeCreation = function(edge) {};

/**
 * Creates the edge reconnection {\@link yfiles.graph.IUndoUnit undo unit} for the given edge.
 * @protected
 * @param {?} edge The edge that has been reconnected to other ports.
 * @param {?} oldSource The old source port the edge connected to before the change.
 * @param {?} oldTarget The old target port the edge connected to before the change.
 * @return {?} The unit that can be used to undo and redo the port change operation.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForEdgeReconnection = function(edge, oldSource, oldTarget) {};

/**
 * Creates the edge removal {\@link yfiles.graph.IUndoUnit undo unit} for the given edge.
 * @protected
 * @param {?} edge The edge that will be removed.
 * @return {?} The unit that can be used to undo and redo the removal.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForEdgeRemoval = function(edge) {};

/**
 * Creates the {\@link yfiles.graph.IUndoUnit undo unit} for changing whether the given node is a group node.
 * @protected
 * @param {?} node The node whose group node status has been changed.
 * @param {boolean} isGroupNode The new group node status.
 * @return {?} The unit that can be used to undo and redo the group node status change.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForIsGroupNodeChange = function(node, isGroupNode) {};

/**
 * Creates the label addition {\@link yfiles.graph.IUndoUnit undo unit} for the given label.
 * @protected
 * @param {?} label The label that has been added.
 * @return {?} The unit that can be used to undo and redo the creation.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForLabelAddition = function(label) {};

/**
 * Creates the label removal {\@link yfiles.graph.IUndoUnit undo unit} for the given label.
 * @protected
 * @param {?} label The label that will be removed.
 * @return {?} The unit that can be used to undo and redo the removal.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForLabelRemoval = function(label) {};

/**
 * Creates the node creation {\@link yfiles.graph.IUndoUnit undo unit} for the given node.
 * @protected
 * @param {?} node The node that has been created.
 * @param {?} parent
 * @param {boolean} isGroupNode
 * @return {?} The unit that can be used to undo and redo the creation.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForNodeCreation = function(node, parent, isGroupNode) {};

/**
 * Creates the node removal {\@link yfiles.graph.IUndoUnit undo unit} for the given node.
 * @protected
 * @param {?} node The node that will be removed.
 * @return {?} The unit that can be used to undo and redo the removal.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForNodeRemoval = function(node) {};

/**
 * Creates the parent change {\@link yfiles.graph.IUndoUnit undo unit} for the given node.
 * @protected
 * @param {?} node The node whose parent has been changed.
 * @param {?} oldParent
 * @param {?} newParent The node which is the new parent.
 * @return {?} The unit that can be used to undo and redo the parent change.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForParentChange = function(node, oldParent, newParent) {};

/**
 * Creates the port addition {\@link yfiles.graph.IUndoUnit undo unit} for the given port.
 * @protected
 * @param {?} port The port that has been added.
 * @return {?} The unit that can be used to undo and redo the creation.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForPortAddition = function(port) {};

/**
 * Creates the port removal {\@link yfiles.graph.IUndoUnit undo unit} for the given port.
 * @protected
 * @param {?} port The port that will be removed.
 * @return {?} The unit that can be used to undo and redo the removal.
 */
yfiles.graph.DefaultGraph.prototype.createUndoUnitForPortRemoval = function(port) {};

/**
 *
 *
 * @param {?} owner_or_port
 * @param {yfiles.graph.AdjacencyTypes=} type
 * @return {?<?>}
 */
yfiles.graph.DefaultGraph.prototype.edgesAt = function(owner_or_port, type) {};

/**
 *
 * @param {?} node
 * @return {?<?>}
 */
yfiles.graph.DefaultGraph.prototype.getChildren = function(node) {};

/**
 * Returns the lookup implementation that is used for {\@link yfiles.graph.DefaultGraph#lookup} calls.
 * @see yfiles.graph.DefaultGraph#setLookupImplementation
 * @return {?} The replacing lookup instance or <code>null</code> if the internal lookup mechanism is used.
 */
yfiles.graph.DefaultGraph.prototype.getLookup = function() {};

/**
 * Determines a {\@link yfiles.graph.IPort} instance to use for the creation of a new edge that starts at the given
 * {\@link yfiles.graph.IPortOwner}.
 * <p>
 * This implementation will {\@link yfiles.graph.DefaultGraph#addPort add a new center anchored port} to the node.
 * </p>
 * @see yfiles.graph.DefaultGraph#createEdge
 * @protected
 * @param {?} source The source node to find a port for.
 * @return {?} The port to use for a newly created edge.
 */
yfiles.graph.DefaultGraph.prototype.getNewSourcePort = function(source) {};

/**
 * Determines a {\@link yfiles.graph.IPort} instance to use for the creation of a new edge that ends at the given
 * {\@link yfiles.graph.IPortOwner}.
 * <p>
 * This implementation will {\@link yfiles.graph.DefaultGraph#addPort add a new center anchored port} to the node.
 * </p>
 * @see yfiles.graph.DefaultGraph#createEdge
 * @protected
 * @param {?} targetOwner The target node to find a port for.
 * @return {?} The port to use for a newly created edge.
 */
yfiles.graph.DefaultGraph.prototype.getNewTargetPort = function(targetOwner) {};

/**
 *
 * @param {?} node
 * @return {?}
 */
yfiles.graph.DefaultGraph.prototype.getParent = function(node) {};

/**
 * The last element in the lookup chain is implemented by this method.
 * @protected
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.DefaultGraph.prototype.innerLookup = function(type) {};

/**
 * Triggers the {\@link yfiles.graph.DefaultGraph#addDisplaysInvalidatedListener DisplaysInvalidated} event.
 * <p>
 * Clients can call this method to force an invalidation of the displays that show this graph instance. This implementation
 * delegates to {\@link yfiles.graph.DefaultGraph#onInvalidateDisplays}.
 * </p>
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.invalidateDisplays = function() {};

/**
 *
 * @param {?} node
 * @return {boolean}
 */
yfiles.graph.DefaultGraph.prototype.isGroupNode = function(node) {};

/**
 * Returns an instance that provides another aspect of this instance of the given type or <code>null</code>.
 * <p>
 * Typically, this method will be called in order to obtain a different view or aspect of the current instance. This is
 * quite similar to casting or using a super type or interface of this instance, but is not limited to inheritance or
 * compile time constraints. This method is not required to return non-<code>null</code> implementations for the types, nor does it have
 * to return the same instance any time. Also it depends on the type and context whether the instance returned stays up to
 * date or needs to be re-obtained for subsequent use. This implementation uses the {\@link yfiles.graph.DefaultGraph#setLookupImplementation set lookup implementation} if it has
 * been set or an internal {\@link yfiles.graph.LookupChain lookup chain}, that can be customized using the {\@link yfiles.graph.DefaultGraph#addLookup} and {\@link yfiles.graph.DefaultGraph#removeLookup}
 * methods.
 * </p>
 * @param {!yfiles.lang.Class} type the type for which an instance shall be returned
 * @return {!Object} An instance that is assignable to type or <code>null</code>
 */
yfiles.graph.DefaultGraph.prototype.lookup = function(type) {};

/**
 * Callback that is invoked before a bend is added to this graph's structure.
 * @protected
 * @param {?} edge The edge the bend will be added to.
 * @param {?} bend The bend that will be added to the edge.
 * @param {number} index The index where the bend will be added to the edge.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onAddingBend = function(edge, bend, index) {};

/**
 * Callback method that will be called just before an edge label is added to an edge.
 * @protected
 * @param {?} edge
 * @param {?} label
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onAddingEdgeLabel = function(edge, label) {};

/**
 * Callback method that will be called just before a node label is added to a node.
 * @protected
 * @param {?} node
 * @param {?} label
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onAddingNodeLabel = function(node, label) {};

/**
 * Called when a port is going to be added to a node.
 * @protected
 * @param {?} owner The node.
 * @param {?} port The port to be added.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onAddingPort = function(owner, port) {};

/**
 * Callback that after a bend has been added to this graph's structure.
 * <p>
 * When overriding this method it is mandatory to call the base implementation.
 * </p>
 * @protected
 * @param {?} bend The bend that has been added to the edge.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onBendAdded = function(bend) {};

/**
 * Callback that is invoked after a bend location has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addBendLocationChangedListener BendLocationChanged} event.
 * </p>
 * @protected
 * @param {?} bend The bend whose location has changed.
 * @param {!yfiles.geometry.Point} oldLocation The bend location before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onBendLocationChanged = function(bend, oldLocation) {};

/**
 * Callback method that is invoked just after a bend has been removed from its edge.
 * <p>
 * When overriding this method it is mandatory to call the base implementation.
 * </p>
 * @protected
 * @param {?} owner The old edge.
 * @param {?} bend The bend.
 * @param {number} index The former index of the bend in the {\@link #bends} list.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onBendRemoved = function(owner, bend, index) {};

/**
 * Callback that is invoked after a bend tag has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addBendTagChangedListener BendTagChanged} event.
 * </p>
 * @protected
 * @param {?} bend The bend whose tag has changed.
 * @param {!Object} oldTag The bend tag before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onBendTagChanged = function(bend, oldTag) {};

/**
 * Callback that is invoked before the ports of an edge are being changed.
 * @protected
 * @param {?} edge An edge whose the ports are to be changed.
 * @param {?} newSource The new source port
 * @param {?} newTarget The new target port
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingEdgePorts = function(edge, newSource, newTarget) {};

/**
 * Callback that is invoked before an edge style is being changed.
 * @protected
 * @param {?} edge An edge whose the style is going to be changed.
 * @param {?} newStyle The new edge style.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingEdgeStyle = function(edge, newStyle) {};

/**
 * Callback that is invoked before the graph's tag is being changed.
 * @protected
 * @param {!Object} newTag The new port tag
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingGraphTag = function(newTag) {};

/**
 * Callback that is invoked before the {\@link yfiles.graph.ILabel#layoutParameter} of a label is being changed.
 * @protected
 * @param {?} label A label whose {\@link #layoutParameter} is to be changed.
 * @param {?} newLayoutParameter The new label model parameter
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingLabelLayoutParameter = function(label, newLayoutParameter) {};

/**
 * Callback that is invoked before the preferred size of a label is being changed.
 * @protected
 * @param {?} label A label whose preferred size is going to be changed.
 * @param {!yfiles.geometry.Size} newSize The new preferred size
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingLabelPreferredSize = function(label, newSize) {};

/**
 * Callback that is invoked before a label style is being changed.
 * @protected
 * @param {?} label A label whose the style is going to be changed.
 * @param {?} newStyle The new label style.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingLabelStyle = function(label, newStyle) {};

/**
 * Callback that is invoked before the text of a label is being changed.
 * @protected
 * @param {?} label A label whose text is going to be changed.
 * @param {string} newText The new label text
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingLabelText = function(label, newText) {};

/**
 * Callback that is invoked before a node style is being changed.
 * @protected
 * @param {?} node A node whose the style is going to be changed.
 * @param {?} newStyle The new node style.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingNodeStyle = function(node, newStyle) {};

/**
 * Callback that is invoked before the {\@link yfiles.graph.IPort#locationParameter} of a port is being changed.
 * @protected
 * @param {?} port A port whose {\@link #locationParameter} is to be changed.
 * @param {?} newLocationParameter The new location model parameter
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingPortLocationModelParameter = function(port, newLocationParameter) {};

/**
 * Callback that is invoked before a port style is being changed.
 * @protected
 * @param {?} port A port whose the style is going to be changed.
 * @param {?} newStyle The new port style.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onChangingPortStyle = function(port, newStyle) {};

/**
 * Callback that is invoked before the edge is added to this graph's structure.
 * @protected
 * @param {?} edge An edge that is not yet contained in this graph.
 * @param {?} sourcePort The source port this edge will connect to.
 * @param {?} targetPort The target port this edge will connect to.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onCreatingEdge = function(edge, sourcePort, targetPort) {};

/**
 * Callback that is invoked before the node is added to this graph's structure.
 * @protected
 * @param {?} node A node that is not yet contained in this graph.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onCreatingNode = function(node) {};

/**
 * Callback that triggers the {\@link yfiles.graph.DefaultGraph#addEdgeCreatedListener EdgeCreated} event.
 * @protected
 * @param {?} edge The edge that has been created.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onEdgeCreated = function(edge) {};

/**
 * Called after a label has been added to an edge.
 * <p>
 * This method triggers the {\@link yfiles.graph.DefaultGraph#addLabelAddedListener LabelAdded} event.
 * </p>
 * <p>
 * When overriding this method it is mandatory to call the base implementation.
 * </p>
 * @protected
 * @param {?} label The label that has just been added.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onEdgeLabelAdded = function(label) {};

/**
 * Called after a label has been removed from its edge.
 * <p>
 * When overriding this method it is mandatory to call the base implementation.
 * </p>
 * @protected
 * @param {?} owner The previous owner of the label.
 * @param {?} label The label that has just been removed.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onEdgeLabelRemoved = function(owner, label) {};

/**
 * Callback that is invoked after the ports of an edge has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addEdgePortsChangedListener EdgePortsChanged} event.
 * </p>
 * @protected
 * @param {?} edge The edge whose ports have changed.
 * @param {?} oldSource The source port that the edge had been connected to before the change.
 * @param {?} oldTarget The target port that the edge had been connected to before the change.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onEdgePortsChanged = function(edge, oldSource, oldTarget) {};

/**
 * Callback that triggers the {\@link yfiles.graph.DefaultGraph#addEdgeRemovedListener EdgeRemoved} event.
 * @protected
 * @param {?} edge The edge that got removed
 * @param {?} oldSource The source port that the edge had been connected to.
 * @param {?} oldTarget The target port that the edge had been connected to.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onEdgeRemoved = function(edge, oldSource, oldTarget) {};

/**
 * Callback that is invoked after the style of an edge has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addEdgeStyleChangedListener EdgeStyleChanged} event.
 * </p>
 * @protected
 * @param {?} edge The edge whose style that has changed.
 * @param {?} oldStyle The edge style before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onEdgeStyleChanged = function(edge, oldStyle) {};

/**
 * Callback that is invoked after the tag of an edge has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addEdgeTagChangedListener EdgeTagChanged} event.
 * </p>
 * @protected
 * @param {?} edge The edge whose tag has changed.
 * @param {!Object} oldTag The edge tag before the change.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onEdgeTagChanged = function(edge, oldTag) {};

/**
 * Callback that triggers the {\@link yfiles.graph.DefaultGraph#addGraphTagChangedListener GraphTagChanged} event.
 * @protected
 * @param {!Object} oldTag The graph tag before the change.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onGraphTagChanged = function(oldTag) {};

/**
 * Triggers the {\@link yfiles.graph.DefaultGraph#addDisplaysInvalidatedListener DisplaysInvalidated} event.
 * @protected
 * @param {!yfiles.lang.EventArgs} evt The event arguments.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onInvalidateDisplays = function(evt) {};

/**
 * Callback that is invoked after a label model parameter has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addLabelLayoutParameterChangedListener LabelLayoutParameterChanged} event.
 * </p>
 * @protected
 * @param {?} label The label whose model parameter has changed.
 * @param {?} oldLayoutParamater The label model parameter before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onLabelLayoutParameterChanged = function(label, oldLayoutParamater) {};

/**
 * Callback that is invoked after the preferred size of a label has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addLabelPreferredSizeChangedListener LabelPreferredSizeChanged} event.
 * </p>
 * @param {?} label The label whose preferred size has changed.
 * @param {!yfiles.geometry.Size} oldSize The preferred size of the label before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onLabelPreferredSizeChanged = function(label, oldSize) {};

/**
 * Callback that is invoked after a label style has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addLabelStyleChangedListener LabelStyleChanged} event.
 * </p>
 * @protected
 * @param {?} label The label whose style has changed.
 * @param {?} oldStyle The label style before the change.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onLabelStyleChanged = function(label, oldStyle) {};

/**
 * Callback that is invoked after a label tag has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addLabelTagChangedListener LabelTagChanged} event.
 * </p>
 * @param {?} label The label whose tag has changed.
 * @param {!Object} oldTag The label tag before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onLabelTagChanged = function(label, oldTag) {};

/**
 * Callback that is invoked after a label text has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addLabelTextChangedListener LabelTextChanged} event.
 * </p>
 * @param {?} label The label whose text has changed.
 * @param {string} oldText The label text before the change.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onLabelTextChanged = function(label, oldText) {};

/**
 * Callback that triggers the {\@link yfiles.graph.DefaultGraph#addNodeCreatedListener NodeCreated} event.
 * @protected
 * @param {?} node The node that has been created.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onNodeCreated = function(node) {};

/**
 * Called after a label has been added to a node.
 * <p>
 * This method triggers the {\@link yfiles.graph.DefaultGraph#addLabelAddedListener LabelAdded} event.
 * </p>
 * <p>
 * When overriding this method it is mandatory to call the base implementation.
 * </p>
 * @protected
 * @param {?} label The label that has just been added.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onNodeLabelAdded = function(label) {};

/**
 * Called after a label has been removed from its node.
 * <p>
 * When overriding this method it is mandatory to call the base implementation.
 * </p>
 * @protected
 * @param {?} owner The old owner of the label.
 * @param {?} label The label that has just been removed.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onNodeLabelRemoved = function(owner, label) {};

/**
 * Callback that is invoked after a node layout has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addNodeLayoutChangedListener NodeLayoutChanged} event.
 * </p>
 * @protected
 * @param {?} node The node whose layout has changed.
 * @param {!yfiles.geometry.Rect} oldLayout The node layout before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onNodeLayoutChanged = function(node, oldLayout) {};

/**
 * Callback that triggers the {\@link yfiles.graph.DefaultGraph#addNodeRemovedListener NodeRemoved} event.
 * @protected
 * @param {?} node The node that got removed
 * @param {?} oldParent
 * @param {boolean} oldIsGroupNode
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onNodeRemoved = function(node, oldParent, oldIsGroupNode) {};

/**
 * Callback that is invoked after a node style has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addNodeStyleChangedListener NodeStyleChanged} event.
 * </p>
 * @protected
 * @param {?} node The node whose style has changed.
 * @param {?} oldStyle The node style before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onNodeStyleChanged = function(node, oldStyle) {};

/**
 * Callback that is invoked after a node tag has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addNodeTagChangedListener NodeTagChanged} event.
 * </p>
 * @protected
 * @param {?} node The node whose tag has changed.
 * @param {!Object} oldTag The node tag before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onNodeTagChanged = function(node, oldTag) {};

/**
 * Called when a port has been added to a node.
 * <p>
 * When overriding this method it is mandatory to call the base implementation.
 * </p>
 * @protected
 * @param {?} port The port that has just been added to its owner.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onPortAdded = function(port) {};

/**
 * Callback that is invoked after a port location model parameter has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addPortLocationParameterChangedListener PortLocationParameterChanged}
 * event.
 * </p>
 * @param {?} port The port whose location model parameter has changed.
 * @param {?} oldLocationParameter The port location model parameter before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onPortLocationParameterChanged = function(port, oldLocationParameter) {};

/**
 * Callback method that is called just after a port has been removed from its owner.
 * <p>
 * When overriding this method it is mandatory to call the base implementation.
 * </p>
 * @protected
 * @param {?} oldOwner The previous owner of the port.
 * @param {?} port The port that has been removed.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onPortRemoved = function(oldOwner, port) {};

/**
 * Callback that is invoked after a port style has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addPortStyleChangedListener PortStyleChanged} event.
 * </p>
 * @protected
 * @param {?} port The port whose style has changed.
 * @param {?} oldStyle The port style before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onPortStyleChanged = function(port, oldStyle) {};

/**
 * Callback that is invoked after a port tag has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.DefaultGraph#addPortTagChangedListener PortTagChanged} event.
 * </p>
 * @protected
 * @param {?} port The port whose tag has changed.
 * @param {!Object} oldTag The port tag before the change
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onPortTagChanged = function(port, oldTag) {};

/**
 * Callback method that is invoked just before a bend is removed.
 * @protected
 * @param {?} bend The bend that will be removed.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onRemovingBend = function(bend) {};

/**
 * Callback that will be invoked before the node will be removed.
 * @protected
 * @param {?} edge That edge that is going to be removed.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onRemovingEdge = function(edge) {};

/**
 * Callback method that will be called just before an edge label is removed from its edge.
 * @protected
 * @param {?} label
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onRemovingEdgeLabel = function(label) {};

/**
 * Callback that will be invoked before the node will be removed.
 * @protected
 * @param {?} node That node that is going to be removed.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onRemovingNode = function(node) {};

/**
 * Callback method that will be called just before a node label is removed from its node.
 * @protected
 * @param {?} label
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onRemovingNodeLabel = function(label) {};

/**
 * Callback method that is called just before a port will be removed.
 * @protected
 * @param {?} port The port that is about to be removed.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.onRemovingPort = function(port) {};

/**
 *
 * @param {?} item
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.remove = function(item) {};

/**
 * Removes a previously added lookup chain element from the lookup of <code>this</code>.
 * @param {?} lookup The element to remove.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeLookup = function(lookup) {};

/**
 * Modifies the location of the given bend.
 * <p>
 * This implementation will also trigger an {\@link yfiles.graph.DefaultGraph#invalidateDisplays} call.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If <code>bend</code> is not in this graph.
 * @see yfiles.graph.DefaultGraph#addBend
 * @param {?} bend the bend whose location is to be modified
 * @param {!yfiles.geometry.Point} location the new coordinates of the bend
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setBendLocation = function(bend, location) {};

/**
 * Sets the ports of the given edge to the new values.
 * <p>
 * This will trigger an {\@link yfiles.graph.DefaultGraph#addEdgePortsChangedListener EdgePortsChanged} event if source or
 * target ports differ from the current ones. Both ports and the edge must belong to the current graph instance. If {\@link yfiles.graph.IPortDefaults#autoCleanup} is
 * enabled, this method will remove unoccupied ports after they have been changed.
 * </p>
 * @param {?} edge The edge to change the ports.
 * @param {?} sourcePort The new source port instance.
 * @param {?} targetPort The new target port instance.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setEdgePorts = function(edge, sourcePort, targetPort) {};

/**
 *
 * @param {?} node
 * @param {boolean} isGroupNode
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setIsGroupNode = function(node, isGroupNode) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setLabelLayoutParameter = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {!yfiles.geometry.Size} size
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setLabelPreferredSize = function(label, size) {};

/**
 * Sets the label text of the given label.
 * <p>
 * This implementation will {\@link yfiles.graph.IGraph#adjustLabelPreferredSize adjust the preferred size} for the label if {\@link yfiles.graph.ILabelDefaults#autoAdjustPreferredSize} is enabled.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If <code>label</code> is not in this graph.
 * @throws {Stubs.Exceptions.ArgumentError} If <code>text</code> is <code>null</code>.
 * @see yfiles.graph.ILabel#text
 * @param {?} label the label to modify
 * @param {string} text the new text of the label
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setLabelText = function(label, text) {};

/**
 * Sets the lookup implementation that will be used for {\@link yfiles.graph.DefaultGraph#lookup} calls.
 * <p>
 * A value of <code>null</code> will revert to the default behavior.
 * </p>
 * @see yfiles.graph.DefaultGraph#addLookup
 * @see yfiles.graph.DefaultGraph#getLookup
 * @protected
 * @param {?} lookup The lookup instance to delegate lookup calls to.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setLookupImplementation = function(lookup) {};

/**
 * Sets the layout of the given node to the new values.
 * <p>
 * This will trigger a call to {\@link yfiles.graph.DefaultGraph#invalidateDisplays}.
 * </p>
 * @see yfiles.graph.INode#layout
 * @param {?} node a live node that belongs to this graph
 * @param {!yfiles.geometry.Rect} layout the new absolute layout in world coordinates of the node
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setNodeLayout = function(node, layout) {};

/**
 *
 * @param {?} node
 * @param {?} parent
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setParent = function(node, parent) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setPortLocationParameter = function(port, locationParameter) {};

/**
 *
 *
 * Assigns the given style instance by reference to the label.
 * <p>
 * Style instances can be shared.
 * </p>
 * <p>
 * This implementation will {\@link yfiles.graph.IGraph#adjustLabelPreferredSize adjust the preferred size} for the label if {\@link yfiles.graph.ILabelDefaults#autoAdjustPreferredSize} is enabled.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If <code>label</code> is not in this graph.
 * @throws {Stubs.Exceptions.ArgumentError} If <code>style</code> is <code>null</code>.
 * @see yfiles.graph.ILabel#style
 * @see yfiles.graph.DefaultGraph#onChangingLabelStyle
 * @see yfiles.graph.DefaultGraph#addLabelStyleChangedListener
 * Assigns the given style instance by reference to the node.
 * <p>
 * Style instances can be shared.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If <code>node</code> is not in this graph.
 * @throws {Stubs.Exceptions.ArgumentError} If <code>style</code> is <code>null</code>.
 * @see yfiles.graph.INode#style
 * @see yfiles.graph.DefaultGraph#onChangingNodeStyle
 * @see yfiles.graph.DefaultGraph#addNodeStyleChangedListener
 * @param {?} port_or_edge_or_label_or_node The label that will be assigned the new style / The node that will be assigned the new style
 * @param {?} style The style instance that will be assigned to the label. / The style instance that will be assigned to the node.
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.setStyle = function(port_or_edge_or_label_or_node, style) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addGraphTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeGraphTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addNodeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeNodeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addNodeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeNodeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addNodeStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeNodeStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, ?, !yfiles.geometry.Rect): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addNodeLayoutChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, ?, !yfiles.geometry.Rect): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeNodeLayoutChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addNodeTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeNodeTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addEdgeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeEdgeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addEdgeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeEdgeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addEdgeStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeEdgeStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addEdgePortsChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeEdgePortsChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addEdgeTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeEdgeTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addBendAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeBendAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.BendEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addBendRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.BendEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeBendRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, ?, !yfiles.geometry.Point): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addBendLocationChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, ?, !yfiles.geometry.Point): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeBendLocationChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addBendTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeBendTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addLabelAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeLabelAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addLabelRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeLabelRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addLabelStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeLabelStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !yfiles.geometry.Size>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addLabelPreferredSizeChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !yfiles.geometry.Size>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeLabelPreferredSizeChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, string>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addLabelTextChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, string>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeLabelTextChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addLabelLayoutParameterChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeLabelLayoutParameterChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addLabelTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeLabelTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addPortAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removePortAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.PortEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addPortRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.PortEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removePortRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addPortStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removePortStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addPortLocationParameterChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removePortLocationParameterChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addPortTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removePortTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addDisplaysInvalidatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeDisplaysInvalidatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addParentChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeParentChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.addIsGroupNodeChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.DefaultGraph.prototype.removeIsGroupNodeChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graph.SimpleLabel = function() {};
 /** @type {?} */
yfiles.graph.SimpleLabel.prototype.layoutParameter;
 /** @type {string} */
yfiles.graph.SimpleLabel.prototype.text;
 /** @type {?} */
yfiles.graph.SimpleLabel.prototype.style;
 /** @type {?} */
yfiles.graph.SimpleLabel.prototype.owner;
 /** @type {!yfiles.geometry.Size} */
yfiles.graph.SimpleLabel.prototype.preferredSize;
 /** @type {!Object} */
yfiles.graph.SimpleLabel.prototype.tag;
 /** @type {?} */
yfiles.graph.SimpleLabel.prototype.lookupImplementation;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.SimpleLabel.$class;

/**
 * Gets the {\@link yfiles.styles.ILabelStyleRenderer#getPreferredSize} from the labels style and sets the {\@link yfiles.graph.SimpleLabel#preferredSize} to that value.
 * @return {void}
 */
yfiles.graph.SimpleLabel.prototype.adoptPreferredSizeFromStyle = function() {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.SimpleLabel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.SimpleNode = function() {};
 /** @type {?} */
yfiles.graph.SimpleNode.prototype.layout;
 /** @type {?} */
yfiles.graph.SimpleNode.prototype.style;
 /** @type {?<?>} */
yfiles.graph.SimpleNode.prototype.ports;
 /** @type {?<?>} */
yfiles.graph.SimpleNode.prototype.labels;
 /** @type {!Object} */
yfiles.graph.SimpleNode.prototype.tag;
 /** @type {?} */
yfiles.graph.SimpleNode.prototype.lookupImplementation;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.SimpleNode.$class;

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.SimpleNode.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.SimplePort = function() {};
 /** @type {?} */
yfiles.graph.SimplePort.prototype.style;
 /** @type {?} */
yfiles.graph.SimplePort.prototype.locationParameter;
 /** @type {?} */
yfiles.graph.SimplePort.prototype.owner;
 /** @type {!Object} */
yfiles.graph.SimplePort.prototype.tag;
 /** @type {?} */
yfiles.graph.SimplePort.prototype.lookupImplementation;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.SimplePort.$class;

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.SimplePort.prototype.lookup = function(type) {};

/**
 * Sets the location of this port.
 * @param {!yfiles.geometry.Point} location
 * @return {void}
 */
yfiles.graph.SimplePort.prototype.setLocation = function(location) {};
/**
 * @record
 * @struct
 */
yfiles.graph.DescriptorWrapperLabelModel = function() {};
 /** @type {?} */
yfiles.graph.DescriptorWrapperLabelModel.prototype.descriptor;
 /** @type {?} */
yfiles.graph.DescriptorWrapperLabelModel.prototype.innerModel;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.DescriptorWrapperLabelModel.$class;

/**
 * Creates a default parameter that can be used for this model.
 * @return {?} The default parameter from {\@link #innerModel}
 */
yfiles.graph.DescriptorWrapperLabelModel.prototype.createDefaultParameter = function() {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.DescriptorWrapperLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.DescriptorWrapperLabelModel.prototype.getDescriptor = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.DescriptorWrapperLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} model
 * @return {?<?>}
 */
yfiles.graph.DescriptorWrapperLabelModel.prototype.getParameters = function(label, model) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.DescriptorWrapperLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.FoldingEdgeStateId = function() {};
 /** @type {?} */
yfiles.graph.FoldingEdgeStateId.prototype.masterEdge;
 /** @type {?} */
yfiles.graph.FoldingEdgeStateId.prototype.currentMasterSource;
 /** @type {?} */
yfiles.graph.FoldingEdgeStateId.prototype.currentMasterTarget;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeStateId.prototype.sourceIsCollapsed;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeStateId.prototype.targetIsCollapsed;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FoldingEdgeStateId.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.EdgePathLabelModel = function() {};
 /** @type {yfiles.graph.EdgeSides} */
yfiles.graph.EdgePathLabelModel.prototype.sideOfEdge;
 /** @type {number} */
yfiles.graph.EdgePathLabelModel.prototype.distance;
 /** @type {number} */
yfiles.graph.EdgePathLabelModel.prototype.offset;
 /** @type {boolean} */
yfiles.graph.EdgePathLabelModel.prototype.autoRotationEnabled;
 /** @type {number} */
yfiles.graph.EdgePathLabelModel.prototype.angle;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.EdgePathLabelModel.$class;

/**
 * A model parameter that encodes the default position of this model's allowed edge label positions.
 * <p>
 * Returns a model parameter that encodes the default position of this model's allowed edge label positions.
 * </p>
 * @return {?}
 */
yfiles.graph.EdgePathLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates a parameter at the provided edge path ratio.
 * @param {number} edgePathRatio The ratio at which to place the label at the edge path. A ratio of 0.0 will place the label at the source side of the
 * edge path, a ratio of 1.0 at the target side.
 * @param {yfiles.graph.EdgeSides} sideOfEdge The side of the edge the label is placed on. Note that only single enum values but no combined ones are allowed.
 * @return {?} A label parameter at the provided edge path ratio for this model instance.
 */
yfiles.graph.EdgePathLabelModel.prototype.createRatioParameter = function(edgePathRatio, sideOfEdge) {};

/**
 * Returns an empty context.
 * @param {?} label The label to use in the context.
 * @param {?} layoutParameter The parameter to use for the label in the context.
 * @return {?} An empty context.
 */
yfiles.graph.EdgePathLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.EdgePathLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.EdgeSegmentLabelModel = function() {};
 /** @type {yfiles.graph.EdgeSides} */
yfiles.graph.EdgeSegmentLabelModel.prototype.sideOfEdge;
 /** @type {number} */
yfiles.graph.EdgeSegmentLabelModel.prototype.distance;
 /** @type {number} */
yfiles.graph.EdgeSegmentLabelModel.prototype.offset;
 /** @type {boolean} */
yfiles.graph.EdgeSegmentLabelModel.prototype.autoRotationEnabled;
 /** @type {number} */
yfiles.graph.EdgeSegmentLabelModel.prototype.angle;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.EdgeSegmentLabelModel.$class;

/**
 * A model parameter that encodes the default position of this model's allowed edge label positions.
 * <p>
 * Returns a model parameter that encodes the default position of this model's allowed edge label positions.
 * </p>
 * @return {?}
 */
yfiles.graph.EdgeSegmentLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates a parameter where the label is attached to the edge segment that contains the edge's midpoint.
 * @param {number} segmentRatio The ratio at which to place the label at the segment. A ratio of 0.0 will place the label at the source side of the
 * segment, a ratio of 1.0 at the target side. Ratios &lt; 0.0 or > 1.0 will be interpreted as absolute values in world
 * coordinates.
 * @param {yfiles.graph.EdgeSides} sideOfEdge The side of the edge the label is placed on. Note that only single enum values but no combined ones are allowed.
 * @return {?} A label parameter that describes the provided parameters for this model instance.
 */
yfiles.graph.EdgeSegmentLabelModel.prototype.createParameterFromCenter = function(segmentRatio, sideOfEdge) {};

/**
 * Creates a parameter that measures the provided segment index from the source side of the edge path.
 * @param {number} segmentIndex The zero-based index of the segment beginning from the source side.
 * @param {number} segmentRatio The ratio at which to place the label at the segment. A ratio of 0.0 will place the label at the source side of the
 * segment, a ratio of 1.0 at the target side. Ratios &lt; 0.0 or > 1.0 will be interpreted as absolute values in world
 * coordinates.
 * @param {yfiles.graph.EdgeSides} sideOfEdge The side of the edge the label is placed on. Note that only single enum values but no combined ones are allowed.
 * @return {?} A label parameter that describes the provided parameters for this model instance.
 */
yfiles.graph.EdgeSegmentLabelModel.prototype.createParameterFromSource = function(segmentIndex, segmentRatio, sideOfEdge) {};

/**
 * Creates a parameter that measures the provided segment index from the target side of the edge path.
 * @param {number} segmentIndex The zero-based index of the segment beginning from the target side.
 * @param {number} segmentRatio The ratio at which to place the label at the segment. A ratio of 0.0 will place the label at the target side of the
 * segment, a ratio of 1.0 at the source side. Ratios &lt; 0.0 or > 1.0 will be interpreted as absolute values in world
 * coordinates.
 * @param {yfiles.graph.EdgeSides} sideOfEdge The side of the edge the label is placed on. Note that only single enum values but no combined ones are allowed.
 * @return {?} A label parameter that describes the provided parameters for this model instance.
 */
yfiles.graph.EdgeSegmentLabelModel.prototype.createParameterFromTarget = function(segmentIndex, segmentRatio, sideOfEdge) {};

/**
 * Returns an empty context.
 * @param {?} label The label to use in the context.
 * @param {?} layoutParameter The parameter to use for the label in the context.
 * @return {?} An empty context.
 */
yfiles.graph.EdgeSegmentLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.EdgeSegmentLabelModel.prototype.lookup = function(type) {};

/** @const */
yfiles.graph.EdgeSides = {};
/** @const {number} */
yfiles.graph.EdgeSides.ON_EDGE;
/** @const {number} */
yfiles.graph.EdgeSides.LEFT_OF_EDGE;
/** @const {number} */
yfiles.graph.EdgeSides.RIGHT_OF_EDGE;
/** @const {number} */
yfiles.graph.EdgeSides.ABOVE_EDGE;
/** @const {number} */
yfiles.graph.EdgeSides.BELOW_EDGE;

/** @const */
yfiles.graph.PlaceAlongEdge = {};
/** @const {number} */
yfiles.graph.PlaceAlongEdge.AT_SOURCE;
/** @const {number} */
yfiles.graph.PlaceAlongEdge.AT_TARGET;
/** @const {number} */
yfiles.graph.PlaceAlongEdge.AT_CENTER;

/** @const */
yfiles.graph.ExteriorLabelModelPosition = {};
/** @const {number} */
yfiles.graph.ExteriorLabelModelPosition.NORTH;
/** @const {number} */
yfiles.graph.ExteriorLabelModelPosition.EAST;
/** @const {number} */
yfiles.graph.ExteriorLabelModelPosition.SOUTH;
/** @const {number} */
yfiles.graph.ExteriorLabelModelPosition.WEST;
/** @const {number} */
yfiles.graph.ExteriorLabelModelPosition.NORTH_EAST;
/** @const {number} */
yfiles.graph.ExteriorLabelModelPosition.SOUTH_EAST;
/** @const {number} */
yfiles.graph.ExteriorLabelModelPosition.NORTH_WEST;
/** @const {number} */
yfiles.graph.ExteriorLabelModelPosition.SOUTH_WEST;
/**
 * @record
 * @struct
 */
yfiles.graph.ExteriorLabelModel = function() {};
 /** @type {?} */
yfiles.graph.ExteriorLabelModel.NORTH;
 /** @type {?} */
yfiles.graph.ExteriorLabelModel.EAST;
 /** @type {?} */
yfiles.graph.ExteriorLabelModel.SOUTH;
 /** @type {?} */
yfiles.graph.ExteriorLabelModel.SOUTH_EAST;
 /** @type {?} */
yfiles.graph.ExteriorLabelModel.SOUTH_WEST;
 /** @type {?} */
yfiles.graph.ExteriorLabelModel.WEST;
 /** @type {?} */
yfiles.graph.ExteriorLabelModel.NORTH_EAST;
 /** @type {?} */
yfiles.graph.ExteriorLabelModel.NORTH_WEST;
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.ExteriorLabelModel.prototype.insets;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.ExteriorLabelModel.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.ExteriorLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates a new parameter that is associated with this instance for the provided position.
 * @param {yfiles.graph.ExteriorLabelModelPosition} position The position constant that describes the position of the label.
 * @return {?} A new parameter instance.
 */
yfiles.graph.ExteriorLabelModel.prototype.createParameter = function(position) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.ExteriorLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.ExteriorLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} model
 * @return {?<?>}
 */
yfiles.graph.ExteriorLabelModel.prototype.getParameters = function(label, model) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.ExteriorLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.FilteredGraphWrapper = function() {};
 /** @type {function(?): boolean} */
yfiles.graph.FilteredGraphWrapper.prototype.nodePredicate;
 /** @type {function(?): boolean} */
yfiles.graph.FilteredGraphWrapper.prototype.edgePredicate;
 /** @type {?<?>} */
yfiles.graph.FilteredGraphWrapper.prototype.nodes;
 /** @type {?<?>} */
yfiles.graph.FilteredGraphWrapper.prototype.edges;
 /** @type {?<?>} */
yfiles.graph.FilteredGraphWrapper.prototype.labels;
 /** @type {?<?>} */
yfiles.graph.FilteredGraphWrapper.prototype.ports;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FilteredGraphWrapper.$class;

/**
 * Should be called by the client if the {\@link yfiles.graph.FilteredGraphWrapper#edgePredicate} changed for the given edge in the graph.
 * Should be called by the client if the {\@link yfiles.graph.FilteredGraphWrapper#edgePredicate} changed for the edge in the graph.
 * @param {?=} edge
 * @return {void}
 */
yfiles.graph.FilteredGraphWrapper.prototype.edgePredicateChanged = function(edge) {};

/**
 * Should be called by clients if the {\@link yfiles.graph.FilteredGraphWrapper#nodePredicate} changed for the given node.
 * Should be called by the client if the {\@link yfiles.graph.FilteredGraphWrapper#nodePredicate} changed for the nodes in the graph.
 * @param {?=} node The node.
 * @return {void}
 */
yfiles.graph.FilteredGraphWrapper.prototype.nodePredicateChanged = function(node) {};
/**
 * @record
 * @struct
 */
yfiles.graph.FreeEdgeLabelModel = function() {};
 /** @type {boolean} */
yfiles.graph.FreeEdgeLabelModel.prototype.edgeRelativeAngle;
 /** @type {!yfiles.graph.FreeEdgeLabelModel} */
yfiles.graph.FreeEdgeLabelModel.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FreeEdgeLabelModel.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.FreeEdgeLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates a parameter for the given location.
 * @see yfiles.graph.FreeEdgeLabelModel#edgeRelativeAngle
 * @param {number} ratio The ratio at which the label will be anchored between the location of the source port and the location of the target
 * port.
 * @param {number} distance The distance orthogonally to the connection between the source and target point.
 * @param {number} angle The angle by which the label should be rotated.
 * @return {?} A parameter that describes the position.
 */
yfiles.graph.FreeEdgeLabelModel.prototype.createEdgeAnchored = function(ratio, distance, angle) {};

/**
 * Tries to find a parameter that best matches the given layout for the provided label instance.
 * <p>
 * This implementation will match the provided layout perfectly.
 * </p>
 * @param {?} label The label to find a parameter for.
 * @param {?} model The model instance to use. This should be this instance.
 * @param {?} layout The anticipated layout for the label.
 * @return {?} A non-<code>null</code> parameter that can be used for the label to approximate the provided layout.
 */
yfiles.graph.FreeEdgeLabelModel.prototype.findBestParameter = function(label, model, layout) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.FreeEdgeLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.FreeEdgeLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.FreeEdgeLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.FreeLabelModel = function() {};
 /** @type {!yfiles.graph.FreeLabelModel} */
yfiles.graph.FreeLabelModel.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FreeLabelModel.$class;

/**
 * Creates a new label model parameter that places the label at the given absolute position using the provided angle.
 * @param {!yfiles.geometry.Point} anchorLocation The location for the parameter.
 * @param {number} angle The angle of rotation.
 * @return {?} A new parameter that is associated with this instance.
 */
yfiles.graph.FreeLabelModel.prototype.createAbsolute = function(anchorLocation, angle) {};

/**
 * Creates a new label at the given dynamic location using the provided angle.
 * @param {?} location The location to place the parameter at. That instance is stored by reference.
 * @param {number} angle The angle of rotation.
 * @return {?} A new parameter that is associated with this instance.
 */
yfiles.graph.FreeLabelModel.prototype.createAnchored = function(location, angle) {};

/**
 *
 * @return {?}
 */
yfiles.graph.FreeLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates a new label model parameter that dynamically reads the label layout from the provided instance.
 * @param {?} layout The oriented rectangle to dynamically retrieve the values from.
 * @return {?} A new parameter that is associated with this instance.
 */
yfiles.graph.FreeLabelModel.prototype.createDynamic = function(layout) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.FreeLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.FreeLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.FreeLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.FreeNodeLabelModel = function() {};
 /** @type {!yfiles.graph.FreeNodeLabelModel} */
yfiles.graph.FreeNodeLabelModel.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FreeNodeLabelModel.$class;

/**
 * Creates a parameter instance that anchors the label to the node at the canonical position with respect to the given
 * reference point.
 * <p>
 * This method {\@link yfiles.graph.FreeNodeLabelModel#createParameter creates a parameter} with the canonical settings for the ratios and offsets in the following way. Each
 * coordinate axis is considered independently. If the reference point coordinate is within the node layout interval, its
 * relative location specifies the layout ratio for this coordinate. Otherwise, the absolute distance of the reference
 * point and the interval specifies the layout offset and the layout ratio is either either <code>0.0</code> or
 * <code>1.0</code>. The parameters for the label ratio and label offset are calculated analogously. If no reference point is provided,
 * the reference point is determined automatically in the following way: For each coordinate, if the node layout and label
 * layout do not overlap, the reference is the label corner that is closest to the node. If they overlap and if in addition
 * the start or end coordinate of the label matches the start, center or end coordinate of the node, that coordinate is the
 * reference. Otherwise, the center of the label specifies the reference.
 * </p>
 * @param {!yfiles.geometry.Rect} nodeLayout The node layout.
 * @param {?} labelLayout The label layout.
 * @param {!yfiles.geometry.Point=} referenceLocation
 * @return {?} The canonical parameter for the specified node and label layout.
 */
yfiles.graph.FreeNodeLabelModel.prototype.createCanonicalParameter = function(nodeLayout, labelLayout, referenceLocation) {};

/**
 * Creates a parameter that is anchored at the node center and has no rotation.
 * @return {?} A parameter that is anchored at the node center and has no rotation.
 */
yfiles.graph.FreeNodeLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates a parameter instance that anchors the label to the node at a given position.
 * <p>
 * The parameter will use the ratio and offset values to determine a point on both the label and the node. It will place
 * the label in such a way that both points coincide.
 * </p>
 * @param {!yfiles.geometry.Point} layoutRatio The ratio that describes the point on the node's layout relative to its size.
 * @param {!yfiles.geometry.Point} layoutOffset The offset to apply to the point on the node after the ratio has been determined.
 * @param {!yfiles.geometry.Point} labelRatio The ratio that describes the point on the label's layout relative to its size.
 * @param {!yfiles.geometry.Point} labelOffset The offset to apply to the point on the label after the ratio has been determined.
 * @param {number} angle The angle by which the label should be rotated around the point described using the ratio and offset, measured in
 * radians.
 * @return {?} A parameter that exactly fits the described location.
 */
yfiles.graph.FreeNodeLabelModel.prototype.createParameter = function(layoutRatio, layoutOffset, labelRatio, labelOffset, angle) {};

/**
 * Tries to find a parameter that best matches the given layout for the provided label instance.
 * <p>
 * This implementation will match the provided layout perfectly.
 * </p>
 * @param {?} label The label to find a parameter for.
 * @param {?} model The model instance to use. This should be this instance.
 * @param {?} layout The anticipated layout for the label.
 * @return {?} A non-<code>null</code> parameter that can be used for the label to approximate the provided layout.
 */
yfiles.graph.FreeNodeLabelModel.prototype.findBestParameter = function(label, model, layout) {};

/**
 * Returns an empty context.
 * @param {?} label The label to use in the context.
 * @param {?} layoutParameter The parameter to use for the label in the context.
 * @return {?} An empty context.
 */
yfiles.graph.FreeNodeLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.FreeNodeLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 * Returns this instance if an instance of {\@link yfiles.graph.ILabelModelParameterFinder} is requested and <code>null</code> otherwise.
 * @param {!yfiles.lang.Class} type The type for which an instance is requested.
 * @return {!Object} An instance that is assignable to the given type or <code>null</code>.
 */
yfiles.graph.FreeNodeLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.FreeNodePortLocationModel = function() {};
 /** @type {!yfiles.graph.FreeNodePortLocationModel} */
yfiles.graph.FreeNodePortLocationModel.INSTANCE;
 /** @type {?} */
yfiles.graph.FreeNodePortLocationModel.NODE_CENTER_ANCHORED;
 /** @type {?} */
yfiles.graph.FreeNodePortLocationModel.NODE_LEFT_ANCHORED;
 /** @type {?} */
yfiles.graph.FreeNodePortLocationModel.NODE_RIGHT_ANCHORED;
 /** @type {?} */
yfiles.graph.FreeNodePortLocationModel.NODE_TOP_ANCHORED;
 /** @type {?} */
yfiles.graph.FreeNodePortLocationModel.NODE_BOTTOM_ANCHORED;
 /** @type {?} */
yfiles.graph.FreeNodePortLocationModel.NODE_TOP_LEFT_ANCHORED;
 /** @type {?} */
yfiles.graph.FreeNodePortLocationModel.NODE_TOP_RIGHT_ANCHORED;
 /** @type {?} */
yfiles.graph.FreeNodePortLocationModel.NODE_BOTTOM_RIGHT_ANCHORED;
 /** @type {?} */
yfiles.graph.FreeNodePortLocationModel.NODE_BOTTOM_LEFT_ANCHORED;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FreeNodePortLocationModel.$class;

/**
 *
 * @param {?} owner
 * @param {!yfiles.geometry.Point} location
 * @return {?}
 */
yfiles.graph.FreeNodePortLocationModel.prototype.createParameter = function(owner, location) {};

/**
 * Creates a parameter that uses the given ratios and offsets.
 * <p>
 * The <code>ratios</code> will be scaled by the node layout's size and added to the node's top left corner and the <code>offset</code> to determine
 * the port location.
 * </p>
 * @param {!yfiles.geometry.Point} ratios The ratios of the node layout's size.
 * @param {!yfiles.geometry.Point=} offset
 * @return {?} A new parameter that matches the specification.
 */
yfiles.graph.FreeNodePortLocationModel.prototype.createParameterForRatios = function(ratios, offset) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {?}
 */
yfiles.graph.FreeNodePortLocationModel.prototype.getContext = function(port, locationParameter) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {!yfiles.geometry.Point}
 */
yfiles.graph.FreeNodePortLocationModel.prototype.getLocation = function(port, locationParameter) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.FreeNodePortLocationModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.GenericLabelModel = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graph.GenericLabelModel.$class;

/**
 * Adds another parameter to this models collection of parameters.
 * <p>
 * Note that the parameter will be wrapped by this class and the resulting parameter which will use this model instance as
 * its {\@link yfiles.graph.ILabelModelParameter#model} will be returned. The parameter is stored by reference and subsequent modification of the parameter or its
 * associated model will be reflected by this instance. Also the methods allows for associating a {\@link yfiles.graph.ILabelCandidateDescriptor}
 * with each parameter that can later be retrieved via the {\@link yfiles.graph.GenericLabelModel#getDescriptor} method.
 * </p>
 * @param {?} layoutParameter The parameter to add to this instance.
 * @param {?=} descriptor
 * @return {?} A new parameter that wraps the provided parameter and uses this instance as its model.
 */
yfiles.graph.GenericLabelModel.prototype.addParameter = function(layoutParameter, descriptor) {};

/**
 *
 * @return {?}
 */
yfiles.graph.GenericLabelModel.prototype.createDefaultParameter = function() {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.GenericLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 * Yields the {\@link yfiles.graph.ILabelCandidateDescriptor} that has been associated with the instance during
 * {\@link yfiles.graph.GenericLabelModel#addParameter}.
 * @param {?} label The label instance to use.
 * @param {?} layoutParameter The parameter to get the descriptor for.
 * @return {?} The descriptor instance that had been added to this instance during {\@link #addParameter}.
 */
yfiles.graph.GenericLabelModel.prototype.getDescriptor = function(label, layoutParameter) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.GenericLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.GenericPortLocationModel = function() {};
 /** @type {?<?>} */
yfiles.graph.GenericPortLocationModel.prototype.locationParameters;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.GenericPortLocationModel.$class;

/**
 * This method simply delegates to {\@link yfiles.graph.GenericPortLocationModel#addParameter}.
 * <p>
 * It is there to allow for convenient initialization in code.
 * </p>
 * <p>
 * This method is used by the compiler if the collection initializer syntax is used.
 * </p>
 * @see yfiles.graph.GenericPortLocationModel#addParameter
 * @param {?} locationParameter The parameter to add to this instance.
 * @return {void}
 */
yfiles.graph.GenericPortLocationModel.prototype.add = function(locationParameter) {};

/**
 * Adds the given parameter to the {\@link yfiles.graph.GenericPortLocationModel#locationParameters} of this instance.
 * <p>
 * Note that this will create a new parameter instance that is then actually bound to this instance and returned. The
 * instance is stored by reference so if this is a mutable instance this instance will be modified, implicitly, too.
 * </p>
 * @see yfiles.graph.GenericPortLocationModel#add
 * @param {?} locationParameter The parameter to add to this instance.
 * @return {?} The parameter to use with this model that wraps the given parameter.
 */
yfiles.graph.GenericPortLocationModel.prototype.addParameter = function(locationParameter) {};

/**
 * Factory method that creates a parameter for the given port that tries to match the provided location in absolute world
 * coordinates.
 * <p>
 * This implementation iterates over all {\@link yfiles.graph.GenericPortLocationModel#locationParameters} to return the one that matches the given location the best.
 * </p>
 * @param {?} owner The port owner that will own the port for which the parameter shall be created.
 * @param {!yfiles.geometry.Point} location The location in the world coordinate system that should be matched as best as possible.
 * @return {?} A new instance that can be used to describe the location of an {\@link } at the given <code>owner</code>.
 */
yfiles.graph.GenericPortLocationModel.prototype.createParameter = function(owner, location) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {?}
 */
yfiles.graph.GenericPortLocationModel.prototype.getContext = function(port, locationParameter) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {!yfiles.geometry.Point}
 */
yfiles.graph.GenericPortLocationModel.prototype.getLocation = function(port, locationParameter) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.GenericPortLocationModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.IClipboardHelper = function() {};

/**
 * This method is called during the copy operation of the given item to retrieve additional state that can be later used
 * during a {\@link yfiles.graph.IClipboardHelper#paste} operation.
 * <p>
 * If the source graph is a managed folding view, the <code>item</code> is always a master item.
 * </p>
 * @abstract
 * @param {?} context The context in which this interface is used, can be <code>null</code>
 * @param {?} item The item to copy to the clipboard.
 * @return {!Object} A custom user object that will later be provided to {\@link #paste}.
 */
yfiles.graph.IClipboardHelper.prototype.copy = function(context, item) {};

/**
 * This method is called during the cut operation of the given item to retrieve additional state that can be later used
 * during a {\@link yfiles.graph.IClipboardHelper#paste} operation.
 * <p>
 * If the source graph is a managed folding view, the <code>item</code> is always a master item.
 * </p>
 * @abstract
 * @param {?} context The context in which this interface is used, can be <code>null</code>
 * @param {?} item The item to cut to the clipboard.
 * @return {!Object} A custom user object that will later be provided to {\@link #paste}.
 */
yfiles.graph.IClipboardHelper.prototype.cut = function(context, item) {};

/**
 * This method is called after the item has been pasted from the clipboard.
 * <p>
 * The <code>item</code> is always a master item since the clipboard graph is not a managed folding view.
 * </p>
 * @abstract
 * @param {?} context The context in which this interface is used, can be <code>null</code>
 * @param {?} item The item that has been created during the paste operation.
 * @param {!Object} userData The data that had been queried during {\@link #cut} or {\@link #copy}
 * respectively.
 * @return {void}
 */
yfiles.graph.IClipboardHelper.prototype.paste = function(context, item, userData) {};

/**
 * Determines whether the given item can or should be copied to the clipboard.
 * <p>
 * If the source graph is a managed folding view, the <code>item</code> is always a view item. Furthermore, if collapsed nodes are to be
 * copied, this method will be queried with the collapsed group node as <code>item</code> for each "hidden" node that is currently not
 * visible.
 * </p>
 * @abstract
 * @param {?} context The context in which this interface is used, can be <code>null</code>
 * @param {?} item The item in question.
 * @return {boolean} Whether this item should be copied.
 */
yfiles.graph.IClipboardHelper.prototype.shouldCopy = function(context, item) {};

/**
 * Determines whether the given item can or should be cut to the clipboard.
 * <p>
 * If the source graph is a managed folding view, the <code>item</code> is always a view item. Furthermore, if collapsed nodes are to be
 * cut, this method will be queried with the collapsed group node as <code>item</code> for each "hidden" node that is currently not
 * visible.
 * </p>
 * @abstract
 * @param {?} context The context in which this interface is used, can be <code>null</code>
 * @param {?} item The item in question.
 * @return {boolean} Whether this item should be cut.
 */
yfiles.graph.IClipboardHelper.prototype.shouldCut = function(context, item) {};

/**
 * Determines whether the given item can or should be pasted from the clipboard to the target graph.
 * <p>
 * The <code>item</code> is always a master item since the clipboard graph is not a managed folding view.
 * </p>
 * @abstract
 * @param {?} context The context in which this interface is used, can be <code>null</code>
 * @param {?} item The item in the clipboard graph.
 * @param {!Object} userData The state memento that had been created during {\@link #cut} or {\@link #copy}.
 * @return {boolean} Whether this item should be pasted.
 */
yfiles.graph.IClipboardHelper.prototype.shouldPaste = function(context, item, userData) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IClipboardHelper;
/**
 * @record
 * @struct
 */
yfiles.graph.IGraphClipboardContext = function() {};
 /** @type {!yfiles.graph.GraphClipboard} */
yfiles.graph.IGraphClipboardContext.prototype.clipboard;
 /** @type {?} */
yfiles.graph.IGraphClipboardContext.prototype.sourceGraph;
 /** @type {?} */
yfiles.graph.IGraphClipboardContext.prototype.targetGraph;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IGraphClipboardContext;
/**
 * @record
 * @struct
 */
yfiles.graph.IClipboardIdProvider = function() {};

/**
 * Gets the ID for the given <code>originalItem</code>.
 * @abstract
 * @param {?} context The clipboard context
 * @param {?} originalItem The original item which is copied. The item is part of the original graph from which the item is copied.
 * @return {!Object} An ID for the given item. The object should be suitable for use in a {\@link }.
 */
yfiles.graph.IClipboardIdProvider.prototype.getId = function(context, originalItem) {};

/**
 * Gets the item which is represented by the given <code>id</code>.
 * @abstract
 * @param {?} context The clipboard context.
 * @param {!Object} id The ID to get the item for.
 * @return {?} The item which is represented by the given ID or <code>null</code> if the item cannot be located or is invalid. The item needs to be
 * part of the target graph for paste operations.
 */
yfiles.graph.IClipboardIdProvider.prototype.getItem = function(context, id) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IClipboardIdProvider;

/** @const */
yfiles.graph.ParentNodeDetectionModes = {};
/** @const {number} */
yfiles.graph.ParentNodeDetectionModes.ROOT;
/** @const {number} */
yfiles.graph.ParentNodeDetectionModes.SELECTION;
/** @const {number} */
yfiles.graph.ParentNodeDetectionModes.PREVIOUS_PARENT;
/** @const {number} */
yfiles.graph.ParentNodeDetectionModes.AT_LOCATION;
/** @const {number} */
yfiles.graph.ParentNodeDetectionModes.ALLOW_SELF;
/** @const {number} */
yfiles.graph.ParentNodeDetectionModes.FORCE;
/** @const {number} */
yfiles.graph.ParentNodeDetectionModes.MODE_MASK;
/** @const {number} */
yfiles.graph.ParentNodeDetectionModes.MODIFIER_MASK;
/**
 * @record
 * @struct
 */
yfiles.graph.GraphClipboard = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.graph.GraphClipboard.prototype.pasteDelta;
 /** @type {boolean} */
yfiles.graph.GraphClipboard.prototype.empty;
 /** @type {!yfiles.graph.GraphCopier} */
yfiles.graph.GraphClipboard.prototype.toClipboardCopier;
 /** @type {!yfiles.graph.GraphCopier} */
yfiles.graph.GraphClipboard.prototype.fromClipboardCopier;
 /** @type {!yfiles.graph.GraphCopier} */
yfiles.graph.GraphClipboard.prototype.duplicateCopier;
 /** @type {?} */
yfiles.graph.GraphClipboard.prototype.idProvider;
 /** @type {?} */
yfiles.graph.GraphClipboard.prototype.clipboardGraph;
 /** @type {yfiles.graph.ParentNodeDetectionModes} */
yfiles.graph.GraphClipboard.prototype.parentNodeDetection;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.graph.GraphClipboard.prototype.dependentCopyItems;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.graph.GraphClipboard.prototype.independentCopyItems;
 /** @type {yfiles.graph.GraphItemTypes} */
yfiles.graph.GraphClipboard.prototype.copyItems;
 /** @type {boolean} */
yfiles.graph.GraphClipboard.prototype.ignoreEdgesWithOneNode;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.GraphClipboard.$class;

/**
 * Clears the clipboard's contents.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.clear = function() {};

/**
 * Copies the elements indicated by the filter to the clipboard graph.
 * <p>
 * For each element copied to the clipboard graph the {\@link yfiles.graph.GraphClipboard#onElementCopied} delegate will be called.
 * The actual work of this method is delegated to the {\@link yfiles.graph.GraphClipboard#toClipboardCopier}'s {\@link yfiles.graph.GraphCopier#copy} method.
 * </p>
 * @param {?} sourceGraph The graph to copy the contents from.
 * @param {function(?): boolean} filter The filter to apply to the source graph's elements.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.copy = function(sourceGraph, filter) {};

/**
 * Creates the graph used for the clipboard.
 * @protected
 * @return {?} A new readily configured {\@link } instance.
 */
yfiles.graph.GraphClipboard.prototype.createClipboardGraph = function() {};

/**
 * Convenience method that creates a predicate that is based upon the outcome of the {\@link yfiles.graph.IClipboardHelper#shouldCopy}
 * method that can be found in the {\@link yfiles.graph.ILookup#lookup} of the provided {\@link yfiles.graph.IModelItem}.
 * @see yfiles.graph.GraphClipboard#onCopy
 * @return {function(?): boolean} A predicate that uses {\@link #shouldCopy}.
 */
yfiles.graph.GraphClipboard.prototype.createClipBoardHelperCopyFilter = function() {};

/**
 * Convenience method that creates a predicate that is based upon the outcome of the {\@link yfiles.graph.IClipboardHelper#shouldCut}
 * method that can be found in the {\@link yfiles.graph.ILookup#lookup} of the provided {\@link yfiles.graph.IModelItem}.
 * @see yfiles.graph.GraphClipboard#cut
 * @return {function(?): boolean} A predicate that uses {\@link #shouldCut}.
 */
yfiles.graph.GraphClipboard.prototype.createClipBoardHelperCutFilter = function() {};

/**
 * Convenience method that creates a predicate that is based upon the outcome of the {\@link yfiles.graph.IClipboardHelper#shouldPaste}
 * method that can be found in the {\@link yfiles.graph.ILookup#lookup} of the provided {\@link yfiles.graph.IModelItem}.
 * @see yfiles.graph.GraphClipboard#cut
 * @return {function(?): boolean} A predicate that uses {\@link #shouldPaste}.
 */
yfiles.graph.GraphClipboard.prototype.createClipBoardHelperPasteFilter = function() {};

/**
 * Factory method that creates the context for the upcoming calls to the {\@link yfiles.graph.IClipboardHelper} methods.
 * @protected
 * @param {?} sourceGraph The source graph of the operation.
 * @param {?} targetGraph The target graph of the operation.
 * @return {?} A context that has the properties configured according to the parameters.
 */
yfiles.graph.GraphClipboard.prototype.createContext = function(sourceGraph, targetGraph) {};

/**
 * Creates the default {\@link yfiles.graph.IClipboardIdProvider} used by this instance to provide IDs for copied items.
 * <p>
 * The default implementation simply uses a reference to the original item as ID.
 * </p>
 * <p>
 * Custom ID can be used to map between elements in different graphs.
 * </p>
 * @protected
 * @return {?}
 */
yfiles.graph.GraphClipboard.prototype.createDefaultClipboardIdProvider = function() {};

/**
 * Creates a predicate for use in the {\@link yfiles.graph.GraphClipboard#onCopy} method.
 * <p>
 * This filter uses two predicates to decide whether a graph item can be copied. The base set of items specified by this
 * filter is induced by the {\@link yfiles.graph.GraphClipboard#createSelectionFilter}. Optionally, this set can be restricted
 * further by an {\@link yfiles.graph.IClipboardHelper#shouldCopy} predicate. If such a predicate returns <code>false</code> for the item itself
 * or any item this item depends on, then the item will not be copied. Items without such a predicate are handled solely
 * according to their selection state.
 * </p>
 * @param {?} selection The selection model to base the filter on.
 * @param {?} graph The graph to use for determining adjacency.
 * @return {function(?): boolean} A predicate that filters subgraph induced by the selection of nodes and restricted by an optional {\@link #shouldCopy}
 * predicate.
 */
yfiles.graph.GraphClipboard.prototype.createDefaultCopyFilter = function(selection, graph) {};

/**
 * Creates a predicate for use in the {\@link yfiles.graph.GraphClipboard#cut} method.
 * <p>
 * This filter uses two predicates to decide whether a graph item can be cut. The base set of items specified by this
 * filter is induced by the {\@link yfiles.graph.GraphClipboard#createSelectionFilter}. Optionally, this set can be restricted
 * further by an {\@link yfiles.graph.IClipboardHelper#shouldCut} predicate. If such a predicate returns <code>false</code> for the item itself
 * or any item this item depends on, then the item will not be cut. Items without such a predicate are handled solely
 * according to their selection state.
 * </p>
 * @param {?} selection The selection model to base the filter on.
 * @param {?} graph The graph to use for determining adjacency.
 * @return {function(?): boolean} A predicate that filters subgraph induced by the selection of nodes and restricted by an optional {\@link #shouldCut}
 * predicate.
 */
yfiles.graph.GraphClipboard.prototype.createDefaultCutFilter = function(selection, graph) {};

/**
 * Creates a predicate for use in the {\@link yfiles.graph.GraphClipboard#duplicate} method.
 * <p>
 * By default this method uses the same filter implementation as {\@link yfiles.graph.GraphClipboard#createDefaultCopyFilter}: This
 * filter uses two predicates to decide whether a graph item will be duplicated. The base set of items specified by this
 * filter is induced by the {\@link yfiles.graph.GraphClipboard#createSelectionFilter}. Optionally, this set can be restricted
 * further by an {\@link yfiles.graph.IClipboardHelper#shouldCopy} predicate. If such a predicate returns <code>false</code> for the item itself
 * or any item this item depends on, then the item will not be copied. Items without such a predicate are handled solely
 * according to their selection state.
 * </p>
 * @param {?} selection The selection model to base the filter on.
 * @param {?} graph The graph to use for determining adjacency.
 * @return {function(?): boolean} A predicate that filters subgraph induced by the selection of nodes and restricted by an optional {\@link #shouldCopy}
 * predicate.
 */
yfiles.graph.GraphClipboard.prototype.createDefaultDuplicateFilter = function(selection, graph) {};

/**
 * Factory method that creates the {\@link yfiles.graph.GraphClipboard#duplicateCopier}.
 * @protected
 * @return {!yfiles.graph.GraphCopier} A new {\@link } instance.
 */
yfiles.graph.GraphClipboard.prototype.createDuplicateCopier = function() {};

/**
 * Factory method that creates the {\@link yfiles.graph.GraphClipboard#fromClipboardCopier}.
 * @protected
 * @return {!yfiles.graph.GraphCopier} A new {\@link } instance.
 */
yfiles.graph.GraphClipboard.prototype.createFromClipboardCopier = function() {};

/**
 * Creates a predicate for use in the {\@link yfiles.graph.GraphClipboard#cut} and {\@link yfiles.graph.GraphClipboard#onCopy} methods.
 * <p>
 * This predicate is based on the element induced by the set of selected nodes, e.g. each edge that has both of its
 * adjacent port owners selected will be included as well as each label and port whose owner is included. Also ports where
 * no adjacent edge is included (but edges exist), will not be included, unless the {\@link yfiles.graph.IPortDefaults#autoCleanup} is set to <code>false</code>.
 * </p>
 * @param {?} selection The selection model to base the filter on.
 * @param {?} graph The graph to use for determining adjacency.
 * @return {function(?): boolean} A predicate that filters subgraph induced by the selection of nodes.
 */
yfiles.graph.GraphClipboard.prototype.createSelectionFilter = function(selection, graph) {};

/**
 * Factory method that creates the {\@link yfiles.graph.GraphClipboard#toClipboardCopier}.
 * @protected
 * @return {!yfiles.graph.GraphCopier} A new {\@link } instance.
 */
yfiles.graph.GraphClipboard.prototype.createToClipboardCopier = function() {};

/**
 * Creates an induced predicate from <code>coreFilter</code> for use in the {\@link yfiles.graph.GraphClipboard#cut} and {\@link yfiles.graph.GraphClipboard#onCopy}
 * methods that takes dependent items into account.
 * <p>
 * This method can create a predicate for only a core set of items which is then extended or restricted depending on the
 * predicate values of graph item dependencies.
 * </p>
 * <p>
 * The <code>restrictive</code> parameter determines whether the result restricts or extends the set of elements handled by <code>coreFilter</code>:
 * </p>
 * <ul>
 * <li>
 * If <code>restrictive</code> is <code>false</code>, an item is allowed if either <code>coreFilter</code> returns <code>true</code> for itself or if all items it depends on
 * (e.g. label/port owner, source/target port etc.) are allowed by <code>coreFilter</code>.
 * </li>
 * <li>
 * If <code>restrictive</code> is <code>true</code>, an item is forbidden if either <code>coreFilter</code> returns <code>false</code> for itself or if any item it depends on
 * (e.g. label/port owner, source/target port etc.) is forbidden by <code>coreFilter</code>.
 * </li>
 * </ul>
 * @param {function(?): boolean} coreFilter The core predicate for the base set of elements.
 * @param {?} graph The graph to use for determining adjacency.
 * @param {boolean} restrictive Whether to create a restriction or extension for the <code>coreFilter</code> predicate
 * @return {function(?): boolean}
 */
yfiles.graph.GraphClipboard.createWrappedFilter = function(coreFilter, graph, restrictive) {};

/**
 * Cuts the items indicated by <code>filter</code> to the clipboard and removes them from the graph.
 * <p>
 * This method delegates the core work to {\@link yfiles.graph.GraphClipboard#onCopy} which will use the {\@link yfiles.graph.GraphClipboard#toClipboardCopier} to copy the cut elements
 * to the clipboard.
 * </p>
 * @see yfiles.graph.GraphClipboard#createSelectionFilter
 * @param {?} sourceGraph The graph to cut the items from.
 * @param {function(?): boolean} filter The filter to use.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.cut = function(sourceGraph, filter) {};

/**
 * Duplicates the elements indicated by the filter.
 * <p>
 * The {\@link yfiles.graph.GraphClipboard#clipboardGraph} is not altered by this operation.
 * </p>
 * @param {?} context The current {\@link }.
 * @param {?} sourceGraph The graph whose elements should be duplicated.
 * @param {function(?): boolean} filter A predicate which returns <code>true</code> for elements which should be duplicated.
 * @param {function(?, ?): void} elementDuplicated An element copied callback which gets invoked for each element which has been duplicated. The two parameters passed into
 * the callback are guaranteed to be part of the <code>sourceGraph</code>.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.duplicate = function(context, sourceGraph, filter, elementDuplicated) {};

/**
 * Retrieves the {\@link yfiles.graph.IClipboardHelper} instance associated with the given item.
 * <p>
 * This implementation uses the item's {\@link yfiles.graph.ILookup#lookup} method to retrieve the helper instance.
 * </p>
 * @protected
 * @param {?} item The item to find the clipboard helper for.
 * @return {?} An instance or <code>null</code>.
 */
yfiles.graph.GraphClipboard.prototype.getClipboardHelper = function(item) {};

/**
 * Gets a folding state of an edge for a given {\@link yfiles.graph.FoldingEdgeStateId}.
 * <p>
 * This method might be overridden to map folding states for edges whose source or target node's hierarchy might have
 * changed during a paste operation.
 * </p>
 * @protected
 * @param {?} edge The edge to get the folding state for.
 * @param {!yfiles.graph.FoldingEdgeStateId} id The original {\@link } to get the folding state for. Passing <code>null</code> will return the folding state
 * which was visible when the edge was copied into the clipboard.
 * @return {?} The folding state which is mapped to the given <code>id</code>. May be <code>null</code>.
 */
yfiles.graph.GraphClipboard.prototype.getFoldingEdgeState = function(edge, id) {};

/**
 * Gets a {\@link yfiles.graph.ILabelModelParameter} for the given <code>label</code> to be placed at the given <code>newOwner</code>.
 * <p>
 * Implementations might delegate to {\@link yfiles.graph.GraphCopier#copyLabelLayoutParameter} to copy the existing parameter or
 * use the {\@link yfiles.graph.IGraph#nodeDefaults} or {\@link yfiles.graph.IGraph#edgeDefaults} to create a new one. Note that the type of the owner might have changed during the copy operation.
 * </p>
 * @protected
 * @param {!yfiles.graph.GraphCopier} copier The {\@link } whose {\@link #copyLabelLayoutParameter} method can be used to copy the
 * existing parameter.
 * @param {?} graph The {\@link } whose {\@link #nodeDefaults} or {\@link #edgeDefaults} can be used to create a new parameter.
 * @param {?} label The label to be copied.
 * @param {?} newOwner The new owner for the label.
 * @return {?} An {\@link } for the copied label.
 */
yfiles.graph.GraphClipboard.prototype.getLabelLayoutParameter = function(copier, graph, label, newOwner) {};

/**
 * Retrieves the memento associated with an item in the clipboard graph that has been stored with the item during {\@link yfiles.graph.GraphClipboard#onElementCopied}
 * and {\@link yfiles.graph.GraphClipboard#onElementCut}.
 * @param {?} clipboardItem The item in the clipboard graph.
 * @return {!Object} The object returned by the {\@link } methods or <code>null</code>.
 */
yfiles.graph.GraphClipboard.prototype.getMemento = function(clipboardItem) {};

/**
 * Gets a {\@link yfiles.graph.IPortLocationModelParameter} for the given <code>originalPort</code> to be placed at the given <code>newOwner</code>.
 * <p>
 * Implementations might delegate to {\@link yfiles.graph.GraphCopier#copyPortLocationParameter} to copy the existing parameter or
 * use the {\@link yfiles.graph.IGraph#nodeDefaults} or {\@link yfiles.graph.IGraph#edgeDefaults} to create a new one. Note that the type of the owner might have changed during the copy operation.
 * </p>
 * @protected
 * @param {!yfiles.graph.GraphCopier} copier The {\@link } whose {\@link #copyPortLocationParameter} method can be used to copy the
 * existing parameter.
 * @param {?} graph The {\@link } whose {\@link #nodeDefaults} or {\@link #edgeDefaults} can be used to create a new parameter.
 * @param {?} originalPort The port to be copied.
 * @param {?} newOwner The new owner for the port.
 * @return {?} An {\@link } for the copied port.
 */
yfiles.graph.GraphClipboard.prototype.getPortLocationParameter = function(copier, graph, originalPort, newOwner) {};

/**
 * Provides an {\@link yfiles.graph.IEdge} where the given <code>originalBend</code> can be added to.
 * <p>
 * Called for {\@link yfiles.graph.IBend}s whose edge is not copied to provide a new owner. Might return <code>null</code> if no target for the
 * given <code>originalBend</code> is found. In this case the bend will not be copied.
 * </p>
 * @protected
 * @param {?} originalBend The bend to be copied.
 * @return {?} An {\@link } for the bend to be added to or <code>null</code> if the bend should not be copied.
 */
yfiles.graph.GraphClipboard.prototype.getTargetEdge = function(originalBend) {};

/**
 * Provides an {\@link yfiles.graph.ILabelOwner} where the given <code>originalLabel</code> can be added to.
 * <p>
 * Called for {\@link yfiles.graph.ILabel}s whose owners are not copied to provide a new owner. Might return <code>null</code> if no target for
 * the given <code>originalLabel</code> is found. In this case the label will not be copied.
 * </p>
 * @protected
 * @param {?} originalLabel The label to be copied.
 * @return {?} An {\@link } for the label to be added to or <code>null</code> if the label should not be copied.
 */
yfiles.graph.GraphClipboard.prototype.getTargetLabeledItem = function(originalLabel) {};

/**
 * Provides a parent group node for the given <code>originalNode</code>.
 * <p>
 * Called for {\@link yfiles.graph.INode}s to place them inside a group node. Might return <code>null</code> if the given node should be placed
 * at the root or if the graph is not grouped.
 * </p>
 * @see yfiles.graph.GraphClipboard#parentNodeDetection
 * @protected
 * @param {?} originalNode The node to be copied.
 * @return {?} The new parent group of the node or <code>null</code> if the node should be placed at the root of the hierarchy or if the graph is
 * not grouped.
 */
yfiles.graph.GraphClipboard.prototype.getTargetNode = function(originalNode) {};

/**
 * Provides an {\@link yfiles.graph.IPort} where the given <code>originalEdge</code> can be added to.
 * <p>
 * Called for {\@link yfiles.graph.IEdge}s whose source or target ports are not copied to provide a new port. Might return <code>null</code> if
 * no target for the given <code>originalEdge</code> is found. In this case the edge will not be copied.
 * </p>
 * @protected
 * @param {?} originalEdge The edge to be copied.
 * @param {boolean} atSource Whether to look for a source port.
 * @return {?} An {\@link } for the edge to be added to or <code>null</code> if the edge should not be copied.
 */
yfiles.graph.GraphClipboard.prototype.getTargetPort = function(originalEdge, atSource) {};

/**
 * Provides an {\@link yfiles.graph.IPortOwner} where the given <code>originalPort</code> can be added to.
 * <p>
 * Called for {\@link yfiles.graph.IPort}s whose owners are not copied to provide a new owner. Might return <code>null</code> if no target for
 * the given <code>originalPort</code> is found. In this case the port will not be copied.
 * </p>
 * @protected
 * @param {?} originalPort The port to be copied.
 * @return {?} An {\@link } for the port to be added to or <code>null</code> if the port should not be copied.
 */
yfiles.graph.GraphClipboard.prototype.getTargetPortOwner = function(originalPort) {};

/**
 * Whether the given <code>item</code> is a "dummy" item which should not be pasted.
 * <p>
 * A dummy item is used to keep {\@link yfiles.graph.IModelItem}s which cannot exist without an owner in the {\@link yfiles.graph.GraphClipboard#clipboardGraph} (e.g.
 * {\@link yfiles.graph.ILabel}s).
 * </p>
 * @param {?} item The item to test.
 * @return {boolean} <code>true</code> if the item is a "dummy" item.
 */
yfiles.graph.GraphClipboard.prototype.isDummy = function(item) {};

/**
 * Whether the given <code>item</code> exists in a folding state of its <code>owner</code>.
 * @protected
 * @param {?} owner The owner of the given item.
 * @param {?} item An {\@link }, {\@link }, or {\@link }.
 * @return {boolean} <code>true</code> if the given item exists in a folding state.
 */
yfiles.graph.GraphClipboard.isFoldingStateElement = function(owner, item) {};

/**
 * Calls {\@link yfiles.graph.GraphCopier#copy} on the current {\@link yfiles.graph.GraphClipboard#toClipboardCopier} instance or {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} instance, depending on whether the <code>targetGraph</code> is the {\@link yfiles.graph.GraphClipboard#clipboardGraph}
 * instance.
 * @protected
 * @param {?} sourceGraph The source graph to pass to {\@link #copy}
 * @param {function(?): boolean} filter The predicate to pass on.
 * @param {?} targetGraph The target graph to pass on.
 * @param {?} targetRootNode The node to use as the root node in the grouped <code>targetGraph</code>.
 * @param {function(?, ?): void} elementCopiedCallback The delegate to pass on. For each element that is copied during the operation to the clipboard, this callback will be
 * passed the original and the copy of the item. In case the <code>sourceGraph</code> is a {\@link #views folding view graph} both elements are passed
 * as {\@link #masterGraph master} elements or {\@link #getFolderNodeState folding state elements} if a master element does not exist.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.onCopy = function(sourceGraph, filter, targetGraph, targetRootNode, elementCopiedCallback) {};

/**
 * A callback that will be invoked for each item that has been copied into the clipboard graph in response to a {\@link yfiles.graph.GraphClipboard#onCopy}
 * operation.
 * <p>
 * This implementation will {\@link yfiles.graph.ILookup#lookup} a {\@link yfiles.graph.IClipboardHelper} for each item in the original graph
 * and remember the memento retrieved by the {\@link yfiles.graph.IClipboardHelper#copy} method for later use during the {\@link yfiles.graph.GraphClipboard#onElementPasted}
 * operation.
 * </p>
 * @protected
 * @param {?} original The original element from the source graph instance. If the source graph is a managed folding view, this is always a
 * master item.
 * @param {?} copy The copy from the clipboard graph.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.onElementCopied = function(original, copy) {};

/**
 * A callback function that will be invoked for each item that has been copied into the clipboard graph in response to a {\@link yfiles.graph.GraphClipboard#cut}
 * operation.
 * <p>
 * This implementation will {\@link yfiles.graph.ILookup#lookup} a {\@link yfiles.graph.IClipboardHelper} for each item in the original graph
 * and remember the memento retrieved by the {\@link yfiles.graph.IClipboardHelper#cut} method for later use during the {\@link yfiles.graph.GraphClipboard#onElementPasted}
 * operation.
 * </p>
 * @protected
 * @param {?} original The original element from the source graph instance. If the source graph is a managed folding view, this is always a
 * master item.
 * @param {?} copy The copy from the clipboard graph.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.onElementCut = function(original, copy) {};

/**
 * A callback function that will be invoked for each item that has been pasted into the target graph in response to a
 * Paste(IGraph) operation.
 * <p>
 * This method will use a previously stored {\@link yfiles.graph.IClipboardHelper} to let it {\@link yfiles.graph.IClipboardHelper#paste finish} its work.
 * </p>
 * @protected
 * @param {?} original The original element from the clipboard graph instance. If the target graph is a managed folding view, this is always a
 * master item.
 * @param {?} copy The copy from the target graph.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.onElementPasted = function(original, copy) {};

/**
 * Calls {\@link yfiles.graph.GraphCopier#copy} on the current {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} instance, depending on whether the <code>targetGraph</code> is the {\@link yfiles.graph.GraphClipboard#clipboardGraph} instance.
 * @protected
 * @param {?} sourceGraph The source graph to pass to {\@link #copy}
 * @param {function(?): boolean} filter The predicate to pass on.
 * @param {?} targetGraph The target graph to pass on.
 * @param {?} targetRootNode The node to use as the root node in the grouped <code>targetGraph</code>.
 * @param {function(?, ?): void} elementCopiedCallback The delegate to pass on. For each element that is copied during the operation to the clipboard, this callback will be
 * passed the original and the copy of the item. In case the <code>targetGraph</code> is a {\@link #views folding view graph} the original element is
 * passed as {\@link #masterGraph master} elements or {\@link #getFolderNodeState folding state elements} if a master element does not exist. The copied element is always
 * part of the <code>targetGraph</code>.
 * @param {function(?): boolean} targetFilter This predicate is used to determine which {\@link }s and {\@link }s can be used as targets for paste
 * operations, e.g. if a labels or ports are copied without their owners. If <code>null</code> all model items can be used as targets.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.onPaste = function(sourceGraph, filter, targetGraph, targetRootNode, elementCopiedCallback, targetFilter) {};

/**
 * Pastes the {\@link yfiles.graph.GraphClipboard#clipboardGraph}'s contents into the <code>targetGraph</code>, selecting all pasted elements.
 * <p>
 * The actual work of this method is delegated to the {\@link yfiles.graph.GraphClipboard#fromClipboardCopier}'s {\@link yfiles.graph.GraphCopier#copy} method.
 * </p>
 * Pastes the contents from the {\@link yfiles.graph.GraphClipboard#clipboardGraph} to the <code>targetGraph</code> after applying a <code>filter</code>.
 * <p>
 * For each element pasted into the graph the <code>elementPasted</code> delegate will be invoked and the {\@link yfiles.graph.GraphClipboard#onElementPasted}
 * method will be called. The actual work of this method is delegated to the {\@link yfiles.graph.GraphClipboard#fromClipboardCopier}'s {\@link yfiles.graph.GraphCopier#copy} method.
 * <br />
 * Providing a valid <code>targetFilter</code> allows for pasting {\@link yfiles.graph.ILabel}s, {\@link yfiles.graph.IPort}s, and
 * {\@link yfiles.graph.IEdge}s without valid owners.
 * </p>
 * Pastes the contents from the {\@link yfiles.graph.GraphClipboard#clipboardGraph} to the <code>targetGraph</code> after applying a <code>filter</code>.
 * <p>
 * For each element pasted into the graph the <code>elementPasted</code> delegate will be invoked and the {\@link yfiles.graph.GraphClipboard#onElementPasted}
 * method will be called. The actual work of this method is delegated to the {\@link yfiles.graph.GraphClipboard#fromClipboardCopier}'s {\@link yfiles.graph.GraphCopier#copy} method.
 * </p>
 * Pastes the contents from the {\@link yfiles.graph.GraphClipboard#clipboardGraph} to the <code>targetGraph</code> after applying a <code>filter</code>.
 * <p>
 * For each element pasted into the graph the <code>elementPasted</code> delegate will be invoked and the {\@link yfiles.graph.GraphClipboard#onElementPasted}
 * method will be called. The actual work of this method is delegated to the {\@link yfiles.graph.GraphClipboard#fromClipboardCopier}'s {\@link yfiles.graph.GraphCopier#copy} method.
 * </p>
 * @param {?|{targetGraph: ?, filter: function(?): boolean, elementPasted: function(?, ?): void}} targetGraph_or_context_or_options The graph to paste into. / A valid input mode context. Passing a valid input mode context is required for keeping orthogonal edges at group nodes
 * whose size might be adjusted after the paste operation. / The graph to paste the contents in.
 * @param {?|function(?): boolean=} selection_or_targetGraph_or_filter The selection model to set the selection on. / The graph to paste the contents in.
 * @param {function(?): boolean|function(?, ?): void=} filter_or_elementPasted The filter to apply to the clipboard graph.
 * @param {function(?, ?): void=} elementPasted The callback to use for each element that has been pasted. For each element that is copied during the operation to the
 * clipboard, this callback will be passed the original and the copy of the item. In case the <code>targetGraph</code> is a {\@link #views folding view graph}
 * the original element is passed as {\@link #masterGraph master} elements or {\@link #getFolderNodeState folding state elements} if a master element does not exist. The
 * copied element is always part of the <code>targetGraph</code>.
 * @param {function(?): boolean=} targetFilter A filter which returns <code>true</code> for model items which can be used as target for clipboard items which need an owner (e.g.
 * {\@link }s which were copied without their owner). If <code>null</code> all model items can be used as targets.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.paste = function(targetGraph_or_context_or_options, selection_or_targetGraph_or_filter, filter_or_elementPasted, elementPasted, targetFilter) {};

/**
 * Removes elements from the graph based on a predicate.
 * @see yfiles.graph.GraphClipboard#cut
 * @protected
 * @param {?} sourceGraph The graph to remove elements from.
 * @param {function(?): boolean} predicate The predicate that decides which elements to remove.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.removeElements = function(sourceGraph, predicate) {};

/**
 * Adds the given listener for the <code>ElementsCut</code> event that occurs when the {\@link yfiles.graph.GraphClipboard#cut} operation
 * finished successfully.
 * @see yfiles.graph.GraphClipboard#removeElementsCutListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.addElementsCutListener = function(listener) {};

/**
 * Removes the given listener for the <code>ElementsCut</code> event that occurs when the {\@link yfiles.graph.GraphClipboard#cut} operation
 * finished successfully.
 * @see yfiles.graph.GraphClipboard#addElementsCutListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.removeElementsCutListener = function(listener) {};

/**
 * Adds the given listener for the <code>ElementsCopied</code> event that occurs when the {\@link yfiles.graph.GraphClipboard#copy} operation
 * finished successfully.
 * @see yfiles.graph.GraphClipboard#removeElementsCopiedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.addElementsCopiedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ElementsCopied</code> event that occurs when the {\@link yfiles.graph.GraphClipboard#copy} operation
 * finished successfully.
 * @see yfiles.graph.GraphClipboard#addElementsCopiedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.removeElementsCopiedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ElementsPasted</code> event that occurs when the {\@link yfiles.graph.GraphClipboard#paste} operation
 * finished successfully.
 * @see yfiles.graph.GraphClipboard#removeElementsPastedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.addElementsPastedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ElementsPasted</code> event that occurs when the {\@link yfiles.graph.GraphClipboard#paste} operation
 * finished successfully.
 * @see yfiles.graph.GraphClipboard#addElementsPastedListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphClipboard.prototype.removeElementsPastedListener = function(listener) {};

/** @const */
yfiles.graph.CloneTypes = {};
/** @const {number} */
yfiles.graph.CloneTypes.NODE_STYLE;
/** @const {number} */
yfiles.graph.CloneTypes.EDGE_STYLE;
/** @const {number} */
yfiles.graph.CloneTypes.PORT_STYLE;
/** @const {number} */
yfiles.graph.CloneTypes.LABEL_STYLE;
/** @const {number} */
yfiles.graph.CloneTypes.LABEL_MODEL_PARAMETER;
/** @const {number} */
yfiles.graph.CloneTypes.PORT_LOCATION_MODEL_PARAMETER;
/** @const {number} */
yfiles.graph.CloneTypes.TAGS;
/** @const {number} */
yfiles.graph.CloneTypes.ALL;
/**
 * @record
 * @struct
 */
yfiles.graph.GraphCopier = function() {};
 /** @type {yfiles.graph.CloneTypes} */
yfiles.graph.GraphCopier.prototype.clone;
 /** @type {yfiles.graph.CloneTypes} */
yfiles.graph.GraphCopier.prototype.referentialIdentityTypes;
 /** @type {!Object} */
yfiles.graph.GraphCopier.NO_COPY;
 /** @type {boolean} */
yfiles.graph.GraphCopier.prototype.copyGrouping;
 /** @type {boolean} */
yfiles.graph.GraphCopier.prototype.copyFoldingStates;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.GraphCopier.$class;

/**
 * Callback method that adds a bend to the targetEdge in the targetGraph as a copy of the source bend.
 * @protected
 * @param {?} sourceGraph The source graph.
 * @param {?} targetGraph The target graph.
 * @param {?} targetEdge The target edge to add the bend to.
 * @param {?} sourceBend The source bend to copy the values from.
 * @param {!yfiles.geometry.Point} offset The offset to apply to the copied bend.
 * @param {number} index The index to add the bend at.
 * @return {?} The newly created bend.
 */
yfiles.graph.GraphCopier.prototype.addBend = function(sourceGraph, targetGraph, targetEdge, sourceBend, offset, index) {};

/**
 * Callback method that adds a label to the target item in the targetGraph as a copy of the source label.
 * <p>
 * This implementation uses {\@link yfiles.graph.GraphCopier#copyLabelLayoutParameter}, {\@link yfiles.graph.GraphCopier#copyLabelStyle}, and
 * {\@link yfiles.graph.GraphCopier#copyLabelTag} as callbacks.
 * </p>
 * @protected
 * @param {?} sourceGraph The source graph.
 * @param {?} targetGraph The target graph.
 * @param {?} targetOwner The item owner in the target graph to add the label to.
 * @param {?} sourceLabel The source label in the source graph.
 * @return {?} The newly created label.
 */
yfiles.graph.GraphCopier.prototype.addLabel = function(sourceGraph, targetGraph, targetOwner, sourceLabel) {};

/**
 * Callback method that adds a port to the targetPortOwner in the targetGraph as a copy of the source port.
 * <p>
 * This implementation does not need to copy the adjacent {\@link yfiles.graph.IEdge}s of the <code>sourcePort</code>. This implementation uses
 * {\@link yfiles.graph.GraphCopier#copyPortLocationParameter}, {\@link yfiles.graph.GraphCopier#copyPortStyle}, and {\@link yfiles.graph.GraphCopier#copyPortTag}
 * as callbacks.
 * </p>
 * @param {?} sourceGraph The source graph.
 * @param {?} targetGraph The target graph.
 * @param {?} targetOwner The port owner in the target graph to add the port to.
 * @param {?} sourcePort The source port in the source graph.
 * @return {?} The newly created port.
 */
yfiles.graph.GraphCopier.prototype.addPort = function(sourceGraph, targetGraph, targetOwner, sourcePort) {};

/**
 * This method places the given copy into an internal cache.
 * <p>
 * The cache can be queried using {\@link yfiles.graph.GraphCopier#getCopy}. The cache is held until {\@link yfiles.graph.GraphCopier#clearCopyCache}
 * is called.
 * </p>
 * Type parameter <code>T</code>: The type of the item to cache.
 * @see yfiles.graph.GraphCopier#getOrCreateCopy
 * @protected
 * @template T
 * @param {T} original The original item.
 * @param {T} copy The copy of the item.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.cacheCopy = function(original, copy) {};

/**
 * Clears the cache for the {\@link yfiles.graph.GraphCopier#cacheCopy cached copies} of the instance copied using this class.
 * <p>
 * This method is called before and after a copy operation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.clearCopyCache = function() {};

/**
 * Copies a subgraph induced by a predicate from the <code>sourceGraph</code> to the <code>targetGraph</code>.
 * <p>
 * For each element that has been copied, the <code>elementCopiedCallback</code> will be invoked.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if <code>targetRootNode</code> is not in <code>targetGraph</code>
 * Copies a subgraph described by a predicate from the <code>sourceGraph</code> to the <code>targetGraph</code>.
 * <p>
 * For each element that has been copied, the <code>elementCopiedCallback</code> will be invoked. This method actually delegates to {\@link yfiles.graph.GraphCopier#copy}
 * and provides the root as the "targetGraph" parameter if there is a hierarchy associated with <code>targetGraph</code>.
 * </p>
 * Copies <code>sourceGraph</code> to <code>targetGraph</code>.
 * <p>
 * This method actually delegates to {\@link yfiles.graph.GraphCopier#copy} and provides the root as the "targetGraph" parameter if
 * there is a hierarchy associated with <code>targetGraph</code>.
 * </p>
 * @param {?} sourceGraph The graph to copy the elements from. / The graph to copy.
 * @param {function(?): boolean|?} filter_or_targetGraph The filter that decides which elements to copy. / The graph to copy to.
 * @param {?=} targetGraph The graph to copy the elements to.
 * @param {?|!yfiles.geometry.Point=} targetRootNode_or_offset The group node that should act as the root node for the pasted elements. May be <code>null</code> if there is no such node. / The offset to apply to the copied items. Only nodes and bends will be offset explicitly, while other items will move
 * implicitly.
 * @param {!yfiles.geometry.Point|function(?, ?): void=} offset_or_elementCopiedCallback The offset to apply to the copied items. Only nodes and bends will be offset explicitly, while other items will move
 * implicitly. / A delegate to invoke for each element being copied.
 * @param {function(?, ?): void=} elementCopiedCallback A delegate to invoke for each element being copied.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.copy = function(sourceGraph, filter_or_targetGraph, targetGraph, targetRootNode_or_offset, offset_or_elementCopiedCallback, elementCopiedCallback) {};

/**
 * Callback method that adds an edge to the targetGraph as a copy of the source edge.
 * <p>
 * This implementation does not need to copy the {\@link yfiles.graph.IBend}s of the <code>sourceEdge</code>, nor should it copy
 * {\@link yfiles.graph.IPort}s or {\@link yfiles.graph.ILabel}s. This implementation uses {\@link yfiles.graph.GraphCopier#copyEdgeStyle} and {\@link yfiles.graph.GraphCopier#copyEdgeTag}
 * as callbacks.
 * </p>
 * @protected
 * @param {?} sourceGraph The source graph.
 * @param {?} targetGraph The target graph.
 * @param {?} sourceEdge The edge in the source graph.
 * @param {?} targetSourcePort The new source port in the target graph.
 * @param {?} targetTargetPort The new target port in the target graph.
 * @return {?} The newly created edge.
 */
yfiles.graph.GraphCopier.prototype.copyEdge = function(sourceGraph, targetGraph, sourceEdge, targetSourcePort, targetTargetPort) {};

/**
 * Copies an {\@link yfiles.styles.IEdgeStyle} instance.
 * <p>
 * This implementation uses the {\@link yfiles.lang.ICloneable#clone} method to create a copy.
 * </p>
 * @see yfiles.graph.GraphCopier#copy
 * @param {?} graph The graph that contains the edge.
 * @param {?} edge The edge to copy the style from.
 * @return {?} The style to apply for the copy.
 */
yfiles.graph.GraphCopier.prototype.copyEdgeStyle = function(graph, edge) {};

/**
 * Callback that copies the {\@link yfiles.graph.ITagOwner#tag} of an {\@link yfiles.graph.IEdge}.
 * <p>
 * This implementation simply delegates to {\@link yfiles.graph.GraphCopier#copyTag}
 * </p>
 * @protected
 * @param {?} edge The old edge.
 * @param {!Object} tag The tag to copy.
 * @return {!Object} The copy of the tag.
 */
yfiles.graph.GraphCopier.prototype.copyEdgeTag = function(edge, tag) {};

/**
 * Callback method that creates a copy of the <code>sourceGroupNode</code> in the <code>targetGraph</code>.
 * <p>
 * This implementation does not need to copy {\@link yfiles.graph.IPort}s or {\@link yfiles.graph.ILabel}s. This implementation uses {\@link yfiles.graph.GraphCopier#copyNodeStyle}
 * and {\@link yfiles.graph.GraphCopier#copyNodeTag} as callbacks.
 * </p>
 * @protected
 * @param {?} sourceGraph The source graph.
 * @param {?} targetGraph The target graph.
 * @param {?} sourceGroupNode The source node to create a copy of in the <code>targetGraph</code>.
 * @param {?} targetParent The parent of the group node in the target graph.
 * @param {!yfiles.geometry.Point} offset The offset to apply to the copied node.
 * @return {?} The newly created node.
 */
yfiles.graph.GraphCopier.prototype.copyGroupNode = function(sourceGraph, targetGraph, sourceGroupNode, targetParent, offset) {};

/**
 * Copies a {\@link yfiles.graph.ILabelModelParameter} for a given label.
 * <p>
 * This implementation uses the {\@link yfiles.lang.ICloneable#clone} method to create a copy.
 * </p>
 * @see yfiles.graph.GraphCopier#copy
 * @param {?} graph The graph that contains the label.
 * @param {?} label The label to copy the label model parameter from.
 * @return {?} The copy of the parameter to apply for the copy.
 */
yfiles.graph.GraphCopier.prototype.copyLabelLayoutParameter = function(graph, label) {};

/**
 * Copies an {\@link yfiles.styles.ILabelStyle} instance.
 * <p>
 * This implementation uses the {\@link yfiles.lang.ICloneable#clone} method to create a copy.
 * </p>
 * @see yfiles.graph.GraphCopier#copy
 * @param {?} graph The graph that contains the label.
 * @param {?} label The label to copy the style from.
 * @return {?} The style to apply for the copy.
 */
yfiles.graph.GraphCopier.prototype.copyLabelStyle = function(graph, label) {};

/**
 * Callback that copies the {\@link yfiles.graph.ITagOwner#tag} of a {\@link yfiles.graph.ILabel}.
 * <p>
 * This implementation simply delegates to {\@link yfiles.graph.GraphCopier#copyTag}
 * </p>
 * @param {?} label The old label.
 * @param {!Object} tag The tag to copy.
 * @return {!Object} The copy of the tag.
 */
yfiles.graph.GraphCopier.prototype.copyLabelTag = function(label, tag) {};

/**
 * Callback method that creates a copy of the <code>node</code> in the <code>targetGraph</code>.
 * <p>
 * This implementation does not need to copy {\@link yfiles.graph.IPort}s or {\@link yfiles.graph.ILabel}s. This implementation uses {\@link yfiles.graph.GraphCopier#copyNodeStyle}
 * and {\@link yfiles.graph.GraphCopier#copyNodeTag} as callbacks.
 * </p>
 * @protected
 * Callback method that creates a copy of the <code>node</code> in the <code>targetGraph</code>.
 * <p>
 * This implementation does not need to copy {\@link yfiles.graph.IPort}s or {\@link yfiles.graph.ILabel}s. This implementation uses {\@link yfiles.graph.GraphCopier#copyNodeStyle}
 * and {\@link yfiles.graph.GraphCopier#copyNodeTag} as callbacks.
 * </p>
 * @protected
 * @param {?} sourceGraph The source graph.
 * @param {?} targetGraph The target graph.
 * @param {?} node The source node to create a copy of in the <code>targetGraph</code>.
 * @param {?|!yfiles.geometry.Point} targetParent_or_offset The parent of the group node in the target graph. / The offset to apply to the copied node.
 * @param {!yfiles.geometry.Point=} offset The offset to apply to the copied node.
 * @return {?} The newly created node.
 */
yfiles.graph.GraphCopier.prototype.copyNode = function(sourceGraph, targetGraph, node, targetParent_or_offset, offset) {};

/**
 * Copies an {\@link yfiles.styles.INodeStyle} instance.
 * <p>
 * This implementation uses the {\@link yfiles.lang.ICloneable#clone} method to create a copy.
 * </p>
 * @see yfiles.graph.GraphCopier#copy
 * @param {?} graph The graph that contains the node.
 * @param {?} node The node to copy the style from.
 * @return {?} The style to apply for the copy.
 */
yfiles.graph.GraphCopier.prototype.copyNodeStyle = function(graph, node) {};

/**
 * Callback that copies the {\@link yfiles.graph.ITagOwner#tag} of a {\@link yfiles.graph.INode}.
 * <p>
 * This implementation simply delegates to {\@link yfiles.graph.GraphCopier#copyTag}
 * </p>
 * @protected
 * @param {?} node The old node.
 * @param {!Object} tag The tag to copy.
 * @return {!Object} The copy of the tag.
 */
yfiles.graph.GraphCopier.prototype.copyNodeTag = function(node, tag) {};

/**
 * Copies a {\@link yfiles.graph.IPortLocationModelParameter} for a given port.
 * <p>
 * This implementation uses the {\@link yfiles.lang.ICloneable#clone} method to create a copy.
 * </p>
 * @see yfiles.graph.GraphCopier#copy
 * @param {?} graph The graph that contains the port.
 * @param {?} port The port to copy the model parameter from.
 * @return {?} The copy of the parameter to apply for the copy.
 */
yfiles.graph.GraphCopier.prototype.copyPortLocationParameter = function(graph, port) {};

/**
 * Copies an {\@link yfiles.styles.IPortStyle} instance.
 * <p>
 * This implementation uses the {\@link yfiles.lang.ICloneable#clone} method to create a copy.
 * </p>
 * @see yfiles.graph.GraphCopier#copy
 * @param {?} graph The graph that contains the port.
 * @param {?} port The port to copy the style from.
 * @return {?} The style to apply for the copy.
 */
yfiles.graph.GraphCopier.prototype.copyPortStyle = function(graph, port) {};

/**
 * Callback that copies the {\@link yfiles.graph.ITagOwner#tag} of a {\@link yfiles.graph.IPort}.
 * <p>
 * This implementation simply delegates to {\@link yfiles.graph.GraphCopier#copyTag}
 * </p>
 * @protected
 * @param {?} port The old port.
 * @param {!Object} tag The tag to copy.
 * @return {!Object} The copy of the tag.
 */
yfiles.graph.GraphCopier.prototype.copyPortTag = function(port, tag) {};

/**
 * Callback that will copy a {\@link yfiles.graph.ITagOwner#tag} for the target graph.
 * <p>
 * This implementation will try to {\@link yfiles.lang.ICloneable#clone} the <code>tag</code> if the {\@link yfiles.graph.GraphCopier#clone} property has the {\@link yfiles.graph.CloneTypes#TAGS}
 * flag set. If this is not the case or the tag is not {\@link yfiles.lang.ICloneable}, the instance will be returned.
 * </p>
 * @param {?} owner The old owner of the tag.
 * @param {!Object} tag The tag to copy.
 * @return {!Object} A copy of the tag.
 */
yfiles.graph.GraphCopier.prototype.copyTag = function(owner, tag) {};

/**
 * Tries to obtain a previously {\@link yfiles.graph.GraphCopier#cacheCopy cached} copy for the given original.
 * <p>
 * Values will be stored in the cache until the next call to {\@link yfiles.graph.GraphCopier#clearCopyCache}. In order to indicate
 * that no copy is available, this implementation yields {\@link yfiles.graph.GraphCopier#NO_COPY}. In contrast, <code>null</code> is a valid
 * return value that is the copied value of the original.
 * </p>
 * Type parameter <code>T</code>: The type of the item to copy.
 * @see yfiles.graph.GraphCopier#cacheCopy
 * @see yfiles.graph.GraphCopier#getOrCreateCopy
 * @protected
 * @template T
 * @param {!yfiles.lang.Class} itemType The type of the item to copy.
 * @param {T} original The original item.
 * @return {T} The copy of <code>original</code> or {\@link #NO_COPY} if no copy has been found.
 */
yfiles.graph.GraphCopier.prototype.getCopy = function(itemType, original) {};

/**
 * Convenience method that either yields a previously {\@link yfiles.graph.GraphCopier#cacheCopy cached} copy for the given original or uses the <code>copyDelegate</code> to create
 * the copy of the original.
 * <p>
 * If there is a cache miss, the delegate will be used to create the copy and the copy will be placed into the {\@link yfiles.graph.GraphCopier#cacheCopy cache}.
 * </p>
 * Type parameter <code>T</code>: The type of the item to copy.
 * @template T
 * @param {!yfiles.lang.Class} tType The type of the item to copy.
 * @param {T} original The original item.
 * @param {function(T): T} copyDelegate The copy delegate to create the copy.
 * @return {T} A copy of the original, either cached, or newly created and then cached.
 */
yfiles.graph.GraphCopier.prototype.getOrCreateCopy = function(tType, original, copyDelegate) {};

/**
 * Called after a bend has been copied.
 * <p>
 * Raises the {\@link yfiles.graph.GraphCopier#addBendCopiedListener BendCopied} event.
 * </p>
 * @param {?} original The original of the copied bend.
 * @param {?} copy The copied bend.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.onBendCopied = function(original, copy) {};

/**
 * Called after an edge has been copied.
 * <p>
 * Raises the {\@link yfiles.graph.GraphCopier#addEdgeCopiedListener EdgeCopied} event.
 * </p>
 * @protected
 * @param {?} original The original of the copied edge.
 * @param {?} copy The copied edge.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.onEdgeCopied = function(original, copy) {};

/**
 * Called after the entire graph has been copied.
 * <p>
 * Raises the {\@link yfiles.graph.GraphCopier#addGraphCopiedListener GraphCopied} event.
 * </p>
 * @protected
 * @param {?} sourceGraph The source graph from which the elements have been copied.
 * @param {?} targetGraph The graph to which the elements have been copied.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.onGraphCopied = function(sourceGraph, targetGraph) {};

/**
 * Called after a label has been copied.
 * <p>
 * Raises the {\@link yfiles.graph.GraphCopier#addLabelCopiedListener LabelCopied} event.
 * </p>
 * @param {?} original The original of the copied label.
 * @param {?} copy The copied label.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.onLabelCopied = function(original, copy) {};

/**
 * Called after a node has been copied.
 * <p>
 * Raises the {\@link yfiles.graph.GraphCopier#addNodeCopiedListener NodeCopied} event.
 * </p>
 * @protected
 * @param {?} original The original of the copied node.
 * @param {?} copy The copied node.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.onNodeCopied = function(original, copy) {};

/**
 * Emits the {\@link yfiles.graph.GraphCopier#addObjectCopiedListener ObjectCopied} event.
 * @protected
 * @param {!yfiles.graph.ItemCopiedEventArgs<!Object>} evt The argument to use.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.onObjectCopied = function(evt) {};

/**
 * Called after a port has been copied.
 * <p>
 * Raises the {\@link yfiles.graph.GraphCopier#addPortCopiedListener PortCopied} event.
 * </p>
 * @param {?} original The original of the copied port.
 * @param {?} copy The copied port.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.onPortCopied = function(original, copy) {};

/**
 * Adds the given listener for the <code>NodeCopied</code> event that occurs after a node has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * @see yfiles.graph.GraphCopier#removeNodeCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.addNodeCopiedListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeCopied</code> event that occurs after a node has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * @see yfiles.graph.GraphCopier#addNodeCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.removeNodeCopiedListener = function(listener) {};

/**
 * Adds the given listener for the <code>BendCopied</code> event that occurs after a bend has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * For {\@link yfiles.graph.FoldingManager#getFoldingEdgeState folding edge} bends, their view state representation is passed. These elements are neither part of the {\@link yfiles.graph.FoldingManager#masterGraph} nor the
 * {\@link yfiles.graph.FoldingManager#views view graph}.
 * </p>
 * @see yfiles.graph.GraphCopier#removeBendCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.addBendCopiedListener = function(listener) {};

/**
 * Removes the given listener for the <code>BendCopied</code> event that occurs after a bend has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * For {\@link yfiles.graph.FoldingManager#getFoldingEdgeState folding edge} bends, their view state representation is passed. These elements are neither part of the {\@link yfiles.graph.FoldingManager#masterGraph} nor the
 * {\@link yfiles.graph.FoldingManager#views view graph}.
 * </p>
 * @see yfiles.graph.GraphCopier#addBendCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.removeBendCopiedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ObjectCopied</code> event that occurs after a style has been copied.
 * <p>
 * This event is triggered for all minor objects the graph items are made up of, e.g. the {\@link yfiles.graph.GraphCopier#copyNodeStyle styles}, {\@link yfiles.graph.GraphCopier#copyTag tags}, {\@link yfiles.graph.GraphCopier#copyLabelLayoutParameter labels}, and {\@link yfiles.graph.GraphCopier#copyPortLocationParameter port}
 * parameters.
 * </p>
 * <p>
 * This event will <b>not</b> be triggered for the graph items themselves and will not be triggered if the object reference is
 * reused, i.e. it will only be triggered if the old and new references actually differ.
 * </p>
 * @see yfiles.graph.GraphCopier#removeObjectCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<!Object>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.addObjectCopiedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ObjectCopied</code> event that occurs after a style has been copied.
 * <p>
 * This event is triggered for all minor objects the graph items are made up of, e.g. the {\@link yfiles.graph.GraphCopier#copyNodeStyle styles}, {\@link yfiles.graph.GraphCopier#copyTag tags}, {\@link yfiles.graph.GraphCopier#copyLabelLayoutParameter labels}, and {\@link yfiles.graph.GraphCopier#copyPortLocationParameter port}
 * parameters.
 * </p>
 * <p>
 * This event will <b>not</b> be triggered for the graph items themselves and will not be triggered if the object reference is
 * reused, i.e. it will only be triggered if the old and new references actually differ.
 * </p>
 * @see yfiles.graph.GraphCopier#addObjectCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<!Object>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.removeObjectCopiedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeCopied</code> event that occurs after an edge has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * @see yfiles.graph.GraphCopier#removeEdgeCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.addEdgeCopiedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeCopied</code> event that occurs after an edge has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * @see yfiles.graph.GraphCopier#addEdgeCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.removeEdgeCopiedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortCopied</code> event that occurs after a port has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * @see yfiles.graph.GraphCopier#removePortCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.addPortCopiedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortCopied</code> event that occurs after a port has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * @see yfiles.graph.GraphCopier#addPortCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.removePortCopiedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelCopied</code> event that occurs after a label has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * For {\@link yfiles.graph.FoldingManager#getFoldingEdgeState folding edge} or dummy node labels, their view state representation is passed. These elements are neither part of the
 * {\@link yfiles.graph.FoldingManager#masterGraph} nor the {\@link yfiles.graph.FoldingManager#views view graph}.
 * </p>
 * @see yfiles.graph.GraphCopier#removeLabelCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.addLabelCopiedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelCopied</code> event that occurs after a label has been copied.
 * <p>
 * This event is dispatched after the element copied callback has been executed.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original original} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy copied} item is a master item, i.e. it belongs to the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * </p>
 * <p>
 * For {\@link yfiles.graph.FoldingManager#getFoldingEdgeState folding edge} or dummy node labels, their view state representation is passed. These elements are neither part of the
 * {\@link yfiles.graph.FoldingManager#masterGraph} nor the {\@link yfiles.graph.FoldingManager#views view graph}.
 * </p>
 * @see yfiles.graph.GraphCopier#addLabelCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.removeLabelCopiedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GraphCopied</code> event that occurs after the entire graph has been copied.
 * <p>
 * This event is dispatched at the end of the {\@link yfiles.graph.GraphCopier#copy} method.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original source graph} item is the {\@link yfiles.graph.FoldingManager#masterGraph master graph} of the folding view.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy target graph} is the {\@link yfiles.graph.FoldingManager#masterGraph master graph} of the folding view.
 * </p>
 * @see yfiles.graph.GraphCopier#removeGraphCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.addGraphCopiedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphCopied</code> event that occurs after the entire graph has been copied.
 * <p>
 * This event is dispatched at the end of the {\@link yfiles.graph.GraphCopier#copy} method.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#toClipboardCopier} (Cut/Copy) and the source graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#original source graph} item is the {\@link yfiles.graph.FoldingManager#masterGraph master graph} of the folding view.
 * </p>
 * <p>
 * If this GraphCopier instance is used as {\@link yfiles.graph.GraphClipboard}'s {\@link yfiles.graph.GraphClipboard#fromClipboardCopier} (Paste) and the target graph is a folding view
 * graph the {\@link yfiles.graph.ItemCopiedEventArgs.<T>#copy target graph} is the {\@link yfiles.graph.FoldingManager#masterGraph master graph} of the folding view.
 * </p>
 * @see yfiles.graph.GraphCopier#addGraphCopiedListener
 * @param {function(!Object, !yfiles.graph.ItemCopiedEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.GraphCopier.prototype.removeGraphCopiedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graph.ItemCopiedEventArgs = function() {};
 /** @type {T} */
yfiles.graph.ItemCopiedEventArgs.prototype.original;
 /** @type {T} */
yfiles.graph.ItemCopiedEventArgs.prototype.copy;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.ItemCopiedEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.GraphDecorator = function() {};
 /** @type {!yfiles.graph.NodeDecorator} */
yfiles.graph.GraphDecorator.prototype.nodeDecorator;
 /** @type {!yfiles.graph.EdgeDecorator} */
yfiles.graph.GraphDecorator.prototype.edgeDecorator;
 /** @type {!yfiles.graph.LabelDecorator} */
yfiles.graph.GraphDecorator.prototype.labelDecorator;
 /** @type {!yfiles.graph.PortDecorator} */
yfiles.graph.GraphDecorator.prototype.portDecorator;
 /** @type {!yfiles.graph.BendDecorator} */
yfiles.graph.GraphDecorator.prototype.bendDecorator;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.GraphDecorator.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.LabelDecorator = function() {};
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.positionHandlerDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.clipboardHelperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.marqueeTestableDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.mementoSupportDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.selectionDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.highlightDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.focusIndicatorDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.handleProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.obstacleProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.labelModelParameterFinderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.editLabelHelperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.labelModelParameterProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.LabelDecorator.prototype.labelSnapContextHelperDecorator;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.LabelDecorator.$class;

/**
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.ILabel}s that can be used to decorate <code>TInterface</code> types of the labels.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.ILabel}s that can be used to decorate <code>TInterface</code> types of the labels.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * @template TInterface
 * @param {!yfiles.lang.Class|{type: !yfiles.lang.Class, decorateNulls: boolean, nullIsFallback: boolean}} type_or_options The type of the interface that should be decorated of the instances' {\@link #lookup}.
 * @param {boolean=} decorateNulls
 * @param {boolean=} nullIsFallback
 * @return {!yfiles.graph.LookupDecorator<?, TInterface>} A new {\@link } for the specified interface.
 */
yfiles.graph.LabelDecorator.prototype.getDecoratorFor = function(type_or_options, decorateNulls, nullIsFallback) {};
/**
 * @record
 * @struct
 */
yfiles.graph.EdgeDecorator = function() {};
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.edgeReconnectionPortCandidateProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.portCandidateProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.edgePortHandleProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.orthogonalEdgeHelperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.edgeSnapResultProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.editLabelHelperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.bendCreatorDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.bendSelectionTesterDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.snapLineProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.positionHandlerDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.clipboardHelperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.marqueeTestableDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.mementoSupportDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.selectionDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.highlightDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.focusIndicatorDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.handleProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.EdgeDecorator.prototype.obstacleProviderDecorator;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.EdgeDecorator.$class;

/**
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.IEdge}s that can be used to decorate <code>TInterface</code> types of the edges.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.IEdge}s that can be used to decorate <code>TInterface</code> types of the edges.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * @template TInterface
 * @param {!yfiles.lang.Class|{type: !yfiles.lang.Class, decorateNulls: boolean, nullIsFallback: boolean}} type_or_options The type of the interface that should be decorated of the instances' {\@link #lookup}.
 * @param {boolean=} decorateNulls
 * @param {boolean=} nullIsFallback
 * @return {!yfiles.graph.LookupDecorator<?, TInterface>} A new {\@link } for the specified interface.
 */
yfiles.graph.EdgeDecorator.prototype.getDecoratorFor = function(type_or_options, decorateNulls, nullIsFallback) {};
/**
 * @record
 * @struct
 */
yfiles.graph.BendDecorator = function() {};
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.handleDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.bendSnapResultProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.positionHandlerDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.clipboardHelperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.marqueeTestableDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.mementoSupportDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.selectionDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.highlightDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.focusIndicatorDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.handleProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.BendDecorator.prototype.obstacleProviderDecorator;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.BendDecorator.$class;

/**
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.IBend}s that can be used to decorate <code>TInterface</code> types of the bends.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.IBend}s that can be used to decorate <code>TInterface</code> types of the bends.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * @template TInterface
 * @param {!yfiles.lang.Class|{type: !yfiles.lang.Class, decorateNulls: boolean, nullIsFallback: boolean}} type_or_options The type of the interface that should be decorated of the instances' {\@link #lookup}.
 * @param {boolean=} decorateNulls
 * @param {boolean=} nullIsFallback
 * @return {!yfiles.graph.LookupDecorator<?, TInterface>} A new {\@link } for the specified interface.
 */
yfiles.graph.BendDecorator.prototype.getDecoratorFor = function(type_or_options, decorateNulls, nullIsFallback) {};
/**
 * @record
 * @struct
 */
yfiles.graph.PortDecorator = function() {};
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.handleDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.edgePathCropperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.snapLineProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.portSnapResultProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.positionHandlerDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.clipboardHelperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.marqueeTestableDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.mementoSupportDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.selectionDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.highlightDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.focusIndicatorDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.handleProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.PortDecorator.prototype.obstacleProviderDecorator;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.PortDecorator.$class;

/**
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.IPort}s that can be used to decorate <code>TInterface</code> types of the ports.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.IPort}s that can be used to decorate <code>TInterface</code> types of the ports.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * @template TInterface
 * @param {!yfiles.lang.Class|{type: !yfiles.lang.Class, decorateNulls: boolean, nullIsFallback: boolean}} type_or_options The type of the interface that should be decorated of the instances' {\@link #lookup}.
 * @param {boolean=} decorateNulls
 * @param {boolean=} nullIsFallback
 * @return {!yfiles.graph.LookupDecorator<?, TInterface>} A new {\@link } for the specified interface.
 */
yfiles.graph.PortDecorator.prototype.getDecoratorFor = function(type_or_options, decorateNulls, nullIsFallback) {};
/**
 * @record
 * @struct
 */
yfiles.graph.NodeDecorator = function() {};
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.reshapeHandleProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.editLabelHelperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.shapeGeometryDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.sizeConstraintProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.groupBoundsCalculatorDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.insetsProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.portCandidateProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.snapLineProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.nodeSnapResultProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.nodeReshapeSnapResultProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.positionHandlerDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.clipboardHelperDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.marqueeTestableDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.mementoSupportDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.selectionDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.highlightDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.focusIndicatorDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.handleProviderDecorator;
 /** @type {!yfiles.graph.LookupDecorator<?, ?>} */
yfiles.graph.NodeDecorator.prototype.obstacleProviderDecorator;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.NodeDecorator.$class;

/**
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.INode}s that can be used to decorate <code>TInterface</code> types of the nodes.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * Creates a {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>} for {\@link yfiles.graph.INode}s that can be used to decorate <code>TInterface</code> types of the nodes.
 * Type parameter <code>TInterface</code>: The type of the interface that should be decorated of the instances' {\@link yfiles.graph.ILookup#lookup}.
 * @template TInterface
 * @param {!yfiles.lang.Class|{type: !yfiles.lang.Class, decorateNulls: boolean, nullIsFallback: boolean}} type_or_options The type of the interface that should be decorated of the instances' {\@link #lookup}.
 * @param {boolean=} decorateNulls
 * @param {boolean=} nullIsFallback
 * @return {!yfiles.graph.LookupDecorator<?, TInterface>} A new {\@link } for the specified interface.
 */
yfiles.graph.NodeDecorator.prototype.getDecoratorFor = function(type_or_options, decorateNulls, nullIsFallback) {};
/**
 * @record
 * @struct
 */
yfiles.graph.LookupDecorator = function() {};
 /** @type {?} */
yfiles.graph.LookupDecorator.prototype.decorator;
 /** @type {boolean} */
yfiles.graph.LookupDecorator.prototype.decorateNulls;
 /** @type {boolean} */
yfiles.graph.LookupDecorator.prototype.nullIsFallback;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.LookupDecorator.$class;

/**
 * Simple helper method that tries to add the provided chain link to the {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#decorator}.
 * @see yfiles.graph.ILookupDecorator#addLookup
 * @param {?} lookup The link to add.
 * @return {?} The <code>lookup</code> that has been {\@link #addLookup added} to the {\@link #decorator} as a result of this call, or <code>null</code> if the decoration was unsuccessful.
 */
yfiles.graph.LookupDecorator.prototype.addChainLink = function(lookup) {};

/**
 * Amends the {\@link yfiles.graph.IContextLookupChainLink lookup chain} for all <code>TDecoratedType</code> items matching a <code>predicate</code> to return <code>null</code> if <code>TInterface</code> is queried during the
 * {\@link yfiles.graph.ILookup#lookup}.
 * <p>
 * This can be used to temporarily or permanently disable a certain behavior for all items. To do this only for items
 * matching a predicate, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#hideImplementation} instead.
 * </p>
 * <p>
 * The effects of this method call can be undone by passing the return value to
 * {\@link yfiles.graph.ILookupDecorator#removeLookup}.
 * </p>
 * @see yfiles.graph.ILookupDecorator#addLookup
 * @param {function(TDecoratedType): boolean=} predicate
 * @return {?} An {\@link } that has been {\@link #addLookup added} to the {\@link #decorator} as a result of this call, or <code>null</code> if decoration was
 * unsuccessful.
 */
yfiles.graph.LookupDecorator.prototype.hideImplementation = function(predicate) {};

/**
 * Amends the {\@link yfiles.graph.IContextLookupChainLink lookup chain} for items matching a <code>predicate</code> with a <code>factory</code> that creates a <code>TInterface</code> instance if <code>TInterface</code> is queried during the
 * {\@link yfiles.graph.ILookup#lookup}.
 * <p>
 * This can be used to modify the lookup of all items matching a certain predicate where the returned instance either
 * depends on the item or uses it in some way.
 * </p>
 * <p>
 * To adjust the lookup of all items in this manner, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setFactory} instead. To adjust the lookup of a single item, use
 * {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation}.
 * </p>
 * <p>
 * Note that depending on the value of the {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#nullIsFallback} property a <code>null</code> return value from the <code>factory</code> will be either returned directly,
 * or interpreted as a hint to return a fallback value which is obtained by querying the remainder of the lookup chain.
 * </p>
 * <p>
 * The effects of this method call can be undone by passing the return value to
 * {\@link yfiles.graph.ILookupDecorator#removeLookup}.
 * </p>
 * @see yfiles.graph.ILookupDecorator#addLookup
 * @see yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#nullIsFallback
 * Amends the {\@link yfiles.graph.IContextLookupChainLink lookup chain} for all <code>TDecoratedType</code> items, so that <code>factory</code> is used to create a <code>TInterface</code> instance if <code>TInterface</code> is queried during the
 * {\@link yfiles.graph.ILookup#lookup}.
 * <p>
 * This can be used to modify the lookup of all items where the returned instance either depends on the item or uses it in
 * some way.
 * </p>
 * <p>
 * To only adjust the lookup of items matching a predicate in this manner, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setFactory} instead. To adjust the lookup of
 * a single item, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation}.
 * </p>
 * <p>
 * Note that depending on the value of the {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#nullIsFallback} property a <code>null</code> return value from the <code>factory</code> will be either returned directly,
 * or interpreted as a hint to return a fallback value which is obtained by querying the remainder of the lookup chain.
 * </p>
 * <p>
 * The effects of this method call can be undone by passing the return value to
 * {\@link yfiles.graph.ILookupDecorator#removeLookup}.
 * </p>
 * @see yfiles.graph.ILookupDecorator#addLookup
 * @see yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#nullIsFallback
 * @param {function(TDecoratedType): boolean|function(TDecoratedType): TInterface} predicate_or_factory The predicate that determines for which items the factory shall be called. / The factory that is queried to create the result.
 * @param {function(TDecoratedType): TInterface=} factory The factory that is queried to create the result.
 * @return {?} An {\@link } that has been {\@link #addLookup added} to the {\@link #decorator} as a result of this call, or <code>null</code> if decoration was
 * unsuccessful.
 */
yfiles.graph.LookupDecorator.prototype.setFactory = function(predicate_or_factory, factory) {};

/**
 * Amends the {\@link yfiles.graph.IContextLookupChainLink lookup chain} for all items matching a <code>predicate</code> with a fixed <code>TInterface</code> <code>implementation</code> if <code>TInterface</code> is queried on an item's
 * {\@link yfiles.graph.ILookup#lookup}.
 * <p>
 * This can be used to modify the lookup of all items matching a certain predicate in the same way.
 * </p>
 * <p>
 * To adjust the lookup of only a single item, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation} instead. To adjust the lookup of all items, use
 * {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation}.
 * </p>
 * <p>
 * The effects of this method call can be undone by passing the return value to
 * {\@link yfiles.graph.ILookupDecorator#removeLookup}.
 * </p>
 * @see yfiles.graph.ILookupDecorator#addLookup
 * Amends the {\@link yfiles.graph.IContextLookupChainLink lookup chain} for a single item with a fixed <code>TInterface</code> <code>implementation</code> if <code>TInterface</code> is queried on the <code>item</code>'s
 * {\@link yfiles.graph.ILookup#lookup}.
 * <p>
 * This can be used to modify the lookup of a single item only.
 * </p>
 * <p>
 * To adjust the lookup of all items matching a predicate, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation} instead. To adjust the lookup of all
 * items, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation}.
 * </p>
 * <p>
 * The effects of this method call can be undone by passing the return value to
 * {\@link yfiles.graph.ILookupDecorator#removeLookup}.
 * </p>
 * @see yfiles.graph.ILookupDecorator#addLookup
 * Amends the {\@link yfiles.graph.IContextLookupChainLink lookup chain}, so that <code>implementation</code> is always returned if <code>TInterface</code> is queried on an item's
 * {\@link yfiles.graph.ILookup#lookup}.
 * <p>
 * This can be used to modify the lookup of all items in the same way.
 * </p>
 * <p>
 * To adjust the lookup of only a single item, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation} instead. To adjust the lookup of all items matching a
 * certain predicate, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation}.
 * </p>
 * <p>
 * The effects of this method call can be undone by passing the return value to
 * {\@link yfiles.graph.ILookupDecorator#removeLookup}.
 * </p>
 * @see yfiles.graph.ILookupDecorator#addLookup
 * @param {function(TDecoratedType): boolean|TDecoratedType|TInterface} predicate_or_item_or_implementation A predicate that determines which items are affected. / The item for which the implementation shall be returned. / The implementation to return unconditionally.
 * @param {TInterface=} implementation The implementation to return if the <code>predicate</code> matches and <code>TInterface</code> is queried. / The implementation to return if <code>item</code> is queried for <code>TInterface</code>.
 * @return {?} An {\@link } that has been {\@link #addLookup added} to the {\@link #decorator} as a result of this call, or <code>null</code> if decoration was
 * unsuccessful.
 */
yfiles.graph.LookupDecorator.prototype.setImplementation = function(predicate_or_item_or_implementation, implementation) {};

/**
 * Amends the {\@link yfiles.graph.IContextLookupChainLink lookup chain} for all items matching a <code>predicate</code> with a <code>factory</code> callback that wraps the underlying
 * implementation if <code>TInterface</code> is queried during the {\@link yfiles.graph.ILookup#lookup}.
 * <p>
 * This can be used to modify the lookup of all items matching a certain predicate where the factory implementation may
 * delegate to the wrapped implementation in certain cases.
 * </p>
 * <p>
 * To adjust the lookup for all items in this manner, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementationWrapper} instead. To adjust the lookup of a
 * single item, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation}.
 * </p>
 * <p>
 * Note that depending on the value of the {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#decorateNulls} property, the factory will not not be called to decorate <code>null</code> results.
 * </p>
 * <p>
 * The effects of this method call can be undone by passing the return value to
 * {\@link yfiles.graph.ILookupDecorator#removeLookup}.
 * </p>
 * @see yfiles.graph.ILookupDecorator#addLookup
 * Amends the {\@link yfiles.graph.IContextLookupChainLink lookup chain} for all items with a <code>factory</code> callback that wraps the underlying implementation if <code>TInterface</code> is queried
 * during the {\@link yfiles.graph.ILookup#lookup}.
 * <p>
 * This can be used to modify the lookup of all items matching where the factory implementation may delegate to the wrapped
 * implementation in certain cases.
 * </p>
 * <p>
 * To adjust the lookup in this manner only for items matching a predicate, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementationWrapper} instead. To
 * adjust the lookup of a single item, use {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#setImplementation}.
 * </p>
 * <p>
 * Note that depending on the value of the {\@link yfiles.graph.LookupDecorator.<TDecoratedType,TInterface>#decorateNulls} property, the factory will not not be called to decorate <code>null</code> results.
 * </p>
 * <p>
 * The effects of this method call can be undone by passing the return value to
 * {\@link yfiles.graph.ILookupDecorator#removeLookup}.
 * </p>
 * @see yfiles.graph.ILookupDecorator#addLookup
 * @param {function(TDecoratedType): boolean|function(TDecoratedType, TInterface): TInterface} predicate_or_factory The predicate that determines for which items the wrapping shall be performed. / The factory that will be passed the underlying implementation and that is queried to create the result.
 * @param {function(TDecoratedType, TInterface): TInterface=} factory The factory that will be passed the underlying implementation and that is queried to create the result.
 * @return {?} An {\@link } that has been {\@link #addLookup added} to the {\@link #decorator} as a result of this call, or <code>null</code> if decoration was
 * unsuccessful.
 */
yfiles.graph.LookupDecorator.prototype.setImplementationWrapper = function(predicate_or_factory, factory) {};
/**
 * @record
 * @struct
 */
yfiles.graph.GroupingSupport = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graph.GroupingSupport.$class;

/**
 * Calculates the minimum area to enclose by the given group node with respect to its {\@link yfiles.graph.IGroupBoundsCalculator}.
 * @param {?} groupNode The group node to calculate the minimum enclosed area of.
 * @return {!yfiles.geometry.Rect} The area to enclose for the given group node. This is {\@link #EMPTY} if the node is not a group node, or if
 * it hasn't any children.
 */
yfiles.graph.GroupingSupport.prototype.calculateMinimumEnclosedArea = function(groupNode) {};

/**
 * Enlarges all group nodes in the graph in an interactive scenario, so that the {\@link yfiles.graph.GroupingSupport#calculateMinimumEnclosedArea minimum enclosed area} is respected.
 * <p>
 * This method should be used in an interactive editing scenario. It records an {\@link yfiles.graph.ICompoundEdit} to support
 * undoability and uses the {\@link yfiles.input.IReshapeHandler} for the resizing of the nodes. That way, e.g. orthogonally edited
 * edges will be properly reshaped.
 * </p>
 * @see yfiles.graph.GroupingSupport#enlargeGroupNode
 * Enlarges all group nodes in the graph so that the {\@link yfiles.graph.GroupingSupport#calculateMinimumEnclosedArea minimum enclosed area} is respected.
 * @see yfiles.graph.GroupingSupport#enlargeGroupNode
 * @param {?=} context The context to use for the {\@link }s.
 * @return {void}
 */
yfiles.graph.GroupingSupport.prototype.enlargeAllGroupNodes = function(context) {};

/**
 * Enlarges the group nodes in an interactive scenario, using {\@link yfiles.input.IReshapeHandler} implementations of the group
 * nodes to perform the actual resizing.
 * <p>
 * This method should be used in an interactive editing scenario. It records an {\@link yfiles.graph.ICompoundEdit} to support
 * undoability and uses the {\@link yfiles.input.IReshapeHandler} for the resizing of the nodes. That way, e.g. orthogonally edited
 * edges will be properly reshaped.
 * </p>
 * @see yfiles.input.IReshapeHandler
 * Enlarges the given group node to ensure that the {\@link yfiles.graph.GroupingSupport#calculateMinimumEnclosedArea minimum enclosed} area is inside of its bounds.
 * <p>
 * This method can be used to resize a group node and all of its parent group nodes to fully contain its children, e.g.
 * after a child node has changed its bounds. Note that this method will only enlarge the bounds of the group nodes, it
 * will never reduce the size of a group node.
 * </p>
 * @see yfiles.graph.GroupingSupport#enlargeGroupNode
 * @param {?} context_or_groupNode The context to use for the {\@link }s. / The group node to resize.
 * @param {?|boolean} node_or_ancestors The node to enlarge appropriately. / if set to <code>true</code> all ancestor group nodes will be resized, too, if necessary
 * @param {boolean=} ancestors if set to <code>true</code> ancestors the ancestor group nodes will be adjusted, too, if necessary.
 * @return {void}
 */
yfiles.graph.GroupingSupport.prototype.enlargeGroupNode = function(context_or_groupNode, node_or_ancestors, ancestors) {};

/**
 * Returns all descendants of the provided node that are part of the grouped graph.
 * <p>
 * The enumeration will be top down, i.e. all of a node's ancestors will be enumerated before the respective node.
 * </p>
 * @param {?} node The root node to get the descendants from.
 * @return {?<?>} An enumeration of the children of the node at the time of this invocation in reverse DFS prefix order.
 */
yfiles.graph.GroupingSupport.prototype.getDescendants = function(node) {};

/**
 * Returns all descendants of the provided node that are part of the grouped graph.
 * <p>
 * The enumeration will be bottom up, i.e. all of a node's children will be enumerated before the respective node.
 * </p>
 * @param {?} node The root node to get the descendants from.
 * @return {?<?>} An enumeration of the children of the node at the time of this invocation in DFS postfix order.
 */
yfiles.graph.GroupingSupport.prototype.getDescendantsBottomUp = function(node) {};

/**
 * Determines the nearest common ancestor of the provided nodes in the graph.
 * Determines the nearest common ancestor of the provided nodes in the graph.
 * @param {...?|?<?>} nodes The nodes to find the nearest common ancestor of.
 * @return {?}
 */
yfiles.graph.GroupingSupport.prototype.getNearestCommonAncestor = function(nodes) {};

/**
 * Gets the path to root traversing all {\@link yfiles.graph.IGraph#getParent parents} of the given item.
 * @param {?} node The node to start.
 * @return {?<?>} A list that includes the node but not the root, unless they are identical and all parents in between them.
 */
yfiles.graph.GroupingSupport.prototype.getPathToRoot = function(node) {};

/**
 * Determines whether there are group nodes in the graph.
 * <p>
 * This methods considers all {\@link yfiles.graph.IGraph#isGroupNode group} nodes, that is, nodes that could have children.
 * </p>
 * @return {boolean} <code>true</code> if there are {\@link #isGroupNode group}.
 */
yfiles.graph.GroupingSupport.prototype.hasGroupNodes = function() {};

/**
 * Determines whether <code>ancestor</code> is an ancestor of <code>node</code> in the grouped graph.
 * @param {?} node The node to check.
 * @param {?} ancestor The ancestor to check.
 * @return {boolean} Whether <code>ancestor</code> is an ancestor of <code>node</code>.
 */
yfiles.graph.GroupingSupport.prototype.isDescendant = function(node, ancestor) {};
/**
 * @record
 * @struct
 */
yfiles.graph.GraphWrapperBase = function() {};
 /** @type {?} */
yfiles.graph.GraphWrapperBase.prototype.wrappedGraph;
 /** @type {?<?>} */
yfiles.graph.GraphWrapperBase.prototype.nodes;
 /** @type {?<?>} */
yfiles.graph.GraphWrapperBase.prototype.edges;
 /** @type {?<?>} */
yfiles.graph.GraphWrapperBase.prototype.labels;
 /** @type {?<?>} */
yfiles.graph.GraphWrapperBase.prototype.ports;
 /** @type {?} */
yfiles.graph.GraphWrapperBase.prototype.edgeDefaults;
 /** @type {?} */
yfiles.graph.GraphWrapperBase.prototype.nodeDefaults;
 /** @type {?} */
yfiles.graph.GraphWrapperBase.prototype.mapperRegistry;
 /** @type {?} */
yfiles.graph.GraphWrapperBase.prototype.groupNodeDefaults;
 /** @type {!Object} */
yfiles.graph.GraphWrapperBase.prototype.tag;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.GraphWrapperBase.$class;

/**
 *
 * @param {?} edge
 * @param {!yfiles.geometry.Point} location
 * @param {number=} index
 * @return {?}
 */
yfiles.graph.GraphWrapperBase.prototype.addBend = function(edge, location, index) {};

/**
 * Adds event handlers that propagate graph events from <code>graph</code> to listeners on this instance.
 * @protected
 * @param {?} graph The graph for which event propagators should be created
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addEventHandlers = function(graph) {};

/**
 *
 *
 * @param {?|{owner: ?, text: string, layoutParameter: ?, style: ?, preferredSize: !yfiles.geometry.Size, tag: !Object}} owner_or_options
 * @param {string=} text
 * @param {?=} layoutParameter
 * @param {?=} style
 * @param {!yfiles.geometry.Size=} preferredSize
 * @param {!Object=} tag
 * @return {?}
 */
yfiles.graph.GraphWrapperBase.prototype.addLabel = function(owner_or_options, text, layoutParameter, style, preferredSize, tag) {};

/**
 *
 *
 * @param {?|{owner: ?, locationParameter: ?, style: ?, tag: !Object}} owner_or_options
 * @param {?=} locationParameter
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?}
 */
yfiles.graph.GraphWrapperBase.prototype.addPort = function(owner_or_options, locationParameter, style, tag) {};

/**
 *
 * @param {?} item
 * @return {boolean}
 */
yfiles.graph.GraphWrapperBase.prototype.contains = function(item) {};

/**
 *
 *
 *
 *
 * @param {?|{source: ?, target: ?, style: ?, tag: !Object}|{sourcePort: ?, targetPort: ?, style: ?, tag: !Object}} source_or_options_or_sourcePort
 * @param {?=} target_or_targetPort
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?}
 */
yfiles.graph.GraphWrapperBase.prototype.createEdge = function(source_or_options_or_sourcePort, target_or_targetPort, style, tag) {};

/**
 *
 *
 * @param {?|{parent: ?, layout: !yfiles.geometry.Rect, style: ?, tag: !Object}=} parent_or_options
 * @param {!yfiles.geometry.Rect=} layout
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?}
 */
yfiles.graph.GraphWrapperBase.prototype.createGroupNode = function(parent_or_options, layout, style, tag) {};

/**
 *
 *
 *
 *
 * @param {!yfiles.geometry.Rect|{layout: !yfiles.geometry.Rect, style: ?, tag: !Object}|?|{parent: ?, layout: !yfiles.geometry.Rect, style: ?, tag: !Object}=} layout_or_options_or_parent
 * @param {?|!yfiles.geometry.Rect=} style_or_layout
 * @param {!Object|?=} tag_or_style
 * @param {!Object=} tag
 * @return {?}
 */
yfiles.graph.GraphWrapperBase.prototype.createNode = function(layout_or_options_or_parent, style_or_layout, tag_or_style, tag) {};

/**
 * Clears the internal state of this instance and released memory and bound listeners.
 * <p>
 * After this instance has been disposed of, it will not work as expected anymore. This implementation {\@link yfiles.graph.GraphWrapperBase#removeEventHandlers removes all event handlers}
 * from the {\@link yfiles.graph.GraphWrapperBase#wrappedGraph} and releases the reference.
 * </p>
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.dispose = function() {};

/**
 *
 *
 * @param {?} owner_or_port
 * @param {yfiles.graph.AdjacencyTypes=} type
 * @return {?<?>}
 */
yfiles.graph.GraphWrapperBase.prototype.edgesAt = function(owner_or_port, type) {};

/**
 *
 * @param {?} node
 * @return {?<?>}
 */
yfiles.graph.GraphWrapperBase.prototype.getChildren = function(node) {};

/**
 * Gets the lookup instance to use in {\@link yfiles.graph.GraphWrapperBase#lookup}
 * @return {?}
 */
yfiles.graph.GraphWrapperBase.prototype.getLookup = function() {};

/**
 *
 * @param {?} node
 * @return {?}
 */
yfiles.graph.GraphWrapperBase.prototype.getParent = function(node) {};

/**
 *
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.invalidateDisplays = function() {};

/**
 *
 * @param {?} node
 * @return {boolean}
 */
yfiles.graph.GraphWrapperBase.prototype.isGroupNode = function(node) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.GraphWrapperBase.prototype.lookup = function(type) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addBendAddedListener BendAdded} event
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onBendAdded = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addBendLocationChangedListener BendLocationChanged} event
 * @protected
 * @param {?} bend The bend whose location changed
 * @param {!yfiles.geometry.Point} oldLocation The bend location before the change
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onBendLocationChanged = function(bend, oldLocation) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addBendRemovedListener BendRemoved} event
 * @protected
 * @param {!yfiles.graph.BendEventArgs} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onBendRemoved = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addBendTagChangedListener BendTagChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, !Object>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onBendTagChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addEdgeCreatedListener EdgeCreated} event
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onEdgeCreated = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addEdgePortsChangedListener EdgePortsChanged} event
 * @protected
 * @param {!yfiles.graph.EdgeEventArgs} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onEdgePortsChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addEdgeRemovedListener EdgeRemoved} event
 * @protected
 * @param {!yfiles.graph.EdgeEventArgs} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onEdgeRemoved = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addEdgeStyleChangedListener EdgeStyleChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, ?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onEdgeStyleChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addEdgeTagChangedListener EdgeTagChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, !Object>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onEdgeTagChanged = function(evt) {};

/**
 * Called when the {\@link yfiles.graph.GraphWrapperBase#wrappedGraph} property value changes and after initialization of the field.
 * <p>
 * Delegates to {\@link yfiles.graph.GraphWrapperBase#addEventHandlers} for <code>newGraph</code> and to {\@link yfiles.graph.GraphWrapperBase#removeEventHandlers}
 * for <code>oldGraph</code>.
 * </p>
 * @protected
 * @param {?} oldGraph the old value, which may be <code>null</code> the first time
 * @param {?} newGraph the new value
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onGraphChanged = function(oldGraph, newGraph) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addGraphTagChangedListener GraphTagChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, !Object>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onGraphTagChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addDisplaysInvalidatedListener DisplaysInvalidated} event
 * @protected
 * @param {!yfiles.lang.EventArgs} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onInvalidateDisplays = function(evt) {};

/**
 * Dispatches the {\@link yfiles.graph.GraphWrapperBase#addIsGroupNodeChangedListener IsGroupNodeChanged} event.
 * @protected
 * @param {!yfiles.graph.NodeEventArgs} evt The event args to dispatch.
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onIsGroupNodeChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addLabelAddedListener LabelAdded} event
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onLabelAdded = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addLabelLayoutParameterChangedListener LabelLayoutParameterChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, ?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onLabelLayoutParameterChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addLabelPreferredSizeChangedListener LabelPreferredSizeChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, !yfiles.geometry.Size>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onLabelPreferredSizeChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addLabelRemovedListener LabelRemoved} event
 * @protected
 * @param {!yfiles.graph.LabelEventArgs} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onLabelRemoved = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addLabelStyleChangedListener LabelStyleChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, ?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onLabelStyleChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addLabelTagChangedListener LabelTagChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, !Object>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onLabelTagChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addLabelTextChangedListener LabelTextChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, string>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onLabelTextChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addNodeCreatedListener NodeCreated} event
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onNodeCreated = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addNodeLayoutChangedListener NodeLayoutChanged} event
 * @protected
 * @param {?} node The node whose layout changed
 * @param {!yfiles.geometry.Rect} oldLayout The node layout before the change
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onNodeLayoutChanged = function(node, oldLayout) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addNodeRemovedListener NodeRemoved} event
 * @protected
 * @param {!yfiles.graph.NodeEventArgs} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onNodeRemoved = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addNodeStyleChangedListener NodeStyleChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, ?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onNodeStyleChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addNodeTagChangedListener NodeTagChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, !Object>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onNodeTagChanged = function(evt) {};

/**
 * Dispatches the {\@link yfiles.graph.GraphWrapperBase#addParentChangedListener ParentChanged} event.
 * @protected
 * @param {!yfiles.graph.NodeEventArgs} evt The event args to dispatch.
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onParentChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addPortAddedListener PortAdded} event
 * @protected
 * @param {!yfiles.collections.ItemEventArgs<?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onPortAdded = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addPortLocationParameterChangedListener PortLocationParameterChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, ?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onPortLocationParameterChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addPortRemovedListener PortRemoved} event
 * @protected
 * @param {!yfiles.graph.PortEventArgs} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onPortRemoved = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addPortStyleChangedListener PortStyleChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, ?>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onPortStyleChanged = function(evt) {};

/**
 * Raises the {\@link yfiles.graph.GraphWrapperBase#addPortTagChangedListener PortTagChanged} event
 * @protected
 * @param {!yfiles.graph.ItemChangedEventArgs<?, !Object>} evt The parameters for the event
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.onPortTagChanged = function(evt) {};

/**
 *
 * @param {?} item
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.remove = function(item) {};

/**
 * Removes event handlers for <code>graph</code> that have been added with {\@link yfiles.graph.GraphWrapperBase#addEventHandlers}.
 * @protected
 * @param {?} graph The graph for which event propagators should be removed
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeEventHandlers = function(graph) {};

/**
 *
 * @param {?} bend
 * @param {!yfiles.geometry.Point} location
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setBendLocation = function(bend, location) {};

/**
 *
 * @param {?} edge
 * @param {?} sourcePort
 * @param {?} targetPort
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setEdgePorts = function(edge, sourcePort, targetPort) {};

/**
 *
 * @param {?} node
 * @param {boolean} isGroupNode
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setIsGroupNode = function(node, isGroupNode) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setLabelLayoutParameter = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {!yfiles.geometry.Size} preferredSize
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setLabelPreferredSize = function(label, preferredSize) {};

/**
 *
 * @param {?} label
 * @param {string} text
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setLabelText = function(label, text) {};

/**
 * Sets the lookup instance to use in {\@link yfiles.graph.GraphWrapperBase#lookup}
 * @param {?} lookup
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setLookup = function(lookup) {};

/**
 *
 * @param {?} node
 * @param {!yfiles.geometry.Rect} layout
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setNodeLayout = function(node, layout) {};

/**
 *
 * @param {?} node
 * @param {?} parent
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setParent = function(node, parent) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setPortLocationParameter = function(port, locationParameter) {};

/**
 *
 *
 *
 *
 * @param {?} port_or_edge_or_label_or_node
 * @param {?} style
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.setStyle = function(port_or_edge_or_label_or_node, style) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addGraphTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeGraphTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addNodeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeNodeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addNodeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeNodeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addNodeStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeNodeStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, ?, !yfiles.geometry.Rect): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addNodeLayoutChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, ?, !yfiles.geometry.Rect): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeNodeLayoutChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addNodeTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeNodeTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addEdgeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeEdgeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addEdgeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeEdgeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addEdgeStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeEdgeStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addEdgePortsChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeEdgePortsChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addEdgeTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeEdgeTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addBendAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeBendAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.BendEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addBendRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.BendEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeBendRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, ?, !yfiles.geometry.Point): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addBendLocationChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, ?, !yfiles.geometry.Point): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeBendLocationChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addBendTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeBendTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addLabelAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeLabelAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addLabelRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeLabelRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addLabelStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeLabelStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !yfiles.geometry.Size>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addLabelPreferredSizeChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !yfiles.geometry.Size>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeLabelPreferredSizeChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, string>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addLabelTextChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, string>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeLabelTextChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addLabelLayoutParameterChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeLabelLayoutParameterChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addLabelTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeLabelTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addPortAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removePortAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.PortEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addPortRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.PortEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removePortRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addPortStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removePortStyleChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addPortLocationParameterChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removePortLocationParameterChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addPortTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removePortTagChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addDisplaysInvalidatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeDisplaysInvalidatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addParentChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeParentChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.addIsGroupNodeChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.GraphWrapperBase.prototype.removeIsGroupNodeChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graph.IBend = function() {};
 /** @type {?} */
yfiles.graph.IBend.prototype.owner;
 /** @type {?} */
yfiles.graph.IBend.prototype.location;
 /** @type {number} */
yfiles.graph.IBend.prototype.index;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IBend;
/**
 * @record
 * @struct
 */
yfiles.graph.IEdge = function() {};
 /** @type {?<?>} */
yfiles.graph.IEdge.prototype.bends;
 /** @type {?} */
yfiles.graph.IEdge.prototype.sourcePort;
 /** @type {?} */
yfiles.graph.IEdge.prototype.targetPort;
 /** @type {?} */
yfiles.graph.IEdge.prototype.style;
 /** @type {?} */
yfiles.graph.IEdge.prototype.sourceNode;
 /** @type {?} */
yfiles.graph.IEdge.prototype.targetNode;
 /** @type {boolean} */
yfiles.graph.IEdge.prototype.isSelfloop;

/**
 * Gets the opposite port of an {\@link yfiles.graph.IEdge}.
 * @throws {Stubs.Exceptions.ArgumentError} If <code>port</code> is neither the source or target of the edge.
 * Gets the opposite port owner of an {\@link yfiles.graph.IEdge}.
 * @throws {Stubs.Exceptions.ArgumentError} If <code>owner</code> is neither the source or target of the edge.
 * @param {?} port_or_owner The port that the {\@link } is connected to. / The owner of the port that the {\@link } is connected to.
 * @return {?} The opposite port. / The owner of the opposite port.
 */
yfiles.graph.IEdge.prototype.opposite = function(port_or_owner) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IEdge;
/**
 * @record
 * @struct
 */
yfiles.graph.IEdgeDefaults = function() {};
 /** @type {?} */
yfiles.graph.IEdgeDefaults.prototype.ports;
 /** @type {?} */
yfiles.graph.IEdgeDefaults.prototype.labels;
 /** @type {?} */
yfiles.graph.IEdgeDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.IEdgeDefaults.prototype.shareStyleInstance;

/**
 * Factory method that returns a style instance for use with newly created edges.
 * <p>
 * Most implementations will yield either, a {\@link yfiles.lang.ICloneable#clone clone} of or the {\@link yfiles.graph.IEdgeDefaults#style} property, if {\@link yfiles.graph.IEdgeDefaults#shareStyleInstance} is enabled, but they might use more complicated
 * logic, too.
 * </p>
 * @abstract
 * @return {?} The style to use, which for most implementations is either a {\@link #clone clone} of or the {\@link #style} property, if {\@link #shareStyleInstance} is enabled.
 */
yfiles.graph.IEdgeDefaults.prototype.getStyleInstance = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IEdgeDefaults;
/**
 * @record
 * @struct
 */
yfiles.graph.IFoldingView = function() {};
 /** @type {?} */
yfiles.graph.IFoldingView.prototype.graph;
 /** @type {boolean} */
yfiles.graph.IFoldingView.prototype.autoSwitchToAncestor;
 /** @type {boolean} */
yfiles.graph.IFoldingView.prototype.invalid;
 /** @type {boolean} */
yfiles.graph.IFoldingView.prototype.enqueueNavigationalUndoUnits;
 /** @type {?} */
yfiles.graph.IFoldingView.prototype.localRoot;
 /** @type {!yfiles.graph.FoldingManager} */
yfiles.graph.IFoldingView.prototype.manager;

/**
 * This method will collapse the {\@link yfiles.graph.IGraph#getChildren children} of a group node into the group node.
 * <p>
 * If a {\@link yfiles.graph.IGraph#isGroupNode group} node that belongs to this view's hierarchy is in {\@link yfiles.graph.IFoldingView#expand expanded} state, calling this method will remove the {\@link yfiles.graph.IGraph#getChildren children}
 * from this {\@link yfiles.graph.IFoldingView#graph view}. This method will do nothing if the node is already collapsed. Note that collapsing a group node will
 * make it a {\@link yfiles.graph.IGraph#isGroupNode non-group} node in the hierarchy. The collapsed group node has its own separate set of attributes, which can be
 * obtained using the {\@link yfiles.graph.FoldingManager#getFolderNodeState} method. Therefore it may appear that the node changes
 * its location during a collapse operation. This behavior ensures that collapsing a node does not modify the state of the
 * model (only the state in the view is changed), but depending on the application this may confuse the user because he
 * might loose his mental map of the diagram. In order to customize the behavior custom code can register with the {\@link yfiles.graph.IFoldingView#addGroupCollapsedListener GroupCollapsed}
 * event to perform the necessary modifications, like adjusting the view port or moving the node to the desired location.
 * </p>
 * <p>
 * In addition to that this method can also be used for {\@link yfiles.graph.FoldingManager#masterGraph master} nodes which are currently not represented in this view. In
 * this case these nodes will be displayed as collapsed the next time they will be included in this view.
 * </p>
 * @see yfiles.graph.IFoldingView#isExpanded
 * @abstract
 * @param {?} groupNode A group node that is part of the {\@link #graph} or the {\@link #masterGraph master graph}.
 * @return {void}
 */
yfiles.graph.IFoldingView.prototype.collapse = function(groupNode) {};

/**
 * Directly creates a collapsed node on this instance with the given parameters.
 * <p>
 * This will implicitly create a new empty group node on the {\@link yfiles.graph.FoldingManager#masterGraph} with the defaults for such a group node. The <code>parent</code> must be
 * part of the {\@link yfiles.graph.IFoldingView#graph Folded Graph View} or <code>null</code> to create a folder at the root of the current hierarchy. It will be converted into
 * a group node if necessary. The returned {\@link yfiles.graph.INode} is also part of the {\@link yfiles.graph.IFoldingView#graph Folded Graph View}.
 * </p>
 * @abstract
 * Directly creates a collapsed node on this instance with the given parameters.
 * <p>
 * This will implicitly create a new empty group node on the {\@link yfiles.graph.FoldingManager#masterGraph} with the defaults for such a group node. The <code>parent</code> must be
 * part of the {\@link yfiles.graph.IFoldingView#graph Folded Graph View} or <code>null</code> to create a folder at the root of the current hierarchy. It will be converted into
 * a group node if necessary. The returned {\@link yfiles.graph.INode} is also part of the {\@link yfiles.graph.IFoldingView#graph Folded Graph View}.
 * </p>
 * @abstract
 * @param {?|{parent: ?, layout: !yfiles.geometry.Rect, style: ?, tag: !Object}=} parent_or_options
 * @param {!yfiles.geometry.Rect=} layout
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?} A collapsed (folder) node that lives in {\@link #graph}
 */
yfiles.graph.IFoldingView.prototype.createFolderNode = function(parent_or_options, layout, style, tag) {};

/**
 * Disposes of this view explicitly.
 * <p>
 * Normally it is not necessary to do so, because the view will be garbage collected automatically. However if the view
 * still displays contents, this might have unwanted negative side effects (group node sizes being calculated, etc.) A
 * disposed of instance is not synchronized with the {\@link yfiles.graph.FoldingManager} anymore and should not be used anymore.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.graph.IFoldingView.prototype.dispose = function() {};

/**
 * This method will expand a previously {\@link yfiles.graph.IFoldingView#collapse collapsed} group node to make its contents appear in this view.
 * <p>
 * If a node that belongs to this view is in {\@link yfiles.graph.IFoldingView#collapse collapsed} state, calling this method will make the {\@link yfiles.graph.IGraph#getChildren children} appear in this
 * {\@link yfiles.graph.IFoldingView#graph view}. This method will do nothing if the node is already expanded. Note that expanding a collapsed group node will make
 * the node a {\@link yfiles.graph.IGraph#isGroupNode group node}, whereas a collapsed group node is no group node in this hierarchy and thus cannot have visible
 * children. The expanded group node has its own separate set of attributes, which may be different from the collapsed
 * state that can be obtained using the {\@link yfiles.graph.FoldingManager#getFolderNodeState} method. The expanded state is always
 * the same as the state of the {\@link yfiles.graph.IFoldingView#getMasterItem master node}. Because of these differences it may appear that the node changes its location
 * during an expand operation. This behavior ensures that expanding a node does not modify the state of the model by moving
 * the node or its descendants (only the state in the view is changed), but depending on the application this may confuse
 * the user because he might loose his mental map of the diagram. In order to customize the behavior custom code can
 * register with the {\@link yfiles.graph.IFoldingView#addGroupExpandedListener GroupExpanded} event to perform the
 * necessary modifications, like adjusting the view port or moving the node and its descendants to the desired location.
 * </p>
 * <p>
 * In addition to that this method can also be used for {\@link yfiles.graph.FoldingManager#masterGraph master} nodes which are currently not represented in this view. In
 * this case these nodes will be displayed as expanded the next time they will be included in this view.
 * </p>
 * @see yfiles.graph.IFoldingView#isExpanded
 * @see yfiles.graph.IFoldingView#collapse
 * @abstract
 * @param {?} groupNode A group node that is part of the {\@link #graph} or the {\@link #masterGraph master graph}.
 * @return {void}
 */
yfiles.graph.IFoldingView.prototype.expand = function(groupNode) {};

/**
 * Helper method that corresponds to the {\@link yfiles.graph.IFoldingView#getMasterItem} method, but is used for folding edges,
 * only.
 * <p>
 * Since folding edges can represent more than one master edge, this method can be used to query all of the master edges
 * that the provided folding edge represents. If the folding edge corresponds to a single master edge, the result will
 * enumerate that edge, only.
 * </p>
 * @see yfiles.graph.IFoldingEdgeFactory#addToExistingFoldingEdge
 * @see yfiles.graph.IFoldingView#getViewItem
 * @abstract
 * @param {?} foldingEdge The folding edge for which the master edges should be returned.
 * @return {?<?>} An enumerable that can enumerate all of the edges in the {\@link #masterGraph} that are being represented by the folding edge in this {\@link #graph view}.
 */
yfiles.graph.IFoldingView.prototype.getMasterEdges = function(foldingEdge) {};

/**
 * Helper method that can be used to retrieve the original "master" items in the {\@link yfiles.graph.FoldingManager#masterGraph} that is managed by the Manager associated
 * with this view.
 * <p>
 * Since the {\@link yfiles.graph.IFoldingView#graph} view that is associated with this instance maintains a copy of the entities in the Manager's {\@link yfiles.graph.FoldingManager#masterGraph}, there is a
 * mapping between elements that belong to this view's {\@link yfiles.graph.IFoldingView#graph} and the elements in the master graph. This method can be called for
 * the elements contained in this {\@link yfiles.graph.IGraph} and will return the corresponding item in the master graph that the
 * element corresponds to, if any. Note that for some items in the {\@link yfiles.graph.IFoldingView#graph}, there is no master item in the {\@link yfiles.graph.FoldingManager#masterGraph}, e.g. the {\@link yfiles.graph.IPort}
 * instances to which {\@link yfiles.graph.FoldingEdgeStateId folding edges} connect have no corresponding ports in the master graph. The same holds true for the {\@link yfiles.graph.IBend bends}
 * and {\@link yfiles.graph.ILabel labels} of folding edges and folder nodes. For folding edges, this method will yield the main representing edge in
 * the master, if the folding edge represents more than one master edge. For nodes, the master node will be returned, no
 * matter whether the node is currently {\@link yfiles.graph.IFoldingView#collapse collapsed} or not.
 * </p>
 * Type parameter <code>T</code>: The type of the argument, which is typically {\@link yfiles.graph.INode}, {\@link yfiles.graph.IEdge}, {\@link yfiles.graph.ILabel},
 * {\@link yfiles.graph.IBend}, or {\@link yfiles.graph.IPort}.
 * @see yfiles.graph.IFoldingView#getViewItem
 * @abstract
 * @template T
 * @param {T} item The item that is part of this {\@link #graph} for which the original "master" item in the {\@link #masterGraph} will be returned.
 * @return {T} An item in the {\@link #masterGraph} that corresponds to the <code>item</code> or <code>null</code>, if there is no such item.
 */
yfiles.graph.IFoldingView.prototype.getMasterItem = function(item) {};

/**
 * Helper method that can be used to retrieve the items in this {\@link yfiles.graph.IFoldingView#graph}-view for all items that are part of the {\@link yfiles.graph.FoldingManager#masterGraph} that is
 * associated with the Manager of this instance.
 * <p>
 * Since the {\@link yfiles.graph.IFoldingView#graph} view that is associated with this instance maintains a copy of the entities in the Manager's {\@link yfiles.graph.FoldingManager#masterGraph}, there is a
 * mapping between elements that belong to master graph and the elements in the {\@link yfiles.graph.IFoldingView#graph} of this view. This method can be called
 * for the elements contained in this {\@link yfiles.graph.FoldingManager#masterGraph master graph's} items and will return the corresponding item in this view's {\@link yfiles.graph.IFoldingView#graph} if the
 * element is represented by an item in this view. Note that for some items in the {\@link yfiles.graph.FoldingManager#masterGraph}, there may be no item in the {\@link yfiles.graph.IFoldingView#graph} instance,
 * e.g. those elements which are part of a {\@link yfiles.graph.IFoldingView#collapse collapsed} subtree in the {\@link yfiles.graph.FoldingManager#masterGraph} hierarchy or those items that do not belong to the
 * subtree that is induced by the {\@link yfiles.graph.IFoldingView#localRoot} of this view. Also, for nodes and edges that are being represented by dummies in this
 * view, labels, ports, and bends are not being represented directly by corresponding entities in this graph. If more than
 * one edge is represented by a folding edge in this view, this method will yield the same folding edge instance for each
 * of them.
 * </p>
 * Type parameter <code>T</code>: The type of the argument, which is typically {\@link yfiles.graph.INode}, {\@link yfiles.graph.IEdge}, {\@link yfiles.graph.ILabel},
 * {\@link yfiles.graph.IBend}, or {\@link yfiles.graph.IPort}.
 * @see yfiles.graph.IFoldingView#getMasterItem
 * @see yfiles.graph.IFoldingView#getMasterEdges
 * @abstract
 * @template T
 * @param {T} item An item that is part of the {\@link #masterGraph} that is associated with the Manager of this instance.
 * @return {T} An item in the {\@link #graph local graph view} that corresponds to the <code>item</code> or
 * <code>null</code>, if the item is not currently being represented in this view.
 */
yfiles.graph.IFoldingView.prototype.getViewItem = function(item) {};

/**
 * Determines whether the provided node is currently expanded or will be displayed in
 * {\@link yfiles.graph.IFoldingView#expand}ed state the next time it will be included in this view.
 * <p>
 * Expanded group nodes will have all of their {\@link yfiles.graph.IGraph#getChildren children} visible in this {\@link yfiles.graph.IFoldingView#graph view}.
 * </p>
 * <p>
 * The <code>groupNode</code> can be either a node of the {\@link yfiles.graph.IFoldingView#graph view} or the {\@link yfiles.graph.FoldingManager#masterGraph master graph}. If the node is from the master graph and is
 * currently not represented in this view, this method will return the
 * {\@link yfiles.graph.IFoldingView#expand}ed state it will have the next time it will be included in this view.
 * </p>
 * @abstract
 * @param {?} groupNode The group node for which the {\@link #expand expanded} state will be returned.
 * @return {boolean} <code>true</code>, if the group node can be {\@link #collapse collapsed}.
 */
yfiles.graph.IFoldingView.prototype.isExpanded = function(groupNode) {};

/**
 * Determines whether the specified item is a folding state in this view.
 * <p>
 * This method can be used to determine if an {\@link yfiles.graph.INode}, {\@link yfiles.graph.IEdge}, {\@link yfiles.graph.IPort},
 * {\@link yfiles.graph.ILabel}, or {\@link yfiles.graph.IBend} has a {\@link yfiles.graph.FoldingManager#getFolderNodeState view local state} and is not a direct copy of the {\@link yfiles.graph.IFoldingView#getMasterItem master item}, if any.
 * Note that {\@link yfiles.graph.IFoldingView#collapse collapsed} group nodes are in folding state, even though they do have a {\@link yfiles.graph.IFoldingView#getMasterItem master} item in the master graph and
 * folding edges always have at least one
 * {\@link yfiles.graph.IFoldingView#getMasterEdges master edge}, while all other folding items don't have a corresponding master item in the master graph.
 * </p>
 * @abstract
 * @param {?} item One of the items that are {\@link #contains contained} in the {\@link #graph}.
 * @return {boolean} Whether the item is in folding state and is not an exact copy of an item in the {\@link #masterGraph}.
 */
yfiles.graph.IFoldingView.prototype.isInFoldingState = function(item) {};

/**
 * Adds the given listener for the <code>GroupCollapsed</code> event that occurs whenever a group has been
 * {\@link yfiles.graph.IFoldingView#collapse}d.
 * @see yfiles.graph.IFoldingView#removeGroupCollapsedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IFoldingView.prototype.addGroupCollapsedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupCollapsed</code> event that occurs whenever a group has been
 * {\@link yfiles.graph.IFoldingView#collapse}d.
 * @see yfiles.graph.IFoldingView#addGroupCollapsedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IFoldingView.prototype.removeGroupCollapsedListener = function(listener) {};

/**
 * Adds the given listener for the <code>GroupExpanded</code> event that occurs whenever a group has been
 * {\@link yfiles.graph.IFoldingView#expand}ed.
 * @see yfiles.graph.IFoldingView#removeGroupExpandedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IFoldingView.prototype.addGroupExpandedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GroupExpanded</code> event that occurs whenever a group has been
 * {\@link yfiles.graph.IFoldingView#expand}ed.
 * @see yfiles.graph.IFoldingView#addGroupExpandedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IFoldingView.prototype.removeGroupExpandedListener = function(listener) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IFoldingView;

/** @const */
yfiles.graph.AdjacencyTypes = {};
/** @const {number} */
yfiles.graph.AdjacencyTypes.NONE;
/** @const {number} */
yfiles.graph.AdjacencyTypes.INCOMING;
/** @const {number} */
yfiles.graph.AdjacencyTypes.OUTGOING;
/** @const {number} */
yfiles.graph.AdjacencyTypes.ALL;

/** @const */
yfiles.graph.GraphItemTypes = {};
/** @const {number} */
yfiles.graph.GraphItemTypes.NODE;
/** @const {number} */
yfiles.graph.GraphItemTypes.EDGE;
/** @const {number} */
yfiles.graph.GraphItemTypes.NODE_LABEL;
/** @const {number} */
yfiles.graph.GraphItemTypes.EDGE_LABEL;
/** @const {number} */
yfiles.graph.GraphItemTypes.PORT;
/** @const {number} */
yfiles.graph.GraphItemTypes.LABEL;
/** @const {number} */
yfiles.graph.GraphItemTypes.LABEL_OWNER;
/** @const {number} */
yfiles.graph.GraphItemTypes.BEND;
/** @const {number} */
yfiles.graph.GraphItemTypes.ALL;
/** @const {number} */
yfiles.graph.GraphItemTypes.NONE;
/**
 * @record
 * @struct
 */
yfiles.graph.IGraph = function() {};
 /** @type {?<?>} */
yfiles.graph.IGraph.prototype.nodes;
 /** @type {?<?>} */
yfiles.graph.IGraph.prototype.edges;
 /** @type {?<?>} */
yfiles.graph.IGraph.prototype.labels;
 /** @type {?<?>} */
yfiles.graph.IGraph.prototype.ports;
 /** @type {?} */
yfiles.graph.IGraph.prototype.nodeDefaults;
 /** @type {?} */
yfiles.graph.IGraph.prototype.edgeDefaults;
 /** @type {?} */
yfiles.graph.IGraph.prototype.mapperRegistry;
 /** @type {?} */
yfiles.graph.IGraph.prototype.groupNodeDefaults;
 /** @type {!yfiles.graph.GraphDecorator} */
yfiles.graph.IGraph.prototype.decorator;
 /** @type {!yfiles.graph.GroupingSupport} */
yfiles.graph.IGraph.prototype.groupingSupport;
 /** @type {?} */
yfiles.graph.IGraph.prototype.foldingView;
 /** @type {!yfiles.graph.UndoEngine} */
yfiles.graph.IGraph.prototype.undoEngine;
 /** @type {boolean} */
yfiles.graph.IGraph.prototype.undoEngineEnabled;
 /** @type {?<?>} */
yfiles.graph.IGraph.prototype.bends;
 /** @type {?<?>} */
yfiles.graph.IGraph.prototype.edgeLabels;
 /** @type {?<?>} */
yfiles.graph.IGraph.prototype.nodeLabels;

/**
 * Adds a bend at the given index to the given edge using the coordinates provided.
 * <p>
 * The added instance will be returned.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>edge</code> is not in this graph.
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.graph.IGraph#setBendLocation
 * @abstract
 * @param {?} edge The edge to which the bend will be added.
 * @param {!yfiles.geometry.Point} location the coordinates to use for the newly created bend
 * @param {number=} index
 * @return {?} a newly created live bend
 */
yfiles.graph.IGraph.prototype.addBend = function(edge, location, index) {};

/**
 * Adds bends with the given locations to the end of the bend list of the given edge.
 * @throws {Stubs.Exceptions.ArgumentError} <code>edge</code> is not in this graph.
 * @param {?} edge The edge to add the bends to.
 * @param {?<!yfiles.geometry.Point>} locations The locations of the bends.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addBends = function(edge, locations) {};

/**
 * Add a label to the given node or edge using the text as the initial label text and label model parameter, style and
 * tag.
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @see yfiles.graph.IGraph#addLabelAddedListener
 * @see yfiles.graph.IGraph#setLabelText
 * @see yfiles.graph.IGraph#setLabelLayoutParameter
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.styles.VoidLabelStyle#INSTANCE
 * @abstract
 * Add a label to the given node or edge using the text as the initial label text and label model parameter, style and
 * tag.
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @see yfiles.graph.IGraph#addLabelAddedListener
 * @see yfiles.graph.IGraph#setLabelText
 * @see yfiles.graph.IGraph#setLabelLayoutParameter
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.styles.VoidLabelStyle#INSTANCE
 * @abstract
 * @param {?|{owner: ?, text: string, layoutParameter: ?, style: ?, preferredSize: !yfiles.geometry.Size, tag: !Object}} owner_or_options The node or edge to add the label to.
 * @param {string=} text The initial text of the label
 * @param {?=} layoutParameter
 * @param {?=} style
 * @param {!yfiles.geometry.Size=} preferredSize
 * @param {!Object=} tag
 * @return {?} the newly created label
 */
yfiles.graph.IGraph.prototype.addLabel = function(owner_or_options, text, layoutParameter, style, preferredSize, tag) {};

/**
 * Add a port to the given port owner using the location model parameter, style and tag.
 * <p>
 * The <code>locationParameter</code> determines the location of the port.
 * </p>
 * <p>
 * Depending on the implementation this method may throw an {\@link yfiles.lang.Exception} if the type of the <code>owner</code> instance does
 * not support adding of ports.
 * </p>
 * @throws {Stubs.Exceptions.NotSupportedError} If this instance cannot add a port to <code>owner</code>.
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @see yfiles.graph.IGraph#addPortAddedListener
 * @see yfiles.styles.VoidPortStyle#INSTANCE
 * @abstract
 * Add a port to the given port owner using the location model parameter, style and tag.
 * <p>
 * The <code>locationParameter</code> determines the location of the port.
 * </p>
 * <p>
 * Depending on the implementation this method may throw an {\@link yfiles.lang.Exception} if the type of the <code>owner</code> instance does
 * not support adding of ports.
 * </p>
 * @throws {Stubs.Exceptions.NotSupportedError} If this instance cannot add a port to <code>owner</code>.
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @see yfiles.graph.IGraph#addPortAddedListener
 * @see yfiles.styles.VoidPortStyle#INSTANCE
 * @abstract
 * @param {?|{owner: ?, locationParameter: ?, style: ?, tag: !Object}} owner_or_options the owner to add the port instance to.
 * @param {?=} locationParameter
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?} the newly created port
 */
yfiles.graph.IGraph.prototype.addPort = function(owner_or_options, locationParameter, style, tag) {};

/**
 * Add a port to the given port owner using the absolute coordinates as the new initial position of the port anchor.
 * @throws {Stubs.Exceptions.NotSupportedError} If this instance cannot add a port to <code>owner</code>.
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * Add a port to the given port owner using the absolute coordinates as the new initial position of the port anchor.
 * @throws {Stubs.Exceptions.NotSupportedError} If this instance cannot add a port to <code>owner</code>.
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @param {?|{owner: ?, location: !yfiles.geometry.Point, style: ?, tag: !Object}} owner_or_options the owner to add the port instance to.
 * @param {!yfiles.geometry.Point=} location the location to use for the port to determine its location. This is passed to the {\@link #createDefaultPortLocationParameter}
 * method to determine the initial {\@link } to use.
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?} the newly created port
 */
yfiles.graph.IGraph.prototype.addPortAt = function(owner_or_options, location, style, tag) {};

/**
 * Adds a new port to the graph at the node using a location that is relative to the center of the node.
 * <p>
 * The port style for the newly-created port is taken from the graph's defaults. The location parameter is determined by
 * delegating to {\@link yfiles.graph.IGraph#addPortAt}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @param {?} node The owner of the port.
 * @param {!yfiles.geometry.Point} relativeLocation The offset of the port relative to the center of the {\@link #layout}.
 * @return {?} The newly added port instance.
 */
yfiles.graph.IGraph.prototype.addRelativePort = function(node, relativeLocation) {};

/**
 * Convenience method that uses the {\@link yfiles.graph.UndoEngine} from the {\@link yfiles.graph.IGraph}'s {\@link yfiles.graph.ILookup} to
 * {\@link yfiles.graph.UndoEngine#addUnit add a unit}.
 * @param {string} undoName The name of the undo operation.
 * @param {string} redoName The name of the redo operation.
 * @param {function(): void} undo The undo action.
 * @param {function(): void} redo The redo action.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addUndoUnit = function(undoName, redoName, undo, redo) {};

/**
 * Method to adjust the size of a group node.
 * <p>
 * This will resize the group node bounds such that the node requires the least amount of space. If the node does not have
 * any {\@link yfiles.graph.IGraph#getChildren children}, its bounds will be left unchanged. This will also respect any {\@link yfiles.input.INodeSizeConstraintProvider}s
 * for {\@link yfiles.graph.INode}s, that are available in the lookup of the <code>groupNode</code>.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>groupNode</code> is not in this graph.
 * @see yfiles.graph.IGroupBoundsCalculator
 * @see yfiles.input.INodeSizeConstraintProvider
 * @see yfiles.graph.GroupingSupport#calculateMinimumEnclosedArea
 * @see yfiles.graph.GroupingSupport#enlargeGroupNode
 * @see yfiles.graph.GroupingSupport#enlargeAllGroupNodes
 * @param {?} groupNode The group node to adjust the size of.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.adjustGroupNodeLayout = function(groupNode) {};

/**
 * Adjusts the {\@link yfiles.graph.ILabel#preferredSize} property of a label to fit the suggested size of its {\@link yfiles.styles.ILabelStyleRenderer}.
 * <p>
 * This implementation uses the {\@link yfiles.graph.ILabel#style style's} renderer for the label to determine the preferred rendering size. This is useful
 * after the label's content or style have been changed.
 * </p>
 * @see yfiles.graph.ILabelDefaults#autoAdjustPreferredSize
 * @param {?} label The label to adjust the size for.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.adjustLabelPreferredSize = function(label) {};

/**
 * Convenience method that runs a layout on a graph using {\@link yfiles.layout.LayoutGraphAdapter#applyLayout}.
 * @see yfiles.view.GraphComponent#morphLayout
 * @param {?} layout The layout.
 * @param {!yfiles.layout.LayoutData=} layoutData
 * @return {void}
 */
yfiles.graph.IGraph.prototype.applyLayout = function(layout, layoutData) {};

/**
 * Starts an {\@link yfiles.graph.ICompoundEdit} that uses the {\@link yfiles.graph.IMementoSupport memento design pattern} to record changes to the items in the given <code>items</code>
 * collection.
 * <p>
 * This method uses the {\@link yfiles.graph.IMementoSupport} returned by the <code>provider</code> to record the state of an item at the
 * beginning of the edit and when {\@link yfiles.graph.ICompoundEdit#commit} is called to create an {\@link yfiles.graph.IUndoUnit} that can
 * revert the item to the recorded state and back. If no <code>provider</code> is given, this method uses the {\@link yfiles.graph.IMementoSupport}
 * returned by the {\@link yfiles.graph.ILookup#lookup} implementation of the items to record the state of an item at the beginning
 * of the edit and when {\@link yfiles.graph.ICompoundEdit#commit} is called to create an {\@link yfiles.graph.IUndoUnit} that can revert the
 * item to the recorded state and back.
 * </p>
 * <p>
 * Calling this method will immediately enqueue an {\@link yfiles.graph.IUndoUnit} into the undo queue. Subsequent additions to the
 * queue will be added after the created instance, even if they are added to the queue before the {\@link yfiles.graph.ICompoundEdit#commit}
 * method has been called.
 * </p>
 * <p>
 * The following is an example implementation of an item that is being managed using {\@link yfiles.graph.IMementoSupport}:
 * </p>
 * <p>
 * A collection of items from this type can then be watched using the following code snippet:
 * </p>
 * <p>
 * Alternatively, when using a specific provider, consider the following examples. The following is an example
 * implementation of an item that is being managed using {\@link yfiles.graph.IMementoSupport}:
 * </p>
 * <p>
 * A collection of items from this type can then be watched using the following code snippet, using the <code>provider</code> to return
 * an appropriate {\@link yfiles.graph.IMementoSupport} implementation:
 * </p>
 * <p>
 * Implementing the {\@link yfiles.graph.IMementoSupport} interface is quite unrestrained, the type of the state returned by {\@link yfiles.graph.IMementoSupport#getState}
 * method can by anything as long as the {\@link yfiles.graph.IMementoSupport#applyState} and {\@link yfiles.graph.IMementoSupport#stateEquals}
 * methods can deal with it:
 * </p>
 * <p>
 * In summary, use this concept when you want to track the state of items during certain operations for undo/redo. This is
 * efficient if it's easier to handle an item's state than the changes to the item themselves. If you want to focus on the
 * changes or on certain events, you should use custom {\@link yfiles.graph.IUndoUnit}
 * </p>
 * Type parameter <code>T</code>: The type of the items that will be modified subsequently.
 * @see yfiles.graph.IMementoSupport
 * Starts an {\@link yfiles.graph.ICompoundEdit} that records graph changes and {\@link yfiles.graph.IGraph#addUndoUnit custom undo units} in a single compound unit.
 * <p>
 * This method can be used to bracket several undo units. All edits added to the queue after this call and before a call to
 * {\@link yfiles.graph.ICompoundEdit#cancel} or {\@link yfiles.graph.ICompoundEdit#commit} will be placed into the queue as a single block.
 * </p>
 * <p>
 * Client code needs to make sure that either the {\@link yfiles.graph.ICompoundEdit#cancel} or {\@link yfiles.graph.ICompoundEdit#commit}
 * method is called on the returned instance.
 * </p>
 * @template T
 * @param {string} undoName The {\@link #undoName} of the {\@link } that will be placed into the undo queue after {\@link #commit} has
 * been called. / The undo name for the compound edit.
 * @param {string} redoName The {\@link #redoName} of the {\@link } that will be placed into the undo queue after {\@link #commit} has
 * been called. / The redo name for the compound edit.
 * @param {?<T>=} items The items that will be changed after this call and before the call to {\@link #commit}.
 * @param {function(T): ?=} provider
 * @return {?} An implementation of the {\@link } interface whose {\@link #commit} or {\@link #cancel}
 * methods need to be called after the items have been modified. / The handle to stop the recording by calling {\@link #cancel} or {\@link #commit} on
 * it.
 */
yfiles.graph.IGraph.prototype.beginEdit = function(undoName, redoName, items, provider) {};

/**
 * Calculates the preferred size of a label with the given properties.
 * Calculates the preferred size of a label with the given properties.
 * @param {?|{owner: ?, text: string, layoutParameter: ?, style: ?, tag: !Object}} owner_or_options The item that will own the label.
 * @param {string=} text The text.
 * @param {?=} layoutParameter
 * @param {?=} style
 * @param {!Object=} tag
 * @return {!yfiles.geometry.Size} The size as calculated by the {\@link }.
 */
yfiles.graph.IGraph.prototype.calculateLabelPreferredSize = function(owner_or_options, text, layoutParameter, style, tag) {};

/**
 * Clears the graph, removing all items in proper order.
 * @see yfiles.graph.IGraph#remove
 * @return {void}
 */
yfiles.graph.IGraph.prototype.clear = function() {};

/**
 * Removes all bends from the given edge.
 * <p>
 * The edge must be part of this graph at the time of the invocation. This will trigger the corresponding events.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>edge</code> is not in this graph.
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.graph.IGraph#addBendRemovedListener
 * @param {?} edge the edge whose bends will be removed
 * @return {void}
 */
yfiles.graph.IGraph.prototype.clearBends = function(edge) {};

/**
 * Determines whether this graph contains the specified item.
 * @abstract
 * @param {?} item The item.
 * @return {boolean} <code>true</code> if this graph contains the specified item; otherwise, <code>false</code>.
 */
yfiles.graph.IGraph.prototype.contains = function(item) {};

/**
 * Creates the label layout parameter for a given {\@link yfiles.graph.ILabelOwner}.
 * <p>
 * This implementation uses the {\@link yfiles.graph.IGraph#getLabelDefaults label defaults} for the <code>graph</code> to {\@link yfiles.graph.ILabelDefaults#getLayoutParameterInstance obtain the parameter instance}.
 * </p>
 * @see yfiles.graph.ILabelDefaults#getLayoutParameterInstance
 * @see yfiles.graph.IGraph#getLabelDefaults
 * @param {?} owner The item that is the {\@link #owner} of the label in question.
 * @return {?} The default label layout parameter to use for newly created labels at the item.
 */
yfiles.graph.IGraph.prototype.createDefaultLabelLayoutParameter = function(owner) {};

/**
 * Creates a location model parameter for a newly created {\@link yfiles.graph.IPort} at the <code>owner</code> that matches the <code>location</code>.
 * <p>
 * If <code>location</code> is <code>null</code>, this method uses the {\@link yfiles.graph.IGraph#getPortDefaults port defaults} for the <code>owner</code> to obtain the {\@link yfiles.graph.IPortDefaults#getLocationParameterInstance location parameter}.
 * </p>
 * @see yfiles.graph.IPortLocationModel#createParameter
 * @see yfiles.graph.IGraph#getPortDefaults
 * @param {?} owner The owner of the port.
 * @param {!yfiles.geometry.Point=} location
 * @return {?} Either a location model parameter that matches the location, or the default parameter to use for the {\@link }
 * as returned by {\@link #getLocationParameterInstance}.
 */
yfiles.graph.IGraph.prototype.createDefaultPortLocationParameter = function(owner, location) {};

/**
 * Convenience method that creates and returns an edge that connects to the given node instances using the given style
 * instance.
 * <p>
 * The nodes must be part of this graph at the time of the invocation, and the implementation will choose the {\@link yfiles.graph.IPort}
 * instances to which the edge will be connected. The edge will be a part of this graph after the method returns. This will
 * trigger the corresponding events.
 * </p>
 * @see yfiles.graph.IGraph#addEdgeCreatedListener
 * @see yfiles.styles.VoidEdgeStyle#INSTANCE
 * @abstract
 * Convenience method that creates and returns an edge that connects to the given node instances using the given style
 * instance.
 * <p>
 * The nodes must be part of this graph at the time of the invocation, and the implementation will choose the {\@link yfiles.graph.IPort}
 * instances to which the edge will be connected. The edge will be a part of this graph after the method returns. This will
 * trigger the corresponding events.
 * </p>
 * @see yfiles.graph.IGraph#addEdgeCreatedListener
 * @see yfiles.styles.VoidEdgeStyle#INSTANCE
 * @abstract
 * Creates and returns an edge that connects to the given port instances.
 * <p>
 * The ports must be part of this graph at the time of the invocation. The edge will be a part of this graph after the
 * method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.IGraph#addEdgeCreatedListener
 * @see yfiles.styles.VoidEdgeStyle#INSTANCE
 * @abstract
 * Creates and returns an edge that connects to the given port instances.
 * <p>
 * The ports must be part of this graph at the time of the invocation. The edge will be a part of this graph after the
 * method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.IGraph#addEdgeCreatedListener
 * @see yfiles.styles.VoidEdgeStyle#INSTANCE
 * @abstract
 * @param {?|{source: ?, target: ?, style: ?, tag: !Object, labels: !Array<?>, ports: !Array<?>, bends: !Array<?>}|{sourcePort: ?, targetPort: ?, style: ?, tag: !Object, labels: !Array<?>, ports: !Array<?>, bends: !Array<?>}} source_or_options_or_sourcePort The source node the created edge will connect to. It is up to the implementation to decide which port to use at the
 * given node. The implementation may create a new port of the edge. / The source port the created edge will connect to.
 * @param {?=} target_or_targetPort The target node the created edge will connect to. It is up to the implementation to decide which port to use at the
 * given node. The implementation may create a new port of the edge. / The target port the created edge will connect to.
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?} the newly created edge instance
 */
yfiles.graph.IGraph.prototype.createEdge = function(source_or_options_or_sourcePort, target_or_targetPort, style, tag) {};

/**
 * Creates a new group node using the provided style and layout as a child of <code>parent</code>.
 * <p>
 * The group node will be a direct descendant of <code>parent</code>.
 * </p>
 * <p>
 * To create group nodes interactively use the {\@link yfiles.input.GraphEditorInputMode} as input mode and enable the
 * {\@link yfiles.input.GraphEditorInputMode#allowGroupingOperations grouping operations}.
 * </p>
 * @abstract
 * Creates a new group node using the provided style and layout as a child of <code>parent</code>.
 * <p>
 * The group node will be a direct descendant of <code>parent</code>.
 * </p>
 * <p>
 * To create group nodes interactively use the {\@link yfiles.input.GraphEditorInputMode} as input mode and enable the
 * {\@link yfiles.input.GraphEditorInputMode#allowGroupingOperations grouping operations}.
 * </p>
 * @abstract
 * @param {?|{parent: ?, layout: !yfiles.geometry.Rect, style: ?, tag: !Object, labels: !Array<?>, ports: !Array<?>, children: !Array<?>}=} parent_or_options
 * @param {!yfiles.geometry.Rect=} layout
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?} The newly created group node.
 */
yfiles.graph.IGraph.prototype.createGroupNode = function(parent_or_options, layout, style, tag) {};

/**
 * Creates and returns a node using the specified values for the initial geometry, style, and {\@link yfiles.graph.ITagOwner#tag}.
 * <p>
 * The node will be a part of this graph after the method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.IGraph#addNodeCreatedListener
 * @see yfiles.styles.VoidNodeStyle#INSTANCE
 * @abstract
 * Creates and returns a node using the specified values for the initial geometry, style, and {\@link yfiles.graph.ITagOwner#tag}.
 * <p>
 * The node will be a part of this graph after the method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.IGraph#addNodeCreatedListener
 * @see yfiles.styles.VoidNodeStyle#INSTANCE
 * @abstract
 * Creates a new ordinary node as a direct descendant of <code>parent</code> using the given layout and style.
 * @throws {Stubs.Exceptions.ArgumentError} <code>parent</code> is not in this graph.
 * @see yfiles.graph.IGraph#setParent
 * @see yfiles.graph.IGraph#createNode
 * @see yfiles.graph.IGraph#createGroupNode
 * @abstract
 * Creates a new ordinary node as a direct descendant of <code>parent</code> using the given layout and style.
 * @throws {Stubs.Exceptions.ArgumentError} <code>parent</code> is not in this graph.
 * @see yfiles.graph.IGraph#setParent
 * @see yfiles.graph.IGraph#createNode
 * @see yfiles.graph.IGraph#createGroupNode
 * @abstract
 * @param {!yfiles.geometry.Rect|{layout: !yfiles.geometry.Rect, style: ?, tag: !Object, labels: !Array<?>, ports: !Array<?>}|?|{parent: ?, layout: !yfiles.geometry.Rect, style: ?, tag: !Object, labels: !Array<?>, ports: !Array<?>}=} layout_or_options_or_parent The layout to use initially. The values will be copied to the node's {\@link #layout Layout} field
 * @param {?|!yfiles.geometry.Rect=} style_or_layout
 * @param {!Object|?=} tag_or_style
 * @param {!Object=} tag
 * @return {?} A newly created node instance / The newly created node.
 */
yfiles.graph.IGraph.prototype.createNode = function(layout_or_options_or_parent, style_or_layout, tag_or_style, tag) {};

/**
 * Creates and returns a node using the specified initial center location and style, as well as the tag.
 * <p>
 * The node will be a part of this graph after the method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.IGraph#addNodeCreatedListener
 * Creates and returns a node using the specified initial center location and style, as well as the tag.
 * <p>
 * The node will be a part of this graph after the method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.IGraph#addNodeCreatedListener
 * @param {!yfiles.geometry.Point|{location: !yfiles.geometry.Point, style: ?, tag: !Object, labels: !Array<?>, ports: !Array<?>}} location_or_options the initial coordinates of the center of the node's {\@link #layout Layout} property
 * @param {?=} style
 * @param {!Object=} tag
 * @return {?} A newly created node instance
 */
yfiles.graph.IGraph.prototype.createNodeAt = function(location_or_options, style, tag) {};

/**
 * Calculates the number of edges at the given {\@link yfiles.graph.IPort} for this graph.
 * <p>
 * Note that an edge that is both incoming and outgoing will be counted twice.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph.
 * Calculates the number of edges at the given {\@link yfiles.graph.IPortOwner} for this graph.
 * <p>
 * Note that an edge that is both incoming and outgoing will be counted twice.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @param {?} port_or_owner The port owner to count the degree of.
 * @return {number} The number of edges that are incident to the port. / The number of edges that are incident to the port owner.
 */
yfiles.graph.IGraph.prototype.degree = function(port_or_owner) {};

/**
 * Returns an {\@link yfiles.collections.IListEnumerable.<T>} for all edges that have the given port owner as their {\@link yfiles.graph.IEdge#targetPort target port's} or {\@link yfiles.graph.IEdge#sourcePort source port's} {\@link yfiles.graph.IPort#owner} depending on the
 * {\@link yfiles.graph.AdjacencyTypes}
 * <p>
 * Note that even though edges can be accessed via index, the underlying graph structure in the default {\@link yfiles.graph.IGraph}
 * implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in
 * your own list, if possible. This is not necessary for the first or last element or when iterating over the adjacent
 * edges via a <code>foreach</code> loop.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @see yfiles.graph.IGraph#inEdgesAt
 * @see yfiles.graph.IGraph#outEdgesAt
 * @see yfiles.graph.AdjacencyTypes
 * @abstract
 * Returns an {\@link yfiles.collections.IEnumerable.<T>} for all edges that are adjacent to the given port as a {\@link yfiles.graph.IEdge#sourcePort} or {\@link yfiles.graph.IEdge#targetPort}.
 * <p>
 * Note that even though edges can be accessed via index, the underlying graph structure in the default {\@link yfiles.graph.IGraph}
 * implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in
 * your own list, if possible. This is not necessary for the first or last element or when iterating over the adjacent
 * edges via a <code>foreach</code> loop.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph.
 * @see yfiles.graph.IGraph#inEdgesAt
 * @see yfiles.graph.IGraph#outEdgesAt
 * @see yfiles.graph.AdjacencyTypes
 * @abstract
 * @param {?} owner_or_port the port owner to check / the port to check
 * @param {yfiles.graph.AdjacencyTypes=} type
 * @return {?<?>} An enumeration of all adjacent edges of the given type.
 */
yfiles.graph.IGraph.prototype.edgesAt = function(owner_or_port, type) {};

/**
 * Returns an enumerable over the children of the provided node.
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @abstract
 * @param {?} node The node for which to return the children or <code>null</code> if the top-level nodes should be returned.
 * @return {?<?>} All nodes that have <code>node</code> as their {\@link #getParent parent}.
 */
yfiles.graph.IGraph.prototype.getChildren = function(node) {};

/**
 * Finds an edge that connects <code>sourcePort</code> and <code>targetPort</code> in the given graph.
 * @throws {Stubs.Exceptions.ArgumentError} <code>sourcePort</code> or <code>targetPort</code> are not in this graph.
 * Finds an edge that connects <code>from</code> and <code>to</code> in the given graph.
 * @throws {Stubs.Exceptions.ArgumentError} <code>from</code> or <code>to</code> are not in this graph.
 * @param {?} sourcePort_or_from The {\@link #sourcePort} of the edge to find. / The {\@link #sourcePort} owner of the edge to find.
 * @param {?} targetPort_or_to The {\@link #targetPort} of the edge to find. / The {\@link #targetPort} owner of the edge to find.
 * @return {?} An edge that satisfies the constraints or <code>null</code>, if none was found.
 */
yfiles.graph.IGraph.prototype.getEdge = function(sourcePort_or_from, targetPort_or_to) {};

/**
 * Gets the {\@link yfiles.graph.ILabelDefaults label defaults} for a given {\@link yfiles.graph.ILabelOwner} in the context of the <code>graph</code>.
 * @param {?} owner The item that the label defaults are returned for. If this is a group node, the {\@link #groupNodeDefaults}'s {\@link #labels label defaults} will be returned,
 * otherwise the {\@link #nodeDefaults} or {\@link #edgeDefaults} {\@link #labels labels} will be returned.
 * @return {?} Appropriate {\@link } for the provided <code>owner</code>.
 */
yfiles.graph.IGraph.prototype.getLabelDefaults = function(owner) {};

/**
 * Returns the parent node of the node or <code>null</code> if <code>node</code> is a top-level node.
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @abstract
 * @param {?} node The node to retrieve the parent node for.
 * @return {?} The parent node in this hierarchy or <code>null</code> if <code>node</code> is a top-level node.
 */
yfiles.graph.IGraph.prototype.getParent = function(node) {};

/**
 * Gets the {\@link yfiles.graph.IPortDefaults port defaults} for a given {\@link yfiles.graph.IPortOwner} in the context of the <code>graph</code>.
 * @param {?} owner The item that the label defaults are returned for. If this is a group node, the {\@link #groupNodeDefaults}'s {\@link #ports port defaults} will be returned,
 * otherwise the {\@link #nodeDefaults} or {\@link #edgeDefaults} {\@link #ports ports} will be returned.
 * @return {?} Appropriate {\@link } for the provided <code>owner</code>.
 */
yfiles.graph.IGraph.prototype.getPortDefaults = function(owner) {};

/**
 * Groups the nodes in <code>children</code> into the provided group node.
 * <p>
 * The <code>parent</code> needs to be a group node at the time of the invocation. This operation is basically the same as calling {\@link yfiles.graph.IGraph#setParent}
 * for each node in <code>children</code> whose parent is not part of the set.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>parent</code> or one of <code>children</code> is not in this graph.
 * @see yfiles.graph.IGraph#groupNodes
 * @see yfiles.graph.IGraph#setParent
 * @see yfiles.graph.IGraph#createGroupNode
 * Groups the nodes in <code>children</code> into a newly created group node.
 * <p>
 * The group node will be created at the common ancestor level of all nodes in <code>children</code>.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} One of <code>children</code> is not in this graph.
 * @see yfiles.graph.GroupingSupport#getNearestCommonAncestor
 * @see yfiles.graph.IGraph#groupNodes
 * Groups the nodes in <code>children</code> into a newly created group node.
 * <p>
 * The group node will be created at the common ancestor level of all nodes in <code>children</code>.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} One of <code>children</code> is not in this graph.
 * @see yfiles.graph.GroupingSupport#getNearestCommonAncestor
 * @see yfiles.graph.IGraph#groupNodes
 * @param {?|?<?>|{children: ?<?>, labels: !Array<?>, ports: !Array<?>}} parent_or_children_or_options The node to use as the parent in the grouping hierarchy. / The children to group into the new group node.
 * @param {?<?>=} children The children to group into the group node.
 * @return {void|?} The newly created group node.
 */
yfiles.graph.IGraph.prototype.groupNodes = function(parent_or_children_or_options, children) {};

/**
 * Calculates the number of incoming edges at the given {\@link yfiles.graph.IPort} for this graph.
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph.
 * Calculates the number of incoming edges at the given {\@link yfiles.graph.IPortOwner} for this graph.
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @param {?} port_or_owner The port to count the incoming edges of. / The port owner to count the incoming edges of.
 * @return {number} The number of edges that have the port as their target port. / The number of edges that have the port owner as their target port's owner.
 */
yfiles.graph.IGraph.prototype.inDegree = function(port_or_owner) {};

/**
 * Convenience method that yields the incoming edges at the given port.
 * <p>
 * This method delegates to {\@link yfiles.graph.IGraph#edgesAt} using {\@link yfiles.graph.AdjacencyTypes#INCOMING}.
 * </p>
 * <p>
 * Note that even though edges can be accessed via index, the underlying graph structure in the default {\@link yfiles.graph.IGraph}
 * implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in
 * your own list, if possible. This is not necessary for the first or last element or when iterating over the incoming
 * edges via a <code>foreach</code> loop.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph.
 * Convenience method that yields the incoming edges at the given owner.
 * <p>
 * This method delegates to {\@link yfiles.graph.IGraph#edgesAt} using {\@link yfiles.graph.AdjacencyTypes#INCOMING}.
 * </p>
 * <p>
 * Note that even though edges can be accessed via index, the underlying graph structure in the default {\@link yfiles.graph.IGraph}
 * implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in
 * your own list, if possible. This is not necessary for the first or last element or when iterating over the incoming
 * edges via a <code>foreach</code> loop.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @param {?} port_or_owner The port of the edges. / The owner of the edges.
 * @return {?<?>} An enumerable for the edges.
 */
yfiles.graph.IGraph.prototype.inEdgesAt = function(port_or_owner) {};

/**
 * Causes the {\@link yfiles.graph.IGraph#addDisplaysInvalidatedListener DisplaysInvalidated} event to be triggered.
 * <p>
 * This method may be called by client code to invalidate all views of the graph that have registered with the {\@link yfiles.graph.IGraph#addDisplaysInvalidatedListener DisplaysInvalidated}
 * event. Views that need to be informed if non-structural changes have been made to the graph should register with the
 * corresponding event.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.graph.IGraph.prototype.invalidateDisplays = function() {};

/**
 * Returns whether the given node is considered a group node.
 * <p>
 * Group nodes may have {\@link yfiles.graph.IGraph#getChildren children} but do not necessarily have to.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @see yfiles.graph.IGraph#getChildren
 * @see yfiles.graph.IGraph#setIsGroupNode
 * @abstract
 * @param {?} node The node to check.
 * @return {boolean} Whether the node is considered a group node.
 */
yfiles.graph.IGraph.prototype.isGroupNode = function(node) {};

/**
 * Enumerates the neighbors of a given {\@link yfiles.graph.INode}.
 * <p>
 * Neighbors are calculated by going through all {\@link yfiles.graph.IPortOwner#ports} and inspecting the {\@link yfiles.graph.IGraph#edgesAt edges at these ports}, collecting the
 * {\@link yfiles.graph.IEdge#opposite}s.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @param {?} node The node.
 * @return {?<?>} An enumerable over all neighbors.
 */
yfiles.graph.IGraph.prototype.neighbors = function(node) {};

/**
 * Calculates the number of outgoing edges at the given {\@link yfiles.graph.IPort} for this graph.
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph.
 * Calculates the number of outgoing edges at the given {\@link yfiles.graph.IPortOwner} for this graph.
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @param {?} port_or_owner The port to count the outgoing edges of. / The port owner to count the outgoing edges of.
 * @return {number} The number of edges that have the port as their source port. / The number of edges that have the port owner as their source port's owner.
 */
yfiles.graph.IGraph.prototype.outDegree = function(port_or_owner) {};

/**
 * Convenience method that yields the outgoing edges at the given port.
 * <p>
 * This method delegates to {\@link yfiles.graph.IGraph#edgesAt} using {\@link yfiles.graph.AdjacencyTypes#OUTGOING}.
 * </p>
 * <p>
 * Note that even though edges can be accessed via index, the underlying graph structure in the default {\@link yfiles.graph.IGraph}
 * implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in
 * your own list, if possible. This is not necessary for the first or last element or when iterating over the outgoing
 * edges via a <code>foreach</code> loop.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph.
 * Convenience method that yields the outgoing edges at the given owner.
 * <p>
 * This method delegates to {\@link yfiles.graph.IGraph#edgesAt} using {\@link yfiles.graph.AdjacencyTypes#OUTGOING}.
 * </p>
 * <p>
 * Note that even though edges can be accessed via index, the underlying graph structure in the default {\@link yfiles.graph.IGraph}
 * implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in
 * your own list, if possible. This is not necessary for the first or last element or when iterating over the outgoing
 * edges via a <code>foreach</code> loop.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>owner</code> is not in this graph.
 * @param {?} port_or_owner The owner of the edges.
 * @return {?<?>} An enumerable for the edges.
 */
yfiles.graph.IGraph.prototype.outEdgesAt = function(port_or_owner) {};

/**
 * Enumerates the predecessors of a given {\@link yfiles.graph.INode}.
 * <p>
 * Predecessors are calculated by going through all {\@link yfiles.graph.IPortOwner#ports} and inspecting the {\@link yfiles.graph.IGraph#inEdgesAt incoming edges at these ports}, collecting the {\@link yfiles.graph.IEdge#sourcePort} {\@link yfiles.graph.IPort#owner}s.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @param {?} node The node.
 * @return {?<?>} An enumerable over all predecessors.
 */
yfiles.graph.IGraph.prototype.predecessors = function(node) {};

/**
 * Removes the given {\@link yfiles.graph.IModelItem item} from this graph.
 * <p>
 * The item must be a part of this graph.
 * </p>
 * <p>
 * If the item is a {\@link yfiles.graph.INode node} the {\@link yfiles.graph.IGraph#addNodeRemovedListener NodeRemoved} event will be triggered. The
 * implementation will remove all adjacent edges and their corresponding ports in proper order before the node will be
 * removed. Also this will trigger the removal of all labels owned by this instance.
 * </p>
 * <p>
 * If the item is an {\@link yfiles.graph.IEdge edge} the {\@link yfiles.graph.IGraph#addEdgeRemovedListener EdgeRemoved} event will be triggered. The
 * implementation may decide to remove the corresponding ports from the node if no other edge connects to them after the
 * given edge has been removed. Also this will trigger the removal of all labels and bends owned by this instance.
 * </p>
 * <p>
 * If the item is a {\@link yfiles.graph.IBend bend} the {\@link yfiles.graph.IGraph#addBendRemovedListener BendRemoved} event will be triggered.
 * </p>
 * <p>
 * If the item is a {\@link yfiles.graph.IPort port} the {\@link yfiles.graph.IGraph#addPortRemovedListener PortRemoved} event will be triggered. This
 * will also remove all edges that are currently connected to the port.
 * </p>
 * <p>
 * If the item is a {\@link yfiles.graph.ILabel label} the {\@link yfiles.graph.IGraph#addLabelRemovedListener LabelRemoved} event will be triggered.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>item</code> is not in this graph.
 * @abstract
 * @param {?} item the live item to be removed from this graph instance
 * @return {void}
 */
yfiles.graph.IGraph.prototype.remove = function(item) {};

/**
 * Reverses an edge by {\@link yfiles.graph.IGraph#setEdgePorts setting source and target port} to {\@link yfiles.graph.IEdge#targetPort} and {\@link yfiles.graph.IEdge#sourcePort}.
 * <p>
 * This also reverses the bends by clearing them and reinserting them in reverse order if there is more than one bend.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>edge</code> is not in this graph.
 * @param {?} edge The edge to reverse.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.reverse = function(edge) {};

/**
 * Modifies the location of the given bend.
 * @throws {Stubs.Exceptions.ArgumentError} <code>bend</code> is not in this graph.
 * @see yfiles.graph.IGraph#addBend
 * @abstract
 * @param {?} bend the bend whose location is to be modified
 * @param {!yfiles.geometry.Point} location the new location of the bend
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setBendLocation = function(bend, location) {};

/**
 * Sets the ports of the given edge to the new values.
 * <p>
 * This will trigger an {\@link yfiles.graph.IGraph#addEdgePortsChangedListener EdgePortsChanged} event if source or target ports
 * differ from the current ones. Both ports and the edge must belong to the current graph instance.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} Either <code>edge</code>, <code>sourcePort</code>, or <code>targetPort</code> are not in this graph.
 * @abstract
 * @param {?} edge The edge to change the ports.
 * @param {?} sourcePort The new source port instance.
 * @param {?} targetPort The new target port instance.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setEdgePorts = function(edge, sourcePort, targetPort) {};

/**
 * Determines whether the given node should be considered a group node.
 * <p>
 * Group nodes may have {\@link yfiles.graph.IGraph#getChildren children} but do not necessarily need to have one. Attempting to set a node to the
 * non-group-node-status while it has children at the same time will result in an {\@link yfiles.lang.Exception}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @throws {Stubs.Exceptions.InvalidOperationError} <code>node</code> is <code>null</code> or currently has children and <code>isGroupNode</code> is <code>false</code>.
 * @see yfiles.graph.IGraph#getChildren
 * @see yfiles.graph.IGraph#isGroupNode
 * @abstract
 * @param {?} node The node to set the group node status for.
 * @param {boolean} isGroupNode Whether to make the node a group node.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setIsGroupNode = function(node, isGroupNode) {};

/**
 * Sets the label model parameter for the given label.
 * @throws {Stubs.Exceptions.ArgumentError} <code>label</code> is not in this graph, or <code>layoutParameter</code> cannot be used for <code>label</code>.
 * @abstract
 * @param {?} label The label.
 * @param {?} layoutParameter The new parameter.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setLabelLayoutParameter = function(label, layoutParameter) {};

/**
 * Sets the preferred size of the label.
 * @throws {Stubs.Exceptions.ArgumentError} <code>label</code> is not in this graph.
 * @see yfiles.graph.ILabel#preferredSize
 * @abstract
 * @param {?} label The label.
 * @param {!yfiles.geometry.Size} preferredSize The new preferred size.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setLabelPreferredSize = function(label, preferredSize) {};

/**
 * Sets the label text of the given label.
 * @throws {Stubs.Exceptions.ArgumentError} <code>label</code> is not in this graph.
 * @see yfiles.graph.ILabel#text
 * @abstract
 * @param {?} label the label to modify
 * @param {string} text the new text of the label
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setLabelText = function(label, text) {};

/**
 * Sets the center of a node to the given world coordinates.
 * <p>
 * This implementation delegates to {\@link yfiles.graph.IGraph#setNodeLayout}
 * </p>
 * @param {?} node The node to recenter.
 * @param {!yfiles.geometry.Point} center The new center coordinates of the node in the world coordinate system.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setNodeCenter = function(node, center) {};

/**
 * Sets the layout of the given node to the new value.
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @see yfiles.graph.INode#layout
 * @abstract
 * @param {?} node a live node that belongs to this graph
 * @param {!yfiles.geometry.Rect} layout The new layout of the node to assign to its {\@link #layout}.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setNodeLayout = function(node, layout) {};

/**
 * Sets the parent node for a given node.
 * <p>
 * Use <code>null</code> as <code>parent</code> to make <code>node</code> a top-level node for this graph.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} Either <code>node</code> or <code>parent</code> are not in this graph.
 * @see yfiles.graph.IGraph#getParent
 * @abstract
 * @param {?} node The node to assign a new parent.
 * @param {?} parent The parent group node to assign to <code>node</code> or <code>null</code> to make <code>node</code> a top-level node.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setParent = function(node, parent) {};

/**
 * Convenience method that tries to set the absolute coordinates of the given port to the given values.
 * <p>
 * For full control over the placement of the ports, the {\@link yfiles.graph.IGraph#setPortLocationParameter} method should be used
 * instead. This implementation will use the port's {\@link yfiles.graph.IPort#locationParameter}'s {\@link yfiles.graph.IPortLocationModelParameter#model} to obtain a new {\@link yfiles.graph.IPortLocationModelParameter} via the {\@link yfiles.graph.IPortLocationModel#createParameter}
 * method. This might result in the port using a different location, because the model might not support parameters that
 * result in the given location. This will also trigger an {\@link yfiles.graph.IGraph#invalidateDisplays} call.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph.
 * @see yfiles.graph.IGraph#addPort
 * @param {?} port The port to modify
 * @param {!yfiles.geometry.Point} location the new absolute coordinates of the port
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setPortLocation = function(port, location) {};

/**
 * Sets a new {\@link yfiles.graph.IPortLocationModelParameter} for the given port.
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph, or <code>locationParameter</code> cannot be used for <code>port</code>.
 * @abstract
 * @param {?} port The port to modify
 * @param {?} locationParameter the new parameter that determines the coordinates of the port
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setPortLocationParameter = function(port, locationParameter) {};

/**
 * Tries to set the location of the port relative to its {\@link yfiles.graph.IPort#owner owner} if the owner is a {\@link yfiles.graph.INode node}.
 * <p>
 * If the port is not owned by a node that is part of this graph, this method will throw an {\@link yfiles.lang.Exception}. This
 * method will delegate to {\@link yfiles.graph.IGraph#setPortLocation}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph or has no owner.
 * @see yfiles.graph.INode#layout
 * @param {?} port the port
 * @param {!yfiles.geometry.Point} relativeLocation the new coordinate offsets relative to the center of the node's {\@link #layout}'s center.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setRelativePortLocation = function(port, relativeLocation) {};

/**
 * Assigns the given style instance by reference to the port.
 * <p>
 * Style instances can be shared.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>port</code> is not in this graph.
 * @see yfiles.graph.IPort#style
 * @see yfiles.graph.IGraph#addPortStyleChangedListener
 * @see yfiles.styles.VoidPortStyle#INSTANCE
 * @abstract
 * Assigns the given style instance by reference to the edge.
 * <p>
 * Style instances can be shared.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>edge</code> is not in this graph.
 * @see yfiles.graph.IEdge#style
 * @see yfiles.graph.IGraph#addEdgeStyleChangedListener
 * @see yfiles.styles.VoidEdgeStyle#INSTANCE
 * @abstract
 * Assigns the given style instance by reference to the label.
 * <p>
 * Style instances can be shared.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>label</code> is not in this graph.
 * @see yfiles.graph.ILabel#style
 * @see yfiles.graph.IGraph#addLabelStyleChangedListener
 * @see yfiles.styles.VoidLabelStyle#INSTANCE
 * @abstract
 * Assigns the given style instance by reference to the node.
 * <p>
 * Style instances can be shared.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @see yfiles.graph.INode#style
 * @see yfiles.graph.IGraph#addNodeStyleChangedListener
 * @see yfiles.styles.VoidNodeStyle#INSTANCE
 * @abstract
 * @param {?} port_or_edge_or_label_or_node The port that will be assigned the new style / The edge that will be assigned the new style / The label that will be assigned the new style / The node that will be assigned the new style
 * @param {?} style The style instance that will be assigned to the port. / The style instance that will be assigned to the edge. / The style instance that will be assigned to the label. / The style instance that will be assigned to the node.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.setStyle = function(port_or_edge_or_label_or_node, style) {};

/**
 * Enumerates the successors of a given {\@link yfiles.graph.INode}.
 * <p>
 * Successors are calculated by going through all {\@link yfiles.graph.IPortOwner#ports} and inspecting the {\@link yfiles.graph.IGraph#outEdgesAt outgoing edges at these ports}, collecting the {\@link yfiles.graph.IEdge#targetPort} {\@link yfiles.graph.IPort#owner}s.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} <code>node</code> is not in this graph.
 * @param {?} node The node.
 * @return {?<?>} An enumerable over all successors.
 */
yfiles.graph.IGraph.prototype.successors = function(node) {};

/**
 * Adds the given listener for the <code>GraphTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of the graph has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#removeGraphTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addGraphTagChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>GraphTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of the graph has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#addGraphTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeGraphTagChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeCreated</code> event that occurs when a node has been created.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addNodeCreatedListener NodeCreated}
 * event if you are interested only in node creation events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the node creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#createNode
 * @see yfiles.graph.IGraph#createNode
 * @see yfiles.graph.IGraph#createGroupNode
 * @see yfiles.input.GraphEditorInputMode#addNodeCreatedListener
 * @see yfiles.graph.IGraph#removeNodeCreatedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addNodeCreatedListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeCreated</code> event that occurs when a node has been created.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addNodeCreatedListener NodeCreated}
 * event if you are interested only in node creation events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the node creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#createNode
 * @see yfiles.graph.IGraph#createNode
 * @see yfiles.graph.IGraph#createGroupNode
 * @see yfiles.input.GraphEditorInputMode#addNodeCreatedListener
 * @see yfiles.graph.IGraph#addNodeCreatedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeNodeCreatedListener = function(listener) {};

/**
 * Adds the given listener for the <code>DisplaysInvalidated</code> event that occurs when the graph has changed visually and the
 * display should be updated to reflect the changes.
 * <p>
 * This event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.graph.IGraph#removeDisplaysInvalidatedListener
 * @abstract
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addDisplaysInvalidatedListener = function(listener) {};

/**
 * Removes the given listener for the <code>DisplaysInvalidated</code> event that occurs when the graph has changed visually and the
 * display should be updated to reflect the changes.
 * <p>
 * This event is invoked with {\@link yfiles.lang.EventArgs#EMPTY} per default.
 * </p>
 * @see yfiles.graph.IGraph#addDisplaysInvalidatedListener
 * @abstract
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeDisplaysInvalidatedListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeRemoved</code> event that occurs when a node has been removed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in node removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the node removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.graph.IGraph#removeNodeRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addNodeRemovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeRemoved</code> event that occurs when a node has been removed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in node removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the node removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.graph.IGraph#addNodeRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeNodeRemovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeStyleChanged</code> event that occurs when a node style has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.graph.IGraph#removeNodeStyleChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addNodeStyleChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeStyleChanged</code> event that occurs when a node style has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.graph.IGraph#addNodeStyleChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeNodeStyleChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeLayoutChanged</code> event that occurs when a node layout has been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setNodeLayout
 * @see yfiles.graph.IGraph#removeNodeLayoutChangedListener
 * @abstract
 * @param {function(!Object, ?, !yfiles.geometry.Rect): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addNodeLayoutChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeLayoutChanged</code> event that occurs when a node layout has been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setNodeLayout
 * @see yfiles.graph.IGraph#addNodeLayoutChangedListener
 * @abstract
 * @param {function(!Object, ?, !yfiles.geometry.Rect): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeNodeLayoutChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>NodeTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of a node has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#removeNodeTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addNodeTagChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>NodeTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of a node has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#addNodeTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeNodeTagChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeCreated</code> event that occurs when an edge has been created.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.CreateEdgeInputMode#addEdgeCreatedListener EdgeCreated}
 * event if you are interested only in edge creation events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the edge creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#createEdge
 * @see yfiles.input.CreateEdgeInputMode#addEdgeCreatedListener
 * @see yfiles.graph.IGraph#removeEdgeCreatedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addEdgeCreatedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeCreated</code> event that occurs when an edge has been created.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.CreateEdgeInputMode#addEdgeCreatedListener EdgeCreated}
 * event if you are interested only in edge creation events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the edge creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#createEdge
 * @see yfiles.input.CreateEdgeInputMode#addEdgeCreatedListener
 * @see yfiles.graph.IGraph#addEdgeCreatedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeEdgeCreatedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeRemoved</code> event that occurs when an edge has been removed.
 * <p>
 * This event will be triggered, too, prior to a node removal.
 * </p>
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in edge removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the edge removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.graph.IGraph#removeEdgeRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addEdgeRemovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeRemoved</code> event that occurs when an edge has been removed.
 * <p>
 * This event will be triggered, too, prior to a node removal.
 * </p>
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in edge removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the edge removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.graph.IGraph#addEdgeRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeEdgeRemovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeStyleChanged</code> event that occurs when an edge style has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.graph.IGraph#removeEdgeStyleChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addEdgeStyleChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeStyleChanged</code> event that occurs when an edge style has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.graph.IGraph#addEdgeStyleChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeEdgeStyleChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgePortsChanged</code> event that occurs when an edge had its {\@link yfiles.graph.IEdge#sourcePort} or {\@link yfiles.graph.IEdge#targetPort} {\@link yfiles.graph.IGraph#setEdgePorts changed}.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setEdgePorts
 * @see yfiles.graph.IGraph#removeEdgePortsChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addEdgePortsChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgePortsChanged</code> event that occurs when an edge had its {\@link yfiles.graph.IEdge#sourcePort} or {\@link yfiles.graph.IEdge#targetPort} {\@link yfiles.graph.IGraph#setEdgePorts changed}.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setEdgePorts
 * @see yfiles.graph.IGraph#addEdgePortsChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.EdgeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeEdgePortsChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>EdgeTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of an edge has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#removeEdgeTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addEdgeTagChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>EdgeTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of an edge has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#addEdgeTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeEdgeTagChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>BendAdded</code> event that occurs when a bend has been added to an edge in this graph.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.CreateBendInputMode#addBendCreatedListener BendCreated}
 * event if you are interested only in bend creation events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the bend creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#addBend
 * @see yfiles.input.CreateBendInputMode#addBendCreatedListener
 * @see yfiles.graph.IGraph#removeBendAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addBendAddedListener = function(listener) {};

/**
 * Removes the given listener for the <code>BendAdded</code> event that occurs when a bend has been added to an edge in this graph.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.CreateBendInputMode#addBendCreatedListener BendCreated}
 * event if you are interested only in bend creation events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the bend creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#addBend
 * @see yfiles.input.CreateBendInputMode#addBendCreatedListener
 * @see yfiles.graph.IGraph#addBendAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeBendAddedListener = function(listener) {};

/**
 * Adds the given listener for the <code>BendRemoved</code> event that occurs when a bend has been removed from an edge in this graph.
 * <p>
 * This event will be triggered, too, if an edge has been removed from the graph, for each of the bends that belonged to
 * the edge.
 * </p>
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in bend removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the bend removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.graph.IGraph#removeBendRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.BendEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addBendRemovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>BendRemoved</code> event that occurs when a bend has been removed from an edge in this
 * graph.
 * <p>
 * This event will be triggered, too, if an edge has been removed from the graph, for each of the bends that belonged to
 * the edge.
 * </p>
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in bend removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the bend removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.graph.IGraph#addBendRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.BendEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeBendRemovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>BendLocationChanged</code> event that occurs when the location of a bend has been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setBendLocation
 * @see yfiles.graph.IGraph#removeBendLocationChangedListener
 * @abstract
 * @param {function(!Object, ?, !yfiles.geometry.Point): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addBendLocationChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>BendLocationChanged</code> event that occurs when the location of a bend has been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setBendLocation
 * @see yfiles.graph.IGraph#addBendLocationChangedListener
 * @abstract
 * @param {function(!Object, ?, !yfiles.geometry.Point): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeBendLocationChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>BendTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of a bend has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#removeBendTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addBendTagChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>BendTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of a bend has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#addBendTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeBendTagChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelAdded</code> event that occurs when a label has been added to this graph instance.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addLabelAddedListener LabelAdded}
 * event if you are interested only in label creation events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the label creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#addLabel
 * @see yfiles.input.GraphEditorInputMode#addLabelAddedListener
 * @see yfiles.graph.IGraph#removeLabelAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addLabelAddedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelAdded</code> event that occurs when a label has been added to this graph instance.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addLabelAddedListener LabelAdded}
 * event if you are interested only in label creation events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the label creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#addLabel
 * @see yfiles.input.GraphEditorInputMode#addLabelAddedListener
 * @see yfiles.graph.IGraph#addLabelAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeLabelAddedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelRemoved</code> event that occurs when a label has been removed from this graph instance.
 * <p>
 * This event will also be triggered, prior to the removal of the {\@link yfiles.graph.ILabel#owner owner} of the label.
 * </p>
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in label removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the label removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.input.GraphEditorInputMode#addLabelTextChangedListener
 * @see yfiles.graph.IGraph#removeLabelRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addLabelRemovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelRemoved</code> event that occurs when a label has been removed from this graph
 * instance.
 * <p>
 * This event will also be triggered, prior to the removal of the {\@link yfiles.graph.ILabel#owner owner} of the label.
 * </p>
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in label removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the label removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.input.GraphEditorInputMode#addLabelTextChangedListener
 * @see yfiles.graph.IGraph#addLabelRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeLabelRemovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelStyleChanged</code> event that occurs when a label style has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.graph.IGraph#removeLabelStyleChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addLabelStyleChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelStyleChanged</code> event that occurs when a label style has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.graph.IGraph#addLabelStyleChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeLabelStyleChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelPreferredSizeChanged</code> event that occurs when the preferred size of a label has been
 * changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setLabelPreferredSize
 * @see yfiles.graph.IGraph#removeLabelPreferredSizeChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !yfiles.geometry.Size>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addLabelPreferredSizeChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelPreferredSizeChanged</code> event that occurs when the preferred size of a label has
 * been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setLabelPreferredSize
 * @see yfiles.graph.IGraph#addLabelPreferredSizeChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !yfiles.geometry.Size>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeLabelPreferredSizeChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelTextChanged</code> event that occurs when the text of a label has been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setLabelText
 * @see yfiles.graph.IGraph#removeLabelTextChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, string>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addLabelTextChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelTextChanged</code> event that occurs when the text of a label has been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setLabelText
 * @see yfiles.graph.IGraph#addLabelTextChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, string>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeLabelTextChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelLayoutParameterChanged</code> event that occurs when the model parameter of a label has
 * been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setLabelLayoutParameter
 * @see yfiles.graph.IGraph#removeLabelLayoutParameterChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addLabelLayoutParameterChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelLayoutParameterChanged</code> event that occurs when the model parameter of a label has
 * been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setLabelLayoutParameter
 * @see yfiles.graph.IGraph#addLabelLayoutParameterChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeLabelLayoutParameterChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of a label has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#removeLabelTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addLabelTagChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of a label has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#addLabelTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeLabelTagChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortAdded</code> event that occurs when a port has been added to this graph instance.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the port creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#addPort
 * @see yfiles.graph.IGraph#createEdge
 * @see yfiles.graph.IGraph#removePortAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addPortAddedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortAdded</code> event that occurs when a port has been added to this graph instance.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the port creation
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#addPort
 * @see yfiles.graph.IGraph#createEdge
 * @see yfiles.graph.IGraph#addPortAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removePortAddedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortRemoved</code> event that occurs when a port has been removed from its {\@link yfiles.graph.IPort#owner owner}.
 * <p>
 * This event will also be triggered prior to the removal of the corresponding owner of the port.
 * </p>
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in port removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the port removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.graph.IGraph#removePortRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.PortEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addPortRemovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortRemoved</code> event that occurs when a port has been removed from its {\@link yfiles.graph.IPort#owner owner}.
 * <p>
 * This event will also be triggered prior to the removal of the corresponding owner of the port.
 * </p>
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure. Please use the {\@link yfiles.input.GraphEditorInputMode#addDeletedItemListener DeletedItem}
 * event if you are interested only in port removal events that result from user interaction.
 * <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the port removal
 * that has triggered this event.
 * </p>
 * @see yfiles.graph.IGraph#remove
 * @see yfiles.input.GraphEditorInputMode#addDeletedItemListener
 * @see yfiles.graph.IGraph#addPortRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.PortEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removePortRemovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortStyleChanged</code> event that occurs when a port style has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.graph.IGraph#removePortStyleChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addPortStyleChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortStyleChanged</code> event that occurs when a port style has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setStyle
 * @see yfiles.graph.IGraph#addPortStyleChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removePortStyleChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortLocationParameterChanged</code> event that occurs when the location model parameter of a
 * port has been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setPortLocationParameter
 * @see yfiles.graph.IGraph#removePortLocationParameterChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addPortLocationParameterChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortLocationParameterChanged</code> event that occurs when the location model parameter of a
 * port has been changed.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.IGraph#setPortLocationParameter
 * @see yfiles.graph.IGraph#addPortLocationParameterChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, ?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removePortLocationParameterChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>PortTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of a port has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#removePortTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addPortTagChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PortTagChanged</code> event that occurs when the {\@link yfiles.graph.ITagOwner#tag tag} of a port has been replaced.
 * <p>
 * This event is intended to provide notification of low level changes in the graph structure.
 * <b>Note:</b>You may not modify the graph in the event handler for this event.
 * </p>
 * @see yfiles.graph.ITagOwner#tag
 * @see yfiles.graph.IGraph#addPortTagChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.ItemChangedEventArgs<?, !Object>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removePortTagChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>ParentChanged</code>
 * event.
 * <br />
 * Event that will be triggered if an node has been reparented in the model.
 * @see yfiles.graph.IGraph#removeParentChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addParentChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>ParentChanged</code>
 * event.
 * <br />
 * Event that will be triggered if an node has been reparented in the model.
 * @see yfiles.graph.IGraph#addParentChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeParentChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>IsGroupNodeChanged</code>
 * event.
 * <br />
 * Event that will be triggered if the group node status of a node has changed.
 * @see yfiles.graph.IGraph#removeIsGroupNodeChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.addIsGroupNodeChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>IsGroupNodeChanged</code>
 * event.
 * <br />
 * Event that will be triggered if the group node status of a node has changed.
 * @see yfiles.graph.IGraph#addIsGroupNodeChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.NodeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.IGraph.prototype.removeIsGroupNodeChangedListener = function(listener) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IGraph;
/**
 * @record
 * @struct
 */
yfiles.graph.NodeEventArgs = function() {};
 /** @type {?} */
yfiles.graph.NodeEventArgs.prototype.parent;
 /** @type {boolean} */
yfiles.graph.NodeEventArgs.prototype.isGroupNode;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.NodeEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.EdgeEventArgs = function() {};
 /** @type {?} */
yfiles.graph.EdgeEventArgs.prototype.sourcePort;
 /** @type {?} */
yfiles.graph.EdgeEventArgs.prototype.targetPort;
 /** @type {?} */
yfiles.graph.EdgeEventArgs.prototype.sourcePortOwner;
 /** @type {?} */
yfiles.graph.EdgeEventArgs.prototype.targetPortOwner;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.EdgeEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.PortEventArgs = function() {};
 /** @type {?} */
yfiles.graph.PortEventArgs.prototype.owner;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.PortEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.LabelEventArgs = function() {};
 /** @type {?} */
yfiles.graph.LabelEventArgs.prototype.owner;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.LabelEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.BendEventArgs = function() {};
 /** @type {?} */
yfiles.graph.BendEventArgs.prototype.owner;
 /** @type {number} */
yfiles.graph.BendEventArgs.prototype.index;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.BendEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.ItemChangedEventArgs = function() {};
 /** @type {TValue} */
yfiles.graph.ItemChangedEventArgs.prototype.oldValue;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.ItemChangedEventArgs.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.ILabel = function() {};
 /** @type {?} */
yfiles.graph.ILabel.prototype.style;
 /** @type {!yfiles.geometry.Size} */
yfiles.graph.ILabel.prototype.preferredSize;
 /** @type {?} */
yfiles.graph.ILabel.prototype.owner;
 /** @type {string} */
yfiles.graph.ILabel.prototype.text;
 /** @type {?} */
yfiles.graph.ILabel.prototype.layoutParameter;
 /** @type {number} */
yfiles.graph.ILabel.prototype.index;
 /** @type {?} */
yfiles.graph.ILabel.prototype.layout;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILabel;
/**
 * @record
 * @struct
 */
yfiles.graph.ILabelDefaults = function() {};
 /** @type {?} */
yfiles.graph.ILabelDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.ILabelDefaults.prototype.autoAdjustPreferredSize;
 /** @type {boolean} */
yfiles.graph.ILabelDefaults.prototype.shareLayoutParameterInstance;
 /** @type {boolean} */
yfiles.graph.ILabelDefaults.prototype.shareStyleInstance;
 /** @type {?} */
yfiles.graph.ILabelDefaults.prototype.layoutParameter;

/**
 * Factory method that returns a label model parameter instance for use with newly created labels.
 * <p>
 * Most implementations will yield either, a {\@link yfiles.lang.ICloneable#clone clone} of or the {\@link yfiles.graph.ILabelDefaults#layoutParameter} property, if {\@link yfiles.graph.ILabelDefaults#shareLayoutParameterInstance} is enabled, but they might use more complicated
 * logic, too.
 * </p>
 * @abstract
 * @param {?} owner The owner of the label that will be created.
 * @return {?} The parameter to use, which for most implementations is either a {\@link #clone clone} of or the {\@link #layoutParameter} property, if {\@link #shareLayoutParameterInstance} is enabled.
 */
yfiles.graph.ILabelDefaults.prototype.getLayoutParameterInstance = function(owner) {};

/**
 * Factory method that returns a style instance for use with newly created labels.
 * <p>
 * Most implementations will yield either, a {\@link yfiles.lang.ICloneable#clone clone} of or the {\@link yfiles.graph.ILabelDefaults#style} property, if {\@link yfiles.graph.ILabelDefaults#shareStyleInstance} is enabled, but they might use more complicated
 * logic, too.
 * </p>
 * @abstract
 * @param {?} owner The owner of the label that will be created.
 * @return {?} The style to use, which for most implementations is either a {\@link #clone clone} of or the {\@link #style} property, if {\@link #shareStyleInstance} is enabled.
 */
yfiles.graph.ILabelDefaults.prototype.getStyleInstance = function(owner) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILabelDefaults;
/**
 * @record
 * @struct
 */
yfiles.graph.ILabelModel = function() {};

/**
 * Creates a default parameter that can be used for this model.
 * @abstract
 * @return {?} a parameter for this model instance
 */
yfiles.graph.ILabelModel.prototype.createDefaultParameter = function() {};

/**
 * Provides a {\@link yfiles.graph.ILookup lookup context} for the given combination of label and parameter.
 * @see yfiles.graph.ILookup#EMPTY
 * @abstract
 * @param {?} label The label to use in the context.
 * @param {?} layoutParameter The parameter to use for the label in the context.
 * @return {?} An implementation of the {\@link } interface that can be used to query additional aspects of the
 * label/parameter combination.
 */
yfiles.graph.ILabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 * Calculates the {\@link yfiles.geometry.IOrientedRectangle geometry} of the given label using the given model parameter.
 * @abstract
 * @param {?} label The label to calculate the geometry for.
 * @param {?} layoutParameter A parameter that is compatible with this model. Typically, this is a parameter that has been created by this model, and
 * its property {\@link #model} returns this instance.
 * @return {?} An {\@link } that describes the geometry of the label. This is typically designed as a
 * flyweight, therefore clients should not cache the instance but store the values if they need a snapshot for later use.
 */
yfiles.graph.ILabelModel.prototype.getGeometry = function(label, layoutParameter) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILabelModel;
/**
 * @record
 * @struct
 */
yfiles.graph.ILabelCandidateDescriptor = function() {};
 /** @type {boolean} */
yfiles.graph.ILabelCandidateDescriptor.prototype.externalCandidate;
 /** @type {number} */
yfiles.graph.ILabelCandidateDescriptor.prototype.edgeOverlapPenalty;
 /** @type {number} */
yfiles.graph.ILabelCandidateDescriptor.prototype.nodeOverlapPenalty;
 /** @type {number} */
yfiles.graph.ILabelCandidateDescriptor.prototype.profit;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILabelCandidateDescriptor;
/**
 * @record
 * @struct
 */
yfiles.graph.ILabelCandidateDescriptorProvider = function() {};

/**
 * Gets the descriptor for a given pair of a label and a {\@link yfiles.graph.ILabelModelParameter}.
 * @abstract
 * @param {?} label The label to possibly assign the <code>layoutParameter</code>.
 * @param {?} layoutParameter The parameter to provide a descriptor for if applied to the given <code>label</code>.
 * @return {?} A descriptor or <code>null</code>.
 */
yfiles.graph.ILabelCandidateDescriptorProvider.prototype.getDescriptor = function(label, layoutParameter) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILabelCandidateDescriptorProvider;
/**
 * @record
 * @struct
 */
yfiles.graph.ConstantLabelCandidateDescriptorProvider = function() {};
 /** @type {?} */
yfiles.graph.ConstantLabelCandidateDescriptorProvider.EXTERNAL_DESCRIPTOR_PROVIDER;
 /** @type {?} */
yfiles.graph.ConstantLabelCandidateDescriptorProvider.INTERNAL_DESCRIPTOR_PROVIDER;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.ConstantLabelCandidateDescriptorProvider.$class;

/**
 * Always yields the parameter that has been passed to the constructor.
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.ConstantLabelCandidateDescriptorProvider.prototype.getDescriptor = function(label, layoutParameter) {};
/**
 * @record
 * @struct
 */
yfiles.graph.LabelCandidateDescriptor = function() {};
 /** @type {?} */
yfiles.graph.LabelCandidateDescriptor.EXTERNAL_DESCRIPTOR;
 /** @type {?} */
yfiles.graph.LabelCandidateDescriptor.INTERNAL_DESCRIPTOR;
 /** @type {boolean} */
yfiles.graph.LabelCandidateDescriptor.prototype.externalCandidate;
 /** @type {number} */
yfiles.graph.LabelCandidateDescriptor.prototype.edgeOverlapPenalty;
 /** @type {number} */
yfiles.graph.LabelCandidateDescriptor.prototype.nodeOverlapPenalty;
 /** @type {number} */
yfiles.graph.LabelCandidateDescriptor.prototype.profit;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.LabelCandidateDescriptor.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.ILabelModelParameter = function() {};
 /** @type {?} */
yfiles.graph.ILabelModelParameter.prototype.model;

/**
 * Determines whether this parameter can be used for a given label instance.
 * <p>
 * A parameter must not necessarily support all types of labels. This method returns whether it supports the given <code>label</code>.
 * For example, a parameter might only support labels that are owned by an {\@link yfiles.graph.INode}.
 * </p>
 * @abstract
 * @param {?} label The label to test.
 * @return {boolean} <code>true</code> if this instance can be used for the given label, <code>false</code> otherwise.
 */
yfiles.graph.ILabelModelParameter.prototype.supports = function(label) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILabelModelParameter;
/**
 * @record
 * @struct
 */
yfiles.graph.ILabelModelParameterFinder = function() {};

/**
 * Tries to find a parameter that best matches the given layout for the provided label instance.
 * <p>
 * This method may not necessarily find a parameter that matches the provided layout exactly. Implementations may choose to
 * simply return the model's {\@link yfiles.graph.ILabelModel#createDefaultParameter default parameter} but may never return <code>null</code>.
 * </p>
 * @abstract
 * @param {?} label The label to find a parameter for.
 * @param {?} model The model instance to use. This should be the instance this instance has been obtained from.
 * @param {?} layout The anticipated layout for the label.
 * @return {?} A non-<code>null</code> parameter that can be used for the label to approximate the provided layout.
 */
yfiles.graph.ILabelModelParameterFinder.prototype.findBestParameter = function(label, model, layout) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILabelModelParameterFinder;
/**
 * @record
 * @struct
 */
yfiles.graph.DefaultLabelModelParameterFinder = function() {};
 /** @type {!yfiles.graph.DefaultLabelModelParameterFinder} */
yfiles.graph.DefaultLabelModelParameterFinder.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.DefaultLabelModelParameterFinder.$class;

/**
 * Calculates a metric for the given label/parameter pair and the target label layout.
 * <p>
 * This implementation gets the geometry from the parameter's model's {\@link yfiles.graph.ILabelModel#getGeometry} method and
 * returns the result of a call to {\@link yfiles.graph.DefaultLabelModelParameterFinder#distance}.
 * </p>
 * @protected
 * @param {?} label The label to apply the parameter to.
 * @param {?} layoutParameter The parameter candidate.
 * @param {?} layout The targeted layout rectangle.
 * @return {number} A metric that indicates the distance between the candidate's layout and the target layout.
 */
yfiles.graph.DefaultLabelModelParameterFinder.prototype.calculateMetric = function(label, layoutParameter, layout) {};

/**
 * Returns the distance between two {\@link yfiles.geometry.IOrientedRectangle} instances.
 * <p>
 * The distance is calculated using the Euclidean distance between the two centers and the angular deviation between the
 * two up vectors.
 * </p>
 * @protected
 * @param {?} rectangle1 The first geometry.
 * @param {?} rectangle2 The geometry to compare the first one with.
 * @return {number} A value indicating the distance between the two instances.
 */
yfiles.graph.DefaultLabelModelParameterFinder.prototype.distance = function(rectangle1, rectangle2) {};

/**
 * Tries to find a parameter that best matches the given layout for the provided label instance.
 * <p>
 * This method may not necessarily find a parameter that matches the provided layout exactly. It will first query the {\@link yfiles.graph.DefaultLabelModelParameterFinder#getCandidateParameters}
 * parameter for an enumeration of candidates and will then find the best matching candidate using a metric calculated by
 * {\@link yfiles.graph.DefaultLabelModelParameterFinder#calculateMetric}. If no parameter can be found this method returns the {\@link yfiles.graph.ILabelModel#createDefaultParameter default parameter}
 * for the model.
 * </p>
 * @param {?} label The label to find a parameter for.
 * @param {?} model The model instance to use. This should be the instance this instance has been obtained from.
 * @param {?} layout The anticipated layout for the label.
 * @return {?} A non-<code>null</code> parameter that can be used for the label to approximate the provided layout.
 */
yfiles.graph.DefaultLabelModelParameterFinder.prototype.findBestParameter = function(label, model, layout) {};

/**
 * Retrieves an enumerator over all candidates for a given label and model.
 * @protected
 * @param {?} label The label.
 * @param {?} model The model of the label.
 * @return {?<?>} An enumerator over the candidates. The enumerator may be empty.
 */
yfiles.graph.DefaultLabelModelParameterFinder.prototype.getCandidateParameters = function(label, model) {};

/**
 * Tries to find a parameter that best matches the given layout for the provided label instance among the set of given
 * parameters.
 * <p>
 * Null may be returned if an empty enumerable is passed.
 * </p>
 * @param {?} label The label to find a parameter for.
 * @param {?} layout The anticipated layout for the label.
 * @param {?<?>} layoutParameters A set of parameters to choose from.
 * @return {?} A parameter that can be used for the label to approximate the provided layout.
 */
yfiles.graph.DefaultLabelModelParameterFinder.prototype.selectBestParameter = function(label, layout, layoutParameters) {};
/**
 * @record
 * @struct
 */
yfiles.graph.ILabelModelParameterProvider = function() {};

/**
 * Returns an enumerator over a set of possible {\@link yfiles.graph.ILabelModelParameter} instances that can be used for the given
 * label and model.
 * @abstract
 * @param {?} label The label instance to use.
 * @param {?} model The model to provide parameters for.
 * @return {?<?>} A possibly empty enumerator over a set of label model parameters.
 */
yfiles.graph.ILabelModelParameterProvider.prototype.getParameters = function(label, model) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILabelModelParameterProvider;
/**
 * @record
 * @struct
 */
yfiles.graph.ILabelOwner = function() {};
 /** @type {?<?>} */
yfiles.graph.ILabelOwner.prototype.labels;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILabelOwner;
/**
 * @record
 * @struct
 */
yfiles.graph.IMapperRegistry = function() {};
 /** @type {?<!Object>} */
yfiles.graph.IMapperRegistry.prototype.registeredTags;

/**
 * Registers a mapper for the given tag.
 * <p>
 * If there already was a mapper for <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>K</code>: The key type for the mapper.
 * Type parameter <code>V</code>: The value type for the mapper.
 * @abstract
 * @template K, V
 * @param {!yfiles.lang.Class} keyType The key type for the mapper.
 * @param {!yfiles.lang.Class} valueType The value type for the mapper.
 * @param {!Object} tag The tag to use.
 * @param {?<K, V>} mapper The mapper to register.
 * @return {void}
 */
yfiles.graph.IMapperRegistry.prototype.addMapper = function(keyType, valueType, tag, mapper) {};

/**
 * Creates a simple read-only {\@link yfiles.collections.IMapper.<K,V>} implementation with key type {\@link yfiles.graph.ILabel} and {\@link yfiles.graph.IMapperRegistry#addMapper adds} it to the <code>registry</code> using the
 * provided <code>tag</code>.
 * <p>
 * The value type of the mapper is inferred by the provided <code>tag</code>. If there already was a mapper for
 * <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.IMapper.<K,V>#fromDelegate
 * Creates a simple read-only {\@link yfiles.collections.IMapper.<K,V>} implementation with key type {\@link yfiles.graph.IEdge} and {\@link yfiles.graph.IMapperRegistry#addMapper adds} it to the <code>registry</code> using the
 * provided <code>tag</code>.
 * <p>
 * The value type of the mapper is inferred by the provided <code>tag</code>. If there already was a mapper for
 * <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.IMapper.<K,V>#fromDelegate
 * Creates a simple read-only {\@link yfiles.collections.IMapper.<K,V>} implementation with key type {\@link yfiles.graph.INode} and {\@link yfiles.graph.IMapperRegistry#addMapper adds} it to the <code>registry</code> using the
 * provided <code>tag</code>.
 * <p>
 * The value type of the mapper is inferred by the provided <code>tag</code>. If there already was a mapper for
 * <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.IMapper.<K,V>#fromDelegate
 * Creates a simple read-only {\@link yfiles.collections.IMapper.<K,V>} implementation and {\@link yfiles.graph.IMapperRegistry#addMapper adds} it to the <code>registry</code> using the provided <code>tag</code>.
 * <p>
 * If there already was a mapper for <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>K</code>: The type of the keys of the mapper.
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.IMapper.<K,V>#fromConstant
 * @template V, K
 * @param {!yfiles.algorithms.ILabelLayoutDpKey<V>|!yfiles.algorithms.EdgeDpKey<V>|!yfiles.algorithms.NodeDpKey<V>|!yfiles.lang.Class} tag_or_keyType The tag.
 * @param {V|!yfiles.lang.Class} constant_or_valueType The value to yield during {\@link } reads.
 * @param {!Object=} tag The tag.
 * @param {V=} constant The value to yield during {\@link } reads.
 * @return {?<?, V>|?<K, V>} The newly created mapper instance.
 */
yfiles.graph.IMapperRegistry.prototype.createConstantMapper = function(tag_or_keyType, constant_or_valueType, tag, constant) {};

/**
 * Creates a delegate-based read-only {\@link yfiles.collections.IMapper.<K,V>} implementation with key type {\@link yfiles.graph.ILabel} and {\@link yfiles.graph.IMapperRegistry#addMapper adds} it to the <code>registry</code> using
 * the provided <code>tag</code>.
 * <p>
 * The value type of the mapper is inferred by the provided <code>tag</code>. If there already was a mapper for
 * <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.IMapper.<K,V>#fromDelegate
 * Creates a delegate-based read-only {\@link yfiles.collections.IMapper.<K,V>} implementation with key type {\@link yfiles.graph.IEdge} and {\@link yfiles.graph.IMapperRegistry#addMapper adds} it to the <code>registry</code> using
 * the provided <code>tag</code>.
 * <p>
 * The value type of the mapper is inferred by the provided <code>tag</code>. If there already was a mapper for
 * <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.IMapper.<K,V>#fromDelegate
 * Creates a delegate-based read-only {\@link yfiles.collections.IMapper.<K,V>} implementation with key type {\@link yfiles.graph.INode} and {\@link yfiles.graph.IMapperRegistry#addMapper adds} it to the <code>registry</code> using
 * the provided <code>tag</code>.
 * <p>
 * The value type of the mapper is inferred by the provided <code>tag</code>. If there already was a mapper for
 * <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.IMapper.<K,V>#fromDelegate
 * Creates a delegate-based read-only {\@link yfiles.collections.IMapper.<K,V>} implementation and {\@link yfiles.graph.IMapperRegistry#addMapper adds} it to the <code>registry</code> using the provided <code>tag</code>.
 * <p>
 * If there already was a mapper for <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>K</code>: The type of the keys of the mapper.
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.IMapper.<K,V>#fromDelegate
 * @template V, K
 * @param {!yfiles.algorithms.ILabelLayoutDpKey<V>|!yfiles.algorithms.EdgeDpKey<V>|!yfiles.algorithms.NodeDpKey<V>|!yfiles.lang.Class} tag_or_keyType The tag.
 * @param {function(?): V|!yfiles.lang.Class} getter_or_valueType The getter delegate to which {\@link } reads will be delegated.
 * @param {!Object=} tag The tag.
 * @param {function(K): V=} getter The getter delegate to which {\@link } reads will be delegated.
 * @return {?<?, V>|?<K, V>} The newly created mapper instance.
 */
yfiles.graph.IMapperRegistry.prototype.createDelegateMapper = function(tag_or_keyType, getter_or_valueType, tag, getter) {};

/**
 * Creates and {\@link yfiles.graph.IMapperRegistry#addMapper adds} a new {\@link yfiles.collections.Mapper.<K,V>} with key type {\@link yfiles.graph.IEdge} to the <code>registry</code> using the provided <code>tag</code>.
 * <p>
 * The value type of the mapper is inferred by the provided <code>tag</code>. If there already was a mapper for
 * <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.Mapper.<K,V>
 * Creates and {\@link yfiles.graph.IMapperRegistry#addMapper adds} a new {\@link yfiles.collections.Mapper.<K,V>} with key type {\@link yfiles.graph.ILabel} to the <code>registry</code> using the provided <code>tag</code>.
 * <p>
 * The value type of the mapper is inferred by the provided <code>tag</code>. If there already was a mapper for
 * <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.Mapper.<K,V>
 * Creates and {\@link yfiles.graph.IMapperRegistry#addMapper adds} a new {\@link yfiles.collections.Mapper.<K,V>} with key type {\@link yfiles.graph.INode} to the <code>registry</code> using the provided <code>tag</code>.
 * <p>
 * The value type of the mapper is inferred by the provided <code>tag</code>. If there already was a mapper for
 * <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.Mapper.<K,V>
 * Creates and {\@link yfiles.graph.IMapperRegistry#addMapper adds} a new {\@link yfiles.collections.Mapper.<K,V>} to the <code>registry</code> using the provided <code>tag</code>.
 * <p>
 * If there already was a mapper for <code>tag</code>, it will be replaced.
 * </p>
 * Type parameter <code>K</code>: The type of the keys of the mapper.
 * Type parameter <code>V</code>: The type of the values of the mapper.
 * @see yfiles.collections.Mapper.<K,V>
 * @template V, K
 * @param {!yfiles.algorithms.EdgeDpKey<V>|!yfiles.algorithms.ILabelLayoutDpKey<V>|!yfiles.algorithms.NodeDpKey<V>|!yfiles.lang.Class} tag_or_keyType The tag.
 * @param {!yfiles.lang.Class=} valueType
 * @param {!Object=} tag The tag.
 * @return {!yfiles.collections.Mapper<?, V>|!yfiles.collections.Mapper<K, V>} The newly created mapper instance.
 */
yfiles.graph.IMapperRegistry.prototype.createMapper = function(tag_or_keyType, valueType, tag) {};

/**
 * Returns a mapper that has previously been registered with this instance for the given tag.
 * Type parameter <code>K</code>: The key type for the mapper.
 * Type parameter <code>V</code>: The value type for the mapper.
 * @abstract
 * @template K, V
 * @param {!Object} tag The tag to use to look up the mapper.
 * @return {?<K, V>} The previously registered instance or <code>null</code>.
 */
yfiles.graph.IMapperRegistry.prototype.getMapper = function(tag) {};

/**
 * Gets the mapper {\@link yfiles.graph.MapperMetadata meta data} for the mapper that is registered using the <code>tag</code>.
 * @abstract
 * @param {!Object} tag The tag.
 * @return {!yfiles.graph.MapperMetadata} The meta data or <code>null</code> if there is no such mapper registered for the given tag.
 */
yfiles.graph.IMapperRegistry.prototype.getMapperMetadata = function(tag) {};

/**
 * Removes a previously registered mapper for the given tag.
 * @abstract
 * @param {!Object} tag The tag that has been used for registering the mapper.
 * @return {void}
 */
yfiles.graph.IMapperRegistry.prototype.removeMapper = function(tag) {};

/**
 * Sets the mapper meta data for the mapper that has been {\@link yfiles.graph.IMapperRegistry#addMapper registered} using the provided <code>tag</code>.
 * @throws {Stubs.Exceptions.ArgumentError} If the {\@link yfiles.graph.MapperMetadata#keyType} or {\@link yfiles.graph.MapperMetadata#valueType} mismatch the mapper instance in the registry.
 * @abstract
 * @param {!Object} tag The tag.
 * @param {!yfiles.graph.MapperMetadata} metadata The meta data to store with the mapper.
 * @return {void}
 */
yfiles.graph.IMapperRegistry.prototype.setMapperMetadata = function(tag, metadata) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IMapperRegistry;
/**
 * @record
 * @struct
 */
yfiles.graph.INode = function() {};
 /** @type {?} */
yfiles.graph.INode.prototype.layout;
 /** @type {?} */
yfiles.graph.INode.prototype.style;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.INode;
/**
 * @record
 * @struct
 */
yfiles.graph.INodeDefaults = function() {};
 /** @type {?} */
yfiles.graph.INodeDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.INodeDefaults.prototype.shareStyleInstance;
 /** @type {?} */
yfiles.graph.INodeDefaults.prototype.ports;
 /** @type {?} */
yfiles.graph.INodeDefaults.prototype.labels;
 /** @type {!yfiles.geometry.Size} */
yfiles.graph.INodeDefaults.prototype.size;

/**
 * Factory method that returns a style instance for use with newly created nodes.
 * <p>
 * Most implementations will yield either, a {\@link yfiles.lang.ICloneable#clone clone} of or the {\@link yfiles.graph.INodeDefaults#style} property, if {\@link yfiles.graph.INodeDefaults#shareStyleInstance} is enabled, but they might use more complicated
 * logic, too.
 * </p>
 * @abstract
 * @return {?} The style to use, which for most implementations is either a {\@link #clone clone} of or the {\@link #style} property, if {\@link #shareStyleInstance} is enabled.
 */
yfiles.graph.INodeDefaults.prototype.getStyleInstance = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.INodeDefaults;
/**
 * @record
 * @struct
 */
yfiles.graph.IPort = function() {};
 /** @type {?} */
yfiles.graph.IPort.prototype.owner;
 /** @type {?} */
yfiles.graph.IPort.prototype.style;
 /** @type {?} */
yfiles.graph.IPort.prototype.locationParameter;
 /** @type {!yfiles.geometry.Point} */
yfiles.graph.IPort.prototype.location;
 /** @type {?} */
yfiles.graph.IPort.prototype.dynamicLocation;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IPort;
/**
 * @record
 * @struct
 */
yfiles.graph.IPortOwner = function() {};
 /** @type {?<?>} */
yfiles.graph.IPortOwner.prototype.ports;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IPortOwner;
/**
 * @record
 * @struct
 */
yfiles.graph.IPortDefaults = function() {};
 /** @type {?} */
yfiles.graph.IPortDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.IPortDefaults.prototype.autoCleanup;
 /** @type {boolean} */
yfiles.graph.IPortDefaults.prototype.shareStyleInstance;
 /** @type {?} */
yfiles.graph.IPortDefaults.prototype.locationParameter;
 /** @type {boolean} */
yfiles.graph.IPortDefaults.prototype.shareLocationParameterInstance;

/**
 * Factory method that returns a location model parameter instance for use with newly created ports.
 * <p>
 * Most implementations will yield either, a {\@link yfiles.lang.ICloneable#clone clone} of or the {\@link yfiles.graph.IPortDefaults#locationParameter} property, if {\@link yfiles.graph.IPortDefaults#shareLocationParameterInstance} is enabled, but they might use more complicated
 * logic, too.
 * </p>
 * @abstract
 * @param {?} owner The owner of the port that will be created.
 * @return {?} The parameter to use, which for most implementations is either a {\@link #clone clone} of or the {\@link #locationParameter} property, if {\@link #shareLocationParameterInstance} is enabled.
 */
yfiles.graph.IPortDefaults.prototype.getLocationParameterInstance = function(owner) {};

/**
 * Factory method that returns a style instance for use with newly created ports.
 * <p>
 * Most implementations will yield either, a {\@link yfiles.lang.ICloneable#clone clone} of or the {\@link yfiles.graph.IPortDefaults#style} property, if {\@link yfiles.graph.IPortDefaults#shareStyleInstance} is enabled, but they might use more complicated
 * logic, too.
 * </p>
 * @abstract
 * @param {?} owner The owner of the port that will be created.
 * @return {?} The style to use, which for most implementations is either a {\@link #clone clone} of or the {\@link #style} property, if {\@link #shareStyleInstance} is enabled.
 */
yfiles.graph.IPortDefaults.prototype.getStyleInstance = function(owner) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IPortDefaults;
/**
 * @record
 * @struct
 */
yfiles.graph.IPortLocationModel = function() {};

/**
 * Factory method that creates a parameter for the given port that tries to match the provided location in absolute world
 * coordinates.
 * @abstract
 * @param {?} owner The port owner that will own the port for which the parameter shall be created.
 * @param {!yfiles.geometry.Point} location The location in the world coordinate system that should be matched as best as possible.
 * @return {?} A new instance that can be used to describe the location of an {\@link } at the given <code>owner</code>.
 */
yfiles.graph.IPortLocationModel.prototype.createParameter = function(owner, location) {};

/**
 * Provides a {\@link yfiles.graph.ILookup lookup context} for the given combination of port and parameter.
 * @abstract
 * @param {?} port The port to use in the context.
 * @param {?} locationParameter The parameter to use for the port in the context.
 * @return {?} An implementation of the {\@link } interface that can be used to query additional aspects of the
 * port/parameter combination.
 */
yfiles.graph.IPortLocationModel.prototype.getContext = function(port, locationParameter) {};

/**
 * Determines the location of the port for the given parameter.
 * @abstract
 * @param {?} port The port to determine the location for.
 * @param {?} locationParameter The parameter to use. The parameter can be expected to be created by this instance having the {\@link #model} property set to this
 * instance..
 * @return {!yfiles.geometry.Point} The calculated location of the port.
 */
yfiles.graph.IPortLocationModel.prototype.getLocation = function(port, locationParameter) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IPortLocationModel;
/**
 * @record
 * @struct
 */
yfiles.graph.IPortLocationModelParameter = function() {};
 /** @type {?} */
yfiles.graph.IPortLocationModelParameter.prototype.model;

/**
 * Determines whether this parameter can be used for ports at the given <code>owner</code>.
 * <p>
 * A parameter must not necessarily support all types of ports. This method returns whether it supports ports at the given
 * <code>owner</code>.
 * </p>
 * @abstract
 * @param {?} owner The port owner to test.
 * @return {boolean} <code>true</code> if this instance can be used for ports of the given port owner, <code>false</code> otherwise.
 */
yfiles.graph.IPortLocationModelParameter.prototype.supports = function(owner) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IPortLocationModelParameter;

/** @const */
yfiles.graph.InteriorStretchLabelModelPosition = {};
/** @const {number} */
yfiles.graph.InteriorStretchLabelModelPosition.NORTH;
/** @const {number} */
yfiles.graph.InteriorStretchLabelModelPosition.EAST;
/** @const {number} */
yfiles.graph.InteriorStretchLabelModelPosition.SOUTH;
/** @const {number} */
yfiles.graph.InteriorStretchLabelModelPosition.WEST;
/** @const {number} */
yfiles.graph.InteriorStretchLabelModelPosition.CENTER;
/**
 * @record
 * @struct
 */
yfiles.graph.InteriorStretchLabelModel = function() {};
 /** @type {?} */
yfiles.graph.InteriorStretchLabelModel.NORTH;
 /** @type {?} */
yfiles.graph.InteriorStretchLabelModel.EAST;
 /** @type {?} */
yfiles.graph.InteriorStretchLabelModel.SOUTH;
 /** @type {?} */
yfiles.graph.InteriorStretchLabelModel.WEST;
 /** @type {?} */
yfiles.graph.InteriorStretchLabelModel.CENTER;
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.InteriorStretchLabelModel.prototype.insets;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.InteriorStretchLabelModel.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.InteriorStretchLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates the parameter for the given position.
 * @param {yfiles.graph.InteriorStretchLabelModelPosition} position The position.
 * @return {?}
 */
yfiles.graph.InteriorStretchLabelModel.prototype.createParameter = function(position) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.InteriorStretchLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.InteriorStretchLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 * Returns the minimum size this model would require for the node owner of the label if the the given label was used with
 * the provided parameter.
 * @param {?} label The label to use.
 * @param {?} layoutParameter The parameter to use.
 * @return {!yfiles.geometry.Size} The minimum size requirements for this label.
 */
yfiles.graph.InteriorStretchLabelModel.prototype.getMinimumNodeSize = function(label, layoutParameter) {};

/**
 * Returns the insets this model would require for the node owner of the label if the the given label was used with the
 * provided parameter.
 * @param {?} label The label to use.
 * @param {?} layoutParameter The parameter to use.
 * @return {!yfiles.geometry.Insets} The insets rectangle.
 */
yfiles.graph.InteriorStretchLabelModel.prototype.getNodeInsets = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} model
 * @return {?<?>}
 */
yfiles.graph.InteriorStretchLabelModel.prototype.getParameters = function(label, model) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.InteriorStretchLabelModel.prototype.lookup = function(type) {};

/** @const */
yfiles.graph.InteriorLabelModelPosition = {};
/** @const {number} */
yfiles.graph.InteriorLabelModelPosition.NORTH;
/** @const {number} */
yfiles.graph.InteriorLabelModelPosition.EAST;
/** @const {number} */
yfiles.graph.InteriorLabelModelPosition.SOUTH;
/** @const {number} */
yfiles.graph.InteriorLabelModelPosition.WEST;
/** @const {number} */
yfiles.graph.InteriorLabelModelPosition.NORTH_EAST;
/** @const {number} */
yfiles.graph.InteriorLabelModelPosition.SOUTH_EAST;
/** @const {number} */
yfiles.graph.InteriorLabelModelPosition.NORTH_WEST;
/** @const {number} */
yfiles.graph.InteriorLabelModelPosition.SOUTH_WEST;
/** @const {number} */
yfiles.graph.InteriorLabelModelPosition.CENTER;
/**
 * @record
 * @struct
 */
yfiles.graph.InteriorLabelModel = function() {};
 /** @type {?} */
yfiles.graph.InteriorLabelModel.NORTH;
 /** @type {?} */
yfiles.graph.InteriorLabelModel.EAST;
 /** @type {?} */
yfiles.graph.InteriorLabelModel.SOUTH;
 /** @type {?} */
yfiles.graph.InteriorLabelModel.SOUTH_EAST;
 /** @type {?} */
yfiles.graph.InteriorLabelModel.SOUTH_WEST;
 /** @type {?} */
yfiles.graph.InteriorLabelModel.WEST;
 /** @type {?} */
yfiles.graph.InteriorLabelModel.NORTH_EAST;
 /** @type {?} */
yfiles.graph.InteriorLabelModel.NORTH_WEST;
 /** @type {?} */
yfiles.graph.InteriorLabelModel.CENTER;
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.InteriorLabelModel.prototype.insets;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.InteriorLabelModel.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.InteriorLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates the parameter for the given position.
 * @param {yfiles.graph.InteriorLabelModelPosition} position The position.
 * @return {?}
 */
yfiles.graph.InteriorLabelModel.prototype.createParameter = function(position) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.InteriorLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.InteriorLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 * Returns the minimum size this model would require for the node owner of the label if the the given label was used with
 * the provided parameter.
 * @param {?} label The label to use.
 * @param {?} layoutParameter The parameter to use.
 * @return {!yfiles.geometry.Size} The minimum size requirements for this label.
 */
yfiles.graph.InteriorLabelModel.prototype.getMinimumNodeSize = function(label, layoutParameter) {};

/**
 * Returns the insets this model would require for the node owner of the label if the the given label was used with the
 * provided parameter.
 * @param {?} label The label to use.
 * @param {?} layoutParameter The parameter to use.
 * @return {!yfiles.geometry.Insets} The insets rectangle.
 */
yfiles.graph.InteriorLabelModel.prototype.getNodeInsets = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} model
 * @return {?<?>}
 */
yfiles.graph.InteriorLabelModel.prototype.getParameters = function(label, model) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.InteriorLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.MapperMetadata = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graph.MapperMetadata.prototype.keyType;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.MapperMetadata.prototype.valueType;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.MapperMetadata.$class;

/**
 * Creates an instance for the specified mapper.
 * Type parameter <code>TKey</code>: The type of the keys.
 * Type parameter <code>TValue</code>: The type of the values.
 * @template TKey, TValue
 * @param {!yfiles.lang.Class} keyType The type of the keys.
 * @param {!yfiles.lang.Class} valueType The type of the values.
 * @param {?<TKey, TValue>} mapper The mapper instance to create the metadata for.
 * @return {!yfiles.graph.MapperMetadata} An instance that uses the {\@link #keyType} and {\@link #valueType} of the mapper.
 */
yfiles.graph.MapperMetadata.create = function(keyType, valueType, mapper) {};
/**
 * @record
 * @struct
 */
yfiles.graph.MapperRegistry = function() {};
 /** @type {?<!Object>} */
yfiles.graph.MapperRegistry.prototype.registeredTags;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.MapperRegistry.$class;

/**
 * 
 * Type parameter <code>K</code>.
 * Type parameter <code>V</code>.
 * @template K, V
 * @param {!yfiles.lang.Class} keyType
 * @param {!yfiles.lang.Class} valueType
 * @param {!Object} tag
 * @param {?<K, V>} mapper
 * @return {void}
 */
yfiles.graph.MapperRegistry.prototype.addMapper = function(keyType, valueType, tag, mapper) {};

/**
 * 
 * Type parameter <code>K</code>.
 * Type parameter <code>V</code>.
 * @template K, V
 * @param {!Object} tag
 * @return {?<K, V>}
 */
yfiles.graph.MapperRegistry.prototype.getMapper = function(tag) {};

/**
 *
 * @param {!Object} tag
 * @return {!yfiles.graph.MapperMetadata}
 */
yfiles.graph.MapperRegistry.prototype.getMapperMetadata = function(tag) {};

/**
 *
 * @param {!Object} tag
 * @return {void}
 */
yfiles.graph.MapperRegistry.prototype.removeMapper = function(tag) {};

/**
 *
 * @param {!Object} tag
 * @param {!yfiles.graph.MapperMetadata} metadata
 * @return {void}
 */
yfiles.graph.MapperRegistry.prototype.setMapperMetadata = function(tag, metadata) {};

/** @const */
yfiles.graph.NinePositionsEdgeLabelModelPosition = {};
/** @const {number} */
yfiles.graph.NinePositionsEdgeLabelModelPosition.SOURCE_ABOVE;
/** @const {number} */
yfiles.graph.NinePositionsEdgeLabelModelPosition.CENTER_ABOVE;
/** @const {number} */
yfiles.graph.NinePositionsEdgeLabelModelPosition.TARGET_ABOVE;
/** @const {number} */
yfiles.graph.NinePositionsEdgeLabelModelPosition.SOURCE_CENTERED;
/** @const {number} */
yfiles.graph.NinePositionsEdgeLabelModelPosition.CENTER_CENTERED;
/** @const {number} */
yfiles.graph.NinePositionsEdgeLabelModelPosition.TARGET_CENTERED;
/** @const {number} */
yfiles.graph.NinePositionsEdgeLabelModelPosition.SOURCE_BELOW;
/** @const {number} */
yfiles.graph.NinePositionsEdgeLabelModelPosition.CENTER_BELOW;
/** @const {number} */
yfiles.graph.NinePositionsEdgeLabelModelPosition.TARGET_BELOW;
/**
 * @record
 * @struct
 */
yfiles.graph.NinePositionsEdgeLabelModel = function() {};
 /** @type {?} */
yfiles.graph.NinePositionsEdgeLabelModel.SOURCE_ABOVE;
 /** @type {?} */
yfiles.graph.NinePositionsEdgeLabelModel.CENTER_ABOVE;
 /** @type {?} */
yfiles.graph.NinePositionsEdgeLabelModel.TARGET_ABOVE;
 /** @type {?} */
yfiles.graph.NinePositionsEdgeLabelModel.SOURCE_CENTERED;
 /** @type {?} */
yfiles.graph.NinePositionsEdgeLabelModel.CENTER_CENTERED;
 /** @type {?} */
yfiles.graph.NinePositionsEdgeLabelModel.TARGET_CENTERED;
 /** @type {?} */
yfiles.graph.NinePositionsEdgeLabelModel.SOURCE_BELOW;
 /** @type {?} */
yfiles.graph.NinePositionsEdgeLabelModel.CENTER_BELOW;
 /** @type {?} */
yfiles.graph.NinePositionsEdgeLabelModel.TARGET_BELOW;
 /** @type {number} */
yfiles.graph.NinePositionsEdgeLabelModel.prototype.angle;
 /** @type {number} */
yfiles.graph.NinePositionsEdgeLabelModel.prototype.distance;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.NinePositionsEdgeLabelModel.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.NinePositionsEdgeLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Create a model parameter for the specified <code>position</code>
 * @param {yfiles.graph.NinePositionsEdgeLabelModelPosition} position The position for this parameter
 * @return {?} a model parameter for the specified <code>position</code>
 */
yfiles.graph.NinePositionsEdgeLabelModel.prototype.createParameter = function(position) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.NinePositionsEdgeLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.NinePositionsEdgeLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} model
 * @return {?<?>}
 */
yfiles.graph.NinePositionsEdgeLabelModel.prototype.getParameters = function(label, model) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.NinePositionsEdgeLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.SandwichLabelModel = function() {};
 /** @type {?} */
yfiles.graph.SandwichLabelModel.NORTH;
 /** @type {?} */
yfiles.graph.SandwichLabelModel.SOUTH;
 /** @type {number} */
yfiles.graph.SandwichLabelModel.prototype.yOffset;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.SandwichLabelModel.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.SandwichLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates a parameter for the north side of the node.
 * @return {?}
 */
yfiles.graph.SandwichLabelModel.prototype.createNorthParameter = function() {};

/**
 * Creates a parameter for the south side of the node.
 * @return {?}
 */
yfiles.graph.SandwichLabelModel.prototype.createSouthParameter = function() {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.SandwichLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.SandwichLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} model
 * @return {?<?>}
 */
yfiles.graph.SandwichLabelModel.prototype.getParameters = function(label, model) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.SandwichLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.SegmentRatioPortLocationModel = function() {};
 /** @type {!yfiles.graph.SegmentRatioPortLocationModel} */
yfiles.graph.SegmentRatioPortLocationModel.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.SegmentRatioPortLocationModel.$class;

/**
 * Creates the a new parameter for the specified segment index and ratio.
 * @param {number} ratio The ratio for the segment, with <code>0</code> being at the start of the segment and <code>1</code> at the end.
 * @param {number} segmentIndex The index of the segment.
 * @return {?} A parameter for the given ratio and segment.
 */
yfiles.graph.SegmentRatioPortLocationModel.prototype.createFromSource = function(ratio, segmentIndex) {};

/**
 * Creates the a new parameter for the specified segment index counted from the target end of the edge and the provided
 * ratio.
 * @param {number} ratio The ratio for the segment, with <code>0</code> being at the start of the segment and <code>1</code> at the end.
 * @param {number} segmentIndex The index of the segment counted from the target end.
 * @return {?} A parameter for the given ratio and segment.
 */
yfiles.graph.SegmentRatioPortLocationModel.prototype.createFromTarget = function(ratio, segmentIndex) {};

/**
 *
 * @param {?} owner
 * @param {!yfiles.geometry.Point} location
 * @return {?}
 */
yfiles.graph.SegmentRatioPortLocationModel.prototype.createParameter = function(owner, location) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {?}
 */
yfiles.graph.SegmentRatioPortLocationModel.prototype.getContext = function(port, locationParameter) {};

/**
 *
 * @param {?} port
 * @param {?} locationParameter
 * @return {!yfiles.geometry.Point}
 */
yfiles.graph.SegmentRatioPortLocationModel.prototype.getLocation = function(port, locationParameter) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.SegmentRatioPortLocationModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.SmartEdgeLabelModel = function() {};
 /** @type {boolean} */
yfiles.graph.SmartEdgeLabelModel.prototype.autoRotation;
 /** @type {number} */
yfiles.graph.SmartEdgeLabelModel.prototype.angle;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.SmartEdgeLabelModel.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.SmartEdgeLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates a parameter that measures the provided segment index from the source side of the edge path.
 * @param {number} segmentIndex The zero-based index of the segment beginning from the source side.
 * @param {number} distance The distance between the label's box and the edge's path.
 * @param {number} segmentRatio The ratio at which to place the label at the segment. A ratio of <code>0.0</code> will place the label at the source side of the
 * segment, a ratio of <code>1.0</code> at the target side. Ratios lesser than <code>0.0</code> or greater than <code>1.0</code> will be interpreted as absolute
 * values in world coordinates.
 * @return {?} A label parameter that describes the provided parameters for this model instance.
 */
yfiles.graph.SmartEdgeLabelModel.prototype.createParameterFromSource = function(segmentIndex, distance, segmentRatio) {};

/**
 * Creates a parameter that measures the provided segment index from the target side of the edge path.
 * @param {number} segmentIndex The zero-based index of the segment beginning from the target side.
 * @param {number} distance The distance between the label's box and the edge's path.
 * @param {number} segmentRatio The ratio at which to place the label at the segment. A ratio of <code>0.0</code> will place the label at the target side of the
 * segment, a ratio of <code>1.0</code> at the source side. Ratios lesser than <code>0.0</code> or greater than <code>1.0</code> will be interpreted as absolute
 * values in world coordinates.
 * @return {?} A label parameter that describes the provided parameters for this model instance.
 */
yfiles.graph.SmartEdgeLabelModel.prototype.createParameterFromTarget = function(segmentIndex, distance, segmentRatio) {};

/**
 *
 * @param {?} label
 * @param {?} model
 * @param {?} layout
 * @return {?}
 */
yfiles.graph.SmartEdgeLabelModel.prototype.findBestParameter = function(label, model, layout) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.SmartEdgeLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 * Gets the distance from the edge path described by the specified parameter.
 * @param {?} layoutParameter The parameter to get the edge path distance for.
 * @return {number} The distance from the edge path
 */
yfiles.graph.SmartEdgeLabelModel.prototype.getDistance = function(layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.SmartEdgeLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.SmartEdgeLabelModel.prototype.lookup = function(type) {};

/** @const */
yfiles.graph.StripeTypes = {};
/** @const {number} */
yfiles.graph.StripeTypes.ROW;
/** @const {number} */
yfiles.graph.StripeTypes.COLUMN;
/** @const {number} */
yfiles.graph.StripeTypes.ALL;
/** @const {number} */
yfiles.graph.StripeTypes.NONE;
/**
 * @record
 * @struct
 */
yfiles.graph.PortDefaults = function() {};
 /** @type {boolean} */
yfiles.graph.PortDefaults.prototype.autoCleanup;
 /** @type {?} */
yfiles.graph.PortDefaults.prototype.locationParameter;
 /** @type {boolean} */
yfiles.graph.PortDefaults.prototype.shareLocationParameterInstance;
 /** @type {?} */
yfiles.graph.PortDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.PortDefaults.prototype.shareStyleInstance;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.PortDefaults.$class;

/**
 * Factory method that returns a style instance for use with newly created ports.
 * <p>
 * Most implementations will yield either, a {\@link yfiles.lang.ICloneable#clone clone} of or the {\@link yfiles.graph.PortDefaults#style} property, if {\@link yfiles.graph.PortDefaults#shareStyleInstance} is enabled, but they might use more complicated
 * logic, too.
 * </p>
 * @return {?} The style to use, which for most implementations is either a {\@link #clone clone} of or the {\@link #style} property, if {\@link #shareStyleInstance} is enabled.
 */
yfiles.graph.PortDefaults.prototype.GetDefaultStyleInstance = function() {};

/**
 *
 * @param {?} owner
 * @return {?}
 */
yfiles.graph.PortDefaults.prototype.getLocationParameterInstance = function(owner) {};

/**
 *
 * @param {?} owner
 * @return {?}
 */
yfiles.graph.PortDefaults.prototype.getStyleInstance = function(owner) {};
/**
 * @record
 * @struct
 */
yfiles.graph.NodeDefaults = function() {};
 /** @type {!yfiles.geometry.Size} */
yfiles.graph.NodeDefaults.prototype.size;
 /** @type {?} */
yfiles.graph.NodeDefaults.prototype.labels;
 /** @type {?} */
yfiles.graph.NodeDefaults.prototype.ports;
 /** @type {?} */
yfiles.graph.NodeDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.NodeDefaults.prototype.shareStyleInstance;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.NodeDefaults.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.NodeDefaults.prototype.getStyleInstance = function() {};
/**
 * @record
 * @struct
 */
yfiles.graph.EdgeDefaults = function() {};
 /** @type {?} */
yfiles.graph.EdgeDefaults.prototype.labels;
 /** @type {?} */
yfiles.graph.EdgeDefaults.prototype.ports;
 /** @type {?} */
yfiles.graph.EdgeDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.EdgeDefaults.prototype.shareStyleInstance;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.EdgeDefaults.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.EdgeDefaults.prototype.getStyleInstance = function() {};
/**
 * @record
 * @struct
 */
yfiles.graph.LabelDefaults = function() {};
 /** @type {boolean} */
yfiles.graph.LabelDefaults.prototype.autoAdjustPreferredSize;
 /** @type {boolean} */
yfiles.graph.LabelDefaults.prototype.shareLayoutParameterInstance;
 /** @type {?} */
yfiles.graph.LabelDefaults.prototype.layoutParameter;
 /** @type {?} */
yfiles.graph.LabelDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.LabelDefaults.prototype.shareStyleInstance;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.LabelDefaults.$class;

/**
 *
 * @param {?} owner
 * @return {?}
 */
yfiles.graph.LabelDefaults.prototype.getLayoutParameterInstance = function(owner) {};

/**
 *
 * @param {?} owner
 * @return {?}
 */
yfiles.graph.LabelDefaults.prototype.getStyleInstance = function(owner) {};
/**
 * @record
 * @struct
 */
yfiles.graph.IGroupBoundsCalculator = function() {};

/**
 * Calculates the bounds of the {\@link yfiles.graph.INode#layout} for the given <code>groupNode</code> that is a group node in the <code>graph</code>.
 * @abstract
 * @param {?} graph The graph which holds the <code>groupNode</code>.
 * @param {?} groupNode The node to calculate the bounds for.
 * @return {!yfiles.geometry.Rect} The minimum bounds to use for the given group node.
 */
yfiles.graph.IGroupBoundsCalculator.prototype.calculateBounds = function(graph, groupNode) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IGroupBoundsCalculator;
/**
 * @record
 * @struct
 */
yfiles.graph.CompositeUndoUnit = function() {};
 /** @type {number} */
yfiles.graph.CompositeUndoUnit.prototype.count;
 /** @type {string} */
yfiles.graph.CompositeUndoUnit.prototype.redoName;
 /** @type {string} */
yfiles.graph.CompositeUndoUnit.prototype.undoName;
 /** @type {boolean} */
yfiles.graph.CompositeUndoUnit.prototype.disposed;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.CompositeUndoUnit.$class;

/**
 * Adds a new {\@link yfiles.graph.IUndoUnit} to the queue.
 * @param {?} unit The unit of work to add.
 * @return {void}
 */
yfiles.graph.CompositeUndoUnit.prototype.add = function(unit) {};

/**
 * Determines whether a call to {\@link yfiles.graph.CompositeUndoUnit#redo} can be made.
 * @return {boolean}
 */
yfiles.graph.CompositeUndoUnit.prototype.canRedo = function() {};

/**
 * Determines whether a call to {\@link yfiles.graph.CompositeUndoUnit#undo} can be made.
 * @return {boolean}
 */
yfiles.graph.CompositeUndoUnit.prototype.canUndo = function() {};

/**
 * Clears the internal collection of units.
 * @return {void}
 */
yfiles.graph.CompositeUndoUnit.prototype.clear = function() {};

/**
 * Disposes this unit and all of its contents.
 * <p>
 * This unit cannot be used anymore after this has been invoked.
 * </p>
 * @return {void}
 */
yfiles.graph.CompositeUndoUnit.prototype.dispose = function() {};

/**
 * Redoes the next {\@link yfiles.graph.IUndoUnit}.
 * @throws {Stubs.Exceptions.NotSupportedError} If an undo operation is already in progress.
 * @throws {yfiles.lang.Exception} If {\@link yfiles.graph.CompositeUndoUnit#canRedo} would yield <code>false</code>.
 * @return {void}
 */
yfiles.graph.CompositeUndoUnit.prototype.redo = function() {};

/**
 * Tries to remove a given unit from this compound unit.
 * <p>
 * This method will throw an exception if this unit has been undone or an undo or redo is in progress or this unit has
 * already been disposed. This method will not automatically {\@link yfiles.graph.IUndoUnit#dispose Dispose} removed units.
 * </p>
 * @param {?} unit The unit to remove.
 * @return {boolean} <code>true</code> iff the unit has been removed from this instance.
 */
yfiles.graph.CompositeUndoUnit.prototype.removeUnit = function(unit) {};

/**
 * Undoes the next {\@link yfiles.graph.IUndoUnit}.
 * @throws {Stubs.Exceptions.NotSupportedError} If an undo operation is already in progress.
 * @throws {yfiles.lang.Exception} If {\@link yfiles.graph.CompositeUndoUnit#canUndo} would yield <code>false</code>.
 * @return {void}
 */
yfiles.graph.CompositeUndoUnit.prototype.undo = function() {};
/**
 * @record
 * @struct
 */
yfiles.graph.ICompoundEdit = function() {};

/**
 * This method cancels the compound editing process.
 * <p>
 * The recorded {\@link yfiles.graph.IUndoUnit}s are {\@link yfiles.graph.IUndoUnit#dispose disposed} and the edit is not usable anymore.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.graph.ICompoundEdit.prototype.cancel = function() {};

/**
 * This method commits the compound editing process.
 * <p>
 * The {\@link yfiles.graph.IUndoUnit}s are enqueued into the corresponding {\@link yfiles.graph.UndoEngine} instance and the edit is not
 * usable anymore.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.graph.ICompoundEdit.prototype.commit = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ICompoundEdit;
/**
 * @record
 * @struct
 */
yfiles.graph.ILookup = function() {};

/**
 * Returns an instance that implements the given type or <code>null</code>.
 * <p>
 * Typically, this method will be called in order to obtain a different view or aspect of the current instance. This is
 * quite similar to casting or using a super type or interface of this instance, but is not limited to inheritance or
 * compile time constraints. An instance implementing this method is not required to return non-<code>null</code> implementations for
 * the types, nor does it have to return the same instance any time. Also it depends on the type and context whether the
 * instance returned stays up to date or needs to be reobtained for subsequent use.
 * </p>
 * @abstract
 * @param {!yfiles.lang.Class} type the type for which an instance shall be returned
 * @return {!Object} an instance that is assignable to type or <code>null</code>
 */
yfiles.graph.ILookup.prototype.lookup = function(type) {};
 /** @type {{createCascadingLookup: function(?, ?): ?, createDynamicLookup: function(!Object): ?, createMapLookup: function(!yfiles.collections.Map<!yfiles.lang.Class, !Object>): ?, createSingleLookup: function(!Object, !yfiles.lang.Class): ?, EMPTY: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILookup;
/**
 * @record
 * @struct
 */
yfiles.graph.IContextLookup = function() {};

/**
 * Tries to create or retrieve an implementation of the given type for a given item.
 * @see yfiles.graph.ILookup#lookup
 * @abstract
 * @param {!Object} item the item to lookup a type for
 * @param {!yfiles.lang.Class} type the type to look up
 * @return {!Object} an implementation or <code>null</code>
 */
yfiles.graph.IContextLookup.prototype.contextLookup = function(item, type) {};
 /** @type {{EMPTY_CONTEXT_LOOKUP: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IContextLookup;
/**
 * @record
 * @struct
 */
yfiles.graph.IContextLookupChainLink = function() {};

/**
 * This method is called by the framework to register the fallback lookup implementation that should be used during a call
 * to {\@link yfiles.graph.IContextLookup#contextLookup}.
 * <p>
 * If the implementation cannot satisfy the query, it will use the provided context as a fallback. Note that
 * implementations can also use the results returned by the next lookup and decorate it appropriately.
 * </p>
 * @abstract
 * @param {?} next The context to use as a fallback.
 * @return {void}
 */
yfiles.graph.IContextLookupChainLink.prototype.setNext = function(next) {};
 /** @type {{addingLookupChainLink: ?, createContextLookupChainLink: function(function(!Object, !yfiles.lang.Class): !Object): ?, factoryLookupChainLink: function(!yfiles.lang.Class, !yfiles.lang.Class, function(TContext): TResult): ?, hidingLookupChainLink: function(!yfiles.lang.Class): ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IContextLookupChainLink;
/**
 * @record
 * @struct
 */
yfiles.graph.ILookupDecorator = function() {};

/**
 * Adds a lookup implementation for a given type using a function of type <code>function(TContext, TResult)</code>.
 * <p>
 * This method is closely related to the {\@link yfiles.graph.ILookupDecorator#add} method, however it passes the result of the
 * remaining chain to the delegate for convenient wrapping of the result. Note that if the implementation does not depend
 * on the previous result in order to wrap it, it is better to use that variant, in order to avoid the possibly costly
 * evaluation of the remainder of the lookup chain.
 * </p>
 * Type parameter <code>TContext</code>: The type of the context subject.
 * Type parameter <code>TResult</code>: The type of the query, which is a base type or the type of the result.
 * Adds a lookup implementation for a given type using a func.
 * Type parameter <code>TContext</code>: The type of the context subject.
 * Type parameter <code>TResult</code>: The type of the query, which is a base type or the type of the result.
 * @template TContext, TResult
 * @param {!yfiles.lang.Class} contextType
 * @param {!yfiles.lang.Class} resultType
 * @param {function(TContext, TResult): TResult|function(TContext): TResult} wrapperFactory_or_factory The factory delegate that will be used to satisfy queries of type <code>TResult</code> / The factory delegate that will be used to satisfy queries of type <code>TResult</code>.
 * @param {boolean=} decorateNull_or_nullIsFallback
 * @return {?} The {\@link } instance as returned by the {\@link #addLookup} call or
 * <code>null</code>, if either <code>decorator</code> was <code>null</code>, or it {\@link #canDecorate could not decorate} the <code>TContext</code> type.
 */
yfiles.graph.ILookupDecorator.prototype.add = function(contextType, resultType, wrapperFactory_or_factory, decorateNull_or_nullIsFallback) {};

/**
 * Add a lookup implementation for a given type that always yields a constant result.
 * Type parameter <code>TContext</code>: The type of the context subject.
 * Type parameter <code>TResult</code>: The type of the query, which is a base type or the type of the result.
 * @template TContext, TResult
 * @param {!yfiles.lang.Class} contextType
 * @param {!yfiles.lang.Class} resultType
 * @param {TResult} result The constant value to yield if the chain is queried for an implementation of type <code>TResult</code>.
 * @return {?} The {\@link } instance as returned by the {\@link #addLookup} call or
 * <code>null</code>, if either <code>decorator</code> was <code>null</code>, or it {\@link #canDecorate could not decorate} the <code>TContext</code> type.
 */
yfiles.graph.ILookupDecorator.prototype.addConstant = function(contextType, resultType, result) {};

/**
 * Adds a lookup chain element to the chain of lookups for a given type.
 * <p>
 * The lookup chain is context specific. This method will not generally decorate the lookup of all instances of type <code>t</code>, but
 * only those that stand in context of this instance. This method will only succeed if {\@link yfiles.graph.ILookupDecorator#canDecorate}
 * yields <code>true</code> for <code>t</code>.
 * </p>
 * @see yfiles.graph.ILookupDecorator#removeLookup
 * @see yfiles.graph.ILookupDecorator#add
 * @see yfiles.graph.ILookupDecorator#add
 * @see yfiles.graph.ILookupDecorator#addConstant
 * @abstract
 * @param {!yfiles.lang.Class} t The type to decorate the lookup.
 * @param {?} lookup The chain element to add to the lookup of the given type.
 * @return {void}
 */
yfiles.graph.ILookupDecorator.prototype.addLookup = function(t, lookup) {};

/**
 * Determines whether this instance can be used to decorate the lookup for a certain type.
 * @abstract
 * @param {!yfiles.lang.Class} t The type to decorate the lookup for.
 * @return {boolean}
 */
yfiles.graph.ILookupDecorator.prototype.canDecorate = function(t) {};

/**
 * Removes a previously registered lookup chain element from the chain of lookups for a given type.
 * @see yfiles.graph.ILookupDecorator#addLookup
 * @abstract
 * @param {!yfiles.lang.Class} t The type to remove the decorator from.
 * @param {?} lookup The chain element to remove from the lookup of the given type.
 * @return {void}
 */
yfiles.graph.ILookupDecorator.prototype.removeLookup = function(t, lookup) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ILookupDecorator;
/**
 * @record
 * @struct
 */
yfiles.graph.ITagOwner = function() {};
 /** @type {!Object} */
yfiles.graph.ITagOwner.prototype.tag;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ITagOwner;
/**
 * @record
 * @struct
 */
yfiles.graph.LookupChain = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graph.LookupChain.$class;

/**
 * A convenience method that adds a {\@link yfiles.graph.IContextLookupChainLink} to the given chain that is based on a function of
 * type <code>function(TContext, TResult)</code>.
 * <p>
 * Depending on <code>decorateNull</code>, <code>null</code> results of the underlying chain will be passed to the
 * <code>wrapperFactory</code>, or simply yielded as the final result.
 * </p>
 * Type parameter <code>TContext</code>: The type of the context.
 * Type parameter <code>TResult</code>: The type of the result.
 * A convenience method that adds a {\@link yfiles.graph.IContextLookupChainLink} to the given chain that is based on a function of
 * type <code>function(</code><code>TContext</code><code>)</code>.
 * <p>
 * Depending on <code>nullIsFallback</code>, <code>null</code> return values of the <code>factory</code> will be interpreted as the final result or indicate to
 * the implementation that the chain should be queried for the result.
 * </p>
 * Type parameter <code>TContext</code>: The type of the context.
 * Type parameter <code>TResult</code>: The type of the result.
 * Adds the given link to the end of the chain.
 * @see yfiles.graph.LookupChain#remove
 * @template TContext, TResult
 * @param {!yfiles.lang.Class|?} contextType_or_lookup The type of the context. / The link to add.
 * @param {!yfiles.lang.Class=} resultType The type of the result.
 * @param {function(TContext, TResult): TResult|function(TContext): TResult=} wrapperFactory_or_factory The wrapper factory that will be called for queries to <code>TResult</code> to wrap the result of the query to the remainder of the chain. / The factory that will be called for queries to <code>TResult</code>.
 * @param {boolean=} decorateNull_or_nullIsFallback
 * @return {?|void} The link that has been registered with the chain.
 */
yfiles.graph.LookupChain.prototype.add = function(contextType_or_lookup, resultType, wrapperFactory_or_factory, decorateNull_or_nullIsFallback) {};

/**
 * Convenience method that can be used instead of the {\@link yfiles.graph.LookupChain#add} method to easily add a lookup
 * implementation for a given type that always yields a constant result.
 * Type parameter <code>TResult</code>: The type of the query, which is a base type or the type of the result.
 * @template TResult
 * @param {!yfiles.lang.Class} resultType
 * @param {TResult} result The constant value to yield if the chain is queried for an implementation of type <code>TResult</code>.
 * @return {?} The {\@link } instance that has been added to the chain.
 */
yfiles.graph.LookupChain.prototype.addConstant = function(resultType, result) {};

/**
 * Performs the actual lookup operation.
 * <p>
 * This call will traverse the chain to satisfy the query.
 * </p>
 * @param {!Object} item The item to use as the context.
 * @param {!yfiles.lang.Class} type The type of the query.
 * @return {!Object} The result of the query.
 */
yfiles.graph.LookupChain.prototype.contextLookup = function(item, type) {};

/**
 * Can be called by client code to trigger the {\@link yfiles.graph.LookupChain#addPropertyChangedListener PropertyChanged}
 * event manually.
 * @return {void}
 */
yfiles.graph.LookupChain.prototype.notifyChange = function() {};

/**
 * Notifies client code that the lookup of this instance might have changed.
 * @protected
 * @param {!yfiles.lang.PropertyChangedEventArgs} evt The arguments
 * @return {void}
 */
yfiles.graph.LookupChain.prototype.onPropertyChanged = function(evt) {};

/**
 * Removes the link that has previously been added to this instance from this chain.
 * @param {?} link The link to remove.
 * @return {void}
 */
yfiles.graph.LookupChain.prototype.remove = function(link) {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when the lookup of this instance has changed for some
 * or all of the types or items.
 * @see yfiles.graph.LookupChain#removePropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.LookupChain.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when the lookup of this instance has changed for
 * some or all of the types or items.
 * @see yfiles.graph.LookupChain#addPropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.LookupChain.prototype.removePropertyChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graph.UndoEngine = function() {};
 /** @type {boolean} */
yfiles.graph.UndoEngine.prototype.mergeUnits;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.graph.UndoEngine.prototype.autoMergeTime;
 /** @type {number} */
yfiles.graph.UndoEngine.prototype.size;
 /** @type {string} */
yfiles.graph.UndoEngine.prototype.undoName;
 /** @type {string} */
yfiles.graph.UndoEngine.prototype.redoName;
 /** @type {boolean} */
yfiles.graph.UndoEngine.prototype.performingUndo;
 /** @type {boolean} */
yfiles.graph.UndoEngine.prototype.performingRedo;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.UndoEngine.$class;

/**
 * Adds a new {\@link yfiles.graph.IUndoUnit} to the queue.
 * <p>
 * This implementation will automatically group multiple units into a single unit if the time since the last add is less
 * than {\@link yfiles.graph.UndoEngine#autoMergeTime}.
 * </p>
 * @param {?} unit The unit of work to add.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.addUnit = function(unit) {};

/**
 * Begins a compound edit that will use the provided name.
 * <p>
 * This will create a new edit that can independently be {\@link yfiles.graph.ICompoundEdit#cancel canceled} or {\@link yfiles.graph.ICompoundEdit#commit committed}. Note that only if the outer-most instances
 * is committed, the corresponding {\@link yfiles.graph.IUndoUnit} units will be enqueued into this instance.
 * </p>
 * @param {string} undoName The undo name to use for the edit.
 * @param {string} redoName The redo name to use for the edit.
 * @return {?} A compound edit implementation that needs to be {\@link #cancel canceled} or {\@link #commit committed} later.
 */
yfiles.graph.UndoEngine.prototype.beginCompoundEdit = function(undoName, redoName) {};

/**
 * Determines whether a call to {\@link yfiles.graph.UndoEngine#redo} can be made.
 * @return {boolean}
 */
yfiles.graph.UndoEngine.prototype.canRedo = function() {};

/**
 * Determines whether a call to {\@link yfiles.graph.UndoEngine#undo} can be made.
 * @return {boolean}
 */
yfiles.graph.UndoEngine.prototype.canUndo = function() {};

/**
 * Clears the internal queue and {\@link yfiles.graph.IUndoUnit#dispose disposes} all units in it.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.clear = function() {};

/**
 * Returns a token that can be used to store and compare the state of the undo queue.
 * <p>
 * E.g. an application can retrieve the token once the user has saved his document. Comparing the token returned by this
 * instance with another one retrieved at a later point in time enables the application to determine whether the document
 * is in the same state.
 * </p>
 * @return {!Object} An object that can be checked against other tokens via the {\@link #equals} method.
 */
yfiles.graph.UndoEngine.prototype.getToken = function() {};

/**
 * This will trigger the corresponding {\@link yfiles.graph.UndoEngine#addPropertyChangedListener PropertyChanged} event.
 * @protected
 * @param {string} name The name of the property that changed.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.onPropertyChanged = function(name) {};

/**
 * Redoes the next {\@link yfiles.graph.IUndoUnit}.
 * @throws {Stubs.Exceptions.NotSupportedError} If an undo operation is already in progress.
 * @throws {yfiles.lang.Exception} If {\@link yfiles.graph.UndoEngine#canRedo} would yield <code>false</code>.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.redo = function() {};

/**
 * Undoes the next {\@link yfiles.graph.IUndoUnit}.
 * @throws {Stubs.Exceptions.NotSupportedError} If an undo operation is already in progress.
 * @throws {yfiles.lang.Exception} If {\@link yfiles.graph.UndoEngine#canUndo} would yield <code>false</code>.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.undo = function() {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when {\@link yfiles.graph.UndoEngine#canUndo},
 * {\@link yfiles.graph.UndoEngine#canRedo}, {\@link yfiles.graph.UndoEngine#undoName}, or {\@link yfiles.graph.UndoEngine#redoName} changed its value.
 * @see yfiles.graph.UndoEngine#removePropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when {\@link yfiles.graph.UndoEngine#canUndo},
 * {\@link yfiles.graph.UndoEngine#canRedo}, {\@link yfiles.graph.UndoEngine#undoName}, or {\@link yfiles.graph.UndoEngine#redoName} changed its value.
 * @see yfiles.graph.UndoEngine#addPropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.removePropertyChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>UnitUndone</code> event that occurs when the engine has successfully executed the {\@link yfiles.graph.IUndoUnit#undo}
 * operation of an {\@link yfiles.graph.IUndoUnit}.
 * @see yfiles.graph.UndoEngine#removeUnitUndoneListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.addUnitUndoneListener = function(listener) {};

/**
 * Removes the given listener for the <code>UnitUndone</code> event that occurs when the engine has successfully executed the {\@link yfiles.graph.IUndoUnit#undo}
 * operation of an {\@link yfiles.graph.IUndoUnit}.
 * @see yfiles.graph.UndoEngine#addUnitUndoneListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.removeUnitUndoneListener = function(listener) {};

/**
 * Adds the given listener for the <code>UnitRedone</code> event that occurs when the engine has successfully executed the {\@link yfiles.graph.IUndoUnit#redo}
 * operation of an {\@link yfiles.graph.IUndoUnit}.
 * @see yfiles.graph.UndoEngine#removeUnitRedoneListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.addUnitRedoneListener = function(listener) {};

/**
 * Removes the given listener for the <code>UnitRedone</code> event that occurs when the engine has successfully executed the {\@link yfiles.graph.IUndoUnit#redo}
 * operation of an {\@link yfiles.graph.IUndoUnit}.
 * @see yfiles.graph.UndoEngine#addUnitRedoneListener
 * @param {function(!Object, !yfiles.lang.EventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.UndoEngine.prototype.removeUnitRedoneListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graph.IUndoUnit = function() {};
 /** @type {string} */
yfiles.graph.IUndoUnit.prototype.undoName;
 /** @type {string} */
yfiles.graph.IUndoUnit.prototype.redoName;

/**
 * Called by the {\@link yfiles.graph.UndoEngine} and client code to let the unit dispose of references aren't needed anymore.
 * <p>
 * When this method is called, the other methods of this interface will not be called anymore by the undo engine. The undo
 * engine calls this method on instances that it will not use anymore to enable the instances to release instances and
 * memory actively.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.graph.IUndoUnit.prototype.dispose = function() {};

/**
 * Redoes the work that is represented by this unit.
 * <p>
 * Undo/redo are sensible operations and should maintain a consistent state before and after each operation since they may
 * be executed potentially often one after another.
 * </p>
 * @see yfiles.graph.IUndoUnit#redoName
 * @abstract
 * @return {void}
 */
yfiles.graph.IUndoUnit.prototype.redo = function() {};

/**
 * Tries to merge the given unit with this one.
 * <p>
 * This method is called when <code>this</code> unit is the head of an {\@link yfiles.graph.UndoEngine}'s or {\@link yfiles.graph.CompositeUndoUnit}'s
 * queue and a new unit is added. It is meant to try to incorporate the change of the given <code>unit</code> into <code>this</code> and if
 * successful return <code>true</code>. This should be the case when the end state of <code>this</code> unit is equal to the start state of the given
 * <code>unit</code>.
 * </p>
 * <p>
 * For example, if <code>this</code> unit is the head of the queue and represents the work from state <code>A</code> to state <code>B</code> and the given unit
 * the work from state <code>B</code> to state <code>C</code>, then this method should try to make <code>this</code> unit shift from state <code>A</code> to state <code>C</code>. If this
 * is successful, the method is expected to return <code>true</code>. The other unit is then {\@link yfiles.graph.IUndoUnit#dispose disposed} by the {\@link yfiles.graph.UndoEngine}
 * afterwards.
 * </p>
 * <p>
 * Clients don't necessarily have to implement this method if the unit doesn't happen very often. In fact, the default
 * implementation of {\@link yfiles.graph.UndoUnitBase#tryMergeUnit} simply returns <code>false</code>. Implementing this method faithfully will
 * cause multiple units of work to inseparably appear as one and undoing/redoing it will undo/redo the work of all
 * collapsed units. Depending on the situation this may be reasonable, for example when there are potentially a lot of
 * changes where not every intermediate step is required to be recorded. In this case implementing this method faithfully
 * will greatly improve the performance and reduce the required amount of memory of the undo process. If you want to group
 * together multiple units as a single block but still want to be able to separate each step, consider to use a {\@link yfiles.graph.CompositeUndoUnit}
 * instead.
 * </p>
 * @abstract
 * @param {?} unit The unit to incorporate that happened after this unit.
 * @return {boolean} Whether the state change of <code>unit</code> has been incorporated into this unit and <code>unit</code> can be disposed of.
 */
yfiles.graph.IUndoUnit.prototype.tryMergeUnit = function(unit) {};

/**
 * Tries to replace the given unit with this one.
 * <p>
 * This method is called if a newly added unit couldn't be {\@link yfiles.graph.IUndoUnit#tryMergeUnit merged} with the head unit of the queue (i.e. returned false).
 * Instead of trying to merge a newly added unit, this method tries to replace the given unit (which is the head of the
 * queue) with <code>this</code> by incorporating the change of the given <code>unit</code> into <code>this</code> and if successful return <code>true</code>. This should be
 * the case when the start state of <code>this</code> unit is equal to the end state of the given <code>unit</code>.
 * </p>
 * <p>
 * For example, if the given <code>unit</code> represents the work from state <code>A</code> to state <code>B</code> and <code>this</code> unit the work from state <code>B</code> to state
 * <code>C</code>, then this method should try to make <code>this</code> unit shift from state <code>A</code> to state <code>C</code>. If this is successful, the method is
 * expected to return <code>true</code>. The given <code>unit</code> is then {\@link yfiles.graph.IUndoUnit#dispose disposed} by the {\@link yfiles.graph.UndoEngine} afterwards and replaced with <code>this</code>
 * unit in the queue.
 * </p>
 * <p>
 * Clients don't necessarily have to implement this method if the unit doesn't happen very often. In fact, the default
 * implementation of {\@link yfiles.graph.UndoUnitBase#tryReplaceUnit} simply returns <code>false</code>. Implementing this method faithfully
 * will cause multiple units of work to inseparably appear as one and undoing/redoing it will undo/redo the work of all
 * collapsed units. Depending on the situation this may be reasonable, for example when there are potentially a lot of
 * changes where not every intermediate step is required to be recorded. In this case implementing this method faithfully
 * will greatly improve the performance and reduce the required amount of memory of the undo process. If you want to group
 * together multiple units as a single block but still want to be able to separate each step, consider to use a {\@link yfiles.graph.CompositeUndoUnit}
 * instead.
 * </p>
 * @abstract
 * @param {?} unit The unit to incorporate that happened before this unit.
 * @return {boolean} Whether the state change of <code>this</code> unit has been incorporated into the given <code>unit</code> and <code>this</code> can be disposed of.
 */
yfiles.graph.IUndoUnit.prototype.tryReplaceUnit = function(unit) {};

/**
 * Undoes the work that is represented by this unit.
 * <p>
 * Undo/redo are sensible operations and should maintain a consistent state before and after each operation since they may
 * be executed potentially often one after another.
 * </p>
 * @see yfiles.graph.IUndoUnit#undoName
 * @abstract
 * @return {void}
 */
yfiles.graph.IUndoUnit.prototype.undo = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IUndoUnit;
/**
 * @record
 * @struct
 */
yfiles.graph.IMementoSupport = function() {};

/**
 * Reapplies a previously queried state object to a given subject.
 * <p>
 * The state object has been created using the {\@link yfiles.graph.IMementoSupport#getState} method.
 * </p>
 * @abstract
 * @param {!Object} subject The subject to modify the state.
 * @param {!Object} state The state object as returned by {\@link #getState}
 * @return {void}
 */
yfiles.graph.IMementoSupport.prototype.applyState = function(subject, state) {};

/**
 * Retrieves an object representing the state at the moment this method is called.
 * <p>
 * The returned state may be reapplied later to the subject in the {\@link yfiles.graph.IMementoSupport#applyState} method.
 * </p>
 * @abstract
 * @param {!Object} subject The subject to read the state from
 * @return {!Object} An object that describes the current state of <code>subject</code>.
 */
yfiles.graph.IMementoSupport.prototype.getState = function(subject) {};

/**
 * Determines whether two state objects are equal.
 * <p>
 * The undo mechanism in yFiles calls this method to determine if the subject has changed and whether an {\@link yfiles.graph.IUndoUnit}
 * should be created for these changes. If this method returns <code>false</code>, an {\@link yfiles.graph.IUndoUnit} is created for the two
 * states that can reapply either state (for either undo or redo). If this method returns <code>true</code> the state is considered not
 * to have changed and no undo unit will be created. Conservative implementations my simply return <code>false</code>.
 * </p>
 * @abstract
 * @param {!Object} state1 The first state as obtained from {\@link #getState}
 * @param {!Object} state2 The second state as obtained from {\@link #getState}
 * @return {boolean} <code>true</code> if the states are equal; <code>false</code> otherwise.
 */
yfiles.graph.IMementoSupport.prototype.stateEquals = function(state1, state2) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IMementoSupport;
/**
 * @record
 * @struct
 */
yfiles.graph.DelegateUndoUnit = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graph.DelegateUndoUnit.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.UndoUnitBase = function() {};
 /** @type {string} */
yfiles.graph.UndoUnitBase.prototype.undoName;
 /** @type {string} */
yfiles.graph.UndoUnitBase.prototype.redoName;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.UndoUnitBase.$class;

/**
 *
 * @return {void}
 */
yfiles.graph.UndoUnitBase.prototype.dispose = function() {};

/**
 *
 * @abstract
 * @return {void}
 */
yfiles.graph.UndoUnitBase.prototype.redo = function() {};

/**
 *
 * @param {?} unit
 * @return {boolean}
 */
yfiles.graph.UndoUnitBase.prototype.tryMergeUnit = function(unit) {};

/**
 *
 * @param {?} unit
 * @return {boolean}
 */
yfiles.graph.UndoUnitBase.prototype.tryReplaceUnit = function(unit) {};

/**
 *
 * @abstract
 * @return {void}
 */
yfiles.graph.UndoUnitBase.prototype.undo = function() {};
/**
 * @record
 * @struct
 */
yfiles.graph.FoldingEdgeConverterBase = function() {};
 /** @type {boolean} */
yfiles.graph.FoldingEdgeConverterBase.prototype.cloneEdgeStyle;
 /** @type {?} */
yfiles.graph.FoldingEdgeConverterBase.prototype.sourcePortStyle;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeConverterBase.prototype.cloneSourcePortStyle;
 /** @type {?} */
yfiles.graph.FoldingEdgeConverterBase.prototype.targetPortStyle;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeConverterBase.prototype.cloneTargetPortStyle;
 /** @type {?} */
yfiles.graph.FoldingEdgeConverterBase.prototype.sourcePortLocationParameter;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeConverterBase.prototype.cloneSourcePortLocationParameter;
 /** @type {?} */
yfiles.graph.FoldingEdgeConverterBase.prototype.targetPortLocationParameter;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeConverterBase.prototype.cloneTargetPortLocationParameter;
 /** @type {?} */
yfiles.graph.FoldingEdgeConverterBase.prototype.labelStyle;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeConverterBase.prototype.cloneLabelStyle;
 /** @type {?} */
yfiles.graph.FoldingEdgeConverterBase.prototype.labelLayoutParameter;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeConverterBase.prototype.cloneLabelLayoutParameter;
 /** @type {?} */
yfiles.graph.FoldingEdgeConverterBase.prototype.foldingEdgeStyle;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeConverterBase.prototype.resetBends;
 /** @type {boolean} */
yfiles.graph.FoldingEdgeConverterBase.prototype.copyFirstLabel;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FoldingEdgeConverterBase.$class;

/**
 *
 * @abstract
 * @param {?} factory
 * @param {?} foldingView
 * @param {?} masterEdge
 * @param {?} source
 * @param {boolean} sourceIsCollapsed
 * @param {?} target
 * @param {boolean} targetIsCollapsed
 * @return {?}
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.addFoldingEdge = function(factory, foldingView, masterEdge, source, sourceIsCollapsed, target, targetIsCollapsed) {};

/**
 * Callback factory method that creates the {\@link yfiles.styles.IEdgeStyle} for use in
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgeStyle}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} foldingEdge The folding edge in the view whose {\@link #style} should be initialized.
 * @param {?<?>} masterEdges The edges that are being represented by the folding edge.
 * @return {?} The {\@link #foldingEdgeStyle} or a {\@link #clone} of it depending on the {\@link #cloneEdgeStyle} property. This method may return <code>null</code> to indicate that
 * the default style should not be changed.
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.createEdgeStyle = function(foldingView, foldingEdge, masterEdges) {};

/**
 * Callback factory method that creates the {\@link yfiles.graph.ILabelModelParameter} for use in
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgeLabels}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localLabel The local label in the view whose {\@link #layoutParameter} should be initialized. May be <code>null</code> if the label layout parameter is requested for the
 * label creation.
 * @param {?} masterLabel The label that is being represented by the folding label.
 * @return {?} The {\@link #labelLayoutParameter} or a {\@link #clone} of it depending on the {\@link #cloneLabelLayoutParameter} property. This method may return <code>null</code> to indicate that
 * the default label layout parameter should not be changed.
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.createLabelLayoutParameter = function(foldingView, localLabel, masterLabel) {};

/**
 * Callback factory method that creates the {\@link yfiles.styles.ILabelStyle} for use in
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgeLabels}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localLabel The local label in the view whose {\@link #style} should be initialized. May be <code>null</code> if the label style is requested for the label
 * creation.
 * @param {?} masterLabel The label that is being represented by the folding label.
 * @return {?} The {\@link #labelStyle} or a {\@link #clone} of it depending on the {\@link #cloneLabelStyle} property. This method may return <code>null</code> to indicate that
 * the default style should not be changed.
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.createLabelStyle = function(foldingView, localLabel, masterLabel) {};

/**
 * Callback factory method that creates the {\@link yfiles.graph.IPortLocationModelParameter} of the source port for use in
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgePorts}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localEdge The local edge in the view whose source port's {\@link #locationParameter} should be initialized.
 * @param {?<?>} masterEdges The master edges that the folding edge represents.
 * @return {?} The {\@link #sourcePortLocationParameter} or a {\@link #clone} of it depending on the {\@link #cloneSourcePortLocationParameter} property. This method may return <code>null</code> to indicate that
 * the default port location parameter should not be changed.
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.createSourcePortLocationParameter = function(foldingView, localEdge, masterEdges) {};

/**
 * Callback factory method that creates the {\@link yfiles.styles.IPortStyle} of the source port for use in
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgePorts}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localEdge The local edge in the view whose source port's {\@link #style} should be initialized.
 * @param {?<?>} masterEdges The master edges that the folding edge represents.
 * @return {?} The {\@link #sourcePortStyle} or a {\@link #clone} of it depending on the {\@link #cloneSourcePortStyle} property. This method may return <code>null</code> to indicate that
 * the default style should not be changed.
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.createSourcePortStyle = function(foldingView, localEdge, masterEdges) {};

/**
 * Callback factory method that creates the {\@link yfiles.graph.IPortLocationModelParameter} of the target port for use in
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgePorts}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localEdge The local edge in the view whose target port's {\@link #locationParameter} should be initialized.
 * @param {?<?>} masterEdges The master edges that the folding edge represents.
 * @return {?} The {\@link #targetPortLocationParameter} or a {\@link #clone} of it depending on the {\@link #cloneTargetPortLocationParameter} property. This method may return <code>null</code> to indicate that
 * the default port location parameter should not be changed.
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.createTargetPortLocationParameter = function(foldingView, localEdge, masterEdges) {};

/**
 * Callback factory method that creates the {\@link yfiles.styles.IPortStyle} of the target port for use in
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgePorts}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localEdge The local edge in the view whose target port's {\@link #style} should be initialized.
 * @param {?<?>} masterEdges The master edges that the folding edge represents.
 * @return {?} The {\@link #targetPortStyle} or a {\@link #clone} of it depending on the {\@link #cloneTargetPortStyle} property. This method may return <code>null</code> to indicate that
 * the default style should not be changed.
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.createTargetPortStyle = function(foldingView, localEdge, masterEdges) {};

/**
 * Callback method that initializes the bends of the folding edge.
 * <p>
 * This will call the {\@link yfiles.graph.FoldingEdgeState#clearBends} callback if {\@link yfiles.graph.FoldingEdgeConverterBase#resetBends} is enabled.
 * </p>
 * @protected
 * @param {!yfiles.graph.FoldingEdgeState} state The viewstate to change.
 * @param {?} foldingView The folding view instance that has triggered the {\@link #initializeFoldingEdgeState} call.
 * @param {?} foldingEdge The folding edge in the view that may be changed using the <code>state</code>.
 * @param {?<?>} masterEdges The master edges that the folding edge represents.
 * @return {void}
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.initializeFoldingEdgeBends = function(state, foldingView, foldingEdge, masterEdges) {};

/**
 * Callback method that initializes the initial labels of the folding edge.
 * <p>
 * This will first {\@link yfiles.graph.FoldingLabelOwnerState#clearLabels clear all the labels} and then try to copy the first label of the single master edge if {\@link yfiles.graph.FoldingEdgeConverterBase#copyFirstLabel} is enabled. It
 * will call {\@link yfiles.graph.FoldingEdgeConverterBase#createLabelStyle} and {\@link yfiles.graph.FoldingEdgeConverterBase#createLabelLayoutParameter}
 * and use the returned style and layout parameter if they are non-<code>null</code> when {\@link yfiles.graph.FoldingEdgeState#addLabel adding the label} on the folding edge.
 * </p>
 * @see yfiles.graph.FoldingEdgeConverterBase#labelStyle
 * @see yfiles.graph.FoldingEdgeConverterBase#labelLayoutParameter
 * @protected
 * @param {!yfiles.graph.FoldingEdgeState} state The viewstate to change.
 * @param {?} foldingView The folding view instance that has triggered the {\@link #initializeFoldingEdgeState} call.
 * @param {?} foldingEdge The folding edge in the view that may be changed using the <code>state</code>.
 * @param {?<?>} masterEdges The master edges that the folding edge represents.
 * @return {void}
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.initializeFoldingEdgeLabels = function(state, foldingView, foldingEdge, masterEdges) {};

/**
 * Callback method that initializes the ports of the folding edge.
 * <p>
 * If the source port of the <code>foldingEdge</code> {\@link yfiles.graph.IFoldingView#isInFoldingState is in folding state}, this implementation calls {\@link yfiles.graph.FoldingEdgeConverterBase#createSourcePortStyle}
 * and {\@link yfiles.graph.FoldingEdgeConverterBase#createSourcePortLocationParameter} and {\@link yfiles.graph.FoldingPortState#style assigns the style} and {\@link yfiles.graph.FoldingPortState#locationParameter location parameter}
 * to the folding source port if non-<code>null</code> values have been returned. The same holds true for the target port where the {\@link yfiles.graph.FoldingEdgeConverterBase#createTargetPortStyle}
 * and {\@link yfiles.graph.FoldingEdgeConverterBase#createTargetPortLocationParameter} callbacks are used.
 * </p>
 * @see yfiles.graph.FoldingEdgeConverterBase#sourcePortStyle
 * @see yfiles.graph.FoldingEdgeConverterBase#targetPortStyle
 * @see yfiles.graph.FoldingEdgeConverterBase#sourcePortLocationParameter
 * @see yfiles.graph.FoldingEdgeConverterBase#targetPortLocationParameter
 * @see yfiles.graph.FoldingEdgeConverterBase#createSourcePortStyle
 * @see yfiles.graph.FoldingEdgeConverterBase#createTargetPortStyle
 * @see yfiles.graph.FoldingEdgeConverterBase#createSourcePortLocationParameter
 * @see yfiles.graph.FoldingEdgeConverterBase#createTargetPortLocationParameter
 * @protected
 * @param {!yfiles.graph.FoldingEdgeState} state The viewState to change.
 * @param {?} foldingView The folding view instance that has triggered the {\@link #initializeFoldingEdgeState} call.
 * @param {?} foldingEdge The folding edge in the view that may be changed using the <code>state</code>.
 * @param {?<?>} masterEdges The master edges that the folding edge represents.
 * @return {void}
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.initializeFoldingEdgePorts = function(state, foldingView, foldingEdge, masterEdges) {};

/**
 * Implements the {\@link yfiles.graph.IFoldingEdgeConverter#initializeFoldingEdgeState} method and initializes the folding edge
 * appearance.
 * <p>
 * This method calls {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgeStyle},
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgePorts},
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgeBends},
 * {\@link yfiles.graph.FoldingEdgeConverterBase#initializeFoldingEdgeLabels}.
 * </p>
 * @param {!yfiles.graph.FoldingEdgeState} state
 * @param {?} foldingView
 * @param {?} foldingEdge
 * @param {?<?>} masterEdges
 * @return {void}
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.initializeFoldingEdgeState = function(state, foldingView, foldingEdge, masterEdges) {};

/**
 * Callback method that initializes the {\@link yfiles.graph.FoldingEdgeState#style style property} of the folding edge.
 * <p>
 * This implementation calls {\@link yfiles.graph.FoldingEdgeConverterBase#createEdgeStyle} and {\@link yfiles.graph.FoldingEdgeState#style assigns} the style to the folding
 * edge if a non-<code>null</code> value has been returned.
 * </p>
 * @protected
 * @param {!yfiles.graph.FoldingEdgeState} state The viewstate to change.
 * @param {?} foldingView The folding view instance that has triggered the {\@link #initializeFoldingEdgeState} call.
 * @param {?} foldingEdge The folding edge in the view that may be changed using the <code>state</code>.
 * @param {?<?>} masterEdges The master edges that the folding edge represents.
 * @return {void}
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.initializeFoldingEdgeStyle = function(state, foldingView, foldingEdge, masterEdges) {};

/**
 * Called by {\@link yfiles.graph.FoldingEdgeConverterBase#updateFoldingEdgeState} to synchronize the first label if {\@link yfiles.graph.FoldingEdgeConverterBase#copyFirstLabel} is enabled.
 * <p>
 * This will adjust the label's text, preferred size and tag properties or remove the label if there is no master label or
 * there is more than one master edge.
 * </p>
 * @protected
 * @param {!yfiles.graph.FoldingEdgeState} state The viewstate of the edge to change.
 * @param {?} foldingView The folding view.
 * @param {?} foldingEdge The folding edge.
 * @param {?<?>} masterEdges The master edges.
 * @return {void}
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.synchronizeLabels = function(state, foldingView, foldingEdge, masterEdges) {};

/**
 * Implements the {\@link yfiles.graph.IFoldingEdgeConverter#updateFoldingEdgeState} method and changes the folding edge
 * appearance.
 * <p>
 * This method calls {\@link yfiles.graph.FoldingEdgeConverterBase#synchronizeLabels}, only.
 * </p>
 * @param {!yfiles.graph.FoldingEdgeState} state
 * @param {?} foldingView
 * @param {?} foldingEdge
 * @param {?<?>} masterEdges
 * @return {void}
 */
yfiles.graph.FoldingEdgeConverterBase.prototype.updateFoldingEdgeState = function(state, foldingView, foldingEdge, masterEdges) {};
/**
 * @record
 * @struct
 */
yfiles.graph.DefaultFoldingEdgeConverter = function() {};
 /** @type {boolean} */
yfiles.graph.DefaultFoldingEdgeConverter.prototype.reuseMasterPorts;
 /** @type {boolean} */
yfiles.graph.DefaultFoldingEdgeConverter.prototype.reuseFolderNodePorts;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.DefaultFoldingEdgeConverter.$class;
/**
 * @record
 * @struct
 */
yfiles.graph.DefaultFolderNodeConverter = function() {};
 /** @type {?} */
yfiles.graph.DefaultFolderNodeConverter.prototype.folderNodeStyle;
 /** @type {boolean} */
yfiles.graph.DefaultFolderNodeConverter.prototype.copyFirstLabel;
 /** @type {?} */
yfiles.graph.DefaultFolderNodeConverter.prototype.labelStyle;
 /** @type {?} */
yfiles.graph.DefaultFolderNodeConverter.prototype.labelLayoutParameter;
 /** @type {?} */
yfiles.graph.DefaultFolderNodeConverter.prototype.portStyle;
 /** @type {!yfiles.geometry.Size} */
yfiles.graph.DefaultFolderNodeConverter.prototype.folderNodeSize;
 /** @type {?} */
yfiles.graph.DefaultFolderNodeConverter.prototype.portLocationParameter;
 /** @type {boolean} */
yfiles.graph.DefaultFolderNodeConverter.prototype.cloneNodeStyle;
 /** @type {boolean} */
yfiles.graph.DefaultFolderNodeConverter.prototype.clonePortStyle;
 /** @type {boolean} */
yfiles.graph.DefaultFolderNodeConverter.prototype.clonePortLocationParameter;
 /** @type {boolean} */
yfiles.graph.DefaultFolderNodeConverter.prototype.cloneLabelStyle;
 /** @type {boolean} */
yfiles.graph.DefaultFolderNodeConverter.prototype.cloneLabelLayoutParameter;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.DefaultFolderNodeConverter.$class;

/**
 * Callback factory method that creates the {\@link yfiles.graph.ILabelModelParameter} for use in
 * {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodeLabels}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localLabel The local label in the view whose {\@link #layoutParameter} should be initialized. May be <code>null</code> if the label layout parameter is requested for the
 * label creation.
 * @param {?} masterLabel The label that is being represented by the folding label.
 * @return {?} The {\@link #labelLayoutParameter} or a {\@link #clone} of it depending on the {\@link #cloneLabelLayoutParameter} property. This method may return <code>null</code> to indicate that
 * the default label layout parameter should not be changed.
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.createLabelLayoutParameter = function(foldingView, localLabel, masterLabel) {};

/**
 * Callback factory method that creates the {\@link yfiles.styles.ILabelStyle} for use in
 * {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodeLabels}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localLabel The local label in the view whose {\@link #style} should be initialized. May be <code>null</code> if the label style is requested for the label
 * creation.
 * @param {?} masterLabel The label that is being represented by the folding label.
 * @return {?} The {\@link #labelStyle} or a {\@link #clone} of it depending on the {\@link #cloneLabelStyle} property. This method may return <code>null</code> to indicate that
 * the default style should not be changed.
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.createLabelStyle = function(foldingView, localLabel, masterLabel) {};

/**
 * Callback factory method that creates the {\@link yfiles.styles.INodeStyle} for use in
 * {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodeStyle}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} viewNode The local folder node in the view whose {\@link #style} should be initialized.
 * @param {?} masterNode The node that is being represented by the folder node.
 * @return {?} The {\@link #folderNodeStyle} or a {\@link #clone} of it depending on the {\@link #cloneNodeStyle} property. This method may return <code>null</code> to indicate that
 * the default style should not be changed.
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.createNodeStyle = function(foldingView, viewNode, masterNode) {};

/**
 * Callback factory method that creates the {\@link yfiles.graph.IPortLocationModelParameter} for use in
 * {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodePorts}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localPort The local port in the view whose {\@link #locationParameter} should be initialized.
 * @param {?} masterPort The port that is being represented by the folding port.
 * @return {?} The {\@link #portLocationParameter} or a {\@link #clone} of it depending on the {\@link #clonePortLocationParameter} property. This method may return <code>null</code> to indicate that
 * the default port location parameter should not be changed.
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.createPortLocationParameter = function(foldingView, localPort, masterPort) {};

/**
 * Callback factory method that creates the {\@link yfiles.styles.IPortStyle} for use in
 * {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodePorts}.
 * @protected
 * @param {?} foldingView The folding view instance.
 * @param {?} localPort The local port in the view whose {\@link #style} should be initialized.
 * @param {?} masterPort The port that is being represented by the folding port.
 * @return {?} The {\@link #portStyle} or a {\@link #clone} of it depending on the {\@link #clonePortStyle} property. This method may return <code>null</code> to indicate that
 * the default style should not be changed.
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.createPortStyle = function(foldingView, localPort, masterPort) {};

/**
 * Callback method that initializes the initial labels of the collapsed group node.
 * <p>
 * This will try to copy the first label of the master node if {\@link yfiles.graph.DefaultFolderNodeConverter#copyFirstLabel} is enabled. It will call {\@link yfiles.graph.DefaultFolderNodeConverter#createLabelStyle}
 * and {\@link yfiles.graph.DefaultFolderNodeConverter#createLabelLayoutParameter} and use the returned style and layout parameter
 * if they are non-<code>null</code> when {\@link yfiles.graph.FolderNodeState#addLabel adding the label} on the folder node.
 * </p>
 * @see yfiles.graph.DefaultFolderNodeConverter#labelStyle
 * @see yfiles.graph.DefaultFolderNodeConverter#labelLayoutParameter
 * @see yfiles.graph.FoldingManager#getFolderNodeState
 * @protected
 * @param {!yfiles.graph.FolderNodeState} state The node view state whose labels should be synchronized.
 * @param {?} foldingView The folding view instance that has triggered the {\@link #initializeFolderNodeState}
 * call.
 * @param {?} viewNode The collapsed group node in the view that may be changed using the {\@link }.
 * @param {?} masterNode The master node that the folder node represents.
 * @return {void}
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.initializeFolderNodeLabels = function(state, foldingView, viewNode, masterNode) {};

/**
 * Callback method that initializes the {\@link yfiles.graph.INode#layout} of the collapsed group node.
 * <p>
 * This implementation will {\@link yfiles.graph.FolderNodeState#layout set the bounds} of the nodes in such a way that the size will be that of the {\@link yfiles.graph.DefaultFolderNodeConverter#folderNodeSize} property (if
 * non-<code>null</code>) but not smaller than the {\@link yfiles.input.INodeSizeConstraintProvider#getMinimumSize minimum} size that is reported by a potential {\@link yfiles.input.INodeSizeConstraintProvider}
 * for {\@link yfiles.graph.INode}s that has been found in the {\@link yfiles.graph.ILookup} of the <code>viewNode</code>.
 * </p>
 * @protected
 * @param {!yfiles.graph.FolderNodeState} state The node view state whose layout should be synchronized.
 * @param {?} foldingView The folding view instance.
 * @param {?} viewNode The local collapsed group node to change.
 * @param {?} masterNode The master node that is represented by the local group node.
 * @return {void}
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.initializeFolderNodeLayout = function(state, foldingView, viewNode, masterNode) {};

/**
 * Called by {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodeState} to initialize the appearance of the {\@link yfiles.graph.IFoldingView#getViewItem representatives}
 * of the master ports at the collapsed group node.
 * <p>
 * This method will call {\@link yfiles.graph.DefaultFolderNodeConverter#createPortStyle} and {\@link yfiles.graph.DefaultFolderNodeConverter#createPortLocationParameter}
 * for each port at the group node and assign the returned style and location parameter if they are non-<code>null</code>.
 * </p>
 * @protected
 * @param {!yfiles.graph.FolderNodeState} state The node view state whose ports should be synchronized.
 * @param {?} foldingView The folding view instance.
 * @param {?} viewNode The local group node.
 * @param {?} masterNode The master group node.
 * @return {void}
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.initializeFolderNodePorts = function(state, foldingView, viewNode, masterNode) {};

/**
 * Implements the {\@link yfiles.graph.IFolderNodeConverter#initializeFolderNodeState} method and initializes the appearance of the
 * collapsed group node.
 * <p>
 * This method calls {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodeStyle},
 * {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodeLabels},
 * {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodeLayout}, and
 * {\@link yfiles.graph.DefaultFolderNodeConverter#initializeFolderNodePorts}.
 * </p>
 * @param {!yfiles.graph.FolderNodeState} state
 * @param {?} foldingView
 * @param {?} viewNode
 * @param {?} masterNode
 * @return {void}
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.initializeFolderNodeState = function(state, foldingView, viewNode, masterNode) {};

/**
 * Callback method that initializes the {\@link yfiles.graph.FolderNodeState#style style property} of the collapsed group node.
 * <p>
 * This implementation calls {\@link yfiles.graph.DefaultFolderNodeConverter#createNodeStyle} and {\@link yfiles.graph.FolderNodeState#style assigns} the style to the group
 * node if a non-<code>null</code> value has been returned.
 * </p>
 * @see yfiles.graph.FoldingManager#getFolderNodeState
 * @protected
 * @param {!yfiles.graph.FolderNodeState} state The node view state whose style should be synchronized.
 * @param {?} foldingView The folding view instance that has triggered the {\@link #initializeFolderNodeState}
 * call.
 * @param {?} viewNode The local node in the view that may be changed using the {\@link }.
 * @param {?} masterNode The master node that the local folder node represents.
 * @return {void}
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.initializeFolderNodeStyle = function(state, foldingView, viewNode, masterNode) {};

/**
 * Called by {\@link yfiles.graph.DefaultFolderNodeConverter#updateFolderNodeState} to synchronize the first label if {\@link yfiles.graph.DefaultFolderNodeConverter#copyFirstLabel} is enabled.
 * <p>
 * This will adjust the label text property or remove the label if there is no master label.
 * </p>
 * @protected
 * @param {!yfiles.graph.FolderNodeState} state The node view state whose labels should be synchronized.
 * @param {?} foldingView The folding view.
 * @param {?} viewNode The local node instance.
 * @param {?} masterNode The master node.
 * @return {void}
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.synchronizeLabels = function(state, foldingView, viewNode, masterNode) {};

/**
 * Implements the {\@link yfiles.graph.IFolderNodeConverter#updateFolderNodeState} method and changes the folder node appearance.
 * <p>
 * This method calls {\@link yfiles.graph.DefaultFolderNodeConverter#synchronizeLabels}, only.
 * </p>
 * @param {!yfiles.graph.FolderNodeState} state
 * @param {?} foldingView
 * @param {?} viewNode
 * @param {?} masterNode
 * @return {void}
 */
yfiles.graph.DefaultFolderNodeConverter.prototype.updateFolderNodeState = function(state, foldingView, viewNode, masterNode) {};
/**
 * @record
 * @struct
 */
yfiles.graph.ExcludingFoldingEdgeConverter = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.graph.ExcludingFoldingEdgeConverter.$class;

/**
 * Always calls {\@link yfiles.graph.IFoldingEdgeFactory#excludeFoldingEdge}
 * @param {?} factory
 * @param {?} foldingView
 * @param {?} masterEdge
 * @param {?} source
 * @param {boolean} sourceIsCollapsed
 * @param {?} target
 * @param {boolean} targetIsCollapsed
 * @return {?}
 */
yfiles.graph.ExcludingFoldingEdgeConverter.prototype.addFoldingEdge = function(factory, foldingView, masterEdge, source, sourceIsCollapsed, target, targetIsCollapsed) {};

/**
 * Does nothing and should not normally be called by the view since all folding edges are excluded from it.
 * @param {!yfiles.graph.FoldingEdgeState} state
 * @param {?} foldingView
 * @param {?} foldingEdge
 * @param {?<?>} masterEdges
 * @return {void}
 */
yfiles.graph.ExcludingFoldingEdgeConverter.prototype.initializeFoldingEdgeState = function(state, foldingView, foldingEdge, masterEdges) {};

/**
 * Does nothing and should not normally be called by the view since all folding edges are excluded from it.
 * @param {!yfiles.graph.FoldingEdgeState} state
 * @param {?} foldingView
 * @param {?} foldingEdge
 * @param {?<?>} masterEdges
 * @return {void}
 */
yfiles.graph.ExcludingFoldingEdgeConverter.prototype.updateFoldingEdgeState = function(state, foldingView, foldingEdge, masterEdges) {};
/**
 * @record
 * @struct
 */
yfiles.graph.MergingFoldingEdgeConverter = function() {};
 /** @type {boolean} */
yfiles.graph.MergingFoldingEdgeConverter.prototype.ignoreEdgeDirection;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.MergingFoldingEdgeConverter.$class;

/**
 * Adds the first separate edge to the source and target node pair using the {\@link yfiles.graph.IFoldingEdgeFactory#addAsSeparateEdge}
 * method.
 * @protected
 * @param {?} factory
 * @param {?} foldingView
 * @param {?} masterEdge
 * @param {?} viewSourceNode
 * @param {boolean} sourceIsCollapsed
 * @param {?} targetSourceNode
 * @param {boolean} targetIsCollapsed
 * @return {?}
 */
yfiles.graph.MergingFoldingEdgeConverter.prototype.addFirstSeparateEdge = function(factory, foldingView, masterEdge, viewSourceNode, sourceIsCollapsed, targetSourceNode, targetIsCollapsed) {};
/**
 * @record
 * @struct
 */
yfiles.graph.FoldingManager = function() {};
 /** @type {?} */
yfiles.graph.FoldingManager.prototype.foldingEdgeConverter;
 /** @type {?} */
yfiles.graph.FoldingManager.prototype.folderNodeConverter;
 /** @type {?} */
yfiles.graph.FoldingManager.prototype.masterGraph;
 /** @type {?<?>} */
yfiles.graph.FoldingManager.prototype.views;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FoldingManager.$class;

/**
 * Creates a separate view instance of the {\@link yfiles.graph.FoldingManager#masterGraph} which is a synchronized copy of a subset of the items from the master graph.
 * <p>
 * This method will create a new instance of an {\@link yfiles.graph.IGraph} that is constructed as a synchronized copy of the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * That instance can be obtained from the {\@link yfiles.graph.IFoldingView#graph} property of the returned {\@link yfiles.graph.IFoldingView} implementation. The graph
 * instance will provide an {\@link yfiles.graph.IFoldingView} instance in its {\@link yfiles.graph.ILookup#lookup} mechanism:
 * </p>
 * <p>
 * This instance can be used to gain access to this manager instance and the folding operations.
 * </p>
 * <p>
 * Note that the entities that are contained in the returned graph instance are not the same instances as the original
 * "master" entities in the {\@link yfiles.graph.FoldingManager#masterGraph}. However they share the same properties (style, {\@link yfiles.graph.ITagOwner#tag tag}, {\@link yfiles.graph.ILabelModelParameter parameters}, and {\@link yfiles.graph.INode#layout geometry}). For collapsed
 * group nodes and view edges, there is a separate set of properties available for each possible state combination. The {\@link yfiles.graph.FoldingManager#getFoldingEdgeState}
 * method for edges and the {\@link yfiles.graph.FoldingManager#getFolderNodeState} method for nodes provide access to that state
 * while it is not being displayed in a view.
 * </p>
 * @see yfiles.graph.FoldingManager#prepareFoldingView
 * Creates a separate view instance of the {\@link yfiles.graph.FoldingManager#masterGraph} which is a synchronized copy of a subset of the items from the master graph.
 * <p>
 * This method will create a new instance of an {\@link yfiles.graph.IGraph} that is constructed as a synchronized copy of the {\@link yfiles.graph.FoldingManager#masterGraph}.
 * That instance can be obtained from the {\@link yfiles.graph.IFoldingView#graph} property of the returned {\@link yfiles.graph.IFoldingView} implementation. The graph
 * instance will provide an {\@link yfiles.graph.IFoldingView} instance in its {\@link yfiles.graph.ILookup#lookup} mechanism:
 * </p>
 * <p>
 * This instance can be used to gain access to this manager instance and the folding operations.
 * </p>
 * <p>
 * Note that the entities that are contained in the returned graph instance are not the same instances as the original
 * "master" entities in the {\@link yfiles.graph.FoldingManager#masterGraph}. However they share the same properties (style, {\@link yfiles.graph.ITagOwner#tag tag}, {\@link yfiles.graph.ILabelModelParameter parameters}, and {\@link yfiles.graph.INode#layout geometry}). For collapsed
 * group nodes and view edges, there is a separate set of properties available for each possible state combination. The {\@link yfiles.graph.FoldingManager#getFoldingEdgeState}
 * method for edges and the {\@link yfiles.graph.FoldingManager#getFolderNodeState} method for nodes provide access to that state
 * while it is not being displayed in a view.
 * </p>
 * @see yfiles.graph.FoldingManager#prepareFoldingView
 * @param {?|{root: ?, isExpanded: function(?): boolean}=} root_or_options
 * @param {function(?): boolean=} isExpanded
 * @return {?} A new graph instance that represents a synchronized view on the {\@link #masterGraph}.
 */
yfiles.graph.FoldingManager.prototype.createFoldingView = function(root_or_options, isExpanded) {};

/**
 * Disposes of this instance.
 * <p>
 * This will disconnect the {\@link yfiles.graph.FoldingManager#masterGraph} from the previously created {\@link yfiles.graph.FoldingManager#createFoldingView managed views}. Also each view will be {\@link yfiles.graph.IFoldingView#dispose disposed}.
 * </p>
 * @return {void}
 */
yfiles.graph.FoldingManager.prototype.dispose = function() {};

/**
 * Provides access to the folder node state of a node.
 * <p>
 * This method can be used to query the collapsed state of a node, even if the node is currently not present in any managed
 * view or the node is in fact expanded in all views.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} The master node does not belong to the managed graph.
 * @param {?} masterNode The node in the {\@link #masterGraph} for which the state should be returned.
 * @return {!yfiles.graph.FolderNodeState} A state holder implementation of a node, which is not part of any graph.
 */
yfiles.graph.FoldingManager.prototype.getFolderNodeState = function(masterNode) {};

/**
 * Return a data container implementation that is not part of any actual {\@link yfiles.graph.IGraph} that describes the state of
 * the edge for the given {\@link yfiles.graph.FoldingEdgeStateId}.
 * <p>
 * This method can be used to query the state of an edge that is either not currently visible in any {\@link yfiles.graph.FoldingManager#views view} or connects to
 * different source and target nodes because of the {\@link yfiles.graph.IFoldingView#collapse collapsed} states of the nodes and their parents in the view.
 * </p>
 * @see yfiles.graph.FoldingManager#getFolderNodeState
 * @see yfiles.graph.FoldingEdgeStateId
 * @param {!yfiles.graph.FoldingEdgeStateId} id The ID of the folding edge for which the folding state should be returned.
 * @return {!yfiles.graph.FoldingEdgeState} A {\@link } that can be used to query and change the properties of the edge.
 */
yfiles.graph.FoldingManager.prototype.getFoldingEdgeState = function(id) {};

/**
 * Determines whether for the given <code>masterNode</code> this manager has stored associated folder node state.
 * <p>
 * The manager does not necessarily have folder node state for folder nodes if that specific state has never been requested
 * by a {\@link yfiles.graph.IFoldingView view} because it has never been visualized. This method indicates whether there is state information available for
 * the given master node.
 * </p>
 * @see yfiles.graph.FoldingManager#getFolderNodeState
 * @param {?} masterNode The master node for which the state is requested.
 * @return {boolean} Whether {\@link #getFolderNodeState} would return existing state information.
 */
yfiles.graph.FoldingManager.prototype.hasFolderNodeState = function(masterNode) {};

/**
 * Determines whether for the given {\@link yfiles.graph.FoldingEdgeStateId} this manager has stored associated view local state.
 * <p>
 * The manager does not necessarily have a {\@link yfiles.graph.FoldingEdgeState} for folding elements if that specific state has
 * never been requested by a {\@link yfiles.graph.IFoldingView} because it has never been visualized. This method indicates whether
 * there is state information available for the given id.
 * </p>
 * @see yfiles.graph.FoldingManager#getFoldingEdgeState
 * @param {!yfiles.graph.FoldingEdgeStateId} id The id for which state is requested.
 * @return {boolean} Whether {\@link #getFoldingEdgeState} would return existing state information.
 */
yfiles.graph.FoldingManager.prototype.hasFoldingEdgeState = function(id) {};

/**
 * Callback that can be overridden by subclasses to prepare the {\@link yfiles.graph.IFoldingView} instance right before it will be
 * initialized with a copy of the elements in the initial graph.
 * <p>
 * Subclasses could override this method to register additional {\@link yfiles.collections.IMapper.<K,V>} instances with the graph instance or add
 * {\@link yfiles.graph.IContextLookupChainLink}s via the {\@link yfiles.graph.ILookupDecorator} of the {\@link yfiles.graph.IFoldingView#graph} to the instance if they are
 * essential for the initial creation of the elements in the view instance. Overriding methods should always consider to
 * call the base class implementation, first.
 * </p>
 * @protected
 * @param {?} foldingView The graph view that has just been created but is still empty.
 * @return {void}
 */
yfiles.graph.FoldingManager.prototype.prepareFoldingView = function(foldingView) {};

/**
 * Triggers a call to {\@link yfiles.graph.IFolderNodeConverter#updateFolderNodeState} for all view nodes that {\@link yfiles.graph.IFoldingView#getViewItem represent} the given <code>masterNode</code>
 * in its collapsed state.
 * <p>
 * In all {\@link yfiles.graph.FoldingManager#views} that are currrently showing the node in collapsed state, the {\@link yfiles.graph.FoldingManager#getFolderNodeState view-local state} will be updated via a call to the
 * {\@link yfiles.graph.IFolderNodeConverter}'s {\@link yfiles.graph.IFolderNodeConverter#updateFolderNodeState} method.
 * </p>
 * <p>
 * Note that all {\@link yfiles.graph.FoldingManager#views} share the same {\@link yfiles.graph.FolderNodeState} for the <code>masterNode</code>.
 * </p>
 * <p>
 * This method is useful in situations where a change in the data on the master graph did not automatically trigger a call
 * to the converter. Using this method, the state of the collapsed nodes in the views can be synchronized according to the
 * logic in the {\@link yfiles.graph.IFolderNodeConverter} implementation.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If the provided master node does not belong to the master graph.
 * @see yfiles.graph.FoldingManager#updateFoldingEdgeStates
 * @param {?} masterNode The master node that belongs to the {\@link #masterGraph}.
 * @return {void}
 */
yfiles.graph.FoldingManager.prototype.updateFolderNodeStates = function(masterNode) {};

/**
 * Triggers a call to {\@link yfiles.graph.IFoldingEdgeConverter#updateFoldingEdgeState} for all folder edges that {\@link yfiles.graph.IFoldingView#getViewItem represent} the
 * given <code>masterEdge</code>.
 * <p>
 * In all {\@link yfiles.graph.FoldingManager#views} that are currrently showing the view edge for the provided master edge, the {\@link yfiles.graph.FoldingManager#getFoldingEdgeState view-local state} will be updated via
 * a call to the {\@link yfiles.graph.IFoldingEdgeConverter}'s {\@link yfiles.graph.IFoldingEdgeConverter#updateFoldingEdgeState} method.
 * </p>
 * <p>
 * This method is useful in situations where a change in the data on the master graph did not automatically trigger a call
 * to the converter. Using this method, the state of the representing edges in the views can be synchronized according to
 * the logic in the {\@link yfiles.graph.IFoldingEdgeConverter} implementation.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If the provided master edge does not belong to the master graph.
 * @see yfiles.graph.FoldingManager#updateFolderNodeStates
 * @param {?} masterEdge The master edge that belongs to the {\@link #masterGraph}.
 * @return {void}
 */
yfiles.graph.FoldingManager.prototype.updateFoldingEdgeStates = function(masterEdge) {};
/**
 * @record
 * @struct
 */
yfiles.graph.FoldingBendState = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.graph.FoldingBendState.prototype.location;
 /** @type {!Object} */
yfiles.graph.FoldingBendState.prototype.tag;
 /** @type {number} */
yfiles.graph.FoldingBendState.prototype.index;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FoldingBendState.$class;

/**
 * Returns an {\@link yfiles.graph.IBend} instance which represents this bend state.
 * <p>
 * The returned bend is not present in any graph but may be passed to {\@link yfiles.graph.IFoldingView#getViewItem} to get the bend
 * state's view bend in the {\@link yfiles.graph.IFoldingView#graph folding view graph}.
 * </p>
 * @return {?} An {\@link } instance which represents this bend state.
 */
yfiles.graph.FoldingBendState.prototype.asBend = function() {};
/**
 * @record
 * @struct
 */
yfiles.graph.FoldingEdgeState = function() {};
 /** @type {!Object} */
yfiles.graph.FoldingEdgeState.prototype.tag;
 /** @type {?<!yfiles.graph.FoldingBendState>} */
yfiles.graph.FoldingEdgeState.prototype.bends;
 /** @type {!yfiles.graph.FoldingPortState} */
yfiles.graph.FoldingEdgeState.prototype.sourcePort;
 /** @type {!yfiles.graph.FoldingPortState} */
yfiles.graph.FoldingEdgeState.prototype.targetPort;
 /** @type {?} */
yfiles.graph.FoldingEdgeState.prototype.style;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FoldingEdgeState.$class;

/**
 * Adds a new {\@link yfiles.graph.FoldingBendState} to this edge state at the given <code>index</code> and <code>location</code>.
 * @param {!yfiles.geometry.Point} location The location of the new bend state.
 * @param {number=} index
 * @return {!yfiles.graph.FoldingBendState} The newly added bend state.
 */
yfiles.graph.FoldingEdgeState.prototype.addBend = function(location, index) {};

/**
 * Returns an {\@link yfiles.graph.IEdge} instance which represents this edge state.
 * <p>
 * The returned edge is not present in any graph but may be passed to {\@link yfiles.graph.IFoldingView#getViewItem} to get the edge
 * state's view edge in the {\@link yfiles.graph.IFoldingView#graph folding view graph}.
 * </p>
 * @return {?} An {\@link } instance which represents this edge state.
 */
yfiles.graph.FoldingEdgeState.prototype.asEdge = function() {};

/**
 * Removes all {\@link yfiles.graph.FoldingEdgeState#bends}.
 * @return {void}
 */
yfiles.graph.FoldingEdgeState.prototype.clearBends = function() {};

/**
 *
 * Removes the <code>bend</code> from this edge state.
 * @throws {Stubs.Exceptions.ArgumentError} Thrown if the <code>bend</code> doesn't belong to this edge state.
 * @param {!yfiles.graph.FoldingLabelState|!yfiles.graph.FoldingBendState} label_or_bend The bend to remove.
 * @return {void}
 */
yfiles.graph.FoldingEdgeState.prototype.remove = function(label_or_bend) {};
/**
 * @record
 * @struct
 */
yfiles.graph.FoldingLabelState = function() {};
 /** @type {?} */
yfiles.graph.FoldingLabelState.prototype.style;
 /** @type {!yfiles.geometry.Size} */
yfiles.graph.FoldingLabelState.prototype.preferredSize;
 /** @type {string} */
yfiles.graph.FoldingLabelState.prototype.text;
 /** @type {?} */
yfiles.graph.FoldingLabelState.prototype.layoutParameter;
 /** @type {!Object} */
yfiles.graph.FoldingLabelState.prototype.tag;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FoldingLabelState.$class;

/**
 * Returns an {\@link yfiles.graph.ILabel} instance which represents this label state.
 * <p>
 * The returned label is not present in any graph but may be passed to {\@link yfiles.graph.IFoldingView#getViewItem} to get the
 * label state's view label in the {\@link yfiles.graph.IFoldingView#graph folding view graph}.
 * </p>
 * @return {?} An {\@link } instance which represents this label state.
 */
yfiles.graph.FoldingLabelState.prototype.asLabel = function() {};
/**
 * @record
 * @struct
 */
yfiles.graph.FoldingLabelOwnerState = function() {};
 /** @type {?<!yfiles.graph.FoldingLabelState>} */
yfiles.graph.FoldingLabelOwnerState.prototype.labels;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FoldingLabelOwnerState.$class;

/**
 * Adds a {\@link yfiles.graph.FoldingLabelState} to this state.
 * @abstract
 * @param {string} text The text of the new label.
 * @param {?} layoutParameter The layout parameter of the new label.
 * @param {?} style The style of the new label.
 * @param {!yfiles.geometry.Size} preferredSize The preferred size of the label.
 * @param {!Object} tag The tag of the label.
 * @return {!yfiles.graph.FoldingLabelState} The newly added {\@link }.
 */
yfiles.graph.FoldingLabelOwnerState.prototype.addLabel = function(text, layoutParameter, style, preferredSize, tag) {};

/**
 * Removes all {\@link yfiles.graph.FoldingLabelOwnerState#labels}.
 * @return {void}
 */
yfiles.graph.FoldingLabelOwnerState.prototype.clearLabels = function() {};
/**
 * @record
 * @struct
 */
yfiles.graph.FoldingPortState = function() {};
 /** @type {?} */
yfiles.graph.FoldingPortState.prototype.style;
 /** @type {?} */
yfiles.graph.FoldingPortState.prototype.locationParameter;
 /** @type {!Object} */
yfiles.graph.FoldingPortState.prototype.tag;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FoldingPortState.$class;

/**
 * Returns an {\@link yfiles.graph.IPort} instance which represents this port state.
 * <p>
 * The returned port is not present in any graph but may be passed to {\@link yfiles.graph.IFoldingView#getViewItem} to get the port
 * state's view port in the {\@link yfiles.graph.IFoldingView#graph folding view graph}.
 * </p>
 * @abstract
 * @return {?} An {\@link } instance which represents this port state.
 */
yfiles.graph.FoldingPortState.prototype.asPort = function() {};
/**
 * @record
 * @struct
 */
yfiles.graph.FolderNodeState = function() {};
 /** @type {?} */
yfiles.graph.FolderNodeState.prototype.layout;
 /** @type {?} */
yfiles.graph.FolderNodeState.prototype.style;
 /** @type {!Object} */
yfiles.graph.FolderNodeState.prototype.tag;
 /** @type {?<!yfiles.graph.FoldingPortState>} */
yfiles.graph.FolderNodeState.prototype.ports;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.FolderNodeState.$class;

/**
 * Returns an {\@link yfiles.graph.INode} instance which represents this folder node state.
 * <p>
 * The returned node is not present in any graph but may be passed to {\@link yfiles.graph.IFoldingView#getViewItem} to get the node
 * state's folder node in the {\@link yfiles.graph.IFoldingView#graph folding view graph}.
 * </p>
 * @return {?} An {\@link } instance which represents this folder node state.
 */
yfiles.graph.FolderNodeState.prototype.asNode = function() {};

/**
 * Provides access to the folding state of a master port.
 * <p>
 * This method can be used to query the folding state of a port at the folder which is represented by this state.
 * </p>
 * @see yfiles.graph.FoldingPortState#style
 * @see yfiles.graph.FoldingPortState#locationParameter
 * @param {?} masterPort The master port for which the state should be returned.
 * @return {!yfiles.graph.FoldingPortState} A state holder implementation of the <code>masterPort</code>, which reflects the port in the node's collapsed state.
 */
yfiles.graph.FolderNodeState.prototype.getFoldingPortState = function(masterPort) {};

/**
 *
 * @param {!yfiles.graph.FoldingLabelState} label
 * @return {void}
 */
yfiles.graph.FolderNodeState.prototype.remove = function(label) {};
/**
 * @record
 * @struct
 */
yfiles.graph.IFoldingEdgeConverter = function() {};

/**
 * This method gets called by the {\@link yfiles.graph.IFoldingView} implementation to determine whether a given edge in the {\@link yfiles.graph.FoldingManager#masterGraph} should
 * be represented by a folding edge in the given view.
 * <p>
 * The implementation will be passed in a <code>factory</code> object that implements the {\@link yfiles.graph.IFoldingEdgeFactory} interface,
 * which needs to be used by the implementation to communicate the result of the query. The implementation needs to either
 * call {\@link yfiles.graph.IFoldingEdgeFactory#addAsSeparateEdge}, {\@link yfiles.graph.IFoldingEdgeFactory#addToExistingFoldingEdge}, or {\@link yfiles.graph.IFoldingEdgeFactory#excludeFoldingEdge}
 * and return the values that these implementation yields to the caller. The implementation can optionally query the {\@link yfiles.graph.IFoldingEdgeFactory#getExistingFoldingEdges existing folding edges}
 * between the source and target node and decide whether to add the edge {\@link yfiles.graph.IFoldingEdgeFactory#addToExistingFoldingEdge to the existing folding edge}.
 * </p>
 * @abstract
 * @param {?} factory The {\@link } implementation that needs to be called in order to communicate the results of this
 * query.
 * @param {?} foldingView The instance into which the folding edge is going to be inserted.
 * @param {?} masterEdge The edge from the {\@link #masterGraph} that needs to be represented by a folding edge. Note that you may not return this instance.
 * @param {?} source The source node that belongs to the {\@link } graph that will act as the local view node of the actual
 * source node.
 * @param {boolean} sourceIsCollapsed Determines whether the <code>source</code> is currently a folder node.
 * @param {?} target The target node that belongs to the {\@link } graph that will act as the local view node of the actual
 * target node.
 * @param {boolean} targetIsCollapsed Determines whether the <code>target</code> is currently a folder node.
 * @return {?} The edge as returned by {\@link #addAsSeparateEdge}, or
 * {\@link #addToExistingFoldingEdge}, or <code>null</code> if the edge will be {\@link #excludeFoldingEdge excluded} from the view.
 */
yfiles.graph.IFoldingEdgeConverter.prototype.addFoldingEdge = function(factory, foldingView, masterEdge, source, sourceIsCollapsed, target, targetIsCollapsed) {};

/**
 * Callback that is triggered by the {\@link yfiles.graph.IFoldingView view} to initially create the appearance of a folding edge.
 * <p>
 * Implementations may not use the {\@link yfiles.graph.IFoldingView}'s {\@link yfiles.graph.IFoldingView#graph} instance to modify the <code>foldingEdge</code>, because this would
 * create and enqueue undo events. Rather the properties provided by the <code>state</code> implementation must be set.
 * </p>
 * @see yfiles.graph.IFoldingEdgeConverter#updateFoldingEdgeState
 * @abstract
 * @param {!yfiles.graph.FoldingEdgeState} state The {\@link } of the edge to change.
 * @param {?} foldingView The graph to which the folding edge belongs.
 * @param {?} foldingEdge The folding edge for which the appearance shall be determined.
 * @param {?<?>} masterEdges The list of {\@link #getMasterEdges master edges}, that the folding edge initially represents.
 * @return {void}
 */
yfiles.graph.IFoldingEdgeConverter.prototype.initializeFoldingEdgeState = function(state, foldingView, foldingEdge, masterEdges) {};

/**
 * Callback that is triggered by the {\@link yfiles.graph.IFoldingView view} to adjust the appearance of a folding edge
 * <p>
 * For instance, it can be used to reflect a state change in the {\@link yfiles.graph.IFoldingView#getMasterEdges master edges} that make up that folding edge.
 * </p>
 * <p>
 * Implementations may not use the {\@link yfiles.graph.IFoldingView}'s {\@link yfiles.graph.IFoldingView#graph} instance to modify the <code>foldingEdge</code>, because this would
 * create and enqueue undo events. Rather the properties provided by the <code>state</code> implementation must be set.
 * </p>
 * @see yfiles.graph.IFoldingEdgeConverter#initializeFoldingEdgeState
 * @abstract
 * @param {!yfiles.graph.FoldingEdgeState} state The {\@link } of the edge to change.
 * @param {?} foldingView The graph to which the folding edge belongs.
 * @param {?} foldingEdge The folding edge for which the appearance might need an update.
 * @param {?<?>} masterEdges The list of {\@link #getMasterEdges master edges}, that the folding edge currently represents.
 * @return {void}
 */
yfiles.graph.IFoldingEdgeConverter.prototype.updateFoldingEdgeState = function(state, foldingView, foldingEdge, masterEdges) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IFoldingEdgeConverter;
/**
 * @record
 * @struct
 */
yfiles.graph.IFolderNodeConverter = function() {};

/**
 * Callback that is used by {\@link yfiles.graph.IFoldingView view} implementations to initially create the appearance of a {\@link yfiles.graph.IFoldingView#isInFoldingState folder} node.
 * <p>
 * This method is called by the view to allow for initially creating the appearance of a local folder node in the view when
 * it is included in the view for the first time. This can be used, e.g. to initialize the labels or style properties with
 * the corresponding properties of the <code>masterNode</code>.
 * </p>
 * <p>
 * By default the <code>state</code> is an exact copy of the <code>masterNode</code>, including layout, style, labels, and ports.
 * </p>
 * <p>
 * Note that changing the appearance has to be done on <code>state</code>.
 * </p>
 * @see yfiles.graph.IFolderNodeConverter#updateFolderNodeState
 * @abstract
 * @param {!yfiles.graph.FolderNodeState} state The folder node state to initialize.
 * @param {?} foldingView The graph instance for which the folder node has been created.
 * @param {?} viewNode The folder node instance in the view
 * @param {?} masterNode The node that represents the {\@link #getMasterItem} of the viewstate to change.
 * @return {void}
 */
yfiles.graph.IFolderNodeConverter.prototype.initializeFolderNodeState = function(state, foldingView, viewNode, masterNode) {};

/**
 * Callback that is used by {\@link yfiles.graph.IFoldingView view} implementations to change the appearance of a {\@link yfiles.graph.IFoldingView#isInFoldingState folder} node.
 * <p>
 * This method is called by the view to allow for adjusting the appearance of a local folder node in the view when the {\@link yfiles.graph.IFoldingView#getMasterItem master}
 * node for it has changed properties. This can be used, e.g. to synchronize the label or style properties with the
 * corresponding properties of the <code>masterNode</code>.
 * </p>
 * <p>
 * Note that changing the appearance has to be done on <code>state</code>.
 * </p>
 * @see yfiles.graph.IFolderNodeConverter#initializeFolderNodeState
 * @abstract
 * @param {!yfiles.graph.FolderNodeState} state The folder node state to update.
 * @param {?} foldingView The graph instance for which the folder node can be changed.
 * @param {?} viewNode The folder node instance in the view
 * @param {?} masterNode The node that represents the {\@link #getMasterItem} of the viewstate to change.
 * @return {void}
 */
yfiles.graph.IFolderNodeConverter.prototype.updateFolderNodeState = function(state, foldingView, viewNode, masterNode) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IFolderNodeConverter;
/**
 * @record
 * @struct
 */
yfiles.graph.IFoldingEdgeFactory = function() {};

/**
 * Tells the {\@link yfiles.graph.IFoldingView} implementation to add the edge provided to the {\@link yfiles.graph.IFoldingEdgeConverter#addFoldingEdge}
 * method as a separate folding edge to the view at the given ports.
 * <p>
 * This tells the view that there is currently no {\@link yfiles.graph.IFoldingEdgeFactory#getExistingFoldingEdges existing folding edge} in the view to which the master edge should be
 * added to. Instead the view should add a separate folding edge that represents the master edge. Use the result of this
 * method call as the return value for the {\@link yfiles.graph.IFoldingEdgeConverter#addFoldingEdge} call. Note that the returned
 * folding edge should not be modified by this code, instead the {\@link yfiles.graph.IFoldingEdgeConverter#initializeFoldingEdgeState}
 * and {\@link yfiles.graph.IFoldingEdgeConverter#updateFoldingEdgeState} callbacks need to be used to change the appearance of the
 * folding edge. Existing ports at the provided source and target nodes may be specified to further influence the folding
 * edge creation.
 * </p>
 * @see yfiles.graph.IFoldingEdgeConverter
 * @see yfiles.graph.IFoldingView#getViewItem
 * @abstract
 * @param {?} sourcePort The source port at the source node in the view to use or <code>null</code> if an extra {\@link #isInFoldingState folding state} port should be added for the
 * edge to connect to at the source.
 * @param {?} targetPort The target port at the target node in the view to use or <code>null</code> if an extra {\@link #isInFoldingState folding state} port should be added for the
 * edge to connect to at the target.
 * @return {?} The folding edge that has been created in the view. Don't change the properties of the edge directly.
 */
yfiles.graph.IFoldingEdgeFactory.prototype.addAsSeparateEdge = function(sourcePort, targetPort) {};

/**
 * Tells the {\@link yfiles.graph.IFoldingView} implementation to logically add the edge provided to the {\@link yfiles.graph.IFoldingEdgeConverter#addFoldingEdge}
 * method to a folding edge that already exists in the view.
 * <p>
 * This tells the view that there is already an {\@link yfiles.graph.IFoldingEdgeFactory#getExistingFoldingEdges existing folding edge} in the view to which the master edge should be added
 * logically added to. The given <code>foldingEdge</code> will have the master edge added to its collection of {\@link yfiles.graph.IFoldingView#getMasterEdges master edges}. Note that
 * the returned folding edge should not be modified by this code, instead the {\@link yfiles.graph.IFoldingEdgeConverter#updateFoldingEdgeState}
 * callback needs to be used to change the appearance of the folding edge. Implementations can use the {\@link yfiles.graph.IFoldingEdgeFactory#getExistingFoldingEdges}
 * method to retrieve the current set of existing folding edges that interconnect the same source and target nodes. The
 * range of valid parameters is constrained to this collection.
 * </p>
 * @see yfiles.graph.IFoldingEdgeConverter
 * @see yfiles.graph.IFoldingEdgeFactory#getExistingFoldingEdges
 * @abstract
 * @param {?} foldingEdge One of the {\@link #getExistingFoldingEdges existing folding edges} from the view which has been chosen to represent the master edge in this view.
 * @return {?} The folding edge that represents the edge in the view, which is the same as the <code>foldingEdge</code> parameter. Don't change the
 * properties of the edge directly.
 */
yfiles.graph.IFoldingEdgeFactory.prototype.addToExistingFoldingEdge = function(foldingEdge) {};

/**
 * Tells the {\@link yfiles.graph.IFoldingView} implementation not to add a folding edge for the edge provided to the {\@link yfiles.graph.IFoldingEdgeConverter#addFoldingEdge}
 * method in this view.
 * <p>
 * This tells the view that there should not be a representation of the master edge in this view. If this method is called,
 * <code>null</code> should be returned as the result of a {\@link yfiles.graph.IFoldingEdgeConverter#addFoldingEdge} call, which is the same as
 * the return value of this method. So it is possible to just pass the return value on to the caller.
 * </p>
 * @see yfiles.graph.IFoldingEdgeConverter
 * @abstract
 * @return {?} This method will always return <code>null</code>. This is for symmetry reasons to be easily exchangeable with the other methods.
 */
yfiles.graph.IFoldingEdgeFactory.prototype.excludeFoldingEdge = function() {};

/**
 * Helper methods that can be used by the implementation of the {\@link yfiles.graph.IFoldingEdgeConverter#addFoldingEdge} method to
 * determine the folding edges that are currently part of the view and interconnect the same nodes as the folding edge
 * would, if it was included in the view.
 * <p>
 * This method will yield all {\@link yfiles.graph.IFoldingView#isInFoldingState folding edges} that interconnect the same source and target node as that the folding edge
 * would, if it was included in this view. One of the items in the returned collection can be passed to the {\@link yfiles.graph.IFoldingEdgeFactory#addToExistingFoldingEdge}
 * method.
 * </p>
 * @abstract
 * @param {boolean} ignoreDirection Whether the direction of the edges should be ignored so that reverse edges are included in the enumeration, too.
 * @return {?<?>} An collection of currently existing folding edges in the view that interconnects the same source and target node.
 */
yfiles.graph.IFoldingEdgeFactory.prototype.getExistingFoldingEdges = function(ignoreDirection) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IFoldingEdgeFactory;
/**
 * @record
 * @struct
 */
yfiles.graph.IStripe = function() {};
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.IStripe.prototype.insets;
 /** @type {?} */
yfiles.graph.IStripe.prototype.layout;
 /** @type {?} */
yfiles.graph.IStripe.prototype.style;
 /** @type {number} */
yfiles.graph.IStripe.prototype.size;
 /** @type {number} */
yfiles.graph.IStripe.prototype.minimumSize;
 /** @type {?} */
yfiles.graph.IStripe.prototype.table;
 /** @type {boolean} */
yfiles.graph.IStripe.prototype.isRoot;
 /** @type {number} */
yfiles.graph.IStripe.prototype.index;
 /** @type {number} */
yfiles.graph.IStripe.prototype.actualMinSize;
 /** @type {?<?>} */
yfiles.graph.IStripe.prototype.childStripes;
 /** @type {?} */
yfiles.graph.IStripe.prototype.parentStripe;
 /** @type {?} */
yfiles.graph.IStripe.prototype.root;
 /** @type {?<?>} */
yfiles.graph.IStripe.prototype.leaves;
 /** @type {?<?>} */
yfiles.graph.IStripe.prototype.descendants;
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.IStripe.prototype.actualInsets;
 /** @type {number} */
yfiles.graph.IStripe.prototype.actualSize;

/**
 * Returns the layout of <code>stripe</code> in absolute coordinates.
 * <p>
 * Since {\@link yfiles.graph.IStripe#layout} is relative to the owning node's left corner, you need to provide an <code>node</code> node to calculate the absolute layout.
 * </p>
 * @param {?} node The node relative to which the stripe layout is calculated. This should be the same node where {\@link #table} for <code>stripe</code> is associated
 * to.
 * @return {!yfiles.geometry.Rect}
 */
yfiles.graph.IStripe.prototype.getAbsoluteBounds = function(node) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IStripe;
/**
 * @record
 * @struct
 */
yfiles.graph.ITable = function() {};
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.ITable.prototype.insets;
 /** @type {!yfiles.geometry.Point} */
yfiles.graph.ITable.prototype.relativeLocation;
 /** @type {?} */
yfiles.graph.ITable.prototype.layout;
 /** @type {?} */
yfiles.graph.ITable.prototype.rowDefaults;
 /** @type {?} */
yfiles.graph.ITable.prototype.columnDefaults;
 /** @type {?} */
yfiles.graph.ITable.prototype.rootRow;
 /** @type {?} */
yfiles.graph.ITable.prototype.rootColumn;

/**
 * Add a label to the given owner using the text as the initial label text and label model parameter and style.
 * @see yfiles.graph.ITable#setLabelText
 * @see yfiles.graph.ITable#setLabelLayoutParameter
 * @see yfiles.graph.ITable#setStyle
 * @abstract
 * Add a label to the given owner using the text as the initial label text and label model parameter and style.
 * @see yfiles.graph.ITable#setLabelText
 * @see yfiles.graph.ITable#setLabelLayoutParameter
 * @see yfiles.graph.ITable#setStyle
 * @abstract
 * @param {?|{owner: ?, text: string, layoutParameter: ?, style: ?, preferredSize: !yfiles.geometry.Size, tag: !Object}} owner_or_options the owner to add the label to.
 * @param {string=} text the initial text of the label
 * @param {?=} layoutParameter
 * @param {?=} style
 * @param {!yfiles.geometry.Size=} preferredSize
 * @param {!Object=} tag
 * @return {?} the newly created label
 */
yfiles.graph.ITable.prototype.addLabel = function(owner_or_options, text, layoutParameter, style, preferredSize, tag) {};

/**
 * Adjusts the {\@link yfiles.graph.ILabel#preferredSize} property of a label to fit the suggested size of its {\@link yfiles.styles.ILabelStyleRenderer}.
 * <p>
 * This implementation uses the {\@link yfiles.graph.ILabel#style style's} renderer for the label to determine the preferred rendering size. This is useful
 * after the label's content or style have been changed.
 * </p>
 * @see yfiles.graph.ILabelDefaults#autoAdjustPreferredSize
 * @param {?} label The label to adjust the size for.
 * @return {void}
 */
yfiles.graph.ITable.prototype.adjustLabelPreferredSize = function(label) {};

/**
 * Calculates the preferred size of a label with the given properties.
 * @param {?} stripe The item that will own the label.
 * @param {?} style The label style.
 * @param {?} layoutParameter The label model parameter.
 * @param {string} text The text.
 * @param {!Object} tag The tag for the label.
 * @return {!yfiles.geometry.Size} The size as calculated by the {\@link }.
 */
yfiles.graph.ITable.prototype.calculateLabelPreferredSize = function(stripe, style, layoutParameter, text, tag) {};

/**
 * Convenience method that clears all stripes from a table.
 * <p>
 * All existing rows and columns are cleared from <code>table</code>
 * </p>
 * @return {void}
 */
yfiles.graph.ITable.prototype.clear = function() {};

/**
 * Create a new column as the <code>index</code>th child of <code>owner</code> with the given parameters.
 * @abstract
 * Create a new column as the <code>index</code>th child of <code>owner</code> with the given parameters.
 * @abstract
 * @param {?|{owner: ?, width: number, minWidth: number, insets: !yfiles.geometry.Insets, style: ?, tag: !Object, index: number, labels: !Array<?>, childColumns: !Array<?>}} owner_or_options The owner of the new column.
 * @param {number=} width
 * @param {number=} minWidth
 * @param {!yfiles.geometry.Insets=} insets
 * @param {?=} style
 * @param {!Object=} tag
 * @param {number=} index
 * @return {?} A new column instance
 */
yfiles.graph.ITable.prototype.createChildColumn = function(owner_or_options, width, minWidth, insets, style, tag, index) {};

/**
 * Create a new row as the <code>index</code>th child of <code>owner</code> with the given parameters.
 * @abstract
 * Create a new row as the <code>index</code>th child of <code>owner</code> with the given parameters.
 * @abstract
 * @param {?|{owner: ?, height: number, minHeight: number, insets: !yfiles.geometry.Insets, style: ?, tag: !Object, index: number, labels: !Array<?>, childRows: !Array<?>}} owner_or_options The owner of the new row.
 * @param {number=} height
 * @param {number=} minHeight
 * @param {!yfiles.geometry.Insets=} insets
 * @param {?=} style
 * @param {!Object=} tag
 * @param {number=} index
 * @return {?} A new row instance
 */
yfiles.graph.ITable.prototype.createChildRow = function(owner_or_options, height, minHeight, insets, style, tag, index) {};

/**
 * Creates and returns a column as last child of <code>table</code>.
 * <p>
 * The column will be a part of this table after the method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.ITable#addStripeCreatedListener
 * Creates and returns a column as last child of <code>table</code>.
 * <p>
 * The column will be a part of this table after the method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.ITable#addStripeCreatedListener
 * @param {number|{width: number, minWidth: number, insets: !yfiles.geometry.Insets, style: ?, tag: !Object, index: number}=} width_or_options
 * @param {number=} minWidth
 * @param {!yfiles.geometry.Insets=} insets
 * @param {?=} style
 * @param {!Object=} tag
 * @param {number=} index
 * @return {?} A newly created column instance
 */
yfiles.graph.ITable.prototype.createColumn = function(width_or_options, minWidth, insets, style, tag, index) {};

/**
 * Convenience method that creates a <code>columns</code> x <code>rows</code>.
 * <p>
 * All existing rows and columns are cleared from <code>table</code>
 * </p>
 * @param {number} columns The number of columns to test.
 * @param {number} rows The number of rows to test.
 * @return {void}
 */
yfiles.graph.ITable.prototype.createGrid = function(columns, rows) {};

/**
 * Creates the label model parameter for a given {\@link yfiles.graph.ILabelOwner}.
 * <p>
 * This implementation uses the label defaults for the <code>table</code> to {\@link yfiles.graph.ILabelDefaults#getLayoutParameterInstance obtain the parameter instance}.
 * </p>
 * @see yfiles.graph.ILabelDefaults#getLayoutParameterInstance
 * @param {?} stripe The item that is the {\@link #owner} of the label in question.
 * @return {?} The default label model parameter to use for newly created labels at the item.
 */
yfiles.graph.ITable.prototype.createLabelLayoutParameter = function(stripe) {};

/**
 * Convenience method that delegates to the {\@link yfiles.graph.ILabelDefaults#getStyleInstance} method for the given {\@link yfiles.graph.IStripe stripe}.
 * @param {?} stripe The item the newly created label will belong to.
 * @return {?} The style instance to use for newly created stripes.
 */
yfiles.graph.ITable.prototype.createLabelStyle = function(stripe) {};

/**
 * Creates and returns a row as last child of <code>table</code>.
 * <p>
 * The row will be a part of this table after the method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.ITable#addStripeCreatedListener
 * Creates and returns a row as last child of <code>table</code>.
 * <p>
 * The row will be a part of this table after the method returns. This will trigger the corresponding events.
 * </p>
 * @see yfiles.graph.ITable#addStripeCreatedListener
 * @param {number|{height: number, minHeight: number, insets: !yfiles.geometry.Insets, style: ?, tag: !Object, index: number}=} height_or_options
 * @param {number=} minHeight
 * @param {!yfiles.geometry.Insets=} insets
 * @param {?=} style
 * @param {!Object=} tag
 * @param {number=} index
 * @return {?} A newly created row instance
 */
yfiles.graph.ITable.prototype.createRow = function(height_or_options, minHeight, insets, style, tag, index) {};

/**
 * Convenience method to find a column underneath a certain point.
 * <p>
 * The column are tested in bottom up order.
 * </p>
 * @param {?} node The node this table is currently bound to
 * @param {!yfiles.geometry.Point} location The location to test.
 * @param {function(?): boolean} filter Additional predicate to further restrict the results.
 * @return {?} The topmost column that has been found for the location or <code>null</code>.
 */
yfiles.graph.ITable.prototype.findColumn = function(node, location, filter) {};

/**
 * Convenience method to find a row underneath a certain point.
 * <p>
 * The rows are tested in bottom up order.
 * </p>
 * @param {?} node The node this table is currently bound to
 * @param {!yfiles.geometry.Point} location The location to test.
 * @param {function(?): boolean} filter Additional predicate to further restrict the results.
 * @return {?} The topmost row that has been found for the location or <code>null</code>.
 */
yfiles.graph.ITable.prototype.findRow = function(node, location, filter) {};

/**
 * Convenience method to find all stripes underneath a certain point.
 * <p>
 * The stripes are always returned in bottom up, rows first order. Note that this method does not take any {\@link yfiles.view.ICanvasContext#hitTestRadius} into account.
 * </p>
 * @param {?} node The node this table is currently bound to
 * @param {!yfiles.geometry.Point} location The location to test.
 * @param {yfiles.graph.StripeTypes} stripeTypes An enumeration value of {\@link } to specify the stripe type.
 * @param {function(?): boolean} filter Additional predicate to further restrict the hit test results.
 * @return {?<?>} The stripes that have been found for the location or <code>null</code>.
 */
yfiles.graph.ITable.prototype.findStripes = function(node, location, stripeTypes, filter) {};

/**
 * Return the accumulated insets for the table.
 * @return {!yfiles.geometry.Insets}
 */
yfiles.graph.ITable.prototype.getAccumulatedInsets = function() {};

/**
 * Calculates the relative bounds of a table cell that is determined by <code>column</code> and <code>row</code>
 * <p>
 * Both <code>column</code> and <code>row</code> must live in the provided <code>table</code> instance. Otherwise, an {\@link yfiles.lang.Exception} is thrown.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If <code>column</code> and <code>row</code> are part of a different table instance.
 * @param {?} column The column that determines the cell
 * @param {?} row The row that determines the cell
 * @return {!yfiles.geometry.Rect} The relative bounds of a the cell determined by <code>column</code> and <code>row</code>
 */
yfiles.graph.ITable.prototype.getCellBounds = function(column, row) {};

/**
 * Removes <code>stripe</code> from its parent container.
 * <p>
 * This method reparents all children of <code>stripe</code> to the parent of the stripe.
 * </p>
 * @abstract
 * Removes the given label from its owner.
 * <p>
 * This will trigger the corresponding event.
 * </p>
 * @abstract
 * @param {?} stripe_or_label The stripe to remove / the label to remove
 * @return {void}
 */
yfiles.graph.ITable.prototype.remove = function(stripe_or_label) {};

/**
 * {\@link yfiles.graph.ITable#remove Removes} <code>stripe</code> and all of its descendants from <code>table</code>.
 * <p>
 * This method does not resize any stripes, use {\@link yfiles.graph.ITable#removeRecursivelyWithResize} instead.
 * </p>
 * @param {?} stripe The stripe to remove
 * @return {void}
 */
yfiles.graph.ITable.prototype.removeRecursively = function(stripe) {};

/**
 * {\@link yfiles.graph.ITable#removeWithResize Removes} the given <code>stripe</code> and all of its descendants from <code>table</code> and resizes all affected stripes so that the table size
 * does not change if possible.
 * @param {?} stripe The stripe to remove
 * @return {void}
 */
yfiles.graph.ITable.prototype.removeRecursivelyWithResize = function(stripe) {};

/**
 * {\@link yfiles.graph.ITable#remove Removes} <code>stripe</code> from <code>table</code> and resizes all affected stripes so that the table size does not change if possible.
 * @param {?} stripe The stripe to remove
 * @return {void}
 */
yfiles.graph.ITable.prototype.removeWithResize = function(stripe) {};

/**
 * Sets the label model parameter for the given label.
 * @throws {Stubs.Exceptions.ArgumentError} If the parameter cannot be used for this label.
 * @abstract
 * @param {?} label The label.
 * @param {?} layoutParameter The new parameter.
 * @return {void}
 */
yfiles.graph.ITable.prototype.setLabelLayoutParameter = function(label, layoutParameter) {};

/**
 * Sets the preferred size of the label.
 * @see yfiles.graph.ILabel#preferredSize
 * @abstract
 * @param {?} label The label.
 * @param {!yfiles.geometry.Size} preferredSize The new preferred size.
 * @return {void}
 */
yfiles.graph.ITable.prototype.setLabelPreferredSize = function(label, preferredSize) {};

/**
 * Sets the label text of the given label.
 * @see yfiles.graph.ILabel#text
 * @abstract
 * @param {?} label the label to modify
 * @param {string} text the new text of the label
 * @return {void}
 */
yfiles.graph.ITable.prototype.setLabelText = function(label, text) {};

/**
 * Sets the minimum size of <code>stripe</code>.
 * <p>
 * This method sets the {\@link yfiles.graph.IStripe#minimumSize} of <code>stripe</code>.
 * </p>
 * @abstract
 * @param {?} stripe The stripe to change
 * @param {number} minimumSize The new minimum size of the stripe
 * @return {void}
 */
yfiles.graph.ITable.prototype.setMinimumSize = function(stripe, minimumSize) {};

/**
 * Sets <code>owner</code> as new parent of <code>column</code>, inserting <code>column</code> at the given <code>index</code>.
 * <p>
 * The column will be inserted at position <code>index</code> in the child list of the new parent.
 * </p>
 * @abstract
 * Sets <code>owner</code> as new parent of <code>row</code>, inserting <code>row</code> at the given <code>index</code>.
 * <p>
 * The row will be inserted at position <code>index</code> in the child list of the new parent.
 * </p>
 * @abstract
 * @param {?} owner
 * @param {?} column_or_row
 * @param {number=} index
 * @return {void}
 */
yfiles.graph.ITable.prototype.setParent = function(owner, column_or_row, index) {};

/**
 * Sets the actual size of <code>stripe</code>.
 * <p>
 * This method sets the {\@link yfiles.graph.IStripe#size} of <code>stripe</code>.
 * </p>
 * @abstract
 * @param {?} stripe The stripe to change
 * @param {number} size The new size of the stripe
 * @return {void}
 */
yfiles.graph.ITable.prototype.setSize = function(stripe, size) {};

/**
 * Sets the insets of <code>stripe</code>.
 * @abstract
 * @param {?} stripe The stripe to change
 * @param {!yfiles.geometry.Insets} insets The new insets of the stripe
 * @return {void}
 */
yfiles.graph.ITable.prototype.setStripeInsets = function(stripe, insets) {};

/**
 * Sets the style of <code>stripe</code>.
 * @abstract
 * Assigns the given style instance by reference to the label.
 * <p>
 * Style instances can be shared.
 * </p>
 * @see yfiles.graph.ILabel#style
 * @abstract
 * @param {?} stripe_or_label The stripe to change / The label that will be assigned the new style
 * @param {?} style The new style of the stripe / The style instance that will be assigned to the label.
 * @return {void}
 */
yfiles.graph.ITable.prototype.setStyle = function(stripe_or_label, style) {};

/**
 * Adds the given listener for the <code>LabelAdded</code> event that occurs when a label has been added to this graph instance.
 * @see yfiles.graph.ITable#addLabel
 * @see yfiles.graph.ITable#removeLabelAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.ITable.prototype.addLabelAddedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelAdded</code> event that occurs when a label has been added to this graph instance.
 * @see yfiles.graph.ITable#addLabel
 * @see yfiles.graph.ITable#addLabelAddedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.ITable.prototype.removeLabelAddedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelRemoved</code> event that occurs when a label has been removed from this graph instance.
 * <p>
 * This event will also be triggered, prior to the removal of the {\@link yfiles.graph.ILabel#owner owner} of the label.
 * </p>
 * <p>
 * Implementations may choose to use the {\@link yfiles.graph.LabelEventArgs} to carry additional label owner information. The {\@link yfiles.graph.LabelEventArgs#owner}
 * property will be set to the the owner of the label that owned it before the removal.
 * </p>
 * @see yfiles.graph.ITable#remove
 * @see yfiles.graph.ITable#removeLabelRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.ITable.prototype.addLabelRemovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelRemoved</code> event that occurs when a label has been removed from this graph
 * instance.
 * <p>
 * This event will also be triggered, prior to the removal of the {\@link yfiles.graph.ILabel#owner owner} of the label.
 * </p>
 * <p>
 * Implementations may choose to use the {\@link yfiles.graph.LabelEventArgs} to carry additional label owner information. The {\@link yfiles.graph.LabelEventArgs#owner}
 * property will be set to the the owner of the label that owned it before the removal.
 * </p>
 * @see yfiles.graph.ITable#remove
 * @see yfiles.graph.ITable#addLabelRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.ITable.prototype.removeLabelRemovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>LabelChanged</code> event that occurs when a label has been changed, for instance, if its style
 * has been replaced.
 * @see yfiles.graph.ITable#setStyle
 * @see yfiles.graph.ITable#removeLabelChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.ITable.prototype.addLabelChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>LabelChanged</code> event that occurs when a label has been changed, for instance, if its
 * style has been replaced.
 * @see yfiles.graph.ITable#setStyle
 * @see yfiles.graph.ITable#addLabelChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.ITable.prototype.removeLabelChangedListener = function(listener) {};

/**
 * Adds the given listener for the <code>StripeCreated</code> event that occurs when a stripe has been added.
 * @see yfiles.graph.ITable#createChildRow
 * @see yfiles.graph.ITable#createChildColumn
 * @see yfiles.graph.ITable#removeStripeCreatedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.ITable.prototype.addStripeCreatedListener = function(listener) {};

/**
 * Removes the given listener for the <code>StripeCreated</code> event that occurs when a stripe has been added.
 * @see yfiles.graph.ITable#createChildRow
 * @see yfiles.graph.ITable#createChildColumn
 * @see yfiles.graph.ITable#addStripeCreatedListener
 * @abstract
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.ITable.prototype.removeStripeCreatedListener = function(listener) {};

/**
 * Adds the given listener for the <code>StripeRemoved</code> event that occurs when a stripe has been removed from its parent.
 * @see yfiles.graph.ITable#remove
 * @see yfiles.graph.ITable#removeStripeRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.ITable.prototype.addStripeRemovedListener = function(listener) {};

/**
 * Removes the given listener for the <code>StripeRemoved</code> event that occurs when a stripe has been removed from its parent.
 * @see yfiles.graph.ITable#remove
 * @see yfiles.graph.ITable#addStripeRemovedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.ITable.prototype.removeStripeRemovedListener = function(listener) {};

/**
 * Adds the given listener for the <code>StripeChanged</code> event that occurs when a stripe has been changed, for instance, if its
 * style has been replaced.
 * @see yfiles.graph.ITable#setStyle
 * @see yfiles.graph.ITable#setStripeInsets
 * @see yfiles.graph.ITable#setSize
 * @see yfiles.graph.ITable#setMinimumSize
 * @see yfiles.graph.ITable#removeStripeChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.graph.ITable.prototype.addStripeChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>StripeChanged</code> event that occurs when a stripe has been changed, for instance, if its
 * style has been replaced.
 * @see yfiles.graph.ITable#setStyle
 * @see yfiles.graph.ITable#setStripeInsets
 * @see yfiles.graph.ITable#setSize
 * @see yfiles.graph.ITable#setMinimumSize
 * @see yfiles.graph.ITable#addStripeChangedListener
 * @abstract
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.graph.ITable.prototype.removeStripeChangedListener = function(listener) {};
 /** @type {{findStripe: function(!yfiles.geometry.Point, yfiles.graph.StripeTypes, yfiles.input.StripeSubregionTypes, !yfiles.view.CanvasComponent, function(!yfiles.input.StripeSubregion): boolean): !yfiles.input.StripeSubregion, findStripes: function(!yfiles.geometry.Point, yfiles.graph.StripeTypes, yfiles.input.StripeSubregionTypes, !yfiles.view.CanvasComponent, function(!yfiles.input.StripeSubregion): boolean): ?<!yfiles.input.StripeSubregion>, getCellBounds: function(?, ?, ?): !yfiles.geometry.Rect, placeNodeInCell: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.ITable;
/**
 * @record
 * @struct
 */
yfiles.graph.IRow = function() {};
 /** @type {?} */
yfiles.graph.IRow.prototype.parentRow;
 /** @type {?<?>} */
yfiles.graph.IRow.prototype.childRows;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IRow;
/**
 * @record
 * @struct
 */
yfiles.graph.IColumn = function() {};
 /** @type {?} */
yfiles.graph.IColumn.prototype.parentColumn;
 /** @type {?<?>} */
yfiles.graph.IColumn.prototype.childColumns;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IColumn;

/** @const */
yfiles.graph.StretchStripeLabelModelPosition = {};
/** @const {number} */
yfiles.graph.StretchStripeLabelModelPosition.NORTH;
/** @const {number} */
yfiles.graph.StretchStripeLabelModelPosition.EAST;
/** @const {number} */
yfiles.graph.StretchStripeLabelModelPosition.SOUTH;
/** @const {number} */
yfiles.graph.StretchStripeLabelModelPosition.WEST;
/**
 * @record
 * @struct
 */
yfiles.graph.StretchStripeLabelModel = function() {};
 /** @type {?} */
yfiles.graph.StretchStripeLabelModel.NORTH;
 /** @type {?} */
yfiles.graph.StretchStripeLabelModel.SOUTH;
 /** @type {?} */
yfiles.graph.StretchStripeLabelModel.EAST;
 /** @type {?} */
yfiles.graph.StretchStripeLabelModel.WEST;
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.StretchStripeLabelModel.prototype.insets;
 /** @type {boolean} */
yfiles.graph.StretchStripeLabelModel.prototype.useActualInsets;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.StretchStripeLabelModel.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.StretchStripeLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates the parameter for the given position.
 * @param {yfiles.graph.StretchStripeLabelModelPosition} position The position.
 * @return {?}
 */
yfiles.graph.StretchStripeLabelModel.prototype.createParameter = function(position) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.StretchStripeLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 * Calculates the geometry in form of an {\@link yfiles.geometry.IOrientedRectangle} for a given label using the given model
 * parameter.
 * <p>
 * The geometry is calculated in table coordinates, i.e. relative to {\@link yfiles.graph.ITable#relativeLocation}.
 * </p>
 * @param {?} label the label to calculate the geometry for
 * @param {?} layoutParameter A parameter that has been created by this model. This is typically the parameter that yielded this instance through its
 * {\@link #model} property.
 * @return {?} An instance that describes the geometry. This is typically an instance designed as a flyweight, so clients should not
 * cache the instance but store the values if they need a snapshot for later use
 */
yfiles.graph.StretchStripeLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} model
 * @return {?<?>}
 */
yfiles.graph.StretchStripeLabelModel.prototype.getParameters = function(label, model) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.StretchStripeLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.StripeEventArgs = function() {};
 /** @type {?} */
yfiles.graph.StripeEventArgs.prototype.parentStripe;
 /** @type {?} */
yfiles.graph.StripeEventArgs.prototype.table;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.StripeEventArgs.$class;

/** @const */
yfiles.graph.StripeLabelModelPosition = {};
/** @const {number} */
yfiles.graph.StripeLabelModelPosition.NORTH;
/** @const {number} */
yfiles.graph.StripeLabelModelPosition.EAST;
/** @const {number} */
yfiles.graph.StripeLabelModelPosition.SOUTH;
/** @const {number} */
yfiles.graph.StripeLabelModelPosition.WEST;
/**
 * @record
 * @struct
 */
yfiles.graph.StripeLabelModel = function() {};
 /** @type {?} */
yfiles.graph.StripeLabelModel.NORTH;
 /** @type {?} */
yfiles.graph.StripeLabelModel.SOUTH;
 /** @type {?} */
yfiles.graph.StripeLabelModel.EAST;
 /** @type {?} */
yfiles.graph.StripeLabelModel.WEST;
 /** @type {boolean} */
yfiles.graph.StripeLabelModel.prototype.useActualInsets;
 /** @type {number} */
yfiles.graph.StripeLabelModel.prototype.ratio;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.StripeLabelModel.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.StripeLabelModel.prototype.createDefaultParameter = function() {};

/**
 * Creates the parameter for the given position.
 * @param {yfiles.graph.StripeLabelModelPosition} position The position.
 * @return {?}
 */
yfiles.graph.StripeLabelModel.prototype.createParameter = function(position) {};

/**
 *
 * @param {?} label
 * @param {?} layoutParameter
 * @return {?}
 */
yfiles.graph.StripeLabelModel.prototype.getContext = function(label, layoutParameter) {};

/**
 * Calculates the geometry in form of an {\@link yfiles.geometry.IOrientedRectangle} for a given label using the given model
 * parameter.
 * <p>
 * The geometry is calculated in table coordinates, i.e. relative to {\@link yfiles.graph.ITable#relativeLocation}.
 * </p>
 * @param {?} label the label to calculate the geometry for
 * @param {?} layoutParameter A parameter that has been created by this model. This is typically the parameter that yielded this instance through its
 * {\@link #model} property.
 * @return {?} An instance that describes the geometry. This is typically an instance designed as a flyweight, so clients should not
 * cache the instance but store the values if they need a snapshot for later use
 */
yfiles.graph.StripeLabelModel.prototype.getGeometry = function(label, layoutParameter) {};

/**
 *
 * @param {?} label
 * @param {?} model
 * @return {?<?>}
 */
yfiles.graph.StripeLabelModel.prototype.getParameters = function(label, model) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.StripeLabelModel.prototype.lookup = function(type) {};
/**
 * @record
 * @struct
 */
yfiles.graph.Table = function() {};
 /** @type {?} */
yfiles.graph.Table.DEFAULT_STRIPE_LOOKUP;
 /** @type {?} */
yfiles.graph.Table.DEFAULT_COLUMN_LOOKUP;
 /** @type {?} */
yfiles.graph.Table.DEFAULT_ROW_LOOKUP;
 /** @type {?<?>} */
yfiles.graph.Table.prototype.rows;
 /** @type {?<?>} */
yfiles.graph.Table.prototype.columns;
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.Table.prototype.insets;
 /** @type {!yfiles.geometry.Point} */
yfiles.graph.Table.prototype.relativeLocation;
 /** @type {?} */
yfiles.graph.Table.prototype.layout;
 /** @type {?} */
yfiles.graph.Table.prototype.rowDefaults;
 /** @type {?} */
yfiles.graph.Table.prototype.columnDefaults;
 /** @type {?} */
yfiles.graph.Table.prototype.rootRow;
 /** @type {?} */
yfiles.graph.Table.prototype.rootColumn;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.Table.$class;

/**
 *
 *
 * @param {?|{owner: ?, text: string, layoutParameter: ?, style: ?, preferredSize: !yfiles.geometry.Size, tag: !Object}} owner_or_options
 * @param {string=} text
 * @param {?=} layoutParameter
 * @param {?=} style
 * @param {!yfiles.geometry.Size=} preferredSize
 * @param {!Object=} tag
 * @return {?}
 */
yfiles.graph.Table.prototype.addLabel = function(owner_or_options, text, layoutParameter, style, preferredSize, tag) {};

/**
 *
 * @return {!Object}
 */
yfiles.graph.Table.prototype.clone = function() {};

/**
 * Called during {\@link yfiles.graph.Table#clone} to create a copy of <code>column</code>
 * <p>
 * If <code>column</code> implements the {\@link yfiles.lang.ICloneable} interface, the <code>column</code> instance is
 * {\@link yfiles.lang.ICloneable#clone}d, otherwise, the original instance is returned unchanged.
 * </p>
 * @protected
 * @param {?} column The column that should be copied during a clone operation.
 * @return {?} A clone of <code>column</code> if possible, otherwise the original reference to <code>column</code>
 */
yfiles.graph.Table.prototype.copyColumn = function(column) {};

/**
 * Called during {\@link yfiles.graph.Table#clone} to create a copy of <code>originalDefaults</code>
 * <p>
 * This implementation returns an unchanged reference to <code>originalDefaults</code>. If you need to create a deep clone of
 * <code>originalDefaults</code>, you'll have to perform the cloning yourself.
 * </p>
 * @protected
 * @param {?} originalDefaults The default settings that should be copied during a clone operation.
 * @return {?} The original reference to <code>originalDefaults</code>
 */
yfiles.graph.Table.prototype.copyDefaults = function(originalDefaults) {};

/**
 * Called during {\@link yfiles.graph.Table#clone} to create a copy of <code>row</code>
 * <p>
 * If <code>row</code> implements the {\@link yfiles.lang.ICloneable} interface, the <code>row</code> instance is
 * {\@link yfiles.lang.ICloneable#clone}d, otherwise, the original instance is returned unchanged.
 * </p>
 * @protected
 * @param {?} row The row that should be copied during a clone operation.
 * @return {?} A clone of <code>row</code> if possible, otherwise the original reference to <code>row</code>
 */
yfiles.graph.Table.prototype.copyRow = function(row) {};

/**
 *
 *
 * @param {?|{owner: ?, width: number, minWidth: number, insets: !yfiles.geometry.Insets, style: ?, tag: !Object, index: number}} owner_or_options
 * @param {number=} width
 * @param {number=} minWidth
 * @param {!yfiles.geometry.Insets=} insets
 * @param {?=} style
 * @param {!Object=} tag
 * @param {number=} index
 * @return {?}
 */
yfiles.graph.Table.prototype.createChildColumn = function(owner_or_options, width, minWidth, insets, style, tag, index) {};

/**
 *
 *
 * @param {?|{owner: ?, height: number, minHeight: number, insets: !yfiles.geometry.Insets, style: ?, tag: !Object, index: number}} owner_or_options
 * @param {number=} height
 * @param {number=} minHeight
 * @param {!yfiles.geometry.Insets=} insets
 * @param {?=} style
 * @param {!Object=} tag
 * @param {number=} index
 * @return {?}
 */
yfiles.graph.Table.prototype.createChildRow = function(owner_or_options, height, minHeight, insets, style, tag, index) {};

/**
 * Callback method that creates the Column defaults.
 * @protected
 * @return {?} A new instance of the {\@link } class which is used for newly created columns.
 */
yfiles.graph.Table.prototype.createColumnDefaults = function() {};

/**
 * Callback method that creates the row defaults.
 * @protected
 * @return {?} A new instance of the {\@link } class that is used for newly created rows.
 */
yfiles.graph.Table.prototype.createRowDefaults = function() {};

/**
 * Installs the undo support for use with all tables that are bound to nodes in <code>graph</code>.
 * <p>
 * This method queries the <code>graph</code> for its undo support dynamically whenever undo support is queried in the table. In
 * contrast to {\@link yfiles.graph.Table#installStaticUndoSupport} the undo support installed with this method will thus always be
 * the one which is the currently available support for the <code>graph</code>.
 * </p>
 * @see yfiles.graph.Table#uninstallDynamicUndoSupport
 * @see yfiles.graph.Table#installStaticUndoSupport
 * @param {?} graph The graph where the nodes exist or will be created/changed and where the undo support should come from.
 * @return {void}
 */
yfiles.graph.Table.installDynamicUndoSupport = function(graph) {};

/**
 * Installs the undo support for use with all tables that are bound to nodes in <code>graph</code>.
 * <p>
 * This methods installs the undo support which manages the <code>graph</code> at the time this method is called. In contrast to {\@link yfiles.graph.Table#installDynamicUndoSupport}
 * the installed undo support will not change when the <code>graph</code>'s undo support changes.
 * </p>
 * <p>
 * This method adds undo support both for existing nodes in <code>graph</code> as well as for newly created or changed nodes.
 * </p>
 * @see yfiles.graph.Table#uninstallStaticUndoSupport
 * @see yfiles.graph.Table#installDynamicUndoSupport
 * @param {?} graph The graph where the nodes exist or will be created/changed.
 * @return {void}
 */
yfiles.graph.Table.installStaticUndoSupport = function(graph) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.graph.Table.prototype.lookup = function(type) {};

/**
 * Called after a label has been added to a stripe.
 * <p>
 * This method raises the {\@link yfiles.graph.Table#addLabelAddedListener LabelAdded} event.
 * </p>
 * @protected
 * @param {?} label The label that has just been added.
 * @return {void}
 */
yfiles.graph.Table.prototype.onLabelAdded = function(label) {};

/**
 * Callback that is invoked after a label has changed.
 * <p>
 * This method raises the {\@link yfiles.graph.Table#addLabelChangedListener LabelChanged} event.
 * </p>
 * @protected
 * @param {?} label The label that has changed.
 * @return {void}
 */
yfiles.graph.Table.prototype.onLabelChanged = function(label) {};

/**
 * Called after a label has been removed from its stripe.
 * <p>
 * This method raises the {\@link yfiles.graph.Table#addLabelRemovedListener LabelRemoved} event.
 * </p>
 * @protected
 * @param {?} owner The old owner of the label.
 * @param {?} label The label that has just been removed.
 * @return {void}
 */
yfiles.graph.Table.prototype.onLabelRemoved = function(owner, label) {};

/**
 * Callback that is invoked after a stripe has changed.
 * <p>
 * This will trigger the {\@link yfiles.graph.Table#addStripeChangedListener StripeChanged} event.
 * </p>
 * @protected
 * @param {?} owner The original owner
 * @param {?} stripe The stripe that has changed.
 * @param {?} oldTable The original table owner, in case the stripe has been moved between different table instances
 * @return {void}
 */
yfiles.graph.Table.prototype.onStripeChanged = function(owner, stripe, oldTable) {};

/**
 * Called after a stripe has been created and added to a table.
 * <p>
 * This method raises the {\@link yfiles.graph.Table#addStripeCreatedListener StripeCreated} event.
 * </p>
 * @protected
 * @param {?} stripe The stripe that has just been created.
 * @return {void}
 */
yfiles.graph.Table.prototype.onStripeCreated = function(stripe) {};

/**
 * Called after a stripe has been removed from its owner.
 * <p>
 * This method raises the {\@link yfiles.graph.Table#addStripeRemovedListener StripeRemoved} event.
 * </p>
 * @protected
 * @param {?} owner The old owner of the stripe.
 * @param {?} stripe The stripe that has just been removed.
 * @return {void}
 */
yfiles.graph.Table.prototype.onStripeRemoved = function(owner, stripe) {};

/**
 * Removes the given label from its owner.
 * <p>
 * This will trigger the corresponding event.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} If the label is not associated with this table instance.
 *
 * @param {?} label_or_stripe the label to remove
 * @return {void}
 */
yfiles.graph.Table.prototype.remove = function(label_or_stripe) {};

/**
 * Sets the label model parameter for the given label.
 * @throws {Stubs.Exceptions.ArgumentError} If the parameter cannot be used for this label or if the label is not associated with this table instance.
 * @param {?} label The label.
 * @param {?} layoutParameter The new parameter.
 * @return {void}
 */
yfiles.graph.Table.prototype.setLabelLayoutParameter = function(label, layoutParameter) {};

/**
 * Sets the preferred size of the label.
 * @throws {Stubs.Exceptions.ArgumentError} If the label is not associated with this table instance.
 * @see yfiles.graph.ILabel#preferredSize
 * @param {?} label The label.
 * @param {!yfiles.geometry.Size} preferredSize The new preferred size.
 * @return {void}
 */
yfiles.graph.Table.prototype.setLabelPreferredSize = function(label, preferredSize) {};

/**
 * Sets the label text of the given label.
 * @throws {Stubs.Exceptions.ArgumentError} If the label is not associated with this table instance.
 * @see yfiles.graph.ILabel#text
 * @param {?} label the label to modify
 * @param {string} text the new text of the label
 * @return {void}
 */
yfiles.graph.Table.prototype.setLabelText = function(label, text) {};

/**
 *
 * @param {?} stripe
 * @param {number} minimumSize
 * @return {void}
 */
yfiles.graph.Table.prototype.setMinimumSize = function(stripe, minimumSize) {};

/**
 *
 *
 * @param {?} owner
 * @param {?} column_or_row
 * @param {number=} index
 * @return {void}
 */
yfiles.graph.Table.prototype.setParent = function(owner, column_or_row, index) {};

/**
 *
 * @param {?} stripe
 * @param {number} size
 * @return {void}
 */
yfiles.graph.Table.prototype.setSize = function(stripe, size) {};

/**
 *
 * @param {?} stripe
 * @param {!yfiles.geometry.Insets} insets
 * @return {void}
 */
yfiles.graph.Table.prototype.setStripeInsets = function(stripe, insets) {};

/**
 * Assigns the given style instance by reference to the label.
 * <p>
 * Style instances can be shared.
 * </p>
 * @see yfiles.graph.ILabel#style
 *
 * @param {?} label_or_stripe The label that will be assigned the new style
 * @param {?} style The style instance that will be assigned to the label.
 * @return {void}
 */
yfiles.graph.Table.prototype.setStyle = function(label_or_stripe, style) {};

/**
 * Uninstalls the undo support that has previously been installed with {\@link yfiles.graph.Table#installDynamicUndoSupport}
 * @param {?} graph The graph where the tables are installed for which the undo support should be cleared.
 * @return {void}
 */
yfiles.graph.Table.uninstallDynamicUndoSupport = function(graph) {};

/**
 * Uninstalls the undo support that has previously been installed with {\@link yfiles.graph.Table#installStaticUndoSupport}
 * @param {?} graph The graph where the tables are installed for which the undo support should be cleared.
 * @return {void}
 */
yfiles.graph.Table.uninstallStaticUndoSupport = function(graph) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.addStripeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.removeStripeCreatedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.addStripeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.removeStripeRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.addStripeChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.StripeEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.removeStripeChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.addLabelAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.removeLabelAddedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.addLabelRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.graph.LabelEventArgs): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.removeLabelRemovedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.addLabelChangedListener = function(listener) {};

/**
 *
 * @param {function(!Object, !yfiles.collections.ItemEventArgs<?>): void} listener
 * @return {void}
 */
yfiles.graph.Table.prototype.removeLabelChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.graph.IStripeDefaults = function() {};
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.IStripeDefaults.prototype.insets;
 /** @type {number} */
yfiles.graph.IStripeDefaults.prototype.size;
 /** @type {number} */
yfiles.graph.IStripeDefaults.prototype.minimumSize;
 /** @type {?} */
yfiles.graph.IStripeDefaults.prototype.labels;
 /** @type {?} */
yfiles.graph.IStripeDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.IStripeDefaults.prototype.shareStyleInstance;

/**
 * Factory method that returns a style instance for use with newly created stripes.
 * <p>
 * Most implementations will yield either, a {\@link yfiles.lang.ICloneable#clone clone} of or the {\@link yfiles.graph.IStripeDefaults#style} property, if {\@link yfiles.graph.IStripeDefaults#shareStyleInstance} is enabled, but they might use more complicated
 * logic, too.
 * </p>
 * @abstract
 * @return {?} The style to use, which for most implementations is either a {\@link #clone clone} of or the {\@link #style} property, if {\@link #shareStyleInstance} is enabled.
 */
yfiles.graph.IStripeDefaults.prototype.getStyleInstance = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.graph.IStripeDefaults;
/**
 * @record
 * @struct
 */
yfiles.graph.StripeDefaults = function() {};
 /** @type {!yfiles.geometry.Insets} */
yfiles.graph.StripeDefaults.prototype.insets;
 /** @type {number} */
yfiles.graph.StripeDefaults.prototype.size;
 /** @type {number} */
yfiles.graph.StripeDefaults.prototype.minimumSize;
 /** @type {?} */
yfiles.graph.StripeDefaults.prototype.labels;
 /** @type {?} */
yfiles.graph.StripeDefaults.prototype.style;
 /** @type {boolean} */
yfiles.graph.StripeDefaults.prototype.shareStyleInstance;
 /** @type {!yfiles.lang.Class} */
yfiles.graph.StripeDefaults.$class;

/**
 *
 * @return {?}
 */
yfiles.graph.StripeDefaults.prototype.getStyleInstance = function() {};
/** @const */
yfiles.geometry = {};

/** @const */
yfiles.geometry.PathType = {};
/** @const {number} */
yfiles.geometry.PathType.MOVE_TO;
/** @const {number} */
yfiles.geometry.PathType.LINE_TO;
/** @const {number} */
yfiles.geometry.PathType.QUAD_TO;
/** @const {number} */
yfiles.geometry.PathType.CUBIC_TO;
/** @const {number} */
yfiles.geometry.PathType.CLOSE;
/**
 * @record
 * @struct
 */
yfiles.geometry.GeneralPathCursor = function() {};
 /** @type {number} */
yfiles.geometry.GeneralPathCursor.prototype.index;
 /** @type {yfiles.geometry.PathType} */
yfiles.geometry.GeneralPathCursor.prototype.pathType;
 /** @type {number} */
yfiles.geometry.GeneralPathCursor.prototype.currentEndPointX;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.GeneralPathCursor.prototype.currentEndPoint;
 /** @type {number} */
yfiles.geometry.GeneralPathCursor.prototype.currentEndPointY;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.GeneralPathCursor.$class;

/**
 * Places the coordinates for the current type into the given array.
 * <p>
 * The array needs to have a length of at least 6, since {\@link yfiles.geometry.PathType#CUBIC_TO} needs six coordinates. If the
 * path has been flattened a length of two suffices.
 * </p>
 * @see yfiles.geometry.GeneralPathCursor#getCurrentEndPoint
 * @param {!Array<number>} coordinates
 * @return {yfiles.geometry.PathType} The current type of the path element.
 */
yfiles.geometry.GeneralPathCursor.prototype.getCurrent = function(coordinates) {};

/**
 * Places the current end coordinates of the last path element into the array.
 * @param {!Array<number>} coordinates An array with length at least 2.
 * @return {yfiles.geometry.PathType} The type of the current element.
 */
yfiles.geometry.GeneralPathCursor.prototype.getCurrentEndPoint = function(coordinates) {};

/**
 * Advances the cursor to the next position if possible.
 * @return {boolean} Whether the cursor has been moved successfully. <code>false</code> if the cursor has been moved beyond the end of the path.
 */
yfiles.geometry.GeneralPathCursor.prototype.moveNext = function() {};

/**
 * Moves the cursor to the previous position in the path.
 * @return {boolean} Whether the move was successful.
 */
yfiles.geometry.GeneralPathCursor.prototype.movePrevious = function() {};

/**
 * Reset the cursor to point to the beginning of the path.
 * @return {void}
 */
yfiles.geometry.GeneralPathCursor.prototype.reset = function() {};

/**
 * Resets the cursor to point to the last element in the path.
 * @return {boolean} Whether the cursor has been moved successfully.
 */
yfiles.geometry.GeneralPathCursor.prototype.toLast = function() {};
/**
 * @record
 * @struct
 */
yfiles.geometry.GeneralPath = function() {};
 /** @type {number} */
yfiles.geometry.GeneralPath.prototype.lastX;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.GeneralPath.prototype.lastCoordinate;
 /** @type {number} */
yfiles.geometry.GeneralPath.prototype.lastY;
 /** @type {boolean} */
yfiles.geometry.GeneralPath.prototype.isEmpty;
 /** @type {boolean} */
yfiles.geometry.GeneralPath.prototype.isVisible;
 /** @type {number} */
yfiles.geometry.GeneralPath.prototype.size;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.GeneralPath.$class;

/**
 * Appends parts of the contents of the given path to this path.
 * <p>
 * If <code>connect</code> is <code>true</code>, an initial {\@link yfiles.geometry.PathType#MOVE_TO} in <code>other</code> will be transformed into a
 * {\@link yfiles.geometry.PathType#LINE_TO}.
 * </p>
 * Appends the contents of the given path to this path.
 * <p>
 * If <code>connect</code> is <code>true</code>, an initial {\@link yfiles.geometry.PathType#MOVE_TO} in <code>other</code> will be transformed into a
 * {\@link yfiles.geometry.PathType#LINE_TO}.
 * </p>
 * @param {!yfiles.geometry.GeneralPath} other The path to append to this path.
 * @param {number|boolean} beginIndex_or_connect The first element to be copied from <code>other</code>, inclusively. / Whether to connect the path to the end of this path.
 * @param {number=} endIndex The last element to be copied from <code>other</code>, exclusively.
 * @param {boolean=} connect Whether to connect the path to the end of this path.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.append = function(other, beginIndex_or_connect, endIndex, connect) {};

/**
 * Appends an ellipse using the given bounding box to this instance.
 * @param {?} bounds The bounds of the ellipse.
 * @param {boolean} connect Whether to initially {\@link #lineTo} the ellipses lowest point.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.appendEllipse = function(bounds, connect) {};

/**
 * Appends an {\@link yfiles.geometry.IOrientedRectangle} to this path instance.
 * @param {?} rectangle The {\@link } to get the coordinates from.
 * @param {boolean} connect Whether to use a {\@link #lineTo} to the anchor corner.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.appendOrientedRectangle = function(rectangle, connect) {};

/**
 * Appends a rectangle to this path instance.
 * @param {?} rectangle The rectangle to get the coordinates from.
 * @param {boolean} connect Whether to use a {\@link #lineTo} to the upper left corner.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.appendRectangle = function(rectangle, connect) {};

/**
 * Checks whether the point lies inside the area that is described by this path instance.
 * <p>
 * Note that this will only work as expected for closed paths. The epsilon is used for internally flattening Bézier
 * curves.
 * </p>
 * @param {?} point The coordinates of the point to test.
 * @param {number=} eps
 * @return {boolean} Whether the point lies within the area described by this path.
 */
yfiles.geometry.GeneralPath.prototype.areaContains = function(point, eps) {};

/**
 * Resets this path to be an empty path.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.clear = function() {};

/**
 * Creates a clone of this instance, copying the path information to the new instance.
 * @return {!Object} An exact clone of this instance.
 */
yfiles.geometry.GeneralPath.prototype.clone = function() {};

/**
 * Appends a {\@link yfiles.geometry.PathType#CLOSE} operation to the path elements, creating a line to the last {\@link yfiles.geometry.PathType#MOVE_TO}
 * position.
 * <p>
 * This draws a line from the current end point to the last {\@link yfiles.geometry.GeneralPath#moveTo} position, closing the
 * current sub path.
 * </p>
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.close = function() {};

/**
 * Compresses the internal data structures so that the amount of memory used by this instance is minimal with respect to
 * the information stored in it.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.compress = function() {};

/**
 * Creates a cursor for iterating over the elements of this path.
 * <p>
 * The cursor is fail-fast, i.e. if the path's structure is modified after the construction of the cursor any cursor
 * operation will fail.
 * </p>
 * @return {!yfiles.geometry.GeneralPathCursor} A cursor to iterate over this path.
 */
yfiles.geometry.GeneralPath.prototype.createCursor = function() {};

/**
 * Creates a new path based on this one where corners are smoothed with a quadratic Bézier arc starting at <code>smoothingLength</code>
 * away from the corner.
 * @param {number} smoothingLength Distance from the corner where the arc begins.
 * @return {!yfiles.geometry.GeneralPath} A new path, with its corners smoothed.
 */
yfiles.geometry.GeneralPath.prototype.createSmoothedPath = function(smoothingLength) {};

/**
 * Creates an SVG <code>path</code> element using the provided parameters.
 * @param {!yfiles.geometry.Matrix=} transform
 * @return {!SVGPathElement} A {\@link  path} that displays this instance using the provided attributes.
 */
yfiles.geometry.GeneralPath.prototype.createSvgPath = function(transform) {};

/**
 * Creates the data for a SVG <code>path</code> element that corresponds to this instance with the provided transform.
 * @param {!yfiles.geometry.Matrix=} transform
 * @return {string} The path data for an SVG <code>path</code> element that corresponds to this instance with the provided transform.
 */
yfiles.geometry.GeneralPath.prototype.createSvgPathData = function(transform) {};

/**
 * Creates a new {\@link yfiles.geometry.GeneralPath} that is a copy of this path with all geometry transformed using the supplied
 * matrix.
 * @param {!yfiles.geometry.Matrix} transform The matrix to multiply the geometry with.
 * @return {!yfiles.geometry.GeneralPath} A new path.
 */
yfiles.geometry.GeneralPath.prototype.createTransformedPath = function(transform) {};

/**
 * Crops the path after the position indicated by the cursor.
 * <p>
 * This will remove all path operations that follow the position indicated by the cursor.
 * </p>
 * @param {!yfiles.geometry.GeneralPathCursor} cursor The cursor that depicts a position in this path.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.cropAfter = function(cursor) {};

/**
 * Crops the path before the position indicated by the cursor.
 * <p>
 * This will remove all path operations that precede the position indicated by the cursor.
 * </p>
 * @param {!yfiles.geometry.GeneralPathCursor} cursor The cursor that depicts a position in this path.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.cropBefore = function(cursor) {};

/**
 * Appends a {\@link yfiles.geometry.PathType#CUBIC_TO cubic Bézier curve} to the path elements.
 * <p>
 * This draws a cubic Bézier curve from the current end point to the given position using the two given control points.
 * </p>
 * Appends a {\@link yfiles.geometry.PathType#CUBIC_TO cubic Bézier curve} to the path elements.
 * <p>
 * This draws a cubic Bézier curve from the current end point to the given position using the two given control points.
 * </p>
 * @param {number|?} c1x_or_c1 The x coordinate of the first Bézier control point. / The coordinates of the first Bézier control point.
 * @param {number|?} c1y_or_c2 The y coordinate of the first Bézier control point. / The coordinates of the second Bézier control point.
 * @param {number|?} c2x_or_end The x coordinate of the second Bézier control point. / The coordinates of the curve's end point.
 * @param {number=} c2y The y coordinate of the second Bézier control point.
 * @param {number=} x The x coordinate of the curve's end point.
 * @param {number=} y The y coordinate of the curve's end point.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.cubicTo = function(c1x_or_c1, c1y_or_c2, c2x_or_end, c2y, x, y) {};

/**
 * Finds an intersection point between a line and this {\@link yfiles.geometry.GeneralPath}.
 * <p>
 * The value returned will be the smallest positive value smaller than 1 such that the point depicted by <code>start + result * (end - start)</code>
 * is an intersection point between the line and the path.
 * </p>
 * @param {!yfiles.geometry.Point} start The coordinates of the first point of the line.
 * @param {!yfiles.geometry.Point} end The coordinates of the second point of the line.
 * @param {number=} eps
 * @return {number} The factor to calculate the intersection point or <code>double.PositiveInfinity</code>.
 */
yfiles.geometry.GeneralPath.prototype.findLineIntersection = function(start, end, eps) {};

/**
 * Finds the first intersection of a ray with this {\@link yfiles.geometry.GeneralPath} using a given epsilon for flattening Bézier
 * curves contained in the path.
 * <p>
 * The ray is treated like an infinite line starting at the given anchor point and continuing in the direction of rayX,
 * rayY. The ray vector does not need to be normalized. The value returned will be the smallest positive value such that
 * the point depicted by <code>(anchorX + result * rayX, anchorY + result * rayY)</code> is an intersection point between the ray and
 * the path.
 * </p>
 * @param {!yfiles.geometry.Point} anchor The coordinates of the anchor point of the ray.
 * @param {!yfiles.geometry.Point} direction The coordinates of the direction vector of the ray.
 * @param {number=} eps
 * @return {number} The factor to calculate the intersection point or <code>double.PositiveInfinity</code>.
 */
yfiles.geometry.GeneralPath.prototype.findRayIntersection = function(anchor, direction, eps) {};

/**
 * Creates a new path from this instance flattening all Bézier curves using the given epsilon.
 * <p>
 * This will create a path that consists of {\@link yfiles.geometry.PathType#MOVE_TO}, {\@link yfiles.geometry.PathType#LINE_TO}, and {\@link yfiles.geometry.PathType#CLOSE}
 * operations only.
 * </p>
 * @param {number} eps The maximum value the flattened path may diverge from the original path for the Bézier curve line interpolations.
 * @return {!yfiles.geometry.GeneralPath} A new path that does not contain Bézier curves.
 */
yfiles.geometry.GeneralPath.prototype.flatten = function(eps) {};

/**
 * Gets the bounds of a flattened version the path.
 * Calculates the bounds of this path and returns it.
 * <p>
 * This will not yield tight bounds if the path contains Bézier curves. The bounds are calculated using the union of all
 * points and control points contained in this path.
 * </p>
 * @see yfiles.geometry.GeneralPath#getBounds
 * @param {number=} eps The epsilon to use for the flattening operation.
 * @return {!yfiles.geometry.Rect} The bounds of the flattened path. / A rectangle that describes the geometric bounds of this path.
 */
yfiles.geometry.GeneralPath.prototype.getBounds = function(eps) {};

/**
 * Returns the geometric length of this path.
 * <p>
 * Note that Bézier curves are still treated as line segments.
 * </p>
 * @return {number} The length of this path.
 */
yfiles.geometry.GeneralPath.prototype.getLength = function() {};

/**
 * Gets a point on this path instance at the given ratio.
 * <p>
 * Note that this implementation still treats Bézier curves as linear segments.
 * </p>
 * @param {number} ratio A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of this path.
 * @return {!yfiles.geometry.Point} The coordinates of the point.
 */
yfiles.geometry.GeneralPath.prototype.getPoint = function(ratio) {};

/**
 * Gets the number of segments in this path, that is the number of {\@link yfiles.geometry.PathType#LINE_TO} and {\@link yfiles.geometry.PathType#CLOSE}
 * operations.
 * @return {number} The number of segments.
 */
yfiles.geometry.GeneralPath.prototype.getSegmentCount = function() {};

/**
 * Gets the tangent on this path instance at the segment and segment ratio.
 * <p>
 * Note that this implementation still treats Bézier curves as linear segments. Also note that the tangent vector may not
 * be normalized.
 * </p>
 * Gets the tangent on this path instance at the given ratio.
 * <p>
 * Note that this implementation still treats Bézier curves as linear segments.
 * </p>
 * @param {number} segmentIndex_or_ratio The segment index to determine a point at. / A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of this path.
 * @param {number=} ratio A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of the segment at segmentIndex
 * for this path.
 * @return {!yfiles.geometry.Tangent} The tangent, if any exists. The tangent vector may not be normalized.
 */
yfiles.geometry.GeneralPath.prototype.getTangent = function(segmentIndex_or_ratio, ratio) {};

/**
 * Determines whether <code>this</code> has the same values like <code>path</code>.
 * @param {!yfiles.geometry.GeneralPath} path The object to compare <code>this</code> to. Must be of the same type.
 * @return {boolean} <code>true</code> if <code>this</code> has the same values like the other object.
 */
yfiles.geometry.GeneralPath.prototype.hasSameValue = function(path) {};

/**
 * Checks whether this path intersects the given rectangle.
 * <p>
 * This will yield false if the rectangle is fully contained within the area of the path.
 * </p>
 * @param {!yfiles.geometry.Rect} rectangle The rectangle to test.
 * @param {number} eps The epsilon to use for fuzzy testing.
 * @return {boolean} Whether the path described by this instance intersects the rectangle.
 */
yfiles.geometry.GeneralPath.prototype.intersects = function(rectangle, eps) {};

/**
 * Appends a {\@link yfiles.geometry.PathType#LINE_TO} operation to the path elements.
 * <p>
 * This draws a line from the current end point to the given position.
 * </p>
 * Appends a {\@link yfiles.geometry.PathType#LINE_TO} operation to the path elements.
 * <p>
 * This draws a line from the current end point to the given position.
 * </p>
 * @param {number|?} x_or_point The x coordinate of the line's end point. / The coordinates of the line's end point.
 * @param {number=} y The y coordinate of the line's end point.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.lineTo = function(x_or_point, y) {};

/**
 * Performs a quick test to decide whether this path might intersect the clipping rectangle, provided the path would be
 * rendered using stroke of the given width.
 * <p>
 * This method will return false if the clip is entirely inside the area of this path.
 * </p>
 * @param {!yfiles.geometry.Rect} clip The clip to check for intersection.
 * @param {number} width The width of the stroke.
 * @return {boolean} <code>false</code> if it is guaranteed that this instance would not intersect the given clip.
 */
yfiles.geometry.GeneralPath.prototype.mayIntersectClip = function(clip, width) {};

/**
 * Appends a {\@link yfiles.geometry.PathType#MOVE_TO} operation to the path elements.
 * <p>
 * This moves the pen to a new position without drawing a line.
 * </p>
 * Appends a {\@link yfiles.geometry.PathType#MOVE_TO} operation to the path elements.
 * <p>
 * This moves the pen to a new position without drawing a line.
 * </p>
 * @param {number|?} x_or_point The next x coordinate. / The next coordinate.
 * @param {number=} y The next y coordinate.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.moveTo = function(x_or_point, y) {};

/**
 * Tests whether the line of the path is hit at the given point using an epsilon for fuzzy hit testing.
 * @param {?} point The p coordinates of the point to test.
 * @param {number=} eps
 * @return {boolean} Whether the point hits the path.
 */
yfiles.geometry.GeneralPath.prototype.pathContains = function(point, eps) {};

/**
 * Adds the contents of the given path to the beginning of this path.
 * <p>
 * If <code>connect</code> is <code>true</code>, the initial {\@link yfiles.geometry.PathType#MOVE_TO} in <code>this</code> will be transformed into a
 * {\@link yfiles.geometry.PathType#LINE_TO}.
 * </p>
 * @param {!yfiles.geometry.GeneralPath} other The path to append to this path.
 * @param {boolean} connect Whether to connect the path to the end of this path.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.prepend = function(other, connect) {};

/**
 * Appends a {\@link yfiles.geometry.PathType#QUAD_TO quadratic Bézier curve} to the path elements.
 * <p>
 * This draws a quadratic Bézier curve from the current end point to the given position using the given control point.
 * </p>
 * Appends a {\@link yfiles.geometry.PathType#QUAD_TO quadratic Bézier curve} to the path elements.
 * <p>
 * This draws a quadratic Bézier curve from the current end point to the given position using the given control point.
 * </p>
 * @param {number|?} cx_or_center The x coordinate of the Bézier control point. / The coordinates of the Bézier control point.
 * @param {number|?} cy_or_point The y coordinate of the Bézier control point. / The coordinates of the curve's end point.
 * @param {number=} x The x coordinate of the curve's end point.
 * @param {number=} y The y coordinate of the curve's end point.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.quadTo = function(cx_or_center, cy_or_point, x, y) {};

/**
 * Transforms this {\@link yfiles.geometry.GeneralPath} in place using the given transform.
 * @param {!yfiles.geometry.Matrix} transform The matrix to multiply the geometry with.
 * @return {void}
 */
yfiles.geometry.GeneralPath.prototype.transform = function(transform) {};
/**
 * @record
 * @struct
 */
yfiles.geometry.Size = function() {};
 /** @type {!yfiles.geometry.Size} */
yfiles.geometry.Size.EMPTY;
 /** @type {!yfiles.geometry.Size} */
yfiles.geometry.Size.ZERO;
 /** @type {!yfiles.geometry.Size} */
yfiles.geometry.Size.INFINITE;
 /** @type {number} */
yfiles.geometry.Size.prototype.width;
 /** @type {number} */
yfiles.geometry.Size.prototype.height;
 /** @type {number} */
yfiles.geometry.Size.prototype.area;
 /** @type {boolean} */
yfiles.geometry.Size.prototype.isEmpty;
 /** @type {boolean} */
yfiles.geometry.Size.prototype.isFinite;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.Size.$class;

/**
 *
 * @return {!yfiles.geometry.Size}
 */
yfiles.geometry.Size.prototype.clone = function() {};

/**
 * Performs an implicit conversion from {\@link yfiles.geometry.MutableSize} to {\@link yfiles.geometry.Size}.
 * @param {!yfiles.geometry.MutableSize} size The size.
 * @return {!yfiles.geometry.Size} The result of the conversion.
 */
yfiles.geometry.Size.convertFrom = function(size) {};

/**
 * Performs an explicit conversion from {\@link yfiles.geometry.Size} to {\@link yfiles.geometry.MutableSize}.
 * @param {!yfiles.geometry.Size} size The size.
 * @return {!yfiles.geometry.MutableSize} The result of the conversion.
 */
yfiles.geometry.Size.convertToMutableSize = function(size) {};

/**
 * Returns a size whose {\@link yfiles.geometry.Size#width} and {\@link yfiles.geometry.Size#height} is the {\@link Math#max} of the respecting properties of the two parameters.
 * @param {!yfiles.geometry.Size} size1 The first size.
 * @param {!yfiles.geometry.Size} size2 The second size.
 * @return {!yfiles.geometry.Size} A size whose {\@link #width} and {\@link #height} is the {\@link #max} of the respecting properties of the two parameters.
 */
yfiles.geometry.Size.max = function(size1, size2) {};

/**
 * Returns a size whose {\@link yfiles.geometry.Size#width} and {\@link yfiles.geometry.Size#height} is the {\@link Math#min} of the respecting properties of the two parameters.
 * @param {!yfiles.geometry.Size} size1 The first size.
 * @param {!yfiles.geometry.Size} size2 The second size.
 * @return {!yfiles.geometry.Size} A size whose {\@link #width} and {\@link #height} is the {\@link #min} of the respecting properties of the two parameters.
 */
yfiles.geometry.Size.min = function(size1, size2) {};

/**
 * Multiplies the {\@link yfiles.geometry.Size#width} and {\@link yfiles.geometry.Size#height} by the given factor and returns the result.
 * @param {number} factor The factor to multiply the width and height by.
 * @return {!yfiles.geometry.Size} A new size that has the width and height multiplied by the factor.
 */
yfiles.geometry.Size.prototype.multiply = function(factor) {};

/**
 * Converts this instance to an {\@link yfiles.geometry.MutableSize} instance
 * @return {!yfiles.geometry.MutableSize} The {\@link } instance, whose attributes have been initialized with the values of this instance.
 */
yfiles.geometry.Size.prototype.toMutableSize = function() {};

/**
 * Creates a {\@link yfiles.algorithms.YDimension} from a given {\@link yfiles.geometry.Size}.
 * @return {!yfiles.algorithms.YDimension} The {\@link }.
 */
yfiles.geometry.Size.prototype.toYDimension = function() {};
/**
 * @record
 * @struct
 */
yfiles.geometry.Point = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.Point.ORIGIN;
 /** @type {number} */
yfiles.geometry.Point.prototype.x;
 /** @type {number} */
yfiles.geometry.Point.prototype.y;
 /** @type {number} */
yfiles.geometry.Point.prototype.vectorLength;
 /** @type {number} */
yfiles.geometry.Point.prototype.squaredVectorLength;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.Point.prototype.normalized;
 /** @type {boolean} */
yfiles.geometry.Point.prototype.isVerticalVector;
 /** @type {boolean} */
yfiles.geometry.Point.prototype.isHorizontalVector;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.Point.$class;

/**
 * Adds the given vector to this instance.
 * <p>
 * This operator is applied componentwise to {\@link yfiles.geometry.Point#x} and {\@link yfiles.geometry.Point#y}.
 * </p>
 * @param {!yfiles.geometry.Point} otherPoint The second point.
 * @return {!yfiles.geometry.Point} The result of the vector addition.
 */
yfiles.geometry.Point.prototype.add = function(otherPoint) {};

/**
 *
 * @return {!yfiles.geometry.Point}
 */
yfiles.geometry.Point.prototype.clone = function() {};

/**
 * Performs an explicit conversion from {\@link yfiles.geometry.MutablePoint} to {\@link yfiles.geometry.Point}.
 * @param {!yfiles.geometry.MutablePoint} p The point to convert.
 * @return {!yfiles.geometry.Point} The result of the conversion.
 */
yfiles.geometry.Point.convertFrom = function(p) {};

/**
 * Performs an implicit conversion from {\@link yfiles.geometry.Point} to {\@link yfiles.geometry.MutablePoint}.
 * @param {!yfiles.geometry.Point} point The point to convert.
 * @return {!yfiles.geometry.MutablePoint}
 */
yfiles.geometry.Point.convertToMutablePoint = function(point) {};

/**
 * Determines the distance between this point and a line segment.
 * @param {!yfiles.geometry.Point} start The coordinates of the first point of the line.
 * @param {!yfiles.geometry.Point} end The coordinates of the second point of the line.
 * @return {number} The distance between this point and the closest point on the line segment.
 */
yfiles.geometry.Point.prototype.distanceToSegment = function(start, end) {};

/**
 * Determines whether the two given points have the same coordinates with respect to a certain given <code>eps</code>.
 * @param {!yfiles.geometry.Point} other The other point to check for equality against this point.
 * @param {number} eps The epsilon value.
 * @return {boolean} Whether both coordinates are equal with respect for the given epsilon.
 */
yfiles.geometry.Point.prototype.equalsEps = function(other, eps) {};

/**
 * Create a constrained copy of this instance that lies within the given non-empty <code>rectangle</code>.
 * <p>
 * If the given rectangle is {\@link yfiles.geometry.Rect#EMPTY}, this implementation will silently return.
 * </p>
 * @param {!yfiles.geometry.Rect} rectangle The rectangle to constrain this instance by.
 * @return {!yfiles.geometry.Point} A constrained copy of this instance.
 */
yfiles.geometry.Point.prototype.getConstrained = function(rectangle) {};

/**
 * Calculates the projection of this point onto a line.
 * @param {!yfiles.geometry.Point} anchor An anchor for the infinite line.
 * @param {!yfiles.geometry.Point} direction A direction vector for the infinite line.
 * @return {!yfiles.geometry.Point} The point on the line that is closest to this point.
 */
yfiles.geometry.Point.prototype.getProjectionOnLine = function(anchor, direction) {};

/**
 * Calculates the projection of this point onto a ray.
 * <p>
 * If the perpendicular projection onto the line is outside of the ray ("behind" the <code>rayStart</code>) the <code>rayStart</code> is returned
 * instead.
 * </p>
 * @param {!yfiles.geometry.Point} rayStart The start of the segment.
 * @param {!yfiles.geometry.Point} direction The direction of the ray.
 * @return {!yfiles.geometry.Point} The point on the ray that is closest to this point.
 */
yfiles.geometry.Point.prototype.getProjectionOnRay = function(rayStart, direction) {};

/**
 * Calculates the projection of this point onto a segment.
 * <p>
 * If the perpendicular projection onto the line is outside of the segment the nearest segment endpoint is returned.
 * </p>
 * @param {!yfiles.geometry.Point} start The start of the segment.
 * @param {!yfiles.geometry.Point} end The end of the segment.
 * @return {!yfiles.geometry.Point} The point on the segment that is closest to this point.
 */
yfiles.geometry.Point.prototype.getProjectionOnSegment = function(start, end) {};

/**
 * Determines if the point lies close to this point given an epsilon.
 * @param {!yfiles.geometry.Point} other The coordinates of the other point.
 * @param {number} hitTestRadius The hit test epsilon.
 * @return {boolean} Whether the distance between the two points is smaller than <code>hitTestRadius</code>
 */
yfiles.geometry.Point.prototype.hits = function(other, hitTestRadius) {};

/**
 * Determines whether this point hits the line segment with respect to a given <code>radius</code>.
 * @param {!yfiles.geometry.Point} start The starting point of the line segment to test.
 * @param {!yfiles.geometry.Point} end The ending point of the line segment to test.
 * @param {number} radius The hit test radius.
 * @return {boolean} Whether this point hits the given line segment within the radius.
 */
yfiles.geometry.Point.prototype.hitsLineSegment = function(start, end, radius) {};

/**
 * Determines whether a polygonal line is hit by this point given an epsilon.
 * @param {?<?>} points The list of points that is treated as a polygon
 * @param {number} radius A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than
 * or equal to that value, it will be considered a hit.
 * @return {boolean} Whether the point hits the polygon.
 */
yfiles.geometry.Point.prototype.hitsPolyline = function(points, radius) {};

/**
 * Applies the given matrix to this instance by calling {\@link yfiles.geometry.Matrix#transform} and returns the result.
 * Multiplies the given factor with this instance using scalar multiplication and returns the result.
 * <p>
 * This factor is applied componentwise to {\@link yfiles.geometry.Point#x} and {\@link yfiles.geometry.Point#y}.
 * </p>
 * @param {!yfiles.geometry.Matrix|number} matrix_or_factor The matrix to use for the transformation. / The factor to scale the components by.
 * @return {!yfiles.geometry.Point} The result of the transformation. / The result of the scalar multiplication.
 */
yfiles.geometry.Point.prototype.multiply = function(matrix_or_factor) {};

/**
 * Calculates the scalar product of this and the given vector.
 * @param {!yfiles.geometry.Point} other The other vector.
 * @return {number} The scalar product (<code>X*other.X + Y*other.Y</code>)
 */
yfiles.geometry.Point.prototype.scalarProduct = function(other) {};

/**
 * Calculates the scalar product of the two given points.
 * @param {!yfiles.geometry.Point} point1 The first point.
 * @param {!yfiles.geometry.Point} point2 The second point.
 * @return {number} The scalar product of the two points.
 */
yfiles.geometry.Point.scalarProduct = function(point1, point2) {};

/**
 * Subtracts the given vector from this instance.
 * <p>
 * This operator is applied componentwise to {\@link yfiles.geometry.Point#x} and {\@link yfiles.geometry.Point#y}.
 * </p>
 * @param {!yfiles.geometry.Point} otherPoint The second point.
 * @return {!yfiles.geometry.Point} The result of the vector subtraction.
 */
yfiles.geometry.Point.prototype.subtract = function(otherPoint) {};

/**
 * Creates an {\@link yfiles.geometry.IMutablePoint} that has the same coordinates as this instance.
 * @return {?} A {\@link } with the same coordinates.
 */
yfiles.geometry.Point.prototype.toMutablePoint = function() {};

/**
 * Creates a {\@link yfiles.algorithms.Point2D} from a given {\@link yfiles.geometry.Point}.
 * @return {!yfiles.algorithms.Point2D} The {\@link }.
 */
yfiles.geometry.Point.prototype.toPoint2D = function() {};

/**
 * Creates a {\@link yfiles.algorithms.YPoint} from a given {\@link yfiles.geometry.Point}.
 * @return {!yfiles.algorithms.YPoint} The {\@link }.
 */
yfiles.geometry.Point.prototype.toYPoint = function() {};

/**
 * Creates a {\@link yfiles.algorithms.YVector} from a given {\@link yfiles.geometry.Point}.
 * @return {!yfiles.algorithms.YVector} The {\@link }.
 */
yfiles.geometry.Point.prototype.toYVector = function() {};
/**
 * @record
 * @struct
 */
yfiles.geometry.Insets = function() {};
 /** @type {!yfiles.geometry.Insets} */
yfiles.geometry.Insets.EMPTY;
 /** @type {number} */
yfiles.geometry.Insets.prototype.top;
 /** @type {number} */
yfiles.geometry.Insets.prototype.left;
 /** @type {number} */
yfiles.geometry.Insets.prototype.bottom;
 /** @type {number} */
yfiles.geometry.Insets.prototype.right;
 /** @type {number} */
yfiles.geometry.Insets.prototype.verticalInsets;
 /** @type {number} */
yfiles.geometry.Insets.prototype.horizontalInsets;
 /** @type {boolean} */
yfiles.geometry.Insets.prototype.isEmpty;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.Insets.$class;

/**
 *
 * @return {!yfiles.geometry.Insets}
 */
yfiles.geometry.Insets.prototype.clone = function() {};

/**
 * Calculates the union of this instance and the given inset which is done by performing {\@link Math#max} on all four inset
 * values.
 * @param {!yfiles.geometry.Insets} insets The insets to max with these insets.
 * @return {!yfiles.geometry.Insets}
 */
yfiles.geometry.Insets.prototype.createUnion = function(insets) {};

/**
 * Creates an enlarged instance by adding the insets of the specified insets to this instance and returning the result.
 * @param {!yfiles.geometry.Insets} insets The insets to add to this instance.
 * @return {!yfiles.geometry.Insets}
 */
yfiles.geometry.Insets.prototype.getEnlarged = function(insets) {};

/**
 * Multiplies each side of the insets by the given factor and returns the result.
 * @param {number} factor The factor to scales up by.
 * @return {!yfiles.geometry.Insets} New insets scaled up by the factor.
 */
yfiles.geometry.Insets.prototype.multiply = function(factor) {};

/**
 * Creates a {\@link yfiles.algorithms.Insets} from a given {\@link yfiles.geometry.Insets}.
 * @return {!yfiles.algorithms.Insets} The {\@link }.
 */
yfiles.geometry.Insets.prototype.toInsets = function() {};
/**
 * @record
 * @struct
 */
yfiles.geometry.Rect = function() {};
 /** @type {!yfiles.geometry.Rect} */
yfiles.geometry.Rect.EMPTY;
 /** @type {!yfiles.geometry.Rect} */
yfiles.geometry.Rect.INFINITE;
 /** @type {number} */
yfiles.geometry.Rect.prototype.x;
 /** @type {number} */
yfiles.geometry.Rect.prototype.y;
 /** @type {number} */
yfiles.geometry.Rect.prototype.width;
 /** @type {number} */
yfiles.geometry.Rect.prototype.height;
 /** @type {number} */
yfiles.geometry.Rect.prototype.centerX;
 /** @type {number} */
yfiles.geometry.Rect.prototype.centerY;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.Rect.prototype.center;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.Rect.prototype.topLeft;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.Rect.prototype.topRight;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.Rect.prototype.bottomLeft;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.Rect.prototype.bottomRight;
 /** @type {!yfiles.geometry.Size} */
yfiles.geometry.Rect.prototype.size;
 /** @type {boolean} */
yfiles.geometry.Rect.prototype.isEmpty;
 /** @type {boolean} */
yfiles.geometry.Rect.prototype.isFinite;
 /** @type {number} */
yfiles.geometry.Rect.prototype.maxX;
 /** @type {number} */
yfiles.geometry.Rect.prototype.maxY;
 /** @type {number} */
yfiles.geometry.Rect.prototype.minX;
 /** @type {number} */
yfiles.geometry.Rect.prototype.minY;
 /** @type {number} */
yfiles.geometry.Rect.prototype.area;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.Rect.$class;

/**
 * Returns the union of this rectangle and the given point.
 * @param {!yfiles.geometry.Point} point The point to include in the rectangle's bounds.
 * @return {!yfiles.geometry.Rect} The enlarged rectangle.
 */
yfiles.geometry.Rect.prototype.add = function(point) {};

/**
 * Returns the union of the given rectangles.
 * <p>
 * {\@link yfiles.geometry.Rect#isEmpty empty} rectangles will not be considered.
 * </p>
 * @param {!yfiles.geometry.Rect} firstRectangle The first rectangle to use for the union.
 * @param {!yfiles.geometry.Rect} secondRectangle The second rectangle to use for the union.
 * @return {!yfiles.geometry.Rect} A rectangle that encompasses the area of the two given rectangles.
 */
yfiles.geometry.Rect.add = function(firstRectangle, secondRectangle) {};

/**
 *
 * @return {!yfiles.geometry.Rect}
 */
yfiles.geometry.Rect.prototype.clone = function() {};

/**
 * Determines whether this rectangle contains the specified point with respect to a given epsilon.
 * @param {!yfiles.geometry.Point} point The point to test.
 * @param {number} eps The positive epsilon distance that the point may lie outside the rectangle and still be considered contained.
 * @return {boolean} <code>true</code> if this rectangle contains the specified point; <code>false</code> otherwise. An {\@link #isEmpty empty} instance never contains any point. A
 * point is considered to be contained in the rectangle when the coordinates are not smaller than {\@link #minX} and {\@link #minY} minus <code>eps</code> nor
 * greater than {\@link #maxX} and {\@link #maxY} plus <code>eps</code>.
 */
yfiles.geometry.Rect.prototype.containsWithEps = function(point, eps) {};

/**
 * Performs an explicit conversion from {\@link yfiles.geometry.MutableRectangle} to {\@link yfiles.geometry.Rect}.
 * @param {!yfiles.geometry.MutableRectangle} rectangle The rectangle to convert.
 * @return {!yfiles.geometry.Rect} The result of the conversion.
 */
yfiles.geometry.Rect.convertFrom = function(rectangle) {};

/**
 * Performs an explicit conversion from {\@link yfiles.geometry.Rect} to {\@link yfiles.geometry.MutableRectangle}.
 * @param {!yfiles.geometry.Rect} rectangle The rectangle to convert.
 * @return {!yfiles.geometry.MutableRectangle} The result of the conversion.
 */
yfiles.geometry.Rect.convertToMutableRectangle = function(rectangle) {};

/**
 * Finds the intersection between a rectangle and a line.
 * @param {!yfiles.geometry.Point} inner The coordinates of a point lying inside the rectangle.
 * @param {!yfiles.geometry.Point} outer The coordinates of a point lying outside the rectangle.
 * @return {!yfiles.geometry.Point} The intersection point if the inner point lies inside the rectangle, the outer point lies outside the rectangle and thus
 * an intersection point has been found, or <code>null</code> otherwise.
 */
yfiles.geometry.Rect.prototype.findLineIntersection = function(inner, outer) {};

/**
 * Creates a new instance given the center of the rectangle and its size.
 * @param {!yfiles.geometry.Point} center The center to use.
 * @param {!yfiles.geometry.Size} size The size to assign.
 * @return {!yfiles.geometry.Rect} An instance whose center is set to <code>center</code> and size is <code>size</code>
 */
yfiles.geometry.Rect.fromCenter = function(center, size) {};

/**
 * Creates an enlarged instance of this rectangle using the same insets for all sides.
 * <p>
 * If this instance {\@link yfiles.geometry.Rect#isEmpty}, the result will be the same.
 * </p>
 * @see yfiles.geometry.Rect#getEnlarged
 * Creates an enlarged instance that is the same as this one but enlarged by the specified insets.
 * <p>
 * If this instance {\@link yfiles.geometry.Rect#isEmpty}, the same will be returned.
 * </p>
 * @param {number|!yfiles.geometry.Insets} size_or_insets The inset to add to each of the sides to grow the new instance. / The insets to use to add to the instance.
 * @return {!yfiles.geometry.Rect}
 */
yfiles.geometry.Rect.prototype.getEnlarged = function(size_or_insets) {};

/**
 * Transforms this instance using the specified matrix and returns the result.
 * @param {!yfiles.geometry.Matrix} transform The transform matrix to apply to this instance.
 * @return {!yfiles.geometry.Rect}
 */
yfiles.geometry.Rect.prototype.getTransformed = function(transform) {};

/**
 * Returns a translated instance of this which has modified {\@link yfiles.geometry.Rect#x} and {\@link yfiles.geometry.Rect#y} by the given amount.
 * @param {!yfiles.geometry.Point} delta The delta to add to {\@link #x} and {\@link #y}.
 * @return {!yfiles.geometry.Rect}
 */
yfiles.geometry.Rect.prototype.getTranslated = function(delta) {};

/**
 * Determines whether the bounds of this instance intersect with the bounds of the specified rectangle.
 * Determines whether this rectangle intersects an {\@link yfiles.geometry.IOrientedRectangle}, given an epsilon.
 * @param {!yfiles.geometry.Rect|?} rectangle The rectangle to check. / The {\@link } to test.
 * @param {number=} eps
 * @return {boolean} Whether both instance are non-empty and have an intersection with positive {\@link #area}. / Whether they have a non-empty intersection.
 */
yfiles.geometry.Rect.prototype.intersects = function(rectangle, eps) {};

/**
 * Determines whether this rectangle intersects a line.
 * @param {!yfiles.geometry.Point} start The first end point of the line.
 * @param {!yfiles.geometry.Point} end The second end point of the line.
 * @return {boolean} Whether the line intersects the rectangle.
 */
yfiles.geometry.Rect.prototype.intersectsLine = function(start, end) {};

/**
 * Determines whether a rectangle intersects a polygonal line.
 * @param {?<?>} points The list of points that is interpreted as a number of line segments.
 * @return {boolean} <code>true</code> if the rectangle intersects at least one segment of the line.
 */
yfiles.geometry.Rect.prototype.intersectsPolyline = function(points) {};

/**
 * Creates an {\@link yfiles.geometry.IMutableRectangle} using the values from this instance.
 * @return {?} An instance that has been initialized from the values of this instance.
 */
yfiles.geometry.Rect.prototype.toMutableRectangle = function() {};

/**
 * Creates a {\@link yfiles.algorithms.Rectangle2D Rectangle2D} from a given {\@link yfiles.geometry.Rect}.
 * @return {!yfiles.algorithms.Rectangle2D} The {\@link  Rectangle2D}.
 */
yfiles.geometry.Rect.prototype.toRectangle2D = function() {};

/**
 * Creates a {\@link yfiles.algorithms.YRectangle} from a given {\@link yfiles.geometry.Rect}.
 * @return {!yfiles.algorithms.YRectangle} The {\@link }.
 */
yfiles.geometry.Rect.prototype.toYRectangle = function() {};
/**
 * @record
 * @struct
 */
yfiles.geometry.Tangent = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.Tangent.prototype.point;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.Tangent.prototype.vector;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.Tangent.$class;
/**
 * @record
 * @struct
 */
yfiles.geometry.GeomUtilities = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.GeomUtilities.$class;

/**
 * Checks whether an ellipse contains the given point.
 * @param {!yfiles.geometry.Rect} bounds The coordinates of the bounds of the ellipse's enclosing rectangle.
 * @param {!yfiles.geometry.Point} point The coordinates of the point to test.
 * @param {number} eps A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than
 * or equal to that value, it will be considered a hit.
 * @return {boolean} Whether the point lies within the ellipse
 */
yfiles.geometry.GeomUtilities.ellipseContains = function(bounds, point, eps) {};

/**
 * Returns the ellipse/line intersection point for the given point pair.
 * <p>
 * This will always return the intersection point that lies in the direction from inner to outer.
 * </p>
 * @param {!yfiles.geometry.Rect} bounds The coordinates of the bounds of the ellipse's enclosing rectangle.
 * @param {!yfiles.geometry.Point} inner The coordinates of a point lying inside the ellipse.
 * @param {!yfiles.geometry.Point} outer The coordinates of a point lying outside the ellipse.
 * @return {!yfiles.geometry.Point} The intersection point iff the inner point lies inside the ellipse and an intersection point has been found, otherwise
 * <code>null</code>.
 */
yfiles.geometry.GeomUtilities.findEllipseLineIntersection = function(bounds, inner, outer) {};

/**
 * Finds the intersection between a line segment and an infinite ray.
 * <p>
 * The ray is described using an anchor point and a ray direction. The direction vector does not need to be normalized. In
 * order to obtain the intersection point do the following:
 * </p>
 * @param {!yfiles.geometry.Point} start The coordinates of the first end point of the line segment.
 * @param {!yfiles.geometry.Point} end The coordinates of the second end point of the line segment.
 * @param {!yfiles.geometry.Point} anchor The coordinates of the starting point of the ray.
 * @param {!yfiles.geometry.Point} rayDirection The direction vector of the ray.
 * @return {number} The distance factor or {\@link #POSITIVE_INFINITY} if the ray does not intersect the line.
 */
yfiles.geometry.GeomUtilities.findRayIntersection = function(start, end, anchor, rayDirection) {};
/**
 * @record
 * @struct
 */
yfiles.geometry.IMutableOrientedRectangle = function() {};
 /** @type {number} */
yfiles.geometry.IMutableOrientedRectangle.prototype.anchorX;
 /** @type {number} */
yfiles.geometry.IMutableOrientedRectangle.prototype.anchorY;

/**
 * Sets the anchor vector of the oriented rectangle to the given value.
 * @param {!yfiles.geometry.Point} location The coordinates of the new anchor location.
 * @return {void}
 */
yfiles.geometry.IMutableOrientedRectangle.prototype.setAnchor = function(location) {};

/**
 * Sets the center of the oriented rectangle to the given value.
 * @param {!yfiles.geometry.Point} center The coordinates of the new center.
 * @return {void}
 */
yfiles.geometry.IMutableOrientedRectangle.prototype.setCenter = function(center) {};

/**
 * Sets the orientation of this oriented rectangle by modifying the up vector components.
 * <p>
 * It is up to the caller to assure that the values describe a vector of length 1.
 * </p>
 * @see yfiles.geometry.IOrientedRectangle#upX
 * @see yfiles.geometry.IOrientedRectangle#upY
 * @abstract
 * @param {number} upx The x component of the normalized up vector.
 * @param {number} upy The y component of the normalized up vector.
 * @return {void}
 */
yfiles.geometry.IMutableOrientedRectangle.prototype.setUpVector = function(upx, upy) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.geometry.IMutableOrientedRectangle;
/**
 * @record
 * @struct
 */
yfiles.geometry.IMutablePoint = function() {};
 /** @type {number} */
yfiles.geometry.IMutablePoint.prototype.x;
 /** @type {number} */
yfiles.geometry.IMutablePoint.prototype.y;

/**
 * Sets the coordinates of the point to the given values.
 * Sets the coordinates of the point to the given values.
 * @param {number|?} x_or_location The new x coordinate / The new location.
 * @param {number=} y The new y coordinate
 * @return {void}
 */
yfiles.geometry.IMutablePoint.prototype.relocate = function(x_or_location, y) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.geometry.IMutablePoint;
/**
 * @record
 * @struct
 */
yfiles.geometry.IMutableRectangle = function() {};

/**
 * Adds a point to a rectangle, possibly enlarging the rectangle.
 * <p>
 * If the rectangle is initially empty, i.e. its width or height is negative, the bounds of the rectangle will be set to
 * (p.x, p.y, 0, 0)
 * </p>
 * Adds a rectangle to another one.
 * <p>
 * The result is placed into the first rectangle, which is returned. If either of the two rectangles is empty, i.e. it's
 * width or height is negative, the result will be the other rectangle.
 * </p>
 * @param {?} point_or_rectangle2 The coordinate to include in the bounds. / The rectangle to be added.
 * @return {void}
 */
yfiles.geometry.IMutableRectangle.prototype.add = function(point_or_rectangle2) {};

/**
 * Applies a new position and size to a given mutable rectangle.
 * Applies a new position and size to a given mutable rectangle.
 * Applies a new position and size to a given mutable rectangle.
 * @param {number|?} x_or_position_or_newRectangle The new x coordinate of the upper left corner of the rectangle. / The new location. / The bounds to set to the <code>rectangle</code>.
 * @param {number|?=} y_or_size The new y coordinate of the upper left corner of the rectangle. / The new size.
 * @param {number=} width The new width of the rectangle.
 * @param {number=} height The new height of the rectangle.
 * @return {void}
 */
yfiles.geometry.IMutableRectangle.prototype.reshape = function(x_or_position_or_newRectangle, y_or_size, width, height) {};

/**
 * Sets the center of the rectangle to the provided value.
 * @param {!yfiles.geometry.Point} center The new center coordinates.
 * @return {void}
 */
yfiles.geometry.IMutableRectangle.prototype.setCenter = function(center) {};

/**
 * Creates the union of two rectangles, placing the result in the this parameter.
 * <p>
 * Either of the two parameters rectangles may be the same as the first parameter. The result is placed into the this
 * parameter. This method treats rectangles with negative width or height as empty.
 * </p>
 * @param {?} rectangle1 The first rectangle to create the union of.
 * @param {?} rectangle2 The second rectangle to create the union of.
 * @return {void}
 */
yfiles.geometry.IMutableRectangle.prototype.setToUnion = function(rectangle1, rectangle2) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.geometry.IMutableRectangle;
/**
 * @record
 * @struct
 */
yfiles.geometry.IMutableSize = function() {};
 /** @type {number} */
yfiles.geometry.IMutableSize.prototype.width;
 /** @type {number} */
yfiles.geometry.IMutableSize.prototype.height;

/**
 * Sets the coordinates of the size to the given values.
 * Sets the coordinates of the size to the given values.
 * @param {number|?} newWidth_or_newSize The new x coordinate / The new location.
 * @param {number=} newHeight The new y coordinate
 * @return {void}
 */
yfiles.geometry.IMutableSize.prototype.resize = function(newWidth_or_newSize, newHeight) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.geometry.IMutableSize;
/**
 * @record
 * @struct
 */
yfiles.geometry.IOrientedRectangle = function() {};
 /** @type {number} */
yfiles.geometry.IOrientedRectangle.prototype.anchorX;
 /** @type {number} */
yfiles.geometry.IOrientedRectangle.prototype.anchorY;
 /** @type {number} */
yfiles.geometry.IOrientedRectangle.prototype.upX;
 /** @type {number} */
yfiles.geometry.IOrientedRectangle.prototype.upY;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.IOrientedRectangle.prototype.upVector;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.IOrientedRectangle.prototype.anchorLocation;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.IOrientedRectangle.prototype.orientedRectangleCenter;
 /** @type {!yfiles.geometry.Rect} */
yfiles.geometry.IOrientedRectangle.prototype.bounds;

/**
 * Determines whether the given oriented rectangle contains the provided point, using an epsilon value.
 * @param {!yfiles.geometry.Point} point The coordinates of the point to test.
 * @param {number} eps A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than
 * or equal to that value, it will be considered a hit.
 * @return {boolean} <code>true</code> iff the point lies inside the rectangle.
 */
yfiles.geometry.IOrientedRectangle.prototype.containsWithEps = function(point, eps) {};

/**
 * Creates a transformation matrix that can be used to transform points that are in the local coordinate system of the
 * oriented rectangle if the top-left corner is the origin.
 * @return {!yfiles.geometry.Matrix} A matrix that can be used to transform from oriented rectangle coordinates to world coordinates.
 */
yfiles.geometry.IOrientedRectangle.prototype.createTransform = function() {};

/**
 * Determines whether the oriented rectangle contains the provided point, using an epsilon value.
 * @param {!yfiles.geometry.Point} location The coordinates of the point to test.
 * @param {number} eps A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than
 * or equal to that value, it will be considered a hit.
 * @return {boolean} <code>true</code> iff the point lies inside the rectangle.
 */
yfiles.geometry.IOrientedRectangle.prototype.hits = function(location, eps) {};

/**
 * Creates a {\@link yfiles.algorithms.YOrientedRectangle} from a given {\@link yfiles.geometry.IOrientedRectangle}.
 * @return {!yfiles.algorithms.YOrientedRectangle} The {\@link }.
 */
yfiles.geometry.IOrientedRectangle.prototype.toOrientedRectangle = function() {};
 /** @type {{EMPTY: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.geometry.IOrientedRectangle;
/**
 * @record
 * @struct
 */
yfiles.geometry.IPoint = function() {};
 /** @type {number} */
yfiles.geometry.IPoint.prototype.x;
 /** @type {number} */
yfiles.geometry.IPoint.prototype.y;

/**
 * Calculates the Euclidean distance between two points.
 * @param {?} point2 The second point.
 * @return {number} The distance between the two points.
 */
yfiles.geometry.IPoint.prototype.distanceTo = function(point2) {};

/**
 * Copies the current values of the coordinates of the point to a {\@link yfiles.geometry.Point} struct.
 * <p>
 * This method is useful to obtain a copy of the state and for making use of the various utility methods that are provided
 * by {\@link yfiles.geometry.Point}.
 * </p>
 * @see yfiles.geometry.Point#toMutablePoint
 * @return {!yfiles.geometry.Point} The current values of the coordinates of the point.
 */
yfiles.geometry.IPoint.prototype.toPoint = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.geometry.IPoint;
/**
 * @record
 * @struct
 */
yfiles.geometry.IRectangle = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.IRectangle.prototype.topLeft;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.IRectangle.prototype.bottomLeft;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.IRectangle.prototype.center;
 /** @type {number} */
yfiles.geometry.IRectangle.prototype.maxX;
 /** @type {boolean} */
yfiles.geometry.IRectangle.prototype.isEmpty;
 /** @type {number} */
yfiles.geometry.IRectangle.prototype.maxY;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.IRectangle.prototype.topRight;
 /** @type {!yfiles.geometry.Point} */
yfiles.geometry.IRectangle.prototype.bottomRight;

/**
 * Determines whether the given rectangle contains the provided point.
 * Determines whether the given rectangle contains the provided point.
 * @param {!yfiles.geometry.Point|?} point The point to test.
 * @return {boolean} <code>true</code> iff the point lies inside the rectangle.
 */
yfiles.geometry.IRectangle.prototype.contains = function(point) {};

/**
 * Copies the current values of the rectangle to {\@link yfiles.geometry.Rect} struct.
 * <p>
 * This method can be used to obtain a copy of the current state of the rectangle and for using the utility methods that
 * are available for the {\@link yfiles.geometry.Rect} type.
 * </p>
 * @see yfiles.geometry.IMutableRectangle#reshape
 * @see yfiles.geometry.Rect#toMutableRectangle
 * @return {!yfiles.geometry.Rect} A {\@link } that holds the values of the <code>rectangle</code> at the time of the invocation.
 */
yfiles.geometry.IRectangle.prototype.toRect = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.geometry.IRectangle;
/**
 * @record
 * @struct
 */
yfiles.geometry.ISize = function() {};
 /** @type {number} */
yfiles.geometry.ISize.prototype.width;
 /** @type {number} */
yfiles.geometry.ISize.prototype.height;

/**
 * Converts the {\@link yfiles.geometry.ISize} to a {\@link yfiles.geometry.Size} struct.
 * @return {!yfiles.geometry.Size} A {\@link } struct that has been initialized with the current values of <code>size</code>.
 */
yfiles.geometry.ISize.prototype.toSize = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.geometry.ISize;

/** @const */
yfiles.geometry.MatrixOrder = {};
/** @const {number} */
yfiles.geometry.MatrixOrder.PREPEND;
/** @const {number} */
yfiles.geometry.MatrixOrder.APPEND;
/**
 * @record
 * @struct
 */
yfiles.geometry.Matrix = function() {};
 /** @type {!Array<number>} */
yfiles.geometry.Matrix.prototype.elements;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.Matrix.$class;

/**
 * Applies this matrix to the given SVG element.
 * Applies this matrix to the given HTML canvas rendering context.
 * @param {!SVGElement|!CanvasRenderingContext2D} element_or_ctx The element to transform. / The context to transform.
 * @return {void}
 */
yfiles.geometry.Matrix.prototype.applyTo = function(element_or_ctx) {};

/**
 * Creates a matrix rotation instance around the origin.
 * @param {number} theta The rotation angle in radians.
 * @return {!yfiles.geometry.Matrix} A new matrix.
 */
yfiles.geometry.Matrix.createRotateInstance = function(theta) {};

/**
 * Determines whether <code>this</code> has the same values like <code>other</code>.
 * @param {!yfiles.geometry.Matrix} other The object to compare <code>this</code> to. Must be of the same type.
 * @return {boolean} <code>true</code> if <code>this</code> has the same values like the other object.
 */
yfiles.geometry.Matrix.prototype.hasSameValue = function(other) {};

/**
 * Inverts this instance.
 * @return {void}
 */
yfiles.geometry.Matrix.prototype.invert = function() {};

/**
 * Multiplies this matrix instance by the given instance using the given order.
 * @param {!yfiles.geometry.Matrix} matrix The matrix to multiply with this one.
 * @param {yfiles.geometry.MatrixOrder=} order
 * @return {void}
 */
yfiles.geometry.Matrix.prototype.multiply = function(matrix, order) {};

/**
 * Resets this instance to the identity.
 * @return {void}
 */
yfiles.geometry.Matrix.prototype.reset = function() {};

/**
 * Prepends or appends a rotation operation to this matrix around the specified rotation center.
 * Prepends or appends a rotation operation to this matrix around the origin.
 * @param {number} theta The rotation angle in radians
 * @param {!yfiles.geometry.Point|yfiles.geometry.MatrixOrder=} center_or_order The coordinate of the center of the rotation.
 * @param {yfiles.geometry.MatrixOrder=} order
 * @return {void}
 */
yfiles.geometry.Matrix.prototype.rotate = function(theta, center_or_order, order) {};

/**
 * Appends or prepends a scale operation to this instance.
 * @param {number} x
 * @param {number} y
 * @param {yfiles.geometry.MatrixOrder=} order
 * @return {void}
 */
yfiles.geometry.Matrix.prototype.scale = function(x, y, order) {};

/**
 * Sets all elements of this instance.
 * Sets the values of the given matrix to this instance.
 * @param {number|!yfiles.geometry.Matrix} m0_or_matrix
 * @param {number=} m1
 * @param {number=} m2
 * @param {number=} m3
 * @param {number=} dx
 * @param {number=} dy
 * @return {void}
 */
yfiles.geometry.Matrix.prototype.set = function(m0_or_matrix, m1, m2, m3, dx, dy) {};

/**
 * Converts the {\@link yfiles.geometry.Matrix} object to an SVG transform string.
 * <p>
 * The returned string can be used in a transform attribute.
 * </p>
 * @return {string} The transform string
 */
yfiles.geometry.Matrix.prototype.toSvgTransform = function() {};

/**
 * Transforms the given coordinate.
 * Transforms the given point in place.
 * @param {!yfiles.geometry.Point|?} point The coordinate to transform. / The point to transform and return.
 * @return {!yfiles.geometry.Point|?} The transformed coordinates. / <code>point</code>
 */
yfiles.geometry.Matrix.prototype.transform = function(point) {};

/**
 * Appends or Prepends a translation to this instance.
 * @param {!yfiles.geometry.Point} delta
 * @param {yfiles.geometry.MatrixOrder=} order
 * @return {void}
 */
yfiles.geometry.Matrix.prototype.translate = function(delta, order) {};
/**
 * @record
 * @struct
 */
yfiles.geometry.MutablePoint = function() {};
 /** @type {number} */
yfiles.geometry.MutablePoint.prototype.x;
 /** @type {number} */
yfiles.geometry.MutablePoint.prototype.y;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.MutablePoint.$class;

/**
 * Moves this instance by adding the provided offsets to the coordinates of this point.
 * @param {!yfiles.geometry.Point} delta The offset to add to this point's x coordinate
 * @return {void}
 */
yfiles.geometry.MutablePoint.prototype.moveBy = function(delta) {};

/**
 * Normalizes this point as if it was a vector.
 * <p>
 * After this the "length" of this point is <code>1.0d</code> if it is treated as a vector.
 * </p>
 * @see yfiles.geometry.Point#normalized
 * @return {void}
 */
yfiles.geometry.MutablePoint.prototype.normalize = function() {};
/**
 * @record
 * @struct
 */
yfiles.geometry.MutableRectangle = function() {};
 /** @type {boolean} */
yfiles.geometry.MutableRectangle.prototype.isEmpty;
 /** @type {?} */
yfiles.geometry.MutableRectangle.prototype.location;
 /** @type {?} */
yfiles.geometry.MutableRectangle.prototype.size;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.width;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.height;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.x;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.y;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.x2;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.y2;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.anchorX;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.anchorY;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.upX;
 /** @type {number} */
yfiles.geometry.MutableRectangle.prototype.upY;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.MutableRectangle.$class;

/**
 * Moves this rectangle by applying the offset to the {\@link yfiles.geometry.MutableRectangle#location}
 * @param {!yfiles.geometry.Point} delta The offset to move the rectangle's position by.
 * @return {void}
 */
yfiles.geometry.MutableRectangle.prototype.moveBy = function(delta) {};
/**
 * @record
 * @struct
 */
yfiles.geometry.MutableSize = function() {};
 /** @type {number} */
yfiles.geometry.MutableSize.prototype.width;
 /** @type {number} */
yfiles.geometry.MutableSize.prototype.height;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.MutableSize.$class;
/**
 * @record
 * @struct
 */
yfiles.geometry.OrientedRectangle = function() {};
 /** @type {boolean} */
yfiles.geometry.OrientedRectangle.prototype.isEmpty;
 /** @type {?} */
yfiles.geometry.OrientedRectangle.prototype.anchor;
 /** @type {?} */
yfiles.geometry.OrientedRectangle.prototype.size;
 /** @type {number} */
yfiles.geometry.OrientedRectangle.prototype.width;
 /** @type {number} */
yfiles.geometry.OrientedRectangle.prototype.height;
 /** @type {number} */
yfiles.geometry.OrientedRectangle.prototype.x;
 /** @type {number} */
yfiles.geometry.OrientedRectangle.prototype.y;
 /** @type {number} */
yfiles.geometry.OrientedRectangle.prototype.anchorX;
 /** @type {number} */
yfiles.geometry.OrientedRectangle.prototype.anchorY;
 /** @type {number} */
yfiles.geometry.OrientedRectangle.prototype.upX;
 /** @type {number} */
yfiles.geometry.OrientedRectangle.prototype.upY;
 /** @type {number} */
yfiles.geometry.OrientedRectangle.prototype.angle;
 /** @type {!yfiles.lang.Class} */
yfiles.geometry.OrientedRectangle.$class;

/**
 * A casting operator that creates a new instance of {\@link yfiles.geometry.OrientedRectangle} using the current state of the
 * rectangle that is cast.
 * <p>
 * The anchor will be set to the lower left corner of the provided rectangle. Thus this instance will have the exact same
 * bounds as the rectangle initially. The up vector will be initialized to
 * <code>(0, -1)</code>. Unlike true casting this will create a new instance that will be initialized to the current state of the object
 * being cast, but which will not stay in sync with the state of the object.
 * </p>
 * @param {!yfiles.geometry.MutableRectangle} rect the rectangle to get the current state from
 * @return {!yfiles.geometry.OrientedRectangle} A new instance of {\@link } that holds no reference to the provided rectangle.
 */
yfiles.geometry.OrientedRectangle.convertFrom = function(rect) {};

/**
 * Creates an immutable {\@link yfiles.geometry.IOrientedRectangle} with the given values.
 * @param {number} anchorX
 * @param {number} anchorY
 * @param {number} width
 * @param {number} height
 * @param {number} upX
 * @param {number} upY
 * @return {?}
 */
yfiles.geometry.OrientedRectangle.createImmutable = function(anchorX, anchorY, width, height, upX, upY) {};

/**
 * Moves this rectangle by applying the offset to the {\@link yfiles.geometry.OrientedRectangle#anchor}
 * @param {!yfiles.geometry.Point} delta The offset to move the rectangle's anchor by.
 * @return {void}
 */
yfiles.geometry.OrientedRectangle.prototype.moveBy = function(delta) {};

/**
 * Applies the values provided by the given instance to the values of this instance.
 * @param {?} rectangle The instance to retrieve the values from.
 * @return {void}
 */
yfiles.geometry.OrientedRectangle.prototype.reshape = function(rectangle) {};

/**
 * Sets the components of the up vector to the new values.
 * <p>
 * It is up to the caller to assure that the values describe a vector of length 1.
 * </p>
 * @see yfiles.geometry.OrientedRectangle#angle
 * @param {number} upx The x component of the normalized up vector.
 * @param {number} upy The y component of the normalized up vector.
 * @return {void}
 */
yfiles.geometry.OrientedRectangle.prototype.setUpVector = function(upx, upy) {};
/** @const */
yfiles.styles = {};
/**
 * @record
 * @struct
 */
yfiles.styles.Arrow = function() {};
 /** @type {yfiles.styles.ArrowType} */
yfiles.styles.Arrow.prototype.type;
 /** @type {number} */
yfiles.styles.Arrow.prototype.scale;
 /** @type {!yfiles.view.Stroke} */
yfiles.styles.Arrow.prototype.stroke;
 /** @type {!yfiles.view.Fill} */
yfiles.styles.Arrow.prototype.fill;
 /** @type {number} */
yfiles.styles.Arrow.prototype.cropLength;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.Arrow.$class;

/**
 * Returns an immutable {\@link yfiles.styles.IArrow} instance that uses the current properties.
 * @return {?} An immutable instance
 */
yfiles.styles.Arrow.prototype.asFrozen = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.DefaultEdgePathCropper = function() {};
 /** @type {?} */
yfiles.styles.DefaultEdgePathCropper.INSTANCE;
 /** @type {number} */
yfiles.styles.DefaultEdgePathCropper.prototype.extraCropLength;
 /** @type {boolean} */
yfiles.styles.DefaultEdgePathCropper.prototype.cropAtPort;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.DefaultEdgePathCropper.$class;

/**
 * Calculates the total length the edge path is cropped.
 * <p>
 * This method can be overridden to change the length that is cropped from an edge. The default implementation returns the
 * sum of {\@link yfiles.styles.DefaultEdgePathCropper#extraCropLength}, {\@link yfiles.styles.IArrow#length arrow length} and {\@link yfiles.styles.IArrow#cropLength arrow crop length}
 * </p>
 * @see yfiles.styles.DefaultEdgePathCropper#cropEdgePath
 * @see yfiles.styles.DefaultEdgePathCropper#cropEdgePathAtArrow
 * @protected
 * @param {?} arrow The arrow at this edge end.
 * @param {boolean} atSource <code>true</code> if the crop length should be calculated at the edge source. <code>false</code> otherwise.
 * @return {number} The total length the edge path is cropped.
 */
yfiles.styles.DefaultEdgePathCropper.prototype.calculateTotalCropLength = function(arrow, atSource) {};

/**
 * Crops the provided <code>path</code> at one end of an edge.
 * <p>
 * If {\@link yfiles.styles.DefaultEdgePathCropper#cropAtPort} is <code>true</code> this implementation delegates to {\@link yfiles.styles.DefaultEdgePathCropper#cropEdgePathAtPortGeometry}. Otherwise
 * the edge path is cropped at the {\@link yfiles.styles.DefaultEdgePathCropper#getNodeGeometry node geometry}. If this would result in an empty path, the cropping is delegated to {\@link yfiles.styles.DefaultEdgePathCropper#handleEmptyPath}
 * instead.
 * </p>
 * @param {?} edge The edge whose path is to be cropped.
 * @param {boolean} atSource Whether to crop the source or target side of the path.
 * @param {?} arrow The arrow that is used at the end of the edge.
 * @param {!yfiles.geometry.GeneralPath} path The path to crop.
 * @return {!yfiles.geometry.GeneralPath} The cropped path. This is can be either the same instance of the given path or a newly created instance.
 */
yfiles.styles.DefaultEdgePathCropper.prototype.cropEdgePath = function(edge, atSource, arrow, path) {};

/**
 * Crops an edge's path at the source or target side with respect to the given arrow.
 * <p>
 * The <code>path</code> is cropped by the length {\@link yfiles.styles.DefaultEdgePathCropper#calculateTotalCropLength} returns for <code>arrow</code> and
 * <code>atSource</code>.
 * </p>
 * @param {boolean} atSource if set to <code>true</code> the source side is cropped.
 * @param {?} arrow The arrow to consider for the cropping.
 * @param {!yfiles.geometry.GeneralPath} path The edge's path to crop.
 * @return {!yfiles.geometry.GeneralPath} The cropped path. This is can be either the same instance of the given path or a newly created instance.
 */
yfiles.styles.DefaultEdgePathCropper.prototype.cropEdgePathAtArrow = function(atSource, arrow, path) {};

/**
 * Crops an edge's path at the source or target side at the {\@link yfiles.styles.DefaultEdgePathCropper#getPortGeometry port geometry} with respect to the given arrow.
 * @protected
 * @param {?} edge The edge whose path is to be cropped.
 * @param {boolean} atSource Whether to crop the source or target side of the path.
 * @param {?} arrow The arrow that is used at the end of the edge.
 * @param {!yfiles.geometry.GeneralPath} path The path to crop.
 * @return {!yfiles.geometry.GeneralPath} The cropped path. This is can be either the same instance of the given path or a newly created instance.
 */
yfiles.styles.DefaultEdgePathCropper.prototype.cropEdgePathAtPortGeometry = function(edge, atSource, arrow, path) {};

/**
 * Finds the intersection between a node and the edge.
 * @protected
 * @param {?} node
 * @param {?} nodeShapeGeometry
 * @param {?} edge
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point}
 */
yfiles.styles.DefaultEdgePathCropper.prototype.getIntersection = function(node, nodeShapeGeometry, edge, inner, outer) {};

/**
 * Returns the {\@link yfiles.styles.IShapeGeometry geometry} that is used to crop the edge at the node outline.
 * <p>
 * The default implementation queries the {\@link yfiles.styles.INodeStyleRenderer#getShapeGeometry node style renderer} for an implementation of {\@link yfiles.styles.IShapeGeometry}. This
 * method can be overridden to return an arbitrary {\@link yfiles.styles.IShapeGeometry geometry} for a node.
 * </p>
 * @protected
 * @param {?} node The node the edge should be cropped at.
 * @return {?} The {\@link  geometry} of the node.
 */
yfiles.styles.DefaultEdgePathCropper.prototype.getNodeGeometry = function(node) {};

/**
 * Returns the {\@link yfiles.styles.IShapeGeometry geometry} that is used to crop the edge at the port outline if {\@link yfiles.styles.DefaultEdgePathCropper#cropAtPort} is set to <code>true</code>.
 * <p>
 * The default implementation returns <code>null</code>. This method can be overridden to return an arbitrary {\@link yfiles.styles.IShapeGeometry geometry} for a port.
 * </p>
 * @see yfiles.styles.DefaultEdgePathCropper#cropAtPort
 * @protected
 * @param {?} port The port the edge should be cropped at.
 * @return {?} The {\@link  geometry} of the port.
 */
yfiles.styles.DefaultEdgePathCropper.prototype.getPortGeometry = function(port) {};

/**
 * Handles the edge path cropping if {\@link yfiles.styles.DefaultEdgePathCropper#cropEdgePath} would result in a {\@link yfiles.geometry.GeneralPath#clear cleared} path.
 * <p>
 * This method is called by {\@link yfiles.styles.DefaultEdgePathCropper#cropEdgePath} if {\@link yfiles.styles.DefaultEdgePathCropper#cropAtPort} is <code>false</code> and cropping the edge path at
 * the {\@link yfiles.styles.DefaultEdgePathCropper#getNodeGeometry node geometry} would result in an empty path.
 * </p>
 * <p>
 * The default implementation is to {\@link yfiles.geometry.GeneralPath#clear} the edge path.
 * </p>
 * @protected
 * @param {?} edge The edge whose path is to be cropped.
 * @param {boolean} atSource Whether to crop the source or target side of the path.
 * @param {?} arrow The arrow that is used at the end of the edge.
 * @param {!yfiles.geometry.GeneralPath} path The path to crop.
 * @return {!yfiles.geometry.GeneralPath} The cropped path. This is can be either the same instance of the given path or a newly created instance.
 */
yfiles.styles.DefaultEdgePathCropper.prototype.handleEmptyPath = function(edge, atSource, arrow, path) {};

/**
 * Checks whether a given point is inside a node's shape geometry with respect to the edge that is being calculated.
 * @protected
 * @param {!yfiles.geometry.Point} location
 * @param {?} node
 * @param {?} nodeShapeGeometry
 * @param {?} edge
 * @return {boolean}
 */
yfiles.styles.DefaultEdgePathCropper.prototype.isInside = function(location, node, nodeShapeGeometry, edge) {};
/**
 * @record
 * @struct
 */
yfiles.styles.IArrow = function() {};
 /** @type {number} */
yfiles.styles.IArrow.prototype.length;
 /** @type {number} */
yfiles.styles.IArrow.prototype.cropLength;

/**
 * Gets an {\@link yfiles.view.IBoundsProvider} implementation that can yield this arrow's bounds if painted at the given location
 * using the given direction for the given edge.
 * @abstract
 * @param {?} edge the edge this arrow belongs to
 * @param {boolean} atSource whether this will be the source arrow
 * @param {!yfiles.geometry.Point} anchor the anchor point for the tip of the arrow
 * @param {!yfiles.geometry.Point} directionVector the direction the arrow is pointing in
 * @return {?} an implementation of the {\@link } interface that can subsequently be used to query the bounds.
 * Clients will always call this method before using the implementation and may not cache the instance returned. This
 * allows for applying the flyweight design pattern to implementations.
 */
yfiles.styles.IArrow.prototype.getBoundsProvider = function(edge, atSource, anchor, directionVector) {};

/**
 * Gets an {\@link yfiles.view.IVisualCreator} implementation that will paint this arrow at the given location using the given
 * direction for the given edge.
 * @abstract
 * @param {?} edge the edge this arrow belongs to
 * @param {boolean} atSource whether this will be the source arrow
 * @param {!yfiles.geometry.Point} anchor the anchor point for the tip of the arrow
 * @param {!yfiles.geometry.Point} direction the direction the arrow is pointing in
 * @return {?} an implementation of the {\@link } interface that can subsequently be used to perform the actual
 * painting. Clients will always call this method before using the implementation and may not cache the instance returned.
 * This allows for applying the flyweight design pattern to implementations.
 */
yfiles.styles.IArrow.prototype.getVisualCreator = function(edge, atSource, anchor, direction) {};
 /** @type {{NONE: ?, SIMPLE: ?, DEFAULT: ?, SHORT: ?, DIAMOND: ?, CROSS: ?, CIRCLE: ?, TRIANGLE: ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IArrow;
/**
 * @record
 * @struct
 */
yfiles.styles.VoidEdgeStyle = function() {};
 /** @type {!yfiles.styles.VoidEdgeStyle} */
yfiles.styles.VoidEdgeStyle.INSTANCE;
 /** @type {?} */
yfiles.styles.VoidEdgeStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidEdgeStyle.$class;

/**
 * Returns <code>this</code>.
 * @return {!Object} <code>this</code>
 */
yfiles.styles.VoidEdgeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.VoidEdgeStyleRenderer = function() {};
 /** @type {?} */
yfiles.styles.VoidEdgeStyleRenderer.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidEdgeStyleRenderer.$class;

/**
 * Yields the {\@link yfiles.view.IBoundsProvider#EMPTY} that will return empty bounds.
 * @param {?} edge
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidEdgeStyleRenderer.prototype.getBoundsProvider = function(edge, style) {};

/**
 * Yields the {\@link yfiles.graph.ILookup#EMPTY} that will not yield anything.
 * @param {?} edge
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidEdgeStyleRenderer.prototype.getContext = function(edge, style) {};

/**
 * Yields the {\@link yfiles.input.IHitTestable#NEVER} that will always report misses.
 * @param {?} edge
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidEdgeStyleRenderer.prototype.getHitTestable = function(edge, style) {};

/**
 * Yields the {\@link yfiles.input.IMarqueeTestable#NEVER} that will always report misses.
 * @param {?} edge
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidEdgeStyleRenderer.prototype.getMarqueeTestable = function(edge, style) {};

/**
 * This method always returns the {\@link yfiles.styles.VoidPathGeometry#INSTANCE VoidPathGeometry instance}.
 * @see yfiles.styles.IEdgeStyleRenderer#getPathGeometry
 * @param {?} edge The edge to provide an instance for
 * @param {?} style The style to use for the rendering
 * @return {?} The {\@link #INSTANCE VoidPathGeometry instance}.
 */
yfiles.styles.VoidEdgeStyleRenderer.prototype.getPathGeometry = function(edge, style) {};

/**
 * Yields the {\@link yfiles.view.IVisibilityTestable#NEVER} that will always claim invisibility.
 * @param {?} edge
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidEdgeStyleRenderer.prototype.getVisibilityTestable = function(edge, style) {};

/**
 * Yields the {\@link yfiles.view.VoidVisualCreator#INSTANCE} that will do nothing.
 * @param {?} edge
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidEdgeStyleRenderer.prototype.getVisualCreator = function(edge, style) {};
/**
 * @record
 * @struct
 */
yfiles.styles.VoidPathGeometry = function() {};
 /** @type {?} */
yfiles.styles.VoidPathGeometry.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidPathGeometry.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.IEdgeStyle = function() {};
 /** @type {?} */
yfiles.styles.IEdgeStyle.prototype.renderer;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IEdgeStyle;
/**
 * @record
 * @struct
 */
yfiles.styles.IEdgeStyleRenderer = function() {};

/**
 * Gets an implementation of the {\@link yfiles.view.IBoundsProvider} interface that can handle the provided edge and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} edge The edge to provide an instance for
 * @param {?} style The style to use for the calculating the painting bounds
 * @return {?} An implementation that may be used to subsequently query the edge's painting bounds. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.IEdgeStyleRenderer.prototype.getBoundsProvider = function(edge, style) {};

/**
 * Gets a temporary context instance that can be used to query additional information for the edge's style.
 * <p>
 * Implementations may return {\@link yfiles.graph.ILookup#EMPTY} if they don't support this, but may not return <code>null</code>.
 * </p>
 * @see yfiles.graph.ILookup#EMPTY
 * @see yfiles.graph.ILookup
 * @abstract
 * @param {?} edge The edge to provide a context instance for.
 * @param {?} style The style to use for the context.
 * @return {?} An non-<code>null</code> lookup implementation.
 */
yfiles.styles.IEdgeStyleRenderer.prototype.getContext = function(edge, style) {};

/**
 * Gets an implementation of the {\@link yfiles.input.IHitTestable} interface that can handle the provided edge and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} edge The edge to provide an instance for
 * @param {?} style The style to use for the querying hit tests
 * @return {?} An implementation that may be used to subsequently perform hit tests. Clients should not cache this instance and must
 * always call this method immediately before using the value returned. This enables the use of the flyweight design
 * pattern for implementations. This method may return <code>null</code> to indicate that the edge cannot be hit tested.
 */
yfiles.styles.IEdgeStyleRenderer.prototype.getHitTestable = function(edge, style) {};

/**
 * Gets an implementation of the {\@link yfiles.input.IMarqueeTestable} interface that can handle the provided edge and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} edge The edge to provide an instance for
 * @param {?} style The style to use for the querying marquee intersection test.
 * @return {?} An implementation that may be used to subsequently query the marquee intersections. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.IEdgeStyleRenderer.prototype.getMarqueeTestable = function(edge, style) {};

/**
 * Gets an implementation of the {\@link yfiles.styles.IPathGeometry} interface that can handle the provided edge and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} edge The edge to provide an instance for
 * @param {?} style The style to use for the rendering
 * @return {?} An implementation that may be used to subsequently query geometry information from. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.IEdgeStyleRenderer.prototype.getPathGeometry = function(edge, style) {};

/**
 * Gets an implementation of the {\@link yfiles.view.IVisibilityTestable} interface that can handle the provided edge and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} edge The edge to provide an instance for
 * @param {?} style The style to use for the testing the visibility
 * @return {?} An implementation that may be used to subsequently query the edge's visibility. Clients should not cache this instance
 * and must always call this method immediately before using the value returned. This enables the use of the flyweight
 * design pattern for implementations
 */
yfiles.styles.IEdgeStyleRenderer.prototype.getVisibilityTestable = function(edge, style) {};

/**
 * Gets an implementation of the {\@link yfiles.view.IVisualCreator} interface that can handle the provided edge and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation, but never <code>null</code>.
 * </p>
 * @see yfiles.view.VoidVisualCreator#INSTANCE
 * @abstract
 * @param {?} edge The edge to provide an instance for
 * @param {?} style The style to use for the creation of the visual
 * @return {?} An implementation that may be used to subsequently create or update the visual for the edge. Clients should not cache
 * this instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations. This method may not return <code>null</code> but should yield a {\@link #INSTANCE void} implementation
 * instead.
 */
yfiles.styles.IEdgeStyleRenderer.prototype.getVisualCreator = function(edge, style) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IEdgeStyleRenderer;

/** @const */
yfiles.styles.ArrowType = {};
/** @const {number} */
yfiles.styles.ArrowType.DEFAULT;
/** @const {number} */
yfiles.styles.ArrowType.SIMPLE;
/** @const {number} */
yfiles.styles.ArrowType.SHORT;
/** @const {number} */
yfiles.styles.ArrowType.DIAMOND;
/** @const {number} */
yfiles.styles.ArrowType.NONE;
/** @const {number} */
yfiles.styles.ArrowType.CIRCLE;
/** @const {number} */
yfiles.styles.ArrowType.CROSS;
/** @const {number} */
yfiles.styles.ArrowType.TRIANGLE;
/**
 * @record
 * @struct
 */
yfiles.styles.IEdgePathCropper = function() {};

/**
 * Crops the provided <code>path</code> at one end of an edge.
 * @abstract
 * @param {?} edge The edge whose path is to be cropped.
 * @param {boolean} atSource Whether to crop the source or target side of the path.
 * @param {?} arrow The arrow that is used at the end of the edge.
 * @param {!yfiles.geometry.GeneralPath} path The path to crop.
 * @return {!yfiles.geometry.GeneralPath} The cropped path. This is can be either the same instance of the given path or a newly created instance.
 */
yfiles.styles.IEdgePathCropper.prototype.cropEdgePath = function(edge, atSource, arrow, path) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IEdgePathCropper;
/**
 * @record
 * @struct
 */
yfiles.styles.VoidLabelStyle = function() {};
 /** @type {!yfiles.styles.VoidLabelStyle} */
yfiles.styles.VoidLabelStyle.INSTANCE;
 /** @type {?} */
yfiles.styles.VoidLabelStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidLabelStyle.$class;

/**
 * Returns <code>this</code>.
 * @return {!Object} <code>this</code>
 */
yfiles.styles.VoidLabelStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.VoidLabelStyleRenderer = function() {};
 /** @type {?} */
yfiles.styles.VoidLabelStyleRenderer.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidLabelStyleRenderer.$class;

/**
 * Yields the {\@link yfiles.view.IBoundsProvider#EMPTY} that will return empty bounds.
 * @param {?} label
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidLabelStyleRenderer.prototype.getBoundsProvider = function(label, style) {};

/**
 * Yields the {\@link yfiles.graph.ILookup#EMPTY} that will not yield anything.
 * @param {?} label
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidLabelStyleRenderer.prototype.getContext = function(label, style) {};

/**
 * Yields the {\@link yfiles.input.IHitTestable#NEVER} that will always report misses.
 * @param {?} label
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidLabelStyleRenderer.prototype.getHitTestable = function(label, style) {};

/**
 * Yields the {\@link yfiles.input.IMarqueeTestable#NEVER} that will always report misses.
 * @param {?} label
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidLabelStyleRenderer.prototype.getMarqueeTestable = function(label, style) {};

/**
 * Yields {\@link yfiles.geometry.Size#EMPTY}.
 * @param {?} label
 * @param {?} style
 * @return {!yfiles.geometry.Size}
 */
yfiles.styles.VoidLabelStyleRenderer.prototype.getPreferredSize = function(label, style) {};

/**
 * Yields the {\@link yfiles.view.IVisibilityTestable#NEVER} that will always claim invisibility.
 * @param {?} label
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidLabelStyleRenderer.prototype.getVisibilityTestable = function(label, style) {};

/**
 * Yields the {\@link yfiles.view.VoidVisualCreator#INSTANCE} that will do nothing.
 * @param {?} label
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidLabelStyleRenderer.prototype.getVisualCreator = function(label, style) {};
/**
 * @record
 * @struct
 */
yfiles.styles.ILabelStyle = function() {};
 /** @type {?} */
yfiles.styles.ILabelStyle.prototype.renderer;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.ILabelStyle;
/**
 * @record
 * @struct
 */
yfiles.styles.ILabelStyleRenderer = function() {};

/**
 * Gets an implementation of the {\@link yfiles.view.IBoundsProvider} interface that can handle the provided label and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} label The label to provide an instance for
 * @param {?} style The style to use for the calculating the painting bounds
 * @return {?} An implementation that may be used to subsequently query the label's painting bounds. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.ILabelStyleRenderer.prototype.getBoundsProvider = function(label, style) {};

/**
 * Gets a temporary context instance that can be used to query additional information for the label's style.
 * <p>
 * Implementations may return {\@link yfiles.graph.ILookup#EMPTY} if they don't support this, but may not return <code>null</code>.
 * </p>
 * @see yfiles.graph.ILookup#EMPTY
 * @see yfiles.graph.ILookup
 * @abstract
 * @param {?} label The label to provide a context instance for.
 * @param {?} style The style to use for the context.
 * @return {?} An non-<code>null</code> lookup implementation.
 */
yfiles.styles.ILabelStyleRenderer.prototype.getContext = function(label, style) {};

/**
 * Gets an implementation of the {\@link yfiles.input.IHitTestable} interface that can handle the provided label and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} label The label to provide an instance for
 * @param {?} style The style to use for the querying hit tests
 * @return {?} An implementation that may be used to subsequently perform hit tests. Clients should not cache this instance and must
 * always call this method immediately before using the value returned. This enables the use of the flyweight design
 * pattern for implementations. This method may return <code>null</code> to indicate that the label cannot be hit tested.
 */
yfiles.styles.ILabelStyleRenderer.prototype.getHitTestable = function(label, style) {};

/**
 * Gets an implementation of the {\@link yfiles.input.IMarqueeTestable} interface that can handle the provided label and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} label The label to provide an instance for
 * @param {?} style The style to use for the querying marquee intersection test.
 * @return {?} An implementation that may be used to subsequently query the marquee intersections. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.ILabelStyleRenderer.prototype.getMarqueeTestable = function(label, style) {};

/**
 * Calculates the {\@link yfiles.graph.ILabel#preferredSize preferred size} of a given label using the associated style.
 * @abstract
 * @param {?} label The label to determine the preferred size for
 * @param {?} style The style instance that uses this instance as its {\@link #renderer}
 * @return {!yfiles.geometry.Size} A size that can be used as the {\@link #preferredSize} if this renderer renders the label using the associated style.
 */
yfiles.styles.ILabelStyleRenderer.prototype.getPreferredSize = function(label, style) {};

/**
 * Gets an implementation of the {\@link yfiles.view.IVisibilityTestable} interface that can handle the provided label and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} label The label to provide an instance for
 * @param {?} style The style to use for the testing the visibility
 * @return {?} An implementation that may be used to subsequently query the label's visibility. Clients should not cache this instance
 * and must always call this method immediately before using the value returned. This enables the use of the flyweight
 * design pattern for implementations
 */
yfiles.styles.ILabelStyleRenderer.prototype.getVisibilityTestable = function(label, style) {};

/**
 * Gets an implementation of the {\@link yfiles.view.IVisualCreator} interface that can handle the provided label and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation, but never <code>null</code>.
 * </p>
 * @see yfiles.view.VoidVisualCreator#INSTANCE
 * @abstract
 * @param {?} label The label to provide an instance for
 * @param {?} style The style to use for the creation of the visual
 * @return {?} An implementation that may be used to subsequently create or update the visual for the label. Clients should not cache
 * this instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations. This method may not return <code>null</code> but should yield a {\@link #INSTANCE void} implementation
 * instead.
 */
yfiles.styles.ILabelStyleRenderer.prototype.getVisualCreator = function(label, style) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.ILabelStyleRenderer;
/**
 * @record
 * @struct
 */
yfiles.styles.VoidShapeGeometry = function() {};
 /** @type {?} */
yfiles.styles.VoidShapeGeometry.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidShapeGeometry.$class;

/**
 * This implementation always returns <code>null</code> (a {\@link T} with no value).
 * @see yfiles.styles.IShapeGeometry#getIntersection
 * @param {!yfiles.geometry.Point} inner The first point of the line that is inside the shape.
 * @param {!yfiles.geometry.Point} outer The second point of the line that is outside the shape.
 * @return {!yfiles.geometry.Point} A {\@link } with no value.
 */
yfiles.styles.VoidShapeGeometry.prototype.getIntersection = function(inner, outer) {};

/**
 * This implementation returns an empty path.
 * <p>
 * This means that the outline never intersects any line or contains any point.
 * </p>
 * @see yfiles.styles.IShapeGeometry#getOutline
 * @return {!yfiles.geometry.GeneralPath} The empty path.
 */
yfiles.styles.VoidShapeGeometry.prototype.getOutline = function() {};

/**
 * This implementation always returns <code>false</code>.
 * @see yfiles.styles.IShapeGeometry#isInside
 * @param {!yfiles.geometry.Point} location The point to test.
 * @return {boolean} <code>false</code>
 */
yfiles.styles.VoidShapeGeometry.prototype.isInside = function(location) {};
/**
 * @record
 * @struct
 */
yfiles.styles.VoidNodeStyle = function() {};
 /** @type {!yfiles.styles.VoidNodeStyle} */
yfiles.styles.VoidNodeStyle.INSTANCE;
 /** @type {?} */
yfiles.styles.VoidNodeStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidNodeStyle.$class;

/**
 * Returns <code>this</code>.
 * @return {!Object} <code>this</code>
 */
yfiles.styles.VoidNodeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.VoidNodeStyleRenderer = function() {};
 /** @type {?} */
yfiles.styles.VoidNodeStyleRenderer.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidNodeStyleRenderer.$class;

/**
 * Yields the {\@link yfiles.view.IBoundsProvider#EMPTY} that will return empty bounds.
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidNodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Yields the {\@link yfiles.graph.ILookup#EMPTY} that will not yield anything.
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidNodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 * Yields the {\@link yfiles.input.IHitTestable#NEVER} that will always report misses.
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidNodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 * Yields the {\@link yfiles.input.IMarqueeTestable#NEVER} that will always report misses.
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidNodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 * This implementation always returns the {\@link yfiles.styles.VoidShapeGeometry#INSTANCE VoidShapeGeometry instance}.
 * @see yfiles.styles.INodeStyleRenderer#getShapeGeometry
 * @param {?} node The node to provide an instance for
 * @param {?} style The style to use for the rendering
 * @return {?} The {\@link #INSTANCE VoidShapeGeometry instance}.
 */
yfiles.styles.VoidNodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Yields the {\@link yfiles.view.IVisibilityTestable#NEVER} that will always claim invisibility.
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidNodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Yields the {\@link yfiles.view.VoidVisualCreator#INSTANCE} that will do nothing.
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidNodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};
/**
 * @record
 * @struct
 */
yfiles.styles.INodeStyle = function() {};
 /** @type {?} */
yfiles.styles.INodeStyle.prototype.renderer;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.INodeStyle;
/**
 * @record
 * @struct
 */
yfiles.styles.INodeStyleRenderer = function() {};

/**
 * Gets an implementation of the {\@link yfiles.view.IBoundsProvider} interface that can handle the provided node and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} node The node to provide an instance for
 * @param {?} style The style to use for the calculating the painting bounds
 * @return {?} An implementation that may be used to subsequently query the node's painting bounds. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.INodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Gets a temporary context instance that can be used to query additional information for the node's style.
 * <p>
 * Implementations may return {\@link yfiles.graph.ILookup#EMPTY} if they don't support this, but may not return <code>null</code>.
 * </p>
 * @see yfiles.graph.ILookup#EMPTY
 * @see yfiles.graph.ILookup
 * @abstract
 * @param {?} node The node to provide a context instance for.
 * @param {?} style The style to use for the context.
 * @return {?} An non-<code>null</code> lookup implementation.
 */
yfiles.styles.INodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 * Gets an implementation of the {\@link yfiles.input.IHitTestable} interface that can handle the provided node and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} node The node to provide an instance for
 * @param {?} style The style to use for the querying hit tests
 * @return {?} An implementation that may be used to subsequently perform hit tests. Clients should not cache this instance and must
 * always call this method immediately before using the value returned. This enables the use of the flyweight design
 * pattern for implementations. This method may return <code>null</code> to indicate that the node cannot be hit tested.
 */
yfiles.styles.INodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 * Gets an implementation of the {\@link yfiles.input.IMarqueeTestable} interface that can handle the provided node and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} node The node to provide an instance for
 * @param {?} style The style to use for the querying marquee intersection test.
 * @return {?} An implementation that may be used to subsequently query the marquee intersections. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.INodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 * Gets an implementation of the {\@link yfiles.styles.IShapeGeometry} interface that can handle the provided node and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} node The node to provide an instance for
 * @param {?} style The style to use for the rendering
 * @return {?} An implementation that may be used to subsequently query geometry information from. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.INodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Gets an implementation of the {\@link yfiles.view.IVisibilityTestable} interface that can handle the provided node and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} node The node to provide an instance for
 * @param {?} style The style to use for the testing the visibility
 * @return {?} An implementation that may be used to subsequently query the node's visibility. Clients should not cache this instance
 * and must always call this method immediately before using the value returned. This enables the use of the flyweight
 * design pattern for implementations
 */
yfiles.styles.INodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Gets an implementation of the {\@link yfiles.view.IVisualCreator} interface that can handle the provided node and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation, but never <code>null</code>.
 * </p>
 * @see yfiles.view.VoidVisualCreator#INSTANCE
 * @abstract
 * @param {?} node The node to provide an instance for
 * @param {?} style The style to use for the creation of the visual
 * @return {?} An implementation that may be used to subsequently create or update the visual for the node. Clients should not cache
 * this instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations. This method may not return <code>null</code> but should yield a {\@link #INSTANCE void} implementation
 * instead.
 */
yfiles.styles.INodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.INodeStyleRenderer;
/**
 * @record
 * @struct
 */
yfiles.styles.IPathGeometry = function() {};

/**
 * Returns a representation of the visible path of the edge in form of a {\@link yfiles.geometry.GeneralPath}
 * @abstract
 * @return {!yfiles.geometry.GeneralPath} An instance that describes the visible path or <code>null</code> if this is not applicable for the current geometry.
 */
yfiles.styles.IPathGeometry.prototype.getPath = function() {};

/**
 * Returns the number of "segments" this edge's path consists of.
 * @abstract
 * @return {number} the number of segments or <code>-1</code> if there is no such thing as a segment for this edge.
 */
yfiles.styles.IPathGeometry.prototype.getSegmentCount = function() {};

/**
 * Calculates the tangent on the edge's path at the given ratio point for the given segment.
 * @see yfiles.styles.IPathGeometry#getTangent
 * @see yfiles.styles.IPathGeometry#getSegmentCount
 * @abstract
 * Calculates the tangent on the edge's path at the given ratio point.
 * @abstract
 * @param {number} segmentIndex_or_ratio the segment to use for the calculation / a value in [0,1] where 0 is the source's end and 1 is at the target's end of the visible edge path
 * @param {number=} ratio a value in [0,1] where 0 is the source's end and 1 is at the target's end of the segment
 * @return {!yfiles.geometry.Tangent} The tangential line, if any exists.
 */
yfiles.styles.IPathGeometry.prototype.getTangent = function(segmentIndex_or_ratio, ratio) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IPathGeometry;
/**
 * @record
 * @struct
 */
yfiles.styles.VoidPortStyleRenderer = function() {};
 /** @type {?} */
yfiles.styles.VoidPortStyleRenderer.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidPortStyleRenderer.$class;

/**
 * Yields the {\@link yfiles.view.IBoundsProvider#EMPTY} that will return empty bounds.
 * @param {?} port
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidPortStyleRenderer.prototype.getBoundsProvider = function(port, style) {};

/**
 * Yields the {\@link yfiles.graph.ILookup#EMPTY} that will not yield anything.
 * @param {?} port
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidPortStyleRenderer.prototype.getContext = function(port, style) {};

/**
 * Yields the {\@link yfiles.input.IHitTestable#NEVER} that will always report misses.
 * @param {?} port
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidPortStyleRenderer.prototype.getHitTestable = function(port, style) {};

/**
 * Yields the {\@link yfiles.input.IMarqueeTestable#NEVER} that will always report misses.
 * @param {?} port
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidPortStyleRenderer.prototype.getMarqueeTestable = function(port, style) {};

/**
 * Yields the {\@link yfiles.view.IVisibilityTestable#NEVER} that will always claim invisibility.
 * @param {?} port
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidPortStyleRenderer.prototype.getVisibilityTestable = function(port, style) {};

/**
 * Yields the {\@link yfiles.view.VoidVisualCreator#INSTANCE} that will do nothing.
 * @param {?} port
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidPortStyleRenderer.prototype.getVisualCreator = function(port, style) {};
/**
 * @record
 * @struct
 */
yfiles.styles.VoidPortStyle = function() {};
 /** @type {!yfiles.styles.VoidPortStyle} */
yfiles.styles.VoidPortStyle.INSTANCE;
 /** @type {?} */
yfiles.styles.VoidPortStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidPortStyle.$class;

/**
 * Returns <code>this</code>.
 * @return {!Object} <code>this</code>
 */
yfiles.styles.VoidPortStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.IPortStyle = function() {};
 /** @type {?} */
yfiles.styles.IPortStyle.prototype.renderer;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IPortStyle;
/**
 * @record
 * @struct
 */
yfiles.styles.IPortStyleRenderer = function() {};

/**
 * Gets an implementation of the {\@link yfiles.view.IBoundsProvider} interface that can handle the provided port and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} port The port to provide an instance for
 * @param {?} style The style to use for the calculating the painting bounds
 * @return {?} An implementation that may be used to subsequently query the port's painting bounds. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.IPortStyleRenderer.prototype.getBoundsProvider = function(port, style) {};

/**
 * Gets a temporary context instance that can be used to query additional information for the port's style.
 * <p>
 * Implementations may return {\@link yfiles.graph.ILookup#EMPTY} if they don't support this, but may not return <code>null</code>.
 * </p>
 * @see yfiles.graph.ILookup#EMPTY
 * @see yfiles.graph.ILookup
 * @abstract
 * @param {?} port The port to provide a context instance for.
 * @param {?} style The style to use for the context.
 * @return {?} An non-<code>null</code> lookup implementation.
 */
yfiles.styles.IPortStyleRenderer.prototype.getContext = function(port, style) {};

/**
 * Gets an implementation of the {\@link yfiles.input.IHitTestable} interface that can handle the provided port and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} port The port to provide an instance for
 * @param {?} style The style to use for the querying hit tests
 * @return {?} An implementation that may be used to subsequently perform hit tests. Clients should not cache this instance and must
 * always call this method immediately before using the value returned. This enables the use of the flyweight design
 * pattern for implementations. This method may return <code>null</code> to indicate that the port cannot be hit tested.
 */
yfiles.styles.IPortStyleRenderer.prototype.getHitTestable = function(port, style) {};

/**
 * Gets an implementation of the {\@link yfiles.input.IMarqueeTestable} interface that can handle the provided port and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} port The port to provide an instance for
 * @param {?} style The style to use for the querying marquee intersection test.
 * @return {?} An implementation that may be used to subsequently query the marquee intersections. Clients should not cache this
 * instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations
 */
yfiles.styles.IPortStyleRenderer.prototype.getMarqueeTestable = function(port, style) {};

/**
 * Gets an implementation of the {\@link yfiles.view.IVisibilityTestable} interface that can handle the provided port and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation.
 * </p>
 * @abstract
 * @param {?} port The port to provide an instance for
 * @param {?} style The style to use for the testing the visibility
 * @return {?} An implementation that may be used to subsequently query the port's visibility. Clients should not cache this instance
 * and must always call this method immediately before using the value returned. This enables the use of the flyweight
 * design pattern for implementations
 */
yfiles.styles.IPortStyleRenderer.prototype.getVisibilityTestable = function(port, style) {};

/**
 * Gets an implementation of the {\@link yfiles.view.IVisualCreator} interface that can handle the provided port and its associated
 * style.
 * <p>
 * This method may return a flyweight implementation, but never <code>null</code>.
 * </p>
 * @see yfiles.view.VoidVisualCreator#INSTANCE
 * @abstract
 * @param {?} port The port to provide an instance for
 * @param {?} style The style to use for the creation of the visual
 * @return {?} An implementation that may be used to subsequently create or update the visual for the port. Clients should not cache
 * this instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations. This method may not return <code>null</code> but should yield a {\@link #INSTANCE void} implementation
 * instead.
 */
yfiles.styles.IPortStyleRenderer.prototype.getVisualCreator = function(port, style) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IPortStyleRenderer;
/**
 * @record
 * @struct
 */
yfiles.styles.IShapeGeometry = function() {};

/**
 * Returns the intersection for the given line with this shape's geometry.
 * @abstract
 * @param {!yfiles.geometry.Point} inner The first point of the line that is inside the shape.
 * @param {!yfiles.geometry.Point} outer The second point of the line that is outside the shape.
 * @return {!yfiles.geometry.Point} The coordinates of the intersection point, if an intersection was found.
 */
yfiles.styles.IShapeGeometry.prototype.getIntersection = function(inner, outer) {};

/**
 * Returns the outline of the shape or <code>null</code>.
 * @abstract
 * @return {!yfiles.geometry.GeneralPath} The outline or <code>null</code> if no outline can be provided.
 */
yfiles.styles.IShapeGeometry.prototype.getOutline = function() {};

/**
 * Checks whether the given coordinate is deemed to lie within the shape's geometric bounds.
 * @abstract
 * @param {!yfiles.geometry.Point} location The point to test.
 * @return {boolean} True if the point lies within the shape.
 */
yfiles.styles.IShapeGeometry.prototype.isInside = function(location) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IShapeGeometry;
/**
 * @record
 * @struct
 */
yfiles.styles.GraphOverviewSvgVisualCreator = function() {};
 /** @type {?} */
yfiles.styles.GraphOverviewSvgVisualCreator.prototype.nodeStyle;
 /** @type {?} */
yfiles.styles.GraphOverviewSvgVisualCreator.prototype.groupNodeStyle;
 /** @type {?} */
yfiles.styles.GraphOverviewSvgVisualCreator.prototype.edgeStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.GraphOverviewSvgVisualCreator.$class;

/**
 * Callback that returns and/or configures a edge style for the given edge to render.
 * @protected
 * @param {?} edge The edge to render.
 * @return {?} The style or <code>null</code>
 */
yfiles.styles.GraphOverviewSvgVisualCreator.prototype.getEdgeStyle = function(edge) {};

/**
 * Obtains the {\@link yfiles.view.IVisualCreator} for the given edge.
 * @protected
 * @param {?} context The context.
 * @param {?} edge The edge.
 * @return {?} The visual creator that is obtained from the {\@link #getEdgeStyle}'s {\@link #getVisualCreator}
 * method.
 */
yfiles.styles.GraphOverviewSvgVisualCreator.prototype.getEdgeVisualCreator = function(context, edge) {};

/**
 * Callback that returns and/or configures a group node style for the given node to render.
 * @protected
 * @param {?} node The group node to render.
 * @return {?} The style or <code>null</code>
 */
yfiles.styles.GraphOverviewSvgVisualCreator.prototype.getGroupNodeStyle = function(node) {};

/**
 * Obtains the {\@link yfiles.view.IVisualCreator} for the given group node.
 * @protected
 * @param {?} context The context.
 * @param {?} node The group node.
 * @return {?} The visual creator that is obtained from the {\@link #getGroupNodeStyle}'s {\@link #getVisualCreator}
 * method.
 */
yfiles.styles.GraphOverviewSvgVisualCreator.prototype.getGroupNodeVisualCreator = function(context, node) {};

/**
 * Callback that returns and/or configures a node style for the given node to render.
 * @protected
 * @param {?} node The node to render.
 * @return {?} The style or <code>null</code>
 */
yfiles.styles.GraphOverviewSvgVisualCreator.prototype.getNodeStyle = function(node) {};

/**
 * Obtains the {\@link yfiles.view.IVisualCreator} for the given node.
 * @protected
 * @param {?} context The context.
 * @param {?} node The node.
 * @return {?} The visual creator that is obtained from the {\@link #getNodeStyle}'s {\@link #getVisualCreator}
 * method.
 */
yfiles.styles.GraphOverviewSvgVisualCreator.prototype.getNodeVisualCreator = function(context, node) {};
/**
 * @record
 * @struct
 */
yfiles.styles.EdgeStyleBase = function() {};
 /** @type {?} */
yfiles.styles.EdgeStyleBase.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.EdgeStyleBase.$class;

/**
 * Convenience method that adds the arrows to a given container.
 * @protected
 * @param {?} context The context for the rendering.
 * @param {!SVGGElement} group The container to which the arrows should be added.
 * @param {?} edge The edge that is being rendered.
 * @param {!yfiles.geometry.GeneralPath} edgePath The edge path.
 * @param {?} sourceArrow The source arrow.
 * @param {?} targetArrow The target arrow.
 * @return {void}
 */
yfiles.styles.EdgeStyleBase.prototype.addArrows = function(context, group, edge, edgePath, sourceArrow, targetArrow) {};

/**
 * Creates a new object that is a copy of the current instance.
 * <p>
 * Immutable subclasses should consider returning <code>this</code>.
 * </p>
 * @return {!Object} A new object that is a copy of this instance using {\@link #memberwiseClone}.
 */
yfiles.styles.EdgeStyleBase.prototype.clone = function() {};

/**
 * Callback that creates the visual.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#createVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.EdgeStyleBase#renderer}.
 * </p>
 * @see yfiles.styles.EdgeStyleBase#updateVisual
 * @protected
 * @abstract
 * @param {?} context The render context.
 * @param {?} edge The edge to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.EdgeStyleBase.prototype.createVisual = function(context, edge) {};

/**
 * Convenience method that crops the edge's path at the nodes.
 * <p>
 * This implementation uses the {\@link yfiles.styles.IEdgePathCropper} instances found in the {\@link yfiles.graph.ILookup#lookup} of the
 * source and target port of the edge to perform the actual cropping.
 * </p>
 * @protected
 * @param {?} edge The edge that is being rendered.
 * @param {?} sourceArrow The source arrow instance.
 * @param {?} targetArrow The target arrow instance.
 * @param {!yfiles.geometry.GeneralPath} path The path that should be cropped.
 * @return {!yfiles.geometry.GeneralPath} The cropped path. This is can be either the same instance of the given path or a newly created instance.
 */
yfiles.styles.EdgeStyleBase.prototype.cropPath = function(edge, sourceArrow, targetArrow, path) {};

/**
 * Gets the bounds of the visual for the edge in the given context.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IBoundsProvider#getBounds} call to the instance that has been queried
 * from the {\@link yfiles.styles.EdgeStyleBase#renderer}. This implementation simply yields a {\@link yfiles.geometry.Rect rectangle} containing. the locations of the {\@link yfiles.graph.IEdge#sourcePort source port} and the {\@link yfiles.graph.IEdge#targetPort target port}
 * of the edge and the locations of all its {\@link yfiles.graph.IEdge#bends bends}.
 * </p>
 * @protected
 * @param {?} context The canvas context.
 * @param {?} edge The edge to which this style instance is assigned.
 * @return {!yfiles.geometry.Rect} The visual bounds of the visual representation.
 */
yfiles.styles.EdgeStyleBase.prototype.getBounds = function(context, edge) {};

/**
 * Gets the path of the edge.
 * @protected
 * @param {?} edge The edge.
 * @return {!yfiles.geometry.GeneralPath} The path.
 */
yfiles.styles.EdgeStyleBase.prototype.getPath = function(edge) {};

/**
 * Gets the number of segments of the edge.
 * @protected
 * @param {?} edge The edge.
 * @return {number} The segment count.
 */
yfiles.styles.EdgeStyleBase.prototype.getSegmentCount = function(edge) {};

/**
 * Convenience method that calculates the source arrow anchor and direction for a a given arrow and path.
 * @protected
 * @param {!yfiles.geometry.GeneralPath} path The path of the edge.
 * @param {?} arrow The arrow.
 * @return {!yfiles.geometry.Tangent} The anchor and directional vector of the arrow, if any exist.
 */
yfiles.styles.EdgeStyleBase.prototype.getSourceArrowAnchor = function(path, arrow) {};

/**
 * Gets the tangent to the edge at the specified ratio of a segment of the edge and the corresponding touch point.
 * @protected
 * Gets the tangent to the edge at the specified ratio and the corresponding touch point.
 * @protected
 * @param {?} edge The edge.
 * @param {number} segmentIndex_or_ratio Index of the segment of the edge. / A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of the path of the edge.
 * @param {number=} ratio A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of the segment of the edge.
 * @return {!yfiles.geometry.Tangent} The tangent, if any exists.
 */
yfiles.styles.EdgeStyleBase.prototype.getTangent = function(edge, segmentIndex_or_ratio, ratio) {};

/**
 * Convenience method that calculates the target arrow anchor and direction for a a given arrow and path.
 * @protected
 * @param {!yfiles.geometry.GeneralPath} path The path of the edge.
 * @param {?} arrow The arrow.
 * @return {!yfiles.geometry.Tangent} The anchor and directional vector of the arrow, if any exist.
 */
yfiles.styles.EdgeStyleBase.prototype.getTargetArrowAnchor = function(path, arrow) {};

/**
 * Determines whether the visual representation of the edge has been hit at the given location.
 * <p>
 * This method is called in response to a {\@link yfiles.input.IHitTestable#isHit} call to the instance that has been queried from
 * the {\@link yfiles.styles.EdgeStyleBase#renderer}.
 * </p>
 * <p>
 * This implementation returns the result of the {\@link yfiles.geometry.Point#hitsPolyline} method of class {\@link yfiles.geometry.Point}
 * with the polygonal line defined by the source port, the target port and the bends of the edge and the {\@link yfiles.view.ICanvasContext#hitTestRadius} of the
 * {\@link yfiles.view.ICanvasContext canvas context}.
 * </p>
 * @see yfiles.geometry.Point#hitsPolyline
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Point} location The point to test.
 * @param {?} edge The edge to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified edge representation is hit; <code>false</code> otherwise.
 */
yfiles.styles.EdgeStyleBase.prototype.isHit = function(context, location, edge) {};

/**
 * Determines whether the visualization for the specified edge is included in the marquee selection.
 * <p>
 * This method is called in response to a {\@link yfiles.input.IMarqueeTestable#isInBox} call to the instance that has been queried
 * from the {\@link yfiles.styles.EdgeStyleBase#renderer}.
 * </p>
 * <p>
 * This implementation returns the result of the {\@link yfiles.geometry.Rect#intersectsPolyline} method of class {\@link yfiles.geometry.Rect}
 * with the polygonal line defined by the source port, the target port and the bends of the edge.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} rectangle The marquee selection box.
 * @param {?} edge The edge to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified edge is visible is selected by the marquee rectangle; <code>false</code> otherwise.
 */
yfiles.styles.EdgeStyleBase.prototype.isInBox = function(context, rectangle, edge) {};

/**
 * Determines whether the visualization for the specified edge is visible in the context.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisibilityTestable#isVisible} call to the instance that has been
 * queried from the {\@link yfiles.styles.EdgeStyleBase#renderer}. This implementation simply tests whether the {\@link yfiles.styles.EdgeStyleBase#getBounds bounds} intersect the clip.
 * </p>
 * @protected
 * @param {?} context The canvas context.
 * @param {!yfiles.geometry.Rect} rectangle The clipping rectangle.
 * @param {?} edge The edge to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified edge is visible in the clipping rectangle; <code>false</code> otherwise.
 */
yfiles.styles.EdgeStyleBase.prototype.isVisible = function(context, rectangle, edge) {};

/**
 * Performs the {\@link yfiles.graph.ILookup#lookup} operation for the {\@link yfiles.styles.IEdgeStyleRenderer#getContext} that has been
 * queried from the {\@link yfiles.styles.EdgeStyleBase#renderer}.
 * <p>
 * This implementation yields <code>null</code> for everything but:
 * </p>
 * <ul>
 * <li>{\@link yfiles.input.IHitTestable}</li>
 * <li>{\@link yfiles.view.IVisualCreator}</li>
 * <li>{\@link yfiles.view.IBoundsProvider}</li>
 * <li>{\@link yfiles.view.IVisibilityTestable}</li>
 * <li>{\@link yfiles.input.IMarqueeTestable}</li>
 * <li>{\@link yfiles.graph.ILookup}</li>
 * <li>{\@link yfiles.styles.IPathGeometry}</li>
 * </ul>
 * <p>
 * For these interfaces an implementation will be returned that delegates to the methods in this instance.
 * </p>
 * @protected
 * @param {?} edge The edge to use for the context lookup.
 * @param {!yfiles.lang.Class} type The type to query.
 * @return {!Object} An implementation of the <code>type</code> or <code>null</code>.
 */
yfiles.styles.EdgeStyleBase.prototype.lookup = function(edge, type) {};

/**
 * Convenience method that updates the arrows in a given container.
 * @protected
 * @param {?} context The context for the rendering.
 * @param {!SVGGElement} group The container to which the arrows should be added.
 * @param {?} edge The edge that is being rendered.
 * @param {!yfiles.geometry.GeneralPath} edgePath The edge path.
 * @param {?} sourceArrow The source arrow.
 * @param {?} targetArrow The target arrow.
 * @return {void}
 */
yfiles.styles.EdgeStyleBase.prototype.updateArrows = function(context, group, edge, edgePath, sourceArrow, targetArrow) {};

/**
 * Callback that updates the visual previously created by {\@link yfiles.styles.EdgeStyleBase#createVisual}.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#updateVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.EdgeStyleBase#renderer}. This implementation simply delegates to {\@link yfiles.styles.EdgeStyleBase#createVisual} so subclasses should
 * override to improve rendering performance.
 * </p>
 * @see yfiles.styles.EdgeStyleBase#createVisual
 * @protected
 * @param {?} context The render context.
 * @param {!yfiles.view.Visual} oldVisual The visual that has been created in the call to {\@link #createVisual}.
 * @param {?} edge The edge to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.EdgeStyleBase.prototype.updateVisual = function(context, oldVisual, edge) {};
/**
 * @record
 * @struct
 */
yfiles.styles.CollapsibleNodeStyleDecorator = function() {};
 /** @type {?} */
yfiles.styles.CollapsibleNodeStyleDecorator.prototype.buttonPlacement;
 /** @type {!yfiles.geometry.Insets} */
yfiles.styles.CollapsibleNodeStyleDecorator.prototype.insets;
 /** @type {?} */
yfiles.styles.CollapsibleNodeStyleDecorator.prototype.renderer;
 /** @type {?} */
yfiles.styles.CollapsibleNodeStyleDecorator.prototype.wrapped;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.CollapsibleNodeStyleDecorator.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.CollapsibleNodeStyleDecorator.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer = function() {};
 /** @type {!yfiles.styles.CollapsibleNodeStyleDecorator} */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.node;
 /** @type {?} */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.layout;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.$class;

/**
 * Adds the toggle expansion state command to the given button visual.
 * <p>
 * This method adds event listeners for click and tap events to the given button visual that execute
 * {\@link yfiles.input.ICommand#TOGGLE_EXPANSION_STATE}. It is called by
 * {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#createButton}.
 * </p>
 * @param {!yfiles.view.SvgVisual} button The button visual to add the event listeners to.
 * @param {?} currentNode The group node whose state is to be toggled.
 * @param {?} context The context.
 * @return {void}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.addToggleExpansionStateCommand = function(button, currentNode, context) {};

/**
 * Prepares this instance for subsequent calls after the style and node have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#style} and {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#node} properies have been populated by the
 * {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getVisualCreator},
 * {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getBoundsProvider},
 * {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getHitTestable}, or {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.configure = function() {};

/**
 * Creates the button visual.
 * <p>
 * This method is called from {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#createVisual} to create the button. Custom
 * implementations can override this method to use a custom button visualization.
 * </p>
 * <p>
 * This implementation adds the {\@link yfiles.input.ICommand#TOGGLE_EXPANSION_STATE} command to the button. The created button is
 * automatically unchecked if the group node is {\@link yfiles.graph.IFoldingView#isExpanded expanded} and vice versa.
 * </p>
 * @protected
 * @param {?} context The context.
 * @param {boolean} expanded Specifies whether the button visual is created for the expanded or the collapsed state.
 * @param {!yfiles.geometry.Size} size The button size.
 * @return {!yfiles.view.SvgVisual}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.createButton = function(context, expanded, size) {};

/**
 * Callback that provides a customized {\@link yfiles.view.ISelectionIndicatorInstaller}.
 * @protected
 * @return {?} This implementation yields a {\@link } that uses
 * {\@link #SELECTION_TEMPLATE_KEY}.
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.createSelectionInstaller = function() {};

/**
 * Creates the visual for the given context.
 * <p>
 * This method uses {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#createButton} to create the togglebutton instance.
 * It will then use the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getButtonLocationParameter} to determine the
 * placement of the button and use the {\@link yfiles.styles.CollapsibleNodeStyleDecorator#wrapped wrapped style} to create the visual for the actual node.
 * </p>
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.createVisual = function(context) {};

/**
 * Delegates to the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getWrappedStyle} and takes the button into account.
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure} and
 * returns <code>this</code>.
 * @see yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getBounds
 * @param {?} node The node to retrieve the bounds provider for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Yields the {\@link yfiles.styles.CollapsibleNodeStyleDecorator#buttonPlacement} for the current {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#style}
 * @protected
 * @return {?}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getButtonLocationParameter = function() {};

/**
 * Returns the size of new buttons.
 * @protected
 * @return {!yfiles.geometry.Size} The size of new buttons
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getButtonSize = function() {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure} and
 * returns <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call
 * {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure}, instead subclasses should ensure that in the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#lookup}
 * method call they should call {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure} only if needed, i.e. if they
 * decide to return <code>this</code> or an instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#lookup
 * @param {?} node The node to query the context for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getContext = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure} and
 * returns <code>this</code>.
 * @see yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#isHit
 * @param {?} node The node to query hit test with. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getHitTestable = function(node, style) {};

/**
 * Delegates to the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getWrappedStyle}.
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getIntersection = function(inner, outer) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure} and
 * returns <code>this</code>.
 * @see yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#isInBox
 * @param {?} node The node to query marquee intersection tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 * Delegates to the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getWrappedStyle}.
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getOutline = function() {};

/**
 * Configures the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#style} and {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#node} properties, calls {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#isInside
 * @see yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getIntersection
 * @param {?} node The node to retrieve the shape geometry for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure} and
 * returns <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call
 * {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure}. If the subclass implementation depends on this instance
 * to be configured, it needs to call <code>Configure</code> in {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#isVisible
 * @param {?} node The node to query visibility tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#configure} and
 * returns <code>this</code>.
 * @see yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#createVisual
 * @see yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#updateVisual
 * @param {?} node The node to retrieve the {\@link } for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getVisualCreator = function(node, style) {};

/**
 * Yields the {\@link yfiles.styles.CollapsibleNodeStyleDecorator#wrapped} property for the current {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#style}
 * @protected
 * @return {?}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.getWrappedStyle = function() {};

/**
 * Delegates to the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getWrappedStyle} and checks the button.
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.isHit = function(context, location) {};

/**
 * Delegates to the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getWrappedStyle}.
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 * Delegates to the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getWrappedStyle}.
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.isInside = function(location) {};

/**
 * Delegates to the {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#getWrappedStyle}.
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.lookup = function(type) {};

/**
 * Updates the button visual.
 * <p>
 * This method is called from {\@link yfiles.styles.CollapsibleNodeStyleDecoratorRenderer#updateVisual} to update an existing button
 * or to create a new one. Custom implementations can override this method to use a custom button visualization.
 * </p>
 * @protected
 * @param {?} context The context.
 * @param {boolean} expanded Specifies whether the button visual is updated for the expanded or the collapsed state.
 * @param {!yfiles.geometry.Size} size The button size.
 * @param {!yfiles.view.Visual} oldButton The old button visual.
 * @return {!yfiles.view.SvgVisual}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.updateButton = function(context, expanded, size, oldButton) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.CollapsibleNodeStyleDecoratorRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.LabelStyleBase = function() {};
 /** @type {?} */
yfiles.styles.LabelStyleBase.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.LabelStyleBase.$class;

/**
 * Creates a new object that is a copy of the current instance.
 * <p>
 * Immutable subclasses should consider returning <code>this</code>.
 * </p>
 * @return {!Object} A new object that is a copy of this instance using {\@link #memberwiseClone}.
 */
yfiles.styles.LabelStyleBase.prototype.clone = function() {};

/**
 * Creates a transform matrix that can be applied to a {\@link yfiles.view.Visual} to arrange it according to the given <code>layout</code> and <code>autoFlip</code>
 * rule.
 * @param {?} layout The layout used to create the transform matrix.
 * @param {boolean} autoFlip Whether to automatically flip the mtrix by 180 degrees, if the result would be pointing downwards.
 * @return {!yfiles.geometry.Matrix} The transform matrix.
 */
yfiles.styles.LabelStyleBase.createLayoutTransform = function(layout, autoFlip) {};

/**
 * Callback that creates the visual.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#createVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.LabelStyleBase#renderer}.
 * </p>
 * @see yfiles.styles.LabelStyleBase#updateVisual
 * @protected
 * @abstract
 * @param {?} context The render context.
 * @param {?} label The label to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.LabelStyleBase.prototype.createVisual = function(context, label) {};

/**
 * Gets the bounds of the visual for the label in the given context.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IBoundsProvider#getBounds} call to the instance that has been queried
 * from the {\@link yfiles.styles.LabelStyleBase#renderer}.
 * </p>
 * <p>
 * This implementation simply yields the {\@link yfiles.geometry.IOrientedRectangle#bounds bounds} of the {\@link yfiles.graph.ILabel#layout layout} of the given label.
 * </p>
 * @protected
 * @param {?} context The canvas context.
 * @param {?} label The label to which this style instance is assigned.
 * @return {!yfiles.geometry.Rect} The visual bounds of the visual representation.
 */
yfiles.styles.LabelStyleBase.prototype.getBounds = function(context, label) {};

/**
 * Callback that returns the preferred {\@link yfiles.geometry.Size size} of the label.
 * @protected
 * @abstract
 * @param {?} label The label to which this style instance is assigned.
 * @return {!yfiles.geometry.Size} The preferred size.
 */
yfiles.styles.LabelStyleBase.prototype.getPreferredSize = function(label) {};

/**
 * Determines whether the visual representation of the label has been hit at the given location.
 * <p>
 * This method is called in response to a {\@link yfiles.input.IHitTestable#isHit} call to the instance that has been queried from
 * the {\@link yfiles.styles.LabelStyleBase#renderer}.
 * </p>
 * <p>
 * This implementation returns the result of the {\@link yfiles.geometry.IOrientedRectangle#hits} method invoked for the {\@link yfiles.graph.ILabel#layout layout} of
 * the label, the given {\@link yfiles.geometry.Point point} and the {\@link yfiles.view.ICanvasContext#hitTestRadius hit test radius} of the {\@link yfiles.view.ICanvasContext canvas context}.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Point} location The point to test.
 * @param {?} label The label to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified label representation is hit; <code>false</code> otherwise.
 */
yfiles.styles.LabelStyleBase.prototype.isHit = function(context, location, label) {};

/**
 * Determines whether the visualization for the specified label is included in the marquee selection.
 * <p>
 * This method is called in response to a {\@link yfiles.input.IMarqueeTestable#isInBox} call to the instance that has been queried
 * from the {\@link yfiles.styles.LabelStyleBase#renderer}.
 * </p>
 * <p>
 * This implementation returns the result of the {\@link yfiles.geometry.Rect#intersects} method invoked on <code>rectangle</code> for the {\@link yfiles.graph.ILabel#layout layout}
 * of the label and the <code>context</code>.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} rectangle The marquee selection box.
 * @param {?} label The label to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified label is visible is selected by the marquee rectangle; <code>false</code> otherwise.
 */
yfiles.styles.LabelStyleBase.prototype.isInBox = function(context, rectangle, label) {};

/**
 * Determines whether the visualization for the specified label is visible in the context.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisibilityTestable#isVisible} call to the instance that has been
 * queried from the {\@link yfiles.styles.LabelStyleBase#renderer}.
 * </p>
 * <p>
 * This implementation simply tests whether the {\@link yfiles.styles.LabelStyleBase#getBounds bounds} intersect the clip.
 * </p>
 * @protected
 * @param {?} context The canvas context.
 * @param {!yfiles.geometry.Rect} rectangle The clipping rectangle.
 * @param {?} label The label to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified label is visible in the clipping rectangle; <code>false</code> otherwise.
 */
yfiles.styles.LabelStyleBase.prototype.isVisible = function(context, rectangle, label) {};

/**
 * Performs the {\@link yfiles.graph.ILookup#lookup} operation for the {\@link yfiles.styles.ILabelStyleRenderer#getContext} that has been
 * queried from the {\@link yfiles.styles.LabelStyleBase#renderer}.
 * <p>
 * This implementation yields <code>null</code> for everything but:
 * </p>
 * <ul>
 * <li>{\@link yfiles.input.IHitTestable}</li>
 * <li>{\@link yfiles.view.IVisualCreator}</li>
 * <li>{\@link yfiles.view.IBoundsProvider}</li>
 * <li>{\@link yfiles.view.IVisibilityTestable}</li>
 * <li>{\@link yfiles.input.IMarqueeTestable}</li>
 * <li>{\@link yfiles.graph.ILookup}</li>
 * </ul>
 * <p>
 * For these interfaces an implementation will be returned that delegates to the methods in this instance.
 * </p>
 * @protected
 * @param {?} label The label to use for the context lookup.
 * @param {!yfiles.lang.Class} type The type to query.
 * @return {!Object} An implementation of the <code>type</code> or <code>null</code>.
 */
yfiles.styles.LabelStyleBase.prototype.lookup = function(label, type) {};

/**
 * Callback that updates the visual previously created by {\@link yfiles.styles.LabelStyleBase#createVisual}.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#updateVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.LabelStyleBase#renderer}. This implementation simply delegates to {\@link yfiles.styles.LabelStyleBase#createVisual} so subclasses
 * should override to improve rendering performance.
 * </p>
 * @see yfiles.styles.LabelStyleBase#createVisual
 * @protected
 * @param {?} context The render context.
 * @param {!yfiles.view.Visual} oldVisual The visual that has been created in the call to {\@link #createVisual}.
 * @param {?} label The label to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.LabelStyleBase.prototype.updateVisual = function(context, oldVisual, label) {};
/**
 * @record
 * @struct
 */
yfiles.styles.NodeStyleBase = function() {};
 /** @type {?} */
yfiles.styles.NodeStyleBase.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.NodeStyleBase.$class;

/**
 * Creates a new object that is a copy of the current instance.
 * <p>
 * Immutable subclasses should consider returning <code>this</code>.
 * </p>
 * @return {!Object} A new object that is a copy of this instance using {\@link #memberwiseClone}.
 */
yfiles.styles.NodeStyleBase.prototype.clone = function() {};

/**
 * Callback that creates the visual.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#createVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.NodeStyleBase#renderer}.
 * </p>
 * @see yfiles.styles.NodeStyleBase#updateVisual
 * @protected
 * @abstract
 * @param {?} context The render context.
 * @param {?} node The node to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.NodeStyleBase.prototype.createVisual = function(context, node) {};

/**
 * Gets the bounds of the visual for the node in the given context.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IBoundsProvider#getBounds} call to the instance that has been queried
 * from the {\@link yfiles.styles.NodeStyleBase#renderer}. This implementation simply yields the {\@link yfiles.graph.INode#layout}.
 * </p>
 * @protected
 * @param {?} context The canvas context.
 * @param {?} node The node to which this style instance is assigned.
 * @return {!yfiles.geometry.Rect} The visual bounds of the visual representation.
 */
yfiles.styles.NodeStyleBase.prototype.getBounds = function(context, node) {};

/**
 * Gets the intersection of a line with the visual representation of the node.
 * <p>
 * This method is called in response to a {\@link yfiles.styles.IShapeGeometry#getIntersection} call to the instance that has been
 * queried from the {\@link yfiles.styles.NodeStyleBase#renderer}. This implementation simply uses the {\@link yfiles.styles.NodeStyleBase#getOutline outline} to determine the intersection or the {\@link yfiles.graph.INode#layout} if the outline is
 * <code>null</code>. If it is feasible to determine the intersection point for the current shape, this method should be implemented in
 * addition to {\@link yfiles.styles.NodeStyleBase#getOutline} to improve performance.
 * </p>
 * @see yfiles.styles.NodeStyleBase#isInside
 * @protected
 * @param {?} node The node to which this style instance is assigned.
 * @param {!yfiles.geometry.Point} inner The coordinates of a point lying {\@link #isInside inside} the shape.
 * @param {!yfiles.geometry.Point} outer The coordinates of a point lying outside the shape.
 * @return {!yfiles.geometry.Point} The intersection point if one has been found or <code>null</code>, otherwise.
 */
yfiles.styles.NodeStyleBase.prototype.getIntersection = function(node, inner, outer) {};

/**
 * Gets the outline of the visual style.
 * <p>
 * This implementation yields <code>null</code> to indicate that the {\@link yfiles.graph.INode#layout} depicts the outline. Implementing this method influences the
 * behavior of {\@link yfiles.styles.NodeStyleBase#isInside} and {\@link yfiles.styles.NodeStyleBase#getIntersection} since the default
 * implementations delegate to it.
 * </p>
 * @protected
 * @param {?} node The node to which this style instance is assigned.
 * @return {!yfiles.geometry.GeneralPath} The outline of the visual representation or <code>null</code>.
 */
yfiles.styles.NodeStyleBase.prototype.getOutline = function(node) {};

/**
 * Determines whether the visual representation of the node has been hit at the given location.
 * <p>
 * This method is called in response to a {\@link yfiles.input.IHitTestable#isHit} call to the instance that has been queried from
 * the {\@link yfiles.styles.NodeStyleBase#renderer}. This implementation uses the {\@link yfiles.styles.NodeStyleBase#getOutline outline} to determine whether the node has been hit.
 * </p>
 * @protected
 * @param {?} context The canvas context.
 * @param {!yfiles.geometry.Point} location The point to test.
 * @param {?} node The node to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified node representation is hit; <code>false</code> otherwise.
 */
yfiles.styles.NodeStyleBase.prototype.isHit = function(context, location, node) {};

/**
 * Determines whether the visualization for the specified node is included in the marquee selection.
 * <p>
 * This method is called in response to a {\@link yfiles.input.IMarqueeTestable#isInBox} call to the instance that has been queried
 * from the {\@link yfiles.styles.NodeStyleBase#renderer}. This implementation simply tests whether the {\@link yfiles.styles.NodeStyleBase#getBounds bounds} intersect the marquee box.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} rectangle The marquee selection box.
 * @param {?} node The node to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified node is visible is selected by the marquee rectangle; <code>false</code> otherwise.
 */
yfiles.styles.NodeStyleBase.prototype.isInBox = function(context, rectangle, node) {};

/**
 * Determines whether the provided point is geometrically inside the visual bounds of the node.
 * <p>
 * This method is called in response to a {\@link yfiles.styles.IShapeGeometry#isInside} call to the instance that has been queried
 * from the {\@link yfiles.styles.NodeStyleBase#renderer}. This implementation simply uses the {\@link yfiles.styles.NodeStyleBase#getOutline outline} to determine whether the point is contained or the {\@link yfiles.graph.INode#layout} if the
 * outline is <code>null</code>. If it is feasible to determine whether a given point lies inside the shape, this method should be
 * implemented in addition to {\@link yfiles.styles.NodeStyleBase#getOutline} to improve performance.
 * </p>
 * @protected
 * @param {?} node The node to which this style instance is assigned.
 * @param {!yfiles.geometry.Point} location The point to test.
 * @return {boolean} Whether the point is considered to lie inside the shape.
 */
yfiles.styles.NodeStyleBase.prototype.isInside = function(node, location) {};

/**
 * Determines whether the visualization for the specified node is visible in the context.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisibilityTestable#isVisible} call to the instance that has been
 * queried from the {\@link yfiles.styles.NodeStyleBase#renderer}. This implementation simply tests whether the {\@link yfiles.styles.NodeStyleBase#getBounds bounds} intersect the clip.
 * </p>
 * @protected
 * @param {?} context The canvas context.
 * @param {!yfiles.geometry.Rect} rectangle The clipping rectangle.
 * @param {?} node The node to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified node is visible in the clipping rectangle; <code>false</code> otherwise.
 */
yfiles.styles.NodeStyleBase.prototype.isVisible = function(context, rectangle, node) {};

/**
 * Performs the {\@link yfiles.graph.ILookup#lookup} operation for the {\@link yfiles.styles.INodeStyleRenderer#getContext} that has been
 * queried from the {\@link yfiles.styles.NodeStyleBase#renderer}.
 * <p>
 * This implementation yields <code>null</code> for everything but:
 * </p>
 * <ul>
 * <li>{\@link yfiles.input.IHitTestable}</li>
 * <li>{\@link yfiles.view.IVisualCreator}</li>
 * <li>{\@link yfiles.view.IBoundsProvider}</li>
 * <li>{\@link yfiles.view.IVisibilityTestable}</li>
 * <li>{\@link yfiles.input.IMarqueeTestable}</li>
 * <li>{\@link yfiles.graph.ILookup}</li>
 * <li>{\@link yfiles.styles.IShapeGeometry}</li>
 * </ul>
 * <p>
 * For these interfaces an implementation will be returned that delegates to the methods in this instance.
 * </p>
 * @protected
 * @param {?} node The node to use for the context lookup.
 * @param {!yfiles.lang.Class} type The type to query.
 * @return {!Object} An implementation of the <code>type</code> or <code>null</code>.
 */
yfiles.styles.NodeStyleBase.prototype.lookup = function(node, type) {};

/**
 * Callback that updates the visual previously created by {\@link yfiles.styles.NodeStyleBase#createVisual}.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#updateVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.NodeStyleBase#renderer}. This implementation simply delegates to {\@link yfiles.styles.NodeStyleBase#createVisual} so subclasses should
 * override to improve rendering performance.
 * </p>
 * @see yfiles.styles.NodeStyleBase#createVisual
 * @protected
 * @param {?} context The render context.
 * @param {!yfiles.view.Visual} oldVisual The visual that has been created in the call to {\@link #createVisual}.
 * @param {?} node The node to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.NodeStyleBase.prototype.updateVisual = function(context, oldVisual, node) {};
/**
 * @record
 * @struct
 */
yfiles.styles.NodeStyleLabelStyleAdapter = function() {};
 /** @type {?} */
yfiles.styles.NodeStyleLabelStyleAdapter.prototype.renderer;
 /** @type {?} */
yfiles.styles.NodeStyleLabelStyleAdapter.prototype.nodeStyle;
 /** @type {?} */
yfiles.styles.NodeStyleLabelStyleAdapter.prototype.labelStyle;
 /** @type {boolean} */
yfiles.styles.NodeStyleLabelStyleAdapter.prototype.autoFlip;
 /** @type {!yfiles.geometry.Insets} */
yfiles.styles.NodeStyleLabelStyleAdapter.prototype.labelStyleInsets;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.NodeStyleLabelStyleAdapter.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.NodeStyleLabelStyleAdapter.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.NodeStylePortStyleAdapter = function() {};
 /** @type {?} */
yfiles.styles.NodeStylePortStyleAdapter.prototype.renderer;
 /** @type {?} */
yfiles.styles.NodeStylePortStyleAdapter.prototype.nodeStyle;
 /** @type {!yfiles.geometry.Size} */
yfiles.styles.NodeStylePortStyleAdapter.prototype.renderSize;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.NodeStylePortStyleAdapter.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.NodeStylePortStyleAdapter.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.PortStyleBase = function() {};
 /** @type {?} */
yfiles.styles.PortStyleBase.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.PortStyleBase.$class;

/**
 * Creates a new object that is a copy of the current instance.
 * <p>
 * Immutable subclasses should consider returning <code>this</code>.
 * </p>
 * @return {!Object} A new object that is a copy of this instance using {\@link #memberwiseClone}.
 */
yfiles.styles.PortStyleBase.prototype.clone = function() {};

/**
 * Callback that creates the visual.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#createVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.PortStyleBase#renderer}.
 * </p>
 * @see yfiles.styles.PortStyleBase#updateVisual
 * @protected
 * @abstract
 * @param {?} context The render context.
 * @param {?} port The port to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.PortStyleBase.prototype.createVisual = function(context, port) {};

/**
 * Callback that returns the bounds of the visual for the port in the given context.
 * @protected
 * @abstract
 * @param {?} context The canvas context.
 * @param {?} port The port to which this style instance is assigned.
 * @return {!yfiles.geometry.Rect} The visual bounds of the visual representation.
 */
yfiles.styles.PortStyleBase.prototype.getBounds = function(context, port) {};

/**
 * Determines whether the visual representation of the port has been hit at the given location.
 * <p>
 * This method is called in response to a {\@link yfiles.input.IHitTestable#isHit} call to the instance that has been queried from
 * the {\@link yfiles.styles.PortStyleBase#renderer}.
 * </p>
 * <p>
 * This implementation uses the {\@link yfiles.styles.PortStyleBase#getBounds bounds} to determine whether the port has been hit.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Point} location The point to test.
 * @param {?} port The port to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified port representation is hit; <code>false</code> otherwise.
 */
yfiles.styles.PortStyleBase.prototype.isHit = function(context, location, port) {};

/**
 * Determines whether the visualization for the specified port is included in the marquee selection.
 * <p>
 * This method is called in response to a {\@link yfiles.input.IMarqueeTestable#isInBox} call to the instance that has been queried
 * from the {\@link yfiles.styles.PortStyleBase#renderer}.
 * </p>
 * <p>
 * This implementation simply tests whether the {\@link yfiles.styles.PortStyleBase#getBounds bounds} intersect the marquee box.
 * </p>
 * @protected
 * @param {?} context The input mode context.
 * @param {!yfiles.geometry.Rect} rectangle The marquee selection box.
 * @param {?} port The port to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified port is visible is selected by the marquee rectangle; <code>false</code> otherwise.
 */
yfiles.styles.PortStyleBase.prototype.isInBox = function(context, rectangle, port) {};

/**
 * Determines whether the visualization for the specified port is visible in the context.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisibilityTestable#isVisible} call to the instance that has been
 * queried from the {\@link yfiles.styles.PortStyleBase#renderer}. This implementation simply tests whether the {\@link yfiles.styles.PortStyleBase#getBounds bounds} intersect the clip.
 * </p>
 * @protected
 * @param {?} context The canvas context.
 * @param {!yfiles.geometry.Rect} rectangle The clipping rectangle.
 * @param {?} port The port to which this style instance is assigned.
 * @return {boolean} <code>true</code> if the specified port is visible in the clipping rectangle; <code>false</code> otherwise.
 */
yfiles.styles.PortStyleBase.prototype.isVisible = function(context, rectangle, port) {};

/**
 * Performs the {\@link yfiles.graph.ILookup#lookup} operation for the {\@link yfiles.styles.IPortStyleRenderer#getContext} that has been
 * queried from the {\@link yfiles.styles.PortStyleBase#renderer}.
 * <p>
 * This implementation yields <code>null</code> for everything but:
 * </p>
 * <ul>
 * <li>{\@link yfiles.input.IHitTestable}</li>
 * <li>{\@link yfiles.view.IVisualCreator}</li>
 * <li>{\@link yfiles.view.IBoundsProvider}</li>
 * <li>{\@link yfiles.view.IVisibilityTestable}</li>
 * <li>{\@link yfiles.input.IMarqueeTestable}</li>
 * <li>{\@link yfiles.graph.ILookup}</li>
 * </ul>
 * <p>
 * For these interfaces an implementation will be returned that delegates to the methods in this instance.
 * </p>
 * @protected
 * @param {?} port The port to use for the context lookup.
 * @param {!yfiles.lang.Class} type The type to query.
 * @return {!Object} An implementation of the <code>type</code> or <code>null</code>.
 */
yfiles.styles.PortStyleBase.prototype.lookup = function(port, type) {};

/**
 * Callback that updates the visual previously created by {\@link yfiles.styles.PortStyleBase#createVisual}.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#updateVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.PortStyleBase#renderer}. This implementation simply delegates to {\@link yfiles.styles.PortStyleBase#createVisual} so subclasses should
 * override to improve rendering performance.
 * </p>
 * @see yfiles.styles.PortStyleBase#createVisual
 * @protected
 * @param {?} context The render context.
 * @param {!yfiles.view.Visual} oldVisual The visual that has been created in the call to {\@link #createVisual}.
 * @param {?} port The port to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.PortStyleBase.prototype.updateVisual = function(context, oldVisual, port) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TextRenderSupport = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TextRenderSupport.$class;

/**
 * Add the text content to the provided SVG <code>text</code> element.
 * Add the text content to the provided SVG <code>text</code> element.
 * @param {!SVGTextElement|{targetElement: !SVGTextElement, text: string, font: !yfiles.view.Font, maximumSize: !yfiles.geometry.Size, wrapping: yfiles.view.TextWrapping, measurePolicy: yfiles.styles.TextMeasurePolicy}} targetElement_or_options An SVG text element to add the provided text to (either as <code>textContent</code>, or by appending <code>tspan</code> elements).
 * @param {string=} text The text content to add to the provided text element (may contain newline characters).
 * @param {!yfiles.view.Font=} font The {\@link } that defines the font properties to apply to the added text.
 * @param {!yfiles.geometry.Size=} maximumSize The bounds that shouldn't be exceeded when placing the text; <code>null</code> or not provided means unbound.
 * @param {yfiles.view.TextWrapping=} wrapping
 * @param {yfiles.styles.TextMeasurePolicy=} measurePolicy
 * @return {string} The text that was actually placed in the <code>targetElement</code>.
 */
yfiles.styles.TextRenderSupport.addText = function(targetElement_or_options, text, font, maximumSize, wrapping, measurePolicy) {};

/**
 * Calculate the width and height required to render the provided text using the provided {\@link yfiles.view.Font}.
 * @param {string} text The text that should be measured.
 * @param {!yfiles.view.Font} font The {\@link } to apply to the text before measuring.
 * @param {yfiles.styles.TextMeasurePolicy=} measurePolicy
 * @return {!yfiles.geometry.Size} The measured text size
 */
yfiles.styles.TextRenderSupport.measureText = function(text, font, measurePolicy) {};

/** @const */
yfiles.styles.TextMeasurePolicy = {};
/** @const {number} */
yfiles.styles.TextMeasurePolicy.AUTOMATIC;
/** @const {number} */
yfiles.styles.TextMeasurePolicy.SVG;
/** @const {number} */
yfiles.styles.TextMeasurePolicy.CANVAS;
/**
 * @record
 * @struct
 */
yfiles.styles.DefaultLabelStyle = function() {};
 /** @type {!yfiles.view.Fill} */
yfiles.styles.DefaultLabelStyle.prototype.backgroundFill;
 /** @type {yfiles.view.VerticalTextAlignment} */
yfiles.styles.DefaultLabelStyle.prototype.verticalTextAlignment;
 /** @type {yfiles.view.HorizontalTextAlignment} */
yfiles.styles.DefaultLabelStyle.prototype.horizontalTextAlignment;
 /** @type {yfiles.view.TextWrapping} */
yfiles.styles.DefaultLabelStyle.prototype.wrapping;
 /** @type {boolean} */
yfiles.styles.DefaultLabelStyle.prototype.clipText;
 /** @type {!yfiles.view.Stroke} */
yfiles.styles.DefaultLabelStyle.prototype.backgroundStroke;
 /** @type {?} */
yfiles.styles.DefaultLabelStyle.prototype.renderer;
 /** @type {!yfiles.view.Font} */
yfiles.styles.DefaultLabelStyle.prototype.font;
 /** @type {boolean} */
yfiles.styles.DefaultLabelStyle.prototype.autoFlip;
 /** @type {!yfiles.view.Fill} */
yfiles.styles.DefaultLabelStyle.prototype.textFill;
 /** @type {number} */
yfiles.styles.DefaultLabelStyle.prototype.textSize;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.DefaultLabelStyle.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.DefaultLabelStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.IconLabelStyle = function() {};
 /** @type {string} */
yfiles.styles.IconLabelStyle.prototype.icon;
 /** @type {!yfiles.geometry.Size} */
yfiles.styles.IconLabelStyle.prototype.iconSize;
 /** @type {?} */
yfiles.styles.IconLabelStyle.prototype.iconPlacement;
 /** @type {?} */
yfiles.styles.IconLabelStyle.prototype.wrapped;
 /** @type {!yfiles.geometry.Insets} */
yfiles.styles.IconLabelStyle.prototype.wrappedInsets;
 /** @type {?} */
yfiles.styles.IconLabelStyle.prototype.renderer;
 /** @type {boolean} */
yfiles.styles.IconLabelStyle.prototype.autoFlip;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.IconLabelStyle.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.IconLabelStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.DefaultLabelStyleRenderer = function() {};
 /** @type {?} */
yfiles.styles.DefaultLabelStyleRenderer.prototype.layout;
 /** @type {!yfiles.styles.DefaultLabelStyle} */
yfiles.styles.DefaultLabelStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.DefaultLabelStyleRenderer.prototype.label;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.DefaultLabelStyleRenderer.$class;

/**
 * Add the text content to the provided SVG text element.
 * @protected
 * @param {!SVGTextElement} textElement An SVG text element to add the provided text to.
 * @param {!yfiles.view.Font} font The {\@link } that defines the font properties to apply to the added text.
 * @param {string} text The text content to add to the provided text element (may contain newline characters).
 * @param {!yfiles.geometry.Size} maxSize The bounds that shouldn't be exceeded when placing the text; <code>null</code> or not provided means unbound.
 * @param {yfiles.view.TextWrapping} wrapping The {\@link } policy to apply when the text exceeds the provided <code>maxSize</code>.
 * @return {string}
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.addTextElements = function(textElement, font, text, maxSize, wrapping) {};

/**
 * Prepares this instance for subsequent calls after the style and label have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.DefaultLabelStyleRenderer#style} and {\@link yfiles.styles.DefaultLabelStyleRenderer#label} properties have been populated by the
 * {\@link yfiles.styles.DefaultLabelStyleRenderer#getVisualCreator}, {\@link yfiles.styles.DefaultLabelStyleRenderer#getBoundsProvider},
 * {\@link yfiles.styles.DefaultLabelStyleRenderer#getHitTestable}, or {\@link yfiles.styles.DefaultLabelStyleRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * <p>
 * Stores the {\@link yfiles.graph.ILabel#layout layout} into {\@link yfiles.styles.DefaultLabelStyleRenderer#layout}. Subclasses which to override this method should call the base implementation.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.configure = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.createVisual = function(context) {};

/**
 *
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, calls {\@link yfiles.styles.DefaultLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.DefaultLabelStyleRenderer#getBounds
 * @param {?} label The label to retrieve the bounds provider for. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getBoundsProvider = function(label, style) {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, does <b>not</b> call {\@link yfiles.styles.DefaultLabelStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.DefaultLabelStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.DefaultLabelStyleRenderer#lookup} method call they should call
 * {\@link yfiles.styles.DefaultLabelStyleRenderer#configure} only if needed, i.e. if they decide to return <code>this</code> or an instance that
 * depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.DefaultLabelStyleRenderer#lookup
 * @param {?} label The label to query the context for. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getContext = function(label, style) {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, calls {\@link yfiles.styles.DefaultLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.DefaultLabelStyleRenderer#isHit
 * @param {?} label The label to query hit test with. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getHitTestable = function(label, style) {};

/**
 * Determines how the text should be aligned within the assigned label bounds.
 * @protected
 * @return {yfiles.view.HorizontalTextAlignment} This value as obtained from the style.
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getHorizontalTextAlignment = function() {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, calls {\@link yfiles.styles.DefaultLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.DefaultLabelStyleRenderer#isInBox
 * @param {?} label The label to query marquee intersection tests. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getMarqueeTestable = function(label, style) {};

/**
 *
 * @param {?} label
 * @param {?} style
 * @return {!yfiles.geometry.Size}
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getPreferredSize = function(label, style) {};

/**
 * Calculates the preferred size given the current state of the renderer.
 * @protected
 * @return {!yfiles.geometry.Size} The size as suggested by this renderer.
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getPreferredSizeCore = function() {};

/**
 * Determines how the text should be aligned vertically within the assigned label bounds.
 * @protected
 * @return {yfiles.view.VerticalTextAlignment} This value as obtained from the style.
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getVerticalTextAlignment = function() {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, does <b>not</b> call {\@link yfiles.styles.DefaultLabelStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.DefaultLabelStyleRenderer#configure}. If
 * the subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.DefaultLabelStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.DefaultLabelStyleRenderer#isVisible
 * @param {?} label The label to query visibility tests. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getVisibilityTestable = function(label, style) {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, calls {\@link yfiles.styles.DefaultLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.DefaultLabelStyleRenderer#createVisual
 * @see yfiles.styles.DefaultLabelStyleRenderer#updateVisual
 * @param {?} label The label to retrieve the {\@link } for. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getVisualCreator = function(label, style) {};

/**
 * Determines how the text should be trimmed to fit the assigned label bounds.
 * @protected
 * @return {yfiles.view.TextWrapping} This value as obtained from the style.
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.getWrapping = function() {};

/**
 * Delegates to {\@link yfiles.styles.DefaultLabelStyle#autoFlip}
 * @protected
 * @return {boolean} Whether to flip the drawing if it is upside down.
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.isAutoFlip = function() {};

/**
 * Determines whether text should be forced to be clipped inside the rectangle.
 * @protected
 * @return {boolean} This value as obtained from the style.
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.isClippingText = function() {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.isHit = function(context, location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 * Uses the {\@link yfiles.graph.ILabel#layout} to determine whether the clip intersects.
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 * Implements the {\@link yfiles.graph.ILookup} interface.
 * <p>
 * This method will be used by default if {\@link yfiles.styles.DefaultLabelStyleRenderer#getContext} has been queried for a lookup
 * implementation. Note that it cannot be assumed that {\@link yfiles.styles.DefaultLabelStyleRenderer#configure} has already been
 * invoked. However, normally {\@link yfiles.styles.DefaultLabelStyleRenderer#label} and {\@link yfiles.styles.DefaultLabelStyleRenderer#style} will be correctly configured if invoked directly after <code>GetContext</code>. Subclass
 * implementations should make sure to configure this instance before they return <code>this</code> as a result of a successful lookup.
 * This implementation will check if <code>type.IsInstanceOfType(this)</code> and will call {\@link yfiles.styles.DefaultLabelStyleRenderer#configure}
 * on success and return <code>this</code>.
 * </p>
 * @param {!yfiles.lang.Class} type The type to query for.
 * @return {!Object} An implementation or <code>null</code>.
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.lookup = function(type) {};

/**
 * Calculate the width and height required to render the provided text using the provided {\@link yfiles.view.Font}.
 * @protected
 * @param {string} text The text that should be measured.
 * @param {!yfiles.view.Font} font The {\@link } to apply to the text before measuring.
 * @return {!yfiles.geometry.Size} The text size.
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.measureText = function(text, font) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.DefaultLabelStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.IconLabelStyleRenderer = function() {};
 /** @type {!yfiles.styles.IconLabelStyle} */
yfiles.styles.IconLabelStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.IconLabelStyleRenderer.prototype.label;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.IconLabelStyleRenderer.$class;

/**
 *
 * @protected
 * @return {void}
 */
yfiles.styles.IconLabelStyleRenderer.prototype.configure = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.IconLabelStyleRenderer.prototype.createVisual = function(context) {};

/**
 *
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, calls {\@link yfiles.styles.IconLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.IconLabelStyleRenderer#getBounds
 * @param {?} label The label to retrieve the bounds provider for. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getBoundsProvider = function(label, style) {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, does <b>not</b> call {\@link yfiles.styles.IconLabelStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.IconLabelStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.IconLabelStyleRenderer#lookup} method call they should call {\@link yfiles.styles.IconLabelStyleRenderer#configure}
 * only if needed, i.e. if they decide to return <code>this</code> or an instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.IconLabelStyleRenderer#lookup
 * @param {?} label The label to query the context for. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getContext = function(label, style) {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, calls {\@link yfiles.styles.IconLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.IconLabelStyleRenderer#isHit
 * @param {?} label The label to query hit test with. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getHitTestable = function(label, style) {};

/**
 * Retrieves the {\@link yfiles.styles.IconLabelStyle#icon} from the {\@link yfiles.styles.IconLabelStyleRenderer#style}.
 * @protected
 * @return {string} The icon.
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getIcon = function() {};

/**
 * Retrieves the {\@link yfiles.styles.IconLabelStyle#iconPlacement} from the {\@link yfiles.styles.IconLabelStyleRenderer#style}.
 * @protected
 * @return {?} The placement parameter.
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getIconPlacement = function() {};

/**
 * Gets the size of the icon from the {\@link yfiles.styles.IconLabelStyle#iconSize} property.
 * @protected
 * @return {!yfiles.geometry.Size} The size to use for the icon.
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getIconSize = function() {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, calls {\@link yfiles.styles.IconLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.IconLabelStyleRenderer#isInBox
 * @param {?} label The label to query marquee intersection tests. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getMarqueeTestable = function(label, style) {};

/**
 *
 * @param {?} label
 * @param {?} style
 * @return {!yfiles.geometry.Size}
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getPreferredSize = function(label, style) {};

/**
 * Calculates the preferred size given the current state of the renderer.
 * @protected
 * @return {!yfiles.geometry.Size} The size as suggested by this renderer.
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getPreferredSizeCore = function() {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, does <b>not</b> call {\@link yfiles.styles.IconLabelStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.IconLabelStyleRenderer#configure}. If the
 * subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.IconLabelStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.IconLabelStyleRenderer#isVisible
 * @param {?} label The label to query visibility tests. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getVisibilityTestable = function(label, style) {};

/**
 * Configures the <code>style</code> and <code>label</code> parameters, calls {\@link yfiles.styles.IconLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.IconLabelStyleRenderer#createVisual
 * @see yfiles.styles.IconLabelStyleRenderer#updateVisual
 * @param {?} label The label to retrieve the {\@link } for. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getVisualCreator = function(label, style) {};

/**
 * Retrieves the {\@link yfiles.styles.IconLabelStyle#wrapped} from the {\@link yfiles.styles.IconLabelStyleRenderer#style}.
 * @protected
 * @return {?} The style.
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getWrappedStyle = function() {};

/**
 * Retrieves the {\@link yfiles.styles.IconLabelStyle#wrappedInsets} from the {\@link yfiles.styles.IconLabelStyleRenderer#style}.
 * @protected
 * @return {!yfiles.geometry.Insets} The insets.
 */
yfiles.styles.IconLabelStyleRenderer.prototype.getWrappedStyleInsets = function() {};

/**
 * Retrieves the {\@link yfiles.styles.IconLabelStyle#autoFlip} property from the {\@link yfiles.styles.IconLabelStyleRenderer#style}.
 * @protected
 * @return {boolean} The autoflip property value.
 */
yfiles.styles.IconLabelStyleRenderer.prototype.isAutoFlip = function() {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.IconLabelStyleRenderer.prototype.isHit = function(context, location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.IconLabelStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.IconLabelStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 * Implements the {\@link yfiles.graph.ILookup} interface.
 * <p>
 * This method will be used by default if {\@link yfiles.styles.IconLabelStyleRenderer#getContext} has been queried for a lookup
 * implementation. Note that it cannot be assumed that {\@link yfiles.styles.IconLabelStyleRenderer#configure} has already been
 * invoked. However, normally {\@link yfiles.styles.IconLabelStyleRenderer#label} and {\@link yfiles.styles.IconLabelStyleRenderer#style} will be correctly configured if invoked directly after <code>GetContext</code>. Subclass
 * implementations should make sure to configure this instance before they return <code>this</code> as a result of a successful lookup.
 * This implementation will check if <code>type.IsInstanceOfType(this)</code> and will call {\@link yfiles.styles.IconLabelStyleRenderer#configure}
 * on success and return <code>this</code>.
 * </p>
 * @param {!yfiles.lang.Class} type The type to query for.
 * @return {!Object} An implementation or <code>null</code>.
 */
yfiles.styles.IconLabelStyleRenderer.prototype.lookup = function(type) {};

/**
 * Returns whether the icon bounds should be considered for hit testing.
 * @protected
 * @return {boolean} true
 */
yfiles.styles.IconLabelStyleRenderer.prototype.shouldHitTestIcon = function() {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.IconLabelStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.GeneralPathNodeStyle = function() {};
 /** @type {!yfiles.geometry.GeneralPath} */
yfiles.styles.GeneralPathNodeStyle.prototype.path;
 /** @type {?} */
yfiles.styles.GeneralPathNodeStyle.prototype.renderer;
 /** @type {!yfiles.view.Fill} */
yfiles.styles.GeneralPathNodeStyle.prototype.fill;
 /** @type {!yfiles.view.Stroke} */
yfiles.styles.GeneralPathNodeStyle.prototype.stroke;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.GeneralPathNodeStyle.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.GeneralPathNodeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.GeneralPathNodeStyleRenderer = function() {};
 /** @type {!yfiles.styles.GeneralPathNodeStyle} */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.node;
 /** @type {?} */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.layout;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.GeneralPathNodeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and node have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.GeneralPathNodeStyleRenderer#style} and {\@link yfiles.styles.GeneralPathNodeStyleRenderer#node} properties have been populated by the
 * {\@link yfiles.styles.GeneralPathNodeStyleRenderer#getVisualCreator},
 * {\@link yfiles.styles.GeneralPathNodeStyleRenderer#getBoundsProvider}, {\@link yfiles.styles.GeneralPathNodeStyleRenderer#getHitTestable},
 * or {\@link yfiles.styles.GeneralPathNodeStyleRenderer#getMarqueeTestable} methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.configure = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.createVisual = function(context) {};

/**
 *
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.GeneralPathNodeStyleRenderer#getBounds
 * @param {?} node The node to retrieve the bounds provider for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.GeneralPathNodeStyleRenderer#lookup} method call they should
 * call {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure} only if needed, i.e. if they decide to return <code>this</code> or an
 * instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.GeneralPathNodeStyleRenderer#lookup
 * @param {?} node The node to query the context for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.GeneralPathNodeStyleRenderer#isHit
 * @param {?} node The node to query hit test with. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 *
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point}
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getIntersection = function(inner, outer) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.GeneralPathNodeStyleRenderer#isInBox
 * @param {?} node The node to query marquee intersection tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 *
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getOutline = function() {};

/**
 * Configures the {\@link yfiles.styles.GeneralPathNodeStyleRenderer#style} and {\@link yfiles.styles.GeneralPathNodeStyleRenderer#node} properties, calls {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.GeneralPathNodeStyleRenderer#isInside
 * @see yfiles.styles.GeneralPathNodeStyleRenderer#getIntersection
 * @param {?} node The node to retrieve the shape geometry for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure}. If
 * the subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.GeneralPathNodeStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.GeneralPathNodeStyleRenderer#isVisible
 * @param {?} node The node to query visibility tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.GeneralPathNodeStyleRenderer#createVisual
 * @see yfiles.styles.GeneralPathNodeStyleRenderer#updateVisual
 * @param {?} node The node to retrieve the {\@link } for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.isHit = function(context, location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.isInside = function(location) {};

/**
 * Determines visibility by checking for an intersection with the {\@link yfiles.styles.GeneralPathNodeStyleRenderer#layout}.
 * @param {?} context The context.
 * @param {!yfiles.geometry.Rect} rectangle The current clip
 * @return {boolean} Whether the {\@link #layout} is visible in the clip.
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 * Implements the {\@link yfiles.graph.ILookup} interface.
 * <p>
 * This method will be used by default if {\@link yfiles.styles.GeneralPathNodeStyleRenderer#getContext} has been queried for a
 * lookup implementation. Note that it cannot be assumed that {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure} has
 * already been invoked. However, normally {\@link yfiles.styles.GeneralPathNodeStyleRenderer#node} and {\@link yfiles.styles.GeneralPathNodeStyleRenderer#style} will be correctly configured if invoked directly after <code>GetContext</code>.
 * Subclass implementations should make sure to configure this instance before they return <code>this</code> as a result of a successful
 * lookup. This implementation will check if <code>type.IsInstanceOfType(this)</code> and will call {\@link yfiles.styles.GeneralPathNodeStyleRenderer#configure}
 * on success and return <code>this</code>.
 * </p>
 * @param {!yfiles.lang.Class} type The type to query for.
 * @return {!Object} An implementation or <code>null</code>.
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.lookup = function(type) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.GeneralPathNodeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.PathBasedEdgeStyleRenderer = function() {};
 /** @type {!yfiles.geometry.GeneralPath} */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.path;
 /** @type {TStyle} */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.edge;
 /** @type {boolean} */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.addBridges;
 /** @type {number} */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.selfLoopDistance;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.PathBasedEdgeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and edge have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#style} and {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#edge} properties have been populated by the {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getVisualCreator}, {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getBoundsProvider}, {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getHitTestable},
 * or {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getMarqueeTestable} methods.
 * </p>
 * <p>
 * Subclasses which override this method have to call the base implementation, first.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.configure = function() {};

/**
 * This method should create the basic uncropped path given the control points.
 * @protected
 * @abstract
 * @return {!yfiles.geometry.GeneralPath} A path that has to be cropped, yet.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.createPath = function() {};

/**
 * Static utility method that creates a rectangular self loop path.
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#createSelfLoopPath
 * @protected
 * @param {number} sx The x coordinate of the source port.
 * @param {number} sy The y coordinate of the source port.
 * @param {number} oppositeX The x coordinate of the single control point.
 * @param {number} oppositeY The y coordinate of the single control point.
 * @param {number} tx The x coordinate of the target port.
 * @param {number} ty The y coordinate of the target port.
 * @return {!yfiles.geometry.GeneralPath} A path that describes a rectangular self loop.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.createRectangleSelfLoop = function(sx, sy, oppositeX, oppositeY, tx, ty) {};

/**
 * Static utility method that creates a round self loop path.
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#createSelfLoopPath
 * @protected
 * @param {number} sx The x coordinate of the source port.
 * @param {number} sy The y coordinate of the source port.
 * @param {number} oppositeX The x coordinate of the single control point.
 * @param {number} oppositeY The y coordinate of the single control point.
 * @param {number} tx The x coordinate of the target port.
 * @param {number} ty The y coordinate of the target port.
 * @return {!yfiles.geometry.GeneralPath} A path that describes a round self loop.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.createRoundSelfLoop = function(sx, sy, oppositeX, oppositeY, tx, ty) {};

/**
 * Special implementation that will create a self loop path.
 * @protected
 * @param {boolean} roundSelfLoop
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.createSelfLoopPath = function(roundSelfLoop) {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.createVisual = function(context) {};

/**
 * Crops the edge's path at the nodes.
 * <p>
 * This implementation uses the {\@link yfiles.styles.IEdgePathCropper} instances found in the {\@link yfiles.graph.ILookup#lookup} of the
 * source and target port of the edge to perform the actual cropping.
 * </p>
 * @protected
 * @param {!yfiles.geometry.GeneralPath} path The path that should be cropped.
 * @return {!yfiles.geometry.GeneralPath} The cropped path. This is can be either the same instance of the given path or a newly created instance.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.cropPath = function(path) {};

/**
 *
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>edge</code> parameters, calls {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} and returns <code>this</code>.
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getBounds
 * @param {?} edge The edge to retrieve the bounds provider for. The value will be stored in the {\@link #edge} property.
 * @param {?} style The style to associate with the edge. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getBoundsProvider = function(edge, style) {};

/**
 * Yields the {\@link yfiles.view.IBridgeCreator} to use for {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#addBridges adding bridges} to the {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#createPath created path}.
 * <p>
 * The return value of this method (which may be <code>null</code>) will be passed to the {\@link yfiles.view.BridgeManager}'s {\@link yfiles.view.BridgeManager#addBridges}
 * method.
 * </p>
 * @protected
 * @return {?} This implementation returns <code>null</code>.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getBridgeCreator = function() {};

/**
 * Configures the <code>style</code> and <code>edge</code> parameters, does <b>not</b> call {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} and returns <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure}, instead subclasses should ensure that in
 * the {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#lookup} method call they should call {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} only if needed, i.e. if they decide to return <code>this</code> or an instance
 * that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#lookup
 * @param {?} edge The edge to query the context for. The value will be stored in the {\@link #edge} property.
 * @param {?} style The style to associate with the edge. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getContext = function(edge, style) {};

/**
 * Configures the <code>style</code> and <code>edge</code> parameters and returns <code>this</code>.
 * <p>
 * This implementation does not call {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure}. If subclasses depend on a configured instance in an override of {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#isHit},
 * they need to override this method, too and call {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} if the base call returns a non-<code>null</code> value.
 * </p>
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#isHit
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure
 * @see yfiles.styles.IEdgeStyleRenderer#getHitTestable
 * @param {?} edge
 * @param {?} style
 * @return {?}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getHitTestable = function(edge, style) {};

/**
 * Configures the <code>style</code> and <code>edge</code> parameters, calls {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} and returns <code>this</code>.
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#isInBox
 * @param {?} edge The edge to query marquee intersection tests. The value will be stored in the {\@link #edge} property.
 * @param {?} style The style to associate with the edge. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getMarqueeTestable = function(edge, style) {};

/**
 * Returns {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#createPath} unless {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#isVisible} yields <code>false</code> for the provided context and {\@link yfiles.view.IRenderContext#clip}.
 * @see yfiles.view.IObstacleProvider
 * @param {?} context The context to yield the obstacles for.
 * @return {!yfiles.geometry.GeneralPath} Either <code>null</code> or the result of {\@link #createPath}.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getObstacles = function(context) {};

/**
 *
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getPath = function() {};

/**
 * Gets an implementation of the {\@link yfiles.styles.IPathGeometry} interface that can handle the provided edge and its associated
 * style.
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getTangent
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getTangent
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getSegmentCount
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getPath
 * @param {?} edge The edge to provide an instance for
 * @param {?} style The style to use for the painting
 * @return {?} <code>this</code>
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getPathGeometry = function(edge, style) {};

/**
 * Returns the number of "segments" this edge's path consists of.
 * <p>
 * This method is part of the {\@link yfiles.styles.IPathGeometry} interface, that is implemented by this class. This interface will
 * be returned by {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getPathGeometry}.
 * </p>
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getPathGeometry
 * @abstract
 * @return {number} the number of segments or <code>-1</code> if there is no such thing as a segment for this edge.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getSegmentCount = function() {};

/**
 * Gets the value that determines the radius of the smoothing arcs that can be added to the path at the bends.
 * <p>
 * This implementation returns <code>0.0d</code>, which effectively turns off path smoothing.
 * </p>
 * @protected
 * @return {number} The radius of the arcs to use at the bends of the path.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getSmoothingLength = function() {};

/**
 * Gets the source arrow from the style.
 * @protected
 * @abstract
 * @return {?} The arrow to use.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getSourceArrow = function() {};

/**
 * Calculate and update the anchor and the source arrow's direction vector.
 * @protected
 * @param {?} arrow The arrow to calculate the anchor for.
 * @return {!yfiles.geometry.Tangent} The anchor and directional vector of the arrow, if any exist.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getSourceArrowAnchor = function(arrow) {};

/**
 * Gets the {\@link yfiles.view.Stroke} to use to render the path.
 * @protected
 * @abstract
 * @return {!yfiles.view.Stroke} The {\@link } or <code>null</code>.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getStroke = function() {};

/**
 * Calculates the tangent on the edge's path at the given ratio point for the given segment.
 * <p>
 * This method is part of the {\@link yfiles.styles.IPathGeometry} interface, that is implemented by this class. This interface will
 * be returned by {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getPathGeometry}.
 * </p>
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getTangent
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getSegmentCount
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getPathGeometry
 * @abstract
 * Calculates the tangent on the edge's path at the given ratio point.
 * <p>
 * This method is part of the {\@link yfiles.styles.IPathGeometry} interface, that is implemented by this class. This interface will
 * be returned by {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getPathGeometry}.
 * </p>
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getPathGeometry
 * @abstract
 * @param {number} segmentIndex_or_ratio the segment to use for the calculation / a value in [0,1] where 0 is the source's end and 1 is at the target's end of the visible edge path
 * @param {number=} ratio a value in [0,1] where 0 is the source's end and 1 is at the target's end of the segment
 * @return {!yfiles.geometry.Tangent} The tangential line, if any exists.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getTangent = function(segmentIndex_or_ratio, ratio) {};

/**
 * Gets the target arrow from the style.
 * @protected
 * @abstract
 * @return {?} The arrow to use.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getTargetArrow = function() {};

/**
 * Calculate and update the anchor and the target arrow's direction vector.
 * @protected
 * @param {?} arrow The arrow to calculate the anchor for.
 * @return {!yfiles.geometry.Tangent} The anchor and directional vector of the arrow, if any exist.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getTargetArrowAnchor = function(arrow) {};

/**
 * Configures the <code>style</code> and <code>edge</code> parameters, does <b>not</b> call {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} and returns <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure}. If the subclass implementation depends on
 * this instance to be configured, it needs to call <code>Configure</code> in {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#isVisible}.
 * </p>
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#isVisible
 * @param {?} edge The edge to query visibility tests. The value will be stored in the {\@link #edge} property.
 * @param {?} style The style to associate with the edge. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getVisibilityTestable = function(edge, style) {};

/**
 * Configures the <code>style</code> and <code>edge</code> parameters, calls {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} and returns <code>this</code>.
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#createVisual
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#updateVisual
 * @param {?} edge The edge to retrieve the {\@link } for. The value will be stored in the {\@link #edge} property.
 * @param {?} style The style to associate with the edge. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.getVisualCreator = function(edge, style) {};

/**
 * This method is overridden for performance reasons.
 * <p>
 * This implementation uses {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#isVisible} as an early exit indicator. If <code>IsVisible</code> returns <code>false</code> for a certain rectangle, the
 * instance will not be configured but a non-hit will be assumed. Otherwise this instance will be configured and the
 * standard path based hit test routine
 * <br />
 * Subclasses should not depend on the fact that {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} has already been called. This may not be the case. If your
 * subclass depends on Configure being called, override {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getHitTestable} and call {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} after the base class call.
 * </p>
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getHitTestable
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.isHit = function(context, location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 * Calls {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure} and test the {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#edge} using the {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#style} for a visible intersection with the clip bounds.
 * <p>
 * This simple implementation uses {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getBounds} to determine the visibility. Subclasses may choose to override this behavior
 * for improved performance but need to <b>make sure to call {\@link yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#configure}</b> if they depend on a configured instance.
 * </p>
 * @see yfiles.styles.PathBasedEdgeStyleRenderer.<TStyle>#getVisibilityTestable
 * @param {?} context the current canvas context
 * @param {!yfiles.geometry.Rect} rectangle the clip bounds
 * @return {boolean} <code>true</code> if the edge may be painted within the clip bounds.
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.lookup = function(type) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.PathBasedEdgeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.PolylineEdgeStyleRenderer = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.styles.PolylineEdgeStyleRenderer.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.PolylineEdgeStyle = function() {};
 /** @type {!yfiles.view.Stroke} */
yfiles.styles.PolylineEdgeStyle.prototype.stroke;
 /** @type {number} */
yfiles.styles.PolylineEdgeStyle.prototype.smoothingLength;
 /** @type {?} */
yfiles.styles.PolylineEdgeStyle.prototype.targetArrow;
 /** @type {?} */
yfiles.styles.PolylineEdgeStyle.prototype.sourceArrow;
 /** @type {?} */
yfiles.styles.PolylineEdgeStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.PolylineEdgeStyle.$class;

/**
 * Performs a {\@link Object#memberwiseClone}
 * @return {!Object}
 */
yfiles.styles.PolylineEdgeStyle.prototype.clone = function() {};

/** @const */
yfiles.styles.ShapeNodeShape = {};
/** @const {number} */
yfiles.styles.ShapeNodeShape.RECTANGLE;
/** @const {number} */
yfiles.styles.ShapeNodeShape.ROUND_RECTANGLE;
/** @const {number} */
yfiles.styles.ShapeNodeShape.ELLIPSE;
/** @const {number} */
yfiles.styles.ShapeNodeShape.TRIANGLE;
/** @const {number} */
yfiles.styles.ShapeNodeShape.TRIANGLE2;
/** @const {number} */
yfiles.styles.ShapeNodeShape.SHEARED_RECTANGLE;
/** @const {number} */
yfiles.styles.ShapeNodeShape.SHEARED_RECTANGLE2;
/** @const {number} */
yfiles.styles.ShapeNodeShape.TRAPEZ;
/** @const {number} */
yfiles.styles.ShapeNodeShape.TRAPEZ2;
/** @const {number} */
yfiles.styles.ShapeNodeShape.STAR5;
/** @const {number} */
yfiles.styles.ShapeNodeShape.STAR6;
/** @const {number} */
yfiles.styles.ShapeNodeShape.STAR8;
/** @const {number} */
yfiles.styles.ShapeNodeShape.FAT_ARROW;
/** @const {number} */
yfiles.styles.ShapeNodeShape.FAT_ARROW2;
/** @const {number} */
yfiles.styles.ShapeNodeShape.DIAMOND;
/** @const {number} */
yfiles.styles.ShapeNodeShape.OCTAGON;
/** @const {number} */
yfiles.styles.ShapeNodeShape.HEXAGON;
/**
 * @record
 * @struct
 */
yfiles.styles.ShapeNodeStyleRenderer = function() {};
 /** @type {!yfiles.styles.ShapeNodeStyle} */
yfiles.styles.ShapeNodeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.ShapeNodeStyleRenderer.prototype.node;
 /** @type {?} */
yfiles.styles.ShapeNodeStyleRenderer.prototype.layout;
 /** @type {number} */
yfiles.styles.ShapeNodeStyleRenderer.prototype.roundRectArcRadius;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.ShapeNodeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and node have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.ShapeNodeStyleRenderer#style} and {\@link yfiles.styles.ShapeNodeStyleRenderer#node} properies have been populated by the {\@link yfiles.styles.ShapeNodeStyleRenderer#getVisualCreator},
 * {\@link yfiles.styles.ShapeNodeStyleRenderer#getBoundsProvider}, {\@link yfiles.styles.ShapeNodeStyleRenderer#getHitTestable}, or {\@link yfiles.styles.ShapeNodeStyleRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.configure = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.createVisual = function(context) {};

/**
 * Returns the layout bounds as an upper bound for the painting bound.
 * <p>
 * This implementation simply sets the {\@link yfiles.styles.ShapeNodeStyleRenderer#layout}'s bounds to the scratch variable and returns.
 * </p>
 * @param {?} context the context to calculate the bounds for
 * @return {!yfiles.geometry.Rect} the bounds or <code>null</code> to indicate an unbound area
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ShapeNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShapeNodeStyleRenderer#getBounds
 * @param {?} node The node to retrieve the bounds provider for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.ShapeNodeStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.ShapeNodeStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.ShapeNodeStyleRenderer#lookup} method call they should call {\@link yfiles.styles.ShapeNodeStyleRenderer#configure}
 * only if needed, i.e. if they decide to return <code>this</code> or an instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.ShapeNodeStyleRenderer#lookup
 * @param {?} node The node to query the context for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 * Get the brush that is currently used by this renderer.
 * <p>
 * This implementation retrieves the brush from the owning style
 * </p>
 * @protected
 * @return {!yfiles.view.Fill} The brush that is currently used by this renderer.
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getFill = function() {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ShapeNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShapeNodeStyleRenderer#isHit
 * @param {?} node The node to query hit test with. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 *
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point}
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getIntersection = function(inner, outer) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ShapeNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShapeNodeStyleRenderer#isInBox
 * @param {?} node The node to query marquee intersection tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 *
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getOutline = function() {};

/**
 * Get the shape that is currently used by this renderer.
 * <p>
 * This implementation retrieves the shape from the owning style
 * </p>
 * @protected
 * @return {yfiles.styles.ShapeNodeShape} The shape that is currently used by this renderer.
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getShape = function() {};

/**
 * Configures the {\@link yfiles.styles.ShapeNodeStyleRenderer#style} and {\@link yfiles.styles.ShapeNodeStyleRenderer#node} properties, calls {\@link yfiles.styles.ShapeNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShapeNodeStyleRenderer#isInside
 * @see yfiles.styles.ShapeNodeStyleRenderer#getIntersection
 * @param {?} node The node to retrieve the shape geometry for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Get the pen that is currently used by this renderer.
 * <p>
 * This implementation retrieves the {\@link yfiles.view.Stroke} from the owning style
 * </p>
 * @protected
 * @return {!yfiles.view.Stroke} The {\@link } that is currently used by this renderer.
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getStroke = function() {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.ShapeNodeStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.ShapeNodeStyleRenderer#configure}. If the
 * subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.ShapeNodeStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.ShapeNodeStyleRenderer#isVisible
 * @param {?} node The node to query visibility tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ShapeNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShapeNodeStyleRenderer#createVisual
 * @see yfiles.styles.ShapeNodeStyleRenderer#updateVisual
 * @param {?} node The node to retrieve the {\@link } for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.isHit = function(context, location) {};

/**
 * Tests the {\@link yfiles.styles.ShapeNodeStyleRenderer#node node} using the current {\@link yfiles.styles.ShapeNodeStyleRenderer#style} for an intersection with the given box.
 * <p>
 * This implementation uses the {\@link yfiles.styles.ShapeNodeStyleRenderer#layout} to determine whether the node is in the box.
 * </p>
 * @param {?} context the current input mode context
 * @param {!yfiles.geometry.Rect} rectangle the box describing the marquee's bounds
 * @return {boolean} <code>true</code> if the node is considered to be captured by the marquee
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.isInside = function(location) {};

/**
 * Determines visibility by checking for an intersection with the {\@link yfiles.styles.ShapeNodeStyleRenderer#layout}.
 * @param {?} context The context.
 * @param {!yfiles.geometry.Rect} rectangle The current clip
 * @return {boolean} Whether the {\@link #layout} is visible in the clip.
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 * Implements the {\@link yfiles.graph.ILookup} interface.
 * <p>
 * This method will be used by default if {\@link yfiles.styles.ShapeNodeStyleRenderer#getContext} has been queried for a lookup
 * implementation. Note that it cannot be assumed that {\@link yfiles.styles.ShapeNodeStyleRenderer#configure} has already been
 * invoked. However, normally {\@link yfiles.styles.ShapeNodeStyleRenderer#node} and {\@link yfiles.styles.ShapeNodeStyleRenderer#style} will be correctly configured if invoked directly after <code>GetContext</code>. Subclass
 * implementations should make sure to configure this instance before they return <code>this</code> as a result of a successful lookup.
 * This implementation will check if <code>type.IsInstanceOfType(this)</code> and will call {\@link yfiles.styles.ShapeNodeStyleRenderer#configure}
 * on success and return <code>this</code>.
 * </p>
 * @param {!yfiles.lang.Class} type The type to query for.
 * @return {!Object} An implementation or <code>null</code>.
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.lookup = function(type) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.ShapeNodeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.ShapeNodeStyle = function() {};
 /** @type {!yfiles.view.Stroke} */
yfiles.styles.ShapeNodeStyle.prototype.stroke;
 /** @type {!yfiles.view.Fill} */
yfiles.styles.ShapeNodeStyle.prototype.fill;
 /** @type {yfiles.styles.ShapeNodeShape} */
yfiles.styles.ShapeNodeStyle.prototype.shape;
 /** @type {?} */
yfiles.styles.ShapeNodeStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.ShapeNodeStyle.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.ShapeNodeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.ArcEdgeStyleRenderer = function() {};
 /** @type {boolean} */
yfiles.styles.ArcEdgeStyleRenderer.prototype.addBridges;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.ArcEdgeStyleRenderer.$class;

/**
 * Retrieves the {\@link yfiles.styles.ArcEdgeStyle#height} of the style.
 * @return {number} the height.
 */
yfiles.styles.ArcEdgeStyleRenderer.prototype.getHeight = function() {};

/**
 * Gets a value indicating whether this {\@link yfiles.styles.ArcEdgeStyleRenderer#getHeight} should be interpreted as an absolute
 * or relative value.
 * @see yfiles.styles.ArcEdgeStyleRenderer#getHeight
 * @return {boolean} <code>true</code> if the height value should be interpreted as a fixed value, otherwise, <code>false</code>.
 */
yfiles.styles.ArcEdgeStyleRenderer.prototype.isFixedHeight = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.ArcEdgeStyle = function() {};
 /** @type {!yfiles.view.Stroke} */
yfiles.styles.ArcEdgeStyle.prototype.stroke;
 /** @type {number} */
yfiles.styles.ArcEdgeStyle.prototype.height;
 /** @type {boolean} */
yfiles.styles.ArcEdgeStyle.prototype.fixedHeight;
 /** @type {boolean} */
yfiles.styles.ArcEdgeStyle.prototype.provideHeightHandle;
 /** @type {?} */
yfiles.styles.ArcEdgeStyle.prototype.targetArrow;
 /** @type {?} */
yfiles.styles.ArcEdgeStyle.prototype.sourceArrow;
 /** @type {?} */
yfiles.styles.ArcEdgeStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.ArcEdgeStyle.$class;

/**
 * Performs a {\@link Object#memberwiseClone}
 * @return {!Object}
 */
yfiles.styles.ArcEdgeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.BevelNodeStyleRenderer = function() {};
 /** @type {!yfiles.styles.BevelNodeStyle} */
yfiles.styles.BevelNodeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.BevelNodeStyleRenderer.prototype.node;
 /** @type {?} */
yfiles.styles.BevelNodeStyleRenderer.prototype.layout;
 /** @type {!yfiles.view.Color} */
yfiles.styles.BevelNodeStyleRenderer.prototype.color;
 /** @type {number} */
yfiles.styles.BevelNodeStyleRenderer.prototype.inset;
 /** @type {number} */
yfiles.styles.BevelNodeStyleRenderer.prototype.radius;
 /** @type {boolean} */
yfiles.styles.BevelNodeStyleRenderer.prototype.provideRadiusHandle;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.BevelNodeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and node have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.BevelNodeStyleRenderer#style} and {\@link yfiles.styles.BevelNodeStyleRenderer#node} properties have been populated by the {\@link yfiles.styles.BevelNodeStyleRenderer#getVisualCreator},
 * {\@link yfiles.styles.BevelNodeStyleRenderer#getBoundsProvider}, {\@link yfiles.styles.BevelNodeStyleRenderer#getHitTestable}, or {\@link yfiles.styles.BevelNodeStyleRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.configure = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.createVisual = function(context) {};

/**
 * Returns the layout bounds as an upper bound for the painting bound.
 * <p>
 * This implementation simply sets the {\@link yfiles.styles.BevelNodeStyleRenderer#layout}'s bounds to the scratch variable and returns.
 * </p>
 * @param {?} context the context to calculate the bounds for
 * @return {!yfiles.geometry.Rect} the bounds or <code>null</code> to indicate an unbound area
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.BevelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.BevelNodeStyleRenderer#getBounds
 * @param {?} node The node to retrieve the bounds provider for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.BevelNodeStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.BevelNodeStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.BevelNodeStyleRenderer#lookup} method call they should call {\@link yfiles.styles.BevelNodeStyleRenderer#configure}
 * only if needed, i.e. if they decide to return <code>this</code> or an instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.BevelNodeStyleRenderer#lookup
 * @param {?} node The node to query the context for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.BevelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.BevelNodeStyleRenderer#isHit
 * @param {?} node The node to query hit test with. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 *
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point}
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getIntersection = function(inner, outer) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.BevelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.BevelNodeStyleRenderer#isInBox
 * @param {?} node The node to query marquee intersection tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 *
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getOutline = function() {};

/**
 * Configures the {\@link yfiles.styles.BevelNodeStyleRenderer#style} and {\@link yfiles.styles.BevelNodeStyleRenderer#node} properties, calls {\@link yfiles.styles.BevelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.BevelNodeStyleRenderer#isInside
 * @see yfiles.styles.BevelNodeStyleRenderer#getIntersection
 * @param {?} node The node to retrieve the shape geometry for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.BevelNodeStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.BevelNodeStyleRenderer#configure}. If the
 * subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.BevelNodeStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.BevelNodeStyleRenderer#isVisible
 * @param {?} node The node to query visibility tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.BevelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.BevelNodeStyleRenderer#createVisual
 * @see yfiles.styles.BevelNodeStyleRenderer#updateVisual
 * @param {?} node The node to retrieve the {\@link } for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.isHit = function(context, location) {};

/**
 * Tests the {\@link yfiles.styles.BevelNodeStyleRenderer#node node} using the current {\@link yfiles.styles.BevelNodeStyleRenderer#style} for an intersection with the given box.
 * <p>
 * This implementation uses the {\@link yfiles.styles.BevelNodeStyleRenderer#layout} to determine whether the node is in the box.
 * </p>
 * @param {?} context the current input mode context
 * @param {!yfiles.geometry.Rect} rectangle the box describing the marquee's bounds
 * @return {boolean} <code>true</code> if the node is considered to be captured by the marquee
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.isInside = function(location) {};

/**
 * Determines visibility by checking for an intersection with the {\@link yfiles.styles.BevelNodeStyleRenderer#layout}.
 * @param {?} context The context.
 * @param {!yfiles.geometry.Rect} rectangle The current clip
 * @return {boolean} Whether the {\@link #layout} is visible in the clip.
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.lookup = function(type) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.BevelNodeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.BevelNodeStyle = function() {};
 /** @type {number} */
yfiles.styles.BevelNodeStyle.prototype.inset;
 /** @type {number} */
yfiles.styles.BevelNodeStyle.prototype.radius;
 /** @type {!yfiles.view.Color} */
yfiles.styles.BevelNodeStyle.prototype.color;
 /** @type {?} */
yfiles.styles.BevelNodeStyle.prototype.renderer;
 /** @type {boolean} */
yfiles.styles.BevelNodeStyle.prototype.drawShadow;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.BevelNodeStyle.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.BevelNodeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.ImageNodeStyleRenderer = function() {};
 /** @type {!yfiles.styles.ImageNodeStyle} */
yfiles.styles.ImageNodeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.ImageNodeStyleRenderer.prototype.node;
 /** @type {?} */
yfiles.styles.ImageNodeStyleRenderer.prototype.layout;
 /** @type {string} */
yfiles.styles.ImageNodeStyleRenderer.TEMPLATE_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.ImageNodeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and node have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.ImageNodeStyleRenderer#style} and {\@link yfiles.styles.ImageNodeStyleRenderer#node} properties have been populated by the {\@link yfiles.styles.ImageNodeStyleRenderer#getVisualCreator},
 * {\@link yfiles.styles.ImageNodeStyleRenderer#getBoundsProvider}, {\@link yfiles.styles.ImageNodeStyleRenderer#getHitTestable}, or {\@link yfiles.styles.ImageNodeStyleRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.configure = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.createVisual = function(context) {};

/**
 * Returns the layout bounds as an upper bound for the painting bound.
 * <p>
 * This implementation simply sets the {\@link yfiles.styles.ImageNodeStyleRenderer#layout}'s bounds to the scratch variable and returns.
 * </p>
 * @param {?} context the context to calculate the bounds for
 * @return {!yfiles.geometry.Rect} the bounds or <code>null</code> to indicate an unbound area
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ImageNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ImageNodeStyleRenderer#getBounds
 * @param {?} node The node to retrieve the bounds provider for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.ImageNodeStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.ImageNodeStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.ImageNodeStyleRenderer#lookup} method call they should call {\@link yfiles.styles.ImageNodeStyleRenderer#configure}
 * only if needed, i.e. if they decide to return <code>this</code> or an instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.ImageNodeStyleRenderer#lookup
 * @param {?} node The node to query the context for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 * Get the style's fallback image.
 * @protected
 * @return {string}
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getFallbackImage = function() {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ImageNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ImageNodeStyleRenderer#isHit
 * @param {?} node The node to query hit test with. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 * Get the image that is currently used to render the style.
 * @protected
 * @return {string}
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getImage = function() {};

/**
 * Tries to use the {\@link yfiles.styles.ImageNodeStyle#normalizedOutline} to perform the intersection calculation, otherwise reverts to default (rectangular) behavior.
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point}
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getIntersection = function(inner, outer) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ImageNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ImageNodeStyleRenderer#isInBox
 * @param {?} node The node to query marquee intersection tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 * Tries to use the {\@link yfiles.styles.ImageNodeStyle#normalizedOutline} to create the outline shape path, otherwise reverts to default (rectangular) behavior.
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getOutline = function() {};

/**
 * Gets the value that determines whether the aspect ratio of the image should be preserved.
 * @protected
 * @return {boolean} false
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getPreserveAspectRatio = function() {};

/**
 * Configures the {\@link yfiles.styles.ImageNodeStyleRenderer#style} and {\@link yfiles.styles.ImageNodeStyleRenderer#node} properties, calls {\@link yfiles.styles.ImageNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ImageNodeStyleRenderer#isInside
 * @see yfiles.styles.ImageNodeStyleRenderer#getIntersection
 * @param {?} node The node to retrieve the shape geometry for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.ImageNodeStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.ImageNodeStyleRenderer#configure}. If the
 * subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.ImageNodeStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.ImageNodeStyleRenderer#isVisible
 * @param {?} node The node to query visibility tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ImageNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ImageNodeStyleRenderer#createVisual
 * @see yfiles.styles.ImageNodeStyleRenderer#updateVisual
 * @param {?} node The node to retrieve the {\@link } for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};

/**
 * Tries to use {\@link yfiles.styles.ImageNodeStyle#normalizedOutline} to perform the hit test analysis, otherwise reverts to default (rectangular) behavior.
 * @param {?} context the context the hit test is performed in
 * @param {!yfiles.geometry.Point} location the coordinates in world coordinate system
 * @return {boolean} whether something has been hit
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.isHit = function(context, location) {};

/**
 * Tries to use the {\@link yfiles.styles.ImageNodeStyle#normalizedOutline} to perform the marquee intersection analysis, otherwise reverts to default (rectangular) behavior.
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 * Tries to use the {\@link yfiles.styles.ImageNodeStyle#normalizedOutline} to perform the contains test, otherwise reverts to default (rectangular) behavior.
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.isInside = function(location) {};

/**
 * Determines visibility by checking for an intersection with the {\@link yfiles.styles.ImageNodeStyleRenderer#layout}.
 * @param {?} context The context.
 * @param {!yfiles.geometry.Rect} rectangle The current clip
 * @return {boolean} Whether the {\@link #layout} is visible in the clip.
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 * Implements the {\@link yfiles.graph.ILookup} interface.
 * <p>
 * This method will be used by default if {\@link yfiles.styles.ImageNodeStyleRenderer#getContext} has been queried for a lookup
 * implementation. Note that it cannot be assumed that {\@link yfiles.styles.ImageNodeStyleRenderer#configure} has already been
 * invoked. However, normally {\@link yfiles.styles.ImageNodeStyleRenderer#node} and {\@link yfiles.styles.ImageNodeStyleRenderer#style} will be correctly configured if invoked directly after <code>GetContext</code>. Subclass
 * implementations should make sure to configure this instance before they return <code>this</code> as a result of a successful lookup.
 * This implementation will check if <code>type.IsInstanceOfType(this)</code> and will call {\@link yfiles.styles.ImageNodeStyleRenderer#configure}
 * on success and return <code>this</code>.
 * </p>
 * @param {!yfiles.lang.Class} type The type to query for.
 * @return {!Object} An implementation or <code>null</code>.
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.lookup = function(type) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.ImageNodeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.ImageNodeStyle = function() {};
 /** @type {?} */
yfiles.styles.ImageNodeStyle.prototype.renderer;
 /** @type {string} */
yfiles.styles.ImageNodeStyle.prototype.image;
 /** @type {string} */
yfiles.styles.ImageNodeStyle.prototype.fallbackImage;
 /** @type {!yfiles.geometry.GeneralPath} */
yfiles.styles.ImageNodeStyle.prototype.normalizedOutline;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.ImageNodeStyle.$class;

/**
 * This implementation performs a shallow copy with respect to the {\@link yfiles.styles.ImageNodeStyle#image} property.
 * <p>
 * If clients need to have a deep copy of this instance, they need to manually clone and reassign the {\@link yfiles.styles.ImageNodeStyle#image} to the clone.
 * </p>
 * @return {!Object} A shallow copy of this instance.
 */
yfiles.styles.ImageNodeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.PanelNodeStyle = function() {};
 /** @type {!yfiles.view.Color} */
yfiles.styles.PanelNodeStyle.prototype.color;
 /** @type {!yfiles.view.Color} */
yfiles.styles.PanelNodeStyle.prototype.labelInsetsColor;
 /** @type {!yfiles.geometry.Insets} */
yfiles.styles.PanelNodeStyle.prototype.insets;
 /** @type {?} */
yfiles.styles.PanelNodeStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.PanelNodeStyle.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.PanelNodeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.PanelNodeStyleRenderer = function() {};
 /** @type {!yfiles.styles.PanelNodeStyle} */
yfiles.styles.PanelNodeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.PanelNodeStyleRenderer.prototype.node;
 /** @type {?} */
yfiles.styles.PanelNodeStyleRenderer.prototype.layout;
 /** @type {!yfiles.view.Color} */
yfiles.styles.PanelNodeStyleRenderer.prototype.color;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.PanelNodeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and node have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.PanelNodeStyleRenderer#style} and {\@link yfiles.styles.PanelNodeStyleRenderer#node} properties have been populated by the {\@link yfiles.styles.PanelNodeStyleRenderer#getVisualCreator},
 * {\@link yfiles.styles.PanelNodeStyleRenderer#getBoundsProvider}, {\@link yfiles.styles.PanelNodeStyleRenderer#getHitTestable}, or {\@link yfiles.styles.PanelNodeStyleRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.configure = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.createVisual = function(context) {};

/**
 * Determines whether to draw the drop shadow.
 * @protected
 * @return {boolean} <code>true</code>, always.
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.drawShadow = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.PanelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.PanelNodeStyleRenderer#getBounds
 * @param {?} node The node to retrieve the bounds provider for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.PanelNodeStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.PanelNodeStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.PanelNodeStyleRenderer#lookup} method call they should call {\@link yfiles.styles.PanelNodeStyleRenderer#configure}
 * only if needed, i.e. if they decide to return <code>this</code> or an instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.PanelNodeStyleRenderer#lookup
 * @param {?} node The node to query the context for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.PanelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.PanelNodeStyleRenderer#isHit
 * @param {?} node The node to query hit test with. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 * Finds an intersection for the current {\@link yfiles.styles.PanelNodeStyleRenderer#node node} using the {\@link yfiles.styles.PanelNodeStyleRenderer#style}.
 * <p>
 * This implementation returns the intersection for the {\@link yfiles.styles.PanelNodeStyleRenderer#layout}.
 * </p>
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point} True if an intersection was actually found
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getIntersection = function(inner, outer) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.PanelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.PanelNodeStyleRenderer#isInBox
 * @param {?} node The node to query marquee intersection tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 * Returns the outline of the shape using the node's {\@link yfiles.styles.PanelNodeStyleRenderer#layout}.
 * @return {!yfiles.geometry.GeneralPath} The outline of the bounds of the node.
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getOutline = function() {};

/**
 * Configures the {\@link yfiles.styles.PanelNodeStyleRenderer#style} and {\@link yfiles.styles.PanelNodeStyleRenderer#node} properties, calls {\@link yfiles.styles.PanelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.PanelNodeStyleRenderer#isInside
 * @see yfiles.styles.PanelNodeStyleRenderer#getIntersection
 * @param {?} node The node to retrieve the shape geometry for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.PanelNodeStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.PanelNodeStyleRenderer#configure}. If the
 * subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.PanelNodeStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.PanelNodeStyleRenderer#isVisible
 * @param {?} node The node to query visibility tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.PanelNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.PanelNodeStyleRenderer#createVisual
 * @see yfiles.styles.PanelNodeStyleRenderer#updateVisual
 * @param {?} node The node to retrieve the {\@link } for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};

/**
 * Hit tests the {\@link yfiles.styles.PanelNodeStyleRenderer#node node} using the current {\@link yfiles.styles.PanelNodeStyleRenderer#style}.
 * <p>
 * This implementation uses the {\@link yfiles.styles.PanelNodeStyleRenderer#layout} to determine whether the node has been hit. The check is delegated to {\@link yfiles.geometry.Rect#containsWithEps}
 * using {\@link yfiles.view.ICanvasContext#hitTestRadius} as the last argument.
 * </p>
 * @param {?} context the context the hit test is performed in
 * @param {!yfiles.geometry.Point} location the coordinates in world coordinate system
 * @return {boolean} whether something has been hit
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.isHit = function(context, location) {};

/**
 * Tests the {\@link yfiles.styles.PanelNodeStyleRenderer#node node} using the current {\@link yfiles.styles.PanelNodeStyleRenderer#style} for an intersection with the given box.
 * <p>
 * This implementation uses the {\@link yfiles.styles.PanelNodeStyleRenderer#layout} to determine whether the node is in the box.
 * </p>
 * @param {?} context the current input mode context
 * @param {!yfiles.geometry.Rect} rectangle the box describing the marquee's bounds
 * @return {boolean} <code>true</code> if the node is considered to be captured by the marquee
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 * Checks whether the given coordinate lies within the shape's geometric bounds.
 * <p>
 * This implementation checks for containment in the {\@link yfiles.styles.PanelNodeStyleRenderer#layout}.
 * </p>
 * @param {!yfiles.geometry.Point} location
 * @return {boolean} True if the point lies within the geometry of the rendering.
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.isInside = function(location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.lookup = function(type) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.PanelNodeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.ShadowNodeStyleDecorator = function() {};
 /** @type {?} */
yfiles.styles.ShadowNodeStyleDecorator.prototype.wrapped;
 /** @type {?} */
yfiles.styles.ShadowNodeStyleDecorator.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.ShadowNodeStyleDecorator.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.ShadowNodeStyleDecorator.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.ShinyPlateNodeStyle = function() {};
 /** @type {!yfiles.view.Fill} */
yfiles.styles.ShinyPlateNodeStyle.prototype.fill;
 /** @type {!yfiles.view.Stroke} */
yfiles.styles.ShinyPlateNodeStyle.prototype.stroke;
 /** @type {number} */
yfiles.styles.ShinyPlateNodeStyle.prototype.radius;
 /** @type {boolean} */
yfiles.styles.ShinyPlateNodeStyle.prototype.drawShadow;
 /** @type {!yfiles.geometry.Insets} */
yfiles.styles.ShinyPlateNodeStyle.prototype.insets;
 /** @type {?} */
yfiles.styles.ShinyPlateNodeStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.ShinyPlateNodeStyle.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.ShinyPlateNodeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.ShinyPlateNodeStyleRenderer = function() {};
 /** @type {!yfiles.styles.ShinyPlateNodeStyle} */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.node;
 /** @type {?} */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.layout;
 /** @type {!yfiles.view.Fill} */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.fill;
 /** @type {!yfiles.view.Stroke} */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.stroke;
 /** @type {number} */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.radius;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.ShinyPlateNodeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and node have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#style} and {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#node} properties have been populated by the
 * {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#getVisualCreator}, {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#getBoundsProvider},
 * {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#getHitTestable}, or {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.configure = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.createVisual = function(context) {};

/**
 * Determines whether to draw the drop shadow.
 * @protected
 * @return {boolean}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.drawShadow = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShinyPlateNodeStyleRenderer#getBounds
 * @param {?} node The node to retrieve the bounds provider for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#lookup} method call they should
 * call {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure} only if needed, i.e. if they decide to return <code>this</code> or an
 * instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.ShinyPlateNodeStyleRenderer#lookup
 * @param {?} node The node to query the context for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShinyPlateNodeStyleRenderer#isHit
 * @param {?} node The node to query hit test with. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 *
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getIntersection = function(inner, outer) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShinyPlateNodeStyleRenderer#isInBox
 * @param {?} node The node to query marquee intersection tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 *
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getOutline = function() {};

/**
 * Configures the {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#style} and {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#node} properties, calls {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShinyPlateNodeStyleRenderer#isInside
 * @see yfiles.styles.ShinyPlateNodeStyleRenderer#getIntersection
 * @param {?} node The node to retrieve the shape geometry for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure}. If
 * the subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.ShinyPlateNodeStyleRenderer#isVisible
 * @param {?} node The node to query visibility tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.ShinyPlateNodeStyleRenderer#createVisual
 * @see yfiles.styles.ShinyPlateNodeStyleRenderer#updateVisual
 * @param {?} node The node to retrieve the {\@link } for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.isHit = function(context, location) {};

/**
 * Tests the {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#node node} using the current {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#style} for an intersection with the given box.
 * <p>
 * This implementation uses the {\@link yfiles.styles.ShinyPlateNodeStyleRenderer#layout} to determine whether the node is in the box.
 * </p>
 * @param {?} context the current input mode context
 * @param {!yfiles.geometry.Rect} rectangle the box describing the marquee's bounds
 * @return {boolean} <code>true</code> if the node is considered to be captured by the marquee
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.isInside = function(location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.lookup = function(type) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.ShinyPlateNodeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TemplateStripeStyleBase = function() {};
 /** @type {!Object} */
yfiles.styles.TemplateStripeStyleBase.prototype.styleTag;
 /** @type {?} */
yfiles.styles.TemplateStripeStyleBase.prototype.contextLookup;
 /** @type {?} */
yfiles.styles.TemplateStripeStyleBase.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplateStripeStyleBase.$class;

/**
 * Performs a shallow clone of this instance, except for the value of {\@link yfiles.styles.TemplateStripeStyleBase#styleTag} which is cloned, too, if it can be cloned.
 * @return {!Object} A clone of this instance.
 */
yfiles.styles.TemplateStripeStyleBase.prototype.clone = function() {};

/**
 * Factory method that is called by the {\@link yfiles.styles.TemplateStripeStyleRenderer} to create the visual that will be used
 * for the display of the stripe.
 * @param {?} context The context for which the visual should be created.
 * @param {?} stripe The stripe that will be rendered.
 * @return {!yfiles.view.SvgVisual} The readily styled visual.
 */
yfiles.styles.TemplateStripeStyleBase.prototype.createTemplate = function(context, stripe) {};

/**
 * Loads all template script elements that have not been parsed, yet, and creates the respective template cache objects.
 * <p>
 * This method can be called to perform the template loading at a certain point in time, for example during application
 * startup. By default, a template is loaded lazily when the first visual using this template is built.
 * </p>
 * @return {void}
 */
yfiles.styles.TemplateStripeStyleBase.loadAllTemplates = function() {};

/**
 * Raises the {\@link yfiles.styles.TemplateStripeStyleBase#addPropertyChangedListener PropertyChanged}
 * event.
 * @protected
 * @param {!yfiles.lang.PropertyChangedEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.styles.TemplateStripeStyleBase.prototype.onPropertyChanged = function(evt) {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * @see yfiles.styles.TemplateStripeStyleBase#removePropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.styles.TemplateStripeStyleBase.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * @see yfiles.styles.TemplateStripeStyleBase#addPropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.styles.TemplateStripeStyleBase.prototype.removePropertyChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TemplateStripeStyle = function() {};
 /** @type {string} */
yfiles.styles.TemplateStripeStyle.prototype.styleResourceKey;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplateStripeStyle.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.StringTemplateStripeStyle = function() {};
 /** @type {string} */
yfiles.styles.StringTemplateStripeStyle.prototype.svgContent;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.StringTemplateStripeStyle.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.TemplateStripeStyleRenderer = function() {};
 /** @type {!yfiles.styles.TemplateStripeStyleBase} */
yfiles.styles.TemplateStripeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.TemplateStripeStyleRenderer.prototype.stripe;
 /** @type {?} */
yfiles.styles.TemplateStripeStyleRenderer.prototype.layout;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplateStripeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and stripe have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.TemplateStripeStyleRenderer#style} and {\@link yfiles.styles.TemplateStripeStyleRenderer#stripe} properties have been populated by the {\@link yfiles.styles.TemplateStripeStyleRenderer#getVisualCreator}
 * or {\@link yfiles.styles.TemplateStripeStyleRenderer#getContext} methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.TemplateStripeStyleRenderer.prototype.configure = function() {};

/**
 * Creates the visual by delegating to CreateControl and then initializing the control with the context.
 * @param {?} context The context for the creation.
 * @return {!yfiles.view.Visual} The control that is used for rendering the stripe.
 */
yfiles.styles.TemplateStripeStyleRenderer.prototype.createVisual = function(context) {};

/**
 * Configures the <code>style</code> and <code>stripe</code> parameters, does <b>not</b> call {\@link yfiles.styles.TemplateStripeStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.TemplateStripeStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.TemplateStripeStyleRenderer#lookup} method call they should
 * call {\@link yfiles.styles.TemplateStripeStyleRenderer#configure} only if needed, i.e. if they decide to return <code>this</code> or an
 * instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.TemplateStripeStyleRenderer#lookup
 * @param {?} stripe The stripe to query the context for. The value will be stored in the {\@link #stripe} property.
 * @param {?} style The style to associate with the stripe. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateStripeStyleRenderer.prototype.getContext = function(stripe, style) {};

/**
 * Gets the context by delegating to {\@link yfiles.styles.TemplateStripeStyleBase#contextLookup}.
 * @protected
 * @param {!yfiles.styles.TemplateStripeStyleBase} style
 * @return {?}
 */
yfiles.styles.TemplateStripeStyleRenderer.prototype.getContextLookup = function(style) {};

/**
 * Configures the <code>style</code> and <code>stripe</code> parameters, calls {\@link yfiles.styles.TemplateStripeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplateStripeStyleRenderer#createVisual
 * @see yfiles.styles.TemplateStripeStyleRenderer#updateVisual
 * @param {?} stripe The stripe to retrieve the {\@link } for. The value will be stored in the {\@link #stripe} property.
 * @param {?} style The style to associate with the stripe. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateStripeStyleRenderer.prototype.getVisualCreator = function(stripe, style) {};

/**
 * Implementation of the {\@link yfiles.graph.ILookup#lookup} method.
 * <p>
 * Delegates to the lookup returned by GetContextLookup(StripeControlStripeStyle), first. Last, it returns this class if it
 * implements the queried <code>type</code>.
 * </p>
 * @param {!yfiles.lang.Class} type The type to query an instance for.
 * @return {!Object} The implementation or <code>null</code>.
 */
yfiles.styles.TemplateStripeStyleRenderer.prototype.lookup = function(type) {};

/**
 * Updates the component correspondingly.
 * @param {?} context The context for the creation.
 * @param {!yfiles.view.Visual} oldVisual The currently rendered visual.
 * @return {!yfiles.view.Visual} The control that is used for rendering the stripe.
 */
yfiles.styles.TemplateStripeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TableNodeStyle = function() {};
 /** @type {yfiles.styles.TableRenderingOrder} */
yfiles.styles.TableNodeStyle.prototype.tableRenderingOrder;
 /** @type {?} */
yfiles.styles.TableNodeStyle.prototype.backgroundStyle;
 /** @type {?} */
yfiles.styles.TableNodeStyle.prototype.table;
 /** @type {?} */
yfiles.styles.TableNodeStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TableNodeStyle.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.TableNodeStyle.prototype.clone = function() {};

/**
 * Create a copy of the background style when this style instance is cloned
 * @protected
 * @param {?} style The original background node style
 * @return {?} This implementation always returns the original <code>style</code> instance.
 */
yfiles.styles.TableNodeStyle.prototype.copyBackgroundStyle = function(style) {};

/**
 * Create a copy of the table when this style instance is cloned
 * @protected
 * @param {?} table The original table instance
 * @return {?} This implementation always tries to {\@link #clone} clone the original <code>table</code> instance, if possible,
 * otherwise it returns <code>table</code> unchanged.
 */
yfiles.styles.TableNodeStyle.prototype.copyTable = function(table) {};

/**
 * Raises the {\@link yfiles.styles.TableNodeStyle#addPropertyChangedListener PropertyChanged} event.
 * <p>
 * Called when the value of the {\@link yfiles.styles.TableNodeStyle#table} property changes.
 * </p>
 * @protected
 * @param {!yfiles.lang.PropertyChangedEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.styles.TableNodeStyle.prototype.onPropertyChanged = function(evt) {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when the value of the {\@link yfiles.styles.TableNodeStyle#table} property changes.
 * @see yfiles.styles.TableNodeStyle#removePropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.styles.TableNodeStyle.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when the value of the {\@link yfiles.styles.TableNodeStyle#table} property changes.
 * @see yfiles.styles.TableNodeStyle#addPropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.styles.TableNodeStyle.prototype.removePropertyChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TableNodeStyleRenderer = function() {};
 /** @type {!yfiles.styles.TableNodeStyle} */
yfiles.styles.TableNodeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.TableNodeStyleRenderer.prototype.node;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TableNodeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and node have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.TableNodeStyleRenderer#style} and {\@link yfiles.styles.TableNodeStyleRenderer#node} properties have been populated by the {\@link yfiles.styles.TableNodeStyleRenderer#getVisualCreator},
 * {\@link yfiles.styles.TableNodeStyleRenderer#getBoundsProvider}, {\@link yfiles.styles.TableNodeStyleRenderer#getHitTestable}, or {\@link yfiles.styles.TableNodeStyleRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.configure = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.createVisual = function(context) {};

/**
 * Get the {\@link yfiles.styles.INodeStyle background style} that is currently used by this renderer.
 * <p>
 * This implementation retrieves the {\@link yfiles.styles.TableNodeStyle#backgroundStyle} from the owning style
 * </p>
 * @protected
 * @return {?} The {\@link  background style} that is currently used by this renderer.
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getBackgroundStyle = function() {};

/**
 *
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getBounds = function(context) {};

/**
 *
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 *
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 *
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 *
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getIntersection = function(inner, outer) {};

/**
 *
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 *
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getOutline = function() {};

/**
 *
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Gets the table object that should be used for rendering.
 * <p>
 * This implementation delegates to the Table provided by the {\@link yfiles.styles.TableNodeStyle#table} property.
 * </p>
 * @protected
 * @return {?} The table that should be used for the rendering process.
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getTable = function() {};

/**
 * Get the {\@link yfiles.styles.TableRenderingOrder} that is currently used by this renderer.
 * <p>
 * This implementation retrieves the {\@link yfiles.styles.TableRenderingOrder} from the owning style
 * </p>
 * @protected
 * @return {yfiles.styles.TableRenderingOrder} The {\@link } that is currently used by this renderer.
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getTableRenderingOrder = function() {};

/**
 *
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 *
 * @param {?} node
 * @param {?} style
 * @return {?}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.isHit = function(context, location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.isInside = function(location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 *
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.lookup = function(type) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual
 * @return {!yfiles.view.Visual}
 */
yfiles.styles.TableNodeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.ITemplateStyleBindingContext = function() {};
 /** @type {number} */
yfiles.styles.ITemplateStyleBindingContext.prototype.width;
 /** @type {number} */
yfiles.styles.ITemplateStyleBindingContext.prototype.height;
 /** @type {!yfiles.view.CanvasComponent} */
yfiles.styles.ITemplateStyleBindingContext.prototype.canvasComponent;
 /** @type {boolean} */
yfiles.styles.ITemplateStyleBindingContext.prototype.itemSelected;
 /** @type {boolean} */
yfiles.styles.ITemplateStyleBindingContext.prototype.itemFocused;
 /** @type {boolean} */
yfiles.styles.ITemplateStyleBindingContext.prototype.itemHighlighted;
 /** @type {?} */
yfiles.styles.ITemplateStyleBindingContext.prototype.item;
 /** @type {!Object} */
yfiles.styles.ITemplateStyleBindingContext.prototype.styleTag;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.ITemplateStyleBindingContext;
/**
 * @record
 * @struct
 */
yfiles.styles.ILabelTemplateStyleBindingContext = function() {};
 /** @type {string} */
yfiles.styles.ILabelTemplateStyleBindingContext.prototype.labelText;
 /** @type {boolean} */
yfiles.styles.ILabelTemplateStyleBindingContext.prototype.isFlipped;
 /** @type {boolean} */
yfiles.styles.ILabelTemplateStyleBindingContext.prototype.isUpsideDown;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.ILabelTemplateStyleBindingContext;
/**
 * @record
 * @struct
 */
yfiles.styles.TemplateLabelStyleBase = function() {};
 /** @type {!Object} */
yfiles.styles.TemplateLabelStyleBase.prototype.styleTag;
 /** @type {?} */
yfiles.styles.TemplateLabelStyleBase.prototype.contextLookup;
 /** @type {!yfiles.geometry.GeneralPath} */
yfiles.styles.TemplateLabelStyleBase.prototype.normalizedOutline;
 /** @type {boolean} */
yfiles.styles.TemplateLabelStyleBase.prototype.autoFlip;
 /** @type {!yfiles.geometry.Size} */
yfiles.styles.TemplateLabelStyleBase.prototype.preferredSize;
 /** @type {?} */
yfiles.styles.TemplateLabelStyleBase.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplateLabelStyleBase.$class;

/**
 * Performs a shallow clone of this instance, except for the value of {\@link yfiles.styles.TemplateLabelStyleBase#styleTag} which is cloned, too, if it can be cloned.
 * @return {!Object} A clone of this instance.
 */
yfiles.styles.TemplateLabelStyleBase.prototype.clone = function() {};

/**
 * Factory method that is called by the {\@link yfiles.styles.TemplateLabelStyleRenderer} to create the visual that will be used for
 * the display of the label.
 * @param {?} context The context for which the visual should be created.
 * @param {?} label The label that will be rendered.
 * @return {!yfiles.view.SvgVisual} The readily styled visual.
 */
yfiles.styles.TemplateLabelStyleBase.prototype.createTemplate = function(context, label) {};

/**
 * Convenience method that determines the preferred size of the label if this style was applied.
 * @param {?} context The context for which the size should be calculated.
 * @param {?} label The label to determine the preferred size of.
 * @return {!yfiles.geometry.Size} The preferred size.
 */
yfiles.styles.TemplateLabelStyleBase.prototype.getPreferredSize = function(context, label) {};

/**
 * Loads all template script elements that have not been parsed, yet, and creates the respective template cache objects.
 * <p>
 * This method can be called to perform the template loading at a certain point in time, for example during application
 * startup. By default, a template is loaded lazily when the first visual using this template is built.
 * </p>
 * @return {void}
 */
yfiles.styles.TemplateLabelStyleBase.loadAllTemplates = function() {};

/**
 * Raises the {\@link yfiles.styles.TemplateLabelStyleBase#addPropertyChangedListener PropertyChanged} event.
 * @protected
 * @param {!yfiles.lang.PropertyChangedEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.styles.TemplateLabelStyleBase.prototype.onPropertyChanged = function(evt) {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * @see yfiles.styles.TemplateLabelStyleBase#removePropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.styles.TemplateLabelStyleBase.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * @see yfiles.styles.TemplateLabelStyleBase#addPropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.styles.TemplateLabelStyleBase.prototype.removePropertyChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TemplateLabelStyle = function() {};
 /** @type {string} */
yfiles.styles.TemplateLabelStyle.prototype.styleResourceKey;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplateLabelStyle.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.StringTemplateLabelStyle = function() {};
 /** @type {string} */
yfiles.styles.StringTemplateLabelStyle.prototype.svgContent;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.StringTemplateLabelStyle.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.TemplateLabelStyleRenderer = function() {};
 /** @type {?} */
yfiles.styles.TemplateLabelStyleRenderer.prototype.layout;
 /** @type {!yfiles.styles.TemplateLabelStyleBase} */
yfiles.styles.TemplateLabelStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.TemplateLabelStyleRenderer.prototype.label;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplateLabelStyleRenderer.$class;

/**
 * Stores the {\@link yfiles.graph.ILabel#layout layout}.
 * <p>
 * Subclasses should override this method, call the super implementation and configure their painting entities.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.configure = function() {};

/**
 * Creates the visual by delegating to {\@link yfiles.styles.TemplateLabelStyleBase#createTemplate} and then initializing the
 * control with the context.
 * @param {?} context The context for the creation.
 * @return {!yfiles.view.Visual} The visual that is used for rendering the label.
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.createVisual = function(context) {};

/**
 *
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the {\@link yfiles.styles.TemplateLabelStyleRenderer#style} and {\@link yfiles.styles.TemplateLabelStyleRenderer#label} properties, calls {\@link yfiles.styles.TemplateLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplateLabelStyleRenderer#getBounds
 * @param {?} label The label to retrieve the bounds provider for. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getBoundsProvider = function(label, style) {};

/**
 * Configures the {\@link yfiles.styles.TemplateLabelStyleRenderer#style} and {\@link yfiles.styles.TemplateLabelStyleRenderer#label} properties, does <b>not</b> call {\@link yfiles.styles.TemplateLabelStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.TemplateLabelStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.TemplateLabelStyleRenderer#lookup} method call they should
 * call {\@link yfiles.styles.TemplateLabelStyleRenderer#configure} only if needed, i.e. if they decide to return <code>this</code> or an
 * instance that depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.TemplateLabelStyleRenderer#lookup
 * @param {?} label The label to query the context for. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getContext = function(label, style) {};

/**
 * Configures the {\@link yfiles.styles.TemplateLabelStyleRenderer#style} and {\@link yfiles.styles.TemplateLabelStyleRenderer#label} properties, calls {\@link yfiles.styles.TemplateLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplateLabelStyleRenderer#isHit
 * @param {?} label The label to query hit test with. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getHitTestable = function(label, style) {};

/**
 * Configures the {\@link yfiles.styles.TemplateLabelStyleRenderer#style} and {\@link yfiles.styles.TemplateLabelStyleRenderer#label} properties, calls {\@link yfiles.styles.TemplateLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplateLabelStyleRenderer#isInBox
 * @param {?} label The label to query marquee intersection tests. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getMarqueeTestable = function(label, style) {};

/**
 * Gets the normalized outline by delegating to {\@link yfiles.styles.TemplateLabelStyleBase#normalizedOutline}.
 * @protected
 * @param {!yfiles.styles.TemplateLabelStyleBase} style
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getNormalizedOutline = function(style) {};

/**
 * Calculates the preferred size for the given label and style.
 * @see yfiles.styles.TemplateLabelStyleRenderer#getPreferredSizeCore
 * @param {?} label The label instance.
 * @param {?} style The style instance to apply.
 * @return {!yfiles.geometry.Size} The preferred size for the given label and style.
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getPreferredSize = function(label, style) {};

/**
 * Gets the size of the preferred for the current configuration using the provided context.
 * @protected
 * @param {?} context The context.
 * @return {!yfiles.geometry.Size}
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getPreferredSizeCore = function(context) {};

/**
 * Calculates the preferred size for the given label and style.
 * @see yfiles.styles.TemplateLabelStyleRenderer#getPreferredSizeCore
 * @param {?} context
 * @param {?} label The label instance.
 * @param {?} style The style instance to apply.
 * @return {!yfiles.geometry.Size} The preferred size for the given label and style.
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getPreferredSizeWithContext = function(context, label, style) {};

/**
 * Configures the {\@link yfiles.styles.TemplateLabelStyleRenderer#style} and {\@link yfiles.styles.TemplateLabelStyleRenderer#label} properties, does <b>not</b> call {\@link yfiles.styles.TemplateLabelStyleRenderer#configure} and returns <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.TemplateLabelStyleRenderer#configure}. If
 * the subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.TemplateLabelStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.TemplateLabelStyleRenderer#isVisible
 * @param {?} label The label to query visibility tests. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getVisibilityTestable = function(label, style) {};

/**
 * Configures the {\@link yfiles.styles.TemplateLabelStyleRenderer#style} and {\@link yfiles.styles.TemplateLabelStyleRenderer#label} properties, calls {\@link yfiles.styles.TemplateLabelStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplateLabelStyleRenderer#createVisual
 * @see yfiles.styles.TemplateLabelStyleRenderer#updateVisual
 * @param {?} label The label to retrieve the {\@link } for. The value will be stored in the {\@link #label} property.
 * @param {?} style The style to associate with the label. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.getVisualCreator = function(label, style) {};

/**
 * Delegates to the {\@link yfiles.styles.TemplateLabelStyleBase}'s {\@link yfiles.styles.TemplateLabelStyleBase#autoFlip} property.
 * @protected
 * @param {!yfiles.styles.TemplateLabelStyleBase} style
 * @return {boolean}
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.isAutoFlip = function(style) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.isHit = function(context, location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 * Uses the {\@link yfiles.graph.ILabel#layout layout} to determine whether the clip intersects.
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 * Delegates to the {\@link yfiles.styles.TemplateLabelStyleBase#contextLookup} of the {\@link yfiles.styles.ILabelStyle}.
 * @param {!yfiles.lang.Class} type The type to query an instance for.
 * @return {!Object} The implementation or <code>null</code>.
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.lookup = function(type) {};

/**
 * Delegates to the {\@link yfiles.styles.TemplateLabelStyleBase}'s {\@link yfiles.styles.TemplateLabelStyleBase#contextLookup}.
 * @protected
 * @param {!yfiles.styles.TemplateLabelStyleBase} style The style to look up the context for.
 * @param {?} label The current label.
 * @param {!yfiles.lang.Class} type The type to look up.
 * @return {!Object} The result from the context or <code>null</code>.
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.lookupContext = function(style, label, type) {};

/**
 * Updates the visual correspondingly.
 * @param {?} context The context for the creation.
 * @param {!yfiles.view.Visual} oldVisual The currently rendered visual.
 * @return {!yfiles.view.Visual} The visual that is used for rendering the label.
 */
yfiles.styles.TemplateLabelStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TemplateNodeStyleBase = function() {};
 /** @type {!Object} */
yfiles.styles.TemplateNodeStyleBase.prototype.styleTag;
 /** @type {?} */
yfiles.styles.TemplateNodeStyleBase.prototype.contextLookup;
 /** @type {!yfiles.geometry.Insets} */
yfiles.styles.TemplateNodeStyleBase.prototype.insets;
 /** @type {!yfiles.geometry.Size} */
yfiles.styles.TemplateNodeStyleBase.prototype.minimumSize;
 /** @type {!yfiles.geometry.GeneralPath} */
yfiles.styles.TemplateNodeStyleBase.prototype.normalizedOutline;
 /** @type {?} */
yfiles.styles.TemplateNodeStyleBase.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplateNodeStyleBase.$class;

/**
 * Performs a shallow clone of this instance, except for the value of {\@link yfiles.styles.TemplateNodeStyleBase#styleTag} which is cloned, too, if it can be cloned.
 * @return {!Object} A clone of this instance.
 */
yfiles.styles.TemplateNodeStyleBase.prototype.clone = function() {};

/**
 * Factory method that is called by the {\@link yfiles.styles.TemplateNodeStyleRenderer} to create the visual that will be used for
 * the display of the node.
 * @param {?} context The context for which the visual should be created.
 * @param {?} node The node that will be rendered.
 * @return {!yfiles.view.SvgVisual} The readily styled visual.
 */
yfiles.styles.TemplateNodeStyleBase.prototype.createTemplate = function(context, node) {};

/**
 * Convenience method that determines the preferred size of the node if this style was applied.
 * @see yfiles.view.CanvasComponent#createRenderContext
 * @param {?} context The context for which the size should be calculated. Can be obtained through
 * {\@link #createRenderContext}.
 * @param {?} node The node to determine the preferred size of. Can be a live node or an {\@link }.
 * @return {!yfiles.geometry.Size} The preferred size.
 */
yfiles.styles.TemplateNodeStyleBase.prototype.getPreferredSize = function(context, node) {};

/**
 * Loads all template script elements that have not been parsed, yet, and creates the respective template cache objects.
 * <p>
 * This method can be called to perform the template loading at a certain point in time, for example during application
 * startup. By default, a template is loaded lazily when the first visual using this template is built.
 * </p>
 * @return {void}
 */
yfiles.styles.TemplateNodeStyleBase.loadAllTemplates = function() {};

/**
 * Raises the {\@link yfiles.styles.TemplateNodeStyleBase#addPropertyChangedListener PropertyChanged} event.
 * @protected
 * @param {!yfiles.lang.PropertyChangedEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.styles.TemplateNodeStyleBase.prototype.onPropertyChanged = function(evt) {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * @see yfiles.styles.TemplateNodeStyleBase#removePropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.styles.TemplateNodeStyleBase.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * @see yfiles.styles.TemplateNodeStyleBase#addPropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.styles.TemplateNodeStyleBase.prototype.removePropertyChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TemplateNodeStyle = function() {};
 /** @type {string} */
yfiles.styles.TemplateNodeStyle.prototype.styleResourceKey;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplateNodeStyle.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.StringTemplateNodeStyle = function() {};
 /** @type {string} */
yfiles.styles.StringTemplateNodeStyle.prototype.svgContent;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.StringTemplateNodeStyle.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.TemplateNodeStyleRenderer = function() {};
 /** @type {!yfiles.styles.TemplateNodeStyleBase} */
yfiles.styles.TemplateNodeStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.TemplateNodeStyleRenderer.prototype.node;
 /** @type {?} */
yfiles.styles.TemplateNodeStyleRenderer.prototype.layout;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplateNodeStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and node have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.TemplateNodeStyleRenderer#style} and {\@link yfiles.styles.TemplateNodeStyleRenderer#node} properties have been populated by the
 * {\@link yfiles.styles.TemplateNodeStyleRenderer#getVisualCreator}, {\@link yfiles.styles.TemplateNodeStyleRenderer#getBoundsProvider},
 * {\@link yfiles.styles.TemplateNodeStyleRenderer#getHitTestable}, or {\@link yfiles.styles.TemplateNodeStyleRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * <p>
 * This is an empty implementation. Subclasses might have to override this method.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.configure = function() {};

/**
 * Creates the visual by delegating to {\@link yfiles.styles.TemplateNodeStyleBase#createTemplate} and then initializing the control
 * with the context.
 * @param {?} context The context for the creation.
 * @return {!yfiles.view.Visual} The visual that is used for rendering the node.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.createVisual = function(context) {};

/**
 * Returns the layout bounds as an upper bound for the painting bound.
 * <p>
 * This implementation simply sets the {\@link yfiles.styles.TemplateNodeStyleRenderer#layout}'s bounds to the scratch variable and returns.
 * </p>
 * @param {?} context the context to calculate the bounds for
 * @return {!yfiles.geometry.Rect} the bounds or <code>null</code> to indicate an unbound area
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Provides a {\@link yfiles.view.IBoundsProvider bounds calculation} implementation for the given style and node.
 * <p>
 * If {\@link yfiles.styles.TemplateNodeStyleBase#contextLookup} provides an implementation of the {\@link yfiles.view.IBoundsProvider} interface than this instance will be returned,
 * otherwise the default (rectangular) behavior will be used.
 * </p>
 * @param {?} node The node to query the provider for.
 * @param {?} style The style whose provider is queried.
 * @return {?} An implementation that can calculate visual bounds.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getBoundsProvider = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.TemplateNodeStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.TemplateNodeStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.TemplateNodeStyleRenderer#lookup} method call they should call
 * {\@link yfiles.styles.TemplateNodeStyleRenderer#configure} only if needed, i.e. if they decide to return <code>this</code> or an instance that
 * depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.TemplateNodeStyleRenderer#lookup
 * @param {?} node The node to query the context for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getContext = function(node, style) {};

/**
 * Gets the context by delegating to {\@link yfiles.styles.TemplateNodeStyleBase#contextLookup}.
 * @protected
 * @param {!yfiles.styles.TemplateNodeStyleBase} style
 * @return {?}
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getContextLookup = function(style) {};

/**
 * Provides a {\@link yfiles.input.IHitTestable hit testing} implementation for the given style and node.
 * <p>
 * If {\@link yfiles.styles.TemplateNodeStyleBase#contextLookup} provides an implementation of the {\@link yfiles.input.IHitTestable} interface than this instance will be returned, otherwise
 * the {\@link yfiles.styles.TemplateNodeStyleRenderer#getNormalizedOutline outline shape} will be used to perform the hit testing.
 * </p>
 * @see yfiles.styles.TemplateNodeStyleRenderer#isHit
 * @param {?} node The node to query the tester for.
 * @param {?} style The style whose tester is queried.
 * @return {?} An implementation that can perform the hit testing.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getHitTestable = function(node, style) {};

/**
 * Gets the insets by delegating to {\@link yfiles.styles.TemplateNodeStyleBase#insets}.
 * @protected
 * @param {!yfiles.styles.TemplateNodeStyleBase} style
 * @return {!yfiles.geometry.Insets}
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getInsets = function(style) {};

/**
 * Tries to use the {\@link yfiles.styles.TemplateNodeStyleRenderer#getNormalizedOutline outline shape} to perform the intersection calculation, otherwise reverts to default (rectangular)
 * behavior.
 * @param {!yfiles.geometry.Point} inner
 * @param {!yfiles.geometry.Point} outer
 * @return {!yfiles.geometry.Point}
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getIntersection = function(inner, outer) {};

/**
 * Provides a {\@link yfiles.input.IMarqueeTestable marquee testing} implementation for the given style and node.
 * <p>
 * If {\@link yfiles.styles.TemplateNodeStyleBase#contextLookup} provides an implementation of the {\@link yfiles.input.IMarqueeTestable} interface than this instance will be returned,
 * otherwise the {\@link yfiles.styles.TemplateNodeStyleRenderer#getNormalizedOutline outline shape} will be used to determine the marquee intersection test with the visual representation of
 * the node.
 * </p>
 * @see yfiles.styles.TemplateNodeStyleRenderer#isInBox
 * @param {?} node The node to query the tester for.
 * @param {?} style The style whose tester is queried.
 * @return {?} An implementation that can test for marquee intersections.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getMarqueeTestable = function(node, style) {};

/**
 * Gets the minimum size by delegating to {\@link yfiles.styles.TemplateNodeStyleBase#minimumSize}.
 * @protected
 * @param {!yfiles.styles.TemplateNodeStyleBase} style
 * @return {!yfiles.geometry.Size}
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getMinimumSize = function(style) {};

/**
 * Gets the normalized outline by delegating to {\@link yfiles.styles.TemplateNodeStyleBase#normalizedOutline}.
 * @protected
 * @param {!yfiles.styles.TemplateNodeStyleBase} style
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getNormalizedOutline = function(style) {};

/**
 * Tries to use the {\@link yfiles.styles.TemplateNodeStyleRenderer#getNormalizedOutline outline shape} to create the outline shape path, otherwise reverts to default (rectangular) behavior.
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getOutline = function() {};

/**
 * Calculates the preferred size for the given node and style in the provided context.
 * @see yfiles.styles.TemplateNodeStyleRenderer#getPreferredSizeCore
 * Calculates the preferred size for the given node and style.
 * @see yfiles.styles.TemplateNodeStyleRenderer#getPreferredSizeCore
 * @param {?} context_or_node The context for which the preferred size should be calculated. / The node instance.
 * @param {?} node_or_style The node instance. / The style instance to apply.
 * @param {?=} style The style instance to apply.
 * @return {!yfiles.geometry.Size} The preferred size for the given label and style.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getPreferredSize = function(context_or_node, node_or_style, style) {};

/**
 * Calculates the preferred size given the current state of the renderer for the given context.
 * @protected
 * @param {?} context The render context for which the preferred size should be calculated.
 * @return {!yfiles.geometry.Size} The size as suggested by this renderer.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getPreferredSizeCore = function(context) {};

/**
 * Provides the geometry for the visual representation.
 * <p>
 * If {\@link yfiles.styles.TemplateNodeStyleBase#contextLookup} provides an implementation of the {\@link yfiles.styles.IShapeGeometry} interface than this instance will be returned,
 * otherwise the {\@link yfiles.styles.TemplateNodeStyleRenderer#getNormalizedOutline outline shape} will be used to determine the outline of the visual representation of a node.
 * </p>
 * @see yfiles.styles.TemplateNodeStyleRenderer#isInside
 * @see yfiles.styles.TemplateNodeStyleRenderer#getOutline
 * @param {?} node The node to query the geometry for.
 * @param {?} style The style for which the geometry is queried.
 * @return {?} An implementation that describes the outline geometry of the shape.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getShapeGeometry = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, does <b>not</b> call {\@link yfiles.styles.TemplateNodeStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.TemplateNodeStyleRenderer#configure}. If
 * the subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.TemplateNodeStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.TemplateNodeStyleRenderer#isVisible
 * @param {?} node The node to query visibility tests. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getVisibilityTestable = function(node, style) {};

/**
 * Configures the <code>style</code> and <code>node</code> parameters, calls {\@link yfiles.styles.TemplateNodeStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplateNodeStyleRenderer#createVisual
 * @see yfiles.styles.TemplateNodeStyleRenderer#updateVisual
 * @param {?} node The node to retrieve the {\@link } for. The value will be stored in the {\@link #node} property.
 * @param {?} style The style to associate with the node. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.getVisualCreator = function(node, style) {};

/**
 * Tries to use the {\@link yfiles.styles.TemplateNodeStyleRenderer#getNormalizedOutline outline shape} to perform the hit test analysis, otherwise reverts to default (rectangular) behavior.
 * @param {?} context the context the hit test is performed in
 * @param {!yfiles.geometry.Point} location the hit point in world coordinates
 * @return {boolean} whether something has been hit
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.isHit = function(context, location) {};

/**
 * Tries to use the {\@link yfiles.styles.TemplateNodeStyleRenderer#getNormalizedOutline outline shape} to perform the marquee intersection analysis, otherwise reverts to default (rectangular)
 * behavior.
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 * Tries to use the {\@link yfiles.styles.TemplateNodeStyleRenderer#getNormalizedOutline outline shape} to perform the contains test, otherwise reverts to default (rectangular) behavior.
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.isInside = function(location) {};

/**
 * Determines visibility by checking for an intersection with the {\@link yfiles.styles.TemplateNodeStyleRenderer#layout}.
 * @param {?} context The context.
 * @param {!yfiles.geometry.Rect} rectangle The current clip
 * @return {boolean} Whether the {\@link #layout} is visible in the clip.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 * Implementation of the {\@link yfiles.graph.ILookup#lookup} method.
 * <p>
 * Delegates to the lookup returned by {\@link yfiles.styles.TemplateNodeStyleRenderer#getContextLookup}, first. Returns special {\@link yfiles.input.INodeInsetsProvider}
 * or {\@link yfiles.input.INodeSizeConstraintProvider} implementations if asked for. Last, it returns this class if it implements
 * the queried <code>type</code>.
 * </p>
 * @param {!yfiles.lang.Class} type The type to query an instance for.
 * @return {!Object} The implementation or <code>null</code>.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.lookup = function(type) {};

/**
 * Updates the component correspondingly.
 * @param {?} context The context for the creation.
 * @param {!yfiles.view.Visual} oldVisual The currently rendered visual.
 * @return {!yfiles.view.Visual} The visual that is used for rendering the node.
 */
yfiles.styles.TemplateNodeStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TemplatePortStyleBase = function() {};
 /** @type {!Object} */
yfiles.styles.TemplatePortStyleBase.prototype.styleTag;
 /** @type {?} */
yfiles.styles.TemplatePortStyleBase.prototype.contextLookup;
 /** @type {!yfiles.geometry.Size} */
yfiles.styles.TemplatePortStyleBase.prototype.renderSize;
 /** @type {!yfiles.geometry.GeneralPath} */
yfiles.styles.TemplatePortStyleBase.prototype.normalizedOutline;
 /** @type {?} */
yfiles.styles.TemplatePortStyleBase.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplatePortStyleBase.$class;

/**
 * Performs a shallow clone of this instance, except for the value of {\@link yfiles.styles.TemplatePortStyleBase#styleTag} which is cloned, too, if it can be cloned.
 * @return {!Object} A clone of this instance.
 */
yfiles.styles.TemplatePortStyleBase.prototype.clone = function() {};

/**
 * Factory method that is called by the {\@link yfiles.styles.TemplatePortStyleRenderer} to create the visual that will be used for
 * the display of the port.
 * @param {?} context The context for which the visual should be created.
 * @param {?} port The port that will be rendered.
 * @return {!yfiles.view.SvgVisual} The readily styled visual.
 */
yfiles.styles.TemplatePortStyleBase.prototype.createTemplate = function(context, port) {};

/**
 * Convenience method that determines the preferred {\@link yfiles.styles.TemplatePortStyleBase#renderSize} of the port if this style was applied.
 * @param {?} context The context for which the size should be calculated.
 * @param {?} port The port to determine the preferred size of.
 * @return {!yfiles.geometry.Size} The preferred size.
 */
yfiles.styles.TemplatePortStyleBase.prototype.getPreferredSize = function(context, port) {};

/**
 * Loads all template script elements that have not been parsed, yet, and creates the respective template cache objects.
 * <p>
 * This method can be called to perform the template loading at a certain point in time, for example during application
 * startup. By default, a template is loaded lazily when the first visual using this template is built.
 * </p>
 * @return {void}
 */
yfiles.styles.TemplatePortStyleBase.loadAllTemplates = function() {};

/**
 * Raises the {\@link yfiles.styles.TemplatePortStyleBase#addPropertyChangedListener PropertyChanged} event.
 * @protected
 * @param {!yfiles.lang.PropertyChangedEventArgs} evt The {\@link } instance containing the event data.
 * @return {void}
 */
yfiles.styles.TemplatePortStyleBase.prototype.onPropertyChanged = function(evt) {};

/**
 * Adds the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * @see yfiles.styles.TemplatePortStyleBase#removePropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to add.
 * @return {void}
 */
yfiles.styles.TemplatePortStyleBase.prototype.addPropertyChangedListener = function(listener) {};

/**
 * Removes the given listener for the <code>PropertyChanged</code> event that occurs when a property value changes.
 * @see yfiles.styles.TemplatePortStyleBase#addPropertyChangedListener
 * @param {function(!Object, !yfiles.lang.PropertyChangedEventArgs): void} listener The listener to remove.
 * @return {void}
 */
yfiles.styles.TemplatePortStyleBase.prototype.removePropertyChangedListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.styles.TemplatePortStyle = function() {};
 /** @type {string} */
yfiles.styles.TemplatePortStyle.prototype.styleResourceKey;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplatePortStyle.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.TemplatePortStyleRenderer = function() {};
 /** @type {!yfiles.geometry.Point} */
yfiles.styles.TemplatePortStyleRenderer.prototype.center;
 /** @type {!yfiles.styles.TemplatePortStyleBase} */
yfiles.styles.TemplatePortStyleRenderer.prototype.style;
 /** @type {?} */
yfiles.styles.TemplatePortStyleRenderer.prototype.port;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.TemplatePortStyleRenderer.$class;

/**
 * Prepares this instance for subsequent calls after the style and port have been initialized.
 * <p>
 * Upon invocation the {\@link yfiles.styles.TemplatePortStyleRenderer#style} and {\@link yfiles.styles.TemplatePortStyleRenderer#port} properties have been populated by the
 * {\@link yfiles.styles.TemplatePortStyleRenderer#getVisualCreator}, {\@link yfiles.styles.TemplatePortStyleRenderer#getBoundsProvider},
 * {\@link yfiles.styles.TemplatePortStyleRenderer#getHitTestable}, or {\@link yfiles.styles.TemplatePortStyleRenderer#getMarqueeTestable}
 * methods.
 * </p>
 * @protected
 * @return {void}
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.configure = function() {};

/**
 * Creates the visual by delegating to {\@link yfiles.styles.TemplatePortStyleBase#createTemplate} and then initializing the visual
 * with the context.
 * @param {?} context The context for the creation.
 * @return {!yfiles.view.Visual} The visual that is used for rendering the port.
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.createVisual = function(context) {};

/**
 *
 * @param {?} context
 * @return {!yfiles.geometry.Rect}
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getBounds = function(context) {};

/**
 * Configures the <code>style</code> and <code>port</code> parameters, calls {\@link yfiles.styles.TemplatePortStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplatePortStyleRenderer#getBounds
 * @param {?} port The port to retrieve the bounds provider for. The value will be stored in the {\@link #port} property.
 * @param {?} style The style to associate with the port. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getBoundsProvider = function(port, style) {};

/**
 * Configures the <code>style</code> and <code>port</code> parameters, does <b>not</b> call {\@link yfiles.styles.TemplatePortStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * As this method may be called often it will not automatically call {\@link yfiles.styles.TemplatePortStyleRenderer#configure},
 * instead subclasses should ensure that in the {\@link yfiles.styles.TemplatePortStyleRenderer#lookup} method call they should call
 * {\@link yfiles.styles.TemplatePortStyleRenderer#configure} only if needed, i.e. if they decide to return <code>this</code> or an instance that
 * depends on a correctly configured <code>this</code>.
 * </p>
 * @see yfiles.styles.TemplatePortStyleRenderer#lookup
 * @param {?} port The port to query the context for. The value will be stored in the {\@link #port} property.
 * @param {?} style The style to associate with the port. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getContext = function(port, style) {};

/**
 * Configures the <code>style</code> and <code>port</code> parameters, calls {\@link yfiles.styles.TemplatePortStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplatePortStyleRenderer#isHit
 * @param {?} port The port to query hit test with. The value will be stored in the {\@link #port} property.
 * @param {?} style The style to associate with the port. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getHitTestable = function(port, style) {};

/**
 * Configures the <code>style</code> and <code>port</code> parameters, calls {\@link yfiles.styles.TemplatePortStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplatePortStyleRenderer#isInBox
 * @param {?} port The port to query marquee intersection tests. The value will be stored in the {\@link #port} property.
 * @param {?} style The style to associate with the port. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getMarqueeTestable = function(port, style) {};

/**
 * Gets the normalized outline by delegating to {\@link yfiles.styles.TemplatePortStyleBase#normalizedOutline}.
 * @protected
 * @param {!yfiles.styles.TemplatePortStyleBase} style
 * @return {!yfiles.geometry.GeneralPath}
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getNormalizedOutline = function(style) {};

/**
 * Calculates the preferred size for the given port and style.
 * @see yfiles.styles.TemplatePortStyleRenderer#getPreferredSizeCore
 * @param {?} context The render context which can be <code>null</code>.
 * @param {?} port The port instance.
 * @param {!yfiles.styles.TemplatePortStyleBase} style The style instance to apply.
 * @return {!yfiles.geometry.Size} The preferred size for the given port and style.
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getPreferredSize = function(context, port, style) {};

/**
 * Gets the preferred size for the current configuration.
 * @protected
 * @param {?} context
 * @return {!yfiles.geometry.Size} The preferred size.
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getPreferredSizeCore = function(context) {};

/**
 * Gets the size of the rendering from the style.
 * @protected
 * @return {!yfiles.geometry.Size} The {\@link #renderSize}.
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getRenderSize = function() {};

/**
 * Configures the <code>style</code> and <code>port</code> parameters, does <b>not</b> call {\@link yfiles.styles.TemplatePortStyleRenderer#configure} and returns
 * <code>this</code>.
 * <p>
 * Unlike most of the other methods this implementation does <b>not</b> call {\@link yfiles.styles.TemplatePortStyleRenderer#configure}. If
 * the subclass implementation depends on this instance to be configured, it needs to call <code>Configure</code> in
 * {\@link yfiles.styles.TemplatePortStyleRenderer#isVisible}.
 * </p>
 * @see yfiles.styles.TemplatePortStyleRenderer#isVisible
 * @param {?} port The port to query visibility tests. The value will be stored in the {\@link #port} property.
 * @param {?} style The style to associate with the port. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getVisibilityTestable = function(port, style) {};

/**
 * Configures the <code>style</code> and <code>port</code> parameters, calls {\@link yfiles.styles.TemplatePortStyleRenderer#configure} and returns <code>this</code>.
 * @see yfiles.styles.TemplatePortStyleRenderer#createVisual
 * @see yfiles.styles.TemplatePortStyleRenderer#updateVisual
 * @param {?} port The port to retrieve the {\@link } for. The value will be stored in the {\@link #port} property.
 * @param {?} style The style to associate with the port. The value will be stored in the {\@link #style} property.
 * @return {?} <code>this</code>
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.getVisualCreator = function(port, style) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Point} location
 * @return {boolean}
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.isHit = function(context, location) {};

/**
 *
 * @param {?} context
 * @param {!yfiles.geometry.Rect} rectangle
 * @return {boolean}
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.isInBox = function(context, rectangle) {};

/**
 * Calls {\@link yfiles.styles.TemplatePortStyleRenderer#configure} and test the {\@link yfiles.styles.TemplatePortStyleRenderer#port} using the {\@link yfiles.styles.TemplatePortStyleRenderer#style} for a visible intersection with the
 * clip bounds.
 * <p>
 * This simple implementation uses {\@link yfiles.styles.TemplatePortStyleRenderer#getBounds} to determine the visibility.
 * Subclasses may choose to override this behavior for improved performance but need to <b>make sure to call {\@link yfiles.styles.TemplatePortStyleRenderer#configure}</b> if they depend on a configured
 * instance.
 * </p>
 * @see yfiles.styles.TemplatePortStyleRenderer#getVisibilityTestable
 * @param {?} context the current canvas context
 * @param {!yfiles.geometry.Rect} rectangle the clip bounds
 * @return {boolean} <code>true</code> if the port may be painted within the clip bounds.
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.isVisible = function(context, rectangle) {};

/**
 * Implements the {\@link yfiles.graph.ILookup} interface.
 * <p>
 * This method will be used by default if {\@link yfiles.styles.TemplatePortStyleRenderer#getContext} has been queried for a lookup
 * implementation. Note that it cannot be assumed that {\@link yfiles.styles.TemplatePortStyleRenderer#configure} has already been
 * invoked. However, normally {\@link yfiles.styles.TemplatePortStyleRenderer#port} and {\@link yfiles.styles.TemplatePortStyleRenderer#style} will be correctly configured if invoked directly after <code>GetContext</code>. Subclass
 * implementations should make sure to configure this instance before they return <code>this</code> as a result of a successful lookup.
 * This implementation will check if <code>type.IsInstanceOfType(this)</code> and will call {\@link yfiles.styles.TemplatePortStyleRenderer#configure}
 * on success and return <code>this</code>.
 * </p>
 * @param {!yfiles.lang.Class} type The type to query for.
 * @return {!Object} An implementation or <code>null</code>.
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.lookup = function(type) {};

/**
 * Delegates to the {\@link yfiles.styles.TemplatePortStyleBase}'s {\@link yfiles.styles.TemplatePortStyleBase#contextLookup}.
 * @protected
 * @param {!yfiles.styles.TemplatePortStyleBase} style
 * @param {?} port
 * @param {!yfiles.lang.Class} type
 * @return {!Object}
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.lookupContext = function(style, port, type) {};

/**
 * Updates the component correspondingly.
 * @param {?} context The context for the creation.
 * @param {!yfiles.view.Visual} oldVisual The currently rendered visual.
 * @return {!yfiles.view.Visual} The visual that is used for rendering the port.
 */
yfiles.styles.TemplatePortStyleRenderer.prototype.updateVisual = function(context, oldVisual) {};
/**
 * @record
 * @struct
 */
yfiles.styles.StringTemplatePortStyle = function() {};
 /** @type {string} */
yfiles.styles.StringTemplatePortStyle.prototype.svgContent;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.StringTemplatePortStyle.$class;
/**
 * @record
 * @struct
 */
yfiles.styles.IStripeStyle = function() {};
 /** @type {?} */
yfiles.styles.IStripeStyle.prototype.renderer;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IStripeStyle;
/**
 * @record
 * @struct
 */
yfiles.styles.IStripeStyleRenderer = function() {};

/**
 * Gets a temporary context instance that can be used to query additional information for the stripe's style.
 * <p>
 * Implementations may return {\@link yfiles.graph.ILookup#EMPTY} if they don't support this, but may not return <code>null</code>.
 * </p>
 * @see yfiles.graph.ILookup#EMPTY
 * @see yfiles.graph.ILookup
 * @abstract
 * @param {?} stripe The stripe to provide a context instance for.
 * @param {?} style The style to use for the context.
 * @return {?} An non-<code>null</code> lookup implementation.
 */
yfiles.styles.IStripeStyleRenderer.prototype.getContext = function(stripe, style) {};

/**
 * Gets an implementation of the {\@link yfiles.view.IVisualCreator} interface that can handle the provided stripe and its
 * associated style.
 * <p>
 * This method may return a flyweight implementation, but never <code>null</code>.
 * </p>
 * @see yfiles.view.VoidVisualCreator#INSTANCE
 * @abstract
 * @param {?} stripe The nstripeode to provide an instance for
 * @param {?} style The style to use for the creation of the visual
 * @return {?} An implementation that may be used to subsequently create or update the visual for the stripe. Clients should not cache
 * this instance and must always call this method immediately before using the value returned. This enables the use of the
 * flyweight design pattern for implementations. This method may not return <code>null</code> but should yield a {\@link #INSTANCE void} implementation
 * instead.
 */
yfiles.styles.IStripeStyleRenderer.prototype.getVisualCreator = function(stripe, style) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.styles.IStripeStyleRenderer;
/**
 * @record
 * @struct
 */
yfiles.styles.VoidStripeStyle = function() {};
 /** @type {!yfiles.styles.VoidStripeStyle} */
yfiles.styles.VoidStripeStyle.INSTANCE;
 /** @type {?} */
yfiles.styles.VoidStripeStyle.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidStripeStyle.$class;

/**
 * Returns <code>this</code>.
 * @return {!Object} <code>this</code>
 */
yfiles.styles.VoidStripeStyle.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
yfiles.styles.VoidStripeStyleRenderer = function() {};
 /** @type {?} */
yfiles.styles.VoidStripeStyleRenderer.INSTANCE;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.VoidStripeStyleRenderer.$class;

/**
 * Yields the {\@link yfiles.graph.ILookup#EMPTY} that will not yield anything.
 * @param {?} stripe
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidStripeStyleRenderer.prototype.getContext = function(stripe, style) {};

/**
 * Yields the {\@link yfiles.view.VoidVisualCreator#INSTANCE} that will do nothing.
 * @param {?} stripe
 * @param {?} style
 * @return {?}
 */
yfiles.styles.VoidStripeStyleRenderer.prototype.getVisualCreator = function(stripe, style) {};
/**
 * @record
 * @struct
 */
yfiles.styles.NodeStyleStripeStyleAdapter = function() {};
 /** @type {?} */
yfiles.styles.NodeStyleStripeStyleAdapter.prototype.renderer;
 /** @type {?} */
yfiles.styles.NodeStyleStripeStyleAdapter.prototype.nodeStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.NodeStyleStripeStyleAdapter.$class;

/**
 *
 * @return {!Object}
 */
yfiles.styles.NodeStyleStripeStyleAdapter.prototype.clone = function() {};

/** @const */
yfiles.styles.TableRenderingOrder = {};
/** @const {number} */
yfiles.styles.TableRenderingOrder.COLUMNS_FIRST;
/** @const {number} */
yfiles.styles.TableRenderingOrder.ROWS_FIRST;
/**
 * @record
 * @struct
 */
yfiles.styles.StripeStyleBase = function() {};
 /** @type {?} */
yfiles.styles.StripeStyleBase.prototype.renderer;
 /** @type {!yfiles.lang.Class} */
yfiles.styles.StripeStyleBase.$class;

/**
 * Creates a new object that is a copy of the current instance.
 * <p>
 * Immutable subclasses should consider returning <code>this</code>.
 * </p>
 * @return {!Object} A new object that is a copy of this instance using {\@link #memberwiseClone}.
 */
yfiles.styles.StripeStyleBase.prototype.clone = function() {};

/**
 * Callback that creates the visual.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#createVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.StripeStyleBase#renderer}.
 * </p>
 * @see yfiles.styles.StripeStyleBase#updateVisual
 * @protected
 * @abstract
 * @param {?} context
 * @param {?} stripe The stripe to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.StripeStyleBase.prototype.createVisual = function(context, stripe) {};

/**
 * Performs the {\@link yfiles.graph.ILookup#lookup} operation for the {\@link yfiles.styles.IStripeStyleRenderer#getContext} that has been
 * queried from the {\@link yfiles.styles.StripeStyleBase#renderer}.
 * <p>
 * This implementation yields <code>null</code> for everything but:
 * </p>
 * <ul>
 * <li>{\@link yfiles.view.IVisualCreator}</li>
 * <li>{\@link yfiles.graph.ILookup}</li>
 * </ul>
 * <p>
 * For these interfaces an implementation will be returned that delegates to the methods in this instance.
 * </p>
 * @protected
 * @param {?} stripe The stripe to use for the context lookup.
 * @param {!yfiles.lang.Class} type The type to query.
 * @return {!Object} An implementation of the <code>type</code> or <code>null</code>.
 */
yfiles.styles.StripeStyleBase.prototype.lookup = function(stripe, type) {};

/**
 * Callback that updates the visual previously created by {\@link yfiles.styles.StripeStyleBase#createVisual}.
 * <p>
 * This method is called in response to a {\@link yfiles.view.IVisualCreator#updateVisual} call to the instance that has been
 * queried from the {\@link yfiles.styles.StripeStyleBase#renderer}. This implementation simply delegates to {\@link yfiles.styles.StripeStyleBase#createVisual} so subclasses
 * should override to improve rendering performance.
 * </p>
 * @see yfiles.styles.StripeStyleBase#createVisual
 * @protected
 * @param {?} context
 * @param {!yfiles.view.Visual} oldVisual The visual that has been created in the call to {\@link #createVisual}.
 * @param {?} stripe The stripe to which this style instance is assigned.
 * @return {!yfiles.view.Visual} The visual as required by the {\@link #createVisual} interface.
 */
yfiles.styles.StripeStyleBase.prototype.updateVisual = function(context, oldVisual, stripe) {};
/** @const */
yfiles.binding = {};
/**
 * @record
 * @struct
 */
yfiles.binding.AdjacentNodesGraphBuilder = function() {};
 /** @type {!Object} */
yfiles.binding.AdjacentNodesGraphBuilder.prototype.successorsBinding;
 /** @type {!Object} */
yfiles.binding.AdjacentNodesGraphBuilder.prototype.predecessorsBinding;
 /** @type {!yfiles.lang.Class} */
yfiles.binding.AdjacentNodesGraphBuilder.$class;

/**
 * Creates a new edge connecting the given nodes.
 * <p>
 * This class calls this method to create all new edges, and customers may override it to customize edge creation.
 * </p>
 * @protected
 * @param {?} graph The graph.
 * @param {?} source The source node of the edge.
 * @param {?} target The target node of the edge.
 * @return {?} The created edge.
 */
yfiles.binding.AdjacentNodesGraphBuilder.prototype.createEdge = function(graph, source, target) {};

/**
 * Updates an existing edge connecting the given nodes when {\@link yfiles.binding.GraphBuilderBase#updateGraph} is called and the
 * edge should remain in the graph.
 * @protected
 * @param {?} graph The graph.
 * @param {?} edge The edge to update.
 * @param {?} source The source node of the edge.
 * @param {?} target The target node of the edge.
 * @return {void}
 */
yfiles.binding.AdjacentNodesGraphBuilder.prototype.updateEdge = function(graph, edge, source, target) {};
/**
 * @record
 * @struct
 */
yfiles.binding.GraphBuilder = function() {};
 /** @type {boolean} */
yfiles.binding.GraphBuilder.prototype.lazyNodeDefinition;
 /** @type {!Object} */
yfiles.binding.GraphBuilder.prototype.edgesSource;
 /** @type {!Object} */
yfiles.binding.GraphBuilder.prototype.sourceNodeBinding;
 /** @type {!Object} */
yfiles.binding.GraphBuilder.prototype.targetNodeBinding;
 /** @type {!Object} */
yfiles.binding.GraphBuilder.prototype.edgeLabelBinding;
 /** @type {!yfiles.lang.Class} */
yfiles.binding.GraphBuilder.$class;

/**
 * Creates a new edge connecting the given nodes and assigns the <code>businessObject</code>parameter to the edge's {\@link yfiles.graph.ITagOwner#tag Tag} property.
 * <p>
 * This class calls this method to create all new edges, and customers may override it to customize edge creation.
 * </p>
 * @protected
 * @param {?} graph The graph.
 * @param {?} source The source node of the edge.
 * @param {?} target The target node of the edge.
 * @param {!Object} labelData The optional label data of the edge if an {\@link #edgeLabelBinding} is specified.
 * @param {!Object} businessObject The business data associated with the edge.
 * @return {?} The created edge.
 */
yfiles.binding.GraphBuilder.prototype.createEdge = function(graph, source, target, labelData, businessObject) {};

/**
 * Retrieves the associated edge in the {\@link yfiles.binding.GraphBuilderBase#graph} for a business object from the {\@link yfiles.binding.GraphBuilder#edgesSource}.
 * @see yfiles.binding.GraphBuilderBase#getBusinessObject
 * @see yfiles.binding.GraphBuilderBase#getNode
 * @see yfiles.binding.GraphBuilderBase#getGroup
 * @param {!Object} businessObject A business object from the {\@link #edgesSource} to get the edge for.
 * @return {?} The edge associated with the business object or <code>null</code> for unknown objects.
 */
yfiles.binding.GraphBuilder.prototype.getEdge = function(businessObject) {};

/**
 * Updates an existing edge when {\@link yfiles.binding.GraphBuilderBase#updateGraph} is called and the edge should remain in the
 * graph.
 * @protected
 * @param {?} graph The graph.
 * @param {?} edge The edge to update.
 * @param {!Object} labelData The optional label data of the edge if an {\@link #edgeLabelBinding} is specified.
 * @param {!Object} businessObject The business data associated with the edge.
 * @return {void}
 */
yfiles.binding.GraphBuilder.prototype.updateEdge = function(graph, edge, labelData, businessObject) {};
/**
 * @record
 * @struct
 */
yfiles.binding.GraphBuilderBase = function() {};
 /** @type {?} */
yfiles.binding.GraphBuilderBase.prototype.graph;
 /** @type {!Object} */
yfiles.binding.GraphBuilderBase.prototype.nodesSource;
 /** @type {!Object} */
yfiles.binding.GraphBuilderBase.prototype.groupsSource;
 /** @type {!Object} */
yfiles.binding.GraphBuilderBase.prototype.nodeIdBinding;
 /** @type {!Object} */
yfiles.binding.GraphBuilderBase.prototype.nodeLabelBinding;
 /** @type {!Object} */
yfiles.binding.GraphBuilderBase.prototype.groupIdBinding;
 /** @type {!Object} */
yfiles.binding.GraphBuilderBase.prototype.groupBinding;
 /** @type {!Object} */
yfiles.binding.GraphBuilderBase.prototype.parentGroupBinding;
 /** @type {!Object} */
yfiles.binding.GraphBuilderBase.prototype.locationXBinding;
 /** @type {!Object} */
yfiles.binding.GraphBuilderBase.prototype.locationYBinding;
 /** @type {!yfiles.lang.Class} */
yfiles.binding.GraphBuilderBase.$class;

/**
 * Populates the graph instance with items generated from the bound business data.
 * <p>
 * First, this method clears the graph, and then it adds new groups, nodes, and edges as specified by the business data and
 * bindings.
 * </p>
 * @see yfiles.binding.GraphBuilderBase#updateGraph
 * @return {?} The created graph.
 */
yfiles.binding.GraphBuilderBase.prototype.buildGraph = function() {};

/**
 * Creates a new group node and assigns the <code>businessObject</code>parameter to the group node's {\@link yfiles.graph.ITagOwner#tag Tag} property.
 * @protected
 * @param {?} graph The graph.
 * @param {!Object} businessObject The business data associated with the group node.
 * @return {?} The created node.
 */
yfiles.binding.GraphBuilderBase.prototype.createGroupNode = function(graph, businessObject) {};

/**
 * Creates a new node with the specified parent and assigns the <code>businessObject</code>parameter to the node's {\@link yfiles.graph.ITagOwner#tag Tag} property.
 * <p>
 * This class calls this method to create all new nodes, and customers may override it to customize node creation.
 * </p>
 * @protected
 * @param {?} graph The graph.
 * @param {?} parent The node's parent node.
 * @param {!yfiles.geometry.Point} location The location of the node.
 * @param {!Object} labelData The optional label data of the node if an {\@link #nodeLabelBinding} is specified.
 * @param {!Object} businessObject The business data associated with the node.
 * @return {?} The created node.
 */
yfiles.binding.GraphBuilderBase.prototype.createNode = function(graph, parent, location, labelData, businessObject) {};

/**
 * Retrieves the associated business object for a given {\@link yfiles.graph.IModelItem graph item} from the {\@link yfiles.binding.GraphBuilderBase#graph}.
 * @see yfiles.binding.GraphBuilderBase#getNode
 * @see yfiles.binding.GraphBuilderBase#getGroup
 * @param {?} item The item of the graph to get the business object for.
 * @return {!Object} The business object associated with the graph item.
 */
yfiles.binding.GraphBuilderBase.prototype.getBusinessObject = function(item) {};

/**
 * Retrieves the associated group node in the {\@link yfiles.binding.GraphBuilderBase#graph} for a business object from the {\@link yfiles.binding.GraphBuilderBase#groupsSource}.
 * @see yfiles.binding.GraphBuilderBase#getBusinessObject
 * @see yfiles.binding.GraphBuilderBase#getNode
 * @param {!Object} businessObject A business object from the {\@link #groupsSource} to get the group for.
 * @return {?} The group associated with the business object or <code>null</code> for unknown objects.
 */
yfiles.binding.GraphBuilderBase.prototype.getGroup = function(businessObject) {};

/**
 * Retrieves the associated node in the {\@link yfiles.binding.GraphBuilderBase#graph} for a business object from the {\@link yfiles.binding.GraphBuilderBase#nodesSource}.
 * @see yfiles.binding.GraphBuilderBase#getBusinessObject
 * @see yfiles.binding.GraphBuilderBase#getGroup
 * @param {!Object} businessObject A business object from the {\@link #nodesSource} to get the node for.
 * @return {?} The node associated with the business object or <code>null</code> for unknown objects.
 */
yfiles.binding.GraphBuilderBase.prototype.getNode = function(businessObject) {};

/**
 * Updates the graph instance to fit the bound business data.
 * <p>
 * This method can be used to update the graph to fit changed business data. In contrast to
 * {\@link yfiles.binding.GraphBuilderBase#buildGraph}, it does not initially clear the graph. Instead, it keeps graph elements that
 * for business objects are still present in the data, creates new elements for new data, and removes obsolete elements.
 * </p>
 * @return {void}
 */
yfiles.binding.GraphBuilderBase.prototype.updateGraph = function() {};

/**
 * Updates an existing group node when {\@link yfiles.binding.GraphBuilderBase#updateGraph} is called and the group should remain in
 * the graph.
 * <p>
 * This class calls this method to create all new groups, and customers may override it to customize group creation.
 * </p>
 * @protected
 * @param {?} graph The graph.
 * @param {?} groupNode The group node to update.
 * @param {!Object} businessObject The business data associated with the group node.
 * @return {void}
 */
yfiles.binding.GraphBuilderBase.prototype.updateGroupNode = function(graph, groupNode, businessObject) {};

/**
 * Updates an existing node when {\@link yfiles.binding.GraphBuilderBase#updateGraph} is called and the node should remain in the
 * graph.
 * @protected
 * @param {?} graph The graph.
 * @param {?} node The node to update.
 * @param {?} parent The node's parent node.
 * @param {!yfiles.geometry.Point} location The location of the node.
 * @param {!Object} labelData The optional label data of the node if an {\@link #nodeLabelBinding} is specified.
 * @param {!Object} businessObject The business data associated with the node.
 * @return {void}
 */
yfiles.binding.GraphBuilderBase.prototype.updateNode = function(graph, node, parent, location, labelData, businessObject) {};
/**
 * @record
 * @struct
 */
yfiles.binding.TreeBuilder = function() {};
 /** @type {?} */
yfiles.binding.TreeBuilder.prototype.graph;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.nodesSource;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.groupsSource;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.childBinding;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.idBinding;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.edgeLabelBinding;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.nodeLabelBinding;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.locationXBinding;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.locationYBinding;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.groupIdBinding;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.groupBinding;
 /** @type {!Object} */
yfiles.binding.TreeBuilder.prototype.parentGroupBinding;
 /** @type {!yfiles.lang.Class} */
yfiles.binding.TreeBuilder.$class;

/**
 * Populates the graph instance with items generated from the bound business data.
 * <p>
 * First, this method clears the graph, and then it adds new groups, nodes, and edges as specified by the business data and
 * bindings.
 * </p>
 * @see yfiles.binding.TreeBuilder#updateGraph
 * @return {?} The created graph.
 */
yfiles.binding.TreeBuilder.prototype.buildGraph = function() {};

/**
 * Creates an edge between the source and target node.
 * @protected
 * @param {?} graph The graph.
 * @param {?} source The source node of the edge.
 * @param {?} target The target node of the edge.
 * @param {!Object} labelData The optional label data of the edge if an {\@link #edgeLabelBinding} is specified.
 * @return {?} The created edge.
 */
yfiles.binding.TreeBuilder.prototype.createEdge = function(graph, source, target, labelData) {};

/**
 * Creates a new group node and assigns the <code>businessObject</code>parameter to the group node's {\@link yfiles.graph.ITagOwner#tag Tag} property.
 * @protected
 * @param {?} graph The graph.
 * @param {!Object} businessObject The business data associated with the group node.
 * @return {?} The created node.
 */
yfiles.binding.TreeBuilder.prototype.createGroupNode = function(graph, businessObject) {};

/**
 * Creates a node with the specified parent and assigns the <code>businessObject</code> parameter to the node's {\@link yfiles.graph.ITagOwner#tag Tag} property.
 * @protected
 * @param {?} graph The graph.
 * @param {?} parent The node's parent node.
 * @param {!yfiles.geometry.Point} location The location of the node.
 * @param {!Object} labelData The optional label data of the node if an {\@link #nodeLabelBinding} is specified.
 * @param {!Object} businessObject The business data associated with the node.
 * @return {?} The created node.
 */
yfiles.binding.TreeBuilder.prototype.createNode = function(graph, parent, location, labelData, businessObject) {};

/**
 * Retrieves the associated business object for a given {\@link yfiles.graph.INode node} from the {\@link yfiles.binding.TreeBuilder#graph}.
 * @see yfiles.binding.TreeBuilder#getNode
 * @param {?} item The node of the graph to get the business object for.
 * @return {!Object} The business object associated with the graph element.
 */
yfiles.binding.TreeBuilder.prototype.getBusinessObject = function(item) {};

/**
 * Retrieves the associated node in the {\@link yfiles.binding.TreeBuilder#graph} for a business object from the {\@link yfiles.binding.TreeBuilder#nodesSource}.
 * @see yfiles.binding.TreeBuilder#getBusinessObject
 * @param {!Object} businessObject A business object from the {\@link #nodesSource} to get the node for.
 * @return {?} The node associated with the business object or <code>null</code> for unknown objects.
 */
yfiles.binding.TreeBuilder.prototype.getNode = function(businessObject) {};

/**
 * Updates an edge with the given data.
 * @protected
 * @param {?} graph The graph.
 * @param {?} edge The edge to update.
 * @param {?} source The edge's source node.
 * @param {?} target The edge's target node.
 * @param {!Object} labelData The business data associated with the edge.
 * @return {void}
 */
yfiles.binding.TreeBuilder.prototype.updateEdge = function(graph, edge, source, target, labelData) {};

/**
 * Updates the graph instance to fit the bound business data.
 * <p>
 * This method can be used to update the graph to fit changed business data. In contrast to
 * {\@link yfiles.binding.TreeBuilder#buildGraph}, it does not initially clear the graph. Instead, it keeps graph elements that for
 * business objects are still present in the data, creates new elements for new data, and removes obsolete elements.
 * </p>
 * @return {void}
 */
yfiles.binding.TreeBuilder.prototype.updateGraph = function() {};

/**
 * Updates an existing group node when {\@link yfiles.binding.TreeBuilder#updateGraph} is called and the group should remain in the
 * graph.
 * <p>
 * This class calls this method to create all new groups, and customers may override it to customize group creation.
 * </p>
 * @protected
 * @param {?} graph The graph.
 * @param {?} groupNode The group node to update.
 * @param {!Object} businessObject The business data associated with the group node.
 * @return {void}
 */
yfiles.binding.TreeBuilder.prototype.updateGroupNode = function(graph, groupNode, businessObject) {};

/**
 * Updates a node with the given data.
 * @protected
 * @param {?} graph The graph.
 * @param {?} node The node to update.
 * @param {?} parent The node's parent node.
 * @param {!yfiles.geometry.Point} location The location of the node.
 * @param {!Object} labelData The optional label data of the edge if an {\@link #nodeLabelBinding} is specified.
 * @param {!Object} businessObject The business data associated with the node.
 * @return {void}
 */
yfiles.binding.TreeBuilder.prototype.updateNode = function(graph, node, parent, location, labelData, businessObject) {};
/** @const */
yfiles.algorithms = {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.AbortHandler = function() {};
 /** @type {!yfiles.algorithms.GraphDpKey<!yfiles.algorithms.AbortHandler>} */
yfiles.algorithms.AbortHandler.ABORT_HANDLER_DP_KEY;
 /** @type {boolean} */
yfiles.algorithms.AbortHandler.prototype.stopRequested;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.algorithms.AbortHandler.prototype.stopDuration;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.algorithms.AbortHandler.prototype.cancelDuration;
 /** @type {boolean} */
yfiles.algorithms.AbortHandler.prototype.checkFailed;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.AbortHandler.$class;

/**
 * Determines whether or not an algorithm should terminate immediately.
 * <p>
 * This method returns <code>true</code> if the algorithm should terminate gracefully and ensures that the processed graph remains in a
 * consistent state.
 * </p>
 * @throws {yfiles.algorithms.AlgorithmAbortedError} if the algorithm should terminate immediately
 * @see yfiles.algorithms.AbortHandler#stop
 * @return {boolean} <code>true</code>, if the algorithm should terminate immediately, <code>false</code> otherwise
 */
yfiles.algorithms.AbortHandler.prototype.check = function() {};

/**
 * Determines whether or not an algorithm should terminate immediately.
 * <p>
 * This method returns <code>true</code> if the algorithm should terminate gracefully and ensures that the processed graph remains in a
 * consistent state.
 * </p>
 * <p>
 * This convenience method is meant for one-time checks only. For performance critical code that needs to check repeatedly,
 * it is recommended to retrieve the given graph's attached handler once and only call the handler's {\@link yfiles.algorithms.AbortHandler#check}
 * method repeatedly.
 * </p>
 * @throws {yfiles.algorithms.AlgorithmAbortedError} if the algorithm should terminate immediately
 * @throws {Stubs.Exceptions.ArgumentError} if the given graph is <code>null</code>
 * @see yfiles.algorithms.AbortHandler#check
 * @see yfiles.algorithms.AbortHandler#stop
 * @param {!yfiles.algorithms.Graph} graph
 * @return {boolean} <code>true</code>, if the algorithm should stop immediately while still providing some valid result, <code>false</code> otherwise
 */
yfiles.algorithms.AbortHandler.check = function(graph) {};

/**
 * Attaches the {\@link yfiles.algorithms.AbortHandler} instance of the given source graph to the target graph as well.
 * @throws {Stubs.Exceptions.ArgumentError} if the given source is <code>null</code>
 * @param {!yfiles.algorithms.Graph} source the graph whose handler is attached to the target graph
 * @param {!yfiles.algorithms.Graph} target the graph to which the handler of the source graph is attached
 * @return {void}
 */
yfiles.algorithms.AbortHandler.copyHandler = function(source, target) {};

/**
 * Creates an {\@link yfiles.algorithms.AbortHandler handler} instance and attaches it to the given graph.
 * <p>
 * If the given graph has already an attached handler instance, this is the instance that will be returned and this method
 * will not create a new {\@link yfiles.algorithms.AbortHandler}.
 * </p>
 * <p>
 * This method should be called by client code prior to starting a graph algorithm that may be terminated early.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given graph is <code>null</code>.
 * @see yfiles.algorithms.AbortHandler#hasHandler
 * @param {!yfiles.algorithms.Graph} graph the graph to which the handler will be attached
 * @return {!yfiles.algorithms.AbortHandler} the {\@link } instance for the given graph
 */
yfiles.algorithms.AbortHandler.createForGraph = function(graph) {};

/**
 * Returns an {\@link yfiles.algorithms.AbortHandler} instance for the given graph.
 * <p>
 * If {\@link yfiles.algorithms.AbortHandler#createForGraph} has been used for attaching a new handler to the given graph, this is
 * the instance that will be returned. Otherwise, a non-functional instance is returned whose methods do nothing. Use {\@link yfiles.algorithms.AbortHandler#hasHandler}
 * to check whether or not a handler has been already attached to the given graph.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given graph is <code>null</code>
 * @see yfiles.algorithms.AbortHandler#createForGraph
 * @see yfiles.algorithms.AbortHandler#hasHandler
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {!yfiles.algorithms.AbortHandler} an {\@link } for the given graph or a non-functional instance if no handler has been previously
 * created
 */
yfiles.algorithms.AbortHandler.getFromGraph = function(graph) {};

/**
 * Determines whether or not an {\@link yfiles.algorithms.AbortHandler} instance is attached to the given graph.
 * @throws {Stubs.Exceptions.ArgumentError} if the given graph is <code>null</code>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if a handler is attached to the given graph, <code>false</code> otherwise
 */
yfiles.algorithms.AbortHandler.hasHandler = function(graph) {};

/**
 * Removes any attached {\@link yfiles.algorithms.AbortHandler} instance from the given graph.
 * @throws {Stubs.Exceptions.ArgumentError} if the given graph is <code>null</code>.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {void}
 */
yfiles.algorithms.AbortHandler.removeFromGraph = function(graph) {};

/**
 * Resets the state of the {\@link yfiles.algorithms.AbortHandler handler}.
 * <p>
 * Resetting the {\@link yfiles.algorithms.AbortHandler handler} discards any previous stop or cancel requests. Moreover, the handler's internal timestamp that is
 * used for determining whether or not an algorithm should be stopped or cancelled automatically is reset as well.
 * </p>
 * <p>
 * This method should be called whenever a graph with an attached handler is processed an additional time to prevent
 * previous requests for early termination to result in an undesired early termination of the next algorithm run.
 * </p>
 * @see yfiles.algorithms.AbortHandler#cancelDuration
 * @see yfiles.algorithms.AbortHandler#stopDuration
 * @return {void}
 */
yfiles.algorithms.AbortHandler.prototype.reset = function() {};

/**
 * Schedules a stop request.
 * <p>
 * Algorithms that detect stop requests should terminate gracefully and ensure that the processed graph remains in a
 * consistent state.
 * </p>
 * <p>
 * If a Cancel request has already been scheduled for this handler, the stop request is ignored. If a Cancel request is
 * scheduled later on, the stop request is overridden.
 * </p>
 * @see yfiles.algorithms.AbortHandler#check
 * @see yfiles.algorithms.AbortHandler#cancelDuration
 * @return {void}
 */
yfiles.algorithms.AbortHandler.prototype.stop = function() {};

/**
 * Determines the remaining time (in milliseconds) until an algorithm that {\@link yfiles.algorithms.AbortHandler#check checks} this handler is cancelled automatically.
 * @see yfiles.algorithms.AbortHandler#cancelDuration
 * @see yfiles.algorithms.AbortHandler#reset
 * @see yfiles.algorithms.AbortHandler#cancelDuration
 * @return {!yfiles.lang.TimeSpan} the remaining time until the algorithm is cancelled automatically.
 */
yfiles.algorithms.AbortHandler.prototype.timeToCancel = function() {};

/**
 * Determines the remaining time until an algorithm that {\@link yfiles.algorithms.AbortHandler#check checks} this handler is stopped automatically.
 * <p>
 * If the {\@link yfiles.algorithms.AbortHandler#stopDuration stop duration} is less than or equal to zero, <code>-1</code> will be returned which means that the algorithm may run
 * unrestricted.
 * </p>
 * @see yfiles.algorithms.AbortHandler#stopDuration
 * @see yfiles.algorithms.AbortHandler#reset
 * @see yfiles.algorithms.AbortHandler#stop
 * @return {!yfiles.lang.TimeSpan} the remaining time until the algorithm is stopped automatically or <code>-1</code> if the algorithm may run unrestricted
 */
yfiles.algorithms.AbortHandler.prototype.timeToStop = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Bfs = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Bfs.$class;

/**
 * Returns the layers of nodes constructed by a directed/undirected breadth first search where the maximum number of layers
 * is restricted.
 * <p>
 * The first of these layers contains all nodes within the given {\@link yfiles.algorithms.NodeList}. These nodes are the core nodes
 * from which a breadth first search to the other nodes starts. The algorithm fills the provided {\@link yfiles.algorithms.INodeMap}
 * with an integer indicating the layer of each node.
 * </p>
 * <p>
 * In the <code>i</code>-th layer are previously unassigned nodes that are connected to nodes in the <code>(i-1)</code>-th layer.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given direction is not supported
 * Returns the layers of nodes constructed by a directed/undirected breadth first search where the maximum number of layers
 * is restricted.
 * <p>
 * The first of these layers contains all nodes within the given {\@link yfiles.algorithms.NodeList}. These nodes are the core nodes
 * from which either a directed or undirected breadth first search to the other nodes starts. The algorithm fills the
 * provided {\@link yfiles.algorithms.INodeMap} with an integer indicating the layer of each node.
 * </p>
 * <p>
 * In the <code>i</code>-th layer are previously unassigned nodes that are connected to nodes in the <code>(i-1)</code>-th layer.
 * </p>
 * Returns the layers of nodes constructed by a breadth first search.
 * <p>
 * The first of these layers contains all nodes within the given {\@link yfiles.algorithms.NodeList}. These nodes are the core nodes
 * from which an undirected breadth first search to the other nodes starts. The algorithm fills the provided {\@link yfiles.algorithms.INodeMap}
 * with an integer indicating the layer of each node.
 * </p>
 * <p>
 * In the <code>i</code>-th layer are previously unassigned nodes that are connected to nodes in the <code>(i-1)</code>-th layer.
 * </p>
 * Returns the layers of nodes constructed by a breadth first search.
 * <p>
 * The first of these layers contains all nodes for which the given {\@link yfiles.algorithms.IDataProvider} returns <code>true</code>. These
 * nodes are the core nodes from which an undirected breadth first search to the other nodes starts. The algorithm fills
 * the provided {\@link yfiles.algorithms.INodeMap} with an integer indicating the layer of each node.
 * </p>
 * <p>
 * In the <code>i</code>-th layer are previously unassigned nodes that are connected to nodes in the <code>(i-1)</code>-th layer.
 * </p>
 * Returns the layers of nodes calculated by a breadth first search.
 * <p>
 * The first of these layers contains all nodes within the given
 * {\@link yfiles.algorithms.NodeList}. These nodes are the core nodes from which an undirected breadth first search to the other
 * nodes starts.
 * </p>
 * <p>
 * In the <code>i</code>-th layer are previously unassigned nodes that are connected to nodes in the <code>(i-1)</code>-th layer.
 * </p>
 * Returns the layers of nodes constructed by a breadth first search.
 * <p>
 * The first of these layers contains all nodes for which the given {\@link yfiles.algorithms.IDataProvider} returns
 * <code>true</code>. These nodes are the core nodes from which an undirected breadth first search to the other nodes starts.
 * </p>
 * <p>
 * In the <code>i</code>-th layer are previously unassigned nodes that are connected to nodes in the <code>(i-1)</code>-th layer.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {!yfiles.algorithms.NodeList|?} coreNodes_or_isCoreNode the list of core nodes / the list of core nodes from which the BFS starts / the {\@link } that contains the nodes from which the BFS starts; core nodes are marked with a <code>true</code>
 * value
 * @param {yfiles.algorithms.BfsDirection|boolean|?=} direction_or_directed_or_layerIDMap one of the predefined direction specifiers / <code>true</code> if the graph should be considered directed, <code>false</code> otherwise / the {\@link } that will be filled during the BFS execution and holds the zero-based index of the BFS
 * layer to which each node belongs or <code>-1</code> if the node is not reachable
 * @param {?=} layerIDMap the {\@link } that will be filled during the BFS execution and holds the zero-based index of the BFS
 * layer to which each node belongs or <code>-1</code> if the node is not reachable
 * @param {number=} maxLayers
 * @return {!Array<!yfiles.algorithms.NodeList>} an array of {\@link }s each of which contains the nodes of a particular layer
 */
yfiles.algorithms.Bfs.getLayers = function(graph, coreNodes_or_isCoreNode, direction_or_directed_or_layerIDMap, layerIDMap, maxLayers) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Bipartitions = function() {};
 /** @type {!Object} */
yfiles.algorithms.Bipartitions.RED;
 /** @type {!Object} */
yfiles.algorithms.Bipartitions.BLUE;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Bipartitions.$class;

/**
 * Calculates a bipartition of the given graph, if one exists.
 * <p>
 * If the graph is bipartite, then for all nodes of the given graph either {\@link yfiles.algorithms.Bipartitions#RED} or {\@link yfiles.algorithms.Bipartitions#BLUE}
 * objects will be set in the given {\@link yfiles.algorithms.INodeMap}, depending on the partition to which each node belongs.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {?} markMap the {\@link } that will be filled during the BFS execution and returns the partition (either {\@link #RED}
 * or {\@link #BLUE}) to which each node belongs
 * @return {boolean} <code>true</code> if the graph is bipartite, <code>false</code> otherwise
 */
yfiles.algorithms.Bipartitions.getBipartition = function(graph, markMap) {};

/**
 * Determines whether or not the given graph is bipartite.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the graph is bipartite, <code>false</code> otherwise
 */
yfiles.algorithms.Bipartitions.isBipartite = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Centrality = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Centrality.$class;

/**
 * Computes the closeness centrality for the nodes of a graph.
 * <p>
 * <i>Closeness centrality</i> is defined as the reciprocal of the sum of shortest path distances of a node to all other nodes in the graph.
 * Therefore, a node with high closeness centrality has short distances to all other nodes of a graph. If the sum of the
 * shortest path distances is <code>0</code>, the closeness of a node is set to {\@link number#POSITIVE_INFINITY}.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} closeness the {\@link } that will be filled during the execution and returns a double value (centrality) for each
 * node
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {?} edgeCosts the {\@link } that returns a positive double value (cost) or <code>null</code> if the edges are of equal cost
 * @return {void}
 */
yfiles.algorithms.Centrality.closenessCentrality = function(graph, closeness, directed, edgeCosts) {};

/**
 * Computes the degree centrality for the nodes of a given graph.
 * <p>
 * <i>Degree centrality</i> is the number of the incoming, outgoing or overall edges incident to a node (measures incoming, outgoing and overall
 * degree).
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} centrality the {\@link } that will be filled during the execution and returns a double value (centrality) for each
 * node
 * @param {boolean} considerInEdges <code>true</code> if the incoming edges should be considered, <code>false</code> otherwise
 * @param {boolean} considerOutEdges <code>true</code> if the outgoing edges should be considered, <code>false</code> otherwise
 * @return {void}
 */
yfiles.algorithms.Centrality.degreeCentrality = function(graph, centrality, considerInEdges, considerOutEdges) {};

/**
 * Computes betweenness centrality for each edge of a given graph.
 * <p>
 * <i>Betweenness centrality</i> is a measure for how often an edge lies on a shortest path between each pair of nodes in the graph. Removing a central
 * edge will cause many shortest paths to change.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} centrality the {\@link } that will be filled during the execution and returns a double value (centrality) for each
 * edge
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {?} edgeCosts the {\@link } that returns a positive double value (cost) or <code>null</code> if the edges are of equal cost;
 * for invalid input values the algorithm uses cost <code>1.0</code>
 * @return {void}
 */
yfiles.algorithms.Centrality.edgeBetweenness = function(graph, centrality, directed, edgeCosts) {};

/**
 * Computes the graph centrality for the nodes of a graph.
 * <p>
 * <i>Graph centrality</i> is defined as the reciprocal of the maximum of all shortest path distances from a node to all other nodes in the graph.
 * Nodes with high graph centrality have short distances to all other nodes in the graph.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} centrality the {\@link } that will be filled during the execution and returns a double value (centrality) for each
 * node
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {?} edgeCosts the {\@link } that returns a positive double value (cost) or <code>null</code> if the edges are of equal cost
 * @return {void}
 */
yfiles.algorithms.Centrality.graphCentrality = function(graph, centrality, directed, edgeCosts) {};

/**
 * Computes betweenness centrality for each node of a given graph.
 * <p>
 * <i>Betweenness centrality</i> is a measure for how often a node lies on a shortest path between each pair of nodes in the graph. Removing a central
 * edge will cause many shortest paths to change.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} centrality the {\@link } that will be filled during the execution and returns a double value (centrality) for each
 * node
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {?} edgeCosts the {\@link } that returns a positive double value (cost) or <code>null</code> if the edges are of equal cost;
 * for invalid input values the algorithm uses cost <code>1.0</code>
 * @return {void}
 */
yfiles.algorithms.Centrality.nodeBetweenness = function(graph, centrality, directed, edgeCosts) {};

/**
 * Computes betweenness centrality for each node and edge of a given graph.
 * <p>
 * <i>Betweenness centrality</i> is a measure for how often a node/edge lies on a shortest path between each pair of nodes in the graph. Removing a
 * central node/edge will cause many shortest paths to change.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} nodeCentrality the {\@link } that will be filled during the execution and returns a double value (centrality) for each
 * node
 * @param {?} edgeCentrality the {\@link } that will be filled during the execution and returns a double value (centrality) for each
 * edge
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {?} edgeCosts the {\@link } that returns a positive double value (cost) or <code>null</code> if the edges are of equal cost;
 * for invalid input values the algorithm uses cost <code>1.0</code>
 * @return {void}
 */
yfiles.algorithms.Centrality.nodeEdgeBetweenness = function(graph, nodeCentrality, edgeCentrality, directed, edgeCosts) {};

/**
 * Normalizes the <code>double</code> values of a given {\@link yfiles.algorithms.IEdgeMap} by dividing each of them by the maximum of all values
 * (maximum norm).
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} map the {\@link } that will be filled during the execution and returns a double value from <code>[0,1]</code> interval
 * @return {void}
 */
yfiles.algorithms.Centrality.normalizeEdgeMap = function(graph, map) {};

/**
 * Normalizes the <code>double</code> values of a given {\@link yfiles.algorithms.INodeMap} by dividing each of them by the maximum of all values
 * (maximum norm).
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} map the {\@link } that will be filled during the execution and returns a double value from <code>[0,1]</code> interval
 * @return {void}
 */
yfiles.algorithms.Centrality.normalizeNodeMap = function(graph, map) {};

/**
 * Computes the weight centrality for the nodes of a graph.
 * <p>
 * <i>Weight centrality</i> measures the weight associated with incoming, outgoing, or all edges of a node.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} centrality the {\@link } that will be filled during the execution and returns a double value (centrality) for each
 * node
 * @param {boolean} considerInEdges <code>true</code> if the incoming edges should be considered, <code>false</code> otherwise
 * @param {boolean} considerOutEdges <code>true</code> if the outgoing edges should be considered, <code>false</code> otherwise
 * @param {?} edgeWeights the {\@link } that returns a positive double value (weight) or <code>null</code> if the edges are considered to
 * have uniform weight of <code>1.0</code>
 * @return {void}
 */
yfiles.algorithms.Centrality.weightCentrality = function(graph, centrality, considerInEdges, considerOutEdges, edgeWeights) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Cycles = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Cycles.$class;

/**
 * Returns an {\@link yfiles.algorithms.EdgeList} that contains all the edges that are part of at least one directed or undirected
 * simple cycle.
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {boolean} directed <code>true</code> if the graph should be considered directed, <code>false</code> otherwise
 * @return {!yfiles.algorithms.EdgeList} an {\@link } that contains all the edges that are part of at least one directed or undirected simple
 * cycle
 */
yfiles.algorithms.Cycles.findAllCycleEdges = function(graph, directed) {};

/**
 * Returns an {\@link yfiles.algorithms.EdgeList} that contains the edges of a cycle found in the given graph.
 * <p>
 * The edges are returned in the order they appear in the detected cycle.
 * </p>
 * <p>
 * If the returned cycle is empty, no cycle has been found in the given graph.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {boolean} directed <code>true</code> if the graph should be considered directed, <code>false</code> otherwise
 * @return {!yfiles.algorithms.EdgeList} an {\@link } containing the edges of a cycle or an empty {\@link } if the graph is
 * acyclic
 */
yfiles.algorithms.Cycles.findCycle = function(graph, directed) {};

/**
 * Marks the edges of a given graph whose removal or reversal would make the graph acyclic while trying to minimize the
 * cost associated with the marked edges.
 * <p>
 * This minimization is performed heuristically, since it is a well known hard problem to come up with an optimal
 * solution.
 * </p>
 * <p>
 * The costs are assigned using a {\@link yfiles.algorithms.IDataProvider} that holds a non-negative double value for each edge.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {?} cycleEdges the {\@link } that will be filled during the execution and returns whether an edge is a detected cycle
 * edge
 * @param {?=} costDP
 * @return {void}
 */
yfiles.algorithms.Cycles.findCycleEdges = function(graph, cycleEdges, costDP) {};

/**
 * Marks the edges of a given graph whose removal or reversal would make the graph acyclic based on a depth first search.
 * <p>
 * The number of marked cycle edges is expected to be slightly greater than when using
 * {\@link yfiles.algorithms.Cycles#findCycleEdges}. The advantage of this method is that the result set is more stable when edges
 * are added or removed over time.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {?} cycleEdges the {\@link } that will be filled during the execution and returns a boolean value indicating whether
 * or not an edge is a detected cycle edge
 * @return {void}
 */
yfiles.algorithms.Cycles.findCycleEdgesDFS = function(graph, cycleEdges) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Dart = function() {};
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Dart.prototype.associatedEdge;
 /** @type {boolean} */
yfiles.algorithms.Dart.prototype.reversed;
 /** @type {!yfiles.algorithms.Dart} */
yfiles.algorithms.Dart.prototype.oppositeDart;
 /** @type {?<!yfiles.algorithms.Dart>} */
yfiles.algorithms.Dart.prototype.face;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Dart.$class;
/**
 * @record
 * @struct
 */
yfiles.algorithms.Dfs = function() {};
 /** @type {?} */
yfiles.algorithms.Dfs.prototype.stateMap;
 /** @type {!Object} */
yfiles.algorithms.Dfs.WHITE;
 /** @type {!Object} */
yfiles.algorithms.Dfs.GRAY;
 /** @type {!Object} */
yfiles.algorithms.Dfs.BLACK;
 /** @type {boolean} */
yfiles.algorithms.Dfs.prototype.directedMode;
 /** @type {boolean} */
yfiles.algorithms.Dfs.prototype.lookFurtherMode;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Dfs.$class;

/**
 * Cancels the depth first search.
 * <p>
 * It may be overridden to support custom implementations.
 * </p>
 * @return {void}
 */
yfiles.algorithms.Dfs.prototype.cancel = function() {};

/**
 * Callback method that will be invoked whenever DFS continues its search at a new root node.
 * <p>
 * By default, this method does nothing. It may be overridden to support custom implementations.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} v the new root node
 * @return {void}
 */
yfiles.algorithms.Dfs.prototype.lookFurther = function(v) {};

/**
 * Callback method that will be invoked after the DFS has returned from the given node.
 * <p>
 * By default, this method does nothing. It may be overridden to support custom implementations.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @param {!yfiles.algorithms.Node} node the node that has been reached via the given edge
 * @return {void}
 */
yfiles.algorithms.Dfs.prototype.postTraverse = function(edge, node) {};

/**
 * Callback method that will be invoked whenever a node visit has been completed.
 * <p>
 * By default, this method does nothing. It may be overridden to support custom implementations.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} node the given node
 * @param {number} dfsNumber the DFS number of the given node
 * @param {number} compNumber the completion number of the given node
 * @return {void}
 */
yfiles.algorithms.Dfs.prototype.postVisit = function(node, dfsNumber, compNumber) {};

/**
 * Callback method that will be invoked if the given edge will be considered the first (and only) time during the DFS.
 * <p>
 * By default, this method does nothing. It may be overridden to support custom implementations.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @param {!yfiles.algorithms.Node} node the node to be visited next only if <code>treeEdge == true</code>
 * @param {boolean} treeEdge <code>true</code> if the <code>node</code> will be visited, <code>false</code> otherwise
 * @return {void}
 */
yfiles.algorithms.Dfs.prototype.preTraverse = function(edge, node, treeEdge) {};

/**
 * Callback method that will be invoked whenever a formerly unvisited node gets visited for the first time.
 * <p>
 * By default, this method does nothing. It may be overridden to support custom implementations.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} node the given node
 * @param {number} dfsNumber the DFS number of the given node
 * @return {void}
 */
yfiles.algorithms.Dfs.prototype.preVisit = function(node, dfsNumber) {};

/**
 * Starts a depth first search from a given {\@link yfiles.algorithms.Node} of the input graph.
 * Starts a depth first search on the given graph.
 * <p>
 * The first node of the graph will be visited first.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node=} start the given start node
 * @return {void}
 */
yfiles.algorithms.Dfs.prototype.start = function(graph, start) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.DpKeyBase = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.DpKeyBase.prototype.declaringType;
 /** @type {string} */
yfiles.algorithms.DpKeyBase.prototype.name;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.DpKeyBase.$class;

/**
 * Returns whether this key is equal to the specified <code>other</code>.
 * @protected
 * @param {!yfiles.algorithms.DpKeyBase} other The other key to compare with this instance.
 * @return {boolean} <code>true</code> if the specified key is equal to this instance; otherwise, <code>false</code>.
 */
yfiles.algorithms.DpKeyBase.prototype.equalsCore = function(other) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.EdgeDpKey = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.EdgeDpKey.$class;
/**
 * @record
 * @struct
 */
yfiles.algorithms.GraphDpKey = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.GraphDpKey.$class;
/**
 * @record
 * @struct
 */
yfiles.algorithms.GraphObjectDpKey = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.GraphObjectDpKey.$class;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IEdgeLabelLayoutDpKey = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.IEdgeLabelLayoutDpKey.$class;
/**
 * @record
 * @struct
 */
yfiles.algorithms.INodeLabelLayoutDpKey = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.INodeLabelLayoutDpKey.$class;
/**
 * @record
 * @struct
 */
yfiles.algorithms.ILabelLayoutDpKey = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.ILabelLayoutDpKey.$class;
/**
 * @record
 * @struct
 */
yfiles.algorithms.NodeDpKey = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.NodeDpKey.$class;
/**
 * @record
 * @struct
 */
yfiles.algorithms.Edge = function() {};
 /** @type {!yfiles.algorithms.Graph} */
yfiles.algorithms.Edge.prototype.graph;
 /** @type {number} */
yfiles.algorithms.Edge.prototype.index;
 /** @type {!yfiles.algorithms.Node} */
yfiles.algorithms.Edge.prototype.source;
 /** @type {!yfiles.algorithms.Node} */
yfiles.algorithms.Edge.prototype.target;
 /** @type {boolean} */
yfiles.algorithms.Edge.prototype.selfLoop;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Edge.prototype.nextOutEdge;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Edge.prototype.nextInEdge;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Edge.prototype.prevOutEdge;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Edge.prototype.prevInEdge;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Edge.$class;

/**
 * Creates a copy of this edge that will be inserted into the given graph connecting the given source and target nodes.
 * @param {!yfiles.algorithms.Graph} g The graph the created edge will belong to.
 * @param {!yfiles.algorithms.Node} v The source node of the created edge.
 * @param {!yfiles.algorithms.Node} w The target node of the created edge.
 * @return {!yfiles.algorithms.Edge} The newly created Edge object.
 */
yfiles.algorithms.Edge.prototype.createCopy = function(g, v, w) {};

/**
 * Callback method that is invoked from a graph just before this edge will be reinserted into that graph.
 * @return {void}
 */
yfiles.algorithms.Edge.prototype.onReinsert = function() {};

/**
 * Returns the node at the opposite edge end with respect to the given node.
 * <p>
 * Note that self-loops have the same node at both edge ends.
 * </p>
 * @param {!yfiles.algorithms.Node} v
 * @return {!yfiles.algorithms.Node}
 */
yfiles.algorithms.Edge.prototype.opposite = function(v) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.EdgeList = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.EdgeList.$class;

/**
 * Returns an edge cursor for this edge list.
 * @return {?} An edge cursor granting access to the edges within this list.
 */
yfiles.algorithms.EdgeList.prototype.edges = function() {};

/**
 * Returns the first edge in this list, or <code>null</code> when the list is empty.
 * @return {!yfiles.algorithms.Edge} The first edge in the list.
 */
yfiles.algorithms.EdgeList.prototype.firstEdge = function() {};

/**
 * Returns an enumerator for this collection.
 * @return {?<!yfiles.algorithms.Edge>}
 */
yfiles.algorithms.EdgeList.prototype.getEnumerator = function() {};

/**
 * Returns the last edge in this list, or <code>null</code> when the list is empty.
 * @return {!yfiles.algorithms.Edge} The last edge in the list.
 */
yfiles.algorithms.EdgeList.prototype.lastEdge = function() {};

/**
 * Removes the first edge from this list and returns it.
 * @return {!yfiles.algorithms.Edge} The first edge from the list.
 */
yfiles.algorithms.EdgeList.prototype.popEdge = function() {};

/**
 * Returns an edge array containing all elements of this list in the canonical order.
 * @return {!Array<!yfiles.algorithms.Edge>}
 */
yfiles.algorithms.EdgeList.prototype.toEdgeArray = function() {};

/** @const */
yfiles.algorithms.BfsDirection = {};
/** @const {number} */
yfiles.algorithms.BfsDirection.PREDECESSOR;
/** @const {number} */
yfiles.algorithms.BfsDirection.SUCCESSOR;
/** @const {number} */
yfiles.algorithms.BfsDirection.BOTH;

/** @const */
yfiles.algorithms.GraphElementInsertion = {};
/** @const {number} */
yfiles.algorithms.GraphElementInsertion.BEFORE;
/** @const {number} */
yfiles.algorithms.GraphElementInsertion.AFTER;

/** @const */
yfiles.algorithms.GraphEventType = {};
/** @const {number} */
yfiles.algorithms.GraphEventType.NODE_CREATION;
/** @const {number} */
yfiles.algorithms.GraphEventType.EDGE_CREATION;
/** @const {number} */
yfiles.algorithms.GraphEventType.PRE_NODE_REMOVAL;
/** @const {number} */
yfiles.algorithms.GraphEventType.POST_NODE_REMOVAL;
/** @const {number} */
yfiles.algorithms.GraphEventType.PRE_EDGE_REMOVAL;
/** @const {number} */
yfiles.algorithms.GraphEventType.POST_EDGE_REMOVAL;
/** @const {number} */
yfiles.algorithms.GraphEventType.NODE_REINSERTION;
/** @const {number} */
yfiles.algorithms.GraphEventType.EDGE_REINSERTION;
/** @const {number} */
yfiles.algorithms.GraphEventType.PRE_EDGE_CHANGE;
/** @const {number} */
yfiles.algorithms.GraphEventType.POST_EDGE_CHANGE;
/** @const {number} */
yfiles.algorithms.GraphEventType.SUBGRAPH_INSERTION;
/** @const {number} */
yfiles.algorithms.GraphEventType.SUBGRAPH_REMOVAL;
/** @const {number} */
yfiles.algorithms.GraphEventType.PRE_EVENT;
/** @const {number} */
yfiles.algorithms.GraphEventType.POST_EVENT;

/** @const */
yfiles.algorithms.DistanceMetric = {};
/** @const {number} */
yfiles.algorithms.DistanceMetric.EUCLIDEAN;
/** @const {number} */
yfiles.algorithms.DistanceMetric.EUCLIDEAN_SQUARED;
/** @const {number} */
yfiles.algorithms.DistanceMetric.MANHATTAN;
/** @const {number} */
yfiles.algorithms.DistanceMetric.CHEBYCHEV;

/** @const */
yfiles.algorithms.Linkage = {};
/** @const {number} */
yfiles.algorithms.Linkage.SINGLE;
/** @const {number} */
yfiles.algorithms.Linkage.COMPLETE;
/** @const {number} */
yfiles.algorithms.Linkage.AVERAGE;
/**
 * @record
 * @struct
 */
yfiles.algorithms.AffineLine = function() {};
 /** @type {number} */
yfiles.algorithms.AffineLine.prototype.a;
 /** @type {number} */
yfiles.algorithms.AffineLine.prototype.b;
 /** @type {number} */
yfiles.algorithms.AffineLine.prototype.c;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.AffineLine.$class;

/**
 * Returns the crossing of two lines.
 * <p>
 * If the lines are parallel, <code>null</code> is returned.
 * </p>
 * @param {!yfiles.algorithms.AffineLine} l1
 * @param {!yfiles.algorithms.AffineLine} l2
 * @return {!yfiles.algorithms.YPoint}
 */
yfiles.algorithms.AffineLine.getCrossing = function(l1, l2) {};

/**
 * Projects an point on the line in direction of the X-axis.
 * @param {!yfiles.algorithms.YPoint} p
 * @return {!yfiles.algorithms.YPoint}
 */
yfiles.algorithms.AffineLine.prototype.getXProjection = function(p) {};

/**
 * Projects an point on the line in direction of the Y-axis.
 * @param {!yfiles.algorithms.YPoint} p
 * @return {!yfiles.algorithms.YPoint}
 */
yfiles.algorithms.AffineLine.prototype.getYProjection = function(p) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.BorderLineSegment = function() {};
 /** @type {number} */
yfiles.algorithms.BorderLineSegment.prototype.end;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.BorderLineSegment.$class;

/**
 * Returns the segment's value at the given position.
 * <p>
 * Note: In case the position lies outside the segments range, the calculated value might be invalid. As the segment is not
 * aware of any offsets the position also must not include any offsets.
 * </p>
 * @param {number} position the position the value is retrieved for.
 * @return {number} the segment's value at the given position.
 */
yfiles.algorithms.BorderLineSegment.prototype.getValueAt = function(position) {};

/**
 * Returns the next segment or <code>null</code> if there is no such segment.
 * @return {!yfiles.algorithms.BorderLineSegment}
 */
yfiles.algorithms.BorderLineSegment.prototype.next = function() {};

/**
 * Returns the previous segment or <code>null</code> if there is no such segment.
 * @return {!yfiles.algorithms.BorderLineSegment}
 */
yfiles.algorithms.BorderLineSegment.prototype.prev = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.BorderLine = function() {};
 /** @type {number} */
yfiles.algorithms.BorderLine.prototype.min;
 /** @type {number} */
yfiles.algorithms.BorderLine.prototype.max;
 /** @type {number} */
yfiles.algorithms.BorderLine.prototype.minValue;
 /** @type {number} */
yfiles.algorithms.BorderLine.prototype.maxValue;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.BorderLine.$class;

/**
 * Adds the given offset to the segments' positions.
 * <p>
 * This method has complexity O(1).
 * </p>
 * @param {number} delta the delta to add to the positions
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.addOffset = function(delta) {};

/**
 * Adds the given offset to the current values of the whole borderline.
 * <p>
 * This method has complexity O(1).
 * </p>
 * @param {number} delta the delta to add to the values
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.addValueOffset = function(delta) {};

/**
 * Convenience method that copies the actual data from the given argument to this instance.
 * @param {!yfiles.algorithms.BorderLine} other the argument to retrieve the values from
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.adoptValues = function(other) {};

/**
 * Creates a copy of this borderline.
 * <p>
 * Optionally negates the values or offsets.
 * </p>
 * @param {boolean} negateValues whether the values are negated
 * @param {boolean} negateOffsets whether the offsets are negated
 * @return {!yfiles.algorithms.BorderLine} the copy of the borderline
 */
yfiles.algorithms.BorderLine.prototype.createCopy = function(negateValues, negateOffsets) {};

/**
 * Merges this borderline with the given borderline using the "maximum" policy.
 * <p>
 * That means the resulting borderline will have greater value of both borderline on each position. If you imagine each
 * borderline as a the upper border of a plane, the resulting borderline will be the upper border of the merged planes.
 * </p>
 * @param {!yfiles.algorithms.BorderLine} other the other borderline
 * @return {!yfiles.algorithms.BorderLine} a new borderline that is the result of the merge
 */
yfiles.algorithms.BorderLine.prototype.createMax = function(other) {};

/**
 * Merges this borderline with the given borderline using the "minimum" policy.
 * <p>
 * That means the resulting borderline will have smaller value of both borderline on each position. If you imagine each
 * borderline as a the lower border of a plane, the resulting borderline will be the lower border of the merged planes.
 * </p>
 * @param {!yfiles.algorithms.BorderLine} other the other borderline
 * @return {!yfiles.algorithms.BorderLine} a new borderline that is the result of the merge
 */
yfiles.algorithms.BorderLine.prototype.createMin = function(other) {};

/**
 * Returns the first segment or <code>null</code> if there is no such segment.
 * @return {!yfiles.algorithms.BorderLineSegment}
 */
yfiles.algorithms.BorderLine.prototype.firstSegment = function() {};

/**
 * Calculates the minimal distance between this borderline and the other one.
 * <p>
 * The other one is treated as if the values were all greater.
 * </p>
 * @param {!yfiles.algorithms.BorderLine} greater
 * @return {number}
 */
yfiles.algorithms.BorderLine.prototype.getDistanceTo = function(greater) {};

/**
 * Returns the maximum position of the given segment.
 * @param {!yfiles.algorithms.BorderLineSegment} s the segment
 * @return {number}
 */
yfiles.algorithms.BorderLine.prototype.getMax = function(s) {};

/**
 * Calculates the maximum value in the interval from->to.
 * @param {number} from
 * @param {number} to
 * @return {number}
 */
yfiles.algorithms.BorderLine.prototype.getMaxValue = function(from, to) {};

/**
 * Returns the minimum position of the given segment.
 * @param {!yfiles.algorithms.BorderLineSegment} s the segment
 * @return {number}
 */
yfiles.algorithms.BorderLine.prototype.getMin = function(s) {};

/**
 * Calculates the minimum value in the interval from->to.
 * @param {number} from
 * @param {number} to
 * @return {number}
 */
yfiles.algorithms.BorderLine.prototype.getMinValue = function(from, to) {};

/**
 * Returns the segment at the given position.
 * @param {number} pos the position
 * @return {!yfiles.algorithms.BorderLineSegment}
 */
yfiles.algorithms.BorderLine.prototype.getSegmentAt = function(pos) {};

/**
 * Returns the slope of the given segment.
 * @param {!yfiles.algorithms.BorderLineSegment} s the segment
 * @return {number}
 */
yfiles.algorithms.BorderLine.prototype.getSlope = function(s) {};

/**
 * Returns the value of the minimum of the given segment.
 * <p>
 * If the segment's slope is 0, it's the value of the whole segment. In case the slope differs from 0, it's the value of
 * the start of the slope.
 * </p>
 * @param {!yfiles.algorithms.BorderLineSegment} s the segment
 * @return {number}
 */
yfiles.algorithms.BorderLine.prototype.getValue = function(s) {};

/**
 * Returns the value that is set on this borderline at the specified position.
 * <p>
 * The position must lie within the range of the segment.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if <code>pos</code> is outside the segment's range.
 * Returns the value that is set on this borderline at the specified position.
 * <p>
 * The position must lie within the range of the segment that is stored in <code>cell</code>.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if <code>pos</code> is outside the segment's range that is stored in <code>cell</code>.
 * Returns the value that is set on this borderline at the specified position.
 * @throws {Stubs.Exceptions.IndexOutOfRangeError} if the position is outside of the borderline.
 * @param {!yfiles.algorithms.BorderLineSegment|!yfiles.algorithms.ListCell|number} segment_or_cell_or_pos The segment whose value shall be returned. / The list cell containing the segment whose value shall be returned. / the position
 * @param {number=} pos the position where the value will be retrieved. / the position
 * @return {number} the value
 */
yfiles.algorithms.BorderLine.prototype.getValueAt = function(segment_or_cell_or_pos, pos) {};

/**
 * Grows this BorderLine horizontally, so that the {\@link yfiles.algorithms.BorderLine#getValueAt values} of the BorderLine stay the same however their {\@link yfiles.algorithms.BorderLine#getMin start} and {\@link yfiles.algorithms.BorderLine#getMax end}
 * points are moved in the direction of <code>toMin</code> and <code>toMax</code>.
 * <p>
 * This is useful for scenarios where a BorderLine is needed that consists of an enlarged border.
 * </p>
 * <p>
 * Note that this method normalizes the segments, i.e., it transforms each segment with slope != 0 to a segment with slope
 * == 0.
 * </p>
 * @param {number} toMin the delta by which the border should be extended towards -Infinity
 * @param {number} toMax the delta by which the border should be extended towards +Infinity
 * @param {boolean} positive whether the BorderLine should be interpreted to point in positive direction. This influences the direction into which a
 * segment's border is extended.
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.grow = function(toMin, toMax, positive) {};

/**
 * Returns the last segment or <code>null</code> if there is no such segment.
 * @return {!yfiles.algorithms.BorderLineSegment}
 */
yfiles.algorithms.BorderLine.prototype.lastSegment = function() {};

/**
 * Merges this borderline with the given borderline using the "maximum" policy.
 * @param {!yfiles.algorithms.BorderLine} other the other borderline
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.mergeWithMax = function(other) {};

/**
 * Merges this borderline with the given borderline using the "minimum" policy.
 * @param {!yfiles.algorithms.BorderLine} other the other borderline
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.mergeWithMin = function(other) {};

/**
 * Returns the next segment or <code>null</code> if there is no such segment.
 * @param {!yfiles.algorithms.BorderLineSegment} s
 * @return {!yfiles.algorithms.BorderLineSegment}
 */
yfiles.algorithms.BorderLine.prototype.next = function(s) {};

/**
 * Returns the previous segment or <code>null</code> if there is no such segment.
 * @param {!yfiles.algorithms.BorderLineSegment} s
 * @return {!yfiles.algorithms.BorderLineSegment}
 */
yfiles.algorithms.BorderLine.prototype.prev = function(s) {};

/**
 * Assures that all values in the given interval are greater or equal than the given value.
 * @param {number} min the lower end of the interval
 * @param {number} max the upper end of the interval
 * @param {number} value the smallest possible value for the interval
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.setMaxValue = function(min, max, value) {};

/**
 * Assures that all values in the given interval are less or equal than the given value.
 * @param {number} min the lower end of the interval
 * @param {number} max the upper end of the interval
 * @param {number} value the greatest possible value for the interval
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.setMinValue = function(min, max, value) {};

/**
 * Sets a specific interval to a slope starting at a given value.
 * @throws {Stubs.Exceptions.ArgumentError} if <code>min</code> is greater than <code>max</code>.
 * @param {number} min the left side of the interval.
 * @param {number} max the right side of the interval.
 * @param {number} value the value at <code>min</code> where the slope starts.
 * @param {number} slope the slope of the segment in the given interval.
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.setSloped = function(min, max, value, slope) {};

/**
 * Sets a specific interval described by <code>min</code> and <code>max</code> to a given value.
 * @param {number} min the left side of the interval.
 * @param {number} max the right side of the interval.
 * @param {number} value the value for the whole interval.
 * @return {void}
 */
yfiles.algorithms.BorderLine.prototype.setValue = function(min, max, value) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Geom = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Geom.$class;

/**
 * Calculates the convex hull for a set of points.
 * @param {!yfiles.algorithms.YList} points a list of {\@link } objects
 * @return {!yfiles.algorithms.YList} a list of {\@link } objects that constitute the convex hull of the given points. The list contains points
 * in counter clockwise order around the hull. The first point is the one with the smallest <code>x</code> coordinate. If two such
 * points exist then of these points the one with the smallest <code>y</code> coordinate is chosen as the first one.
 */
yfiles.algorithms.Geom.calcConvexHull = function(points) {};

/**
 * Calculates the intersection point of two <b>affine</b> lines.
 * <p>
 * Each line is given by two points.
 * </p>
 * Calculates the intersection point of two affine lines.
 * <p>
 * Each line is given by a point and a direction vector.
 * </p>
 * Calculates the intersection point of two <b>affine</b> lines.
 * <p>
 * Each line is given by the coordinates of two points.
 * </p>
 * Intersects the pair of specified source <code>Rectangle2D</code> objects and puts the result into the specified destination <code>Rectangle2D</code>
 * object.
 * <p>
 * If one or both of the source rectangles have negative width or height, the resulting rectangle will be located at (0,0)
 * with a width and height of -1. One of the source rectangles can also be the destination to avoid creating a third
 * Rectangle2D object, but in this case the original points of this source rectangle will be overwritten by this method.
 * </p>
 * @param {!yfiles.algorithms.YPoint|number|!yfiles.algorithms.Rectangle2D} p1_or_x1_or_r1 one point on the first line. / origin point of the first line. / x-coordinate of one point on the first line. / the first of a pair of <code>Rectangle2D</code> objects to be intersected with each other
 * @param {!yfiles.algorithms.YPoint|!yfiles.algorithms.YVector|number|!yfiles.algorithms.Rectangle2D} p2_or_d1_or_y1_or_r2 another point on the first line. / direction vector of the first line. / y-coordinate of one point on the first line. / the second of a pair of <code>Rectangle2D</code> objects to be intersected with each other
 * @param {!yfiles.algorithms.YPoint|number|!yfiles.algorithms.Rectangle2D} p3_or_p2_or_x2_or_dest one point on the second line. / origin point of the second line. / x-coordinate of another point on the first line. / the <code>Rectangle2D</code> that holds the results of the intersection of <code>r1</code> and <code>r2</code>
 * @param {!yfiles.algorithms.YPoint|!yfiles.algorithms.YVector|number=} p4_or_d2_or_y2 another point on the second line. / direction vector of the second line. / y-coordinate of another point on the first line.
 * @param {number=} x3 x-coordinate of one point on the second line.
 * @param {number=} y3 y-coordinate of one point on the second line.
 * @param {number=} x4 x-coordinate of another point on the second line.
 * @param {number=} y4 y-coordinate of another point on the second line.
 * @return {!yfiles.algorithms.YPoint|!yfiles.algorithms.Rectangle2D} the intersection point of the specified lines or <code>null</code> if there is no intersection.
 */
yfiles.algorithms.Geom.calcIntersection = function(p1_or_x1_or_r1, p2_or_d1_or_y1_or_r2, p3_or_p2_or_x2_or_dest, p4_or_d2_or_y2, x3, y3, x4, y4) {};

/**
 * Unions the pair of source <code>Rectangle2D</code> objects and puts the result into the specified destination <code>Rectangle2D</code> object.
 * <p>
 * If one of the source rectangles has negative width or height, it is excluded from the union. If both source rectangles
 * have negative width or height, the destination rectangle will become a copy of <code>r1</code>. One of the source rectangles can also
 * be the destination to avoid creating a third Rectangle2D object, but in this case the original points of this source
 * rectangle will be overwritten by this method. If the destination is <code>null</code>, a new <code>Rectangle2D</code> is created.
 * </p>
 * @param {!yfiles.algorithms.Rectangle2D} r1 the first of a pair of <code>Rectangle2D</code> objects to be combined with each other
 * @param {!yfiles.algorithms.Rectangle2D} r2 the second of a pair of <code>Rectangle2D</code> objects to be combined with each other
 * @param {!yfiles.algorithms.Rectangle2D} dest the <code>Rectangle2D</code> that holds the results of the union of <code>r1</code> and <code>r2</code>
 * @return {!yfiles.algorithms.Rectangle2D}
 */
yfiles.algorithms.Geom.calcUnion = function(r1, r2, dest) {};

/**
 * Returns <code>true</code> iff the given points are collinear, i.e.
 * <p>
 * all three points lie on a common line.
 * </p>
 * <p>
 * Same as {\@link yfiles.algorithms.Geom#orientation orientation(p,q,r) == 0}
 * </p>
 * @param {!yfiles.algorithms.YPoint} p
 * @param {!yfiles.algorithms.YPoint} q
 * @param {!yfiles.algorithms.YPoint} r
 * @return {boolean}
 */
yfiles.algorithms.Geom.collinear = function(p, q, r) {};

/**
 * Determines the distance of the point <code>p</code> to the line segment <code>[l1, l2]</code>.
 * @param {number} pointX the x coordinate of p
 * @param {number} pointY the y coordinate of p
 * @param {number} lineX1 the x coordinate of l1
 * @param {number} lineY1 the y coordinate of l1
 * @param {number} lineX2 the x coordinate of l2
 * @param {number} lineY2 the y coordinate of l2
 * @return {number}
 */
yfiles.algorithms.Geom.distanceToLineSegment = function(pointX, pointY, lineX1, lineY1, lineX2, lineY2) {};

/**
 * Same as {\@link yfiles.algorithms.Geom#orientation orientation(p,q,r) > 0}
 * @param {!yfiles.algorithms.YPoint} p
 * @param {!yfiles.algorithms.YPoint} q
 * @param {!yfiles.algorithms.YPoint} r
 * @return {boolean}
 */
yfiles.algorithms.Geom.leftTurn = function(p, q, r) {};

/**
 * Returns whether the two lines defined by the given coordinates intersect or not.
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @param {number} x4
 * @param {number} y4
 * @return {boolean}
 */
yfiles.algorithms.Geom.linesIntersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {};

/**
 * Same as {\@link yfiles.algorithms.Geom#orientation} with double values as arguments.
 * Returns the orientation of point <code>r</code> relative to the directed line from point <code>p</code> to point <code>q</code>.
 * <p>
 * The given tuple of points is said to have positive orientation if <code>p</code> and <code>q</code> are distinct and <code>r</code> lies to the left of the
 * oriented line passing through <code>p</code> and <code>q</code> and oriented from <code>p</code> to <code>q</code>.
 * </p>
 * <p>
 * The tuple is said to have negative orientation if <code>p</code> and <code>q</code> are distinct and <code>r</code> lies to the right of the line, and the
 * tuple is said to have orientation zero if the three points are collinear.
 * </p>
 * @param {number|!yfiles.algorithms.YPoint} px_or_p
 * @param {number|!yfiles.algorithms.YPoint} py_or_q
 * @param {number|!yfiles.algorithms.YPoint} qx_or_r
 * @param {number=} qy
 * @param {number=} rx
 * @param {number=} ry
 * @return {number} <b>+1</b> in the case of positive orientation, <b>-1</b> in the case of negative orientation and <b>0</b> in the case of zero orientation.
 */
yfiles.algorithms.Geom.orientation = function(px_or_p, py_or_q, qx_or_r, qy, rx, ry) {};

/**
 * Determines the projection of the point <code>p</code> onto the line segment <code>[l1, l2]</code>.
 * <p>
 * The resulting point is
 * </p>
 * <ul>
 * <li>the orthogonal projection of <code>p</code> onto the line through <code>l1</code> and <code>l2</code>, iff the projection lies on the line segment <code>[l1, l2]</code></li>
 * <li>the end point of the line segment <code>[l1, l2]</code> that is closest to <code>p</code>, otherwise</li>
 * </ul>
 * @param {number} pointX the x coordinate of p
 * @param {number} pointY the y coordinate of p
 * @param {number} lineX1 the x coordinate of l1
 * @param {number} lineY1 the y coordinate of l1
 * @param {number} lineX2 the x coordinate of l2
 * @param {number} lineY2 the y coordinate of l2
 * @return {!yfiles.algorithms.YPoint}
 */
yfiles.algorithms.Geom.projection = function(pointX, pointY, lineX1, lineY1, lineX2, lineY2) {};

/**
 * Same as {\@link yfiles.algorithms.Geom#orientation orientation(p,q,r) &lt; 0}
 * @param {!yfiles.algorithms.YPoint} p
 * @param {!yfiles.algorithms.YPoint} q
 * @param {!yfiles.algorithms.YPoint} r
 * @return {boolean}
 */
yfiles.algorithms.Geom.rightTurn = function(p, q, r) {};

/**
 * Returns +1 if point <code>d</code> lies left of the directed circle through points <code>a</code>, <code>b</code>, and <code>c</code>, 0 if <code>a,b,c</code> and <code>d</code> are cocircular, and
 * -1 otherwise.
 * @param {!yfiles.algorithms.YPoint} a
 * @param {!yfiles.algorithms.YPoint} b
 * @param {!yfiles.algorithms.YPoint} c
 * @param {!yfiles.algorithms.YPoint} d
 * @return {number}
 */
yfiles.algorithms.Geom.sideOfCircle = function(a, b, c, d) {};

/**
 * Converts the given degree value from radian to angular
 * @param {number} angrad
 * @return {number}
 */
yfiles.algorithms.Geom.toDegrees = function(angrad) {};

/**
 * Converts the given degree value from angular to radian.
 * @param {number} angdeg
 * @return {number}
 */
yfiles.algorithms.Geom.toRadians = function(angdeg) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.ILineSegmentCursor = function() {};
 /** @type {!yfiles.algorithms.LineSegment} */
yfiles.algorithms.ILineSegmentCursor.prototype.lineSegment;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.ILineSegmentCursor;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IPlaneObject = function() {};
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.algorithms.IPlaneObject.prototype.boundingBox;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.IPlaneObject;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IPointCursor = function() {};
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.algorithms.IPointCursor.prototype.point;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.IPointCursor;
/**
 * @record
 * @struct
 */
yfiles.algorithms.Insets = function() {};
 /** @type {number} */
yfiles.algorithms.Insets.prototype.top;
 /** @type {number} */
yfiles.algorithms.Insets.prototype.left;
 /** @type {number} */
yfiles.algorithms.Insets.prototype.bottom;
 /** @type {number} */
yfiles.algorithms.Insets.prototype.right;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Insets.$class;

/**
 *
 * @return {!Object}
 */
yfiles.algorithms.Insets.prototype.clone = function() {};

/**
 * Creates a {\@link yfiles.geometry.Insets} from a given {\@link yfiles.algorithms.Insets}.
 * @return {!yfiles.geometry.Insets} The {\@link }.
 */
yfiles.algorithms.Insets.prototype.toInsets = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.IIntersectionHandler = function() {};

/**
 * This method is called at every intersection.
 * @abstract
 * @param {!Object} a
 * @param {!Object} b
 * @return {void}
 */
yfiles.algorithms.IIntersectionHandler.prototype.checkIntersection = function(a, b) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.IIntersectionHandler;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IntersectionAlgorithm = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.IntersectionAlgorithm.$class;

/**
 * Calculates the intersections of rectangles in the plane.
 * <p>
 * Every found intersection is reported to an
 * <code>IntersectionHandler</code>. Rectangles with negative size are completely ignored by this implementation (i.e. never generate
 * intersections)
 * </p>
 * @param {!yfiles.algorithms.YList} objects a list of <code>PlaneObject</code> objects.
 * @param {?} iHandler intersections are reported to this class.
 * @return {void}
 */
yfiles.algorithms.IntersectionAlgorithm.intersect = function(objects, iHandler) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.LineSegment = function() {};
 /** @type {boolean} */
yfiles.algorithms.LineSegment.prototype.isVertical;
 /** @type {boolean} */
yfiles.algorithms.LineSegment.prototype.isHorizontal;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.algorithms.LineSegment.prototype.firstEndPoint;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.algorithms.LineSegment.prototype.secondEndPoint;
 /** @type {number} */
yfiles.algorithms.LineSegment.prototype.xOffset;
 /** @type {number} */
yfiles.algorithms.LineSegment.prototype.slope;
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.algorithms.LineSegment.prototype.boundingBox;
 /** @type {number} */
yfiles.algorithms.LineSegment.prototype.deltaX;
 /** @type {number} */
yfiles.algorithms.LineSegment.prototype.deltaY;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.LineSegment.$class;

/**
 * Checks whether a line segment intersects a paraxial box.
 * <p>
 * Implemented using the Cohen-Sutherland algorithm.
 * </p>
 * Checks whether a line segment intersects a box.
 * <p>
 * Implemented using the Cohen-Sutherland algorithm.
 * </p>
 * Checks whether a line segment intersects a box.
 * @param {number|!yfiles.algorithms.YRectangle} boxX1_or_box x-coordinate of the upper left corner of the box / A rectangle / A rectangle.
 * @param {number|!yfiles.algorithms.YPoint} boxY1_or_x1_or_s y-coordinate of the upper left corner of the box / x-coordinate of the first end point of the line segment / first end point of the line segment.
 * @param {number|!yfiles.algorithms.YPoint} boxX2_or_y1_or_t x-coordinate of the lower right corner of the box / y-coordinate of the first end point of the line segment / second end point of the line segment.
 * @param {number=} boxY2_or_x2 y-coordinate of the lower right corner of the box / x-coordinate of the second end point of the line segment
 * @param {number=} sX1_or_y2 x-coordinate of the first end point of the line segment / y-coordinate of the second end point of the line segment
 * @param {number=} sY1 y-coordinate of the first end point of the line segment
 * @param {number=} sX2 x-coordinate of the second end point of the line segment
 * @param {number=} sY2 y-coordinate of the second end point of the line segment
 * @return {boolean} <code>true</code> if the line segment intersects the box, <code>false</code> otherwise. / <code>true</code> if the line segments intersects the box, <code>false</code> otherwise.
 */
yfiles.algorithms.LineSegment.boxIntersectsSegment = function(boxX1_or_box, boxY1_or_x1_or_s, boxX2_or_y1_or_t, boxY2_or_x2, sX1_or_y2, sY1, sX2, sY2) {};

/**
 * Checks whether a given point lies on this line segment.
 * @param {!yfiles.algorithms.YPoint} point an arbitrary point.
 * @return {boolean} <code>true</code> if the line segments intersects the box, <code>false</code> otherwise.
 */
yfiles.algorithms.LineSegment.prototype.contains = function(point) {};

/**
 * Returns intersection point between the two line segments, if there is one or <code>null</code> if the two line segments do not
 * intersect.
 * @param {!yfiles.algorithms.LineSegment} s1 first line segment
 * @param {!yfiles.algorithms.LineSegment} s2 second line segment
 * @return {!yfiles.algorithms.YPoint}
 */
yfiles.algorithms.LineSegment.getIntersection = function(s1, s2) {};

/**
 * Checks whether the line segment intersects a point.
 * Checks whether the line segment intersects a box.
 * @param {!yfiles.algorithms.YPoint|!yfiles.algorithms.YRectangle} p_or_box a point / A rectangle.
 * @return {boolean} <code>true</code> if the line segments intersects the given point, <code>false</code> otherwise. / <code>true</code> if the line segments intersects the box, <code>false</code> otherwise.
 */
yfiles.algorithms.LineSegment.prototype.intersects = function(p_or_box) {};

/**
 * Determines if the given points define a horizontal line segment.
 * <p>
 * This methods allows for y-coordinate differences of up to 1e-8.
 * </p>
 * @param {!yfiles.algorithms.YPoint} p1
 * @param {!yfiles.algorithms.YPoint} p2
 * @return {boolean} <code>true</code> if the given points define a horizontal line segment; <code>false</code> otherwise.
 */
yfiles.algorithms.LineSegment.isHorizontalSegment = function(p1, p2) {};

/**
 * Returns if the projection on the X axis of the line segment covers a certain point on the X Axis.
 * @param {number} x
 * @return {boolean}
 */
yfiles.algorithms.LineSegment.prototype.isInXIntervall = function(x) {};

/**
 * Returns if the projection on the Y axis of the line segment covers a certain point on the Y Axis.
 * @param {number} y
 * @return {boolean}
 */
yfiles.algorithms.LineSegment.prototype.isInYIntervall = function(y) {};

/**
 * Determines if the given points define a vertical line segment.
 * <p>
 * This methods allows for x-coordinate differences of up to 1e-8.
 * </p>
 * @param {!yfiles.algorithms.YPoint} p1
 * @param {!yfiles.algorithms.YPoint} p2
 * @return {boolean} <code>true</code> if the given points define a vertical line segment; <code>false</code> otherwise.
 */
yfiles.algorithms.LineSegment.isVerticalSegment = function(p1, p2) {};

/**
 * Returns the length of the line segment, this is the value of the Euclidean norm.
 * @return {number} an value > 0.
 */
yfiles.algorithms.LineSegment.prototype.length = function() {};

/**
 * Returns the affine line defined by the end points of the line segment.
 * @return {!yfiles.algorithms.AffineLine}
 */
yfiles.algorithms.LineSegment.prototype.toAffineLine = function() {};

/**
 * Returns the vector pointing from the first end point to the second end point of the line segment.
 * @return {!yfiles.algorithms.YVector}
 */
yfiles.algorithms.LineSegment.prototype.toYVector = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Point2D = function() {};
 /** @type {!yfiles.algorithms.Point2D} */
yfiles.algorithms.Point2D.prototype.location;
 /** @type {number} */
yfiles.algorithms.Point2D.prototype.x;
 /** @type {number} */
yfiles.algorithms.Point2D.prototype.y;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Point2D.$class;

/**
 * Creates a new instance of this class that has the same values as this objects.
 * @return {!Object} a new instance of this class that has the same values as this objects.
 */
yfiles.algorithms.Point2D.prototype.clone = function() {};

/**
 * Calculates the distance between this points and another one, given as its coordinates.
 * Calculates the distance between this points and another one.
 * @param {number|!yfiles.algorithms.Point2D} px_or_p The x coordinate of the second point. / The second point.
 * @param {number=} py The y coordinate of the second point.
 * @return {number} the distance between this points and another one, given as its coordinates. / the distance between this points and another one.
 */
yfiles.algorithms.Point2D.prototype.distance = function(px_or_p, py) {};

/**
 * Calculates the distance between two points, given as their coordinates.
 * @param {number} x1 The x coordinate of the first point.
 * @param {number} y1 The y coordinate of the first point.
 * @param {number} x2 The x coordinate of the second point.
 * @param {number} y2 The y coordinate of the second point.
 * @return {number} the distance between two points, given as their coordinates.
 */
yfiles.algorithms.Point2D.distance = function(x1, y1, x2, y2) {};

/**
 * Calculates the squared distance between this points and another one, given as its coordinates.
 * Calculates the squared distance between this points and another one.
 * @param {number|!yfiles.algorithms.Point2D} px_or_p The x coordinate of the second point. / The second point.
 * @param {number=} py The y coordinate of the second point.
 * @return {number} the squared distance between this points and another one, given as its coordinates. / the squared distance between this points and another one.
 */
yfiles.algorithms.Point2D.prototype.distanceSq = function(px_or_p, py) {};

/**
 * Calculates the squared distance between two points, given as their coordinates.
 * @param {number} x1 The x coordinate of the first point.
 * @param {number} y1 The y coordinate of the first point.
 * @param {number} x2 The x coordinate of the second point.
 * @param {number} y2 The y coordinate of the second point.
 * @return {number} the squared distance between two points, given as their coordinates.
 */
yfiles.algorithms.Point2D.distanceSq = function(x1, y1, x2, y2) {};

/**
 * Sets the location of this point to the given coordinates.
 * @param {number} x the new x coordinate
 * @param {number} y the new y coordinate
 * @return {void}
 */
yfiles.algorithms.Point2D.prototype.setLocation = function(x, y) {};

/**
 * Creates a {\@link yfiles.geometry.Point} from a given {\@link yfiles.algorithms.Point2D}.
 * @return {!yfiles.geometry.Point} The {\@link }.
 */
yfiles.algorithms.Point2D.prototype.toPoint = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Rectangle2D = function() {};
 /** @type {!yfiles.algorithms.Rectangle2D} */
yfiles.algorithms.Rectangle2D.prototype.frame;
 /** @type {!yfiles.algorithms.Rectangle2D} */
yfiles.algorithms.Rectangle2D.prototype.rect;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.x;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.y;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.width;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.height;
 /** @type {boolean} */
yfiles.algorithms.Rectangle2D.prototype.empty;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.minX;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.minY;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.maxX;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.maxY;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.centerX;
 /** @type {number} */
yfiles.algorithms.Rectangle2D.prototype.centerY;
 /** @type {!yfiles.algorithms.Rectangle2D} */
yfiles.algorithms.Rectangle2D.prototype.bounds2D;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Rectangle2D.$class;

/**
 * Adds a point, specified by its coordinates, to this rectangle.
 * <p>
 * The rectangle will be grown if necessary. Note that for points that would lie on the right or bottom border of the
 * rectangle, {\@link yfiles.algorithms.Rectangle2D#contains} will still return <code>false</code> for the added point.
 * </p>
 * Adds a rectangle to this rectangle.
 * <p>
 * The rectangle will be grown to the union of both rectangles
 * </p>
 * @param {number|!yfiles.algorithms.Rectangle2D} px_or_r the x coordinate of the point to add / the rectangle to add
 * @param {number=} py the y coordinate of the point to add
 * @return {void}
 */
yfiles.algorithms.Rectangle2D.prototype.add = function(px_or_r, py) {};

/**
 * Creates a new instance of this class that has the same values as this objects.
 * @return {!Object} a new instance of this class that has the same values as this objects.
 */
yfiles.algorithms.Rectangle2D.prototype.clone = function() {};

/**
 * Checks whether this rectangle completely contains the second specified rectangle.
 * Checks if the point specified by the given coordinates is contained in this rectangle.
 * Checks whether this rectangle completely contains the second specified rectangle.
 * @param {number|!yfiles.algorithms.Rectangle2D} x_or_rect the x coordinate of the second rectangle. / the x-coordinate of the point. / the rectangle to check for containment
 * @param {number=} y the y coordinate of the second rectangle. / the y-coordinate of the point.
 * @param {number=} width the width coordinate of the second rectangle.
 * @param {number=} height the height coordinate of the second rectangle.
 * @return {boolean} <code>true</code> if this rectangle contains the second one / <code>true</code> if the specified point is contained in this rectangle; <code>false</code> otherwise.
 */
yfiles.algorithms.Rectangle2D.prototype.contains = function(x_or_rect, y, width, height) {};

/**
 * Calculates the intersection of this rectangle with the given rectangle and returns the result as new rectangle.
 * @param {!yfiles.algorithms.Rectangle2D} r a rectangle to intersect with this rectangle.
 * @return {!yfiles.algorithms.Rectangle2D} a new rectangle that represents the calculated intersection.
 */
yfiles.algorithms.Rectangle2D.prototype.createIntersection = function(r) {};

/**
 * Calculates the union of this rectangle with the given rectangle and returns the result as new rectangle.
 * @param {!yfiles.algorithms.Rectangle2D} r a rectangle to union with this rectangle.
 * @return {!yfiles.algorithms.Rectangle2D} a new rectangle that represents the calculated union.
 */
yfiles.algorithms.Rectangle2D.prototype.createUnion = function(r) {};

/**
 * Calculates the intersection of the first and second specified rectangle and sets the resulting location and size to the
 * third rectangle.
 * @param {!yfiles.algorithms.Rectangle2D} src1 the first rectangle to intersect.
 * @param {!yfiles.algorithms.Rectangle2D} src2 the second rectangle to intersect.
 * @param {!yfiles.algorithms.Rectangle2D} dst the rectangle to which the result is set.
 * @return {void}
 */
yfiles.algorithms.Rectangle2D.intersect = function(src1, src2, dst) {};

/**
 * Checks whether this rectangle and the second specified rectangle intersect.
 * Checks whether this rectangle and the second specified rectangle intersect.
 * @param {number|!yfiles.algorithms.Rectangle2D} x_or_rect the x coordinate of the second rectangle. / the rectangle to check for intersection
 * @param {number=} y the y coordinate of the second rectangle.
 * @param {number=} width the width coordinate of the second rectangle.
 * @param {number=} height the height coordinate of the second rectangle.
 * @return {boolean} <code>true</code> if both rectangles intersect
 */
yfiles.algorithms.Rectangle2D.prototype.intersects = function(x_or_rect, y, width, height) {};

/**
 * Checks if the line segment specified by the given coordinates intersects this rectangle.
 * @param {number} x1 the x-coordinate of the first end point of the line.
 * @param {number} y1 the y-coordinate of the first end point of the line.
 * @param {number} x2 the x-coordinate of the other end point of the line.
 * @param {number} y2 the y-coordinate of the other end point of the line.
 * @return {boolean} <code>true</code> if the specified line intersects this rectangle; <code>false</code> otherwise.
 */
yfiles.algorithms.Rectangle2D.prototype.intersectsLine = function(x1, y1, x2, y2) {};

/**
 * Sets the outer bounds of this rectangle based on the specified location and size.
 * @param {number} x the new x-coordinate of the upper left corner.
 * @param {number} y the new y-coordinate of the upper left corner.
 * @param {number} width the new width.
 * @param {number} height the new height.
 * @return {void}
 */
yfiles.algorithms.Rectangle2D.prototype.setFrame = function(x, y, width, height) {};

/**
 * Sets the outer bounds of this rectangle based on the specified new center and corner.
 * Sets the outer bounds of this rectangle based on the specified new center and corner.
 * @param {number|!yfiles.algorithms.Point2D} centerX_or_center the x-coordinate of the new center of this rectangle. / the new center of this rectangle.
 * @param {number|!yfiles.algorithms.Point2D} centerY_or_corner the y-coordinate of the new center of this rectangle. / any new corner of this rectangle.
 * @param {number=} cornerX the x-coordinate of any new corner of this rectangle.
 * @param {number=} cornerY the y-coordinate of any new corner of this rectangle.
 * @return {void}
 */
yfiles.algorithms.Rectangle2D.prototype.setFrameFromCenter = function(centerX_or_center, centerY_or_corner, cornerX, cornerY) {};

/**
 * Sets the outer bounds of this rectangle based on the end points of one of its diagonals.
 * Sets the outer bounds of this rectangle based on the end points of one of its diagonals.
 * @param {number|!yfiles.algorithms.Point2D} x1_or_p1 the x-coordinate of the first end point of a diagonal. / the first end point of a diagonal.
 * @param {number|!yfiles.algorithms.Point2D} y1_or_p2 the y-coordinate of the first end point of a diagonal. / the other end point of a diagonal.
 * @param {number=} x2 the x-coordinate of the other end point of a diagonal.
 * @param {number=} y2 the y-coordinate of the other end point of a diagonal.
 * @return {void}
 */
yfiles.algorithms.Rectangle2D.prototype.setFrameFromDiagonal = function(x1_or_p1, y1_or_p2, x2, y2) {};

/**
 * Sets the location and size of this rectangle to the specified values.
 * @param {number} x the new x-coordinate of the upper left corner.
 * @param {number} y the new y-coordinate of the upper left corner.
 * @param {number} width the new width.
 * @param {number} height the new height.
 * @return {void}
 */
yfiles.algorithms.Rectangle2D.prototype.setRect = function(x, y, width, height) {};

/**
 * Creates a {\@link yfiles.geometry.Rect} from a given {\@link yfiles.algorithms.Rectangle2D}.
 * @return {!yfiles.geometry.Rect} The {\@link }.
 */
yfiles.algorithms.Rectangle2D.prototype.toRect = function() {};

/**
 * Calculates the union of the first and second specified rectangle and sets the resulting location and size to the third
 * rectangle.
 * @param {!yfiles.algorithms.Rectangle2D} src1 the first rectangle to union.
 * @param {!yfiles.algorithms.Rectangle2D} src2 the second rectangle to union.
 * @param {!yfiles.algorithms.Rectangle2D} dst the rectangle to which the result is set.
 * @return {void}
 */
yfiles.algorithms.Rectangle2D.union = function(src1, src2, dst) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Triangulator = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Triangulator.$class;

/**
 * Computes a Delauney triangulation of the given points.
 * <p>
 * A Delauney triangulation is a triangulation such that none of the given points is inside the circumcircle of any of the
 * calculated triangles.
 * </p>
 * <p>
 * The calculated triangulation is represented by an embedded graph, i.e. to each edge there exists a reverse edge and the
 * outedges around each node are in embedded order. The returned edge and the (optional) reverseEdgeMap can be used to
 * construct all faces of the plane graph and to determine its outer face.
 * </p>
 * @param {!yfiles.algorithms.Graph} result a graph whose nodes represent the points that need to be triangulated.
 * @param {?} pointData must provide the location (YPoint) for each node in the given graph.
 * @param {?} revMap a node map that will contain for each edge its reverse edge. If this argument is <code>null</code> then no reverse edge information
 * will be available.
 * @return {!yfiles.algorithms.Edge} an edge on the outer face of the result graph.
 */
yfiles.algorithms.Triangulator.calcDelauneyTriangulation = function(result, pointData, revMap) {};

/**
 * Computes a triangulation of the given points.
 * <p>
 * The calculated triangulation is represented by an embedded graph, i.e. to each edge there exists a reverse edge and the
 * outedges around each node are in embedded order. The returned edge and the (optional) reverseEdgeMap can be used to
 * construct all faces of the plane graph and to determine its outer face.
 * </p>
 * Computes a triangulation of the given points.
 * <p>
 * The calculated triangulation is represented by an embedded graph, i.e. to each edge there exists a reverse edge and the
 * outedges around each node are in embedded order. The returned edge and the (optional) reverseEdgeMap can be used to
 * construct all faces of the plane graph and to determine its outer face.
 * </p>
 * @param {!yfiles.algorithms.YList|!yfiles.algorithms.Graph} points_or_result the point set to be triangulated. The points must be provided as a YList of YPoints. / a graph whose nodes represent the points that need to be triangulated.
 * @param {!yfiles.algorithms.Graph|?} result_or_pointData the resulting triangulation / must provide the location (YPoint) for each node in the given graph.
 * @param {?} resultMap_or_reverseEdgeMap the node map that forms the link between a point and a node. / a node map that will contain for each edge its reverse edge. If this argument is <code>null</code> then no reverse edge information
 * will be available.
 * @param {?=} reverseEdgeMap a node map that will contain for each edge its reverse edge. If this argument is <code>null</code> then no reverse edge information
 * will be available.
 * @return {!yfiles.algorithms.Edge} an edge on the outer face of the result graph.
 */
yfiles.algorithms.Triangulator.triangulatePoints = function(points_or_result, result_or_pointData, resultMap_or_reverseEdgeMap, reverseEdgeMap) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.YDimension = function() {};
 /** @type {number} */
yfiles.algorithms.YDimension.prototype.width;
 /** @type {number} */
yfiles.algorithms.YDimension.prototype.height;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.YDimension.$class;

/**
 *
 * @param {!Object} o
 * @return {number}
 */
yfiles.algorithms.YDimension.prototype.compareTo = function(o) {};

/**
 * Creates a {\@link yfiles.geometry.Size} from a given {\@link yfiles.algorithms.YDimension}.
 * @return {!yfiles.geometry.Size} The {\@link }.
 */
yfiles.algorithms.YDimension.prototype.toSize = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.YOrientedRectangle = function() {};
 /** @type {boolean} */
yfiles.algorithms.YOrientedRectangle.prototype.empty;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.algorithms.YOrientedRectangle.prototype.anchor;
 /** @type {number} */
yfiles.algorithms.YOrientedRectangle.prototype.anchorX;
 /** @type {number} */
yfiles.algorithms.YOrientedRectangle.prototype.anchorY;
 /** @type {!yfiles.algorithms.YDimension} */
yfiles.algorithms.YOrientedRectangle.prototype.size;
 /** @type {number} */
yfiles.algorithms.YOrientedRectangle.prototype.width;
 /** @type {number} */
yfiles.algorithms.YOrientedRectangle.prototype.height;
 /** @type {number} */
yfiles.algorithms.YOrientedRectangle.prototype.upX;
 /** @type {number} */
yfiles.algorithms.YOrientedRectangle.prototype.upY;
 /** @type {number} */
yfiles.algorithms.YOrientedRectangle.prototype.angle;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.algorithms.YOrientedRectangle.prototype.center;
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.algorithms.YOrientedRectangle.prototype.boundingBox;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.YOrientedRectangle.$class;

/**
 * Copies the actual values from the given <code>OrientedRectangle</code> to this instance.
 * @param {!yfiles.algorithms.YOrientedRectangle} other the <code>OrientedRectangle</code> to retrieve the values from
 * @return {void}
 */
yfiles.algorithms.YOrientedRectangle.prototype.adoptValues = function(other) {};

/**
 * Determines the four corner points of an oriented rectangle.
 * @param {!yfiles.algorithms.YOrientedRectangle} rect The rectangle to determine the bounds.
 * @return {!Array<!yfiles.algorithms.YPoint>} the array of corner points.
 */
yfiles.algorithms.YOrientedRectangle.calcPoints = function(rect) {};

/**
 * Determines the coordinates of the four corners of an oriented rectangle.
 * @param {!yfiles.algorithms.YOrientedRectangle} rect The rectangle to determine the bounds.
 * @return {!Array<number>} the array of coordinates of the corner points in which each even index has the x-coordinate and each odd index the
 * y-coordinate
 */
yfiles.algorithms.YOrientedRectangle.calcPointsInDouble = function(rect) {};

/**
 * Determines whether or not the specified point lies inside this oriented rectangle.
 * @param {number} x the x-coordinate of the point to check.
 * @param {number} y the y-coordinate of the point to check.
 * @param {boolean=} closed
 * @return {boolean} <code>true</code> iff the specified point lies inside; <code>false</code> otherwise.
 */
yfiles.algorithms.YOrientedRectangle.prototype.contains = function(x, y, closed) {};

/**
 * Determines whether the given rectangle r1 contains rectangle r2, using an epsilon value.
 * Determines whether the given oriented rectangle contains the provided point, using an epsilon value.
 * Determines whether the given oriented rectangle contains the provided point, using an epsilon value.
 * @param {!yfiles.algorithms.YOrientedRectangle} r1_or_rect The first rectangle. / The rectangle.
 * @param {!yfiles.algorithms.YOrientedRectangle|!yfiles.algorithms.YPoint|number} r2_or_p_or_x The second rectangle. / The point to test. / x-coordinate of the point to test.
 * @param {number} eps_or_y A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than
 * or equal to that value, it will be considered a hit. / fuzziness range. A positive value allows for fuzzy hit testing. If a point lies outside the given rectangle, but its
 * distance is less than or equal to that value, it will be considered a hit. / y-coordinate of the point to test.
 * @param {number=} eps fuzziness range. A positive value allows for fuzzy hit testing. If a point lies outside the given rectangle, but its
 * distance is less than or equal to that value, it will be considered a hit.
 * @return {boolean} true iff the r1 contains r2. / <code>true</code> if the point lies inside the rectangle; <code>false</code> otherwise.
 */
yfiles.algorithms.YOrientedRectangle.contains = function(r1_or_rect, r2_or_p_or_x, eps_or_y, eps) {};

/**
 * Creates a new <code>OrientedRectangle</code> instance whose anchor point is moved by the specified distance values, but has the same
 * width, height, and up vector as this rectangle.
 * @param {number} dx the distance to move the anchor point in x-direction. A positive value means "move" to the right, a negative value means
 * "move" to the left.
 * @param {number} dy the distance to move the anchor point in y-direction. A positive value means "move" downwards, a negative value means
 * "move" upwards.
 * @return {!yfiles.algorithms.YOrientedRectangle} a new <code>OrientedRectangle</code> instance whose anchor point is moved by the specified distance values.
 */
yfiles.algorithms.YOrientedRectangle.prototype.getMovedInstance = function(dx, dy) {};

/**
 * Creates a new <code>OrientedRectangle</code> instance that has the specified width and height, but has the same anchor point and up
 * vector as this rectangle.
 * @param {number} width the width of the new rectangle.
 * @param {number} height the height of the new rectangle.
 * @return {!yfiles.algorithms.YOrientedRectangle} a new <code>OrientedRectangle</code> instance that has the specified width and height.
 */
yfiles.algorithms.YOrientedRectangle.prototype.getResizedInstance = function(width, height) {};

/**
 * Determines an intersection point of the specified oriented rectangle and the specified line segment.
 * <p>
 * Note: there might be more than one intersection point. However this method only returns one intersection point or <code>null</code>
 * if there is no intersection.
 * </p>
 * @param {!yfiles.algorithms.YOrientedRectangle} rect
 * @param {!yfiles.algorithms.LineSegment} line
 * @param {number} eps
 * @return {!yfiles.algorithms.YPoint} an intersection point of the specified oriented rectangle and the specified line segment or <code>null</code> if the rectangle and
 * the segment do not intersect.
 */
yfiles.algorithms.YOrientedRectangle.intersectionPoint = function(rect, line, eps) {};

/**
 * Determines whether or not the specified oriented rectangle and the specified line segment intersect.
 * Determines whether a rectangle intersects an oriented rectangle, given an epsilon.
 * @param {!yfiles.algorithms.YOrientedRectangle} rect_or_orientedRectangle The oriented rectangle to test.
 * @param {!yfiles.algorithms.LineSegment|!yfiles.algorithms.YRectangle} line_or_rectangle The rectangle to test.
 * @param {number} eps A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than
 * or equal to that value, it will be considered a hit.
 * @return {boolean} <code>true</code> if the rectangle and the segment intersect and <code>false</code> otherwise. / Whether they have a non-empty intersection.
 */
yfiles.algorithms.YOrientedRectangle.intersects = function(rect_or_orientedRectangle, line_or_rectangle, eps) {};

/**
 * Moves this rectangle by applying the offset to the anchor.
 * @param {number} dx The x offset to move the rectangle's position by.
 * @param {number} dy The y offset to move the rectangle's position by.
 * @return {void}
 */
yfiles.algorithms.YOrientedRectangle.prototype.moveBy = function(dx, dy) {};

/**
 * Sets the anchor of this rectangle.
 * @param {number} x the new x-coordinate of the anchor point.
 * @param {number} y the new y-coordinate of the anchor point.
 * @return {void}
 */
yfiles.algorithms.YOrientedRectangle.prototype.setAnchor = function(x, y) {};

/**
 * Sets the anchor of the OrientedRectangle so that the center of the rectangle coincides with the given coordinate pair.
 * @param {number} cx The x coordinate of the center.
 * @param {number} cy The y coordinate of the center.
 * @return {void}
 */
yfiles.algorithms.YOrientedRectangle.prototype.setCenter = function(cx, cy) {};

/**
 * Sets the size of this rectangle.
 * @param {number} width the new width.
 * @param {number} height the new height.
 * @return {void}
 */
yfiles.algorithms.YOrientedRectangle.prototype.setSize = function(width, height) {};

/**
 * Sets the components of the up vector to the new values.
 * @param {number} upX The x component of the normalized up vector.
 * @param {number} upY The y component of the normalized up vector.
 * @return {void}
 */
yfiles.algorithms.YOrientedRectangle.prototype.setUpVector = function(upX, upY) {};

/**
 * Creates an immutable {\@link yfiles.geometry.IOrientedRectangle} from a given {\@link yfiles.algorithms.YOrientedRectangle}.
 * @return {?} The {\@link }.
 */
yfiles.algorithms.YOrientedRectangle.prototype.toImmutableOrientedRectangle = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.YPoint = function() {};
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.algorithms.YPoint.ORIGIN;
 /** @type {number} */
yfiles.algorithms.YPoint.prototype.x;
 /** @type {number} */
yfiles.algorithms.YPoint.prototype.y;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.YPoint.$class;

/**
 * Adds two points and returns the result.
 * @param {!yfiles.algorithms.YPoint} p1 an arbitrary instance of YPoint.
 * @param {!yfiles.algorithms.YPoint} p2 an arbitrary instance of YPoint.
 * @return {!yfiles.algorithms.YPoint}
 */
yfiles.algorithms.YPoint.add = function(p1, p2) {};

/**
 * Comparable implementation.
 * <p>
 * YPoints are ordered by ascending x-coordinates. If the x-coordinates of two points equal, then these points are ordered
 * by ascending y-coordinates.
 * </p>
 * @param {!Object} o
 * @return {number}
 */
yfiles.algorithms.YPoint.prototype.compareTo = function(o) {};

/**
 * Returns the euclidean distance between two points.
 * Returns the euclidean distance between two points.
 * @param {number|!yfiles.algorithms.YPoint} x1_or_p1 x-coordinate of first point / an arbitrary point
 * @param {number|!yfiles.algorithms.YPoint} y1_or_p2 y-coordinate of first point / an arbitrary point
 * @param {number=} x2 x-coordinate of second point
 * @param {number=} y2 y-coordinate of second point
 * @return {number} the euclidean distance between first and second point / the Euclidean distance between p1 and p2.
 */
yfiles.algorithms.YPoint.distance = function(x1_or_p1, y1_or_p2, x2, y2) {};

/**
 * Returns the euclidean distance between this point and a given point.
 * Returns the euclidean distance between this point and a given point.
 * @param {number|!yfiles.algorithms.YPoint} x_or_p the x coordinate of an arbitrary point / an arbitrary point
 * @param {number=} y the y coordinate of an arbitrary point
 * @return {number} the Euclidean distance between this point and the point (x,y). / the Euclidean distance between this point and p.
 */
yfiles.algorithms.YPoint.prototype.distanceTo = function(x_or_p, y) {};

/**
 * Returns a point that geometrically lies in in the middle of the line formed by the given points.
 * @param {!yfiles.algorithms.YPoint} p1 an arbitrary instance of YPoint.
 * @param {!yfiles.algorithms.YPoint} p2 an arbitrary instance of YPoint.
 * @return {!yfiles.algorithms.YPoint}
 */
yfiles.algorithms.YPoint.midPoint = function(p1, p2) {};

/**
 * Returns the point, got by moving this point to another position.
 * @param {number} x the value which is added on the x-coordinate of the point.
 * @param {number} y the value which is added on the y-coordinate of the point.
 * @return {!yfiles.algorithms.YPoint} a new instance of YPoint which is the result of the moving operation.
 */
yfiles.algorithms.YPoint.prototype.moveBy = function(x, y) {};

/**
 * Subtracts two points (p1 - p2) and returns the result.
 * @param {!yfiles.algorithms.YPoint} p1 an arbitrary instance of YPoint.
 * @param {!yfiles.algorithms.YPoint} p2 an arbitrary instance of YPoint.
 * @return {!yfiles.algorithms.YPoint}
 */
yfiles.algorithms.YPoint.subtract = function(p1, p2) {};

/**
 * Returns a copy of the given point with exchanged x- and y-coordinates.
 * @param {!yfiles.algorithms.YPoint} p an arbitrary instance of YPoint.
 * @return {!yfiles.algorithms.YPoint}
 */
yfiles.algorithms.YPoint.swap = function(p) {};

/**
 * Creates a {\@link yfiles.geometry.Point} from a given {\@link yfiles.algorithms.YPoint}.
 * @return {!yfiles.geometry.Point} The {\@link }.
 */
yfiles.algorithms.YPoint.prototype.toPoint = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.YPointPath = function() {};
 /** @type {!yfiles.algorithms.YPointPath} */
yfiles.algorithms.YPointPath.EMPTY_PATH;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.algorithms.YPointPath.prototype.first;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.algorithms.YPointPath.prototype.last;
 /** @type {number} */
yfiles.algorithms.YPointPath.prototype.lineSegmentCount;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.YPointPath.$class;

/**
 * Calculate the (geometric) length of the path.
 * <p>
 * The length of the path is the sum of lengths of all line segments making up the path.
 * </p>
 * @return {number} the (geometric) length of the path
 */
yfiles.algorithms.YPointPath.prototype.calculateLength = function() {};

/**
 * Create a point path with reverse ordering of the points.
 * @return {!yfiles.algorithms.YPointPath}
 */
yfiles.algorithms.YPointPath.prototype.createReverse = function() {};

/**
 * Get the points in the path.
 * @return {?}
 */
yfiles.algorithms.YPointPath.prototype.cursor = function() {};

/**
 * Returns a line segment in the path.
 * @param {number} i
 * @return {!yfiles.algorithms.LineSegment}
 */
yfiles.algorithms.YPointPath.prototype.getLineSegment = function(i) {};

/**
 * Get the number of points in the path.
 * @return {number}
 */
yfiles.algorithms.YPointPath.prototype.length = function() {};

/**
 * Get the points in the path.
 * @return {?}
 */
yfiles.algorithms.YPointPath.prototype.lineSegments = function() {};

/**
 * Get the points in the path.
 * @return {?}
 */
yfiles.algorithms.YPointPath.prototype.points = function() {};

/**
 * Get the points in the list as array.
 * @return {!Array<!yfiles.algorithms.YPoint>}
 */
yfiles.algorithms.YPointPath.prototype.toArray = function() {};

/**
 * Get the points in the path as list.
 * @return {?<!Object>} a list of {\@link } instances.
 */
yfiles.algorithms.YPointPath.prototype.toList = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.YRectangle = function() {};
 /** @type {number} */
yfiles.algorithms.YRectangle.prototype.x;
 /** @type {number} */
yfiles.algorithms.YRectangle.prototype.y;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.algorithms.YRectangle.prototype.location;
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.algorithms.YRectangle.prototype.boundingBox;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.YRectangle.$class;

/**
 * Checks whether or not this <code>YRectangle</code> contains the given rectangle.
 * Checks whether or not this <code>YRectangle</code> contains the given point.
 * Checks whether or not this <code>YRectangle</code> contains the rectangle defined by the given frame.
 * Checks whether or not this <code>YRectangle</code> contains the given point.
 * @param {!yfiles.algorithms.YRectangle|!yfiles.algorithms.YPoint|number} p_or_x the x-coordinate of the point to check.
 * @param {number=} y the x-coordinate of the point to check.
 * @param {number=} width
 * @param {number=} height
 * @return {boolean} <code>true</code> if the point lies inside the rectangle; <code>false</code> otherwise.
 */
yfiles.algorithms.YRectangle.prototype.contains = function(p_or_x, y, width, height) {};

/**
 * Determines whether the specified rectangle contains the specified point.
 * @param {number} rx the x-coordinate of the upper left corner of the rectangle.
 * @param {number} ry the y-coordinate of the upper left corner of the rectangle.
 * @param {number} rw the width of the rectangle.
 * @param {number} rh the height of the rectangle.
 * @param {number} x the x-coordinate of the point to check.
 * @param {number} y the x-coordinate of the point to check.
 * @param {boolean=} closed
 * @return {boolean} <code>true</code> if the point lies inside the rectangle; <code>false</code> otherwise.
 */
yfiles.algorithms.YRectangle.contains = function(rx, ry, rw, rh, x, y, closed) {};

/**
 * Returns the Euclidean distance to the passed rectangle.
 * <p>
 * If they overlap, the distance is 0.
 * </p>
 * @param {!yfiles.algorithms.YRectangle} other the second rectangle.
 * @return {number} the distance to the given rectangle.
 */
yfiles.algorithms.YRectangle.prototype.getEuclideanDistance = function(other) {};

/**
 * Returns the Manhattan distance to the passed rectangle.
 * <p>
 * If they overlap the distance is 0.
 * </p>
 * @param {!yfiles.algorithms.YRectangle} other the second rectangle.
 * @return {number} the distance to the given rectangle.
 */
yfiles.algorithms.YRectangle.prototype.getManhattanDistance = function(other) {};

/**
 * Returns whether or not the given rectangles intersect.
 * @param {!yfiles.algorithms.YRectangle} r1
 * @param {!yfiles.algorithms.YRectangle} r2
 * @return {boolean}
 */
yfiles.algorithms.YRectangle.intersects = function(r1, r2) {};

/**
 * Creates a {\@link yfiles.geometry.Rect} from a given {\@link yfiles.algorithms.YRectangle}.
 * @return {!yfiles.geometry.Rect} The {\@link }.
 */
yfiles.algorithms.YRectangle.prototype.toRect = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.YVector = function() {};
 /** @type {number} */
yfiles.algorithms.YVector.prototype.x;
 /** @type {number} */
yfiles.algorithms.YVector.prototype.y;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.YVector.$class;

/**
 * Adds a vector to this vector.
 * @param {!yfiles.algorithms.YVector} v the vector to add.
 * @return {void}
 */
yfiles.algorithms.YVector.prototype.add = function(v) {};

/**
 * Adds the vector to a point and returns the resulting point.
 * Adds two vectors and returns the result.
 * @param {!yfiles.algorithms.YPoint|!yfiles.algorithms.YVector} p_or_v a point. / first vector to sum.
 * @param {!yfiles.algorithms.YVector} v_or_w the vector to add to the point. / second vector to sum.
 * @return {!yfiles.algorithms.YPoint|!yfiles.algorithms.YVector} p+v / v+w
 */
yfiles.algorithms.YVector.add = function(p_or_v, v_or_w) {};

/**
 * Returns the result of the addition of two angles between <code>0</code> and <code>2*Pi</code>.
 * <p>
 * The result is calculated modulo <code>2*Pi</code>.
 * </p>
 * @param {number} a1 a value in <code>[0,2Pi)</code>.
 * @param {number} a2 a value in <code>[0,2Pi)</code>.
 * @return {number} The sum of a1 and a2 modulo <code>2*Pi</code>.
 */
yfiles.algorithms.YVector.addAngle = function(a1, a2) {};

/**
 * Returns the angle (measured in radians) between two vectors in clockwise order (with regards to screen coordinates) from
 * v1 to v2.
 * <p>
 * Screen coordinates mean positive x-direction is from left to right and positive y-direction is from top to bottom.
 * </p>
 * @param {!yfiles.algorithms.YVector} v1
 * @param {!yfiles.algorithms.YVector} v2
 * @return {number}
 */
yfiles.algorithms.YVector.angle = function(v1, v2) {};

/**
 * Returns this vector with unit length.
 * @param {!yfiles.algorithms.YVector} v
 * @return {!yfiles.algorithms.YVector}
 */
yfiles.algorithms.YVector.getNormal = function(v) {};

/**
 * Returns the length of the vector, this is the value of the euclidean norm.
 * @return {number} a value > 0.
 */
yfiles.algorithms.YVector.prototype.length = function() {};

/**
 * Assigns unit length to the vector.
 * <br />
 * @return {void}
 */
yfiles.algorithms.YVector.prototype.norm = function() {};

/**
 * Returns the vector which is orthogonal to the given one and has unit length.
 * @param {!yfiles.algorithms.YVector} v a vector.
 * @return {!yfiles.algorithms.YVector} a vector which is orthogonal to v with unit length.
 */
yfiles.algorithms.YVector.orthoNormal = function(v) {};

/**
 * Returns true if vector v1 is on the right side of v2.
 * @param {!yfiles.algorithms.YVector} v1
 * @param {!yfiles.algorithms.YVector} v2
 * @return {boolean}
 */
yfiles.algorithms.YVector.rightOf = function(v1, v2) {};

/**
 * Returns a new <code>YVector</code> instance that is obtained by rotating this vector by the given angle (measured in radians) in
 * clockwise direction (with regards to screen coordinates).
 * <p>
 * Screen coordinates mean positive x-direction is from left to right and positive y-direction is from top to bottom.
 * </p>
 * @param {number} angle the angle of rotation in radians.
 * @return {!yfiles.algorithms.YVector} the rotated vector.
 */
yfiles.algorithms.YVector.prototype.rotate = function(angle) {};

/**
 * Returns the value of the scalar product of two vectors.
 * @param {!yfiles.algorithms.YVector} v1 the first vector.
 * @param {!yfiles.algorithms.YVector} v2 the second vector.
 * @return {number} <code>v1.x * v2.x + v1.y * v2.y</code>
 */
yfiles.algorithms.YVector.scalarProduct = function(v1, v2) {};

/**
 * Scales the vector by an factor.
 * @param {number} factor the scale factor, with which the length is multiplied.
 * @return {void}
 */
yfiles.algorithms.YVector.prototype.scale = function(factor) {};

/**
 * Creates a {\@link yfiles.geometry.Point} from a given {\@link yfiles.algorithms.YVector}.
 * @return {!yfiles.geometry.Point} The {\@link }.
 */
yfiles.algorithms.YVector.prototype.toPoint = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Graph = function() {};
 /** @type {number} */
yfiles.algorithms.Graph.prototype.n;
 /** @type {number} */
yfiles.algorithms.Graph.prototype.nodeCount;
 /** @type {number} */
yfiles.algorithms.Graph.prototype.e;
 /** @type {number} */
yfiles.algorithms.Graph.prototype.edgeCount;
 /** @type {boolean} */
yfiles.algorithms.Graph.prototype.empty;
 /** @type {!yfiles.algorithms.Node} */
yfiles.algorithms.Graph.prototype.firstNode;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Graph.prototype.firstEdge;
 /** @type {!yfiles.algorithms.Node} */
yfiles.algorithms.Graph.prototype.lastNode;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Graph.prototype.lastEdge;
 /** @type {!Array<?>} */
yfiles.algorithms.Graph.prototype.registeredNodeMaps;
 /** @type {!Array<?>} */
yfiles.algorithms.Graph.prototype.registeredEdgeMaps;
 /** @type {!Array<!Object>} */
yfiles.algorithms.Graph.prototype.dataProviderKeys;
 /** @type {?<!yfiles.algorithms.Node>} */
yfiles.algorithms.Graph.prototype.nodes;
 /** @type {?<!yfiles.algorithms.Edge>} */
yfiles.algorithms.Graph.prototype.edges;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Graph.$class;

/**
 * Registers the given data provider using the given look-up key.
 * <p>
 * If there is already a data provider registered with that key, then it will be overwritten with the new one.
 * </p>
 * @param {!Object} providerKey
 * @param {?} data
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.addDataProvider = function(providerKey, data) {};

/**
 * Redefines an edge's end points and fires corresponding notification events to inform registered listeners.
 * <p>
 * Edge <code>e</code> has source node <code>v := sourceReference.source()</code> or <code>v := newSource</code>, if <code>sourceReference == null</code> and target node <code>w := targetReference.target()</code>
 * or <code>w := newTarget</code>, if <code>targetReference == null</code>.
 * <br />
 * 
 * <br />
 * Edge <code>e</code> is inserted in such a way that an iteration over the edges at <code>v</code> returns <code>e</code>
 * </p>
 * <ul>
 * <li>after <code>sourceReference</code>, if <code>sourceD == AFTER</code></li>
 * <li>before <code>sourceReference</code>, if <code>sourceD == BEFORE</code>,</li>
 * </ul>
 * <p>
 * and an iteration over the edges at <code>w</code> returns <code>e</code>
 * </p>
 * <ul>
 * <li>after <code>targetReference</code>, if <code>targetD == AFTER</code></li>
 * <li>before <code>targetReference</code>, if <code>targetD == BEFORE</code>.</li>
 * </ul>
 * Redefines an edge's end points and fires corresponding notification events to inform registered listeners.
 * <p>
 * Edge <code>e</code> has source node <code>v := e1.source()</code> and target node <code>w := e2.target()</code>.
 * <br />
 * 
 * <br />
 * Edge <code>e</code> is inserted in such a way that an iteration over the edges at <code>v</code> returns <code>e</code>
 * </p>
 * <ul>
 * <li>after <code>e1</code>, if <code>d1 == AFTER</code></li>
 * <li>before <code>e1</code>, if <code>d1 == BEFORE</code>,</li>
 * </ul>
 * <p>
 * and an iteration over the edges at <code>w</code> returns <code>e</code>
 * </p>
 * <ul>
 * <li>after <code>e2</code>, if <code>d2 == AFTER</code></li>
 * <li>before <code>e2</code>, if <code>d2 == BEFORE</code>.</li>
 * </ul>
 * Redefines an edge's end points and fires corresponding notification events to inform registered listeners.
 * <p>
 * The edge is appended to the lists of incoming and outgoing edges at the given source node and target node,
 * respectively.
 * </p>
 * @param {!yfiles.algorithms.Edge} e The edge to be changed.
 * @param {!yfiles.algorithms.Node|!yfiles.algorithms.Edge} newSource_or_e1 The new source node. / Reference edge for insertion at a new source node. / The new source node of the given edge.
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} sourceReference_or_e2_or_newTarget Reference edge for insertion at the new source node. / Reference edge for insertion at a new target node. / The new target node of the given edge.
 * @param {yfiles.algorithms.GraphElementInsertion=} sourceD_or_d1 One of the object insertion specifiers {\@link #BEFORE} or
 * {\@link #AFTER}.
 * @param {!yfiles.algorithms.Node|yfiles.algorithms.GraphElementInsertion=} newTarget_or_d2 The new target node. / One of the object insertion specifiers {\@link #BEFORE} or
 * {\@link #AFTER}.
 * @param {!yfiles.algorithms.Edge=} targetReference Reference edge for insertion at the new target node.
 * @param {yfiles.algorithms.GraphElementInsertion=} targetD One of the object insertion specifiers {\@link #BEFORE} or
 * {\@link #AFTER}.
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.changeEdge = function(e, newSource_or_e1, sourceReference_or_e2_or_newTarget, sourceD_or_d1, newTarget_or_d2, targetReference, targetD) {};

/**
 * Removes all nodes and edges from this graph and fires corresponding notification events to inform registered listeners.
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.clear = function() {};

/**
 * Whether or not this graph contains the given edge.
 * Whether or not this graph contains the given node.
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} e_or_v
 * @return {boolean}
 */
yfiles.algorithms.Graph.prototype.contains = function(e_or_v) {};

/**
 * Returns whether or not this graph contains an edge that connects the given nodes.
 * @see yfiles.algorithms.Node#getEdgeTo
 * @see yfiles.algorithms.Node#getEdgeFrom
 * @see yfiles.algorithms.Node#getEdge
 * @param {!yfiles.algorithms.Node} source The source node.
 * @param {!yfiles.algorithms.Node} target The target node.
 * @return {boolean}
 */
yfiles.algorithms.Graph.prototype.containsEdge = function(source, target) {};

/**
 * Creates a copy of this graph.
 * <p>
 * Invokes {\@link yfiles.algorithms.Graph#Graph}.
 * </p>
 * @return {!yfiles.algorithms.Graph} The newly created Graph object.
 */
yfiles.algorithms.Graph.prototype.createCopy = function() {};

/**
 * Creates a new edge in this graph to be ordered before or after a given edge and fires a corresponding notification event
 * to inform registered listeners.
 * <p>
 * The new edge <code>e</code> has source node <code>v</code> and target node <code>w</code>, i.e., would be written as edge <code>e = (v, w)</code>.
 * <br />
 * 
 * <br />
 * Edge <code>e</code> is inserted in such a way that an iteration over the edges at node <code>v</code> returns <code>e</code>
 * </p>
 * <ul>
 * <li>after <code>e1</code>, if <code>d1 == AFTER</code></li>
 * <li>before <code>e1</code>, if <code>d1 == BEFORE</code>,</li>
 * </ul>
 * <p>
 * and an iteration over the edges at <code>w</code> returns <code>e</code>
 * </p>
 * <ul>
 * <li>after <code>e2</code>, if <code>d2 == AFTER</code></li>
 * <li>before <code>e2</code>, if <code>d2 == BEFORE</code>.</li>
 * </ul>
 * Creates a new edge in this graph and fires a corresponding notification event to inform registered listeners.
 * <p>
 * The new edge has source node <code>v</code> and target node <code>w</code>, i.e., would be written as edge <code>e = (v, w)</code>.
 * </p>
 * <p>
 * The edge is appended to the lists of incoming and outgoing edges at the source node and target node, respectively.
 * </p>
 * @param {!yfiles.algorithms.Node} v The source node of the edge.
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} e1_or_w An edge with source node <code>v</code>. / The target node of the edge.
 * @param {!yfiles.algorithms.Node=} w The target node of the edge.
 * @param {!yfiles.algorithms.Edge=} e2 An edge with target node <code>w</code>.
 * @param {yfiles.algorithms.GraphElementInsertion=} d1 One of the object insertion specifiers {\@link #BEFORE} or
 * {\@link #AFTER}.
 * @param {yfiles.algorithms.GraphElementInsertion=} d2 One of the object insertion specifiers {\@link #BEFORE} or
 * {\@link #AFTER}.
 * @return {!yfiles.algorithms.Edge} The newly created Edge object.
 */
yfiles.algorithms.Graph.prototype.createEdge = function(v, e1_or_w, w, e2, d1, d2) {};

/**
 * Returns a newly created edge map that is valid for the edges in this graph.
 * <p>
 * The implementation returned by this method can be used for any edge that is part of this Graph instance at any point of
 * time, i.e., it is safe to modify the graph structure (add and remove nodes and edges) freely.
 * </p>
 * <p>
 * The implementation returned uses <code>O(m)</code> memory at all times and provides true <code>O(1)</code> read and write access for each edge.
 * </p>
 * <p>
 * In order to release the resources held by this map, {\@link yfiles.algorithms.Graph#disposeEdgeMap} has to be called.
 * </p>
 * @return {?}
 */
yfiles.algorithms.Graph.prototype.createEdgeMap = function() {};

/**
 * Creates an empty base object of the same type as this graph.
 * <p>
 * Subclasses should override this method.
 * </p>
 * @return {!yfiles.algorithms.Graph}
 */
yfiles.algorithms.Graph.prototype.createGraph = function() {};

/**
 * Creates a new node in this graph and fires a corresponding notification event to inform registered listeners.
 * @return {!yfiles.algorithms.Node} The newly created Node object.
 */
yfiles.algorithms.Graph.prototype.createNode = function() {};

/**
 * Returns a newly created node map that is valid for the nodes in this graph.
 * <p>
 * The implementation returned by this method can be used for any node that is part of this Graph instance at any point of
 * time, i.e., it is safe to modify the graph structure (add and remove nodes and edges) freely.
 * </p>
 * <p>
 * The implementation returned uses <code>O(n)</code> memory at all times and provides true <code>O(1)</code> read and write access for each node.
 * </p>
 * <p>
 * In order to release the resources held by this map, {\@link yfiles.algorithms.Graph#disposeNodeMap} has to be called.
 * </p>
 * @return {?}
 */
yfiles.algorithms.Graph.prototype.createNodeMap = function() {};

/**
 * Informs the graph that the given edge map is no longer needed.
 * <p>
 * This method is used for EdgeMap implementations that have been obtained using the {\@link yfiles.algorithms.Graph#createEdgeMap}
 * factory method.
 * </p>
 * <p>
 * Calling this method will destroy the edge map and associated resources can be freed. It is strongly recommended to
 * dispose of all edge maps that are not needed anymore using this method.
 * </p>
 * @param {?} map
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.disposeEdgeMap = function(map) {};

/**
 * Informs the graph that the given node map is no longer needed.
 * <p>
 * This method is used for NodeMap implementations that have been obtained using the {\@link yfiles.algorithms.Graph#createNodeMap}
 * factory method.
 * </p>
 * <p>
 * Calling this method will destroy the node map and associated resources can be freed. It is strongly recommended to
 * dispose of all node maps that are not needed anymore using this method.
 * </p>
 * @param {?} map
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.disposeNodeMap = function(map) {};

/**
 * Low-level iteration support for adjacent edges.
 * @protected
 * @param {!yfiles.algorithms.Node} v
 * @return {!yfiles.algorithms.Edge}
 */
yfiles.algorithms.Graph.firstOutEdge = function(v) {};

/**
 * Returns the data provider that is registered with the graph using the given look-up key.
 * <p>
 * The look-up domain of a returned data provider normally consists of either the nodes of the graph, or its edges, or
 * both.
 * </p>
 * @param {!Object} providerKey
 * @return {?}
 */
yfiles.algorithms.Graph.prototype.getDataProvider = function(providerKey) {};

/**
 * Returns an array containing all edges of this graph.
 * @return {!Array<!yfiles.algorithms.Edge>}
 */
yfiles.algorithms.Graph.prototype.getEdgeArray = function() {};

/**
 * Provides access to the edges of the graph.
 * @return {?} An EdgeCursor to iterate over the edges in the graph.
 */
yfiles.algorithms.Graph.prototype.getEdgeCursor = function() {};

/**
 * Returns an array containing all nodes of this graph.
 * @return {!Array<!yfiles.algorithms.Node>}
 */
yfiles.algorithms.Graph.prototype.getNodeArray = function() {};

/**
 * Provides access to the nodes of the graph.
 * @return {?} A NodeCursor to iterate over the nodes in the graph.
 */
yfiles.algorithms.Graph.prototype.getNodeCursor = function() {};

/**
 * Hides the given node from this graph.
 * <p>
 * Hiding a node means to (temporarily) remove the node from the graph.
 * </p>
 * <p>
 * The only difference to a proper node removal as performed by {\@link yfiles.algorithms.Graph#removeNode} is that no event will be
 * emitted that signals the structural change (i.e. the node's removal).
 * </p>
 * <p>
 * Generally, hiding should <i>only</i> be used in the sense of temporarily removing an object that will be reinserted shortly after.
 * </p>
 * <p>
 * To reinsert a hidden node use {\@link yfiles.algorithms.Graph#unhide}.
 * </p>
 * @see yfiles.algorithms.Graph#hide
 * @see yfiles.algorithms.Graph#unhide
 * Hides the given edge from this graph.
 * <p>
 * Hiding an edge means to (temporarily) remove the edge from the graph.
 * </p>
 * <p>
 * The only difference to a proper edge removal as performed by {\@link yfiles.algorithms.Graph#removeEdge} is that no event will be
 * emitted that signals the structural change (i.e. the edge's removal).
 * </p>
 * <p>
 * Generally, hiding should <i>only</i> be used in the sense of temporarily removing an object that will be reinserted shortly after.
 * </p>
 * <p>
 * To reinsert a hidden edge use {\@link yfiles.algorithms.Graph#unhide}.
 * </p>
 * @see yfiles.algorithms.Graph#hide
 * @see yfiles.algorithms.Graph#unhide
 * @param {!yfiles.algorithms.Node|!yfiles.algorithms.Edge} v_or_e
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.hide = function(v_or_e) {};

/**
 * Moves the given edge to the first position within the sequence of edges in this graph.
 * Moves the given node to the first position within the sequence of nodes in this graph.
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} e_or_v
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.moveToFirst = function(e_or_v) {};

/**
 * Moves the given edge to the last position within the sequence of edges in this graph.
 * Moves the given node to the last position within the sequence of nodes in this graph.
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} e_or_v
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.moveToLast = function(e_or_v) {};

/**
 * For internal debugging purposes only.
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.printNodeSlotSize = function() {};

/**
 * Reinserts a formerly removed edge into this graph and fires a corresponding notification event to inform registered
 * listeners.
 * <p>
 * The reinserted edge is appended to the sequence of edges in this graph, i.e., normally, its new position does not match
 * the position before its removal. The same holds for the edge's positions in the list of incoming and outgoing edges at
 * its source node and target node, respectively.
 * </p>
 * <p>
 * Note that reinserting an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed)
 * causes an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.
 * </p>
 * @see yfiles.algorithms.Graph#removeEdge
 * @param {!yfiles.algorithms.Edge} e The edge to be reinserted.
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.reInsertEdge = function(e) {};

/**
 * Reinserts a formerly removed node into this graph and fires a corresponding notification event to inform registered
 * listeners.
 * <p>
 * The reinserted node is appended to the sequence of nodes in this graph, i.e., normally, its new position does not match
 * the position before its removal.
 * </p>
 * @see yfiles.algorithms.Graph#removeNode
 * @param {!yfiles.algorithms.Node} v The node to be reinserted.
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.reInsertNode = function(v) {};

/**
 * Removes the data provider that is registered using the given look-up key.
 * @param {!Object} providerKey
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.removeDataProvider = function(providerKey) {};

/**
 * Removes the given edge from this graph and fires a corresponding notification event to inform registered listeners.
 * <p>
 * The edge will be deselected before it gets removed.
 * </p>
 * @param {!yfiles.algorithms.Edge} e The edge to be removed.
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.removeEdge = function(e) {};

/**
 * Removes the given node from this graph.
 * <p>
 * All edges connecting to the given node are removed as well (preceding the actual node removal). Corresponding
 * notification events are fired to inform registered listeners.
 * </p>
 * <p>
 * The node will be deselected before it gets removed.
 * </p>
 * @param {!yfiles.algorithms.Node} v The node to be removed from this graph.
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.removeNode = function(v) {};

/**
 * Reverses the given edge and fires corresponding notification events to inform registered listeners.
 * <p>
 * This operation exchanges source and target node of the edge.
 * </p>
 * @param {!yfiles.algorithms.Edge} e
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.reverseEdge = function(e) {};

/**
 * Sorts incoming and outgoing edges at each node of the graph.
 * <p>
 * If a given comparator is <code>null</code>, then the corresponding edges (i.e., incoming/outgoing) will not be sorted. This sorts the
 * order of the edges as returned by {\@link yfiles.algorithms.Node#getOutEdgeCursor} and {\@link yfiles.algorithms.Node#getInEdgeCursor}
 * respectively.
 * </p>
 * Sorts the internally held list of edges.
 * <p>
 * If the given comparator is <code>null</code>, then the edges will not be sorted. This list determines the order of the edges as
 * returned by {\@link yfiles.algorithms.Graph#getEdgeCursor}.
 * </p>
 * @param {?<!Object>} inComparer_or_comparer The comparator used for the incoming edges at each node. / The comparator used for the edges.
 * @param {?<!Object>=} outComparer The comparator used for the outgoing edges at each node.
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.sortEdges = function(inComparer_or_comparer, outComparer) {};

/**
 * Sorts the internally held list of nodes.
 * <p>
 * If the given comparator is <code>null</code>, then the nodes will not be sorted. This list determines the order of the nodes as
 * returned by {\@link yfiles.algorithms.Graph#getNodeCursor}.
 * </p>
 * @param {?<!Object>} comparer The comparator used for the nodes.
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.sortNodes = function(comparer) {};

/**
 * Unhides the given node in this graph.
 * <p>
 * Unhiding a node means to reinsert a node that was formerly hidden from this graph by a call to
 * {\@link yfiles.algorithms.Graph#hide}.
 * </p>
 * <p>
 * The only difference to a proper node reinsertion as performed by {\@link yfiles.algorithms.Graph#reInsertNode} is that no event
 * will be emitted that signals the structural change (i.e. the node's reinsertion).
 * </p>
 * Unhides the given edge in this graph.
 * <p>
 * Unhiding an edge means to reinsert an edge that was formerly hidden from this graph by a call to
 * {\@link yfiles.algorithms.Graph#hide}.
 * </p>
 * <p>
 * The only difference to a proper edge reinsertion as performed by {\@link yfiles.algorithms.Graph#reInsertEdge} is that no event
 * will be emitted that signals the structural change (i.e. the edge's reinsertion).
 * </p>
 * <p>
 * Note that unhiding an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed) causes
 * an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.
 * </p>
 * @see yfiles.algorithms.Graph#hide
 * @see yfiles.algorithms.Graph#unhide
 * @param {!yfiles.algorithms.Node|!yfiles.algorithms.Edge} v_or_e
 * @return {void}
 */
yfiles.algorithms.Graph.prototype.unhide = function(v_or_e) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.GraphChecker = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.GraphChecker.$class;

/**
 * Checks whether or not the given directed graph is acyclic.
 * <p>
 * A graph is called <i>acyclic</i> if it contains no directed cycle.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the graph is acyclic, <code>false</code>, otherwise
 */
yfiles.algorithms.GraphChecker.isAcyclic = function(graph) {};

/**
 * Checks whether or not the given undirected graph is biconnected.
 * <p>
 * A graph is called <i>biconnected</i> if it has no cut vertex or articulation point, i.e., no node whose removal disconnects the graph.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given undirected graph
 * @return {boolean} <code>true</code> if the graph is biconnected, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isBiconnected = function(graph) {};

/**
 * Checks whether or not the given undirected graph is bipartite.
 * <p>
 * A graph is called <i>bipartite</i> if its nodes can be partitioned into two sets such that each edge connects two nodes of different
 * sets.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given undirected graph
 * @return {boolean} <code>true</code> if the graph is bipartite, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isBipartite = function(graph) {};

/**
 * Checks whether or not the given graph is connected.
 * <p>
 * A graph is called <i>connected</i> if there exists an undirected path of edges between every pair of nodes.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the graph is connected, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isConnected = function(graph) {};

/**
 * Checks whether or not the given directed graph is cyclic.
 * <p>
 * A graph is called <i>cyclic</i> if it contains a directed cycle.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the graph is cyclic, <code>false</code>, otherwise
 */
yfiles.algorithms.GraphChecker.isCyclic = function(graph) {};

/**
 * Checks whether the given graph is a forest.
 * <p>
 * A graph is a <i>forest</i> if its connected components are trees.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the graph is a forest, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isForest = function(graph) {};

/**
 * Checks whether or not the given undirected graph contains no multiple edges.
 * <p>
 * More precisely, the method returns <code>true</code> if the graph contains no two distinct edges <code>e1, e2</code> that connect the same pairs
 * of nodes in either direction.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given undirected graph
 * @return {boolean} <code>true</code> if the graph contains no multiple edges, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isMultipleEdgeFree = function(graph) {};

/**
 * Checks whether or not the given graph is a directed rooted tree where each node has a maximum of <code>n</code> children.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {number} n
 * @return {boolean} <code>true</code> if the graph is a directed rooted tree where each node has at most <code>n</code> children, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isNaryTree = function(graph, n) {};

/**
 * Checks whether or not the given directed graph is a directed rooted tree.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the graph is a directed rooted tree, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isRootedTree = function(graph) {};

/**
 * Checks whether or not the given graph contains no self-loops.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the graph contains no self-loops, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isSelfLoopFree = function(graph) {};

/**
 * Checks whether or not the given directed graph is simple.
 * <p>
 * A graph is called <i>simple</i> if it contains no two distinct edges <code>e1, e2</code> where
 * <code>e1.source() == e2.source() &amp;&amp; e1.target() == e2.target()</code>.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given directed graph
 * @return {boolean} <code>true</code> if the graph is simple, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isSimple = function(graph) {};

/**
 * Checks whether or not the given directed graph is strongly connected.
 * <p>
 * A graph is called <i>strongly connected</i> if there exists a directed path between each pair of nodes.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given directed graph
 * @return {boolean} <code>true</code> if the graph is strongly connected, <code>false</code>, otherwise
 */
yfiles.algorithms.GraphChecker.isStronglyConnected = function(graph) {};

/**
 * Checks whether or not the given graph is an undirected tree.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the graph is an undirected tree, <code>false</code> otherwise
 */
yfiles.algorithms.GraphChecker.isTree = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.GraphConnectivity = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.GraphConnectivity.$class;

/**
 * Calculates the biconnected components and the articulation points of a given undirected graph and returns the number of
 * biconnected components.
 * <p>
 * Articulation points are returned in the form of a {\@link yfiles.algorithms.INodeMap} that returns for each node a boolean value
 * indicating whether or not it is an articulation point.
 * </p>
 * @see yfiles.algorithms.GraphConnectivity#biconnectedComponents
 * @see yfiles.algorithms.GraphConnectivity#biconnectedComponents
 * Calculates the biconnected components of a given undirected graph.
 * <p>
 * The result is returned as an array of
 * {\@link yfiles.algorithms.EdgeList}s each containing all edges that belong to the same biconnected component.
 * </p>
 * @see yfiles.algorithms.GraphConnectivity#biconnectedComponents
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?=} compNum the {\@link } that will be filled during the execution and returns the zero-based index of the
 * biconnected component to which each edge belongs or <code>-1</code> for self-loops
 * @param {?=} aPoint
 * @return {number|!Array<!yfiles.algorithms.EdgeList>} the number of biconnected components / an array of {\@link }s each containing all edges that belong to the same biconnected component
 */
yfiles.algorithms.GraphConnectivity.biconnectedComponents = function(graph, compNum, aPoint) {};

/**
 * Calculates the connected components of a given graph and returns their number.
 * <p>
 * A graph <code>G</code> is called <i>connected</i> if there exists an undirected path of edges between every pair of nodes.
 * </p>
 * <p>
 * The connected components of a graph are the maximal connected subgraphs of which the graph consists.
 * </p>
 * Calculates the connected components of a given graph.
 * <p>
 * A graph <code>G</code> is called <i>connected</i> if there exists an undirected path of edges between every pair of nodes.
 * </p>
 * <p>
 * The connected components of a graph are the maximal connected subgraphs of which the graph consists.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?=} compNum the {\@link } that will be filled during the execution and returns the zero-based index of the
 * connected component to which each node belongs
 * @return {number|!Array<!yfiles.algorithms.NodeList>} the number of connected components of the given graph / an array of {\@link }s each of which contains the nodes that belong to the same connected component
 */
yfiles.algorithms.GraphConnectivity.connectedComponents = function(graph, compNum) {};

/**
 * Determines the direct or indirect neighbors of a given set of nodes.
 * <ul>
 * <li>A <i>direct</i> neighbor of a node is directly connected by an edge to that node.</li>
 * <li>An <i>indirect</i> neighbor of a node is directly connected to another direct or indirect neighbor of a node.</li>
 * </ul>
 * <p>
 * The order of the returned nodes is determined by a breadth first search. No start node will be part of the resulting
 * set.
 * </p>
 * <p>
 * To obtain the result, an integer value should be given as input that limits the distance between a start node and a
 * returned node. For all returned nodes there must be a path to a start node that has a length equal to or smaller than
 * this distance.
 * </p>
 * <p>
 * Setting the maximum distance to <code>1</code> will only yield the direct neighbors of all start nodes. On the other hand, setting
 * the maximum distance to <code>graph.N()</code> or larger will yield all neighbors of all start nodes.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph
 * @param {!yfiles.algorithms.NodeList} startNodes
 * @param {number} maxDistance
 * @return {!yfiles.algorithms.NodeList} a {\@link } that contains all direct and indirect neighbors of a node
 */
yfiles.algorithms.GraphConnectivity.getNeighbors = function(graph, startNodes, maxDistance) {};

/**
 * Determines the direct or indirect predecessors of a given list of nodes.
 * <ul>
 * <li>A <i>direct</i> predecessor of a node is the source node of an incoming edge connected to a node.</li>
 * <li>An <i>indirect</i> predecessor of a node is a direct predecessor to another predecessor of a node.</li>
 * </ul>
 * <p>
 * The order of the returned nodes is determined by a breadth first search. No start node will be part of the resulting
 * set.
 * </p>
 * <p>
 * To obtain the result, an integer value should be given as input that limits the distance between a start node and a
 * returned node. For all returned nodes there must be a path to a start node that has a length equal to or smaller than
 * this distance.
 * </p>
 * <p>
 * Setting the maximum distance to <code>1</code> will only yield the direct predecessors of all start nodes. On the other hand, setting
 * the maximum distance to <code>graph.N()</code> or larger will yield all predecessors of all start nodes.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {!yfiles.algorithms.NodeList} startNodes a {\@link } containing the nodes from which the search starts
 * @param {number} maxDistance an integer value that limits the distance between a start node and a returned node
 * @return {!yfiles.algorithms.NodeList} a {\@link } that contains all direct and indirect predecessors of a node
 */
yfiles.algorithms.GraphConnectivity.getPredecessors = function(graph, startNodes, maxDistance) {};

/**
 * Determines the direct or indirect successors of a given list of nodes.
 * <ul>
 * <li>A <i>direct</i> successor of a node is the target node of an outgoing edge connected to a node.</li>
 * <li>An <i>indirect</i> successor of a node is a direct successor to another successor of a node.</li>
 * </ul>
 * <p>
 * The order of the returned nodes is determined by a breadth first search. No start node will be part of the resulting
 * set.
 * </p>
 * <p>
 * To obtain the result, an integer value should be given as input that limits the distance between a start node and a
 * returned node. For all returned nodes there must be a path to a start node that has a length equal to or smaller than
 * this distance.
 * </p>
 * <p>
 * Setting the maximum distance to <code>1</code> will only yield the direct successors of all start nodes. On the other hand, setting
 * the maximum distance to <code>graph.N()</code> or larger will yield all successors of all start nodes.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {!yfiles.algorithms.NodeList} startNodes a {\@link } containing the nodes from which the search starts
 * @param {number} maxDistance an integer value that limits the distance between a start node and a returned node
 * @return {!yfiles.algorithms.NodeList} a {\@link } that contains all direct and indirect successors of a node
 */
yfiles.algorithms.GraphConnectivity.getSuccessors = function(graph, startNodes, maxDistance) {};

/**
 * Checks whether or not the given undirected graph is biconnected.
 * <p>
 * A graph is called <i>biconnected</i> if it has no cut vertex or articulation point, i.e., no node whose removal disconnects the graph.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given undirected graph
 * @return {boolean} <code>true</code> if the graph is biconnected, <code>false</code> otherwise
 */
yfiles.algorithms.GraphConnectivity.isBiconnected = function(graph) {};

/**
 * Checks whether or not the given graph is connected.
 * <p>
 * A graph is called <i>connected</i> if there exists an undirected path of edges between every pair of nodes.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the graph is connected, <code>false</code> otherwise
 */
yfiles.algorithms.GraphConnectivity.isConnected = function(graph) {};

/**
 * Checks whether or not the given directed graph is strongly connected.
 * <p>
 * A graph is called <i>strongly connected</i> if there exists a directed path between each pair of nodes.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given directed graph
 * @return {boolean} <code>true</code> if the graph is strongly connected, <code>false</code>, otherwise
 */
yfiles.algorithms.GraphConnectivity.isStronglyConnected = function(graph) {};

/**
 * Makes the given graph biconnected by inserting a minimum number of edges in the graph.
 * <p>
 * The given graph is considered to be undirected.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {!yfiles.algorithms.EdgeList} an {\@link } containing the edges added to the graph
 */
yfiles.algorithms.GraphConnectivity.makeBiconnected = function(graph) {};

/**
 * Makes a graph connected by adding additional edges to the graph.
 * <p>
 * The number of edges that will be added equals the number of separate components of the original graph minus <code>1</code>.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {!yfiles.algorithms.EdgeList} an {\@link } containing the edges added to the graph
 */
yfiles.algorithms.GraphConnectivity.makeConnected = function(graph) {};

/**
 * Determines the set of nodes that are reachable from a given node when a set of edges that cannot be traversed is
 * specified.
 * <p>
 * The result is based on a depth first search.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {!yfiles.algorithms.Node} start the node from which the search starts
 * @param {boolean} directed <code>true</code> if the edges should be traversed from source to target, <code>false</code> if edges can be traversed in both directions
 * @param {!Array<boolean>} reached an array that will be filled during the execution and returns for each {\@link } a {\@link } value based on whether
 * the node can be reached during the DFS; if a node <code>v</code> is reachable, then <code>reached[v.index()] = true</code>
 * @param {!Array<boolean>=} forbidden
 * @return {void}
 */
yfiles.algorithms.GraphConnectivity.reachable = function(graph, start, directed, reached, forbidden) {};

/**
 * Calculates the strongly connected components of a given graph and returns their number.
 * <p>
 * A graph is called <i>strongly connected</i> if there exists a directed path between each pair of nodes.
 * </p>
 * <p>
 * The strongly connected components of a graph are the strongly connected subgraphs of which it consists.
 * </p>
 * @see yfiles.algorithms.GraphConnectivity#stronglyConnectedComponents
 * Calculates the strongly connected components of a given graph.
 * <p>
 * A graph is called <i>strongly connected</i> if there exists a directed path between each pair of nodes.
 * </p>
 * <p>
 * The strongly connected components of a graph are the strongly connected subgraphs of which it consists.
 * </p>
 * @see yfiles.algorithms.GraphConnectivity#stronglyConnectedComponents
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?=} compNum the {\@link } that will be filled during the execution and returns the zero-based index of the
 * connected component to which each node belongs
 * @return {number|!Array<!yfiles.algorithms.NodeList>} the number of strongly connected components of the given graph / an array of
 * {\@link }s each of which contains the nodes that belong to the same strongly connected component
 */
yfiles.algorithms.GraphConnectivity.stronglyConnectedComponents = function(graph, compNum) {};

/**
 * Transforms the return values of {\@link yfiles.algorithms.GraphConnectivity#biconnectedComponents} to an array of
 * {\@link yfiles.algorithms.EdgeList}s, like it is returned by {\@link yfiles.algorithms.GraphConnectivity#biconnectedComponents}.
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} compNum the {\@link } that will be filled during the execution and returns the zero-based index of the
 * connected component to which each edge belongs
 * @param {number} maxCompNum the maximum number of biconnected components
 * @return {!Array<!yfiles.algorithms.EdgeList>} an array of {\@link }s each containing all edges that belong to the same biconnected component
 */
yfiles.algorithms.GraphConnectivity.toEdgeListArray = function(graph, compNum, maxCompNum) {};

/**
 * Transforms the return values of method {\@link yfiles.algorithms.GraphConnectivity#connectedComponents} to an array of
 * {\@link yfiles.algorithms.NodeList}s, like it is returned by {\@link yfiles.algorithms.GraphConnectivity#connectedComponents}.
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} compNum the {\@link } that will be filled during the execution and returns the zero-based index of the
 * connected component to which each node belongs
 * @param {number} maxCompNum the maximum number of connected components
 * @return {!Array<!yfiles.algorithms.NodeList>} an array of {\@link }s each of which contains the nodes that belong to the same connected component
 */
yfiles.algorithms.GraphConnectivity.toNodeListArray = function(graph, compNum, maxCompNum) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.GraphObject = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.GraphObject.$class;
/**
 * @record
 * @struct
 */
yfiles.algorithms.Dendrogram = function() {};
 /** @type {!yfiles.algorithms.Node} */
yfiles.algorithms.Dendrogram.prototype.root;
 /** @type {number} */
yfiles.algorithms.Dendrogram.prototype.nodeCount;
 /** @type {number} */
yfiles.algorithms.Dendrogram.prototype.levelCount;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Dendrogram.$class;

/**
 * Returns a {\@link yfiles.algorithms.NodeList} that contains the child nodes of the given parent node.
 * <p>
 * If the given node is a {\@link yfiles.algorithms.Dendrogram#isLeaf leaf} node, the returned list will be empty.
 * </p>
 * @param {!yfiles.algorithms.Node} parent the parent node for which to retrieve the child nodes
 * @return {!yfiles.algorithms.NodeList} the list of child nodes of the given parent node
 */
yfiles.algorithms.Dendrogram.prototype.getChildren = function(parent) {};

/**
 * Returns an array of
 * {\@link yfiles.algorithms.NodeList}s that contain the nodes of the original graph that are associated with the given dendrogram
 * node.
 * <p>
 * Each such {\@link yfiles.algorithms.NodeList} represents nodes that belong to the same cluster. For example, say that clusters <code>C1 = {v1, v2}</code>
 * and <code>C2 = {v3, v4}</code> are merged, where <code>{v1, v2, v3, v4}</code> are nodes of the original graph. Say that dendrogram node <code>u</code> is
 * created by this merging. Then, the cluster nodes of <code>u</code> will be returned as two {\@link yfiles.algorithms.NodeList}s where the
 * first contains nodes <code>v1, v2</code> and the second <code>v3, v4</code>.
 * </p>
 * @param {!yfiles.algorithms.Node} node the given dendrogram node
 * @return {!Array<!yfiles.algorithms.NodeList>} an array of
 * {\@link }s that contain the nodes of the original graph that are associated with the given dendrogram
 * node
 */
yfiles.algorithms.Dendrogram.prototype.getClusterNodes = function(node) {};

/**
 * Returns the dissimilarity value associated with the given node of the dendrogram.
 * @param {!yfiles.algorithms.Node} node the given dendrogram node
 * @return {number} the dissimilarity value associated with the given dendrogram node
 */
yfiles.algorithms.Dendrogram.prototype.getDissimilarityValue = function(node) {};

/**
 * Returns the level of the given node of the dendrogram.
 * @param {!yfiles.algorithms.Node} node the given dendrogram node
 * @return {number} the level of the given dendrogram node
 */
yfiles.algorithms.Dendrogram.prototype.getLevel = function(node) {};

/**
 * Returns the node of the dendrogram that belongs to the given level index.
 * <p>
 * If the given level index is greater than the {\@link yfiles.algorithms.Dendrogram#levelCount number of levels}, then this method will return <code>null</code>.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given level is negative or greater than the {\@link yfiles.algorithms.Dendrogram#nodeCount node count} minus one.
 * @param {number} level the given level index
 * @return {!yfiles.algorithms.Node} the node of the dendrogram that belongs to the given level index or <code>null</code> if there exists no level with the given index.
 */
yfiles.algorithms.Dendrogram.prototype.getNodeAtLevel = function(level) {};

/**
 * Returns the node of original graph that is mapped with the given leaf node of the dendrogram.
 * @param {!yfiles.algorithms.Node} node the given leaf node
 * @return {!yfiles.algorithms.Node} the node of original graph that is mapped with the given leaf node or <code>null</code> if the given node is an inner dendrogram
 * node
 */
yfiles.algorithms.Dendrogram.prototype.getOriginalNode = function(node) {};

/**
 * Returns whether or not the given dendrogram node is a leaf node.
 * <p>
 * A leaf node has no further children and represents a node of the original graph. The original node can be retrieved via
 * {\@link yfiles.algorithms.Dendrogram#getOriginalNode}.
 * </p>
 * @param {!yfiles.algorithms.Node} node a dendrogram node
 * @return {boolean} <code>true</code> if the given node is a leaf node, <code>false</code> otherwise
 */
yfiles.algorithms.Dendrogram.prototype.isLeaf = function(node) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.INodeDistanceProvider = function() {};

/**
 * Returns the distance between two given nodes of a graph.
 * <p>
 * Implementations of this method have to guarantee that the returned value is greater or equal to zero. Furthermore, the
 * distances between two nodes have to be symmetric, i.e., the distance between node <code>n1</code> and <code>n2</code> is equal to the distance
 * between node <code>n2</code> and <code>n1</code>.
 * </p>
 * @abstract
 * @param {!yfiles.algorithms.Node} n1 the first node
 * @param {!yfiles.algorithms.Node} n2 the second node
 * @return {number} the distance between the two given nodes
 */
yfiles.algorithms.INodeDistanceProvider.prototype.getDistance = function(n1, n2) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.INodeDistanceProvider;
/**
 * @record
 * @struct
 */
yfiles.algorithms.Groups = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Groups.$class;

/**
 * This method partitions the graph by analyzing its <i>biconnected components</i>.
 * <p>
 * Nodes will be grouped such that the nodes within each group are biconnected. Nodes that belong to multiple biconnected
 * components will be assigned to exactly one of these components.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} groupIDs the {\@link } that will be filled during the execution and returns an integer value (cluster ID) for
 * each node
 * @return {number} the resulting number of different groups
 */
yfiles.algorithms.Groups.biconnectedComponentGrouping = function(graph, groupIDs) {};

/**
 * Partitions the graph into groups using <i>edge betweenness clustering</i> proposed by Girvan and Newman.
 * <p>
 * In each iteration the edge with the highest betweenness centrality is removed from the graph. The method stops, if there
 * are no more edges to remove or if the requested maximum number of groups is found. The clustering with the best quality
 * reached during the process is returned.
 * </p>
 * <p>
 * The algorithm includes several heuristic speed-up techniques available through the quality/time ratio. For the highest
 * quality setting, it is used almost unmodified. The fast betweenness approximation of Brandes and Pich (<i>Centrality Estimation in Large Networks</i>) is employed for
 * values around <code>0.5</code>. Typically, this results in a tiny decrease in quality but a large speed-up and is the recommended
 * setting. To achieve the lowest running time, a local betweenness calculation is used (Gregory: <i>Local Betweenness for Finding Communities in Networks</i>).
 * </p>
 * <p>
 * The method requires the maximum number of groups that will be returned. The smaller this value is, the faster the
 * overall computation time. The upper bound on the number of groups is
 * <code>graph.N()</code>. Also, the number of returned groups is never smaller than the number of connected components of the graph.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if <code>minGroupCount > maxGroupCount</code> or <code>minGroupCount > graph.N()</code> or <code>maxGroupCount &lt;= 0</code>
 * Partitions the graph into groups using <i>edge betweenness centrality</i>.
 * <p>
 * In each iteration the edge with the highest betweenness centrality is removed from the graph. The method stops, if there
 * are no more edges to remove. The clustering with the best quality reached during the process will be returned.
 * </p>
 * <p>
 * The method requires the maximum number of groups that will be returned. The smaller this value is, the faster the
 * overall computation time. The upper bound on the number of groups is
 * <code>graph.N()</code>. Also, the number of returned groups is never smaller than the number of connected components of the graph.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if <code>minGroupCount > maxGroupCount</code> or <code>minGroupCount > graph.N()</code> or <code>maxGroupCount &lt;= 0</code>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} clusterIDs the {\@link } that will be filled during the execution and returns an integer value (cluster ID) for
 * each node
 * @param {number|boolean} qualityTimeRatio_or_directed a value between <code>0.0</code> (low quality, fast) and <code>1.0</code> (high quality, slow); the recommended value is <code>0.5</code> / <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {number} minGroupCount the minimum number of groups that will be returned
 * @param {number} maxGroupCount the maximum number of groups that will be returned
 * @param {boolean|?} refine_or_edgeCosts <code>true</code> if the algorithm refines the current grouping, <code>false</code> if the algorithm discards the current grouping / the {\@link } that holds a positive {\@link } cost or <code>null</code> if the edges of the graph are considered to be
 * of equal cost
 * @return {number} the resulting number of different groups
 */
yfiles.algorithms.Groups.edgeBetweennessClustering = function(graph, clusterIDs, qualityTimeRatio_or_directed, minGroupCount, maxGroupCount, refine_or_edgeCosts) {};

/**
 * Partitions the graph into clusters based on hierarchical clustering, while the dendrogram is cut based on a given
 * maximum number of clusters.
 * <p>
 * The clustering is performed using the agglomerative strategy i.e., a bottom-up approach according to which at the
 * beginning each node belongs to its own cluster. At each step pairs of clusters are merged while moving up to the
 * hierarchy. The dissimilarity between clusters is determined based on the given linkage and the given node distances. The
 * algorithm continues until all nodes belong to the same cluster.
 * </p>
 * <p>
 * The result will be given based on the given maximum number of clusters value that is used for cutting the hierarchical
 * tree at a point such that the number of remaining clusters equals to this value.
 * </p>
 * <p>
 * The maximum number of clusters needs to be greater than zero and less than the number of the nodes of the graph.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if an unknown linkage is given or if the maximum number of clusters is less than or equal to zero or greater than the
 * number of nodes of the graph
 * Partitions the graph into clusters based on hierarchical clustering, while the dendrogram is cut based on a given
 * cut-off value.
 * <p>
 * The clustering is performed using the agglomerative strategy i.e., a bottom-up approach according to which at the
 * beginning each node belongs to its own cluster. At each step pairs of clusters are merged while moving up to the
 * hierarchy. The dissimilarity between clusters is determined based on the given linkage and the given node distances. The
 * algorithm continues until all nodes belong to the same cluster.
 * </p>
 * <p>
 * The result will be given based on the given cut-off value that is used for cutting the hierarchical tree at a point such
 * that the dissimilarity values of the nodes that remain at the dendrogram are less than this value.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if an unknown linkage is used
 * Partitions the graph into clusters based on hierarchical clustering.
 * <p>
 * The clustering is performed using the agglomerative strategy i.e., a bottom-up approach according to which at the
 * beginning each node belongs to its own cluster. At each step pairs of clusters are merged while moving up to the
 * hierarchy. The dissimilarity between clusters is determined based on the given linkage and the given node distances
 * metric. The algorithm continues until all nodes belong to the same cluster.
 * </p>
 * <p>
 * The result is returned as a {\@link yfiles.algorithms.Dendrogram} object which represents the result of the clustering algorithm
 * as a binary tree structure. It can easily be traversed by starting from the {\@link yfiles.algorithms.Dendrogram#root root node} and moving on to nodes of the next
 * level via method {\@link yfiles.algorithms.Dendrogram#getChildren}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if an unknown linkage is given
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {number|?} maxCluster_or_clusterIDs_or_distances the maximum number of clusters that determines where to cut the hierarchic tree into clusters / the {\@link } that will be filled during the execution and returns an integer value (cluster ID) for
 * each node / a given {\@link } object that determines the distance between any two nodes
 * @param {?|yfiles.algorithms.Linkage} clusterIDs_or_distances_or_linkage the {\@link } that will be filled during the execution and returns an integer value (cluster ID) for
 * each node / a given {\@link } object that determines the distance between any two nodes / one of the predefined linkage values
 * @param {?|yfiles.algorithms.Linkage=} distances_or_linkage a given {\@link } object that determines the distance between any two graph nodes / one of the predefined linkage values
 * @param {yfiles.algorithms.Linkage|number=} linkage_or_cutOff one of the predefined linkage values / the cut-off value that determines where to cut the hierarchic tree into clusters
 * @return {number|!yfiles.algorithms.Dendrogram} the resulting number of clusters / a {\@link } which represents the result of the clustering as a binary tree
 */
yfiles.algorithms.Groups.hierarchicalClustering = function(graph, maxCluster_or_clusterIDs_or_distances, clusterIDs_or_distances_or_linkage, distances_or_linkage, linkage_or_cutOff) {};

/**
 * Partitions the graph into clusters using k-means clustering algorithm.
 * <p>
 * The nodes of the graph will be partitioned in <code>k</code> clusters based on their positions such that their distance from the
 * cluster's mean (centroid) is minimized.
 * </p>
 * <p>
 * The distance can be defined using diverse metrics as euclidean distance, euclidean-squared distance, manhattan distance
 * or chebychev distance.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given distance metric is not supported
 * Partitions the graph into clusters using k-means clustering algorithm.
 * <p>
 * The nodes of the graph will be partitioned in <code>k</code> clusters based on their positions such that their distance from the
 * cluster's mean (centroid) is minimized.
 * </p>
 * <p>
 * The distance can be defined using diverse metrics as euclidean distance, euclidean-squared distance, manhattan distance
 * or chebychev distance.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given distance metric is not supported
 * @param {!yfiles.algorithms.Graph|{graph: !yfiles.algorithms.Graph, clusterIDs: ?, nodePositions: ?, distanceMetric: yfiles.algorithms.DistanceMetric, k: number, iterations: number, centroids: !Array<!yfiles.algorithms.YPoint>}} graph_or_options the input graph
 * @param {?=} clusterIDs the {\@link } that will be filled during the execution and returns an integer value (cluster ID) for
 * each node
 * @param {?=} nodePositions the {\@link } that holds a {\@link  point} representing the current position of each node in the graph
 * @param {yfiles.algorithms.DistanceMetric=} distanceMetric one of the predefined distance metrics
 * @param {number=} k the number of clusters
 * @param {number=} iterations
 * @param {!Array<!yfiles.algorithms.YPoint>=} centroids
 * @return {number} the number of resulting (non-empty) clusters
 */
yfiles.algorithms.Groups.kMeansClustering = function(graph_or_options, clusterIDs, nodePositions, distanceMetric, k, iterations, centroids) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.ICursor = function() {};
 /** @type {boolean} */
yfiles.algorithms.ICursor.prototype.ok;
 /** @type {!Object} */
yfiles.algorithms.ICursor.prototype.current;
 /** @type {number} */
yfiles.algorithms.ICursor.prototype.size;

/**
 * Moves this cursor one position forward.
 * @abstract
 * @return {void}
 */
yfiles.algorithms.ICursor.prototype.next = function() {};

/**
 * Moves this cursor one position backward (optional).
 * @abstract
 * @return {void}
 */
yfiles.algorithms.ICursor.prototype.prev = function() {};

/**
 * Moves this cursor to the first valid cursor position (optional).
 * @abstract
 * @return {void}
 */
yfiles.algorithms.ICursor.prototype.toFirst = function() {};

/**
 * Moves this cursor to the last valid cursor position (optional).
 * @abstract
 * @return {void}
 */
yfiles.algorithms.ICursor.prototype.toLast = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.ICursor;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IDataAcceptor = function() {};

/**
 * Sets an object value associated with the given data holder.
 * <p>
 * This method may throw an UnsupportedOperationException.
 * </p>
 * @abstract
 * @param {!Object} dataHolder
 * @param {!Object} value
 * @return {void}
 */
yfiles.algorithms.IDataAcceptor.prototype.set = function(dataHolder, value) {};

/**
 * Sets a boolean value associated with the given data holder.
 * <p>
 * This method may throw an UnsupportedOperationException.
 * </p>
 * @abstract
 * @param {!Object} dataHolder
 * @param {boolean} value
 * @return {void}
 */
yfiles.algorithms.IDataAcceptor.prototype.setBoolean = function(dataHolder, value) {};

/**
 * Sets an integer value associated with the given data holder.
 * <p>
 * This method may throw an UnsupportedOperationException.
 * </p>
 * @abstract
 * @param {!Object} dataHolder
 * @param {number} value
 * @return {void}
 */
yfiles.algorithms.IDataAcceptor.prototype.setInt = function(dataHolder, value) {};

/**
 * Sets a double value associated with the given data holder.
 * <p>
 * This method may throw an UnsupportedOperationException.
 * </p>
 * @abstract
 * @param {!Object} dataHolder
 * @param {number} value
 * @return {void}
 */
yfiles.algorithms.IDataAcceptor.prototype.setNumber = function(dataHolder, value) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.IDataAcceptor;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IDataMap = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.IDataMap;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IDataProvider = function() {};

/**
 * Returns an object value associated with the given data holder.
 * <p>
 * This method may throw an UnsupportedOperationException.
 * </p>
 * @abstract
 * @param {!Object} dataHolder
 * @return {!Object}
 */
yfiles.algorithms.IDataProvider.prototype.get = function(dataHolder) {};

/**
 * Returns a boolean value associated with the given data holder.
 * <p>
 * This method may throw an UnsupportedOperationException.
 * </p>
 * @abstract
 * @param {!Object} dataHolder
 * @return {boolean}
 */
yfiles.algorithms.IDataProvider.prototype.getBoolean = function(dataHolder) {};

/**
 * Returns an integer value associated with the given data holder.
 * <p>
 * This method may throw an UnsupportedOperationException.
 * </p>
 * @abstract
 * @param {!Object} dataHolder
 * @return {number}
 */
yfiles.algorithms.IDataProvider.prototype.getInt = function(dataHolder) {};

/**
 * Returns a double value associated with the given data holder.
 * <p>
 * This method may throw an UnsupportedOperationException.
 * </p>
 * @abstract
 * @param {!Object} dataHolder
 * @return {number}
 */
yfiles.algorithms.IDataProvider.prototype.getNumber = function(dataHolder) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.IDataProvider;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IEdgeCursor = function() {};
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.IEdgeCursor.prototype.edge;

/**
 * Moves the cursor to the cyclic next element of the underlying sequence.
 * <p>
 * This is the next element if available, else it is the first element.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.algorithms.IEdgeCursor.prototype.cyclicNext = function() {};

/**
 * Moves the cursor to the cyclic previous element of the underlying sequence.
 * <p>
 * This is the previous element if available, else it is the last element.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.algorithms.IEdgeCursor.prototype.cyclicPrev = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.IEdgeCursor;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IEdgeMap = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.IEdgeMap;
/**
 * @record
 * @struct
 */
yfiles.algorithms.INodeCursor = function() {};
 /** @type {!yfiles.algorithms.Node} */
yfiles.algorithms.INodeCursor.prototype.node;

/**
 * Moves the cursor to the cyclic next element of the underlying sequence.
 * <p>
 * This is the next element if available, else it is the first element.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.algorithms.INodeCursor.prototype.cyclicNext = function() {};

/**
 * Moves the cursor to the cyclic previous element of the underlying sequence.
 * <p>
 * This is the previous element if available, else it is the last element.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.algorithms.INodeCursor.prototype.cyclicPrev = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.INodeCursor;
/**
 * @record
 * @struct
 */
yfiles.algorithms.INodeMap = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.INodeMap;
/**
 * @record
 * @struct
 */
yfiles.algorithms.INodeSequencer = function() {};

/**
 * Returns a cursor that grants access to <b>all</b> nodes of the given graph in some order.
 * @abstract
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {?} a {\@link } that grants access to all nodes of a graph
 */
yfiles.algorithms.INodeSequencer.prototype.nodes = function(graph) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.algorithms.INodeSequencer;
/**
 * @record
 * @struct
 */
yfiles.algorithms.IndependentSets = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.IndependentSets.$class;

/**
 * Calculates an independent set for a given graph.
 * <p>
 * A greedy heuristic is applied which tries to find a large independent set.
 * </p>
 * @see yfiles.algorithms.IndependentSets#getIndependentSet
 * @param {!yfiles.algorithms.Graph} conflictGraph the input graph
 * @return {!yfiles.algorithms.NodeList} a {\@link } containing an independent set of nodes
 */
yfiles.algorithms.IndependentSets.getIndependentSet = function(conflictGraph) {};

/**
 * Partitions the set of nodes of the given graph into independent sets.
 * <p>
 * The method iteratively calls method {\@link yfiles.algorithms.IndependentSets#getIndependentSet}.
 * </p>
 * @see yfiles.algorithms.IndependentSets#getIndependentSet
 * @param {!yfiles.algorithms.Graph} conflictGraph the input graph
 * @return {!Array<!yfiles.algorithms.NodeList>} an array of {\@link }s each of which contains an independent set of nodes
 */
yfiles.algorithms.IndependentSets.getIndependentSets = function(conflictGraph) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.ListCell = function() {};
 /** @type {!Object} */
yfiles.algorithms.ListCell.prototype.info;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.ListCell.$class;

/**
 * Returns the predecessor cell of this cell.
 * <p>
 * If there is no predecessor, then <code>null</code> is returned.
 * </p>
 * @return {!yfiles.algorithms.ListCell}
 */
yfiles.algorithms.ListCell.prototype.pred = function() {};

/**
 * Returns the successor cell of this cell.
 * <p>
 * If there is no successor, then <code>null</code> is returned.
 * </p>
 * @return {!yfiles.algorithms.ListCell}
 */
yfiles.algorithms.ListCell.prototype.succ = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.NetworkFlows = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.NetworkFlows.$class;

/**
 * Solves a maximum flow problem using the preflow-push method.
 * <p>
 * The implementation is based on
 * </p>
 * <ul>
 * <li>Mehlhorn, Naeher: <i>LEDA: a platform for combinatorial and geometric computing</i>, Cambridge University Press, 2000, pp. 443-488.</li>
 * </ul>
 * <p>
 * The worst case running time is <code>O(mdeg * n^2 * m^(1/2))</code>, where <code>n</code> is the number of nodes in the network, <code>m</code> the number of
 * edges and <code>mdeg</code> the maximal degree of any node.
 * </p>
 * <p>
 * Edges may have infinite capacity, which is denoted by the value <code>0x7FFFFFFF</code>.
 * </p>
 * @see yfiles.algorithms.NetworkFlows#calcMaxFlowMinCut
 * @param {!yfiles.algorithms.Graph} graph the given network
 * @param {!yfiles.algorithms.Node} source the source node of the network
 * @param {!yfiles.algorithms.Node} sink the sink node of the network
 * @param {?} eCapDP the {\@link } that returns the integer capacity of each edge or <code>null</code> if no bound is specified
 * @param {?} flowEM the {\@link } that will be filled during the execution with an integer flow for each edge
 * @return {number} the maximum flow value
 */
yfiles.algorithms.NetworkFlows.calcMaxFlow = function(graph, source, sink, eCapDP, flowEM) {};

/**
 * Solves a maximum flow problem using the preflow-push method but additionally marks all nodes that belong to the minimum
 * cut set that is associated with the source of the network.
 * @see yfiles.algorithms.NetworkFlows#calcMaxFlow
 * @param {!yfiles.algorithms.Graph} graph the given network
 * @param {!yfiles.algorithms.Node} source the source node of the network
 * @param {!yfiles.algorithms.Node} sink the sink node of the network
 * @param {?} eCapDP the {\@link } that returns the integer capacity of each edge or <code>null</code> if no bound is specified
 * @param {?} flowEM the {\@link } that will be filled during the execution with an integer flow for each edge
 * @param {?} sourceCutNM the {\@link } that will be filled during the execution and returns a boolean value indicating whether
 * or not a node belongs to the cut set associated with the source of the network
 * @return {number} the maximum flow value
 */
yfiles.algorithms.NetworkFlows.calcMaxFlowMinCut = function(graph, source, sink, eCapDP, flowEM, sourceCutNM) {};

/**
 * Solves a minimum cost maximum flow problem.
 * @see yfiles.algorithms.NetworkFlows#minCostFlow
 * @see yfiles.algorithms.NetworkFlows#minCostFlow
 * Solves a minimum cost flow problem with a capacity scaling algorithm.
 * <p>
 * This algorithm is a variant of the successive shortest path algorithm (see Ahuja,Magnanti,Orlin: <i>Network flows</i>, Prentice Hall, 1993,
 * pp.320-324). It has the pseudo-polynomial running time <code>O(m*log U*(m+n log n))</code> where <code>n</code> is the number of nodes in the
 * network, <code>m</code> the number of edges and <code>U</code> the maximal edge capacity.
 * </p>
 * <p>
 * Edges may have infinite capacity, which is denoted by the value <code>0x7FFFFFFF</code>.
 * </p>
 * <p>
 * There are no restriction for the costs. In particular, they can also be negative.
 * </p>
 * @see yfiles.algorithms.NetworkFlows#minCostFlow
 * @see yfiles.algorithms.NetworkFlows#minCostFlow
 * Uses method {\@link yfiles.algorithms.NetworkFlows#minCostFlow} to solve a minimum cost flow problem.
 * @see yfiles.algorithms.NetworkFlows#minCostFlow
 * @see yfiles.algorithms.NetworkFlows#minCostFlow
 * @param {!yfiles.algorithms.Graph} graph the given network
 * @param {!yfiles.algorithms.Node|?} s_or_lCapDP_or_uCapDP the source node of the network / the {\@link } that returns the integer lower bound for the capacity of each edge or <code>null</code> if no
 * bound is specified / the {\@link } that returns the integer capacity of each edge or <code>null</code> if no bound is specified
 * @param {!yfiles.algorithms.Node|?} t_or_uCapDP_or_cost0DP the sink node of the network / the {\@link } that returns the integer upper bound for the capacity of each edge or <code>null</code> if no
 * bound is specified / the {\@link } that returns a double value (cost) for each edge
 * @param {?} uCapDP_or_cost0DP_or_supplyDP the {\@link } that returns the integer capacity of each edge or <code>null</code> if no bound is specified / the {\@link } that returns a double value (cost) of each edge / the {\@link } that returns the supply/demand of each node; supply is denoted by a positive value,
 * demand by a negative value
 * @param {?} cost0DP_or_supplyDP_or_flowEM the {\@link } that returns a double value (cost) for each edge / the {\@link } that returns the supply/demand of each node; supply is denoted by a positive value,
 * demand by a negative value / the {\@link } that will be filled during the execution with an integer flow for each edge
 * @param {?} flowEM_or_dualsNM the {\@link } that will be filled during the execution with an integer flow for each edge / the {\@link } that will be filled during the execution with an integer value (dual value) for each node
 * or <code>null</code> if no such values occur; dual values are also referred as potentials
 * @param {?=} dualsNM the {\@link } that will be filled during the execution with an integer value (dual value) for each node
 * or <code>null</code> if no such values occur; dual values are also referred as potentials
 * @return {number} the total cost of the flow
 */
yfiles.algorithms.NetworkFlows.minCostFlow = function(graph, s_or_lCapDP_or_uCapDP, t_or_uCapDP_or_cost0DP, uCapDP_or_cost0DP_or_supplyDP, cost0DP_or_supplyDP_or_flowEM, flowEM_or_dualsNM, dualsNM) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Node = function() {};
 /** @type {number} */
yfiles.algorithms.Node.prototype.degree;
 /** @type {number} */
yfiles.algorithms.Node.prototype.inDegree;
 /** @type {number} */
yfiles.algorithms.Node.prototype.outDegree;
 /** @type {number} */
yfiles.algorithms.Node.prototype.index;
 /** @type {!yfiles.algorithms.Graph} */
yfiles.algorithms.Node.prototype.graph;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Node.prototype.firstOutEdge;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Node.prototype.firstInEdge;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Node.prototype.lastOutEdge;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.algorithms.Node.prototype.lastInEdge;
 /** @type {?<!yfiles.algorithms.Edge>} */
yfiles.algorithms.Node.prototype.outEdges;
 /** @type {?<!yfiles.algorithms.Edge>} */
yfiles.algorithms.Node.prototype.inEdges;
 /** @type {?<!yfiles.algorithms.Edge>} */
yfiles.algorithms.Node.prototype.edges;
 /** @type {?<!yfiles.algorithms.Node>} */
yfiles.algorithms.Node.prototype.successors;
 /** @type {?<!yfiles.algorithms.Node>} */
yfiles.algorithms.Node.prototype.predecessors;
 /** @type {?<!yfiles.algorithms.Node>} */
yfiles.algorithms.Node.prototype.neighbors;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Node.$class;

/**
 * Creates a copy of this node that will be inserted into the given graph.
 * @param {!yfiles.algorithms.Graph} g The graph that the created node will belong to.
 * @return {!yfiles.algorithms.Node} The newly created Node object.
 */
yfiles.algorithms.Node.prototype.createCopy = function(g) {};

/**
 * Returns an edge that connects this node with the given node, if such an edge exists.
 * <p>
 * Otherwise <code>null</code> is returned.
 * </p>
 * <p>
 * Note that the first matching edge is returned, and that outgoing edges are tested prior to incoming edges.
 * </p>
 * @see yfiles.algorithms.Node#getEdgeFrom
 * @see yfiles.algorithms.Node#getEdgeTo
 * @param {!yfiles.algorithms.Node} opposite
 * @return {!yfiles.algorithms.Edge}
 */
yfiles.algorithms.Node.prototype.getEdge = function(opposite) {};

/**
 * Returns an edge cursor for all incoming and outgoing edges at this node.
 * @see yfiles.algorithms.Node#getInEdgeCursor
 * @see yfiles.algorithms.Node#getOutEdgeCursor
 * @return {?}
 */
yfiles.algorithms.Node.prototype.getEdgeCursor = function() {};

/**
 * Returns an incoming edge that connects the given node with this node, if such an edge exists.
 * <p>
 * Otherwise <code>null</code> is returned.
 * </p>
 * @see yfiles.algorithms.Node#getEdge
 * @see yfiles.algorithms.Node#getEdgeTo
 * @param {!yfiles.algorithms.Node} source
 * @return {!yfiles.algorithms.Edge}
 */
yfiles.algorithms.Node.prototype.getEdgeFrom = function(source) {};

/**
 * Returns an outgoing edge that connects this node with the given node, if such an edge exists.
 * <p>
 * Otherwise <code>null</code> is returned.
 * </p>
 * @see yfiles.algorithms.Node#getEdge
 * @see yfiles.algorithms.Node#getEdgeFrom
 * @param {!yfiles.algorithms.Node} target
 * @return {!yfiles.algorithms.Edge}
 */
yfiles.algorithms.Node.prototype.getEdgeTo = function(target) {};

/**
 * Returns an edge cursor for incoming edges at this node.
 * <p>
 * If an edge is specified, the cursor starts at the given edge, and the cyclic sequence order is the same as returned by
 * {\@link yfiles.algorithms.Node#getInEdgeCursor}.
 * </p>
 * @see yfiles.algorithms.Node#getOutEdgeCursor
 * @param {!yfiles.algorithms.Edge=} startEdge
 * @return {?}
 */
yfiles.algorithms.Node.prototype.getInEdgeCursor = function(startEdge) {};

/**
 * Returns a node cursor for all neighbor nodes of this node.
 * <p>
 * Neighbor nodes are those at the opposite ends of both incoming and outgoing edges.
 * </p>
 * @see yfiles.algorithms.Node#getPredecessorCursor
 * @see yfiles.algorithms.Node#getSuccessorCursor
 * @return {?}
 */
yfiles.algorithms.Node.prototype.getNeighborCursor = function() {};

/**
 * Returns an edge cursor for outgoing edges at this node.
 * <p>
 * If an edge is specified, the cursor starts at the given edge, and the cyclic sequence order is the same as returned by
 * {\@link yfiles.algorithms.Node#getOutEdgeCursor}.
 * </p>
 * @see yfiles.algorithms.Node#getInEdgeCursor
 * @param {!yfiles.algorithms.Edge=} startEdge
 * @return {?}
 */
yfiles.algorithms.Node.prototype.getOutEdgeCursor = function(startEdge) {};

/**
 * Returns a node cursor for all predecessor nodes of this node.
 * <p>
 * Predecessor nodes are those at the opposite ends of incoming edges.
 * </p>
 * @see yfiles.algorithms.Node#getSuccessorCursor
 * @return {?}
 */
yfiles.algorithms.Node.prototype.getPredecessorCursor = function() {};

/**
 * Returns a node cursor for all successor nodes of this node.
 * <p>
 * Successor nodes are those at the opposite ends of outgoing edges.
 * </p>
 * @see yfiles.algorithms.Node#getPredecessorCursor
 * @return {?}
 */
yfiles.algorithms.Node.prototype.getSuccessorCursor = function() {};

/**
 * Sorts incoming edges at this node according to the given comparator.
 * @see yfiles.algorithms.Node#sortOutEdges
 * @param {?<!Object>} c
 * @return {void}
 */
yfiles.algorithms.Node.prototype.sortInEdges = function(c) {};

/**
 * Sorts outgoing edges at this node according to the given comparator.
 * @see yfiles.algorithms.Node#sortInEdges
 * @param {?<!Object>} c
 * @return {void}
 */
yfiles.algorithms.Node.prototype.sortOutEdges = function(c) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.NodeList = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.NodeList.$class;

/**
 * Returns the first node in this list, or <code>null</code> when the list is empty.
 * @return {!yfiles.algorithms.Node} The first node in the list.
 */
yfiles.algorithms.NodeList.prototype.firstNode = function() {};

/**
 * Returns an enumerator for this collection.
 * @return {?<!yfiles.algorithms.Node>}
 */
yfiles.algorithms.NodeList.prototype.getEnumerator = function() {};

/**
 * Returns the last node in this list, or <code>null</code> when the list is empty.
 * @return {!yfiles.algorithms.Node} The last node in the list.
 */
yfiles.algorithms.NodeList.prototype.lastNode = function() {};

/**
 * Returns a node cursor for this node list.
 * @return {?} A node cursor granting access to the nodes within this list.
 */
yfiles.algorithms.NodeList.prototype.nodes = function() {};

/**
 * Removes the first node from this list and returns it.
 * @return {!yfiles.algorithms.Node} The first node from the list.
 */
yfiles.algorithms.NodeList.prototype.popNode = function() {};

/**
 * Returns a node array containing all elements of this list in the canonical order.
 * @return {!Array<!yfiles.algorithms.Node>}
 */
yfiles.algorithms.NodeList.prototype.toNodeArray = function() {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.NodeOrders = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.NodeOrders.$class;

/**
 * Calculates an ordering of the nodes identical to the order of node completion events in a depth first search.
 * <p>
 * This ordering is a reversed topological ordering in case the input graph is acyclic.
 * </p>
 * @see yfiles.algorithms.NodeOrders#topological
 * @see yfiles.algorithms.NodeOrders#dfsCompletion
 * Calculates an ordering of the nodes identical to the order of node completion events in a depth first search.
 * <p>
 * Like {\@link yfiles.algorithms.NodeOrders#dfsCompletion} but the result is returned as a {\@link yfiles.algorithms.NodeList}.
 * </p>
 * <p>
 * This ordering is a reversed topological ordering in case the input graph is acyclic.
 * </p>
 * @see yfiles.algorithms.NodeOrders#topological
 * @see yfiles.algorithms.NodeOrders#dfsCompletion
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!Array<number>=} order an array of {\@link }s that returns for each {\@link } <code>v</code>, its zero-based index within the calculated ordering, i.e.,
 * <code>order[v.index()] == 5</code> means that <code>v</code> is the <code>6</code>-th node within the ordering
 * @return {void|!yfiles.algorithms.NodeList} a {\@link } containing the nodes of the graph in the order identical to the order of node completion
 * events in a depth first search
 */
yfiles.algorithms.NodeOrders.dfsCompletion = function(graph, order) {};

/**
 * Assigns an <code>st</code>-ordering to the nodes of a biconnected graph given the edge between source node <code>s</code> and sink node <code>t</code>.
 * <p>
 * An <b><code>st</code>-ordering</b> <code>(v_1,v_2,....,v_n)</code> of a biconnected graph is a node ordering which guarantees that:
 * </p>
 * <ul>
 * <li>Source node <code>s</code> and sink node <code>t</code> are connected by an edge.</li>
 * <li>For each node <code>v_i</code> in the ordering other than <code>s</code> or <code>t</code>, there are neighbors <code>v_j</code> and <code>v_k</code> with <code>j &lt; i</code> and <code>k > i</code>.</li>
 * </ul>
 * @see yfiles.algorithms.NodeOrders#st
 * @see yfiles.algorithms.NodeOrders#st
 * Assigns an <code>st</code>-ordering to the nodes of a biconnected graph.
 * <p>
 * Like {\@link yfiles.algorithms.NodeOrders#st} but the result is returned as a {\@link yfiles.algorithms.NodeList}.
 * </p>
 * <p>
 * An <b><code>st</code>-ordering</b> <code>(v_1,v_2,....,v_n)</code> of a biconnected graph is a node ordering which guarantees that:
 * </p>
 * <ul>
 * <li>Source node <code>s</code> and sink node <code>t</code> are connected by an edge.</li>
 * <li>For each node <code>v_i</code> in the ordering other than <code>s</code> or <code>t</code>, there are neighbors <code>v_j</code> and <code>v_k</code> with <code>j &lt; i</code> and <code>k > i</code>.</li>
 * </ul>
 * @see yfiles.algorithms.NodeOrders#st
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!Array<number>=} stOrder an array of {\@link }s that will be filled during the execution and returns for each {\@link } <code>v</code>, its zero-based
 * index within the calculated ordering, i.e., <code>stOrder[v.index()] == 5</code> means that <code>v</code> is the <code>6</code>-th node within the ordering
 * @param {!yfiles.algorithms.Edge=} stEdge
 * @return {void|!yfiles.algorithms.NodeList} a {\@link } containing the nodes of the graph in the order defined by the <code>st</code>-ordering
 */
yfiles.algorithms.NodeOrders.st = function(graph, stOrder, stEdge) {};

/**
 * Converts an array-based result returned by a method of this class to a {\@link yfiles.algorithms.NodeList} that contains all
 * nodes in the order provided by the given array.
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!Array<number>} order an array of {\@link }s that will be filled during the execution and returns for each {\@link } <code>v</code>, its zero-based
 * index within the calculated ordering, i.e., <code>order[v.index()] == 5</code> means that <code>v</code> is the <code>6</code>-th node within the ordering
 * @return {!yfiles.algorithms.NodeList} a {\@link } containing the nodes of the graph in the order provided by the given array
 */
yfiles.algorithms.NodeOrders.toNodeList = function(graph, order) {};

/**
 * Copies an array-based result returned by a method of this class to a {\@link yfiles.algorithms.INodeMap} that will provide values
 * of basic type <code>int</code>.
 * Copies a {\@link yfiles.algorithms.NodeList}-based result returned by a method of this class to a {\@link yfiles.algorithms.INodeMap} that
 * will provide values of basic type <code>int</code>.
 * @param {!yfiles.algorithms.Graph|!yfiles.algorithms.NodeList} graph_or_order the input graph / a {\@link } containing the nodes of the graph in the appropriate order
 * @param {!Array<number>|?} order_or_result an array of {\@link }s that returns for each {\@link } <code>v</code>, its zero-based index within the calculated ordering, i.e.,
 * <code>order[v.index()] == 5</code> means that <code>v</code> is the <code>6</code>-th node within the ordering / the {\@link } that will be filled during the execution with the zero-based index of each node within
 * the calculated ordering
 * @param {?=} result the {\@link } that will be filled during the execution with the zero-based index of each node within
 * the calculated ordering
 * @return {void}
 */
yfiles.algorithms.NodeOrders.toNodeMap = function(graph_or_order, order_or_result, result) {};

/**
 * Assigns a topological ordering to the nodes of a directed acyclic graph.
 * <p>
 * A topological ordering of the nodes of a directed graph is a linear ordering of the nodes such that for each directed
 * edge <code>(u,v)</code>, node <code>u</code> lies before <code>v</code> in the ordering.
 * </p>
 * @see yfiles.algorithms.NodeOrders#topological
 * Returns a topological ordering of the nodes of a directed acyclic graph.
 * @throws {Stubs.Exceptions.ArgumentError} if the graph is cyclic
 * @see yfiles.algorithms.NodeOrders#topological
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!Array<number>=} order an array of {\@link }s that will be filled during the execution and returns for each {\@link } <code>v</code>, its zero-based
 * index within the calculated ordering, i.e., <code>order[v.index()] == 5</code> means that <code>v</code> is the <code>6</code>-th node within the ordering
 * @return {boolean|!yfiles.algorithms.NodeList} <code>true</code> if the graph is acyclic, <code>false</code> otherwise / a {\@link } containing the nodes of the graph in the order they appear in the topological ordering
 */
yfiles.algorithms.NodeOrders.topological = function(graph, order) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Paths = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Paths.$class;

/**
 * Constructs a {\@link yfiles.algorithms.NodeList path of nodes} from a given {\@link yfiles.algorithms.EdgeList path of edges}.
 * <p>
 * The returned node path has length <code>path.size()+1</code>, if the given path is not empty. Otherwise, the returned path will be
 * empty. The <code>i</code>-th node in the returned path will be either source or target node of the <code>i</code>-th edge in the given path.
 * </p>
 * @param {!yfiles.algorithms.EdgeList} path the given {\@link  path of edges}
 * @return {!yfiles.algorithms.NodeList} a {\@link  path of nodes} from the given {\@link  path of edges}
 */
yfiles.algorithms.Paths.constructNodePath = function(path) {};

/**
 * Returns all chains present in the given graph.
 * <p>
 * A chain is a path of maximum length in which each internal node has degree <code>2</code>.
 * </p>
 * <p>
 * The internal nodes on directed chains all have in-degree <code>1</code> and out-degree <code>1</code>.
 * </p>
 * @see yfiles.algorithms.Paths#constructNodePath
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {boolean} directed <code>true</code> if the chain should be considered as directed, <code>false</code> otherwise
 * @return {!Array<!yfiles.algorithms.EdgeList>} an array of {\@link }s each of which contains the edges (at least two) that make up a chain
 */
yfiles.algorithms.Paths.findAllChains = function(graph, directed) {};

/**
 * A variant of {\@link yfiles.algorithms.Paths#findAllPaths} which returns all simple directed or undirected paths between two
 * given nodes and, additionally, allows to specify a filter for the paths to be returned.
 * Returns all simple directed or undirected paths that connect a <code>start</code> node with an <code>end</code> node.
 * Finds all edges that belong to a directed path from a <code>start</code> node to an <code>end</code> node.
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} startNode the given start node
 * @param {!yfiles.algorithms.Node} endNode the given end node
 * @param {boolean|?} directed_or_pathEdges <code>true</code> if the path should be considered as directed, <code>false</code> otherwise / the {\@link } that will be filled during the execution with a boolean value indicating whether or not
 * an edge belongs to a path connecting the two given nodes
 * @param {function(!yfiles.algorithms.EdgeList): boolean=} filter a predicate that accepts or rejects a found {\@link } and adds it to the result
 * @return {!Array<!yfiles.algorithms.EdgeList>|void} an array of {\@link }s each of which represents a path between the start and end node. / an array of {\@link }s each of which represents a path between the start and end node
 */
yfiles.algorithms.Paths.findAllPaths = function(graph, startNode, endNode, directed_or_pathEdges, filter) {};

/**
 * A variant of
 * {\@link yfiles.algorithms.Paths#findAllPaths}, which returns all simple directed or undirected paths between two given nodes as a
 * special cursor that calculates the next path in the sequence, only when needed.
 * <p>
 * The returned cursor only supports the operation {\@link yfiles.algorithms.ICursor#ok}, {\@link yfiles.algorithms.ICursor#current}, {\@link yfiles.algorithms.ICursor#size} and {\@link yfiles.algorithms.ICursor#next}.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} startNode the given start node
 * @param {!yfiles.algorithms.Node} endNode the given end node
 * @param {boolean} directed <code>true</code> if the path should be considered as directed, <code>false</code> otherwise
 * @return {?} a {\@link } that calculates the next path in the sequence
 */
yfiles.algorithms.Paths.findAllPathsCursor = function(graph, startNode, endNode, directed) {};

/**
 * Returns the longest directed path in a given acyclic weighted graph.
 * <p>
 * All edges of the graph have an integral length associated with them. The longest path is defined as one of all directed
 * paths within the graph for which the edge lengths of all contained edges sum up to a maximum.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph a directed acyclic graph
 * @param {?=} edgeLength
 * @return {!yfiles.algorithms.EdgeList} an {\@link } containing the edges of the longest directed path
 */
yfiles.algorithms.Paths.findLongestPath = function(graph, edgeLength) {};

/**
 * Calculates the longest path from a given node to all other node in a given directed acyclic graph.
 * @param {!yfiles.algorithms.Graph} graph a directed acyclic graph
 * @param {!yfiles.algorithms.Node} startNode the node for which the distances are calculated
 * @param {?} dist the {\@link } that returns the distance (i.e. weight) of type double for each edge
 * @param {?} maxDist the {\@link } that will be filled during the execution and holds the maximum distance between the given
 * node and all other nodes
 * @param {?} predicate the {\@link } that returns a boolean value indicating whether or not an edge should be considered
 * during the path search
 * @return {void}
 */
yfiles.algorithms.Paths.findLongestPaths = function(graph, startNode, dist, maxDist, predicate) {};

/**
 * Returns an {\@link yfiles.algorithms.EdgeList} containing the edges of an undirected simple path within the given graph.
 * <p>
 * The edges are returned in the order that they appear in the found path.
 * </p>
 * <p>
 * A heuristic is used for finding a path that is long. It is not guaranteed, though, that the returned path is actually
 * the longest path within the given graph, since that is a well known hard problem.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {!yfiles.algorithms.EdgeList} an {\@link } containing the edges of an undirected simple path
 */
yfiles.algorithms.Paths.findLongPath = function(graph) {};

/**
 * Returns whether or not a directed path from a start node to another node in an acyclic graph exists.
 * Returns an {\@link yfiles.algorithms.EdgeList} containing the edges of a path from the given start node to the given end node, if
 * such a path exists.
 * <p>
 * The edges are returned in the order that they appear in the found path. If the returned path is empty, no path between
 * the given nodes was found.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph an acyclic graph which contains the two nodes / the input graph
 * @param {!yfiles.algorithms.NodeList|!yfiles.algorithms.Node} topSort_or_startNode a {\@link  list} of nodes sorted in topological order / the first node of the path
 * @param {!yfiles.algorithms.Node} startNode_or_endNode the last node of the path
 * @param {!yfiles.algorithms.Node|boolean} endNode_or_directed <code>true</code> if the path should be directed, <code>false</code> otherwise
 * @param {?=} predicate the {\@link } that returns a boolean value indicating whether or not an edge should be considered
 * during the path search
 * @return {boolean|!yfiles.algorithms.EdgeList} <code>true</code> if a directed path from a start node to another node exists, <code>false</code> otherwise / an {\@link } containing the path edges between the start node and the end node
 */
yfiles.algorithms.Paths.findPath = function(graph, topSort_or_startNode, startNode_or_endNode, endNode_or_directed, predicate) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.PlanarEmbedding = function() {};
 /** @type {?<?<!yfiles.algorithms.Dart>>} */
yfiles.algorithms.PlanarEmbedding.prototype.faces;
 /** @type {?<!yfiles.algorithms.Dart>} */
yfiles.algorithms.PlanarEmbedding.prototype.outerFace;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.PlanarEmbedding.$class;

/**
 * Returns the cyclic next dart of the given dart.
 * @param {!yfiles.algorithms.Dart} dart a dart
 * @return {!yfiles.algorithms.Dart} the cyclic next dart of the given dart
 */
yfiles.algorithms.PlanarEmbedding.prototype.getCyclicNext = function(dart) {};

/**
 * Returns the cyclic previous dart of the given dart.
 * @param {!yfiles.algorithms.Dart} dart a dart
 * @return {!yfiles.algorithms.Dart} the cyclic previous dart of the given dart
 */
yfiles.algorithms.PlanarEmbedding.prototype.getCyclicPrevious = function(dart) {};

/**
 * Returns the two darts associated with the given edge.
 * @param {!yfiles.algorithms.Edge} edge an edge
 * @return {!Array<!yfiles.algorithms.Dart>} the two darts associated with the given edge
 */
yfiles.algorithms.PlanarEmbedding.prototype.getDarts = function(edge) {};

/**
 * Returns a {\@link yfiles.collections.IList.<T>} containing the (cyclic ordered) outgoing darts of the specified node.
 * @param {!yfiles.algorithms.Node} node a node
 * @return {?<!yfiles.algorithms.Dart>} a {\@link } containing the (cyclic ordered) outgoing darts
 */
yfiles.algorithms.PlanarEmbedding.prototype.getOutgoingDarts = function(node) {};

/**
 * Return whether or not the given graph is planar.
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {boolean} <code>true</code> if the given graph is planar, <code>false</code> otherwise
 */
yfiles.algorithms.PlanarEmbedding.isPlanar = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.RankAssignments = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.RankAssignments.$class;

/**
 * Like {\@link yfiles.algorithms.RankAssignments#simple}, but arrays are used instead of {\@link yfiles.algorithms.INodeMap}s and
 * {\@link yfiles.algorithms.IEdgeMap}s.
 * <p>
 * Minimum edge length and weights should be non-negative.
 * </p>
 * @see yfiles.algorithms.RankAssignments#simple
 * This method quickly calculates a tight tree given a maximum time duration for the algorithm.
 * <p>
 * The algorithm is using a highly optimized version of Gansner's algorithm:
 * </p>
 * <ul>
 * <li>E.R. Gansner et al., <i>A Technique for Drawing Directed Graphs</i>, IEEE Transactions on Software Engineering, Vol.19, No.3, March 1993.</li>
 * </ul>
 * <p>
 * Minimum edge length and weights should be non-negative.
 * </p>
 * @see yfiles.algorithms.RankAssignments#simple
 * @param {!yfiles.algorithms.Graph} graph the input graph in which all the edges have directions, such that <code>rank[source] &lt; rank[target]</code> and
 * <code>rank[target] - rank[source] >= minlength[edge]</code>
 * @param {!Array<number>|?} rank an array that will be filled with the ranking <code>r</code> of each node <code>v</code> such that <code>rank[v.index] == r</code> / the {\@link } that will be filled during the execution and returns the integer ranking of each node
 * @param {!Array<number>|?} minLength an array holding a non-negative value <code>len</code> of each edge <code>e</code> such that <code>minLength[e.index] == len</code> / the {\@link } that returns an integer value (minimum/tight length) of each edge
 * @param {number=} maximalDuration
 * @return {number} the number of layers
 */
yfiles.algorithms.RankAssignments.simple = function(graph, rank, minLength, maximalDuration) {};

/**
 * Similar to {\@link yfiles.algorithms.RankAssignments#simplex} but, additionally, it is possible to provide a valid initial tree
 * solution for the problem.
 * <p>
 * Minimum edge length and weights should be non-negative.
 * </p>
 * @see yfiles.algorithms.RankAssignments#simplex
 * @see yfiles.algorithms.RankAssignments#simplex
 * Solves the rank assignment problem using the simplex method given a maximum time duration for the algorithm.
 * <p>
 * This method assigns a minimum rank to the nodes in a acyclic graph.
 * </p>
 * <p>
 * Although its time complexity has not been proven polynomial, in practice it takes few iterations and runs quickly.
 * </p>
 * <p>
 * The algorithm is based on:
 * </p>
 * <ul>
 * <li>E.R. Gansner et al., <i>A Technique for Drawing Directed Graphs</i>, IEEE Transactions on Software Engineering, Vol.19, No.3, March 1993.</li>
 * </ul>
 * <p>
 * Minimum edge length and weights should be non-negative.
 * </p>
 * @see yfiles.algorithms.RankAssignments#simplex
 * @see yfiles.algorithms.RankAssignments#simplex
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {?} layer the {\@link } that will be filled during the execution and returns the zero-based ranking index for
 * each node
 * @param {?} w the {\@link } that returns an integer value (weight) of each edge
 * @param {?} minLength the {\@link } that returns an integer value (minimum length) of each edge
 * @param {?|number=} tree_or_maximalDuration the {\@link } that returns a boolean value indicating whether or not an edge is a tree edge
 * @param {!yfiles.algorithms.Node=} _root the given root node of the tree solution
 * @param {boolean=} validRanking <code>true</code> if the argument <code>layer</code> contains a valid ranking, <code>false</code> otherwise
 * @param {number=} maximalDuration
 * @return {number} the number of layers
 */
yfiles.algorithms.RankAssignments.simplex = function(graph, layer, w, minLength, tree_or_maximalDuration, _root, validRanking, maximalDuration) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.ShortestPaths = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.ShortestPaths.$class;

/**
 * Solves the single-source shortest path problem for <b>acyclic</b> directed graphs.
 * <p>
 * Each edge is associated with an arbitrary double value that represents the cost of that edge.
 * </p>
 * <p>
 * This method yields the shortest distance from a given node <code>s</code> to all other nodes.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#acyclic
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * Solves the single-source shortest path problem for <b>acyclic</b> directed graphs.
 * <p>
 * Each edge is associated with an arbitrary double value that represents the cost of that edge.
 * </p>
 * <p>
 * This method yields the shortest distance from a given node <code>s</code> to all other nodes.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#acyclic
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} s the node from which the shortest path search starts
 * @param {!Array<number>|?} cost an array of double values that returns the costs for traversing each edge; edge <code>e</code> has cost <code>cost[e.index()]</code> / the {\@link } that returns the double value (cost) for traversing each edge
 * @param {!Array<number>|?} dist an array of values that will be filled during the execution and returns the shortest distance from node <code>s</code> to all other
 * nodes. The distance from <code>s</code> to <code>v</code> is <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>, then
 * <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>. / the {\@link } that will be filled during the execution and returns a double value (shortest distance)
 * from node <code>s</code> to all other nodes or {\@link #POSITIVE_INFINITY} if no such paths exist
 * @param {!Array<!yfiles.algorithms.Edge>|?=} pred the {\@link } that will be filled during the execution and returns for each node <code>t</code> the last edge on the
 * shortest path from <code>s</code> to <code>t</code> or <code>null</code> if <code>t == s</code> or no shortest path from <code>s</code> to <code>t</code> exists
 * @return {boolean} <code>true</code> if the input graph is acyclic, <code>false</code> otherwise
 */
yfiles.algorithms.ShortestPaths.acyclic = function(graph, s, cost, dist, pred) {};

/**
 * This method solves the all-pairs shortest path problem for graphs with arbitrary edge costs.
 * <p>
 * If the given graph contains a negative-cost cycle, then <code>false</code> is returned and the values returned in <code>dist</code> are left
 * unspecified.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {!Array<number>} cost an array of double values that returns the costs for traversing each edge; edge <code>e</code> has cost <code>cost[e.index()]</code>
 * @param {!Array<!Array<number>>} dist an array of values that will be filled during the execution and returns the shortest path distances from all pairs of
 * nodes <code>s</code> and <code>t</code> in the graph. The distance from <code>s</code> to <code>t</code> is <code>dist[s.index()][t.index()]</code>. If there is no path from <code>s</code> to <code>t</code>,
 * then <code>dist[s.index()][t.index()] == Double.POSITIVE_INFINITY</code>.
 * @return {boolean} <code>true</code> if the given graph does not contain a negative-cost cycle, <code>false</code> otherwise
 */
yfiles.algorithms.ShortestPaths.allPairs = function(graph, directed, cost, dist) {};

/**
 * Solves the single-source shortest path problem for arbitrary graphs.
 * <p>
 * Each edge is associated with an arbitrary double value that represents the cost of this edge.
 * </p>
 * <p>
 * In case the given weighted graph contains no <b>negative-cost cycles</b>, this method will yield the shortest distance from a given node <code>s</code> to all
 * other nodes. If, on the other hand, the given graph contains negative-cost cycles, this method will yield no reasonable
 * result which will be indicated by the return value <code>false</code>.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#bellmanFord
 * Solves the single-source shortest path problem for arbitrary graphs.
 * <p>
 * Each edge is associated with an arbitrary double value that represents the cost of this edge.
 * </p>
 * <p>
 * In case the given weighted graph contains no <b>negative cost cycles</b>, this method will yield the shortest distance from a given node <code>s</code> to all
 * other nodes. If, on the other hand, the given graph contains negative-cost cycles, this method will yield no reasonable
 * result which will be indicated by the return value <code>false</code>.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * @see yfiles.algorithms.ShortestPaths#bellmanFord
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} s the source node / the node from which the shortest path search starts
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {?|!Array<number>} cost the {\@link } that returns the double value (cost) for traversing each edge / an array of double values that returns the costs for traversing each edge; edge <code>e</code> has cost <code>cost[e.index()]</code>
 * @param {?|!Array<number>} dist the {\@link } that will be filled during the execution and returns a double value (shortest distance)
 * from node <code>s</code> to all other nodes or {\@link #POSITIVE_INFINITY} if no such paths exist / an array of values that will be filled during the execution and returns the shortest distance from node <code>s</code> to all other
 * nodes. The distance from <code>s</code> to <code>v</code> is <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>, then
 * <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>.
 * @param {?|!Array<!yfiles.algorithms.Edge>=} pred the {\@link } that will be filled during the execution and returns for each node <code>t</code> the last edge on the
 * shortest path from <code>s</code> to <code>t</code> or <code>null</code> if <code>t == s</code> or no shortest path from <code>s</code> to <code>t</code> exists
 * @return {boolean}
 */
yfiles.algorithms.ShortestPaths.bellmanFord = function(graph, s, directed, cost, dist, pred) {};

/**
 * Convenience method that constructs an explicit {\@link yfiles.algorithms.EdgeList path of edges} from the result returned by one of the shortest paths
 * methods defined in this class.
 * <p>
 * If there is no path from node <code>s</code> to <code>t</code>, then an empty list is returned.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * Like {\@link yfiles.algorithms.ShortestPaths#constructEdgePath} but the path edges are given by a
 * {\@link yfiles.algorithms.IDataProvider}.
 * <p>
 * If there is no path from node <code>s</code> to <code>t</code>, then an empty list is returned.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * @param {!yfiles.algorithms.Node} s the start node of the shortest path which must be the same start node that was specified when <code>pred</code> was calculated
 * @param {!yfiles.algorithms.Node} t the target node of the path
 * @param {!Array<!yfiles.algorithms.Edge>|?} pred an array of {\@link }s that will be filled during the execution and returns for each node <code>t</code> the shortest
 * path edge <code>pred[t.index()]</code> which is the last edge on the shortest path from <code>s</code> to <code>t</code>. If <code>t == s</code> or if there is no shortest
 * path from <code>s</code> to <code>t</code>, then <code>pred[t.index()] == null</code>. / the {\@link } that will be filled during the execution and returns for each node <code>t</code> the last edge on the
 * shortest path from <code>s</code> to <code>t</code> or <code>null</code> if <code>t == s</code> or no shortest path from <code>s</code> to <code>t</code> exists
 * @return {!yfiles.algorithms.EdgeList} a {\@link  list} containing the edges on the shortest path from <code>s</code> to <code>t</code> in the correct order
 */
yfiles.algorithms.ShortestPaths.constructEdgePath = function(s, t, pred) {};

/**
 * Convenience method that constructs an explicit {\@link yfiles.algorithms.NodeList path of nodes} from the result returned by one of the shortest paths
 * methods defined in this class.
 * <p>
 * If there is no path from node <code>s</code> to <code>t</code>, then an empty list is returned.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * Like {\@link yfiles.algorithms.ShortestPaths#constructNodePath} but the path edges are given by a
 * {\@link yfiles.algorithms.IDataProvider}.
 * <p>
 * If there is no path from node <code>s</code> to <code>t</code>, then an empty list is returned.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @param {!yfiles.algorithms.Node} s the start node of the shortest path which must be the same start node that was specified when <code>pred</code> was calculated
 * @param {!yfiles.algorithms.Node} t the target node of the path
 * @param {!Array<!yfiles.algorithms.Edge>|?} pred an array of {\@link }s that will be filled during the execution and returns for each node <code>t</code> the shortest
 * path edge <code>pred[t.index()]</code> which is the last edge on the shortest path from <code>s</code> to <code>t</code>. If <code>t == s</code> or if there is no shortest
 * path from <code>s</code> to <code>t</code>, then <code>pred[t.index()] == null</code>. / the {\@link } that will be filled during the execution and returns for each node <code>t</code> the last edge on the
 * shortest path from <code>s</code> to <code>t</code> or <code>null</code> if <code>t == s</code> or no shortest path from <code>s</code> to <code>t</code> exists
 * @return {!yfiles.algorithms.NodeList} a {\@link  list} containing the nodes on the shortest path from <code>s</code> to <code>t</code> in the correct order
 */
yfiles.algorithms.ShortestPaths.constructNodePath = function(s, t, pred) {};

/**
 * Solves the single-source shortest path problem for arbitrary graphs.
 * <p>
 * Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.
 * </p>
 * <p>
 * This method yields the shortest distance from a given node <code>s</code> to all other nodes.
 * </p>
 * <p>
 * The costs should be non-negative.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * @see yfiles.algorithms.ShortestPaths#dijkstra
 * Solves the single-source shortest path problem for arbitrary graphs.
 * <p>
 * Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.
 * </p>
 * <p>
 * This method yields the shortest distance from a given node <code>s</code> to all other nodes.
 * </p>
 * <p>
 * The costs should be non-negative.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * @see yfiles.algorithms.ShortestPaths#dijkstra
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} s the node from which the shortest path search starts
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {!Array<number>|?} cost an array of double values that returns the costs for traversing each edge; edge <code>e</code> has cost <code>cost[e.index()]</code> / the {\@link } that returns the double value (cost) for traversing each edge
 * @param {!Array<number>|?} dist an array of values that will be filled during the execution and returns the shortest distance from node <code>s</code> to all other
 * nodes. The distance from <code>s</code> to <code>v</code> is <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>, then
 * <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>. / the {\@link } that will be filled during the execution and returns a double value (shortest distance)
 * from node <code>s</code> to all other nodes or {\@link #POSITIVE_INFINITY} if no such paths exist
 * @param {!Array<!yfiles.algorithms.Edge>|?=} pred the {\@link } that will be filled during the execution and returns for each node <code>t</code> the last edge on the
 * shortest path from <code>s</code> to <code>t</code> or <code>null</code> if <code>t == s</code> or no shortest path from <code>s</code> to <code>t</code> exists
 * @return {void}
 */
yfiles.algorithms.ShortestPaths.dijkstra = function(graph, s, directed, cost, dist, pred) {};

/**
 * Finds all nodes and edges that belong to a shortest path from a <code>start</code> node to a set of target nodes in the graph not
 * farther away than a given distance.
 * <p>
 * This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.
 * </p>
 * Marks all edges that belong to a shortest path from <code>start</code> node to <code>target</code> node.
 * <p>
 * This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} start the start node
 * @param {?|!yfiles.algorithms.Node} targetMap_or_end the {\@link } that returns a boolean value indicating whether or not a node belongs to the set of
 * target nodes / the target node
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {number|?} maxLength_or_pathMap the maximum edge length of the shortest paths / the {\@link } that will be filled during the execution and returns a boolean value indicating whether
 * or not the edge belongs to a shortest path connecting the two nodes
 * @param {!yfiles.algorithms.EdgeList=} pathEdges a {\@link  list} that will be filled during the execution and returns the edges on the shortest path from <code>s</code> to <code>t</code> in the correct
 * order
 * @param {!yfiles.algorithms.NodeList=} pathNodes a {\@link  list} that will be filled during the execution and returns the nodes on the shortest path from <code>s</code> to <code>t</code> in the correct
 * order
 * @return {void}
 */
yfiles.algorithms.ShortestPaths.findShortestUniformPaths = function(graph, start, targetMap_or_end, directed, maxLength_or_pathMap, pathEdges, pathNodes) {};

/**
 * This method finds the <code>k</code> shortest paths connecting a pair of nodes in a directed graph with non-negative edge costs.
 * <p>
 * The result will be returned as a list of {\@link yfiles.algorithms.EdgeList} objects.
 * </p>
 * <p>
 * The cost should be non-negative.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} costDP the {\@link } that returns a double value (cost) for traversing each edge
 * @param {!yfiles.algorithms.Node} start the given start node
 * @param {!yfiles.algorithms.Node} end the given target node
 * @param {number} k a non-negative integer value
 * @return {!yfiles.algorithms.YList} a {\@link  list} of {\@link } objects each of which represents a path from <code>start</code> node to <code>target</code> node. The <code>i</code>-th
 * path in the list contains the <code>i</code>-th shortest path between the <code>start</code> and <code>target</code> node.
 */
yfiles.algorithms.ShortestPaths.kShortestPaths = function(graph, costDP, start, end, k) {};

/**
 * A variant of {\@link yfiles.algorithms.ShortestPaths#kShortestPaths} that returns the result as a special cursor that calculates
 * the next path in the sequence only when needed.
 * <p>
 * The returned cursor only supports the operation {\@link yfiles.algorithms.ICursor#ok}, {\@link yfiles.algorithms.ICursor#current} and {\@link yfiles.algorithms.ICursor#next}.
 * </p>
 * <p>
 * The cost should be non-negative.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} costDP the {\@link } that returns a double value (cost) for traversing each edge
 * @param {!yfiles.algorithms.Node} start the given start node
 * @param {!yfiles.algorithms.Node} end the given target node
 * @param {number} k a non-negative integer value
 * @return {?} a {\@link  cursor} that calculates the next path in the sequence only when needed
 */
yfiles.algorithms.ShortestPaths.kShortestPathsCursor = function(graph, costDP, start, end, k) {};

/**
 * Returns two edge-disjoint paths in a non-negatively weighted directed graph, such that both paths connect nodes <code>s</code> and <code>t</code>
 * and have minimum total length.
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} source the source node of the shortest pair
 * @param {!yfiles.algorithms.Node} target the target node of the shortest pair
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {?} costDP the {\@link } that returns a double value (cost) for traversing each edge
 * @return {!Array<!yfiles.algorithms.EdgeList>} a two-dimensional array of {\@link }s holding the resulting edge-disjoint paths or <code>null</code> if no such
 * edge-disjoint paths exist
 */
yfiles.algorithms.ShortestPaths.shortestPair = function(graph, source, target, directed, costDP) {};

/**
 * This method solves the single-source shortest path problem for arbitrary graphs.
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * @see yfiles.algorithms.ShortestPaths#singleSource
 * This method solves the single-source shortest path problem for arbitrary graphs.
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * @see yfiles.algorithms.ShortestPaths#singleSource
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} s the node from which the shortest path search starts / the source node
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {!Array<number>|?} cost an array of double values that returns the costs for traversing each edge; edge <code>e</code> has cost <code>cost[e.index()]</code> / the {\@link } that returns the double value (cost) for traversing each edge
 * @param {!Array<number>|?} dist an array of values that will be filled during the execution and returns the shortest distance from node <code>s</code> to all other
 * nodes. The distance from <code>s</code> to <code>v</code> is <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>, then
 * <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>. / the {\@link } that will be filled during the execution and returns a double value (shortest distance)
 * from node <code>s</code> to all other nodes or {\@link #POSITIVE_INFINITY} if no such paths exist
 * @param {!Array<!yfiles.algorithms.Edge>|?=} pred the {\@link } that will be filled during the execution and returns for each node <code>t</code> the last edge on the
 * shortest path from <code>s</code> to <code>t</code> or <code>null</code> if <code>t == s</code> or no shortest path from <code>s</code> to <code>t</code> exists
 * @return {boolean} <code>true</code> if the weighted graph does not contain a negative-cost cycle, <code>false</code> otherwise
 */
yfiles.algorithms.ShortestPaths.singleSource = function(graph, s, directed, cost, dist, pred) {};

/**
 * This method solves the single-source single-sink shortest path problem for arbitrary graphs.
 * <p>
 * Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.
 * </p>
 * <p>
 * This method returns the shortest distance from node <code>s</code> to node
 * <code>t</code>. It also returns information to construct the actual path between these two nodes.
 * </p>
 * <p>
 * The costs should be non-negative.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * Like {\@link yfiles.algorithms.ShortestPaths#singleSourceSingleSink} but uses {\@link yfiles.algorithms.INodeMap}s and
 * {\@link yfiles.algorithms.IDataProvider}s instead of arrays.
 * <p>
 * Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.
 * </p>
 * <p>
 * The costs should be non-negative.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * Similar to {\@link yfiles.algorithms.ShortestPaths#singleSourceSingleSink} but instead of returning the shortest distance between
 * the source and sink the actual shortest edge path between these nodes will be returned.
 * <p>
 * Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.
 * </p>
 * <p>
 * If the returned path is empty, then there is no path between the nodes.
 * </p>
 * <p>
 * The costs should be non-negative.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * Similar to {\@link yfiles.algorithms.ShortestPaths#singleSourceSingleSink} but instead of returning the shortest distance between
 * the source and sink the actual shortest edge path between these nodes will be returned.
 * <p>
 * Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.
 * </p>
 * <p>
 * If the returned path is empty, then there is no path between the nodes.
 * </p>
 * <p>
 * The costs should be non-negative.
 * </p>
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * @see yfiles.algorithms.ShortestPaths#singleSourceSingleSink
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} s the source node
 * @param {!yfiles.algorithms.Node} t the sink node
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {!Array<number>|?} cost an array of double values that returns the costs for traversing each edge; edge <code>e</code> has cost <code>cost[e.index()]</code> / the {\@link } that returns the double value (cost) for traversing each edge
 * @param {!Array<!yfiles.algorithms.Edge>|?=} pred an array of {\@link }s that will be filled during the execution and returns for each node <code>t</code> the shortest
 * path edge <code>pred[t.index()]</code> which is the last edge on the shortest path from <code>s</code> to <code>t</code>. If <code>t == s</code> or if there is no shortest
 * path from <code>s</code> to <code>t</code>, then <code>pred[t.index()] == null</code>. / the {\@link } that will be filled during the execution and returns for each node <code>t</code> the last edge on the
 * shortest path from <code>s</code> to <code>t</code> or <code>null</code> if <code>t == s</code> or no shortest path from <code>s</code> to <code>t</code> exists
 * @return {number|!yfiles.algorithms.EdgeList} the distance between <code>s</code>and <code>t</code> if a path between these two nodes exists or <code>Double.POSITIVE_INFINITY</code> otherwise / a shortest {\@link  path of edges} between source and sink
 */
yfiles.algorithms.ShortestPaths.singleSourceSingleSink = function(graph, s, t, directed, cost, pred) {};

/**
 * Solves the single-source shortest path problem for arbitrary graphs in which each edge has a <b>uniform cost of
 * <code>1.0</code></b>.
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * Like {\@link yfiles.algorithms.ShortestPaths#uniform} but uses {\@link yfiles.algorithms.INodeMap}s instead of arrays.
 * @see yfiles.algorithms.ShortestPaths#uniform
 * @see yfiles.algorithms.ShortestPaths#constructNodePath
 * @see yfiles.algorithms.ShortestPaths#constructEdgePath
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.Node} s the node from which the shortest path search starts
 * @param {boolean} directed <code>true</code> if the graph should be considered as directed, <code>false</code> otherwise
 * @param {!Array<number>|?} dist an array of values that will be filled during the execution and returns the shortest distance from node <code>s</code> to all other
 * nodes. The distance from <code>s</code> to <code>v</code> is <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>, then
 * <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>. / the {\@link } that will be filled during the execution and returns a double value (shortest distance)
 * from node <code>s</code> to all other nodes or {\@link #POSITIVE_INFINITY} if no such paths exist
 * @param {!Array<!yfiles.algorithms.Edge>|?=} pred the {\@link } that will be filled during the execution and returns for each node <code>t</code> the last edge on the
 * shortest path from <code>s</code> to <code>t</code> or <code>null</code> if <code>t == s</code> or no shortest path from <code>s</code> to <code>t</code> exists
 * @return {void}
 */
yfiles.algorithms.ShortestPaths.uniform = function(graph, s, directed, dist, pred) {};

/**
 * Convenience method that returns an array containing uniform edge costs of <code>1.0</code> for each edge of the given graph.
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {!Array<number>} an array that contains uniform edge costs of value <code>1.0</code> (i.e., for each edge <code>e: cost[e.index()] == 1.0</code>)
 */
yfiles.algorithms.ShortestPaths.uniformCost = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Sorting = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Sorting.$class;

/**
 * Sorts the nodes of a given graph by degree in ascending order.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {!Array<!yfiles.algorithms.Node>} an array of {\@link }s sorted by degree in ascending order
 */
yfiles.algorithms.Sorting.sortNodesByDegree = function(graph) {};

/**
 * Sorts the nodes of a given graph by an integer key associated with each node through a {\@link yfiles.algorithms.IDataProvider}.
 * <p>
 * The nodes are sorted in ascending order.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {?} keys the {\@link } that returns the keys based on which the nodes will be sorted
 * @return {!Array<!yfiles.algorithms.Node>} an array of {\@link }s sorted by an integer key in ascending order
 */
yfiles.algorithms.Sorting.sortNodesByIntKey = function(graph, keys) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.SpanningTrees = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.SpanningTrees.$class;

/**
 * Returns the overall cost of a previously calculated minimum spanning tree.
 * @param {!yfiles.algorithms.EdgeList} treeEdges the given {\@link  list} of edges that form a minimum spanning tree
 * @param {?} edgeCost the {\@link } that returns a double value (cost) for each tree edge
 * @return {number} the overall cost of the tree edges
 */
yfiles.algorithms.SpanningTrees.cost = function(treeEdges, edgeCost) {};

/**
 * Calculates a minimum spanning tree for the given graph.
 * <p>
 * The implementation is based on an algorithm originally published in:
 * </p>
 * <ul>
 * <li>J.B. Kruskal. On the shortest spanning subtree of a graph and the traveling salesman problem. <i>Proceedings of the American Mathematical Society</i>, pages 48-50, 1956.</li>
 * </ul>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} cost the {\@link } that returns a double value (cost) for each edge
 * @return {!yfiles.algorithms.EdgeList} a {\@link  list} containing the edges that form the minimum spanning tree
 */
yfiles.algorithms.SpanningTrees.kruskal = function(graph, cost) {};

/**
 * Calculates a minimum spanning tree for the given graph.
 * <p>
 * Currently, the result is obtained by calling {\@link yfiles.algorithms.SpanningTrees#prim}.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} cost the {\@link } that returns a double value (cost) for each edge
 * @return {!yfiles.algorithms.EdgeList} a {\@link  list} containing the edges that form the minimum spanning tree
 */
yfiles.algorithms.SpanningTrees.minimum = function(graph, cost) {};

/**
 * Calculates a minimum spanning tree for the given graph.
 * <p>
 * The implementation is based on an algorithm originally published in:
 * </p>
 * <ul>
 * <li>R.C. Prim. Shortest connection networks and some generalizations. <i>Bell System Technical Journal</i>, 36:1389-1401, 1957.</li>
 * </ul>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} cost the {\@link } that returns a double value (cost) for each edge
 * @return {!yfiles.algorithms.EdgeList} a {\@link  list} containing the edges that form the minimum spanning tree
 */
yfiles.algorithms.SpanningTrees.prim = function(graph, cost) {};

/**
 * Calculates a spanning tree for the given graph in which each edge has a uniform cost of <code>1.0</code>.
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {!yfiles.algorithms.EdgeList} a {\@link  list} containing the edges that form the minimum spanning tree
 */
yfiles.algorithms.SpanningTrees.uniform = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Transitivity = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Transitivity.$class;

/**
 * Calculates the transitive closure for a directed acyclic graph.
 * <p>
 * Given a <code>G = (V,E)</code> be a directed acyclic graph. The <i>reflexive, transitive closure</i> of <code>G</code> is a graph which contains edge <code>(v,w)</code> only if there exists a
 * path from <code>v</code> to <code>w</code> in <code>G</code>.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph to which this method will add transitive edges, if necessary
 * @param {!yfiles.algorithms.EdgeList=} addedEdges
 * @return {void}
 */
yfiles.algorithms.Transitivity.transitiveClosure = function(graph, addedEdges) {};

/**
 * Calculates the transitive reduction for a directed acyclic graph.
 * <p>
 * The transitive edges in the graph will be removed by this method.
 * </p>
 * <p>
 * Given <code>G = (V,E)</code> be a directed acyclic graph. The <i>transitive reduction</i> of <code>G</code> is a graph which contains edge <code>(v,w)</code> only if there exists no path
 * from <code>v</code> to <code>w</code> in <code>G</code> of length <code>2</code> or more.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {!yfiles.algorithms.EdgeList=} transitiveEdges
 * @return {void}
 */
yfiles.algorithms.Transitivity.transitiveReduction = function(graph, transitiveEdges) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Trees = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Trees.$class;

/**
 * @param {!yfiles.algorithms.Node} root
 * @param {!yfiles.algorithms.NodeList} nodes
 * @return {void}
 */
yfiles.algorithms.Trees.collectSubtree = function(root, nodes) {};

/**
 * Converts the given tree to a directed rooted tree with the given node as root element by reversing some edges.
 * <p>
 * A list of all reversed edges will be returned by this method.
 * </p>
 * @param {!yfiles.algorithms.Graph} tree the given tree
 * @param {!yfiles.algorithms.Node=} root
 * @return {!yfiles.algorithms.EdgeList} an {\@link } containing the reversed edges
 */
yfiles.algorithms.Trees.directTree = function(tree, root) {};

/**
 * Returns the center node of an undirected tree.
 * <p>
 * The center node has the property of inducing a minimum depth tree when being used as the root of that tree.
 * </p>
 * @param {!yfiles.algorithms.Graph} tree the given undirected tree
 * @return {!yfiles.algorithms.Node} the center node of the given undirected tree
 */
yfiles.algorithms.Trees.getCenterRoot = function(tree) {};

/**
 * Returns all leaf nodes of the given tree.
 * <p>
 * A leaf node is a node with <code>outdegree == 0</code> if the input is a directed rooted tree, and a node with
 * <code>degree == 1</code>, otherwise.
 * </p>
 * @param {!yfiles.algorithms.Graph} tree the given tree
 * @param {boolean} directedRootedTree <code>true</code> if the algorithm should consider the tree as directed, <code>false</code> otherwise
 * @return {!yfiles.algorithms.NodeList} a {\@link } that contains all leaf nodes of the given tree
 */
yfiles.algorithms.Trees.getLeafNodes = function(tree, directedRootedTree) {};

/**
 * Returns the nearest common ancestor of a subset of nodes within a directed rooted tree.
 * <p>
 * It is not part of the given subset.
 * </p>
 * @param {!yfiles.algorithms.Graph} tree the given directed rooted tree
 * @param {!yfiles.algorithms.Node} root the root of the tree
 * @param {boolean} rootedDownward <code>true</code> if the tree is directed from the root to the leaves, <code>false</code> otherwise
 * @param {!yfiles.algorithms.NodeList} nodes the subset of nodes
 * @return {!yfiles.algorithms.Node} the {\@link  nearest common ancestor} of the given subset of nodes
 */
yfiles.algorithms.Trees.getNearestCommonAncestor = function(tree, root, rootedDownward, nodes) {};

/**
 * Returns a possible root for the given (undirected) tree.
 * <p>
 * More precisely:
 * </p>
 * <ul>
 * <li>If the input is a directed rooted tree or reversed directed rooted tree, it returns the corresponding root node.</li>
 * <li>
 * If the input is a tree, the method returns a maximum weight center node as defined in
 * {\@link yfiles.algorithms.Trees#getWeightedCenterNode}.
 * </li>
 * <li>If the input is not a tree, a node with <code>indegree == 0</code> (or <code>outdegree == 0</code>) is returned.</li>
 * </ul>
 * @param {!yfiles.algorithms.Graph} tree the given tree
 * @return {!yfiles.algorithms.Node} a possible root for the given tree
 */
yfiles.algorithms.Trees.getRoot = function(tree) {};

/**
 * Returns the depths of each subtree of a rooted directed tree.
 * @param {!yfiles.algorithms.Graph} tree a rooted directed tree graph
 * @param {?} subtreeDepthMap the {\@link } that will be filled during the execution with the depth of the subtree rooted at each
 * node
 * @return {void}
 */
yfiles.algorithms.Trees.getSubTreeDepths = function(tree, subtreeDepthMap) {};

/**
 * Returns the size (number of nodes) of each subtree of a rooted directed tree.
 * @param {!yfiles.algorithms.Graph} tree a rooted directed tree graph
 * @param {?} subtreeSizeMap the {\@link } that will be filled during the execution with the size of the subtree rooted at each
 * node
 * @return {void}
 */
yfiles.algorithms.Trees.getSubTreeSizes = function(tree, subtreeSizeMap) {};

/**
 * Returns an array of {\@link yfiles.algorithms.EdgeList} objects each containing edges that belong to a maximal directed subtree
 * of the given graph.
 * <p>
 * This method can also be applied to the result obtained by
 * {\@link yfiles.algorithms.Trees#getUndirectedTreeNodes}. In this case, the subtrees are considered to be undirected.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {!Array<!yfiles.algorithms.NodeList>=} treeNodes
 * @return {!Array<!yfiles.algorithms.EdgeList>} an array of {\@link } objects each containing edges that belong to a maximal subtree
 */
yfiles.algorithms.Trees.getTreeEdges = function(graph, treeNodes) {};

/**
 * Returns an array of {\@link yfiles.algorithms.NodeList} objects each containing nodes that belong to a maximal directed subtree
 * of the given graph.
 * <p>
 * For each list of tree nodes, the first node element is the root of a tree. On each such root, all outgoing edges connect
 * to nodes in the subtree and each in-degree of the root is at least two.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {!Array<!yfiles.algorithms.NodeList>} an array of {\@link } objects each containing nodes that belong to a maximal directed subtree
 */
yfiles.algorithms.Trees.getTreeNodes = function(graph) {};

/**
 * Returns an array of {\@link yfiles.algorithms.NodeList} objects each containing nodes that belong to a maximal undirected subtree
 * of the given graph.
 * <p>
 * For each list of tree nodes, the first node is the only node of the subtree that may be incident to non-tree edges.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {!Array<!yfiles.algorithms.NodeList>} an array of {\@link } objects each containing nodes that belong to a maximal undirected subtree
 */
yfiles.algorithms.Trees.getUndirectedTreeNodes = function(graph) {};

/**
 * Finds a node used by the greatest number of all (undirected) paths interconnecting all nodes with each other.
 * <p>
 * The number of paths per node are stored in the given {\@link yfiles.algorithms.INodeMap}.
 * </p>
 * @param {!yfiles.algorithms.Graph} tree the given tree
 * @param {?=} intWeight
 * @return {!yfiles.algorithms.Node} a {\@link } used by the greatest number of all undirected paths
 */
yfiles.algorithms.Trees.getWeightedCenterNode = function(tree, intWeight) {};

/**
 * Checks whether or not the given graph is a forest.
 * <p>
 * If
 * <code>directedRootedTree == true</code>, each component has to be a directed rooted tree. Otherwise, each component has to be an
 * undirected tree.
 * </p>
 * Checks whether or not the given graph is a forest, that is, a graph whose connected components are directed rooted
 * trees.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {boolean=} directedRootedTree <code>true</code> if the algorithm should check for directed rooted trees, <code>false</code> otherwise
 * @return {boolean} <code>true</code> if the given graph is a forest, <code>false</code> otherwise
 */
yfiles.algorithms.Trees.isForest = function(graph, directedRootedTree) {};

/**
 * Checks whether or not the given graph is a directed rooted tree in which each node has a maximum of <code>n</code> children.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @param {number} n the allowed maximum of children
 * @return {boolean} <code>true</code> if the given graph is a n-ary tree, <code>false</code> otherwise
 */
yfiles.algorithms.Trees.isNaryTree = function(graph, n) {};

/**
 * Checks whether or not the given graph is a directed rooted tree.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the given graph is a directed rooted tree, <code>false</code> otherwise
 */
yfiles.algorithms.Trees.isRootedTree = function(graph) {};

/**
 * Checks whether or not the given graph is an undirected tree.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {boolean} <code>true</code> if the given graph is an undirected tree, <code>false</code> otherwise
 */
yfiles.algorithms.Trees.isTree = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Comparers = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Comparers.$class;

/**
 * Compares the specified floating point numbers.
 * <p>
 * Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than
 * the second.
 * </p>
 * <p>
 * <b>Warning:</b> This method does <b>not</b> handle <code>NaN</code>! If you need <code>NaN</code>-safe comparison, use {\@link yfiles.lang.Object_Interface#compare} instead.
 * </p>
 * @see yfiles.collections.IComparer.<T>#compare
 * @param {number} d1 the first number to compare.
 * @param {number} d2 the second number to compare.
 * @return {number} a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the
 * second.
 */
yfiles.algorithms.Comparers.compare = function(d1, d2) {};

/**
 * Returns a {\@link yfiles.collections.IComparer.<T>} that compares to Objects of type Comparable.
 * @return {?<!Object>}
 */
yfiles.algorithms.Comparers.createComparableComparer = function() {};

/**
 * Returns a {\@link yfiles.collections.IComparer.<T>} that compares objects of arbitrary type.
 * <p>
 * Two objects are compared by comparing the {\@link yfiles.lang.IComparable} instances the given data provider returns for each of
 * these objects.
 * </p>
 * @param {?} dp a data provider that must return a {\@link } for each object that is being compared by this comparator.
 * @return {?<!Object>} a {\@link } that compares arbitrary objects.
 */
yfiles.algorithms.Comparers.createComparableDataComparer = function(dp) {};

/**
 * Returns a {\@link yfiles.collections.IComparer.<T>} that compares objects of arbitrary type.
 * <p>
 * Two objects are compared by comparing the int value the given data provider returns for each of these objects.
 * </p>
 * @param {?} dp a data provider that must return an int value for each object that is being compared by this comparator.
 * @return {?<!Object>} a {\@link } that compares arbitrary objects.
 */
yfiles.algorithms.Comparers.createIntDataComparer = function(dp) {};

/**
 * Returns a {\@link yfiles.collections.IComparer.<T>} that compares objects of type {\@link yfiles.algorithms.Edge}.
 * <p>
 * Two edges are compared by comparing their source nodes. Each source node <code>e.source()</code> in turn is compared by the int value
 * provided by the given data provider: <code>dp.getInt(e.source())</code>.
 * </p>
 * @param {?} dp a data provider that must return an int value for the source node of each edge being compared.
 * @return {?<!Object>} a {\@link } that compares edges.
 */
yfiles.algorithms.Comparers.createIntDataSourceComparer = function(dp) {};

/**
 * Returns a {\@link yfiles.collections.IComparer.<T>} that compares objects of type {\@link yfiles.algorithms.Edge}.
 * <p>
 * Two edges are compared by comparing their target nodes. Each target node <code>e.target()</code> in turn is compared by the int value
 * provided by the given data provider: <code>dp.getInt(e.target())</code>.
 * </p>
 * @param {?} dp a data provider that must return an int value for the target node of each edge being compared.
 * @return {?<!Object>} a {\@link } that compares edges.
 */
yfiles.algorithms.Comparers.createIntDataTargetComparer = function(dp) {};

/**
 * Returns a {\@link yfiles.collections.IComparer.<T>} that compares objects of arbitrary type.
 * <p>
 * Two objects are compared by comparing the double value the given data provider returns for each of these objects.
 * </p>
 * @param {?} dp a data provider that must return a double value for each object that is being compared by this comparator.
 * @return {?<!Object>} a {\@link } that compares arbitrary objects.
 */
yfiles.algorithms.Comparers.createNumberDataComparer = function(dp) {};

/**
 * Returns a {\@link yfiles.collections.IComparer.<T>} that compares objects of type {\@link yfiles.algorithms.Edge}.
 * <p>
 * Two edges are compared by comparing their source nodes. Each source node <code>e.source()</code> in turn is compared by the double
 * value provided by the given data provider: <code>dp.getDouble(e.source())</code>.
 * </p>
 * @param {?} dp a data provider that must return a double value for the source node of each edge being compared.
 * @return {?<!Object>} a {\@link } that compares edges.
 */
yfiles.algorithms.Comparers.createNumberDataSourceComparer = function(dp) {};

/**
 * Returns a {\@link yfiles.collections.IComparer.<T>} that compares objects of type {\@link yfiles.algorithms.Edge}.
 * <p>
 * Two edges are compared by comparing their target nodes. Each target node <code>e.target()</code> in turn is compared by the double
 * value provided by the given data provider: <code>dp.getDouble(e.target())</code>.
 * </p>
 * @param {?} dp a data provider that must return a double value for the target node of each edge being compared.
 * @return {?<!Object>} a {\@link } that compares edges.
 */
yfiles.algorithms.Comparers.createNumberDataTargetComparer = function(dp) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Cursors = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Cursors.$class;

/**
 * Creates a new cursor that provides a logical view on the concatenation of the two given cursors.
 * @param {?} c1 - first concatenation argument
 * @param {?} c2 - second concatenation argument
 * @return {?}
 */
yfiles.algorithms.Cursors.concatenate = function(c1, c2) {};

/**
 * Creates a cursor view of the given collection.
 * <p>
 * Creates an ICursor view of the given collection.
 * </p>
 * <p>
 * Note that the returned cursor does not support the {\@link yfiles.algorithms.ICursor#prev prev} and {\@link yfiles.algorithms.ICursor#toLast toLast} operations.
 * </p>
 * Type parameter <code>T</code>.
 * @template T
 * @param {?<T>} c The collection.
 * @return {?} The cursor view of the given collection.
 */
yfiles.algorithms.Cursors.createCursor = function(c) {};

/**
 * Creates a cursor view of the given collection.
 * <p>
 * Note that the returned cursor does not support the operations {\@link yfiles.algorithms.ICursor#prev prev}, {\@link yfiles.algorithms.ICursor#toLast toLast}, and
 * {\@link yfiles.algorithms.IEdgeCursor#cyclicPrev}.
 * </p>
 * Type parameter <code>T</code>.
 * @template T
 * @param {?<T>} c The collection.
 * @return {?} an {\@link } view of the given collection.
 */
yfiles.algorithms.Cursors.createEdgeCursor = function(c) {};

/**
 * Creates a cursor view of the given collection.
 * <p>
 * Note that the returned cursor does not support the operations {\@link yfiles.algorithms.ICursor#prev prev}, {\@link yfiles.algorithms.ICursor#toLast toLast}, and
 * {\@link yfiles.algorithms.INodeCursor#cyclicPrev}.
 * </p>
 * Type parameter <code>T</code>.
 * @template T
 * @param {?<T>} c The collection.
 * @return {?} an {\@link } view of the given collection.
 */
yfiles.algorithms.Cursors.createNodeCursor = function(c) {};

/**
 * Creates or fills an array with the values provided by the cursor
 * @param {?} cursor the cursor
 * @param {!Array<!Object>} dest the array to fill with the values or <code>null</code> if the method should create the array itself
 * @return {!Array<!Object>} dest or a newly created array filled with the values from cursor
 */
yfiles.algorithms.Cursors.toArray = function(cursor, dest) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.DataProviderAdapter = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.DataProviderAdapter.$class;

/**
 * Returns <code>false</code> for all data holders.
 * <p>
 * Subclasses should override this method to make clear for which data holders there is a value accessible via this data
 * provider.
 * </p>
 * @param {!Object} dataHolder
 * @return {boolean} <code>false</code>.
 */
yfiles.algorithms.DataProviderAdapter.prototype.defined = function(dataHolder) {};

/**
 * Subclasses may override this method to provide access to object values.
 * @throws {Stubs.Exceptions.NotSupportedError} unless overwritten.
 * @param {!Object} dataHolder
 * @return {!Object}
 */
yfiles.algorithms.DataProviderAdapter.prototype.get = function(dataHolder) {};

/**
 * Subclasses may override this method to provide access to boolean values.
 * @throws {Stubs.Exceptions.NotSupportedError} unless overwritten.
 * @param {!Object} dataHolder
 * @return {boolean}
 */
yfiles.algorithms.DataProviderAdapter.prototype.getBoolean = function(dataHolder) {};

/**
 * Subclasses may override this method to provide access to integer values.
 * @throws {Stubs.Exceptions.NotSupportedError} unless overwritten.
 * @param {!Object} dataHolder
 * @return {number}
 */
yfiles.algorithms.DataProviderAdapter.prototype.getInt = function(dataHolder) {};

/**
 * Subclasses may override this method to provide access to double values.
 * @throws {Stubs.Exceptions.NotSupportedError} unless overwritten.
 * @param {!Object} dataHolder
 * @return {number}
 */
yfiles.algorithms.DataProviderAdapter.prototype.getNumber = function(dataHolder) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.DataProviders = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.DataProviders.$class;

/**
 * Returns a DataProvider that returns the given value for each key.
 * @param {!Object} data constant Object data returned by the created data provider.
 * @return {?} a data provider view of a single value.
 */
yfiles.algorithms.DataProviders.createConstantDataProvider = function(data) {};

/**
 * Returns a DataProvider view of an Object array defined for edges.
 * <p>
 * The Object value <code>data[edge.index()]</code> will be returned by the data provider upon the method call <code>get(edge)</code>.
 * </p>
 * @param {!Array<!Object>} data array data for each edge of a static graph
 * @return {?} a data provider view of the given array
 */
yfiles.algorithms.DataProviders.createEdgeDataProvider = function(data) {};

/**
 * Returns a DataProvider view of a double, int, boolean and Object array defined for edges.
 * <p>
 * The double value <code>doubleData[edge.index()]</code> will be returned by the data provider upon the method call <code>getDouble(edge)</code>.
 * </p>
 * <p>
 * The int value <code>intData[edge.index()]</code> will be returned by the data provider upon the method call <code>getInt(edge)</code>.
 * </p>
 * <p>
 * The boolean value <code>boolData[edge.index()]</code> will be returned by the data provider upon the method call <code>getBool(edge)</code>.
 * </p>
 * <p>
 * The Object value <code>objectData[edge.index()]</code> will be returned by the data provider upon the method call <code>get(edge)</code>.
 * </p>
 * @param {!Array<number>} doubleData double data for each edge of a static graph
 * @param {!Array<number>} intData int data for each edge of a static graph
 * @param {!Array<boolean>} boolData boolean data for each edge of a static graph
 * @param {!Array<!Object>} objectData Object data for each edge of a static graph
 * @return {?} a data provider view of the given arrays
 */
yfiles.algorithms.DataProviders.createEdgeDataProviderForArrays = function(doubleData, intData, boolData, objectData) {};

/**
 * Returns a DataProvider view of a boolean array defined for edges.
 * <p>
 * The boolean value <code>data[edge.index()]</code> will be returned by the data provider upon the method call <code>getBool(edge)</code>.
 * </p>
 * @param {!Array<boolean>} data array data for each edge of a static graph
 * @return {?} a data provider view of the given array
 */
yfiles.algorithms.DataProviders.createEdgeDataProviderForBoolean = function(data) {};

/**
 * Returns a DataProvider view of an int array defined for edges.
 * <p>
 * The int value <code>data[edge.index()]</code> will be returned by the data provider upon the method call <code>getInt(edge)</code>.
 * </p>
 * @param {!Array<number>} data array data for each edge of a static graph
 * @return {?} a data provider view of the given array
 */
yfiles.algorithms.DataProviders.createEdgeDataProviderForInt = function(data) {};

/**
 * Returns a DataProvider view of a double array defined for edges.
 * <p>
 * The double value <code>data[edge.index()]</code> will be returned by the data provider upon the method call <code>getDouble(edge)</code>.
 * </p>
 * @param {!Array<number>} data array data for each edge of a static graph
 * @return {?} a data provider view of the given array
 */
yfiles.algorithms.DataProviders.createEdgeDataProviderForNumber = function(data) {};

/**
 * Returns a DataProvider that returns the negated boolean values provided by another data provider.
 * @param {?} data
 * @return {?}
 */
yfiles.algorithms.DataProviders.createNegatedDataProvider = function(data) {};

/**
 * Returns a DataProvider view of an Object array defined for nodes.
 * <p>
 * The Object value <code>data[node.index()]</code> will be returned by the data provider upon the method call <code>get(node)</code>.
 * </p>
 * @param {!Array<!Object>} data array data for each node of a static graph
 * @return {?} a data provider view of the given array
 */
yfiles.algorithms.DataProviders.createNodeDataProvider = function(data) {};

/**
 * Returns a DataProvider view of a boolean array defined for nodes.
 * <p>
 * The boolean value <code>data[node.index()]</code> will be returned by the data provider upon the method call <code>getBool(node)</code>.
 * </p>
 * @param {!Array<boolean>} data array data for each node of a static graph
 * @return {?} a data provider view of the given array
 */
yfiles.algorithms.DataProviders.createNodeDataProviderForBoolean = function(data) {};

/**
 * Returns a DataProvider view of an int array defined for nodes.
 * <p>
 * The int value <code>data[node.index()]</code> will be returned by the data provider upon the method call <code>getInt(node)</code>.
 * </p>
 * @param {!Array<number>} data array data for each node of a static graph
 * @return {?} a data provider view of the given array
 */
yfiles.algorithms.DataProviders.createNodeDataProviderForInt = function(data) {};

/**
 * Returns a DataProvider view of a double array defined for nodes.
 * <p>
 * The double value <code>data[node.index()]</code> will be returned by the data provider upon the method call <code>getDouble(node)</code>.
 * </p>
 * @param {!Array<number>} data array data for each node of a static graph
 * @return {?} a data provider view of the given array
 */
yfiles.algorithms.DataProviders.createNodeDataProviderForNumber = function(data) {};

/**
 * Returns a DataProvider view of a double, int, boolean and Object array defined for nodes.
 * <p>
 * The double value <code>doubleData[node.index()]</code> will be returned by the data provider upon the method call <code>getDouble(node)</code>.
 * </p>
 * <p>
 * The int value <code>intData[node.index()]</code> will be returned by the data provider upon the method call <code>getInt(node)</code>.
 * </p>
 * <p>
 * The boolean value <code>boolData[node.index()]</code> will be returned by the data provider upon the method call <code>getBool(node)</code>.
 * </p>
 * <p>
 * The Object value <code>objectData[node.index()]</code> will be returned by the data provider upon the method call <code>get(node)</code>.
 * </p>
 * @param {!Array<number>} doubleData double data for each node of a static graph
 * @param {!Array<number>} intData int data for each node of a static graph
 * @param {!Array<boolean>} boolData boolean data for each node of a static graph
 * @param {!Array<!Object>} objectData Object data for each node of a static graph
 * @return {?} a data provider view of the given arrays
 */
yfiles.algorithms.DataProviders.createNodeDataProviderWithArrays = function(doubleData, intData, boolData, objectData) {};

/**
 * Returns a DataProvider for edges that return the data provider values bound to their source nodes.
 * @param {?} nodeData
 * @return {?}
 */
yfiles.algorithms.DataProviders.createSourceDataProvider = function(nodeData) {};

/**
 * Returns a DataProvider for edges that return the data provider values bound to their target nodes.
 * @param {?} nodeData
 * @return {?}
 */
yfiles.algorithms.DataProviders.createTargetDataProvider = function(nodeData) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.GraphPartitionManager = function() {};
 /** @type {boolean} */
yfiles.algorithms.GraphPartitionManager.prototype.fireGraphEventsEnabled;
 /** @type {!yfiles.algorithms.Graph} */
yfiles.algorithms.GraphPartitionManager.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.GraphPartitionManager.$class;

/**
 * Assures that only nodes are visible in the graph that are associated with the given partitionId.
 * @param {!Object} partitionId the partitionId for the nodes that will be made visible
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.displayPartition = function(partitionId) {};

/**
 * Hides the given list of nodes from the graph.
 * <p>
 * The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * Hides the given list of edges from the graph.
 * <p>
 * The hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * Hides the given edge from the graph.
 * <p>
 * The hidden edge will be stored so that they can be unhidden again at a later time.
 * </p>
 * Hides the given node and all it's adjacent edges from the graph.
 * <p>
 * The hidden elements will be stored so that they can be unhidden again at a later time.
 * </p>
 * @param {!yfiles.algorithms.NodeList|!yfiles.algorithms.EdgeList|!yfiles.algorithms.Edge|!yfiles.algorithms.Node} nl_or_el_or_e_or_v
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.hide = function(nl_or_el_or_e_or_v) {};

/**
 * Hides all nodes and edges from this graph.
 * <p>
 * The hidden elements will be stored so that they can be unhidden again at a later time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.hideAll = function() {};

/**
 * Hides the given edges from the graph.
 * <p>
 * The hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @param {?} ec
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.hideEdgeCursor = function(ec) {};

/**
 * Hides all edges from this graph.
 * <p>
 * The hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.hideEdges = function() {};

/**
 * Hides the given elements from the graph.
 * <p>
 * The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @param {?} cursor
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.hideItemCursor = function(cursor) {};

/**
 * Hides multiple edges from the graph.
 * <p>
 * If there are multiple edges connecting two nodes then all but one (representative) of these edges will be hidden. The
 * hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.hideMultipleEdges = function() {};

/**
 * Hides the given nodes from the graph.
 * <p>
 * The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @param {?} nc
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.hideNodeCursor = function(nc) {};

/**
 * Hides nodes and adjacent edges that have the given partitionId associated.
 * @param {!Object} partitionId the id
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.hidePartition = function(partitionId) {};

/**
 * Hides all self-loop edges from this graph.
 * <p>
 * The hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.hideSelfLoops = function() {};

/**
 * Initializes internal data structures using the new DataProvider.
 * <p>
 * This method must also be called whenever the content of the given DataProvider changes.
 * </p>
 * @param {?} partitionId the data provider that holds the partitionIds for all elements.
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.initPartitions = function(partitionId) {};

/**
 * Hides all self-loops and multiple edges from the graph.
 * <p>
 * The overall effect of this method is that the minimum number of edges are hidden from the graph such that it contains no
 * self-loops and no multiple edges anymore. The hidden edges will be stored so that they can be unhidden again at a later
 * time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.simplifyGraph = function() {};

/**
 * This method will be called whenever the partition manager is requested to unhide the given node from the graph.
 * @protected
 * This method will be called whenever the partition manager is requested to unhide the given edge from the graph.
 * @protected
 * @param {!yfiles.algorithms.Node|!yfiles.algorithms.Edge} v_or_e
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.unhide = function(v_or_e) {};

/**
 * Unhides all formerly hidden elements in the graph.
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.unhideAll = function() {};

/**
 * Unhides all formerly hidden edges in the graph.
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.unhideEdges = function() {};

/**
 * Unhides all formerly hidden nodes in the graph.
 * <p>
 * Note that this method does not unhide hidden edges.
 * </p>
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.unhideNodes = function() {};

/**
 * Unhides nodes that have the given partitionId associated.
 * @param {!Object} partitionId the id
 * @return {void}
 */
yfiles.algorithms.GraphPartitionManager.prototype.unhidePartition = function(partitionId) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.LayoutGraphHider = function() {};
 /** @type {!yfiles.algorithms.EdgeList} */
yfiles.algorithms.LayoutGraphHider.prototype.hiddenEdges;
 /** @type {!yfiles.algorithms.NodeList} */
yfiles.algorithms.LayoutGraphHider.prototype.hiddenNodes;
 /** @type {boolean} */
yfiles.algorithms.LayoutGraphHider.prototype.fireGraphEvents;
 /** @type {!yfiles.algorithms.Graph} */
yfiles.algorithms.LayoutGraphHider.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.LayoutGraphHider.$class;

/**
 * The edges that are currently hidden
 * @return {?} a cursor of the currently hidden edges
 */
yfiles.algorithms.LayoutGraphHider.prototype.getHiddenEdgeCursor = function() {};

/**
 * The nodes that are currently hidden
 * @return {?} a cursor of the currently hidden nodes
 */
yfiles.algorithms.LayoutGraphHider.prototype.getHiddenNodeCursor = function() {};

/**
 * Hides the given list of nodes from the graph.
 * <p>
 * The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * Hides the given list of edges from the graph.
 * <p>
 * The hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * Hides the given edge from the graph.
 * <p>
 * The hidden edge will be stored so that they can be unhidden again at a later time.
 * </p>
 * Hides the given node and all it's adjacent edges from the graph.
 * <p>
 * The hidden elements will be stored so that they can be unhidden again at a later time.
 * </p>
 * @param {!yfiles.algorithms.NodeList|!yfiles.algorithms.EdgeList|!yfiles.algorithms.Edge|!yfiles.algorithms.Node} nl_or_el_or_e_or_v
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.hide = function(nl_or_el_or_e_or_v) {};

/**
 * Hides all nodes and edges from this graph.
 * <p>
 * The hidden elements will be stored so that they can be unhidden again at a later time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.hideAll = function() {};

/**
 * Hides the given edges from the graph.
 * <p>
 * The hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @param {?} ec
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.hideEdgeCursor = function(ec) {};

/**
 * Hides all edges from this graph.
 * <p>
 * The hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.hideEdges = function() {};

/**
 * Hides the given elements from the graph.
 * <p>
 * The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @param {?} cursor
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.hideItemCursor = function(cursor) {};

/**
 * Hides multiple edges from the graph.
 * <p>
 * If there are multiple edges connecting two nodes then all but one (representative) of these edges will be hidden. The
 * hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.hideMultipleEdges = function() {};

/**
 * Hides the given nodes from the graph.
 * <p>
 * The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @param {?} nc
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.hideNodeCursor = function(nc) {};

/**
 * Hides all self-loop edges from this graph.
 * <p>
 * The hidden edges will be stored so that they can be unhidden again at a later time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.hideSelfLoops = function() {};

/**
 * Hides the subgraph induced by the given edges from the given graph.
 * <p>
 * The induced subgraph defined by the given edges consists of the given edges and all nodes that are solely connected to
 * the rest of the graph by the given edges.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph
 * @param {?} ec
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.hideSubgraph = function(graph, ec) {};

/**
 * Hides all self-loops and multiple edges from the graph.
 * <p>
 * The overall effect of this method is that the minimum number of edges are hidden from the graph such that it contains no
 * self-loops and no multiple edges anymore. The hidden edges will be stored so that they can be unhidden again at a later
 * time.
 * </p>
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.simplifyGraph = function() {};

/**
 * This method will be called whenever the hider is requested to unhide the given node from the graph.
 * @protected
 * This method will be called whenever the hider is requested to unhide the given edge from the graph.
 * @protected
 * @param {!yfiles.algorithms.Node|!yfiles.algorithms.Edge} v_or_e
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.unhide = function(v_or_e) {};

/**
 * Unhides all formerly hidden elements in the graph.
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.unhideAll = function() {};

/**
 * Unhides the given edge.
 * <p>
 * Also updates {\@link yfiles.algorithms.LayoutGraphHider#hiddenEdges}.
 * </p>
 * <p>
 * Note that unhiding an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed) causes
 * an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.
 * </p>
 * @param {!yfiles.algorithms.Edge} e the edge that will be unhidden
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.unhideEdge = function(e) {};

/**
 * Unhides the given edges.
 * <p>
 * Also updates {\@link yfiles.algorithms.LayoutGraphHider#hiddenEdges}.
 * </p>
 * <p>
 * Note that unhiding an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed) causes
 * an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.
 * </p>
 * Unhides all formerly hidden edges in the graph.
 * @param {!yfiles.algorithms.EdgeList=} edges the edges that will be unhidden
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.unhideEdges = function(edges) {};

/**
 * Unhides the given node and if requested its adjacent edges.
 * <p>
 * Also updates {\@link yfiles.algorithms.LayoutGraphHider#hiddenNodes} and {\@link yfiles.algorithms.LayoutGraphHider#hiddenEdges}.
 * </p>
 * @param {!yfiles.algorithms.Node} v the node that will be unhidden
 * @param {boolean} unhideAdjacentEdges whether of not to unhide previously hidden edges connected at <code>v</code> whose other end point is not hidden, i.e. it is part of
 * the graph.
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.unhideNode = function(v, unhideAdjacentEdges) {};

/**
 * Unhides the given nodes and if requested its adjacent edges.
 * <p>
 * Also updates {\@link yfiles.algorithms.LayoutGraphHider#hiddenNodes} and {\@link yfiles.algorithms.LayoutGraphHider#hiddenEdges}.
 * </p>
 * Unhides all formerly hidden nodes in the graph.
 * <p>
 * Note that this method does not unhide hidden edges.
 * </p>
 * @param {!yfiles.algorithms.NodeList=} nodes the nodes that will be unhidden
 * @param {boolean=} unhideAdjacentEdges whether of not to unhide previously hidden edges connected at the given nodes whose other end point is not hidden, i.e.
 * it is part of the graph.
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.prototype.unhideNodes = function(nodes, unhideAdjacentEdges) {};

/**
 * Unhides the subgraph induced by the given edges in the given graph.
 * <p>
 * The induced subgraph defined by the given edges consists of the given edges and all nodes that are either source or
 * target of at least one of the given edges.
 * </p>
 * <p>
 * Parts of the subgraph that are already contained in the given graph will not be unhidden and pose no problem to this
 * method.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph
 * @param {?} ec
 * @return {void}
 */
yfiles.algorithms.LayoutGraphHider.unhideSubgraph = function(graph, ec) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.Maps = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.Maps.$class;

/**
 * Create a DataMap view of the given map.
 * <p>
 * Accessing basic value types is solved by storing the corresponding wrapper types Double, Integer and Boolean within the
 * given Map.
 * </p>
 * @param {?<!Object, !Object>} map
 * @return {?}
 */
yfiles.algorithms.Maps.createDataMap = function(map) {};

/**
 * Create an EdgeMap view of the given map.
 * <p>
 * Accessing basic value types is solved by storing the corresponding wrapper types Double, Integer and Boolean within the
 * given Map.
 * </p>
 * @param {?<!Object, !Object>} map
 * @return {?}
 */
yfiles.algorithms.Maps.createEdgeMap = function(map) {};

/**
 * Creates a DataMap that is based on hashing.
 * <p>
 * The preconditions specified in java.util.HashMap apply for the keys and values of this map.
 * </p>
 * @return {?}
 */
yfiles.algorithms.Maps.createHashedDataMap = function() {};

/**
 * Creates an EdgeMap that is based on hashing.
 * <p>
 * The preconditions specified in java.util.HashMap apply for the keys and values of this map.
 * </p>
 * @return {?}
 */
yfiles.algorithms.Maps.createHashedEdgeMap = function() {};

/**
 * Creates a NodeMap that is based on hashing.
 * <p>
 * The preconditions specified in java.util.HashMap apply for the keys and values of this map.
 * </p>
 * @return {?}
 */
yfiles.algorithms.Maps.createHashedNodeMap = function() {};

/**
 * Factory method that creates a {\@link yfiles.collections.IMap.<TKey,TValue>} that is a special hash map implementation mainly used by the layout algorithms.
 * Type parameter <code>K</code>.
 * Type parameter <code>V</code>.
 * @template K, V
 * @param {?<!yfiles.collections.MapEntry<K, V>>=} entries
 * @return {?<K, V>} A new instance.
 */
yfiles.algorithms.Maps.createHashMap = function(entries) {};

/**
 * Factory method that creates an {\@link yfiles.collections.ICollection.<T>} implementation with set semantics that is a special hash map based implementation mainly
 * used by the layout algorithms.
 * Type parameter <code>T</code>.
 * @template T
 * @param {?<T>=} items
 * @return {?<T>} A new instance.
 */
yfiles.algorithms.Maps.createHashSet = function(items) {};

/**
 * Creates a resettable high performance map for values of type <code>double</code>.
 * <p>
 * A high performance map is a facade to another map which will allow to reset all bound values to a default value in
 * constant time.
 * </p>
 * Creates a resettable high performance map for values of type <code>double</code>.
 * <p>
 * A high performance map is a facade to another map which will allow to reset all bound values to a default value in
 * constant time.
 * </p>
 * @param {?} backingProvider_or_backingMap
 * @param {?|number} backingAcceptor_or_defaultValue
 * @param {number=} defaultValue
 * @return {?}
 */
yfiles.algorithms.Maps.createHighPerformanceDoubleMap = function(backingProvider_or_backingMap, backingAcceptor_or_defaultValue, defaultValue) {};

/**
 * Creates a resettable high performance map for values of type <code>int</code>.
 * <p>
 * A high performance map is a facade to another map which will allow to reset all bound values to a default value in
 * constant time.
 * </p>
 * Creates a resettable high performance map for values of type <code>int</code>.
 * <p>
 * A high performance map is a facade to another map which will allow to reset all bound values to a default value in
 * constant time.
 * </p>
 * @param {?} backingProvider_or_backingMap
 * @param {?|number} backingAcceptor_or_defaultValue
 * @param {number=} defaultValue
 * @return {?}
 */
yfiles.algorithms.Maps.createHighPerformanceIntMap = function(backingProvider_or_backingMap, backingAcceptor_or_defaultValue, defaultValue) {};

/**
 * Creates a resettable high performance map for values of type <code>Object</code>.
 * <p>
 * A high performance map is a facade to another map which will allow to reset all bound values to a default value in
 * constant time.
 * </p>
 * Creates a resettable high performance map for values of type <code>Object</code>.
 * <p>
 * A high performance map is a facade to another map which will allow to reset all bound values to a default value in
 * constant time.
 * </p>
 * @param {?} backingProvider_or_backingMap
 * @param {?|!Object} backingAcceptor_or_defaultValue
 * @param {!Object=} defaultValue
 * @return {?}
 */
yfiles.algorithms.Maps.createHighPerformanceMap = function(backingProvider_or_backingMap, backingAcceptor_or_defaultValue, defaultValue) {};

/**
 * Returns a EdgeMap view of an Object array defined for edges.
 * <p>
 * The Object value <code>data[edge.index()]</code> will be accessed by the EdgeMap upon the method calls <code>get(edge)</code> and
 * <code>set(edge,value)</code>.
 * </p>
 * <p>
 * <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.
 * </p>
 * @param {!Array<!Object>} data array data for each edge of a static graph
 * @return {?} a EdgeMap view of the given array
 */
yfiles.algorithms.Maps.createIndexEdgeMap = function(data) {};

/**
 * Returns a EdgeMap view of a boolean array defined for edges.
 * <p>
 * The boolean value <code>data[edge.index()]</code> will be accessed by the EdgeMap upon the method calls <code>getBool(edge)</code> and
 * <code>setBool(edge,value)</code>.
 * </p>
 * <p>
 * <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.
 * </p>
 * @param {!Array<boolean>} data array data for each edge of a static graph
 * @return {?} a EdgeMap view of the given array
 */
yfiles.algorithms.Maps.createIndexEdgeMapForBoolean = function(data) {};

/**
 * Returns a EdgeMap view of an int array defined for edges.
 * <p>
 * The int value <code>data[edge.index()]</code> will be accessed by the EdgeMap upon the method calls <code>getInt(edge)</code> and
 * <code>setInt(edge,value)</code>.
 * </p>
 * <p>
 * <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.
 * </p>
 * @param {!Array<number>} data array data for each edge of a static graph
 * @return {?} a EdgeMap view of the given array
 */
yfiles.algorithms.Maps.createIndexEdgeMapForInt = function(data) {};

/**
 * Returns a EdgeMap view of a double array defined for edges.
 * <p>
 * The double value <code>data[edge.index()]</code> will be accessed by the EdgeMap upon the method calls <code>getDouble(edge)</code> and
 * <code>setDouble(edge,value)</code>.
 * </p>
 * <p>
 * <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.
 * </p>
 * @param {!Array<number>} data array data for each edge of a static graph
 * @return {?} a EdgeMap view of the given array
 */
yfiles.algorithms.Maps.createIndexEdgeMapForNumber = function(data) {};

/**
 * Returns a EdgeMap view of a double, int, boolean and Object array defined for edges.
 * <p>
 * The double value <code>doubleData[edge.index()]</code> will be accessed by the EdgeMap upon the method calls <code>getDouble(edge)</code> and
 * <code>setDouble(edge,value)</code>.
 * </p>
 * <p>
 * The int value <code>intData[edge.index()]</code> will be accessed by the EdgeMap upon the method calls <code>getInt(edge)</code> and
 * <code>setInt(edge,value)</code>.
 * </p>
 * <p>
 * The boolean value <code>boolData[edge.index()]</code> will be accessed by the EdgeMap upon the method calls <code>getBool(edge)</code> and
 * <code>setBool(edge,value)</code>.
 * </p>
 * <p>
 * The Object value <code>objectData[edge.index()]</code> will be accessed by the EdgeMap upon the method calls <code>get(edge)</code> and
 * <code>set(edge,value)</code>.
 * </p>
 * <p>
 * <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.
 * </p>
 * @param {!Array<number>} doubleData double data for each edge of a static graph
 * @param {!Array<number>} intData int data for each edge of a static graph
 * @param {!Array<boolean>} boolData boolean data for each edge of a static graph
 * @param {!Array<!Object>} objectData Object data for each edge of a static graph
 * @return {?} a EdgeMap view of the given arrays
 */
yfiles.algorithms.Maps.createIndexEdgeMapFromArrays = function(doubleData, intData, boolData, objectData) {};

/**
 * Returns a NodeMap view of an Object array defined for nodes.
 * <p>
 * The Object value <code>data[node.index()]</code> will be accessed by the NodeMap upon the method calls <code>get(node)</code> and <code>set(node,value)</code>.
 * <b>Warning!</b> The indices of the accessed nodes must not change during the use of this NodeMap.
 * </p>
 * @param {!Array<!Object>} data array data for each node of a static graph
 * @return {?} a NodeMap view of the given array
 */
yfiles.algorithms.Maps.createIndexNodeMap = function(data) {};

/**
 * Returns a NodeMap view of a boolean array defined for nodes.
 * <p>
 * The boolean value <code>data[node.index()]</code> will be accessed by the NodeMap upon the method calls <code>getBool(node)</code> and
 * <code>setBool(node,value)</code>.
 * </p>
 * @param {!Array<boolean>} data array data for each node of a static graph
 * @return {?} a NodeMap view of the given array
 */
yfiles.algorithms.Maps.createIndexNodeMapForBoolean = function(data) {};

/**
 * Returns a NodeMap view of an int array defined for nodes.
 * <p>
 * The int value <code>data[node.index()]</code> will be accessed by the NodeMap upon the method calls <code>getInt(node)</code> and
 * <code>setInt(node,value)</code>. <b>Warning!</b> The indices of the accessed nodes must not change during the use of this NodeMap.
 * </p>
 * @param {!Array<number>} data array data for each node of a static graph
 * @return {?} a NodeMap view of the given array
 */
yfiles.algorithms.Maps.createIndexNodeMapForInt = function(data) {};

/**
 * Returns a NodeMap view of a double array defined for nodes.
 * <p>
 * The double value <code>data[node.index()]</code> will be accessed by the NodeMap upon the method calls <code>getDouble(node)</code> and
 * <code>setDouble(node,value)</code>.
 * </p>
 * <p>
 * <b>Warning!</b> The indices of the accessed nodes must not change during the use of this NodeMap.
 * </p>
 * @param {!Array<number>} data array data for each node of a static graph
 * @return {?} a NodeMap view of the given array
 */
yfiles.algorithms.Maps.createIndexNodeMapForNumber = function(data) {};

/**
 * Returns a NodeMap view of a double, int, boolean and Object array defined for nodes.
 * <p>
 * The double value <code>doubleData[node.index()]</code> will be accessed by the NodeMap upon the method calls <code>getDouble(node)</code> and
 * <code>setDouble(node,value)</code>.
 * </p>
 * <p>
 * The int value <code>intData[node.index()]</code> will be accessed by the NodeMap upon the method calls <code>getInt(node)</code> and
 * <code>setInt(node,value)</code>.
 * </p>
 * <p>
 * The boolean value <code>boolData[node.index()]</code> will be accessed by the NodeMap upon the method calls <code>getBool(node)</code> and
 * <code>setBool(node,value)</code>.
 * </p>
 * <p>
 * The Object value <code>objectData[node.index()]</code> will be accessed by the NodeMap upon the method calls <code>get(node)</code> and
 * <code>set(node,value)</code>.
 * </p>
 * <p>
 * <b>Warning!</b> The indices of the accessed nodes must not change during the use of this NodeMap.
 * </p>
 * @param {!Array<number>} doubleData double data for each node of a static graph
 * @param {!Array<number>} intData int data for each node of a static graph
 * @param {!Array<boolean>} boolData boolean data for each node of a static graph
 * @param {!Array<!Object>} objectData Object data for each node of a static graph
 * @return {?} a NodeMap view of the given arrays
 */
yfiles.algorithms.Maps.createIndexNodeMapFromArrays = function(doubleData, intData, boolData, objectData) {};

/**
 * Create a NodeMap view of the given map.
 * <p>
 * Accessing basic value types is solved by storing the corresponding wrapper types Double, Integer and Boolean within the
 * given Map.
 * </p>
 * @param {?<!Object, !Object>} map
 * @return {?}
 */
yfiles.algorithms.Maps.createNodeMap = function(map) {};
/**
 * @record
 * @struct
 */
yfiles.algorithms.YList = function() {};
 /** @type {number} */
yfiles.algorithms.YList.prototype.size;
 /** @type {!Object} */
yfiles.algorithms.YList.prototype.firstObject;
 /** @type {!Object} */
yfiles.algorithms.YList.prototype.lastObject;
 /** @type {!yfiles.algorithms.ListCell} */
yfiles.algorithms.YList.prototype.firstCell;
 /** @type {!yfiles.algorithms.ListCell} */
yfiles.algorithms.YList.prototype.lastCell;
 /** @type {!yfiles.lang.Class} */
yfiles.algorithms.YList.$class;

/**
 * Appends all elements provided by the given cursor to this list.
 * <p>
 * The cursor will be moved from its given position to the end.
 * </p>
 * <p>
 * Be aware that a statement like <code>aList.append(aList.cursor())</code> results in an infinite recursion.
 * </p>
 * Appends all elements provided by the given collection to this list.
 *
 * @param {?|?<!Object>|number} c_or_collection_or_index
 * @param {?<!Object>=} c
 * @return {void|boolean} Whether there have been elements appended.
 */
yfiles.algorithms.YList.prototype.addAll = function(c_or_collection_or_index, c) {};

/**
 * Inserts the given object at the head of this list.
 * @param {!Object} o
 * @return {!yfiles.algorithms.ListCell} The newly created ListCell object that stores the given object.
 */
yfiles.algorithms.YList.prototype.addFirst = function(o) {};

/**
 * Adds a formerly removed ListCell object at the head of this list.
 * <p>
 * <b>Attention:</b> If the ListCell object is still part of any list, then that list will be corrupted afterwards.
 * </p>
 * @param {!yfiles.algorithms.ListCell} cell A list cell which is not part of any list.
 * @return {void}
 */
yfiles.algorithms.YList.prototype.addFirstCell = function(cell) {};

/**
 * Inserts the given object at the tail of this list.
 * @param {!Object} o
 * @return {!yfiles.algorithms.ListCell} The newly created ListCell object that stores the given object.
 */
yfiles.algorithms.YList.prototype.addLast = function(o) {};

/**
 * Adds a formerly removed ListCell object at the tail of this list.
 * <p>
 * <b>Attention:</b> If the ListCell object is still part of any list, then that list will be corrupted afterwards.
 * </p>
 * @param {!yfiles.algorithms.ListCell} cell A list cell which is not part of any list.
 * @return {void}
 */
yfiles.algorithms.YList.prototype.addLastCell = function(cell) {};

/**
 * Removes all elements from this list.
 * @return {void}
 */
yfiles.algorithms.YList.prototype.clear = function() {};

/**
 * Whether or not this list contains all the elements in the given collection.
 * <p>
 * Equality of elements is defined by the {\@link Object#equals} method.
 * </p>
 * @param {?<!Object>} collection
 * @return {boolean}
 */
yfiles.algorithms.YList.prototype.containsAll = function(collection) {};

/**
 * Copies the elements of this collection to an array, starting at the specified array index.
 * @param {!Array<!Object>} array The one-dimensional array that is the destination of the elements copied from this collection.
 * @param {number} arrayIndex The zero-based index in <code>array</code> at which copying begins.
 * @return {void}
 */
yfiles.algorithms.YList.prototype.copyTo = function(array, arrayIndex) {};

/**
 * Returns a cursor for this list.
 * <p>
 * All cursor operations are supported. This cursor implementation is not fail-fast and continues to work if this list is
 * modified during the traversal as long as the current ListCell the cursor points at is this in this list or has been
 * removed from this list but has not been added to another instance since then.
 * </p>
 * @return {?}
 */
yfiles.algorithms.YList.prototype.cursor = function() {};

/**
 * Returns the cyclic predecessor cell of the given list cell.
 * <p>
 * The last cell is returned as the cyclic predecessor of the first list cell.
 * </p>
 * @param {!yfiles.algorithms.ListCell} c
 * @return {!yfiles.algorithms.ListCell}
 */
yfiles.algorithms.YList.prototype.cyclicPred = function(c) {};

/**
 * Returns the cyclic successor cell of the given list cell.
 * <p>
 * The first cell is returned as the cyclic successor of the last list cell.
 * </p>
 * @param {!yfiles.algorithms.ListCell} c
 * @return {!yfiles.algorithms.ListCell}
 */
yfiles.algorithms.YList.prototype.cyclicSucc = function(c) {};

/**
 * Returns the i-th element of this list.
 * @param {number} i
 * @return {!Object}
 */
yfiles.algorithms.YList.prototype.elementAt = function(i) {};

/**
 * Returns the {\@link yfiles.algorithms.ListCell} where object <code>o</code> is stored.
 * <p>
 * This operation returns <code>null</code>, if no such cell exists. Equality of elements is defined by the {\@link Object#equals} method. The first
 * element in the list that matches that criteria is returned.
 * </p>
 * @param {!Object} o
 * @return {!yfiles.algorithms.ListCell} the ListCell that contains the element or <code>null</code> if no such ListCell was found
 */
yfiles.algorithms.YList.prototype.findCell = function(o) {};

/**
 * Gets the element at the specified index.
 * @see yfiles.algorithms.YList#set
 * @param {number} index The zero-based index of the element to get or set.
 * @return {!Object} The element at the specified index.
 */
yfiles.algorithms.YList.prototype.get = function(index) {};

/**
 * Gets the cell at the given index.
 * @throws {Stubs.Exceptions.IndexOutOfRangeError} if the index is negative or greater or equal than the {\@link yfiles.algorithms.YList#size}
 * @param {number} index the zero-based index of the cell in this list.
 * @return {!yfiles.algorithms.ListCell} The cell.
 */
yfiles.algorithms.YList.prototype.getCell = function(index) {};

/**
 * Returns an enumerator that iterates through this collection.
 * @return {?<!Object>} An {\@link } that can be used to iterate through this collection.
 */
yfiles.algorithms.YList.prototype.getEnumerator = function() {};

/**
 * Returns the element stored in the given list cell.
 * @param {!yfiles.algorithms.ListCell} c
 * @return {!Object}
 */
yfiles.algorithms.YList.prototype.getInfo = function(c) {};

/**
 * Whether or not this list contains the given element.
 * <p>
 * Equality of elements is defined by the {\@link Object#equals} method.
 * </p>
 * @param {!Object} o
 * @return {boolean}
 */
yfiles.algorithms.YList.prototype.includes = function(o) {};

/**
 * Returns the zero-based index of the given element in this list.
 * <p>
 * If the given element is not in the list, -1 is returned.
 * </p>
 * @param {!Object} obj
 * @return {number}
 */
yfiles.algorithms.YList.prototype.indexOf = function(obj) {};

/**
 *
 * @param {number} index
 * @param {!Object} element
 * @return {void}
 */
yfiles.algorithms.YList.prototype.insert = function(index, element) {};

/**
 * Inserts the given object into this list with respect to a given reference list cell.
 * <p>
 * The (newly created) list cell that stores the object is inserted right after the reference list cell <code>refCell</code>.
 * </p>
 * <p>
 * If <code>refCell == null</code>, the given object is inserted at the head of the list.
 * </p>
 * @param {!Object} o The object to be inserted.
 * @param {!yfiles.algorithms.ListCell} refCell The list cell used to reference the position.
 * @return {!yfiles.algorithms.ListCell} The newly created ListCell object that stores object <code>o</code>.
 */
yfiles.algorithms.YList.prototype.insertAfter = function(o, refCell) {};

/**
 * Inserts the given object into this list with respect to a given reference list cell.
 * <p>
 * The (newly created) list cell that stores the object is inserted right before the reference list cell <code>refCell</code>.
 * </p>
 * <p>
 * If <code>refCell == null</code>, the given object is appended to the list.
 * </p>
 * @param {!Object} o The object to be inserted.
 * @param {!yfiles.algorithms.ListCell} refCell The list cell used to reference the position.
 * @return {!yfiles.algorithms.ListCell} The newly created ListCell object that stores object <code>o</code>.
 */
yfiles.algorithms.YList.prototype.insertBefore = function(o, refCell) {};

/**
 * Inserts a formerly removed ListCell object into this list with respect to a given reference list cell.
 * <p>
 * The ListCell object is inserted right after the reference list cell <code>refCell</code>.
 * </p>
 * <p>
 * <b>Attention:</b> If the ListCell object is still part of any list, then that list will be corrupted afterwards.
 * </p>
 * @param {!yfiles.algorithms.ListCell} cellToInsert A list cell which is not part of any list.
 * @param {!yfiles.algorithms.ListCell} refCell The list cell used to reference the position.
 * @return {void}
 */
yfiles.algorithms.YList.prototype.insertCellAfter = function(cellToInsert, refCell) {};

/**
 * Inserts a formerly removed ListCell object into this list with respect to a given reference list cell.
 * <p>
 * The ListCell object is inserted right before the reference list cell <code>refCell</code>.
 * </p>
 * <p>
 * <b>Attention:</b> If the ListCell object is still part of any list, then that list will be corrupted afterwards.
 * </p>
 * @param {!yfiles.algorithms.ListCell} cellToInsert A list cell which is not part of any list.
 * @param {!yfiles.algorithms.ListCell} refCell The list cell used to reference the position.
 * @return {void}
 */
yfiles.algorithms.YList.prototype.insertCellBefore = function(cellToInsert, refCell) {};

/**
 * Checks whether this list contains elements.
 * @return {boolean}
 */
yfiles.algorithms.YList.prototype.isEmpty = function() {};

/**
 *
 * @param {!Object} o
 * @return {number}
 */
yfiles.algorithms.YList.prototype.lastIndexOf = function(o) {};

/**
 * Equivalent to {\@link yfiles.algorithms.YList#firstObject}.
 * @return {!Object}
 */
yfiles.algorithms.YList.prototype.peek = function() {};

/**
 * Removes the first element from this list and returns it.
 * @return {!Object}
 */
yfiles.algorithms.YList.prototype.pop = function() {};

/**
 * Removes the last element from this list and returns it.
 * @return {!Object}
 */
yfiles.algorithms.YList.prototype.popLast = function() {};

/**
 * Returns the predecessor cell of the given list cell.
 * @param {!yfiles.algorithms.ListCell} c
 * @return {!yfiles.algorithms.ListCell}
 */
yfiles.algorithms.YList.prototype.predCell = function(c) {};

/**
 * Equivalent to {\@link yfiles.algorithms.YList#addFirst}.
 * @param {!Object} o
 * @return {!yfiles.algorithms.ListCell}
 */
yfiles.algorithms.YList.prototype.push = function(o) {};

/**
 * Removes the given object from this list.
 * <p>
 * Only the first element for which equality to <code>o</code> holds gets removed.
 * </p>
 * @param {!Object} o
 * @return {boolean}
 */
yfiles.algorithms.YList.prototype.remove = function(o) {};

/**
 * Removes the given collection of objects from this list.
 * @param {?<!Object>} collection
 * @return {boolean} Whether there have been elements removed.
 */
yfiles.algorithms.YList.prototype.removeAll = function(collection) {};

/**
 *
 * @param {number} index
 * @return {void}
 */
yfiles.algorithms.YList.prototype.removeAt = function(index) {};

/**
 * Removes the element pointed to by the given YCursor object.
 * @param {?} c
 * @return {!Object} The removed element.
 */
yfiles.algorithms.YList.prototype.removeAtCursor = function(c) {};

/**
 * Removes the given list cell, and hence the element stored in it, from this list.
 * @param {!yfiles.algorithms.ListCell} c
 * @return {!Object} The element that is stored in the removed cell.
 */
yfiles.algorithms.YList.prototype.removeCell = function(c) {};

/**
 * Retains only those elements in this list which are contained in the given collection.
 * @param {?<!Object>} collection
 * @return {boolean} Whether there have been elements removed.
 */
yfiles.algorithms.YList.prototype.retainAll = function(collection) {};

/**
 * Reverses the sequence of elements in this list.
 * @return {void}
 */
yfiles.algorithms.YList.prototype.reverse = function() {};

/**
 * Sets the element at the specified index.
 * @see yfiles.algorithms.YList#get
 * @param {number} index The zero-based index of the element to get or set.
 * @param {!Object} value The element at the specified index.
 * @return {void}
 */
yfiles.algorithms.YList.prototype.set = function(index, value) {};

/**
 * Updates the element stored in the given list cell with the given object.
 * @param {!yfiles.algorithms.ListCell} c
 * @param {!Object} value
 * @return {void}
 */
yfiles.algorithms.YList.prototype.setInfo = function(c, value) {};

/**
 * Sorts the elements in this list according to the given comparator.
 * <p>
 * NOTE: The elements will be assigned to different list cells by this method.
 * </p>
 * Sorts the elements in this list into ascending order, according to their natural ordering.
 * <p>
 * All elements must implement the {\@link yfiles.lang.IComparable} interface. Furthermore, all elements in this list must be
 * mutually comparable (that is, <code>e1.compareTo(e2)</code> must not throw a ClassCastException for any elements <code>e1</code> and <code>e2</code> in this
 * list).
 * </p>
 * <p>
 * NOTE: The elements will be assigned to different list cells by this method.
 * </p>
 * @param {?<!Object>=} comparer
 * @return {void}
 */
yfiles.algorithms.YList.prototype.sort = function(comparer) {};

/**
 * Transfers the contents of the given list to the end of this list.
 * <p>
 * The given list will be empty after this operation.
 * </p>
 * <p>
 * Note that this operation transfers the list cells of the given list to this list. No new list cells are created by this
 * operation.
 * </p>
 * @param {!yfiles.algorithms.YList} list
 * @return {void}
 */
yfiles.algorithms.YList.prototype.splice = function(list) {};

/**
 *
 * @param {number} fromIndex
 * @param {number} toIndex
 * @return {?<!Object>}
 */
yfiles.algorithms.YList.prototype.subList = function(fromIndex, toIndex) {};

/**
 * Returns the successor cell of the given list cell.
 * @param {!yfiles.algorithms.ListCell} c
 * @return {!yfiles.algorithms.ListCell}
 */
yfiles.algorithms.YList.prototype.succCell = function(c) {};

/**
 * Returns an array representation of this list.
 * @return {!Array<!Object>}
 */
yfiles.algorithms.YList.prototype.toArray = function() {};
/** @const */
yfiles.layout = {};
/**
 * @record
 * @struct
 */
yfiles.layout.BendConverter = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.layout.BendConverter.DEFAULT_AFFECTED_EDGES_DP_KEY;
 /** @type {?} */
yfiles.layout.BendConverter.prototype.coreLayout;
 /** @type {boolean} */
yfiles.layout.BendConverter.prototype.adoptEdgeGroups;
 /** @type {boolean} */
yfiles.layout.BendConverter.prototype.adoptPortConstraints;
 /** @type {boolean} */
yfiles.layout.BendConverter.prototype.adoptAffectedEdges;
 /** @type {!Object} */
yfiles.layout.BendConverter.prototype.affectedEdgesDpKey;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.BendConverter.$class;

/**
 * Adds information to newly created dummy nodes.
 * <p>
 * This is a callback method that will be invoked after new elements for the given edge have been added to the given graph
 * by {\@link yfiles.layout.BendConverter#prepare}. At this point, the original edge is still in the graph.
 * </p>
 * <p>
 * The current implementation does nothing.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the edge whose bends were replaced by the given dummy nodes
 * @param {!yfiles.algorithms.NodeList} dummyNodes the dummy nodes representing the bends of the edge
 * @return {void}
 */
yfiles.layout.BendConverter.prototype.addedPathForEdge = function(graph, edge, dummyNodes) {};

/**
 * Replaces all bends in the current {\@link yfiles.layout.BendConverter#DEFAULT_AFFECTED_EDGES_DP_KEY scope} with dummy nodes before invoking the {\@link yfiles.layout.BendConverter#coreLayout core layout algorithm}.
 * <p>
 * After the {\@link yfiles.layout.BendConverter#coreLayout core layout algorithm} has finished, the edges between the dummy nodes are reconnected and the dummy nodes are
 * replaced by bends again.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.BendConverter.prototype.applyLayout = function(graph) {};

/**
 * Prepares the graph before calling the {\@link yfiles.layout.BendConverter#coreLayout core layout algorithm}.
 * <p>
 * The bends of the edges belonging to the current scope are replaced by dummy nodes and the segments between those dummy
 * nodes are replaced by dummy edges.
 * </p>
 * <p>
 * Edge-specific information like {\@link yfiles.layout.PortConstraint}s, edge groups or selection state can be applied to the dummy
 * edges to keep this information for the {\@link yfiles.layout.BendConverter#coreLayout core layout algorithm}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.layout.BendConverter#applyLayout} before invoking the
 * {\@link yfiles.layout.BendConverter#coreLayout core layout algorithm}. It may be overridden to extend the edge-specific information that should be adopted by the dummy
 * edges.
 * </p>
 * @see yfiles.layout.BendConverter#restore
 * @see yfiles.layout.BendConverter#adoptAffectedEdges
 * @see yfiles.layout.BendConverter#adoptPortConstraints
 * @see yfiles.layout.BendConverter#adoptEdgeGroups
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.BendConverter.prototype.prepare = function(graph) {};

/**
 * Restores the structure of the graph after the {\@link yfiles.layout.BendConverter#coreLayout core layout algorithm} has finished.
 * <p>
 * This method is called by {\@link yfiles.layout.BendConverter#applyLayout} after invoking the {\@link yfiles.layout.BendConverter#coreLayout core layout algorithm}. It may be
 * overridden to clean up all additional information added in {\@link yfiles.layout.BendConverter#prepare}.
 * </p>
 * @see yfiles.layout.BendConverter#prepare
 * @see yfiles.layout.BendConverter#adoptAffectedEdges
 * @see yfiles.layout.BendConverter#adoptPortConstraints
 * @see yfiles.layout.BendConverter#adoptEdgeGroups
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the graph arranged by the {\@link #coreLayout core layout algorithm}
 * @return {void}
 */
yfiles.layout.BendConverter.prototype.restore = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.BufferedLayout = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.BufferedLayout.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ComponentLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.layout.ComponentLayout.AFFECTED_COMPONENTS_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.layout.ComponentLayout.COMPONENT_ID_DP_KEY;
 /** @type {!yfiles.algorithms.YDimension} */
yfiles.layout.ComponentLayout.prototype.preferredSize;
 /** @type {boolean} */
yfiles.layout.ComponentLayout.prototype.considerLabels;
 /** @type {boolean} */
yfiles.layout.ComponentLayout.prototype.componentArrangement;
 /** @type {number} */
yfiles.layout.ComponentLayout.prototype.gridSpacing;
 /** @type {number} */
yfiles.layout.ComponentLayout.prototype.componentSpacing;
 /** @type {boolean} */
yfiles.layout.ComponentLayout.prototype.considerGrouping;
 /** @type {yfiles.layout.ComponentArrangementStyles} */
yfiles.layout.ComponentLayout.prototype.style;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ComponentLayout.$class;

/**
 * Produces a component graph layout.
 * <p>
 * This method is called by {\@link yfiles.layout.ComponentLayout#applyLayout} in case {\@link yfiles.layout.ComponentLayout#componentArrangement component arrangement} is enabled. It moves
 * the graph's components such that their bounding boxes do not overlap. Subclasses may want to override this method to
 * introduce custom component arrangement styles.
 * </p>
 * @see yfiles.layout.ComponentLayout#arrangeFields
 * @see yfiles.layout.LayoutGraphUtilities#arrangeRectangleRows
 * @see yfiles.layout.LayoutGraphUtilities#arrangeRectangleMultiRows
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!Array<!yfiles.algorithms.NodeList>} nodes the nodes of the components; the i-th list contains the nodes of the i-th component
 * @param {!Array<!yfiles.algorithms.EdgeList>} edges the edges of the components; the i-th list contains the edges of the i-th component
 * @param {!Array<!yfiles.algorithms.YRectangle>} bbox the bounds of the components; the i-th rectangle describes the bounding box of the i-th component
 * @param {!Array<!yfiles.algorithms.Rectangle2D>} boxes the extended bounds of the components; the i-th rectangle describes the bounding box of the i-th component extended by
 * the spacing between components. The method arranges these boxes in such a way that they do not overlap. Then, the i-th
 * graph component must be placed inside the i-th box
 * @return {void}
 */
yfiles.layout.ComponentLayout.prototype.arrangeComponents = function(graph, nodes, edges, bbox, boxes) {};

/**
 * Arranges the bounding boxes of the components.
 * <p>
 * This method is called by {\@link yfiles.layout.ComponentLayout#arrangeComponents} if the {\@link yfiles.layout.ComponentLayout#style style} is set to
 * {\@link yfiles.layout.ComponentArrangementStyles#PACKED_RECTANGLE},
 * {\@link yfiles.layout.ComponentArrangementStyles#PACKED_COMPACT_RECTANGLE}, {\@link yfiles.layout.ComponentArrangementStyles#PACKED_CIRCLE}
 * or
 * {\@link yfiles.layout.ComponentArrangementStyles#PACKED_COMPACT_CIRCLE}. It may be overridden to adjust the component arrangement
 * strategy of the mentioned styles.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!Array<!yfiles.algorithms.NodeList>} nodes the nodes of the components; the i-th list contains the nodes of the i-th component
 * @param {!Array<!yfiles.algorithms.EdgeList>} edges the edges of the components; the i-th list contains the edges of the i-th component
 * @param {!Array<!yfiles.algorithms.YRectangle>} bbox the bounds of the components; the i-th rectangle describes the bounding box of the i-th component
 * @param {!Array<!yfiles.algorithms.Rectangle2D>} boxes the extended bounds of the components; the i-th rectangle describes the bounding box of the i-th component
 * @param {boolean} circular <code>true</code> if the arrangement should be circular, <code>false</code> if it should be rectangular
 * @param {boolean} fill <code>true</code> if it is allowed to place components in empty spaces <em>inside other
 * components</em>, <code>false</code> otherwise
 * @param {boolean} fromSketch <code>true</code> if the initial coordinates should be considered, <code>false</code> otherwise
 * @return {void}
 */
yfiles.layout.ComponentLayout.prototype.arrangeFields = function(graph, nodes, edges, bbox, boxes, circular, fill, fromSketch) {};

/**
 * Calculates the bounding box of a graph component including {\@link yfiles.layout.NodeHalo}s.
 * <p>
 * This method will be invoked for each component of the graph. Depending on the state of property
 * {\@link yfiles.layout.ComponentLayout#considerLabels}, the returned bounding box will also include node and edge labels. It may be overridden to extend the bounds to reserve
 * space for other elements.
 * </p>
 * @see yfiles.layout.ComponentLayout#considerLabels
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the subgraph containing the nodes and edges of a component
 * @return {!yfiles.algorithms.Rectangle2D} the bounding box of the component
 */
yfiles.layout.ComponentLayout.prototype.calculateBounds = function(graph) {};

/**
 * Determines which nodes belong to the same graph component.
 * <p>
 * This implementation uses the graph connectivity to sort the nodes into different components. Nodes that are not
 * connected by a path will be in separate components.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.layout.ComponentLayout#applyLayout}. It may be overridden to choose another approach to
 * find components that will be passed to the
 * {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm}. However, most of the layout algorithms cannot handle disconnected graphs. Also, edges between
 * custom components will be ignored.
 * </p>
 * @see yfiles.algorithms.GraphConnectivity#connectedComponents
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} compNumber a map that will be filled with the zero-based index of the component to which the node belongs
 * @return {number} the number of connected components of this graph
 */
yfiles.layout.ComponentLayout.prototype.findGraphComponents = function(graph, compNumber) {};

/**
 * Moves the subgraph containing the given nodes and edges to the specified origin.
 * <p>
 * This method is called by {\@link yfiles.layout.ComponentLayout#arrangeComponents} and {\@link yfiles.layout.ComponentLayout#arrangeFields}
 * to move the components to overlap-free positions.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.NodeList} nodes the nodes in the moving subgraph
 * @param {!yfiles.algorithms.EdgeList} edges the edges in the moving subgraph
 * @param {!yfiles.algorithms.YPoint} origin the new origin of the graph
 * @param {!yfiles.algorithms.YRectangle} rectangle the current bounds of the subgraph
 * @return {void}
 */
yfiles.layout.ComponentLayout.prototype.setOrigin = function(graph, nodes, edges, origin, rectangle) {};
/**
 * @record
 * @struct
 */
yfiles.layout.CompositeLayoutStage = function() {};
 /** @type {?<!Object>} */
yfiles.layout.CompositeLayoutStage.prototype.layoutStages;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.CompositeLayoutStage.$class;

/**
 * Appends a {\@link yfiles.layout.ILayoutStage} to the previously added {\@link yfiles.layout.ILayoutStage}s.
 * <p>
 * The added {\@link yfiles.layout.ILayoutStage} will be invoked just before the {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm} will be invoked. Its
 * pre-processing code will be executed after the already added {\@link yfiles.layout.ILayoutStage}s' pre-processing code, while its
 * post-processing code will be executed before the post-processing code of all the other {\@link yfiles.layout.ILayoutStage}s.
 * </p>
 * @param {?} stage the stage to append
 * @return {void}
 */
yfiles.layout.CompositeLayoutStage.prototype.appendStage = function(stage) {};

/**
 * Prepends a {\@link yfiles.layout.ILayoutStage} to the previously added {\@link yfiles.layout.ILayoutStage}s.
 * <p>
 * The added {\@link yfiles.layout.ILayoutStage} will be invoked before any other {\@link yfiles.layout.ILayoutStage}. Its pre-processing
 * code will be executed before the already added {\@link yfiles.layout.ILayoutStage}s' pre-processing code, while its
 * post-processing code will be executed after the post-processing code of all the other {\@link yfiles.layout.ILayoutStage}s.
 * </p>
 * @param {?} stage the stage to prepend
 * @return {void}
 */
yfiles.layout.CompositeLayoutStage.prototype.prependStage = function(stage) {};
/**
 * @record
 * @struct
 */
yfiles.layout.CopiedLayoutGraph = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.CopiedLayoutGraph.$class;

/**
 * Writes the current layout information of all elements of this copied graph to the original graph.
 * @return {void}
 */
yfiles.layout.CopiedLayoutGraph.prototype.commitLayoutToOriginalGraph = function() {};

/**
 * Creates an edge in the copied graph that corresponds to the given original edge.
 * <p>
 * The edge will connect to the copies of the source and target of the original edge. All labels of the original edge will
 * be also copied and assigned to this edge.
 * </p>
 * <p>
 * The mappings are updated. Hence, it is possible to look up the newly created edge by using {\@link yfiles.layout.CopiedLayoutGraph#getCopiedEdge}
 * or the original edge by using {\@link yfiles.layout.CopiedLayoutGraph#getOriginalEdge}.
 * </p>
 * <p>
 * This method can be used for keeping the {\@link yfiles.layout.CopiedLayoutGraph} in sync with the original graph.
 * </p>
 * @param {!Object} originalEdge the original edge
 * @return {!yfiles.algorithms.Edge} the copy of the original edge
 */
yfiles.layout.CopiedLayoutGraph.prototype.createCopiedEdge = function(originalEdge) {};

/**
 * Creates a node in the copied graph that corresponds to the given original node.
 * <p>
 * All labels of the original node will be copied and assigned to this node.
 * </p>
 * <p>
 * The mappings are updated. Hence, it is possible to look up the newly created node by using {\@link yfiles.layout.CopiedLayoutGraph#getCopiedNode}
 * or the original node by using {\@link yfiles.layout.CopiedLayoutGraph#getOriginalNode}.
 * </p>
 * <p>
 * This method can be used for keeping the {\@link yfiles.layout.CopiedLayoutGraph} in sync with the original graph.
 * </p>
 * @param {!Object} originalNode the original node
 * @return {!yfiles.algorithms.Node} the copy of the original node
 */
yfiles.layout.CopiedLayoutGraph.prototype.createCopiedNode = function(originalNode) {};

/**
 * Returns the copied edge that corresponds to the given original edge.
 * @param {!Object} originalEdge an edge of the original graph whose copy resides in this graph
 * @return {!yfiles.algorithms.Edge} an edge in this graph that is the copy of the given original edge
 */
yfiles.layout.CopiedLayoutGraph.prototype.getCopiedEdge = function(originalEdge) {};

/**
 * Returns the copied node that corresponds to the given original node.
 * @param {!Object} originalNode a node of the original graph whose copy resides in this graph
 * @return {!yfiles.algorithms.Node} a node in this graph that is the copy of the given original node
 */
yfiles.layout.CopiedLayoutGraph.prototype.getCopiedNode = function(originalNode) {};

/**
 * Returns the original edge that corresponds to the given copied edge.
 * @param {!yfiles.algorithms.Edge} copiedEdge the edge in this graph that is a copy of the returned edge
 * @return {!Object} the edge in the original graph whose copy is the given edge
 */
yfiles.layout.CopiedLayoutGraph.prototype.getOriginalEdge = function(copiedEdge) {};

/**
 * Returns the original node that corresponds to the given copied node.
 * @param {!yfiles.algorithms.Node} copiedNode the node in this graph that is a copy of the returned node
 * @return {!Object} the node in the original graph whose copy is the given node
 */
yfiles.layout.CopiedLayoutGraph.prototype.getOriginalNode = function(copiedNode) {};

/**
 * Synchronizes the structure of the {\@link yfiles.layout.CopiedLayoutGraph} with the actual structure of the underlying original
 * graph.
 * @return {void}
 */
yfiles.layout.CopiedLayoutGraph.prototype.syncStructure = function() {};
/**
 * @record
 * @struct
 */
yfiles.layout.CurveFittingLayoutStage = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.layout.CurveFittingLayoutStage.DEFAULT_AFFECTED_EDGES_DP_KEY;
 /** @type {number} */
yfiles.layout.CurveFittingLayoutStage.prototype.maximumError;
 /** @type {number} */
yfiles.layout.CurveFittingLayoutStage.prototype.straightControlPointRatio;
 /** @type {!Object} */
yfiles.layout.CurveFittingLayoutStage.prototype.affectedEdgesDpKey;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.CurveFittingLayoutStage.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.DefaultLayoutGraph = function() {};
 /** @type {?} */
yfiles.layout.DefaultLayoutGraph.prototype.nodeLabelMap;
 /** @type {?} */
yfiles.layout.DefaultLayoutGraph.prototype.edgeLabelMap;
 /** @type {?<!Object, !Object>} */
yfiles.layout.DefaultLayoutGraph.prototype.nodeLabelFeatureMap;
 /** @type {?<!Object, !Object>} */
yfiles.layout.DefaultLayoutGraph.prototype.edgeLabelFeatureMap;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.DefaultLayoutGraph.$class;

/**
 * Creates a new implementation of {\@link yfiles.layout.IEdgeLayout}.
 * <p>
 * This method is called by {\@link yfiles.layout.DefaultLayoutGraph#getLayout} if there is no layout information assigned to an
 * edge, yet. It may be overridden to create custom {\@link yfiles.layout.IEdgeLayout}s.
 * </p>
 * @protected
 * @return {?} the layout of an edge
 */
yfiles.layout.DefaultLayoutGraph.prototype.createEdgeLayout = function() {};

/**
 * Creates a new implementation of {\@link yfiles.layout.INodeLayout}.
 * <p>
 * This method is called by {\@link yfiles.layout.DefaultLayoutGraph#getLayout} if there is no layout information assigned to a
 * node, yet. It may be overridden to create custom {\@link yfiles.layout.INodeLayout}s.
 * </p>
 * @protected
 * @return {?} the layout of a node
 */
yfiles.layout.DefaultLayoutGraph.prototype.createNodeLayout = function() {};

/**
 * Specifies the layout information for all associated labels of the given edge.
 * <p>
 * The layout information consists of the location, size and orientation of the label.
 * </p>
 * Specifies the layout information for all associated labels of the given node.
 * <p>
 * The layout information consists of the location, size and orientation of the label.
 * </p>
 * Specifies the layout information for all associated labels of the given node in case there is only one label.
 * <p>
 * The layout information consists of the location, size and orientation of the label.
 * </p>
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} edge_or_node the edge / the node
 * @param {!Array<?>|?} layout the layout information for the labels of the edge / the layout information for the labels of the node / the layout information for the label of the node
 * @return {void}
 */
yfiles.layout.DefaultLayoutGraph.prototype.setLabelLayout = function(edge_or_node, layout) {};

/**
 * Specifies the layout information for the given edge.
 * <p>
 * The layout information consists of the locations of the control and end points of the edge.
 * </p>
 * Specifies the layout information for the given node.
 * <p>
 * The layout information consists of the location and size of the node.
 * </p>
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} edge_or_node the edge / the node
 * @param {?} layout the layout information for the edge / the layout information for the node
 * @return {void}
 */
yfiles.layout.DefaultLayoutGraph.prototype.setLayout = function(edge_or_node, layout) {};
/**
 * @record
 * @struct
 */
yfiles.layout.Direction = function() {};
 /** @type {!yfiles.layout.Direction} */
yfiles.layout.Direction.UP;
 /** @type {!yfiles.layout.Direction} */
yfiles.layout.Direction.RIGHT;
 /** @type {!yfiles.layout.Direction} */
yfiles.layout.Direction.DOWN;
 /** @type {!yfiles.layout.Direction} */
yfiles.layout.Direction.LEFT;
 /** @type {!yfiles.layout.Direction} */
yfiles.layout.Direction.prototype.turnCW;
 /** @type {!yfiles.layout.Direction} */
yfiles.layout.Direction.prototype.turnCCW;
 /** @type {!yfiles.layout.Direction} */
yfiles.layout.Direction.prototype.mirror;
 /** @type {boolean} */
yfiles.layout.Direction.prototype.horizontal;
 /** @type {boolean} */
yfiles.layout.Direction.prototype.vertical;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.Direction.$class;

/**
 * Returns the direction encoded as an integer value.
 * @return {number} <code>0</code> for direction {\@link #UP}, <code>1</code> for {\@link #RIGHT}, <code>2</code> for {\@link #DOWN}, and
 * <code>3</code> for {\@link #LEFT}
 */
yfiles.layout.Direction.prototype.getDirection = function() {};
/**
 * @record
 * @struct
 */
yfiles.layout.DiscreteEdgeLabelLayoutModel = function() {};
 /** @type {yfiles.layout.DiscreteEdgeLabelPositions} */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.candidateMask;
 /** @type {boolean} */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.positionRelativeToSegment;
 /** @type {boolean} */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.autoRotationEnabled;
 /** @type {boolean} */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.autoFlipping;
 /** @type {number} */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.angle;
 /** @type {number} */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.distance;
 /** @type {!Object} */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.defaultParameter;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.DiscreteEdgeLabelLayoutModel.$class;

/**
 *
 * @param {!yfiles.algorithms.YOrientedRectangle} labelBounds
 * @param {?} edgeLayout
 * @param {?} sourceNode
 * @param {?} targetNode
 * @return {!Object}
 */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.createModelParameter = function(labelBounds, edgeLayout, sourceNode, targetNode) {};

/**
 * Returns a model parameter that encodes the specified position.
 * <p>
 * This model parameter can be passed to {\@link yfiles.layout.DiscreteEdgeLabelLayoutModel#getLabelPlacement} to determine the
 * label's position.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the specified position is unknown
 * @param {number} position one of the valid positions
 * @return {!Object} a model parameter that encodes the specified position
 */
yfiles.layout.DiscreteEdgeLabelLayoutModel.createPositionParameter = function(position) {};

/**
 *
 * @param {?} label
 * @param {?} edgeLayout
 * @param {?} sourceNode
 * @param {?} targetNode
 * @return {!yfiles.algorithms.YList}
 */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.getLabelCandidates = function(label, edgeLayout, sourceNode, targetNode) {};

/**
 *
 * @param {!yfiles.algorithms.YDimension} labelSize
 * @param {?} edgeLayout
 * @param {?} sourceNode
 * @param {?} targetNode
 * @param {!Object} param
 * @return {!yfiles.algorithms.YOrientedRectangle}
 */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.getLabelPlacement = function(labelSize, edgeLayout, sourceNode, targetNode, param) {};

/**
 * Returns the oriented box of the label for the given label position.
 * <p>
 * This method is called by {\@link yfiles.layout.DiscreteEdgeLabelLayoutModel#getLabelPlacement} and {\@link yfiles.layout.DiscreteEdgeLabelLayoutModel#getLabelCandidates}
 * to retrieve a valid position.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.YDimension} labelSize the size of the label that should be placed
 * @param {?} edgeLayout the layout of the edge to which the label belongs
 * @param {?} sourceLayout the layout of the source node of the label-owning edge
 * @param {?} targetLayout the layout of the target node of the label-owning edge
 * @param {yfiles.layout.DiscreteEdgeLabelPositions} position the label position that is valid in this model
 * @return {!yfiles.algorithms.YOrientedRectangle} the oriented box of the label
 */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.getLabelPlacementForPosition = function(labelSize, edgeLayout, sourceLayout, targetLayout, position) {};

/**
 * Returns the position specifier that is encoded by the given model parameter.
 * @throws {Stubs.Exceptions.ArgumentError} if the specified model parameter is not valid for this model
 * @param {!Object} parameter the model parameter
 * @return {number} the position specifier
 */
yfiles.layout.DiscreteEdgeLabelLayoutModel.getPosition = function(parameter) {};

/**
 * Checks whether or not the given model parameter encodes a valid edge label position for this model.
 * <p>
 * If the model parameter describes a position that is accepted by the candidate mask, this is a valid parameter.
 * </p>
 * @param {!Object} parameter the model parameter
 * @return {boolean} <code>true</code> if the label position described by the given model parameter is allowed, <code>false</code> otherwise
 */
yfiles.layout.DiscreteEdgeLabelLayoutModel.prototype.isParameterValid = function(parameter) {};
/**
 * @record
 * @struct
 */
yfiles.layout.DiscreteNodeLabelLayoutModel = function() {};
 /** @type {yfiles.layout.DiscreteNodeLabelPositions} */
yfiles.layout.DiscreteNodeLabelLayoutModel.prototype.candidateMask;
 /** @type {number} */
yfiles.layout.DiscreteNodeLabelLayoutModel.prototype.distance;
 /** @type {!Object} */
yfiles.layout.DiscreteNodeLabelLayoutModel.prototype.defaultParameter;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.DiscreteNodeLabelLayoutModel.$class;

/**
 *
 * @param {!yfiles.algorithms.YOrientedRectangle} labelBounds
 * @param {?} nodeLayout
 * @return {!Object}
 */
yfiles.layout.DiscreteNodeLabelLayoutModel.prototype.createModelParameter = function(labelBounds, nodeLayout) {};

/**
 *
 * @param {?} labelLayout
 * @param {?} nodeLayout
 * @return {!yfiles.algorithms.YList}
 */
yfiles.layout.DiscreteNodeLabelLayoutModel.prototype.getLabelCandidates = function(labelLayout, nodeLayout) {};

/**
 *
 * @param {!yfiles.algorithms.YDimension} labelSize
 * @param {?} nodeLayout
 * @param {!Object} parameter
 * @return {!yfiles.algorithms.YOrientedRectangle}
 */
yfiles.layout.DiscreteNodeLabelLayoutModel.prototype.getLabelPlacement = function(labelSize, nodeLayout, parameter) {};

/**
 * Returns the oriented box of the label for the given label position.
 * <p>
 * This method is called by {\@link yfiles.layout.DiscreteNodeLabelLayoutModel#getLabelPlacement} and {\@link yfiles.layout.DiscreteNodeLabelLayoutModel#getLabelCandidates}
 * to retrieve a valid position.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.YDimension} labelSize the size of the label that should be placed
 * @param {?} nodeLayout the layout of the node to which the label belongs
 * @param {yfiles.layout.DiscreteNodeLabelPositions} position the label position that is valid in this model
 * @return {!yfiles.algorithms.YOrientedRectangle} the oriented box of the label
 */
yfiles.layout.DiscreteNodeLabelLayoutModel.prototype.getLabelPlacementForPosition = function(labelSize, nodeLayout, position) {};

/**
 * Checks whether or not the given model parameter encodes a valid node label position for this model.
 * <p>
 * If the model parameter describes a position that is accepted by the candidate mask, this is a valid parameter.
 * </p>
 * @param {!Object} parameter the model parameter
 * @return {boolean} <code>true</code> if the label position described by the given model parameter is allowed, <code>false</code> otherwise
 */
yfiles.layout.DiscreteNodeLabelLayoutModel.prototype.isParameterValid = function(parameter) {};
/**
 * @record
 * @struct
 */
yfiles.layout.EdgeBundleDescriptor = function() {};
 /** @type {boolean} */
yfiles.layout.EdgeBundleDescriptor.prototype.considerDirection;
 /** @type {boolean} */
yfiles.layout.EdgeBundleDescriptor.prototype.bundled;
 /** @type {boolean} */
yfiles.layout.EdgeBundleDescriptor.prototype.bezierFitting;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.EdgeBundleDescriptor.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.EdgeBundling = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.layout.EdgeBundleDescriptor>} */
yfiles.layout.EdgeBundling.EDGE_BUNDLE_DESCRIPTOR_DP_KEY;
 /** @type {number} */
yfiles.layout.EdgeBundling.prototype.bundlingQuality;
 /** @type {number} */
yfiles.layout.EdgeBundling.prototype.bundlingStrength;
 /** @type {!yfiles.layout.EdgeBundleDescriptor} */
yfiles.layout.EdgeBundling.prototype.defaultBundleDescriptor;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.EdgeBundling.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.EdgeLabelCandidate = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.EdgeLabelCandidate.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.EdgeLabelOrientationSupport = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.EdgeLabelOrientationSupport.$class;

/**
 * Creates and returns a non-ambiguous {\@link yfiles.layout.PreferredPlacementDescriptor} of the given potentially ambiguous one.
 * <p>
 * The created descriptor will be one without any combinations of settings, e.g., source or target for the {\@link yfiles.layout.PreferredPlacementDescriptor#placeAlongEdge}.
 * </p>
 * @protected
 * @param {!yfiles.layout.PreferredPlacementDescriptor} ambiguous an ambiguous {\@link }
 * @return {!yfiles.layout.PreferredPlacementDescriptor} a non-ambiguous version of the given ambiguous {\@link }
 */
yfiles.layout.EdgeLabelOrientationSupport.prototype.createNonAmbiguous = function(ambiguous) {};

/**
 * Calculates the up vector of an edge label considering the preferred placement of the label as well as the direction of
 * the edge segment the label is attached to.
 * @param {!yfiles.layout.PreferredPlacementDescriptor} descriptor the data describing the preferred label orientation
 * @param {!yfiles.layout.Direction} segmentDirection the direction the edge segment is pointing to
 * @return {!yfiles.algorithms.YVector} the up vector for the edge label that considers the preferred placement of the label as well as the direction of the
 * edge segment the label is attached to
 */
yfiles.layout.EdgeLabelOrientationSupport.getEdgeLabelUpVector = function(descriptor, segmentDirection) {};

/**
 * Calculates the up vector for a label whose right vector is rotated clockwise by the given angle.
 * <p>
 * The up vector starts in the lower-left corner of the label and points up. If the label is paraxial it is <code>(0, -1)</code>. The
 * right vector starts at the same point and points right. In a paraxial label it is <code>(1, 0)</code>.
 * </p>
 * @param {number} rightVectorAngle the angle in radians the right vector is rotated by
 * @return {!yfiles.algorithms.YVector} the up vector for a label whose right vector is rotated clockwise by the given angle
 */
yfiles.layout.EdgeLabelOrientationSupport.getLabelUpVector = function(rightVectorAngle) {};

/**
 * Transforms a direction of the layout to the oriented layout direction.
 * @param {!yfiles.layout.Direction} direction direction in the layout
 * @param {yfiles.layout.LayoutOrientation} orientation the orientation of the layout
 * @param {yfiles.layout.MirrorModes} mirrorMask the mask to determine whether or not the orientation is mirrored
 * @return {!yfiles.layout.Direction} the direction in the oriented layout
 */
yfiles.layout.EdgeLabelOrientationSupport.getOrientedDirection = function(direction, orientation, mirrorMask) {};

/**
 * Returns whether or not the orientation is mirrored.
 * @param {yfiles.layout.LayoutOrientation} orientation the orientation of the layout
 * @param {yfiles.layout.MirrorModes} mirrorMask the mask to determine whether or not the orientation is mirrored
 * @return {boolean} <code>true</code> if the orientation is mirrored, <code>false</code> otherwise
 */
yfiles.layout.EdgeLabelOrientationSupport.isOrientationMirrored = function(orientation, mirrorMask) {};

/**
 * Marks the given port label for a non-port placement (fallback).
 * <p>
 * The given edge label's {\@link yfiles.layout.PreferredPlacementDescriptor} will internally be changed such that its {\@link yfiles.layout.PreferredPlacementDescriptor#placeAlongEdge placement along edge}
 * is either {\@link yfiles.layout.LabelPlacements#AT_SOURCE} or {\@link yfiles.layout.LabelPlacements#AT_TARGET}.
 * </p>
 * <p>
 * Algorithms that are executed after this call and before {\@link yfiles.layout.EdgeLabelOrientationSupport#resetAmbiguousLabelDescriptors}
 * will handle port labels like normal source or target labels.
 * </p>
 * @throws {Stubs.Exceptions.InvalidOperationError} if {\@link yfiles.layout.EdgeLabelOrientationSupport#replaceAmbiguousLabelDescriptors} was never called for the graph containing
 * the given label.
 * @see yfiles.layout.LabelPlacements#AT_SOURCE_PORT
 * @see yfiles.layout.LabelPlacements#AT_TARGET_PORT
 * @param {!yfiles.layout.LabelLayoutData} portLabel an edge label that had a {\@link #AT_SOURCE_PORT} or {\@link #AT_TARGET_PORT}
 * placement preference
 * @return {void}
 */
yfiles.layout.EdgeLabelOrientationSupport.prototype.markPortLabelForFallbackPlacement = function(portLabel) {};

/**
 * Restores the original preferred placement and updates the label rotation according to the layout orientation.
 * <p>
 * The original {\@link yfiles.layout.LabelLayoutData#preferredPlacementDescriptor} that has been replaced in {\@link yfiles.layout.EdgeLabelOrientationSupport#preProcessLabel} gets restored. Then it
 * moves and rotates the {\@link yfiles.layout.LabelLayoutData#bounds label box} in respect of the orientation.
 * </p>
 * <p>
 * This method is called by the core layout algorithm with the integrated edge labeling for each edge label after the
 * location of the label is determined.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the graph to get the orientation information from
 * @param {!yfiles.layout.LabelLayoutData} label the information about the edge label whose location is determined
 * @return {void}
 */
yfiles.layout.EdgeLabelOrientationSupport.prototype.postProcessLabel = function(graph, label) {};

/**
 * Prepares the label for the core layout algorithm.
 * <p>
 * First, the {\@link yfiles.layout.LabelLayoutData#preferredPlacementDescriptor preferred placement} of the edge label is replaced by a non-ambiguous {\@link yfiles.layout.PreferredPlacementDescriptor}
 * that has only relative references. This descriptor is orientation independent and can be used in the core layout
 * algorithm. Second, the method rotates the {\@link yfiles.layout.LabelLayoutData#bounds label box} in respect of its {\@link yfiles.layout.PreferredPlacementDescriptor} and the
 * direction of the segment to which it belongs. After that call, the core layout algorithm can use the geometry ({\@link yfiles.layout.LabelLayoutData#width} and
 * {\@link yfiles.layout.LabelLayoutData#height}) of the label to calculate its location.
 * </p>
 * <p>
 * This method is called by the core layout algorithm with the integrated edge labeling for each edge label before the
 * layout algorithm uses the geometry of labels. It should be called as soon as the direction of the segment the label
 * belongs to is determined.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the graph to get the orientation information from
 * @param {!yfiles.layout.LabelLayoutData} label the information about the edge label whose segment direction is determined
 * @param {!yfiles.layout.Direction} segmentDirection the direction of the segment the edge label belongs to
 * @return {void}
 */
yfiles.layout.EdgeLabelOrientationSupport.prototype.preProcessLabel = function(graph, label, segmentDirection) {};

/**
 * Replaces the
 * {\@link yfiles.layout.PreferredPlacementDescriptor}s of all edge labels in the given graph with non-ambiguous descriptors.
 * <p>
 * The non-ambiguous descriptors are retrieved from the original descriptors. They describe only one of the possible
 * placements.
 * </p>
 * <p>
 * This method should be called by a layout algorithm at the beginning of the layout calculation to assure that the label's
 * placement is handled consistently.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {void}
 */
yfiles.layout.EdgeLabelOrientationSupport.prototype.replaceAmbiguousLabelDescriptors = function(graph) {};

/**
 * Restores the
 * {\@link yfiles.layout.PreferredPlacementDescriptor}s of all edge labels in the given graph with their original descriptors.
 * <p>
 * This method should be called by a layout algorithm at the end of the layout calculation to assure that the original
 * state of the graph is not corrupted.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {void}
 */
yfiles.layout.EdgeLabelOrientationSupport.prototype.resetAmbiguousLabelDescriptors = function(graph) {};

/**
 * Calculates and sets the up vector of an edge label considering the preferred placement of the label as well as the
 * direction of the edge segment the label is attached to.
 * @see yfiles.layout.EdgeLabelOrientationSupport#getEdgeLabelUpVector
 * @param {!yfiles.layout.LabelLayoutData} label the data that describes the label orientation and is used for setting the new up vector
 * @param {!yfiles.layout.Direction} segmentDirection the direction the edge segment is pointing to
 * @return {void}
 */
yfiles.layout.EdgeLabelOrientationSupport.updateLabelOrientation = function(label, segmentDirection) {};
/**
 * @record
 * @struct
 */
yfiles.layout.FixNodeLayoutStage = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.layout.FixNodeLayoutStage.FIXED_NODE_DP_KEY;
 /** @type {yfiles.layout.FixPointPolicy} */
yfiles.layout.FixNodeLayoutStage.prototype.fixPointPolicy;
 /** @type {boolean} */
yfiles.layout.FixNodeLayoutStage.prototype.includingEdges;
 /** @type {boolean} */
yfiles.layout.FixNodeLayoutStage.prototype.includingLabels;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.FixNodeLayoutStage.$class;

/**
 * Calculates the bounding box of the specified nodes.
 * <p>
 * The calculated bounds may contain {\@link yfiles.layout.FixNodeLayoutStage#includingEdges edges} and/or {\@link yfiles.layout.FixNodeLayoutStage#includingLabels labels}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.layout.FixNodeLayoutStage#calculateFixPoint} and may be overridden to customize the size
 * of the bounds.
 * </p>
 * @see yfiles.layout.FixNodeLayoutStage#includingEdges
 * @see yfiles.layout.FixNodeLayoutStage#includingLabels
 * @see yfiles.layout.FixNodeLayoutStage#calculateFixPoint
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the graph associated with the specified nodes
 * @param {!yfiles.algorithms.NodeList} fixed the list of nodes for which to determine the bounding box
 * @return {!yfiles.algorithms.Rectangle2D} the bounding box of the specified nodes
 */
yfiles.layout.FixNodeLayoutStage.prototype.calculateBounds = function(graph, fixed) {};

/**
 * Calculates the fix point for the specified nodes in the specified graph.
 * <p>
 * The default implementation calls {\@link yfiles.layout.FixNodeLayoutStage#calculateBounds} and
 * {\@link yfiles.layout.FixNodeLayoutStage#calculateFixPoint}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.layout.FixNodeLayoutStage#applyLayout} to determine the point that will have the same
 * coordinates before and after invoking the
 * {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm}. It may be overridden to introduce a custom policy for retrieving the fix point.
 * </p>
 * @see yfiles.layout.FixNodeLayoutStage#fixPointPolicy
 * @see yfiles.layout.FixNodeLayoutStage#calculateBounds
 * @see yfiles.layout.FixNodeLayoutStage#calculateFixPoint
 * @protected
 * Calculates the fix point of the specified rectangle according to the policy returned by {\@link yfiles.layout.FixNodeLayoutStage#fixPointPolicy}.
 * <p>
 * If the specified rectangle is <code>null</code> or the rectangle has negative <code>width</code> or negative <code>height</code> then <code>null</code> will be returned.
 * </p>
 * <p>
 * This method is called by
 * {\@link yfiles.layout.FixNodeLayoutStage#calculateFixPoint}. It may be overridden to introduce a custom policy for retrieving the
 * fix point.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the current fix point policy is invalid
 * @see yfiles.layout.FixNodeLayoutStage#fixPointPolicy
 * @protected
 * @param {!yfiles.layout.LayoutGraph|!yfiles.algorithms.Rectangle2D} graph_or_bounds the graph associated with the specified nodes / the rectangle for which to determine the fix point
 * @param {!yfiles.algorithms.NodeList=} fixed the list of nodes for which a fix point has to be determined
 * @return {!yfiles.algorithms.YPoint} the fix point for the specified nodes in the specified graph / the fix point of the specified rectangle or <code>null</code> if nothing should be fixed
 */
yfiles.layout.FixNodeLayoutStage.prototype.calculateFixPoint = function(graph_or_bounds, fixed) {};
/**
 * @record
 * @struct
 */
yfiles.layout.FixPortLocationStage = function() {};
 /** @type {boolean} */
yfiles.layout.FixPortLocationStage.prototype.keepCalculatedPorts;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.FixPortLocationStage.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.FreeEdgeLabelLayoutModelParameter = function() {};
 /** @type {number} */
yfiles.layout.FreeEdgeLabelLayoutModelParameter.prototype.angle;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.layout.FreeEdgeLabelLayoutModelParameter.prototype.point;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.FreeEdgeLabelLayoutModelParameter.$class;

/**
 * Specifies a point that represents the location of the label's center in relation to the source point of the edge.
 * <p>
 * The x-coordinate corresponds to the radius which describes the distance of the label to the source point. The
 * y-coordinate corresponds to the angle between the first segment of the underlying edge and the imaginary line to the
 * center of the label.
 * </p>
 * @param {number} radius the distance to the source point
 * @param {number} theta the location on the radius
 * @return {void}
 */
yfiles.layout.FreeEdgeLabelLayoutModelParameter.prototype.setPoint = function(radius, theta) {};
/**
 * @record
 * @struct
 */
yfiles.layout.FreeEdgeLabelLayoutModel = function() {};
 /** @type {!Object} */
yfiles.layout.FreeEdgeLabelLayoutModel.prototype.defaultParameter;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.FreeEdgeLabelLayoutModel.$class;

/**
 * Creates a model parameter that represents the given edge label position within this model.
 * <p>
 * The created model parameter represents the current location of the given label.
 * </p>
 * <p>
 * This parameter can be passed to {\@link yfiles.layout.FreeEdgeLabelLayoutModel#getLabelPlacement} to retrieve the current label
 * box.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if one or more of the given bounds' values are invalid, i.e., <code>NaN</code>
 * @see yfiles.layout.FreeEdgeLabelLayoutModel#getLabelPlacement
 * @param {!yfiles.algorithms.YOrientedRectangle} labelBounds the oriented box of the label the parameter represents
 * @param {?} edgeLayout the layout of the edge to which the label belongs
 * @param {?} sourceLayout the layout of the source node of the label-owning edge
 * @param {?} targetLayout the layout of the target node of the label-owning edge
 * @return {!Object} the model parameter representing the given label location
 */
yfiles.layout.FreeEdgeLabelLayoutModel.prototype.createModelParameter = function(labelBounds, edgeLayout, sourceLayout, targetLayout) {};

/**
 * Returns the {\@link yfiles.layout.EdgeLabelCandidate} that describes the current label position.
 * @param {?} labelLayout the label for which candidates should be generated
 * @param {?} edgeLayout the layout of the edge to which the label belongs
 * @param {?} sourceLayout the layout of the source node of the label-owning edge
 * @param {?} targetLayout the layout of the target node of the label-owning edge
 * @return {!yfiles.algorithms.YList} a list of {\@link } instances
 */
yfiles.layout.FreeEdgeLabelLayoutModel.prototype.getLabelCandidates = function(labelLayout, edgeLayout, sourceLayout, targetLayout) {};

/**
 *
 * @param {!yfiles.algorithms.YDimension} labelSize
 * @param {?} edgeLayout
 * @param {?} sourceNode
 * @param {?} targetNode
 * @param {!Object} param
 * @return {!yfiles.algorithms.YOrientedRectangle}
 */
yfiles.layout.FreeEdgeLabelLayoutModel.prototype.getLabelPlacement = function(labelSize, edgeLayout, sourceNode, targetNode, param) {};
/**
 * @record
 * @struct
 */
yfiles.layout.FreeNodeLabelLayoutModelParameter = function() {};
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.layout.FreeNodeLabelLayoutModelParameter.prototype.point;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.FreeNodeLabelLayoutModelParameter.$class;

/**
 * Specifies the offset of the label's center to the upper-left corner of the node.
 * @param {number} dx the horizontal offset
 * @param {number} dy the vertical offset
 * @return {void}
 */
yfiles.layout.FreeNodeLabelLayoutModelParameter.prototype.setPoint = function(dx, dy) {};
/**
 * @record
 * @struct
 */
yfiles.layout.FreeNodeLabelLayoutModel = function() {};
 /** @type {!Object} */
yfiles.layout.FreeNodeLabelLayoutModel.prototype.defaultParameter;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.FreeNodeLabelLayoutModel.$class;

/**
 * Creates a model parameter that represents the given node label position within this model.
 * <p>
 * The created model parameter represents the current location of the given label.
 * </p>
 * <p>
 * This parameter can be passed to {\@link yfiles.layout.FreeNodeLabelLayoutModel#getLabelPlacement} to retrieve the current label
 * box.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if one or more of the given bounds' values are invalid, i.e., <code>NaN</code>
 * @see yfiles.layout.FreeNodeLabelLayoutModel#getLabelPlacement
 * @param {!yfiles.algorithms.YOrientedRectangle} labelBounds the bounds of the label the parameter represents
 * @param {?} nodeLayout the layout of the node to which the label belongs
 * @return {!Object} the model parameter
 */
yfiles.layout.FreeNodeLabelLayoutModel.prototype.createModelParameter = function(labelBounds, nodeLayout) {};

/**
 * Returns the {\@link yfiles.layout.NodeLabelCandidate} that describes the current label position.
 * @param {?} labelLayout the label for which candidates should be generated
 * @param {?} nodeLayout the layout of the node to which the label belongs
 * @return {!yfiles.algorithms.YList} a list of {\@link } instances
 */
yfiles.layout.FreeNodeLabelLayoutModel.prototype.getLabelCandidates = function(labelLayout, nodeLayout) {};

/**
 *
 * @param {!yfiles.algorithms.YDimension} labelSize
 * @param {?} nodeLayout
 * @param {!Object} param
 * @return {!yfiles.algorithms.YOrientedRectangle}
 */
yfiles.layout.FreeNodeLabelLayoutModel.prototype.getLabelPlacement = function(labelSize, nodeLayout, param) {};

/** @const */
yfiles.layout.ComponentArrangementStyles = {};
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.NONE;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.ROWS;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.SINGLE_ROW;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.SINGLE_COLUMN;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.PACKED_RECTANGLE;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.PACKED_COMPACT_RECTANGLE;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.PACKED_CIRCLE;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.PACKED_COMPACT_CIRCLE;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.MULTI_ROWS;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.MULTI_ROWS_COMPACT;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.MULTI_ROWS_HEIGHT_CONSTRAINT;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.MULTI_ROWS_HEIGHT_CONSTRAINT_COMPACT;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.MULTI_ROWS_WIDTH_CONSTRAINT;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.MULTI_ROWS_WIDTH_CONSTRAINT_COMPACT;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.MASK;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.MODIFIER_AS_IS;
/** @const {number} */
yfiles.layout.ComponentArrangementStyles.MODIFIER_NO_OVERLAP;

/** @const */
yfiles.layout.DiscreteEdgeLabelPositions = {};
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.SOURCE_HEAD;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.HEAD;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.TARGET_HEAD;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.SOURCE_TAIL;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.TAIL;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.TARGET_TAIL;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.SOURCE_CENTER;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.CENTER;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.TARGET_CENTER;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.TWO_POS;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.CENTERED;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.SIX_POS;
/** @const {number} */
yfiles.layout.DiscreteEdgeLabelPositions.THREE_CENTER;

/** @const */
yfiles.layout.DiscreteNodeLabelPositions = {};
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.NORTH;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.NORTH_WEST;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.NORTH_EAST;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.EAST;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.WEST;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.SOUTH;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.SOUTH_WEST;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.SOUTH_EAST;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.CENTER;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.BOTTOM;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.TOP;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.LEFT;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.RIGHT;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.TOP_LEFT;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.TOP_RIGHT;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.BOTTOM_LEFT;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.BOTTOM_RIGHT;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.SANDWICH_MASK;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.INTERNAL_MASK;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.SIDES_MASK;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.CORNER_MASK;
/** @const {number} */
yfiles.layout.DiscreteNodeLabelPositions.EIGHT_POS_MASK;

/** @const */
yfiles.layout.FixPointPolicy = {};
/** @const {number} */
yfiles.layout.FixPointPolicy.CENTER;
/** @const {number} */
yfiles.layout.FixPointPolicy.UPPER_LEFT;
/** @const {number} */
yfiles.layout.FixPointPolicy.UPPER_RIGHT;
/** @const {number} */
yfiles.layout.FixPointPolicy.LOWER_RIGHT;
/** @const {number} */
yfiles.layout.FixPointPolicy.LOWER_LEFT;

/** @const */
yfiles.layout.LabelPlacements = {};
/** @const {number} */
yfiles.layout.LabelPlacements.AT_SOURCE;
/** @const {number} */
yfiles.layout.LabelPlacements.AT_TARGET;
/** @const {number} */
yfiles.layout.LabelPlacements.AT_CENTER;
/** @const {number} */
yfiles.layout.LabelPlacements.AT_SOURCE_PORT;
/** @const {number} */
yfiles.layout.LabelPlacements.AT_TARGET_PORT;
/** @const {number} */
yfiles.layout.LabelPlacements.ALONG_EDGE_MASK;
/** @const {number} */
yfiles.layout.LabelPlacements.ON_EDGE;
/** @const {number} */
yfiles.layout.LabelPlacements.LEFT_OF_EDGE;
/** @const {number} */
yfiles.layout.LabelPlacements.RIGHT_OF_EDGE;
/** @const {number} */
yfiles.layout.LabelPlacements.ON_SIDE_OF_EDGE_MASK;
/** @const {number} */
yfiles.layout.LabelPlacements.ANYWHERE;

/** @const */
yfiles.layout.LayoutOrientation = {};
/** @const {number} */
yfiles.layout.LayoutOrientation.TOP_TO_BOTTOM;
/** @const {number} */
yfiles.layout.LayoutOrientation.LEFT_TO_RIGHT;
/** @const {number} */
yfiles.layout.LayoutOrientation.RIGHT_TO_LEFT;
/** @const {number} */
yfiles.layout.LayoutOrientation.BOTTOM_TO_TOP;

/** @const */
yfiles.layout.RowAlignment = {};
/** @const {number} */
yfiles.layout.RowAlignment.LEADING;
/** @const {number} */
yfiles.layout.RowAlignment.TRAILING;
/** @const {number} */
yfiles.layout.RowAlignment.JUSTIFIED;
/** @const {number} */
yfiles.layout.RowAlignment.CENTER;

/** @const */
yfiles.layout.MultiRowConstraint = {};
/** @const {number} */
yfiles.layout.MultiRowConstraint.NONE;
/** @const {number} */
yfiles.layout.MultiRowConstraint.HEIGHT;
/** @const {number} */
yfiles.layout.MultiRowConstraint.WIDTH;

/** @const */
yfiles.layout.EdgeFlow = {};
/** @const {number} */
yfiles.layout.EdgeFlow.UP;
/** @const {number} */
yfiles.layout.EdgeFlow.DOWN;
/** @const {number} */
yfiles.layout.EdgeFlow.LEFT;
/** @const {number} */
yfiles.layout.EdgeFlow.RIGHT;
/** @const {number} */
yfiles.layout.EdgeFlow.NONE;

/** @const */
yfiles.layout.NodeAlignment = {};
/** @const {number} */
yfiles.layout.NodeAlignment.LEADING;
/** @const {number} */
yfiles.layout.NodeAlignment.CENTERED;
/** @const {number} */
yfiles.layout.NodeAlignment.TRAILING;
/** @const {number} */
yfiles.layout.NodeAlignment.DISTRIBUTED;

/** @const */
yfiles.layout.MirrorModes = {};
/** @const {number} */
yfiles.layout.MirrorModes.NONE;
/** @const {number} */
yfiles.layout.MirrorModes.TOP_TO_BOTTOM;
/** @const {number} */
yfiles.layout.MirrorModes.RIGHT_TO_LEFT;
/** @const {number} */
yfiles.layout.MirrorModes.BOTTOM_TO_TOP;
/** @const {number} */
yfiles.layout.MirrorModes.LEFT_TO_RIGHT;

/** @const */
yfiles.layout.PortDirections = {};
/** @const {number} */
yfiles.layout.PortDirections.NORTH;
/** @const {number} */
yfiles.layout.PortDirections.EAST;
/** @const {number} */
yfiles.layout.PortDirections.WEST;
/** @const {number} */
yfiles.layout.PortDirections.SOUTH;
/** @const {number} */
yfiles.layout.PortDirections.WITH_THE_FLOW;
/** @const {number} */
yfiles.layout.PortDirections.AGAINST_THE_FLOW;
/** @const {number} */
yfiles.layout.PortDirections.LEFT_IN_FLOW;
/** @const {number} */
yfiles.layout.PortDirections.RIGHT_IN_FLOW;
/** @const {number} */
yfiles.layout.PortDirections.ANY;

/** @const */
yfiles.layout.PortSide = {};
/** @const {number} */
yfiles.layout.PortSide.ANY;
/** @const {number} */
yfiles.layout.PortSide.NORTH;
/** @const {number} */
yfiles.layout.PortSide.SOUTH;
/** @const {number} */
yfiles.layout.PortSide.EAST;
/** @const {number} */
yfiles.layout.PortSide.WEST;

/** @const */
yfiles.layout.LabelSideReferences = {};
/** @const {number} */
yfiles.layout.LabelSideReferences.RELATIVE_TO_EDGE_FLOW;
/** @const {number} */
yfiles.layout.LabelSideReferences.ABSOLUTE_WITH_LEFT_IN_NORTH;
/** @const {number} */
yfiles.layout.LabelSideReferences.ABSOLUTE_WITH_RIGHT_IN_NORTH;

/** @const */
yfiles.layout.LabelAngleReferences = {};
/** @const {number} */
yfiles.layout.LabelAngleReferences.ABSOLUTE;
/** @const {number} */
yfiles.layout.LabelAngleReferences.RELATIVE_TO_EDGE_FLOW;

/** @const */
yfiles.layout.LabelAngleOnRightSideRotations = {};
/** @const {number} */
yfiles.layout.LabelAngleOnRightSideRotations.CLOCKWISE;
/** @const {number} */
yfiles.layout.LabelAngleOnRightSideRotations.COUNTER_CLOCKWISE;

/** @const */
yfiles.layout.LabelAngleOnRightSideOffsets = {};
/** @const {number} */
yfiles.layout.LabelAngleOnRightSideOffsets.NONE;
/** @const {number} */
yfiles.layout.LabelAngleOnRightSideOffsets.SEMI;

/** @const */
yfiles.layout.SliderMode = {};
/** @const {number} */
yfiles.layout.SliderMode.CENTER;
/** @const {number} */
yfiles.layout.SliderMode.SIDE;
/** @const {number} */
yfiles.layout.SliderMode.SINGLE_SIDE;

/** @const */
yfiles.layout.SelfLoopStyle = {};
/** @const {number} */
yfiles.layout.SelfLoopStyle.ORTHOGONAL;
/** @const {number} */
yfiles.layout.SelfLoopStyle.ROUNDED;

/** @const */
yfiles.layout.SwimlanesMode = {};
/** @const {number} */
yfiles.layout.SwimlanesMode.IGNORE_GROUPS;
/** @const {number} */
yfiles.layout.SwimlanesMode.ONLY_GROUPS;
/** @const {number} */
yfiles.layout.SwimlanesMode.MIXED;
/**
 * @record
 * @struct
 */
yfiles.layout.GraphLayoutLineWrapper = function() {};
 /** @type {number} */
yfiles.layout.GraphLayoutLineWrapper.prototype.edgeSpacing;
 /** @type {boolean} */
yfiles.layout.GraphLayoutLineWrapper.prototype.columnMode;
 /** @type {number} */
yfiles.layout.GraphLayoutLineWrapper.prototype.spacing;
 /** @type {boolean} */
yfiles.layout.GraphLayoutLineWrapper.prototype.mirror;
 /** @type {boolean} */
yfiles.layout.GraphLayoutLineWrapper.prototype.fixedWidthLineBreaks;
 /** @type {number} */
yfiles.layout.GraphLayoutLineWrapper.prototype.targetRatio;
 /** @type {number} */
yfiles.layout.GraphLayoutLineWrapper.prototype.fixedWidth;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.GraphLayoutLineWrapper.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ColumnDescriptor = function() {};
 /** @type {number} */
yfiles.layout.ColumnDescriptor.prototype.index;
 /** @type {number} */
yfiles.layout.ColumnDescriptor.prototype.minimumWidth;
 /** @type {number} */
yfiles.layout.ColumnDescriptor.prototype.leftInset;
 /** @type {number} */
yfiles.layout.ColumnDescriptor.prototype.rightInset;
 /** @type {number} */
yfiles.layout.ColumnDescriptor.prototype.computedWidth;
 /** @type {number} */
yfiles.layout.ColumnDescriptor.prototype.originalWidth;
 /** @type {number} */
yfiles.layout.ColumnDescriptor.prototype.originalPosition;
 /** @type {number} */
yfiles.layout.ColumnDescriptor.prototype.computedPosition;
 /** @type {number} */
yfiles.layout.ColumnDescriptor.prototype.tightness;
 /** @type {boolean} */
yfiles.layout.ColumnDescriptor.prototype.indexFixed;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ColumnDescriptor.$class;

/**
 * Compares this {\@link yfiles.layout.ColumnDescriptor} instance with a given other {\@link yfiles.layout.ColumnDescriptor} instance based
 * on the indices of the two instances.
 * @param {!Object} o the {\@link } to compare to
 * @return {number} <code>-1</code>, <code>0</code> or <code>1</code> if this {\@link } is less than, equal to, or greater than the given other
 * {\@link }
 */
yfiles.layout.ColumnDescriptor.prototype.compareTo = function(o) {};
/**
 * @record
 * @struct
 */
yfiles.layout.PartitionCellIdEntry = function() {};
 /** @type {!yfiles.layout.RowDescriptor} */
yfiles.layout.PartitionCellIdEntry.prototype.row;
 /** @type {!yfiles.layout.ColumnDescriptor} */
yfiles.layout.PartitionCellIdEntry.prototype.column;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PartitionCellIdEntry.$class;

/**
 * Compares this {\@link yfiles.layout.PartitionCellIdEntry} instance with a given other {\@link yfiles.layout.PartitionCellIdEntry}
 * instance.
 * <p>
 * The comparison is based on the indices of the {\@link yfiles.layout.PartitionCellIdEntry#row rows} and {\@link yfiles.layout.PartitionCellIdEntry#column columns} of the two pairs. A {\@link yfiles.layout.PartitionCellIdEntry} is
 * considered to be smaller than another pair if its {\@link yfiles.layout.RowDescriptor#index row index} is smaller than the row index of the other pair. If the row
 * indices are equal, the {\@link yfiles.layout.PartitionCellIdEntry} with the smaller {\@link yfiles.layout.ColumnDescriptor#index column index} is said to be smaller. Hence,
 * two {\@link yfiles.layout.PartitionCellIdEntry} instances are equal, if the row and column indices are equal.
 * </p>
 * @param {!Object} o the {\@link } to be compared
 * @return {number} <code>-1</code>, <code>0</code> or <code>1</code> if this {\@link } is smaller than, equal to, or greater than the given other {\@link }
 * instance
 */
yfiles.layout.PartitionCellIdEntry.prototype.compareTo = function(o) {};
/**
 * @record
 * @struct
 */
yfiles.layout.PartitionCellId = function() {};
 /** @type {?<!yfiles.layout.PartitionCellIdEntry>} */
yfiles.layout.PartitionCellId.prototype.cells;
 /** @type {boolean} */
yfiles.layout.PartitionCellId.prototype.isSpanning;
 /** @type {!yfiles.layout.RowDescriptor} */
yfiles.layout.PartitionCellId.prototype.row;
 /** @type {!yfiles.layout.ColumnDescriptor} */
yfiles.layout.PartitionCellId.prototype.column;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PartitionCellId.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.PartitionGrid = function() {};
 /** @type {!yfiles.algorithms.GraphDpKey<!yfiles.layout.PartitionGrid>} */
yfiles.layout.PartitionGrid.PARTITION_GRID_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.layout.PartitionCellId>} */
yfiles.layout.PartitionGrid.PARTITION_CELL_ID_DP_KEY;
 /** @type {boolean} */
yfiles.layout.PartitionGrid.prototype.optimizeColumnOrder;
 /** @type {boolean} */
yfiles.layout.PartitionGrid.prototype.optimizeRowOrder;
 /** @type {!yfiles.algorithms.YList} */
yfiles.layout.PartitionGrid.prototype.rows;
 /** @type {!yfiles.algorithms.YList} */
yfiles.layout.PartitionGrid.prototype.columns;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PartitionGrid.$class;

/**
 * Adds a new {\@link yfiles.layout.ColumnDescriptor column} to the {\@link yfiles.layout.PartitionGrid} instance.
 * <p>
 * The index of the column (as returned by {\@link yfiles.layout.ColumnDescriptor#index}) is equal to the size of the list returned by {\@link yfiles.layout.PartitionGrid#columns}.
 * </p>
 * @return {!yfiles.layout.ColumnDescriptor} a new {\@link } instance
 */
yfiles.layout.PartitionGrid.prototype.addColumn = function() {};

/**
 * Adds a new {\@link yfiles.layout.RowDescriptor row} to the {\@link yfiles.layout.PartitionGrid} instance.
 * <p>
 * The index of the row (as returned by {\@link yfiles.layout.RowDescriptor#index}) is equal to the size of the list returned by {\@link yfiles.layout.PartitionGrid#rows}.
 * </p>
 * @return {!yfiles.layout.RowDescriptor} a new {\@link } instance
 */
yfiles.layout.PartitionGrid.prototype.addRow = function() {};

/**
 * Creates a {\@link yfiles.layout.PartitionCellId partition cell} identifier that represents the cell defined by the given column and row index.
 * @throws {Stubs.Exceptions.ArgumentError} if the given column/row index is not valid
 * Creates a {\@link yfiles.layout.PartitionCellId partition cell} identifier that represents the cell defined by the given {\@link yfiles.layout.ColumnDescriptor column} and {\@link yfiles.layout.RowDescriptor row}.
 * @throws {Stubs.Exceptions.ArgumentError} if the given column/row is <code>null</code>
 * @param {number|!yfiles.layout.RowDescriptor} rowIndex_or_rd the row index of the row defining the cell / the row defining the cell
 * @param {number|!yfiles.layout.ColumnDescriptor} columnIndex_or_cd the column index of the column defining the cell / the column defining the cell
 * @return {!yfiles.layout.PartitionCellId} a {\@link } instance
 */
yfiles.layout.PartitionGrid.prototype.createCellId = function(rowIndex_or_rd, columnIndex_or_cd) {};

/**
 * Creates a {\@link yfiles.layout.PartitionCellId partition cell} identifier that represents a multi-cell spanning multiple columns and rows.
 * <p>
 * The partition cell identifier represents all cells defined by a row between <code>fromRow</code> and <code>toRow</code> (both including) and a
 * column between <code>fromRow</code> and <code>toCol</code> (both including).
 * </p>
 * <p>
 * A group node mapped to such a partition cell identifier represents the multi-cell, i.e., its boundary corresponds to the
 * smallest rectangle containing all partition cells specified by the partition cell identifier. The boundary does not
 * depend on the partition cells associated with the group's descendants. Hence, each non-group descendant has to be
 * manually assigned to one of the partition cells. Furthermore, edges incident to such a group node are not considered
 * during the layout.
 * </p>
 * Creates a {\@link yfiles.layout.PartitionCellId partition cell} identifier that represents a multi-cell spanning multiple columns and rows.
 * <p>
 * The partition cell identifier represents all cells defined by a row with index between <code>fromRowIndex</code> and <code>toRowIndex</code> (both
 * including) and a column with index between <code>fromColIndex</code> and <code>toColIndex</code> (both including).
 * </p>
 * <p>
 * A group node mapped to such a partition cell identifier represents the multi-cell, i.e., its boundary corresponds to the
 * smallest rectangle containing all partition cells specified by the partition cell identifier. The boundary does not
 * depend on the partition cells associated with the group's descendants. Hence, each non-group descendant has to be
 * manually assigned to one of the partition cells. Furthermore, edges incident to such a group node are not considered
 * during the layout.
 * </p>
 * Creates a {\@link yfiles.layout.PartitionCellId partition cell} identifier that represents a multi-cell spanning multiple columns and rows.
 * <p>
 * The partition cell identifier represents all cells spanned by the columns of <code>columnList</code> and rows of <code>rowList</code>.
 * </p>
 * <p>
 * A group node mapped to such a partition cell identifier represents the multi-cell, i.e., its boundary corresponds to the
 * smallest rectangle containing all partition cells specified by the partition cell identifier. The boundary does not
 * depend on the partition cells associated with the group's descendants. Hence, each non-group descendant has to be
 * manually assigned to one of the partition cells. Furthermore, edges incident to such a group node are not considered
 * during the layout.
 * </p>
 * @param {!yfiles.layout.RowDescriptor|number|?<!Object>} fromRow_or_fromRowIndex_or_rowList the topmost row defining the cell / the row index of the topmost row defining the cell / the {\@link  rows} defining the cell
 * @param {!yfiles.layout.ColumnDescriptor|number|?<!Object>} fromCol_or_fromColIndex_or_columnList the leftmost column defining the cell / the column index of the leftmost column defining the cell / the {\@link  columns} defining the cell
 * @param {!yfiles.layout.RowDescriptor|number=} toRow_or_toRowIndex the bottommost row defining the cell / the row index of the bottommost row defining the cell
 * @param {!yfiles.layout.ColumnDescriptor|number=} toCol_or_toColIndex the rightmost column defining the cell / the column index of the rightmost column defining the cell
 * @return {!yfiles.layout.PartitionCellId} a {\@link } instance
 */
yfiles.layout.PartitionGrid.prototype.createCellSpanId = function(fromRow_or_fromRowIndex_or_rowList, fromCol_or_fromColIndex_or_columnList, toRow_or_toRowIndex, toCol_or_toColIndex) {};

/**
 * Creates a {\@link yfiles.layout.PartitionCellId partition cell} identifier that represents a cell spanning a whole column.
 * <p>
 * A group node mapped to such a partition cell identifier represents the column, i.e., its enclosing boundary corresponds
 * to that of the column. The boundary does not depend on the partition cells associated with the group's descendants.
 * Hence, each non-group descendant has to be manually assigned to one of the partition cells. Furthermore, edges incident
 * to such a group node are not considered during the layout.
 * </p>
 * @param {number} columnIndex the column index of the column defining the cell
 * @return {!yfiles.layout.PartitionCellId} a {\@link } instance
 */
yfiles.layout.PartitionGrid.prototype.createColumnSpanId = function(columnIndex) {};

/**
 * Creates a {\@link yfiles.layout.PartitionCellId partition cell} identifier that represents a cell spanning a whole row.
 * <p>
 * A group node mapped to such a partition cell identifier represents the row, i.e., its enclosing boundary corresponds to
 * that of the row. The boundary does not depend on the partition cells associated with the group's descendants. Hence,
 * each non-group descendant has to be manually assigned to one of the partition cells. Furthermore, edges incident to such
 * a group node are not considered during the layout.
 * </p>
 * @param {number} rowIndex the row index of the row defining the cell
 * @return {!yfiles.layout.PartitionCellId} a {\@link } instance
 */
yfiles.layout.PartitionGrid.prototype.createRowSpanId = function(rowIndex) {};

/**
 * Finalizes the orientation changes and is called at the end of the {\@link yfiles.layout.OrientationLayout} stage.
 * <p>
 * Points are transferred to their final positions through {\@link yfiles.layout.OrientationLayout#completeTransform}.
 * </p>
 * @see yfiles.layout.OrientationLayout
 * @param {!yfiles.layout.OrientationLayout} orientationLayouter an {\@link } instance
 * @return {void}
 */
yfiles.layout.PartitionGrid.prototype.finalizeOrientationChange = function(orientationLayouter) {};

/**
 * Returns the {\@link yfiles.layout.ColumnDescriptor column} with the given index.
 * @param {number} index the index of the column to be returned
 * @return {!yfiles.layout.ColumnDescriptor} the {\@link  column} with the given index or <code>null</code> if no such column exists
 */
yfiles.layout.PartitionGrid.prototype.getColumn = function(index) {};

/**
 * Returns the {\@link yfiles.layout.PartitionGrid} instance associated with the given graph.
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {!yfiles.layout.PartitionGrid} the {\@link } of the graph or <code>null</code> if the graph has no associated partition grid
 */
yfiles.layout.PartitionGrid.getPartitionGrid = function(graph) {};

/**
 * Returns the {\@link yfiles.layout.RowDescriptor row} with the given index.
 * @param {number} index the index of the row to be returned
 * @return {!yfiles.layout.RowDescriptor} the {\@link  row} with the given index or <code>null</code> if no such row exists
 */
yfiles.layout.PartitionGrid.prototype.getRow = function(index) {};

/**
 * @param {!yfiles.algorithms.Graph} graph
 * @return {boolean}
 */
yfiles.layout.PartitionGrid.hasAtLeastTwoNonEmptyRows = function(graph) {};

/**
 * Prepares for the orientation changes and is called at the beginning of the {\@link yfiles.layout.OrientationLayout} stage.
 * <p>
 * Original points are transferred to their temporary positions through {\@link yfiles.layout.OrientationLayout#prepareTransform}.
 * </p>
 * @see yfiles.layout.OrientationLayout
 * @param {!yfiles.layout.OrientationLayout} orientationLayouter an {\@link } instance
 * @return {void}
 */
yfiles.layout.PartitionGrid.prototype.prepareOrientationChange = function(orientationLayouter) {};
/**
 * @record
 * @struct
 */
yfiles.layout.RowDescriptor = function() {};
 /** @type {number} */
yfiles.layout.RowDescriptor.prototype.index;
 /** @type {number} */
yfiles.layout.RowDescriptor.prototype.minimumHeight;
 /** @type {number} */
yfiles.layout.RowDescriptor.prototype.topInset;
 /** @type {number} */
yfiles.layout.RowDescriptor.prototype.bottomInset;
 /** @type {number} */
yfiles.layout.RowDescriptor.prototype.computedHeight;
 /** @type {number} */
yfiles.layout.RowDescriptor.prototype.originalPosition;
 /** @type {number} */
yfiles.layout.RowDescriptor.prototype.originalHeight;
 /** @type {number} */
yfiles.layout.RowDescriptor.prototype.computedPosition;
 /** @type {number} */
yfiles.layout.RowDescriptor.prototype.tightness;
 /** @type {boolean} */
yfiles.layout.RowDescriptor.prototype.indexFixed;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.RowDescriptor.$class;

/**
 * Compares this {\@link yfiles.layout.RowDescriptor} instance with a given other {\@link yfiles.layout.RowDescriptor} instance based on the
 * indices of the two instances.
 * @param {!Object} o the {\@link } to compare to
 * @return {number} <code>-1</code>, <code>0</code> or <code>1</code> if this {\@link } is less than, equal to, or greater than the given other
 * {\@link }
 */
yfiles.layout.RowDescriptor.prototype.compareTo = function(o) {};

/** @const */
yfiles.layout.InterEdgeRoutingStyle = {};
/** @const {number} */
yfiles.layout.InterEdgeRoutingStyle.ADOPT;
/** @const {number} */
yfiles.layout.InterEdgeRoutingStyle.ORTHOGONAL;
/** @const {number} */
yfiles.layout.InterEdgeRoutingStyle.STRAIGHTLINE;
/**
 * @record
 * @struct
 */
yfiles.layout.GroupingKeys = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<!Object>} */
yfiles.layout.GroupingKeys.NODE_ID_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!Object>} */
yfiles.layout.GroupingKeys.PARENT_NODE_ID_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.layout.GroupingKeys.GROUP_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.algorithms.Insets>} */
yfiles.layout.GroupingKeys.GROUP_NODE_INSETS_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.algorithms.YDimension>} */
yfiles.layout.GroupingKeys.MINIMUM_NODE_SIZE_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.GroupingKeys.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.GroupingSupport = function() {};
 /** @type {!yfiles.algorithms.Graph} */
yfiles.layout.GroupingSupport.prototype.graph;
 /** @type {!yfiles.algorithms.Node} */
yfiles.layout.GroupingSupport.prototype.root;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.GroupingSupport.$class;

/**
 * Creates a {\@link yfiles.algorithms.INodeMap} to store hierarchy information for each node.
 * <p>
 * This method is called in {\@link yfiles.layout.GroupingSupport#init} and may be overridden to customize how the {\@link yfiles.algorithms.INodeMap}
 * is created.
 * </p>
 * @see yfiles.layout.GroupingSupport#init
 * @see yfiles.layout.GroupingSupport#disposeInfoMap
 * @protected
 * @param {!yfiles.algorithms.Graph} graph the current graph
 * @return {?} the new instance of {\@link }
 */
yfiles.layout.GroupingSupport.prototype.createInfoMap = function(graph) {};

/**
 * Disposes of all internal data structures held by this {\@link yfiles.layout.GroupingSupport instance}.
 * <p>
 * {\@link yfiles.layout.GroupingSupport} should be disposed of when it is not needed anymore, or if the state of the graph changes
 * (e.g. new nodes are added).
 * </p>
 * @return {void}
 */
yfiles.layout.GroupingSupport.prototype.dispose = function() {};

/**
 * Disposes of the {\@link yfiles.algorithms.INodeMap} created to store hierarchy information for each node.
 * <p>
 * This method is called in {\@link yfiles.layout.GroupingSupport#dispose} and may be overridden to revert changes from
 * {\@link yfiles.layout.GroupingSupport#createInfoMap}.
 * </p>
 * @see yfiles.layout.GroupingSupport#dispose
 * @see yfiles.layout.GroupingSupport#createInfoMap
 * @protected
 * @param {!yfiles.algorithms.Graph} graph the current graph
 * @param {?} infoMap the {\@link } which contains the hierarchy information for each node
 * @return {void}
 */
yfiles.layout.GroupingSupport.prototype.disposeInfoMap = function(graph, infoMap) {};

/**
 * Returns the direct children of the given group node.
 * <p>
 * If the {\@link yfiles.layout.GroupingSupport#root virtual root of the hierarchy tree} is passed, all top-level nodes are returned.
 * </p>
 * @see yfiles.layout.GroupingSupport#root
 * @see yfiles.layout.GroupingSupport#getParent
 * @see yfiles.layout.GroupingSupport#getDescendants
 * @param {!yfiles.algorithms.Node} parent the group node
 * @return {!yfiles.algorithms.NodeList} a set of child nodes of the given parent node
 */
yfiles.layout.GroupingSupport.prototype.getChildren = function(parent) {};

/**
 * Returns all descendants of the given group node.
 * <p>
 * All nodes in the subtree rooted at this group node are collected recursively.
 * </p>
 * <p>
 * If the {\@link yfiles.layout.GroupingSupport#root virtual root of the hierarchy tree} is passed, all nodes in the graph are returned.
 * </p>
 * @see yfiles.layout.GroupingSupport#root
 * @see yfiles.layout.GroupingSupport#getParent
 * @see yfiles.layout.GroupingSupport#getChildren
 * @param {!yfiles.algorithms.Node} parent the group node
 * @return {!yfiles.algorithms.NodeList} a set of nodes that belong to a subtree of the hierarchy tree rooted at the given parent
 */
yfiles.layout.GroupingSupport.prototype.getDescendants = function(parent) {};

/**
 * Returns all edges crossing the bounds of the given group node such that their targets are inside the group node while
 * their sources lie outside the group node.
 * @see yfiles.layout.GroupingSupport#getEdgesGoingOut
 * @see yfiles.layout.GroupingSupport#isNormalEdge
 * @param {!yfiles.algorithms.Node} group the group node whose bounds are crossed
 * @return {!yfiles.algorithms.EdgeList} a set of edges that cross the bounds of the group node starting outside the group node
 */
yfiles.layout.GroupingSupport.prototype.getEdgesGoingIn = function(group) {};

/**
 * Returns all edges crossing the bounds of the given group node such that their sources are inside the group node while
 * their targets lie outside the group node.
 * @see yfiles.layout.GroupingSupport#getEdgesGoingIn
 * @see yfiles.layout.GroupingSupport#isNormalEdge
 * @param {!yfiles.algorithms.Node} group the group node whose bounds are crossed
 * @return {!yfiles.algorithms.EdgeList} a set of edges that cross the bounds of the group node starting inside the group node
 */
yfiles.layout.GroupingSupport.prototype.getEdgesGoingOut = function(group) {};

/**
 * Returns the nearest common ancestor of the given nodes in the hierarchy structure.
 * <p>
 * The nearest common ancestor is the local root of the smallest subtree in the hierarchy tree that contains both nodes.
 * This group is the first node that contains these two nodes. If no such node exists, the {\@link yfiles.layout.GroupingSupport#root virtual root} is returned.
 * </p>
 * <p>
 * Common ancestors in special cases:
 * </p>
 * <ul>
 * <li><code>node1 == node2</code>: the parent of <code>node1</code>/<code>node2</code></li>
 * <li><code>node1 is parent of node2</code>: the parent of <code>node1</code></li>
 * <li><code>node2 is parent of node1</code>: the parent of <code>node2</code></li>
 * </ul>
 * @param {!yfiles.algorithms.Node} node1 one of the two nodes whose common ancestor is determined
 * @param {!yfiles.algorithms.Node} node2 one of the two nodes whose common ancestor is determined
 * @return {!yfiles.algorithms.Node} the nearest common ancestor node or {\@link #root}
 */
yfiles.layout.GroupingSupport.prototype.getNearestCommonAncestor = function(node1, node2) {};

/**
 * Returns the parent for the given node.
 * <p>
 * The parent is the containing group node.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given node is <code>null</code>
 * @see yfiles.layout.GroupingSupport#getChildren
 * @see yfiles.layout.GroupingSupport#getDescendants
 * @see yfiles.layout.GroupingSupport#getNearestCommonAncestor
 * @param {!yfiles.algorithms.Node} node the node for which the parent is determined
 * @return {!yfiles.algorithms.Node} the parent of the given node or <code>null</code> for a top-level node
 */
yfiles.layout.GroupingSupport.prototype.getParent = function(node) {};

/**
 * Returns an immediate child of the group node that represents the given node.
 * <p>
 * If this node is already a child of the group node, the group node will be its representative. In case the node is
 * located further down in the hierarchy, the child of the group node, which is also an ancestor of the node, is used.
 * There is no representative if the node is not a descendant of the group.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given node is <code>null</code>
 * @param {!yfiles.algorithms.Node} node the node for which a representative is searched
 * @param {!yfiles.algorithms.Node} group the group node to which the representative should belong
 * @return {!yfiles.algorithms.Node} the representative or <code>null</code> if the node is not a descendant of the group
 */
yfiles.layout.GroupingSupport.prototype.getRepresentative = function(node, group) {};

/**
 * Determines whether or not the given node is a group node with children.
 * <p>
 * Normal nodes never have children.
 * </p>
 * @see yfiles.layout.GroupingSupport#getChildren
 * @see yfiles.layout.GroupingSupport#isGroupNode
 * @param {!yfiles.algorithms.Node} node the potential parent
 * @return {boolean} <code>true</code> if the given node has children, <code>false</code> otherwise
 */
yfiles.layout.GroupingSupport.prototype.hasChildren = function(node) {};

/**
 * Initializes internal data structures.
 * <p>
 * This method is called from {\@link yfiles.layout.GroupingSupport} and retrieves the state of the hierarchic graph at the moment
 * of invocation. It may be overridden to append additional information used for group handling.
 * </p>
 * @see yfiles.layout.GroupingSupport#dispose
 * @protected
 * @return {void}
 */
yfiles.layout.GroupingSupport.prototype.init = function() {};

/**
 * Returns whether or not the given graph is flat.
 * <p>
 * A graph is considered to be <i>flat</i> if there exist no group nodes or there exist group nodes but none of them has children.
 * </p>
 * @see yfiles.layout.GroupingSupport#isGrouped
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {boolean} <code>true</code> if there are no groups or only empty groups in the graph, <code>false</code> otherwise
 */
yfiles.layout.GroupingSupport.isFlat = function(graph) {};

/**
 * Returns whether or not the given graph is grouped.
 * <p>
 * A graph is considered to be grouped if there are {\@link yfiles.algorithms.IDataProvider}s registered with the graph with keys
 * {\@link yfiles.layout.GroupingKeys#GROUP_DP_KEY}, {\@link yfiles.layout.GroupingKeys#NODE_ID_DP_KEY} and
 * {\@link yfiles.layout.GroupingKeys#PARENT_NODE_ID_DP_KEY}.
 * </p>
 * @see yfiles.layout.GroupingSupport#isFlat
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {boolean} <code>true</code> if the graph contains hierarchic information, <code>false</code> otherwise
 */
yfiles.layout.GroupingSupport.isGrouped = function(graph) {};

/**
 * Determines whether or not the given node is a group node.
 * <p>
 * While group nodes may have children, normal nodes never have children.
 * </p>
 * @see yfiles.layout.GroupingSupport#hasChildren
 * @param {!yfiles.algorithms.Node} node the potential group node
 * @return {boolean} <code>true</code> if the given node is a group node, <code>false</code> otherwise
 */
yfiles.layout.GroupingSupport.prototype.isGroupNode = function(node) {};

/**
 * Determines whether or not the given edge is a normal edge as opposed to an edge that crosses any group node bounds.
 * <p>
 * Source and target of a normal edge are part of the same hierarchy level and share the same parent node.
 * </p>
 * @see yfiles.layout.GroupingSupport#getEdgesGoingIn
 * @see yfiles.layout.GroupingSupport#getEdgesGoingOut
 * @param {!yfiles.algorithms.Edge} edge the edge to check
 * @return {boolean} <code>true</code> if the given edge is normal, <code>false</code> otherwise
 */
yfiles.layout.GroupingSupport.prototype.isNormalEdge = function(edge) {};
/**
 * @record
 * @struct
 */
yfiles.layout.HideGroupsStage = function() {};
 /** @type {boolean} */
yfiles.layout.HideGroupsStage.prototype.hidingEmptyGroupNodes;
 /** @type {?} */
yfiles.layout.HideGroupsStage.prototype.groupBoundsCalculator;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.HideGroupsStage.$class;

/**
 * Hides the group nodes and their incident edges of the input graph.
 * <p>
 * Furthermore, this method removes all grouping-related {\@link yfiles.algorithms.IDataProvider}s from the input graph.
 * </p>
 * @see yfiles.layout.GroupingKeys#NODE_ID_DP_KEY
 * @see yfiles.layout.GroupingKeys#PARENT_NODE_ID_DP_KEY
 * @see yfiles.layout.GroupingKeys#GROUP_DP_KEY
 * @see yfiles.layout.HideGroupsStage#unhideGroupNodes
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.HideGroupsStage.prototype.hideGroupNodes = function(graph) {};

/**
 * Un-hides the group nodes and their incident edges of the input graph that were previously hidden using method
 * {\@link yfiles.layout.HideGroupsStage#hideGroupNodes}.
 * <p>
 * Furthermore, this method restores all previously removed grouping related
 * {\@link yfiles.algorithms.IDataProvider}s on the input graph.
 * </p>
 * @see yfiles.layout.GroupingKeys#NODE_ID_DP_KEY
 * @see yfiles.layout.GroupingKeys#PARENT_NODE_ID_DP_KEY
 * @see yfiles.layout.GroupingKeys#GROUP_DP_KEY
 * @see yfiles.layout.HideGroupsStage#hideGroupNodes
 * @param {!yfiles.layout.LayoutGraph} graph the given graph
 * @return {void}
 */
yfiles.layout.HideGroupsStage.prototype.unhideGroupNodes = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.IGroupBoundsCalculator = function() {};

/**
 * Calculates the bounds of the given group node that contains the given list of child nodes.
 * <p>
 * This method is called during the layout process.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} groupNode the group node whose bounds will be calculated
 * @param {!yfiles.algorithms.NodeList} children a {\@link } containing the nodes that reside inside the group node
 * @return {!yfiles.algorithms.Rectangle2D} a {\@link } instance that describes the bounds of the group node
 */
yfiles.layout.IGroupBoundsCalculator.prototype.calculateBounds = function(graph, groupNode, children) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IGroupBoundsCalculator;
/**
 * @record
 * @struct
 */
yfiles.layout.InsetsGroupBoundsCalculator = function() {};
 /** @type {boolean} */
yfiles.layout.InsetsGroupBoundsCalculator.prototype.considerNodeLabels;
 /** @type {boolean} */
yfiles.layout.InsetsGroupBoundsCalculator.prototype.considerEdgeLabels;
 /** @type {boolean} */
yfiles.layout.InsetsGroupBoundsCalculator.prototype.considerNodeHalos;
 /** @type {!yfiles.algorithms.Insets} */
yfiles.layout.InsetsGroupBoundsCalculator.prototype.defaultInsets;
 /** @type {!Object} */
yfiles.layout.InsetsGroupBoundsCalculator.prototype.groupNodeInsetsDpKey;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.InsetsGroupBoundsCalculator.$class;

/**
 * Calculates the bounds of the given group node and enlarges the bounds by the insets associated with the group node.
 * <p>
 * The {\@link yfiles.algorithms.Insets insets} associated with the group node will be retrieved from a {\@link yfiles.algorithms.IDataProvider} registered with the
 * graph with the current {\@link yfiles.layout.InsetsGroupBoundsCalculator#groupNodeInsetsDpKey insets key}.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} groupNode the group node whose bounds will be calculated
 * @param {!yfiles.algorithms.NodeList} children a {\@link } containing the nodes that reside inside the group node
 * @return {!yfiles.algorithms.Rectangle2D} a {\@link } instance that describes the bounds of the group node
 */
yfiles.layout.InsetsGroupBoundsCalculator.prototype.calculateBounds = function(graph, groupNode, children) {};

/**
 * Enlarges the given graph bounds by the insets associated with the given group node.
 * <p>
 * The {\@link yfiles.algorithms.Insets insets} associated with the group node will be retrieved from a {\@link yfiles.algorithms.IDataProvider} registered with the
 * graph with the current {\@link yfiles.layout.InsetsGroupBoundsCalculator#groupNodeInsetsDpKey insets key}.
 * </p>
 * <p>
 * This method is called while {\@link yfiles.layout.InsetsGroupBoundsCalculator#calculateBounds calculating the group bounds} to realize the support for custom insets. It may be overridden
 * to change the way specific insets influence the group node bounds.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} groupNode the group node whose bounds should be enlarged
 * @param {!yfiles.algorithms.NodeList} children the list of nodes that the given group node contains
 * @param {!yfiles.algorithms.Rectangle2D} bounds a {\@link } instance representing the bounds of the given group node
 * @return {!yfiles.algorithms.Rectangle2D} a {\@link } instance representing the enlarged bounds of the given group node
 */
yfiles.layout.InsetsGroupBoundsCalculator.prototype.createEnlargedBounds = function(graph, groupNode, children, bounds) {};
/**
 * @record
 * @struct
 */
yfiles.layout.IsolatedGroupComponentLayout = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.IsolatedGroupComponentLayout.$class;

/**
 * Determines the nodes that belong to the same graph component.
 * <p>
 * Unlike
 * {\@link yfiles.layout.ComponentLayout}, this implementation additionally identifies isolated subgraphs within a group as separate
 * components.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} compNumber the {\@link } that will be filled by the layout algorithm, such that it contains the zero-based index
 * of the component number to which each node belongs
 * @return {number} the number of separate components
 */
yfiles.layout.IsolatedGroupComponentLayout.prototype.findIsolatedGraphComponents = function(graph, compNumber) {};
/**
 * @record
 * @struct
 */
yfiles.layout.MinimumSizeGroupBoundsCalculator = function() {};
 /** @type {number} */
yfiles.layout.MinimumSizeGroupBoundsCalculator.prototype.xAlignment;
 /** @type {number} */
yfiles.layout.MinimumSizeGroupBoundsCalculator.prototype.yAlignment;
 /** @type {!Object} */
yfiles.layout.MinimumSizeGroupBoundsCalculator.prototype.minimumNodeSizeDpKey;
 /** @type {!yfiles.algorithms.YDimension} */
yfiles.layout.MinimumSizeGroupBoundsCalculator.prototype.defaultMinimumNodeSize;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.MinimumSizeGroupBoundsCalculator.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.RecursiveGroupLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.layout.RecursiveGroupLayout.GROUP_NODE_LAYOUT_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.layout.RecursiveGroupLayout.SOURCE_SPLIT_ID_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.layout.RecursiveGroupLayout.TARGET_SPLIT_ID_DP_KEY;
 /** @type {?} */
yfiles.layout.RecursiveGroupLayout.NULL_LAYOUT;
 /** @type {boolean} */
yfiles.layout.RecursiveGroupLayout.prototype.fromSketchMode;
 /** @type {boolean} */
yfiles.layout.RecursiveGroupLayout.prototype.autoAssignPortCandidates;
 /** @type {boolean} */
yfiles.layout.RecursiveGroupLayout.prototype.replacePortConstraints;
 /** @type {boolean} */
yfiles.layout.RecursiveGroupLayout.prototype.considerEmptyGroups;
 /** @type {?} */
yfiles.layout.RecursiveGroupLayout.prototype.interEdgeRouter;
 /** @type {!Object} */
yfiles.layout.RecursiveGroupLayout.prototype.interEdgesDpKey;
 /** @type {?} */
yfiles.layout.RecursiveGroupLayout.prototype.groupBoundsCalculator;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.RecursiveGroupLayout.$class;

/**
 * Reroutes the given inter-edges using the current {\@link yfiles.layout.RecursiveGroupLayout#interEdgeRouter edge routing algorithm}.
 * <p>
 * This method is called after calculating the overall layout when the positions of all nodes and normal edges are fixed.
 * </p>
 * <p>
 * If no {\@link yfiles.layout.RecursiveGroupLayout#interEdgeRouter inter-edge router} is specified, this method {\@link yfiles.layout.LayoutGraphUtilities#resetPath resets the path} of all inter-edges that don't connect to the proper
 * location within the group. This may happen for inter-edges without
 * {\@link yfiles.layout.PortCandidate}s or if the applied layout algorithm doesn't support such constraints.
 * </p>
 * @see yfiles.layout.RecursiveGroupLayout#autoAssignPortCandidates
 * @see yfiles.layout.RecursiveGroupLayout#replacePortConstraints
 * @see yfiles.layout.RecursiveGroupLayout#interEdgeRouter
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.EdgeList} interEdges the edges which traverse the boundary of a group node
 * @return {void}
 */
yfiles.layout.RecursiveGroupLayout.prototype.routeInterEdges = function(graph, interEdges) {};
/**
 * @record
 * @struct
 */
yfiles.layout.HandleNaNCoordinatesStage = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.HandleNaNCoordinatesStage.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.IEdgeLabelLayout = function() {};
 /** @type {?} */
yfiles.layout.IEdgeLabelLayout.prototype.labelModel;
 /** @type {!yfiles.layout.PreferredPlacementDescriptor} */
yfiles.layout.IEdgeLabelLayout.prototype.preferredPlacementDescriptor;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IEdgeLabelLayout;
/**
 * @record
 * @struct
 */
yfiles.layout.IEdgeLabelLayoutModel = function() {};
 /** @type {!Object} */
yfiles.layout.IEdgeLabelLayoutModel.prototype.defaultParameter;

/**
 * Creates a model parameter that represents the given edge label position within this model.
 * <p>
 * The created model parameter is the closest parameter representation of the given label location that can be achieved
 * within this model.
 * </p>
 * <p>
 * This parameter can be passed to {\@link yfiles.layout.IEdgeLabelLayoutModel#getLabelPlacement} to retrieve the current label
 * box.
 * </p>
 * <p>
 * A model parameter can be an arbitrary {\@link Object}. However it must contain all information to allow restoring of the encoded
 * location with this {\@link yfiles.layout.IEdgeLabelLayoutModel}.
 * </p>
 * @see yfiles.layout.IEdgeLabelLayoutModel#getLabelPlacement
 * @abstract
 * @param {!yfiles.algorithms.YOrientedRectangle} labelBounds the oriented box of the label, encoding the label location for which the parameter should be created
 * @param {?} edgeLayout the layout of the edge to which the label belongs
 * @param {?} sourceLayout the layout of the source node of the label-owning edge
 * @param {?} targetLayout the layout of the target node of the label-owning edge
 * @return {!Object} the model parameter representing the given label location
 */
yfiles.layout.IEdgeLabelLayoutModel.prototype.createModelParameter = function(labelBounds, edgeLayout, sourceLayout, targetLayout) {};

/**
 * Returns all {\@link yfiles.layout.EdgeLabelCandidate}s that describe valid label positions within this model.
 * <p>
 * In case the implementing {\@link yfiles.layout.IEdgeLabelLayoutModel} allows every possible location, this method always returns
 * the current location as a {\@link yfiles.layout.LabelCandidate}.
 * </p>
 * @abstract
 * @param {?} labelLayout the label for which candidates should be generated
 * @param {?} edgeLayout the layout of the edge to which the label belongs
 * @param {?} sourceLayout the layout of the source node of the label-owning edge
 * @param {?} targetLayout the layout of the target node of the label-owning edge
 * @return {!yfiles.algorithms.YList} a list of {\@link } instances
 */
yfiles.layout.IEdgeLabelLayoutModel.prototype.getLabelCandidates = function(labelLayout, edgeLayout, sourceLayout, targetLayout) {};

/**
 * Returns the oriented box of the label for the position encoded by the given model parameter.
 * @abstract
 * @param {!yfiles.algorithms.YDimension} labelSize the width and height of the label
 * @param {?} edgeLayout the layout of the edge to which the label belongs
 * @param {?} sourceLayout the layout of the source node of the label-owning edge
 * @param {?} targetLayout the layout of the target node of the label-owning edge
 * @param {!Object} parameter the model parameter that describes the abstract position of the label within this model
 * @return {!yfiles.algorithms.YOrientedRectangle} the oriented bounds of the label
 */
yfiles.layout.IEdgeLabelLayoutModel.prototype.getLabelPlacement = function(labelSize, edgeLayout, sourceLayout, targetLayout, parameter) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IEdgeLabelLayoutModel;
/**
 * @record
 * @struct
 */
yfiles.layout.IEdgeLayout = function() {};
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.layout.IEdgeLayout.prototype.sourcePoint;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.layout.IEdgeLayout.prototype.targetPoint;

/**
 * Adds a control point to the end of the control point sequence.
 * @abstract
 * @param {number} x the absolute x-coordinate of the new control point
 * @param {number} y the absolute y-coordinate of the new control point
 * @return {void}
 */
yfiles.layout.IEdgeLayout.prototype.addPoint = function(x, y) {};

/**
 * Removes all control points from this edge layout.
 * <p>
 * The {\@link yfiles.layout.IEdgeLayout} still keeps the {\@link yfiles.layout.IEdgeLayout#sourcePoint source point} and the {\@link yfiles.layout.IEdgeLayout#targetPoint target point}.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.layout.IEdgeLayout.prototype.clearPoints = function() {};

/**
 * Returns the control point at the given position in the sequence of control points.
 * <p>
 * The first control point in the sequence has index <code>0</code> and the last control point has index {\@link yfiles.layout.IEdgeLayout#pointCount}
 * <code>-1</code>.
 * </p>
 * @see yfiles.layout.IEdgeLayout#setPoint
 * @abstract
 * @param {number} index the position of the control point in the control point sequence
 * @return {!yfiles.algorithms.YPoint} the absolute coordinates of the control point at the given index
 */
yfiles.layout.IEdgeLayout.prototype.getPoint = function(index) {};

/**
 * Returns the number of control points of the edge.
 * <p>
 * The source and target points are not included in the point count.
 * </p>
 * @abstract
 * @return {number} the number of control points
 */
yfiles.layout.IEdgeLayout.prototype.pointCount = function() {};

/**
 * Sets the absolute coordinates of the control point at the given position in the sequence of control points.
 * <p>
 * The first control point in the sequence has index <code>0</code> and the last control point has index {\@link yfiles.layout.IEdgeLayout#pointCount}
 * <code>-1</code>.
 * </p>
 * @abstract
 * @param {number} index the position of the changing control point in the sequence
 * @param {number} x the new absolute x-coordinate of the control point at the given index
 * @param {number} y the new absolute y-coordinate of the control point at the given index
 * @return {void}
 */
yfiles.layout.IEdgeLayout.prototype.setPoint = function(index, x, y) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IEdgeLayout;
/**
 * @record
 * @struct
 */
yfiles.layout.IIntersectionCalculator = function() {};

/**
 * Calculates an intersection point between the edge and the given {\@link yfiles.layout.INodeLayout}.
 * <p>
 * Implementing classes use a point on the connecting edge segment (specified with an offset to the node's center) along
 * with a direction pointing to the node and calculate the intersection between this line and the node.
 * </p>
 * @abstract
 * @param {?} nodeLayout the layout information of the node
 * @param {number} xOffset the x-coordinate of a point on the last line segment relative to the node's center
 * @param {number} yOffset the y-coordinate of a point on the last line segment relative to the node's center
 * @param {number} dx the x-component of the normalized direction vector indicating the direction of the segment pointing towards the node
 * @param {number} dy the y-component of the normalized direction vector indicating the direction of the segment pointing towards the node
 * @return {!yfiles.algorithms.YPoint} the intersection coordinates relative to the node's center or <code>null</code> if no such intersection was found
 */
yfiles.layout.IIntersectionCalculator.prototype.calculateIntersectionPoint = function(nodeLayout, xOffset, yOffset, dx, dy) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IIntersectionCalculator;
/**
 * @record
 * @struct
 */
yfiles.layout.IntersectionCalculatorKeys = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<?>} */
yfiles.layout.IntersectionCalculatorKeys.SOURCE_INTERSECTION_CALCULATOR_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<?>} */
yfiles.layout.IntersectionCalculatorKeys.TARGET_INTERSECTION_CALCULATOR_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.IntersectionCalculatorKeys.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ILabelLayout = function() {};
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.layout.ILabelLayout.prototype.boundingBox;
 /** @type {!yfiles.algorithms.YOrientedRectangle} */
yfiles.layout.ILabelLayout.prototype.orientedBox;
 /** @type {!Object} */
yfiles.layout.ILabelLayout.prototype.modelParameter;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.ILabelLayout;
/**
 * @record
 * @struct
 */
yfiles.layout.ILabelLayoutFactory = function() {};
 /** @type {!yfiles.layout.LayoutGraph} */
yfiles.layout.ILabelLayoutFactory.prototype.graph;

/**
 * Adds the given {\@link yfiles.layout.IEdgeLabelLayout} to the given edge.
 * <p>
 * The given {\@link yfiles.layout.ILabelLayout} has to be created with method {\@link yfiles.layout.ILabelLayoutFactory#createLabelLayout}
 * or {\@link yfiles.layout.ILabelLayoutFactory#createLabelLayout}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given label layout has already been added to the graph
 * @see yfiles.layout.ILabelLayoutFactory#createLabelLayout
 * @see yfiles.layout.ILabelLayoutFactory#createLabelLayout
 * @abstract
 * Adds the given node label layout to the given node.
 * <p>
 * The given label layout has to be created with method {\@link yfiles.layout.ILabelLayoutFactory#createLabelLayout} or
 * {\@link yfiles.layout.ILabelLayoutFactory#createLabelLayout}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given label layout has already been added to the graph
 * @see yfiles.layout.ILabelLayoutFactory#createLabelLayout
 * @see yfiles.layout.ILabelLayoutFactory#createLabelLayout
 * @abstract
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} edge_or_node the edge / the node
 * @param {?} labelLayout the edge label layout that should be added to the given edge / the node label layout that should be added to the given node
 * @return {void}
 */
yfiles.layout.ILabelLayoutFactory.prototype.addLabelLayout = function(edge_or_node, labelLayout) {};

/**
 * Creates a new {\@link yfiles.layout.ILabelLayout} for the given edge.
 * @see yfiles.layout.ILabelLayoutFactory#addLabelLayout
 * @abstract
 * Creates a new {\@link yfiles.layout.ILabelLayout} for the given node.
 * @see yfiles.layout.ILabelLayoutFactory#addLabelLayout
 * @abstract
 * Creates a new {\@link yfiles.layout.ILabelLayout} for the given edge.
 * <p>
 * This method should create a {\@link yfiles.layout.ILabelLayout} with an {\@link yfiles.layout.IEdgeLabelLayoutModel} that supports the
 * desired oriented label box exactly as given.
 * </p>
 * @see yfiles.layout.ILabelLayoutFactory#addLabelLayout
 * @abstract
 * Creates a new {\@link yfiles.layout.ILabelLayout} for the given node.
 * <p>
 * This method should create a {\@link yfiles.layout.ILabelLayout} with a {\@link yfiles.layout.INodeLabelLayoutModel} that supports the
 * desired oriented label box exactly as given.
 * </p>
 * @see yfiles.layout.ILabelLayoutFactory#addLabelLayout
 * @abstract
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} edge_or_node the edge / the node
 * @param {!yfiles.algorithms.YOrientedRectangle} orientedBox the box specifying the size and location of the label
 * @param {?=} model specifies the model of the created edge label / specifies the model of the created node label
 * @param {!yfiles.layout.PreferredPlacementDescriptor=} descriptor specifies the preferred placement descriptor of the created label. If this value is
 * <code>null</code>, the default descriptor is used
 * @return {?} a new edge label layout / a new node label layout
 */
yfiles.layout.ILabelLayoutFactory.prototype.createLabelLayout = function(edge_or_node, orientedBox, model, descriptor) {};

/**
 * Removes the given {\@link yfiles.layout.IEdgeLabelLayout} from the given edge.
 * @see yfiles.layout.ILabelLayoutFactory#addLabelLayout
 * @abstract
 * Removes the given node label layout from the given node.
 * @see yfiles.layout.ILabelLayoutFactory#addLabelLayout
 * @abstract
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} edge_or_node the edge / the node
 * @param {?} labelLayout the label layout that should be removed from the given edge / the label layout that should be removed from the given node
 * @return {void}
 */
yfiles.layout.ILabelLayoutFactory.prototype.removeLabelLayout = function(edge_or_node, labelLayout) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.ILabelLayoutFactory;
/**
 * @record
 * @struct
 */
yfiles.layout.ILayoutAlgorithm = function() {};

/**
 * Main layout routine that assigns new layout information to the given graph.
 * <p>
 * The call to this routine will only succeed if the layout algorithm can handle the input graph.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.ILayoutAlgorithm.prototype.applyLayout = function(graph) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.ILayoutAlgorithm;
/**
 * @record
 * @struct
 */
yfiles.layout.LayoutKeys = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<!Object>} */
yfiles.layout.LayoutKeys.NODE_ID_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.layout.LayoutKeys.EDGE_ID_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.layout.LayoutKeys.AFFECTED_NODES_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.layout.LayoutKeys.AFFECTED_EDGES_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LayoutKeys.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ILayoutStage = function() {};
 /** @type {?} */
yfiles.layout.ILayoutStage.prototype.coreLayout;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.ILayoutStage;
/**
 * @record
 * @struct
 */
yfiles.layout.INodeLabelLayout = function() {};
 /** @type {?} */
yfiles.layout.INodeLabelLayout.prototype.labelModel;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.INodeLabelLayout;
/**
 * @record
 * @struct
 */
yfiles.layout.INodeLabelLayoutModel = function() {};
 /** @type {!Object} */
yfiles.layout.INodeLabelLayoutModel.prototype.defaultParameter;

/**
 * Creates a model parameter that represents the given node label position within this model.
 * <p>
 * The created model parameter is the closest parameter representation of the given label location that can be achieved
 * within this model.
 * </p>
 * <p>
 * This parameter can be passed to {\@link yfiles.layout.INodeLabelLayoutModel#getLabelPlacement} to retrieve the current label
 * box.
 * </p>
 * <p>
 * A model parameter can be an arbitrary {\@link Object}. However it must contain all information to allow restoring of the encoded
 * location with this {\@link yfiles.layout.INodeLabelLayoutModel}.
 * </p>
 * @see yfiles.layout.INodeLabelLayoutModel#getLabelPlacement
 * @abstract
 * @param {!yfiles.algorithms.YOrientedRectangle} labelBounds the box of the label, encoding the label location for which the parameter should be created
 * @param {?} nodeLayout the layout of the node to which the label belongs
 * @return {!Object} the model parameter representing the given label location
 */
yfiles.layout.INodeLabelLayoutModel.prototype.createModelParameter = function(labelBounds, nodeLayout) {};

/**
 * Returns all {\@link yfiles.layout.NodeLabelCandidate}s that describe valid label positions within this model.
 * <p>
 * In case the implementing {\@link yfiles.layout.INodeLabelLayoutModel} allows every possible location, this method always returns
 * the current location as a {\@link yfiles.layout.LabelCandidate}.
 * </p>
 * @abstract
 * @param {?} labelLayout the label for which candidates should be generated
 * @param {?} nodeLayout the layout of the node to which the label belongs
 * @return {!yfiles.algorithms.YList} a list of {\@link } instances
 */
yfiles.layout.INodeLabelLayoutModel.prototype.getLabelCandidates = function(labelLayout, nodeLayout) {};

/**
 * Returns the bounds of the label for the position encoded by the given model parameter.
 * @abstract
 * @param {!yfiles.algorithms.YDimension} labelSize the width and height of the label
 * @param {?} nodeLayout the layout of the node to which the label belongs
 * @param {!Object} param the model parameter that describes the abstract position of the label within this model
 * @return {!yfiles.algorithms.YOrientedRectangle} the oriented box of the label
 */
yfiles.layout.INodeLabelLayoutModel.prototype.getLabelPlacement = function(labelSize, nodeLayout, param) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.INodeLabelLayoutModel;
/**
 * @record
 * @struct
 */
yfiles.layout.INodeLayout = function() {};
 /** @type {number} */
yfiles.layout.INodeLayout.prototype.x;
 /** @type {number} */
yfiles.layout.INodeLayout.prototype.y;
 /** @type {number} */
yfiles.layout.INodeLayout.prototype.width;
 /** @type {number} */
yfiles.layout.INodeLayout.prototype.height;

/**
 * Sets the coordinates of the upper-left corner of the node.
 * @abstract
 * @param {number} x the new x-coordinate of the node
 * @param {number} y the new y-coordinate of the node
 * @return {void}
 */
yfiles.layout.INodeLayout.prototype.setLocation = function(x, y) {};

/**
 * Sets the size of the node.
 * @abstract
 * @param {number} width the new width of the node
 * @param {number} height the new height of the node
 * @return {void}
 */
yfiles.layout.INodeLayout.prototype.setSize = function(width, height) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.INodeLayout;
/**
 * @record
 * @struct
 */
yfiles.layout.IPartitionInterEdgeRouter = function() {};
 /** @type {boolean} */
yfiles.layout.IPartitionInterEdgeRouter.prototype.routeInterEdgesOnly;

/**
 * Routes inter-edges of the partitioned graph.
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} partitionIDDP the partition ID for each node in the graph
 * @param {?} interEdgeDP the map that marks inter-edges
 * @return {void}
 */
yfiles.layout.IPartitionInterEdgeRouter.prototype.routeInterEdges = function(graph, partitionIDDP, interEdgeDP) {};
 /** @type {{createChannelInterEdgeRouter: function(!yfiles.router.ChannelEdgeRouter): ?, createPolylineInterEdgeRouter: function(!yfiles.router.EdgeRouter): ?, $class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IPartitionInterEdgeRouter;
/**
 * @record
 * @struct
 */
yfiles.layout.IProfitModel = function() {};

/**
 * Returns the profit for placing a label using the given {\@link yfiles.layout.LabelCandidate}.
 * <p>
 * Higher profit means better candidates. Hence, there is a higher probability that the candidate is chosen by a labeling
 * algorithm.
 * </p>
 * <p>
 * Profits need to have a value between <code>0</code> and <code>1</code>.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LabelCandidate} candidate the candidate
 * @return {number} the profit of the candidate
 */
yfiles.layout.IProfitModel.prototype.getProfit = function(candidate) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IProfitModel;
/**
 * @record
 * @struct
 */
yfiles.layout.LabelCandidate = function() {};
 /** @type {number} */
yfiles.layout.LabelCandidate.prototype.customProfit;
 /** @type {!Object} */
yfiles.layout.LabelCandidate.prototype.modelParameter;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.layout.LabelCandidate.prototype.location;
 /** @type {!yfiles.algorithms.YDimension} */
yfiles.layout.LabelCandidate.prototype.size;
 /** @type {number} */
yfiles.layout.LabelCandidate.prototype.x;
 /** @type {number} */
yfiles.layout.LabelCandidate.prototype.y;
 /** @type {number} */
yfiles.layout.LabelCandidate.prototype.width;
 /** @type {number} */
yfiles.layout.LabelCandidate.prototype.height;
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.layout.LabelCandidate.prototype.boundingBox;
 /** @type {!yfiles.algorithms.YOrientedRectangle} */
yfiles.layout.LabelCandidate.prototype.box;
 /** @type {?} */
yfiles.layout.LabelCandidate.prototype.owner;
 /** @type {boolean} */
yfiles.layout.LabelCandidate.prototype.internal;
 /** @type {number} */
yfiles.layout.LabelCandidate.prototype.nodeOverlapPenalty;
 /** @type {number} */
yfiles.layout.LabelCandidate.prototype.edgeOverlapPenalty;
 /** @type {number} */
yfiles.layout.LabelCandidate.prototype.overlapPenalty;
 /** @type {boolean} */
yfiles.layout.LabelCandidate.prototype.propagated;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LabelCandidate.$class;

/**
 * Replaces the model parameter and box of the owner with the model parameter and box of this candidate.
 * <p>
 * When this candidate is chosen to provide the placement of the label, this method transfers the model parameter and the
 * candidate box to the {\@link yfiles.layout.ILabelLayout}.
 * </p>
 * @see yfiles.layout.LabelCandidate#owner
 * @see yfiles.layout.LabelCandidate#modelParameter
 * @see yfiles.layout.LabelCandidate#box
 * @return {void}
 */
yfiles.layout.LabelCandidate.prototype.propagate = function() {};
/**
 * @record
 * @struct
 */
yfiles.layout.LabelLayoutBase = function() {};
 /** @type {!yfiles.algorithms.YOrientedRectangle} */
yfiles.layout.LabelLayoutBase.prototype.orientedBox;
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.layout.LabelLayoutBase.prototype.boundingBox;
 /** @type {!Object} */
yfiles.layout.LabelLayoutBase.prototype.modelParameter;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LabelLayoutBase.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.LabelLayoutData = function() {};
 /** @type {!yfiles.algorithms.YOrientedRectangle} */
yfiles.layout.LabelLayoutData.prototype.bounds;
 /** @type {number} */
yfiles.layout.LabelLayoutData.prototype.width;
 /** @type {number} */
yfiles.layout.LabelLayoutData.prototype.height;
 /** @type {number} */
yfiles.layout.LabelLayoutData.prototype.x;
 /** @type {number} */
yfiles.layout.LabelLayoutData.prototype.y;
 /** @type {!yfiles.layout.PreferredPlacementDescriptor} */
yfiles.layout.LabelLayoutData.prototype.preferredPlacementDescriptor;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LabelLayoutData.$class;

/**
 * Specifies the coordinates of the upper-left corner of the bounding box of the label.
 * @see yfiles.layout.LabelLayoutData#x
 * @see yfiles.layout.LabelLayoutData#y
 * @see yfiles.algorithms.YOrientedRectangle#boundingBox
 * @param {number} x the new x-coordinate of the upper-left corner
 * @param {number} y the new y-coordinate of the upper-left corner
 * @return {void}
 */
yfiles.layout.LabelLayoutData.prototype.setLocation = function(x, y) {};

/**
 * Specifies the width and height of the {\@link yfiles.layout.LabelLayoutData#bounds oriented box} of this label.
 * @see yfiles.layout.LabelLayoutData#bounds
 * @param {number} width the width of the oriented box
 * @param {number} height the height of the oriented box
 * @return {void}
 */
yfiles.layout.LabelLayoutData.prototype.setSize = function(width, height) {};
/**
 * @record
 * @struct
 */
yfiles.layout.LabelLayoutKeys = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.layout.LabelLayoutData>} */
yfiles.layout.LabelLayoutKeys.EDGE_LABEL_LAYOUT_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.layout.LabelLayoutData>} */
yfiles.layout.LabelLayoutKeys.NODE_LABEL_LAYOUT_DP_KEY;
 /** @type {!yfiles.algorithms.ILabelLayoutDpKey<boolean>} */
yfiles.layout.LabelLayoutKeys.IGNORED_LABELS_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LabelLayoutKeys.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.LabelLayoutTranslator = function() {};
 /** @type {?} */
yfiles.layout.LabelLayoutTranslator.prototype.coreLayout;
 /** @type {boolean} */
yfiles.layout.LabelLayoutTranslator.prototype.autoFlippingEnabled;
 /** @type {boolean} */
yfiles.layout.LabelLayoutTranslator.prototype.resettingNodeLabelOrientation;
 /** @type {boolean} */
yfiles.layout.LabelLayoutTranslator.prototype.resettingEdgeLabelOrientation;
 /** @type {boolean} */
yfiles.layout.LabelLayoutTranslator.prototype.writeBackEdgeLabels;
 /** @type {boolean} */
yfiles.layout.LabelLayoutTranslator.prototype.writeBackRelativeEdgeLabelLocation;
 /** @type {boolean} */
yfiles.layout.LabelLayoutTranslator.prototype.writeBackNodeLabels;
 /** @type {boolean} */
yfiles.layout.LabelLayoutTranslator.prototype.writeBackRelativeNodeLabelLocation;
 /** @type {boolean} */
yfiles.layout.LabelLayoutTranslator.prototype.translateNodeLabels;
 /** @type {boolean} */
yfiles.layout.LabelLayoutTranslator.prototype.translateEdgeLabels;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LabelLayoutTranslator.$class;

/**
 * Translates traditional {\@link yfiles.layout.ILabelLayout} information to {\@link yfiles.algorithms.IDataProvider}-based
 * {\@link yfiles.layout.LabelLayoutData}.
 * <p>
 * Afterwards, the calculated layout data will be written back to the original label layout.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.LabelLayoutTranslator.prototype.applyLayout = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.LayoutGraph = function() {};
 /** @type {!yfiles.algorithms.EdgeList} */
yfiles.layout.LayoutGraph.prototype.edgeList;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LayoutGraph.$class;

/**
 * Creates a new {\@link yfiles.layout.ILabelLayoutFactory} for this {\@link yfiles.layout.LayoutGraph} that can be used for copying layout
 * information of labels.
 * @protected
 * @abstract
 * @return {?} the new {\@link }
 */
yfiles.layout.LayoutGraph.prototype.createLabelFactory = function() {};

/**
 * Returns the rectangle describing the bounding box of the given node.
 * @see yfiles.layout.LayoutGraph#getLocation
 * @see yfiles.layout.LayoutGraph#getSize
 * @param {!yfiles.algorithms.Node} node the node
 * @return {!yfiles.algorithms.YRectangle} the bounds of the node
 */
yfiles.layout.LayoutGraph.prototype.getBoundingBox = function(node) {};

/**
 * Returns the center coordinates of the given node.
 * @see yfiles.layout.INodeLayout
 * @see yfiles.layout.LayoutGraph#setCenter
 * @param {!yfiles.algorithms.Node} node the node
 * @return {!yfiles.algorithms.YPoint} the location of the node's center
 */
yfiles.layout.LayoutGraph.prototype.getCenter = function(node) {};

/**
 * Returns the x-coordinate of the given node's center.
 * @see yfiles.layout.INodeLayout
 * @param {!yfiles.algorithms.Node} node the node
 * @return {number} the x-value of the node's center coordinate
 */
yfiles.layout.LayoutGraph.prototype.getCenterX = function(node) {};

/**
 * Returns the y-coordinate of the given node's center.
 * @see yfiles.layout.INodeLayout
 * @param {!yfiles.algorithms.Node} node the node
 * @return {number} the y-value of the node's center coordinate
 */
yfiles.layout.LayoutGraph.prototype.getCenterY = function(node) {};

/**
 * Returns the height of the given node.
 * @see yfiles.layout.INodeLayout#height
 * @param {!yfiles.algorithms.Node} node the node
 * @return {number} the height of the node
 */
yfiles.layout.LayoutGraph.prototype.getHeight = function(node) {};

/**
 * Returns the layout information for all labels associated with the given edge.
 * <p>
 * The layout information consists of the location, size and orientation of the label.
 * </p>
 * @abstract
 * Returns the layout information for all labels associated with the given node.
 * <p>
 * The layout information consists of the location, size and orientation of the label.
 * </p>
 * @abstract
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} edge_or_node the edge / the node
 * @return {!Array<?>} the layout information for the edge's labels / the layout information for the node's labels
 */
yfiles.layout.LayoutGraph.prototype.getLabelLayout = function(edge_or_node) {};

/**
 * Returns the layout information for the given edge.
 * <p>
 * The layout information consists of the locations of the control points and end points of the edge.
 * </p>
 * @abstract
 * Returns the layout information for the given node.
 * <p>
 * The layout information consists of the location and size of the node.
 * </p>
 * @abstract
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node} edge_or_node the edge / the node
 * @return {?} the layout information for the edge / the layout information for the node
 */
yfiles.layout.LayoutGraph.prototype.getLayout = function(edge_or_node) {};

/**
 * Returns the coordinates of the given node's upper-left corner.
 * @see yfiles.layout.INodeLayout#x
 * @see yfiles.layout.INodeLayout#y
 * @param {!yfiles.algorithms.Node} node the node
 * @return {!yfiles.algorithms.YPoint} the location of the node's upper-left corner
 */
yfiles.layout.LayoutGraph.prototype.getLocation = function(node) {};

/**
 * Returns the edge to which the given {\@link yfiles.layout.IEdgeLabelLayout} belongs.
 * @abstract
 * @param {?} labelLayout the label's layout information
 * @return {!yfiles.algorithms.Edge} the edge that owns the label
 */
yfiles.layout.LayoutGraph.prototype.getOwnerEdge = function(labelLayout) {};

/**
 * Returns the node to which the given {\@link yfiles.layout.INodeLabelLayout} belongs.
 * @abstract
 * @param {?} labelLayout the label's layout information
 * @return {!yfiles.algorithms.Node} the node that owns the label
 */
yfiles.layout.LayoutGraph.prototype.getOwnerNode = function(labelLayout) {};

/**
 * Returns the path of an edge, including the ports.
 * <p>
 * The path of an edge is the position of the source port, followed by the positions of the bends, followed by the position
 * of the target port.
 * </p>
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {!yfiles.algorithms.YPointPath} the path of the given edge
 */
yfiles.layout.LayoutGraph.prototype.getPath = function(edge) {};

/**
 * Returns the path of an edge, including the ports.
 * <p>
 * The path of an edge is the position of the source port, followed by the positions of the bends, followed by the position
 * of the target port.
 * </p>
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {!yfiles.algorithms.YList} a list of {\@link }s representing the path of the given edge
 */
yfiles.layout.LayoutGraph.prototype.getPathList = function(edge) {};

/**
 * Returns the control points of an edge.
 * @see yfiles.layout.IEdgeLayout
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {!yfiles.algorithms.YList} a list of {\@link }s representing the sequence of control points of the edge
 */
yfiles.layout.LayoutGraph.prototype.getPointList = function(edge) {};

/**
 * Returns the control points of an edge.
 * @see yfiles.layout.IEdgeLayout
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {!yfiles.algorithms.YPointPath} a {\@link } representing the sequence of control points of the edge
 */
yfiles.layout.LayoutGraph.prototype.getPoints = function(edge) {};

/**
 * Returns the size of the given node.
 * @see yfiles.layout.INodeLayout#width
 * @see yfiles.layout.INodeLayout#height
 * @param {!yfiles.algorithms.Node} node the node
 * @return {!yfiles.algorithms.YDimension} the size of the node
 */
yfiles.layout.LayoutGraph.prototype.getSize = function(node) {};

/**
 * Returns the absolute coordinates of the source point of the given edge.
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {!yfiles.algorithms.YPoint} the absolute source point coordinates of the edge
 */
yfiles.layout.LayoutGraph.prototype.getSourcePointAbs = function(edge) {};

/**
 * Returns the relative coordinates of the source point of the given edge.
 * <p>
 * The coordinates are interpreted relative to the center of the source node.
 * </p>
 * @see yfiles.layout.IEdgeLayout#sourcePoint
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {!yfiles.algorithms.YPoint} the relative source point coordinates of the edge
 */
yfiles.layout.LayoutGraph.prototype.getSourcePointRel = function(edge) {};

/**
 * Returns the absolute coordinates of the target point of the given edge.
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {!yfiles.algorithms.YPoint} the absolute target point coordinates of the edge
 */
yfiles.layout.LayoutGraph.prototype.getTargetPointAbs = function(edge) {};

/**
 * Returns the relative coordinates of the target point of the given edge.
 * <p>
 * The coordinates are interpreted relative to the center of the target node.
 * </p>
 * @see yfiles.layout.IEdgeLayout#targetPoint
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {!yfiles.algorithms.YPoint} the relative target point coordinates of the edge
 */
yfiles.layout.LayoutGraph.prototype.getTargetPointRel = function(edge) {};

/**
 * Returns the width of the given node.
 * @see yfiles.layout.INodeLayout#width
 * @param {!yfiles.algorithms.Node} node the node
 * @return {number} the width of the node
 */
yfiles.layout.LayoutGraph.prototype.getWidth = function(node) {};

/**
 * Returns the x-coordinate of the given node's upper-left corner.
 * @see yfiles.layout.INodeLayout#x
 * @param {!yfiles.algorithms.Node} node the node
 * @return {number} the x-value of the node's upper-left corner
 */
yfiles.layout.LayoutGraph.prototype.getX = function(node) {};

/**
 * Returns the y-coordinate of the given node's upper-left corner.
 * @see yfiles.layout.INodeLayout#y
 * @param {!yfiles.algorithms.Node} node the node
 * @return {number} the y-value of the node's upper-left corner
 */
yfiles.layout.LayoutGraph.prototype.getY = function(node) {};

/**
 * Moves the upper-left corner of a node by a given vector.
 * @param {!yfiles.algorithms.Node} node the node
 * @param {number} dx the x-component of the vector
 * @param {number} dy the y-component of the vector
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.moveBy = function(node, dx, dy) {};

/**
 * Specifies the center coordinates of the given node.
 * @see yfiles.layout.INodeLayout
 * Specifies the center coordinates of the given node.
 * @see yfiles.layout.INodeLayout
 * @see yfiles.layout.LayoutGraph#setCenter
 * @param {!yfiles.algorithms.Node} node the node
 * @param {number|!yfiles.algorithms.YPoint} x_or_position the new x-coordinate of the node's center / the new location of the node's center
 * @param {number=} y the new y-coordinate of the node's center
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setCenter = function(node, x_or_position, y) {};

/**
 * Specifies the two end points of the given edge in absolute coordinates.
 * @see yfiles.layout.LayoutGraph#setSourcePointAbs
 * @see yfiles.layout.LayoutGraph#setTargetPointAbs
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {!yfiles.algorithms.YPoint} source the port on the source side of the edge
 * @param {!yfiles.algorithms.YPoint} target the port on the target side of the edge
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setEndPointsAbs = function(edge, source, target) {};

/**
 * Specifies the coordinates of the upper-left corner of the given node.
 * @see yfiles.layout.INodeLayout#setLocation
 * Specifies the coordinates of the upper-left corner of the given node.
 * @see yfiles.layout.INodeLayout#setLocation
 * @see yfiles.layout.LayoutGraph#setLocation
 * @param {!yfiles.algorithms.Node} node the node
 * @param {number|!yfiles.algorithms.YPoint} x_or_position the new x-coordinate of the upper-left corner / the new location of the upper-left corner
 * @param {number=} y the new y-coordinate of the upper-left corner
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setLocation = function(node, x_or_position, y) {};

/**
 * Sets the path of the given edge.
 * <p>
 * The path of an edge is the position of the source port, followed by the positions of the bends, followed by the position
 * of the target port.
 * </p>
 * <p>
 * Both source and target port are expected to be given in absolute coordinates.
 * </p>
 * Sets the path of the given edge.
 * <p>
 * The path of an edge is the position of the source port, followed by the positions of the bends, followed by the position
 * of the target port.
 * </p>
 * <p>
 * Both source and target port are expected to be given in absolute coordinates.
 * </p>
 * @param {!yfiles.algorithms.Edge} edge an edge in the graph
 * @param {!yfiles.algorithms.YList|!yfiles.algorithms.YPointPath} path the list of {\@link }s representing the new path sequence of the edge / the new path sequence of the edge
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setPath = function(edge, path) {};

/**
 * Sets the control points of the given edge.
 * <p>
 * The source and target points of the edge will not be modified.
 * </p>
 * Sets the control points of the given edge.
 * <p>
 * The source and target points of the edge will not be modified.
 * </p>
 * @param {!yfiles.algorithms.Edge} edge an edge in the graph
 * @param {!yfiles.algorithms.YList|!yfiles.algorithms.YPointPath} points the list of {\@link }s representing the new sequence of control points / the new sequence of control points
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setPoints = function(edge, points) {};

/**
 * Specifies the width and height of the given node.
 * @see yfiles.layout.INodeLayout#setSize
 * Specifies the size of the given node.
 * @see yfiles.layout.LayoutGraph#setSize
 * @see yfiles.layout.INodeLayout#setSize
 * @param {!yfiles.algorithms.Node} node the node
 * @param {number|!yfiles.algorithms.YDimension} width_or_size the new width of the node / the new size of the node
 * @param {number=} height the new height of the node
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setSize = function(node, width_or_size, height) {};

/**
 * Specifies the absolute coordinates of the source point of the given edge.
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {!yfiles.algorithms.YPoint} point the new absolute source point coordinates of the edge
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setSourcePointAbs = function(edge, point) {};

/**
 * Specifies the relative coordinates of the source point of the given edge.
 * <p>
 * The coordinates are interpreted relative to the center of the source node.
 * </p>
 * @see yfiles.layout.IEdgeLayout#sourcePoint
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {!yfiles.algorithms.YPoint} point the new relative source point coordinates of the edge
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setSourcePointRel = function(edge, point) {};

/**
 * Specifies the absolute coordinates of the target point of the given edge.
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {!yfiles.algorithms.YPoint} point the new absolute target point coordinates of the edge
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setTargetPointAbs = function(edge, point) {};

/**
 * Specifies the relative coordinates of the target point of the given edge.
 * <p>
 * The coordinates are interpreted relative to the center of the target node.
 * </p>
 * @see yfiles.layout.IEdgeLayout#targetPoint
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {!yfiles.algorithms.YPoint} point the new relative target point coordinates of the edge
 * @return {void}
 */
yfiles.layout.LayoutGraph.prototype.setTargetPointRel = function(edge, point) {};
/**
 * @record
 * @struct
 */
yfiles.layout.LayoutGraphUtilities = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LayoutGraphUtilities.$class;

/**
 * Aligns the specified nodes either vertically or horizontally according to the specified node alignment mode.
 * <p>
 * For vertical arrangements, nodes are either {\@link yfiles.layout.NodeAlignment#LEADING top-aligned}, {\@link yfiles.layout.NodeAlignment#CENTERED center-aligned}, {\@link yfiles.layout.NodeAlignment#TRAILING bottom-aligned}, or {\@link yfiles.layout.NodeAlignment#DISTRIBUTED vertically distributed}.
 * </p>
 * <p>
 * For horizontal arrangements, nodes are either {\@link yfiles.layout.NodeAlignment#LEADING left-aligned}, {\@link yfiles.layout.NodeAlignment#CENTERED center-aligned}, {\@link yfiles.layout.NodeAlignment#TRAILING right-aligned}, or {\@link yfiles.layout.NodeAlignment#DISTRIBUTED horizontally distributed}.
 * </p>
 * <p>
 * In this context, <em>distributed</em> means that the specified nodes are placed in such a way that the projections of their bounds onto the
 * vertical or horizontal coordinate axis do not overlap. For example, after vertically distributing nodes, <code>(n1.y + n1.height) &lt;= n2.y</code>
 * for two consecutively placed nodes <code>n1</code> and <code>n2</code>.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the graph that contains the specified nodes
 * @param {!yfiles.algorithms.NodeList} nodes the subset of the specified graph's nodes that is arranged
 * @param {!yfiles.algorithms.Node} referenceNode if <code>null</code>, the common coordinate for aligning the specified nodes is calculated as the the vertical minimum (top-aligned),
 * the vertical center, the vertical maximum (bottom-aligned), the horizontal minimum (left-aligned), the horizontal
 * center, or the horizontal maximum (right-aligned) of the bounds of the specified nodes; otherwise the appropriate
 * coordinate of the given reference node's bounds is used as common coordinate for aligning the specified nodes. The
 * reference node is ignored when {\@link #DISTRIBUTED distributing} nodes.
 * @param {boolean} vertical <code>true</code> if nodes should be aligned (or distributed) according to their y-coordinates; otherwise nodes are aligned (or
 * distributed) according to their x-coordinates.
 * @param {yfiles.layout.NodeAlignment} mode one of the valid alignment modes
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.alignNodeLayouts = function(graph, nodes, referenceNode, vertical, mode) {};

/**
 * Reassigns the bounds of the rectangles in a grid to fit in a large rectangle with an aspect ratio close to the specified
 * aspect ratio.
 * <p>
 * The aspect ratio must be greater than <code>0</code>.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given aspect ratio is less than or equal to zero
 * @param {!Array<!yfiles.algorithms.Rectangle2D>} rectangles the rectangles whose coordinates will be modified
 * @param {!yfiles.algorithms.Rectangle2D} finalRect the exact dimension will be placed in this rectangle
 * @param {number} aspectRatio the preferred aspect ratio of the grid
 * @return {!yfiles.algorithms.YDimension} the dimension of the grid
 */
yfiles.layout.LayoutGraphUtilities.arrangeRectangleGrid = function(rectangles, finalRect, aspectRatio) {};

/**
 * Reassigns the bounds of the rectangles in multiple rows to fit the preferred width and height.
 * <p>
 * The rectangles will be placed within this bound, arranged in rows, where each row may be split into more sub-rows. This
 * often leads to more compact results than provided by the procedure used in
 * {\@link yfiles.layout.LayoutGraphUtilities#arrangeRectangleRows}. A row will be subdivided into more rows, if two successive
 * rectangles to be placed in the row could be placed stacked within this row without making the row larger in height.
 * </p>
 * <p>
 * The preferred width and height should be greater than <code>0</code>, otherwise the nodes are not arranged.
 * </p>
 * @see yfiles.layout.LayoutGraphUtilities#arrangeRectangleMultiRows
 * @param {!Array<!yfiles.algorithms.Rectangle2D>} rectangles the rectangles to arrange (coordinates will be assigned)
 * @param {!yfiles.algorithms.Rectangle2D} finalRect the exact resulting dimension will be stored in this rectangle
 * @param {number} preferredWidth the preferred width of the result rectangle
 * @param {number} preferredHeight the preferred height of the result rectangle
 * @param {boolean} compaction <code>true</code> if the algorithm tries to always minimize the resulting dimension, whilst respecting the given constraints, <code>false</code>
 * otherwise
 * @param {yfiles.layout.MultiRowConstraint} constraintMode the width or height constraints to consider
 * @param {yfiles.layout.RowAlignment=} alignment
 * @return {number} the number of rows used
 */
yfiles.layout.LayoutGraphUtilities.arrangeRectangleMultiRows = function(rectangles, finalRect, preferredWidth, preferredHeight, compaction, constraintMode, alignment) {};

/**
 * Reassigns the bounds of the rectangles to fit in a large rectangle with an aspect ratio close to the specified aspect
 * ratio.
 * <p>
 * This is achieved by arranging the rectangles in rows.
 * </p>
 * <p>
 * The aspect ratio must be greater than <code>0</code>.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the aspect ratio is <code>0</code> or less
 * @param {!Array<!yfiles.algorithms.Rectangle2D>} rectangles the rectangles whose coordinates will be modified
 * @param {!yfiles.algorithms.Rectangle2D} finalRect the exact dimension of the resulting rectangle
 * @param {number} aspectRatio the preferred aspect ratio of the resulting rectangle
 * @param {yfiles.layout.RowAlignment=} alignment
 * @return {number} the number of used rows
 */
yfiles.layout.LayoutGraphUtilities.arrangeRectangleRows = function(rectangles, finalRect, aspectRatio, alignment) {};

/**
 * Applies the reversed layout of the first edge to the second edge.
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which both edges belong
 * @param {!yfiles.algorithms.Edge} edge1 the edge which adopts the points
 * @param {!yfiles.algorithms.Edge} edge2 the template
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.assignReverseLayout = function(graph, edge1, edge2) {};

/**
 * Flips the orientation of a given rectangle, if its up vector points downward <code>(</code>{\@link yfiles.algorithms.YOrientedRectangle#upY upY}<code> > 0)</code>.
 * <p>
 * That means, it rotates the rectangle by <code>180</code> degrees without changing the rectangle's center.
 * </p>
 * @param {!yfiles.algorithms.YOrientedRectangle} rect the given rectangle
 * @return {boolean} <code>true</code> if the given rectangle was flipped, <code>false</code> otherwise
 */
yfiles.layout.LayoutGraphUtilities.autoFlipBox = function(rect) {};

/**
 * Clips the path of the given edge on the bounding box of the source and target points.
 * <p>
 * On a clipped edge, the source and target port will be located at the border of the corresponding node.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the edge belongs
 * @param {!yfiles.algorithms.Edge} edge the edge to clip
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.clipEdgeOnBounds = function(graph, edge) {};

/**
 * Returns the path of an edge clipped on the bounding box of the source and target node.
 * <p>
 * On the clipped edge, the source and target port will be located at the border of the corresponding node.
 * </p>
 * Returns the path of an edge clipped on insets of the bounding box of the source and target node.
 * <p>
 * On the clipped edge, the source and target port will be located inside the node with an inset to the border of the
 * corresponding node.
 * </p>
 * @param {!yfiles.layout.LayoutGraph|?} graph_or_edge the graph to which the edge belongs / the clipped edge
 * @param {!yfiles.algorithms.Edge|?} edge_or_source the clipped edge / the source of the edge
 * @param {?=} target the target of the edge
 * @param {number=} inset
 * @return {!yfiles.algorithms.YPointPath} the clipped path of the edge
 */
yfiles.layout.LayoutGraphUtilities.clipEdgePathOnBounds = function(graph_or_edge, edge_or_source, target, inset) {};

/**
 * Clips the path of all edges in the graph on the bounding box of their source and target points.
 * <p>
 * On a clipped edge, the source and target port will be located at the border of the corresponding node.
 * </p>
 * @see yfiles.layout.LayoutGraphUtilities#clipEdgeOnBounds
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.clipEdgesOnBounds = function(graph) {};

/**
 * Returns the path of a given edge path clipped on the given bounding boxes of the source and target node.
 * @param {!yfiles.algorithms.YPointPath} path the path that will be clipped
 * @param {!yfiles.algorithms.YRectangle} sourceBox the box of the source node that the given path should be clipped at
 * @param {!yfiles.algorithms.YRectangle} targetBox the box of the target node that the given path should be clipped at
 * @return {!yfiles.algorithms.YPointPath} the path clipped on the given nodes boxes
 */
yfiles.layout.LayoutGraphUtilities.clipPathOnBounds = function(path, sourceBox, targetBox) {};

/**
 * Determines the main direction of the edge flow by analyzing the current layout of the graph.
 * <p>
 * The method only considers edges that are marked in the given {\@link yfiles.algorithms.IDataProvider}.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the underlying graph
 * @param {?} considerEdges the edges to consider
 * @return {yfiles.layout.EdgeFlow} one of the predefined flow directions
 */
yfiles.layout.LayoutGraphUtilities.determineEdgeFlowDirection = function(graph, considerEdges) {};

/**
 * Returns a {\@link string} representation of the path of the given edge.
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the edge belongs
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {string} the {\@link } that contains all control points of the edge
 */
yfiles.layout.LayoutGraphUtilities.edgeLayoutString = function(graph, edge) {};

/**
 * Returns the bounding box of the given edge.
 * <p>
 * In this case, the bounding box is the smallest paraxial rectangle which contains the control points as well as the
 * absolute coordinates of the source and target point of the edge.
 * </p>
 * @see yfiles.layout.LayoutGraph#getSourcePointAbs
 * @see yfiles.layout.LayoutGraph#getTargetPointAbs
 * @see yfiles.layout.LayoutGraph#getLayout
 * Returns the bounding box of the given node.
 * <p>
 * In this case, the bounding box is the smallest paraxial rectangle which contains the given node. It is identical to the
 * node's bounds.
 * </p>
 * @see yfiles.layout.LayoutGraph#getLayout
 * Returns the bounding box of the nodes and edges accessible through the given cursors, optionally including node labels,
 * edge labels or {\@link yfiles.layout.NodeHalo}s.
 * <p>
 * In this case, the bounding box is the smallest paraxial rectangle which contains the given nodes and the control points
 * as well as the source and target points of all edges. If node or edge labels should be included, it also contains their
 * boxes. {\@link yfiles.layout.NodeHalo}s can also extend the bounding box if desired.
 * </p>
 * Returns the bounding box of the nodes and edges accessible through the given cursors, optionally including node labels
 * and edge labels.
 * <p>
 * In this case, the bounding box is the smallest paraxial rectangle which contains the given nodes and the control points
 * as well as the source and target points of all edges. If labels should be included, it also contains their boxes.
 * </p>
 * @see yfiles.layout.LayoutGraphUtilities#getBoundingBox
 * Returns the bounding box of the nodes and edges accessible through the given cursors.
 * <p>
 * In this case, the bounding box is the smallest paraxial rectangle which contains the given nodes and the control points
 * as well as the source and target points of all edges.
 * </p>
 * @see yfiles.layout.LayoutGraphUtilities#getBoundingBoxOfEdges
 * @see yfiles.layout.LayoutGraphUtilities#getBoundingBoxOfNodes
 * @param {!yfiles.layout.LayoutGraph} graph the graph that contains the edge / the graph that contains the node / the graph that contains the given nodes and edges / the graph that contains the nodes and edges
 * @param {!yfiles.algorithms.Edge|!yfiles.algorithms.Node|?} edge_or_node_or_nodes the edge / the node / the nodes to include in the bounding box
 * @param {?=} edges the edges to include in the bounding box
 * @param {boolean=} includeNodeLabels_or_includeLabels <code>true</code> if labels of nodes should be included, <code>false</code> otherwise / <code>true</code> if labels of nodes and edges should be included, <code>false</code> otherwise
 * @param {boolean=} includeEdgeLabels <code>true</code> if labels of edges should be included, <code>false</code> otherwise
 * @param {boolean=} includeHalos
 * @return {!yfiles.algorithms.Rectangle2D} the bounding box of the edge / the bounding box of the node / the bounding box of the given nodes and edges / the bounding box containing the given nodes and edges
 */
yfiles.layout.LayoutGraphUtilities.getBoundingBox = function(graph, edge_or_node_or_nodes, edges, includeNodeLabels_or_includeLabels, includeEdgeLabels, includeHalos) {};

/**
 * Returns the bounding box of the edges accessible through the given cursor.
 * <p>
 * In this case, the bounding box is the smallest paraxial rectangle which contains the control points as well as the
 * absolute coordinates of the source and target points of all given edges.
 * </p>
 * @see yfiles.layout.LayoutGraph#getSourcePointAbs
 * @see yfiles.layout.LayoutGraph#getTargetPointAbs
 * @see yfiles.layout.LayoutGraph#getLayout
 * @param {!yfiles.layout.LayoutGraph} graph the graph that contains the edges
 * @param {?} edges the edges to include in the bounding box
 * @return {!yfiles.algorithms.Rectangle2D} the bounding box containing the given edges
 */
yfiles.layout.LayoutGraphUtilities.getBoundingBoxOfEdges = function(graph, edges) {};

/**
 * Returns the bounding box of the nodes accessible through the given cursor.
 * <p>
 * In this case, the bounding box is the smallest paraxial rectangle which contains the given nodes.
 * </p>
 * @see yfiles.layout.LayoutGraph#getLayout
 * @param {!yfiles.layout.LayoutGraph} graph the graph that contains the nodes
 * @param {?} nodes the nodes to include in the bounding box
 * @return {!yfiles.algorithms.Rectangle2D} the bounding box containing the given nodes
 */
yfiles.layout.LayoutGraphUtilities.getBoundingBoxOfNodes = function(graph, nodes) {};

/**
 * Returns the {\@link yfiles.layout.ILabelLayoutFactory} for the given graph.
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @return {?} the label factory of the graph
 */
yfiles.layout.LayoutGraphUtilities.getLabelFactory = function(graph) {};

/**
 * Returns the upper-left corner of the paraxial bounding box of the given edge label as encoded by the specified model
 * parameter.
 * <p>
 * The parameter describes the abstract position of the label within the specified model. The parameter must have been
 * generated by that model.
 * </p>
 * @see yfiles.layout.IEdgeLabelLayoutModel#getLabelPlacement
 * @see yfiles.algorithms.YOrientedRectangle#boundingBox
 * Returns the upper-left corner of the paraxial bounding box of the given node label as encoded by the specified model
 * parameter.
 * <p>
 * The parameter describes the abstract position of the label within the specified model. The parameter must have been
 * generated by that model.
 * </p>
 * @see yfiles.layout.INodeLabelLayoutModel#getLabelPlacement
 * @see yfiles.algorithms.YOrientedRectangle#boundingBox
 * @param {?} model the {\@link } used for placing the label
 * @param {!yfiles.algorithms.YDimension} labelSize the size of the label that should be placed / the size of the label
 * @param {?} edgeLayout_or_nodeLayout the layout of the edge to which the label belongs / the layout of the node to which the label belongs
 * @param {?|!Object} sourceLayout_or_param the layout of the edge's source node / the model parameter
 * @param {?=} targetLayout the layout of the edge's target node
 * @param {!Object=} param the model parameter
 * @return {!yfiles.algorithms.YPoint} the upper-left corner of the label's bounding box
 */
yfiles.layout.LayoutGraphUtilities.getLabelPlacement = function(model, labelSize, edgeLayout_or_nodeLayout, sourceLayout_or_param, targetLayout, param) {};

/**
 * Returns the distance between the centers of the two given nodes.
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the nodes belong
 * @param {!yfiles.algorithms.Node} node1 the first node
 * @param {!yfiles.algorithms.Node} node2 the second node
 * @return {number} the distance between the nodes' centers
 */
yfiles.layout.LayoutGraphUtilities.getNodeDistance = function(graph, node1, node2) {};

/**
 * Returns a {\@link string} representation of all node positions in the graph.
 * @see yfiles.layout.LayoutGraph#getLocation
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @return {string} the {\@link } containing all node locations
 */
yfiles.layout.LayoutGraphUtilities.getNodePositions = function(graph) {};

/**
 * Returns the length of the path of the given edge.
 * <p>
 * The path starts at the source point, traverses through all control points and ends at the target point.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the edge belongs
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {number} the length of the edge's path
 */
yfiles.layout.LayoutGraphUtilities.getPathLength = function(graph, edge) {};

/**
 * Checks whether or not the path of an edge is outside the bounding box of the source and target node, considering the
 * given halo.
 * <p>
 * The edge is outside the nodes if its control points as well as the source and target point are not inside the nodes'
 * bounding boxes.
 * </p>
 * <p>
 * The nodes can be enlarged by a halo to check if the edge keeps some distance to the nodes.
 * </p>
 * Checks whether or not the path of an edge is outside the bounding box of the source and target node.
 * <p>
 * The edge is outside the nodes if its control points as well as the source and target point are not inside the nodes'
 * bounding boxes.
 * </p>
 * @param {?|!yfiles.layout.LayoutGraph} edge_or_graph the edge / the graph to which the edge belongs
 * @param {?|!yfiles.algorithms.Edge} source_or_edge the source of the edge / the edge
 * @param {?=} target the target of the edge
 * @param {number=} halo the halo for the nodes
 * @return {boolean} <code>true</code> if the edge is outside the nodes, <code>false</code> otherwise
 */
yfiles.layout.LayoutGraphUtilities.isEdgeOutsideNodes = function(edge_or_graph, source_or_edge, target, halo) {};

/**
 * Determines whether or not most of the edges of the graph are routed octilinear.
 * <p>
 * The method only considers edges marked in the given {\@link yfiles.algorithms.IDataProvider}.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the underlying graph
 * @param {?} considerEdges the edges to consider
 * @return {boolean} <code>true</code> if most of the edges in the graph are routed octilinear, <code>false</code> otherwise
 */
yfiles.layout.LayoutGraphUtilities.isUsingOctilinearEdgeRoutes = function(graph, considerEdges) {};

/**
 * Determines whether or not most of the edges of the graph are routed orthogonally.
 * <p>
 * The method only considers edges marked in the given {\@link yfiles.algorithms.IDataProvider}.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the underlying graph
 * @param {?} considerEdges the edges to consider
 * @return {boolean} <code>true</code> if most of the edges in the graph are routed orthogonally, <code>false</code> otherwise
 */
yfiles.layout.LayoutGraphUtilities.isUsingOrthogonalEdgeRoutes = function(graph, considerEdges) {};

/**
 * Moves all control points of the given edge by the vector <code>(dx,dy)</code>.
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {number} dx the horizontal distance to move
 * @param {number} dy the vertical distance to move
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.moveEdge = function(graph, edge, dx, dy) {};

/**
 * Moves the control points of all edges accessible through the given {\@link yfiles.algorithms.IEdgeCursor} by the vector <code>(dx,dy)</code>.
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {?} edges the edges to be moved
 * @param {number} dx the horizontal distance to move
 * @param {number} dy the vertical distance to move
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.moveEdges = function(graph, edges, dx, dy) {};

/**
 * Moves the given node by the vector <code>(dx,dy)</code>.
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {!yfiles.algorithms.Node} node the node
 * @param {number} dx the horizontal distance to move
 * @param {number} dy the vertical distance to move
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.moveNode = function(graph, node, dx, dy) {};

/**
 * Moves all nodes accessible through the given {\@link yfiles.algorithms.INodeCursor} by the vector <code>(dx,dy)</code>.
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {?} nodes the nodes to be moved
 * @param {number} dx the horizontal distance to move
 * @param {number} dy the vertical distance to move
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.moveNodes = function(graph, nodes, dx, dy) {};

/**
 * Moves the subgraph induced by the nodes accessible through the given {\@link yfiles.algorithms.INodeCursor} by the vector
 * <code>(dx,dy)</code>.
 * @param {!yfiles.layout.LayoutGraph} graph the graph that contains the subgraph
 * @param {?} nodes the nodes that induce the subgraph
 * @param {number} dx the horizontal distance to move
 * @param {number} dy the vertical distance to move
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.moveSubgraph = function(graph, nodes, dx, dy) {};

/**
 * Moves the subgraph induced by the edges accessible through the given {\@link yfiles.algorithms.IEdgeCursor} by the vector
 * <code>(dx,dy)</code>.
 * @param {!yfiles.layout.LayoutGraph} graph the graph that contains the subgraph
 * @param {?} edges the edges that induce the subgraph
 * @param {number} dx the horizontal distance to move
 * @param {number} dy the vertical distance to move
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.moveSubgraphOfEdges = function(graph, edges, dx, dy) {};

/**
 * Checks whether or not the path of the given edge intersects the interior of a given rectangular area.
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the edge belongs
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {!yfiles.algorithms.Rectangle2D} rect the rectangular area to check for intersection
 * @return {boolean} <code>true</code> if the edge path intersects with the given rectangle, <code>false</code> otherwise
 */
yfiles.layout.LayoutGraphUtilities.pathIntersectsRect = function(graph, edge, rect) {};

/**
 * Removes successive bends that have the same coordinates from the given edge.
 * Removes successive bends that have the same coordinates from all edges in the graph.
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {!yfiles.algorithms.Edge=} edge the edge
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.removeDuplicateBends = function(graph, edge) {};

/**
 * Assigns a trivial path which has no control points to the specified edge.
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {boolean=} resetPorts
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.resetPath = function(graph, edge, resetPorts) {};

/**
 * Assigns a trivial path which has no control points to all edges in the specified graph.
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {boolean=} resetPorts
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.resetPaths = function(graph, resetPorts) {};

/**
 * Sets the ports of all edges in the graph to the center of the nodes.
 * @see yfiles.layout.LayoutGraph#setSourcePointRel
 * @see yfiles.layout.LayoutGraph#setTargetPointRel
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.resetPorts = function(graph) {};

/**
 * Reverses the layout of an edge.
 * <p>
 * The order of the control points is reversed and source and target point are swapped.
 * </p>
 * @param {?} el the layout information of an edge
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.reverseEdgeLayout = function(el) {};

/**
 * Rounds the locations of the control points and ports of the given edge to integer values.
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the edge belongs
 * @param {!yfiles.algorithms.Edge} edge the edge whose values are rounded
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.roundEdgeLayout = function(graph, edge) {};

/**
 * Rounds coordinates and sizes in the layout of an entire graph to integer values.
 * @see yfiles.layout.LayoutGraphUtilities#roundNodeLayout
 * @see yfiles.layout.LayoutGraphUtilities#roundEdgeLayout
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.roundLayout = function(graph) {};

/**
 * Rounds the location and size of the given node to integer values.
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the node belongs
 * @param {!yfiles.algorithms.Node} node the node whose values are rounded
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.roundNodeLayout = function(graph, node) {};

/**
 * Routes a list of edges which are incident to the same nodes in parallel, optionally joining the end points.
 * <p>
 * All edges get a path that is parallel to the path of the first (leading) edge.
 * </p>
 * <p>
 * The position of the leading edge may be adjusted if there is an odd number of parallel edges. It will be moved from the
 * center to achieve a more symmetric port assignment.
 * </p>
 * Routes a list of edges which are incident to the same nodes in parallel, optionally joining the end points.
 * <p>
 * All edges get a path that is parallel to the path of the first (leading) edge.
 * </p>
 * <p>
 * The position of the leading edge may be adjusted if there is an odd number of parallel edges. It will be moved from the
 * center to achieve a more symmetric port assignment.
 * </p>
 * Routes two edges which are incident to the same nodes in parallel, optionally joining the end points.
 * <p>
 * The second edge gets a path that is parallel to the path of the first (leading) edge.
 * </p>
 * Routes two edges which are incident to the same nodes in parallel, optionally joining the end points.
 * <p>
 * The second edge gets a path that is parallel to the path of the first (leading) edge.
 * </p>
 * @param {!yfiles.layout.LayoutGraph|{graph: !yfiles.layout.LayoutGraph, leadingEdge: !yfiles.algorithms.Edge, edges: !yfiles.algorithms.EdgeList, lineDistance: number, adjustLeadingEdge: boolean, joinEnds: boolean, absJoinDistance: number, relJoinDistance: number}|{graph: !yfiles.layout.LayoutGraph, leadingEdge: !yfiles.algorithms.Edge, edge: !yfiles.algorithms.Edge, lineDistance: number, joinEnds: boolean, absJoinDistance: number, relJoinDistance: number}} graph_or_options the graph
 * @param {!yfiles.algorithms.Edge=} leadingEdge the leading edge
 * @param {!yfiles.algorithms.EdgeList|!yfiles.algorithms.Edge=} edges_or_edge the list of edges that will be aligned with the leading edge / the edge to be adjusted
 * @param {number=} lineDistance the distance between two edges / the distance between the two edges
 * @param {boolean=} adjustLeadingEdge_or_joinEnds
 * @param {boolean|number=} joinEnds_or_absJoinDistance
 * @param {number=} absJoinDistance_or_relJoinDistance
 * @param {number=} relJoinDistance
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.routeEdgesParallel = function(graph_or_options, leadingEdge, edges_or_edge, lineDistance, adjustLeadingEdge_or_joinEnds, joinEnds_or_absJoinDistance, absJoinDistance_or_relJoinDistance, relJoinDistance) {};

/**
 * Routes a self-loop.
 * <p>
 * For a self-loop edge, source and target are identical. The path of the self-loop will start at the top of the node, go
 * around the upper-left corner and end at the left side of the node.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the edge belongs
 * @param {!yfiles.algorithms.Edge} edge the self-loop
 * @return {void}
 */
yfiles.layout.LayoutGraphUtilities.routeSelfLoop = function(graph, edge) {};
/**
 * @record
 * @struct
 */
yfiles.layout.LayoutMultiplexer = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.layout.LayoutMultiplexer.LAYOUT_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LayoutMultiplexer.$class;

/**
 * Returns the core layout algorithm associated with the nodes contained in the given graph.
 * <p>
 * This implementation looks up the layout algorithm in the {\@link yfiles.algorithms.IDataProvider} registered with the key
 * {\@link yfiles.layout.LayoutMultiplexer#LAYOUT_DP_KEY}. The first non-<code>null</code> {\@link yfiles.layout.ILayoutAlgorithm layout algorithm} instance found for a node of the
 * given graph will be returned by this method. If no algorithm is registered at all, it will fall back to the
 * {\@link yfiles.layout.LayoutStageBase#coreLayout default core layout algorithm}.
 * </p>
 * <p>
 * This method is called in {\@link yfiles.layout.LayoutMultiplexer#applyLayout} and may be overridden to implement a different way
 * of selecting the {\@link yfiles.layout.ILayoutAlgorithm layout algorithms}.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {?} the according layout algorithm
 */
yfiles.layout.LayoutMultiplexer.prototype.getCoreLayout = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.LayoutStageBase = function() {};
 /** @type {?} */
yfiles.layout.LayoutStageBase.prototype.coreLayout;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LayoutStageBase.$class;

/**
 *
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph
 * @return {void}
 */
yfiles.layout.LayoutStageBase.prototype.applyLayout = function(graph) {};

/**
 * Invokes the layout process of the {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm}.
 * <p>
 * Overriding classes may call this method during {\@link yfiles.layout.ILayoutAlgorithm#applyLayout} to delegate arranging the
 * graph to the {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm}. They can add pre- and post-processing code before and after this call.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.LayoutStageBase.prototype.applyLayoutCore = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.MinimumNodeSizeStage = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.MinimumNodeSizeStage.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.MultiStageLayout = function() {};
 /** @type {?} */
yfiles.layout.MultiStageLayout.prototype.labeling;
 /** @type {?} */
yfiles.layout.MultiStageLayout.prototype.selfLoopRouter;
 /** @type {?} */
yfiles.layout.MultiStageLayout.prototype.parallelEdgeRouter;
 /** @type {?} */
yfiles.layout.MultiStageLayout.prototype.componentLayout;
 /** @type {?} */
yfiles.layout.MultiStageLayout.prototype.subgraphLayout;
 /** @type {?} */
yfiles.layout.MultiStageLayout.prototype.hideGroupsStage;
 /** @type {?} */
yfiles.layout.MultiStageLayout.prototype.orientationLayout;
 /** @type {boolean} */
yfiles.layout.MultiStageLayout.prototype.orientationLayoutEnabled;
 /** @type {yfiles.layout.LayoutOrientation} */
yfiles.layout.MultiStageLayout.prototype.layoutOrientation;
 /** @type {boolean} */
yfiles.layout.MultiStageLayout.prototype.selfLoopRouterEnabled;
 /** @type {boolean} */
yfiles.layout.MultiStageLayout.prototype.labelingEnabled;
 /** @type {boolean} */
yfiles.layout.MultiStageLayout.prototype.hideGroupsStageEnabled;
 /** @type {boolean} */
yfiles.layout.MultiStageLayout.prototype.componentLayoutEnabled;
 /** @type {boolean} */
yfiles.layout.MultiStageLayout.prototype.parallelEdgeRouterEnabled;
 /** @type {boolean} */
yfiles.layout.MultiStageLayout.prototype.subgraphLayoutEnabled;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.MultiStageLayout.$class;

/**
 * Appends the given {\@link yfiles.layout.ILayoutStage} to the layout pipeline.
 * <p>
 * Stages that are added with this method will be invoked at the very end of the layout pipeline. This means after all
 * prepended {\@link yfiles.layout.ILayoutStage}s, all predefined stages, and all previously appended {\@link yfiles.layout.ILayoutStage}s,
 * but just before the invocation of the {\@link yfiles.layout.MultiStageLayout#applyLayoutCore layout algorithm}.
 * </p>
 * @see yfiles.layout.MultiStageLayout#removeStage
 * @see yfiles.layout.MultiStageLayout#prependStage
 * @param {?} stage the {\@link } instance to be added
 * @return {void}
 */
yfiles.layout.MultiStageLayout.prototype.appendStage = function(stage) {};

/**
 * Calculates a layout for the given graph and applies it directly to the graph.
 * <p>
 * This method executes all activated {\@link yfiles.layout.ILayoutStage}s in the layout pipeline as well as the {\@link yfiles.layout.MultiStageLayout#applyLayoutCore layout algorithm}.
 * </p>
 * @see yfiles.layout.MultiStageLayout#appendStage
 * @see yfiles.layout.MultiStageLayout#prependStage
 * @see yfiles.layout.MultiStageLayout#applyLayoutCore
 * @param {!yfiles.layout.LayoutGraph} layoutGraph the input graph
 * @return {void}
 */
yfiles.layout.MultiStageLayout.prototype.applyLayout = function(layoutGraph) {};

/**
 * Invokes the core layout algorithm.
 * <p>
 * This method should be implemented by subclasses in order to perform the layout routine of the layout algorithm.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.MultiStageLayout.prototype.applyLayoutCore = function(graph) {};

/**
 * Checks the sizes of the nodes to be non-zero.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} g The graph to check.
 * @return {void}
 */
yfiles.layout.MultiStageLayout.prototype.checkNodeSize = function(g) {};

/**
 * Deactivates all predefined {\@link yfiles.layout.ILayoutStage}s so that upon {\@link yfiles.layout.MultiStageLayout#applyLayout} only the
 * {\@link yfiles.layout.MultiStageLayout#applyLayoutCore layout algorithm} will be executed.
 * @return {void}
 */
yfiles.layout.MultiStageLayout.prototype.disableAllStages = function() {};

/**
 * Prepends the given {\@link yfiles.layout.ILayoutStage} to the layout pipeline.
 * <p>
 * Stages that are added with this method will be invoked at the very beginning of the layout pipeline. This means before
 * all previously prepended {\@link yfiles.layout.ILayoutStage}s, all predefined stages, and all appended
 * {\@link yfiles.layout.ILayoutStage}s.
 * </p>
 * @see yfiles.layout.MultiStageLayout#removeStage
 * @see yfiles.layout.MultiStageLayout#appendStage
 * @param {?} stage the {\@link } instance to be added
 * @return {void}
 */
yfiles.layout.MultiStageLayout.prototype.prependStage = function(stage) {};

/**
 * Removes the given {\@link yfiles.layout.ILayoutStage} from the layout pipeline.
 * <p>
 * This method can only remove {\@link yfiles.layout.ILayoutStage}s that have been previously added using {\@link yfiles.layout.MultiStageLayout#appendStage}
 * or {\@link yfiles.layout.MultiStageLayout#prependStage}. Predefined {\@link yfiles.layout.ILayoutStage}s can be deactivated separately.
 * </p>
 * @see yfiles.layout.MultiStageLayout#prependStage
 * @see yfiles.layout.MultiStageLayout#appendStage
 * @see yfiles.layout.MultiStageLayout#selfLoopRouterEnabled
 * @see yfiles.layout.MultiStageLayout#parallelEdgeRouterEnabled
 * @see yfiles.layout.MultiStageLayout#orientationLayoutEnabled
 * @see yfiles.layout.MultiStageLayout#subgraphLayoutEnabled
 * @see yfiles.layout.MultiStageLayout#labelingEnabled
 * @see yfiles.layout.MultiStageLayout#hideGroupsStageEnabled
 * @see yfiles.layout.MultiStageLayout#componentLayoutEnabled
 * @param {?} stage a {\@link } to be removed from the layout pipeline
 * @return {void}
 */
yfiles.layout.MultiStageLayout.prototype.removeStage = function(stage) {};
/**
 * @record
 * @struct
 */
yfiles.layout.NodeHalo = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.layout.NodeHalo>} */
yfiles.layout.NodeHalo.NODE_HALO_DP_KEY;
 /** @type {!yfiles.layout.NodeHalo} */
yfiles.layout.NodeHalo.ZERO_HALO;
 /** @type {number} */
yfiles.layout.NodeHalo.prototype.top;
 /** @type {number} */
yfiles.layout.NodeHalo.prototype.left;
 /** @type {number} */
yfiles.layout.NodeHalo.prototype.bottom;
 /** @type {number} */
yfiles.layout.NodeHalo.prototype.right;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.NodeHalo.$class;

/**
 * Creates a {\@link yfiles.layout.NodeHalo} with the specified values.
 * <p>
 * The values must not be negative, {\@link number#NaN} or {\@link number#POSITIVE_INFINITY}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if one of the values is negative, {\@link number#NaN} or {\@link number#POSITIVE_INFINITY}
 * Creates a {\@link yfiles.layout.NodeHalo} object with the specified value on each side of the node.
 * <p>
 * The value must not be negative, {\@link number#NaN} or {\@link number#POSITIVE_INFINITY}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the value is negative, {\@link number#NaN} or {\@link number#POSITIVE_INFINITY}
 * @param {number} top_or_value the {\@link } size at the top side of the node / the halo size at each side of the node
 * @param {number=} left the {\@link } size at the left side of the node
 * @param {number=} bottom the {\@link } size at the bottom side of the node
 * @param {number=} right the {\@link } size at the right side of the node
 * @return {!yfiles.layout.NodeHalo} the newly created {\@link }
 */
yfiles.layout.NodeHalo.create = function(top_or_value, left, bottom, right) {};

/**
 * Returns the {\@link yfiles.layout.NodeHalo} associated with the given node.
 * <p>
 * If no such {\@link yfiles.layout.NodeHalo} is available, this method returns a {\@link yfiles.layout.NodeHalo#ZERO_HALO}.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the graph containing the given node
 * @param {!yfiles.algorithms.Node} node the node whose {\@link } will be determined
 * @return {!yfiles.layout.NodeHalo} the {\@link } of the given node if available, otherwise a {\@link #ZERO_HALO}
 */
yfiles.layout.NodeHalo.getHalo = function(graph, node) {};

/**
 * Returns a {\@link yfiles.algorithms.YRectangle} instance with the bounds of the given node including its {\@link yfiles.layout.NodeHalo}.
 * <p>
 * This {\@link yfiles.algorithms.YRectangle} is located at the position of the node.
 * </p>
 * <p>
 * If the node does not have a {\@link yfiles.layout.NodeHalo} assigned, this box has the same size as the node.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the graph containing the given node
 * @param {!yfiles.algorithms.Node} node the node whose {\@link } will be determined
 * @return {!yfiles.algorithms.YRectangle} a {\@link } instance with the bounds of the given node including its {\@link }
 */
yfiles.layout.NodeHalo.getHaloBox = function(graph, node) {};

/**
 * Checks whether or not the given graph contains {\@link yfiles.layout.NodeHalo} information.
 * <p>
 * This method looks for a {\@link yfiles.algorithms.IDataProvider} that has been registered with the given graph using
 * {\@link yfiles.layout.NodeHalo#NODE_HALO_DP_KEY}.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {boolean} <code>true</code> if a {\@link } has been registered with the according key, <code>false</code> otherwise
 */
yfiles.layout.NodeHalo.hasHalos = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.NodeLabelCandidate = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.NodeLabelCandidate.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.NormalizeGraphElementOrderStage = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.layout.NormalizeGraphElementOrderStage.NODE_COMPARABLE_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<?>} */
yfiles.layout.NormalizeGraphElementOrderStage.EDGE_COMPARABLE_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.NormalizeGraphElementOrderStage.$class;

/**
 * Assigns comparable values for each node and edge.
 * <p>
 * The compared values are induced from the current ordering of the nodes and edges within the given graph.
 * </p>
 * <p>
 * This is a convenient method to fill the given {\@link yfiles.algorithms.IDataMap}s which can then be registered with the graph
 * with keys {\@link yfiles.layout.NormalizeGraphElementOrderStage#NODE_COMPARABLE_DP_KEY} and {\@link yfiles.layout.NormalizeGraphElementOrderStage#EDGE_COMPARABLE_DP_KEY}
 * and used for several layout calculations.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} comparableNodeMap the map that will be filled with comparable values for the nodes
 * @param {?} comparableEdgeMap the map that will be filled with comparable values for the edges
 * @return {void}
 */
yfiles.layout.NormalizeGraphElementOrderStage.fillComparableMapFromGraph = function(graph, comparableNodeMap, comparableEdgeMap) {};
/**
 * @record
 * @struct
 */
yfiles.layout.OrientationLayout = function() {};
 /** @type {yfiles.layout.LayoutOrientation} */
yfiles.layout.OrientationLayout.prototype.orientation;
 /** @type {yfiles.layout.MirrorModes} */
yfiles.layout.OrientationLayout.prototype.mirrorMode;
 /** @type {boolean} */
yfiles.layout.OrientationLayout.prototype.horizontalOrientation;
 /** @type {boolean} */
yfiles.layout.OrientationLayout.prototype.considerEdgeLabels;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.OrientationLayout.$class;

/**
 * Applies the desired orientation to the graph.
 * <p>
 * It performs the inverse coordinate transformation that has been applied to the layout by method
 * {\@link yfiles.layout.OrientationLayout#prepareOrientationChange}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.layout.OrientationLayout#applyLayout} after invoking the
 * {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm}. It may be overridden to extend the orientation change to custom layout features.
 * </p>
 * @see yfiles.layout.OrientationLayout#prepareOrientationChange
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.OrientationLayout.prototype.completeOrientationChange = function(graph) {};

/**
 * Transforms the given point during completion.
 * <p>
 * The point is transformed from {\@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} orientation to the desired orientation.
 * </p>
 * @see yfiles.layout.OrientationLayout#completeOrientationChange
 * @param {!yfiles.algorithms.YPoint} point the calculated point
 * @return {!yfiles.algorithms.YPoint} the transformed point
 */
yfiles.layout.OrientationLayout.prototype.completeTransform = function(point) {};

/**
 * Creates {\@link yfiles.algorithms.Insets} that are a geometric transformation of the given {\@link yfiles.algorithms.Insets}.
 * <p>
 * The transform will correspond to the currently set orientation.
 * </p>
 * @see yfiles.layout.OrientationLayout#orientation
 * @param {!yfiles.algorithms.Insets} insets the original insets
 * @return {!yfiles.algorithms.Insets} the oriented insets
 */
yfiles.layout.OrientationLayout.prototype.createOrientedInsets = function(insets) {};

/**
 * Creates a {\@link yfiles.layout.NodeHalo} that is a geometric transformation of the given {\@link yfiles.layout.NodeHalo}.
 * <p>
 * The transform will correspond to the currently set orientation.
 * </p>
 * @see yfiles.layout.OrientationLayout#orientation
 * @param {!yfiles.layout.NodeHalo} halo the original {\@link }
 * @return {!yfiles.layout.NodeHalo} the oriented {\@link }
 */
yfiles.layout.OrientationLayout.prototype.createOrientedNodeHalo = function(halo) {};

/**
 * Creates a {\@link yfiles.algorithms.YDimension} that is a geometric transformation of the given size.
 * <p>
 * The transform will correspond to the currently set orientation.
 * </p>
 * @see yfiles.layout.OrientationLayout#orientation
 * @param {!yfiles.algorithms.YDimension} nodeSize the original node size
 * @return {!yfiles.algorithms.YDimension} the oriented node size
 */
yfiles.layout.OrientationLayout.prototype.createOrientedNodeSize = function(nodeSize) {};

/**
 * Returns whether or not this {\@link yfiles.layout.OrientationLayout} instance will mirror the graph for a given layout
 * orientation.
 * <p>
 * Horizontal orientations get mirrored at the x-axis while vertical orientations are mirrored at the y-axis.
 * </p>
 * @see yfiles.layout.OrientationLayout#orientation
 * @see yfiles.layout.OrientationLayout#mirrorMode
 * @param {yfiles.layout.LayoutOrientation} orientation the layout orientation for which to check the mirror state
 * @return {boolean} <code>true</code> if the layout algorithm will mirror the graph at the corresponding axis for the given layout orientation, <code>false</code>
 * otherwise
 */
yfiles.layout.OrientationLayout.prototype.isOrientationMirrored = function(orientation) {};

/**
 * Prepares the layout for the desired orientation.
 * <p>
 * It will rotate and mirror the coordinates and bounds of the graph layout such that the {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm} can perform
 * its calculations assuming the canonical {\@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} orientation.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.layout.OrientationLayout#applyLayout} before invoking the
 * {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm}. It might be overridden to extend the preparations to custom layout features.
 * </p>
 * @see yfiles.layout.OrientationLayout#completeOrientationChange
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.OrientationLayout.prototype.prepareOrientationChange = function(graph) {};

/**
 * Transforms the given point during preparation.
 * <p>
 * The point is transformed so it matches the {\@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} orientation.
 * </p>
 * @see yfiles.layout.OrientationLayout#prepareOrientationChange
 * @param {!yfiles.algorithms.YPoint} point the original point
 * @return {!yfiles.algorithms.YPoint} the transformed point
 */
yfiles.layout.OrientationLayout.prototype.prepareTransform = function(point) {};

/**
 * Transforms the given point during the preparation or completion step.
 * <p>
 * This method is called by {\@link yfiles.layout.OrientationLayout#prepareOrientationChange} and {\@link yfiles.layout.OrientationLayout#completeOrientationChange}
 * to get the according point location.
 * </p>
 * @see yfiles.layout.OrientationLayout#prepareOrientationChange
 * @see yfiles.layout.OrientationLayout#completeOrientationChange
 * @see yfiles.layout.OrientationLayout#prepareTransform
 * @see yfiles.layout.OrientationLayout#completeTransform
 * @protected
 * @param {!yfiles.algorithms.YPoint} point the original/calculated point
 * @param {boolean} prepare <code>true</code> if this method is called during preparation, <code>false</code> if it is called during completion
 * @return {!yfiles.algorithms.YPoint} the transformed point
 */
yfiles.layout.OrientationLayout.prototype.transform = function(point, prepare) {};
/**
 * @record
 * @struct
 */
yfiles.layout.PortCalculator = function() {};
 /** @type {number} */
yfiles.layout.PortCalculator.prototype.Eps;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PortCalculator.$class;

/**
 * Performs the actual port calculation on the specified graph instance.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.PortCalculator.prototype.calculatePorts = function(graph) {};

/**
 * Determines whether two points are equal.
 * <p>
 * This implementation uses {\@link yfiles.layout.PortCalculator#Eps} to add some tolerance to the comparison. It is called by {\@link yfiles.layout.PortCalculator#calculatePorts}
 * and may be overridden to change the accuracy/tolerance of the comparison.
 * </p>
 * @see yfiles.layout.PortCalculator#calculatePorts
 * @see yfiles.layout.PortCalculator#Eps
 * @protected
 * @param {number} x1 the x-coordinate of the first point
 * @param {number} y1 the y-coordinate of the first point
 * @param {number} x2 the x-coordinate of the second point
 * @param {number} y2 the y-coordinate of the second point
 * @return {boolean} <code>true</code> if both points are considered equal, <code>false</code> otherwise
 */
yfiles.layout.PortCalculator.prototype.equalsEps = function(x1, y1, x2, y2) {};
/**
 * @record
 * @struct
 */
yfiles.layout.PortCandidate = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<?<!yfiles.layout.PortCandidate>>} */
yfiles.layout.PortCandidate.SOURCE_PORT_CANDIDATE_COLLECTION_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<?<!yfiles.layout.PortCandidate>>} */
yfiles.layout.PortCandidate.TARGET_PORT_CANDIDATE_COLLECTION_DP_KEY;
 /** @type {yfiles.layout.PortDirections} */
yfiles.layout.PortCandidate.prototype.direction;
 /** @type {boolean} */
yfiles.layout.PortCandidate.prototype.fixed;
 /** @type {number} */
yfiles.layout.PortCandidate.prototype.xOffset;
 /** @type {number} */
yfiles.layout.PortCandidate.prototype.yOffset;
 /** @type {number} */
yfiles.layout.PortCandidate.prototype.cost;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PortCandidate.$class;

/**
 * Factory method that creates a fixed {\@link yfiles.layout.PortCandidate} instance with the given cost of usage, direction and
 * offset values.
 * Factory method that creates a free {\@link yfiles.layout.PortCandidate} instance with the given direction and cost of usage.
 * Factory method that returns a free {\@link yfiles.layout.PortCandidate} instance with zero cost of usage and the direction
 * specified by the {\@link yfiles.layout.PortConstraint#side side} of the given {\@link yfiles.layout.PortConstraint}.
 * Factory method that creates a free {\@link yfiles.layout.PortCandidate} instance with the given direction and zero cost of
 * usage.
 * @param {number|yfiles.layout.PortDirections|!yfiles.layout.PortConstraint} xOffset_or_directionMask_or_fromPortConstraint the X-offset relative to the center of the node / any combination of the default direction specifiers / the {\@link } whose {\@link #side side} should be used as direction
 * @param {number=} yOffset_or_cost the Y-offset relative to the center of the node / the penalty cost for using this {\@link }
 * @param {yfiles.layout.PortDirections=} directionMask any combination of the default direction specifiers
 * @param {number=} cost
 * @return {!yfiles.layout.PortCandidate} a new {\@link } instance
 */
yfiles.layout.PortCandidate.createCandidate = function(xOffset_or_directionMask_or_fromPortConstraint, yOffset_or_cost, directionMask, cost) {};

/**
 * Returns the direction of this {\@link yfiles.layout.PortCandidate} instance with respect to the given {\@link yfiles.layout.OrientationLayout#orientation layout orientation}.
 * <p>
 * If the direction mask is not required to be calculated with respect to the actual {\@link yfiles.layout.OrientationLayout#orientation layout orientation}, {\@link yfiles.layout.PortCandidate#direction} should be used
 * instead.
 * </p>
 * @see yfiles.layout.PortCandidate#direction
 * @param {yfiles.layout.LayoutOrientation} layoutOrientation
 * @return {yfiles.layout.PortDirections} the direction of this {\@link } with respect to the given layout orientation
 */
yfiles.layout.PortCandidate.prototype.getDirectionForLayoutOrientation = function(layoutOrientation) {};

/**
 * Returns the X-offset of the {\@link yfiles.layout.PortCandidate} with respect to the center of the corresponding node for the
 * given {\@link yfiles.layout.OrientationLayout#orientation layout orientation} and {\@link yfiles.layout.OrientationLayout#mirrorMode mirror mask}.
 * <p>
 * The X-offset encodes the horizontal distance of the port relative to the center of a node. If the {\@link yfiles.layout.PortCandidate}
 * is not {\@link yfiles.layout.PortCandidate#fixed fixed} (i.e., free), the X-offset is equal to zero.
 * </p>
 * Returns the X-offset of the {\@link yfiles.layout.PortCandidate} with respect to the center of the corresponding node for the
 * given {\@link yfiles.layout.OrientationLayout#orientation layout orientation}.
 * <p>
 * The X-offset encodes the horizontal distance of the port relative to the center of a node. If the {\@link yfiles.layout.PortCandidate}
 * is not {\@link yfiles.layout.PortCandidate#fixed fixed} (i.e., free), the X-offset is equal to zero.
 * </p>
 * @param {yfiles.layout.LayoutOrientation} layoutOrientation the layout orientation
 * @param {yfiles.layout.MirrorModes=} mirrorMask the mirror mask
 * @return {number} the X-offset of the port with respect to the given orientation and mirror mask / the X-offset of the {\@link } with respect to the given layout orientation
 */
yfiles.layout.PortCandidate.prototype.getXOffsetForLayoutOrientation = function(layoutOrientation, mirrorMask) {};

/**
 * Returns the Y-offset of the {\@link yfiles.layout.PortCandidate} with respect to the center of the corresponding node for the
 * given {\@link yfiles.layout.OrientationLayout#orientation layout orientation} and {\@link yfiles.layout.OrientationLayout#mirrorMode mirror mask}.
 * <p>
 * The Y-offset encodes the vertical distance of the port relative to the center of a node. If the {\@link yfiles.layout.PortCandidate}
 * is not {\@link yfiles.layout.PortCandidate#fixed fixed} (i.e., free), the Y-offset is equal to zero.
 * </p>
 * Returns the Y-offset of the {\@link yfiles.layout.PortCandidate} with respect to the center of the corresponding node for the
 * given {\@link yfiles.layout.OrientationLayout#orientation layout orientation}.
 * <p>
 * The Y-offset encodes the vertical distance of the port relative to the center of a node. If the {\@link yfiles.layout.PortCandidate}
 * is not {\@link yfiles.layout.PortCandidate#fixed fixed} (i.e., free), the Y-offset is equal to zero.
 * </p>
 * @param {yfiles.layout.LayoutOrientation} layoutOrientation the layout orientation
 * @param {yfiles.layout.MirrorModes=} mirrorMask the mirror mask
 * @return {number} the Y-offset of the {\@link } with respect to the given orientation and mirror mask / the Y-offset of the {\@link } with respect to the given layout orientation
 */
yfiles.layout.PortCandidate.prototype.getYOffsetForLayoutOrientation = function(layoutOrientation, mirrorMask) {};

/**
 * Returns whether or not this {\@link yfiles.layout.PortCandidate} lies in the given direction.
 * @param {yfiles.layout.PortDirections} directionMask one of the default direction specifiers
 * @return {boolean} <code>true</code> if this {\@link } lies in the given direction, <code>false</code> otherwise
 */
yfiles.layout.PortCandidate.prototype.isInDirection = function(directionMask) {};

/**
 * A utility method that converts the current {\@link yfiles.layout.PortCandidate} instance to a {\@link yfiles.layout.PortConstraint}.
 * <p>
 * The {\@link yfiles.layout.PortConstraint#side side} of the created {\@link yfiles.layout.PortConstraint} matches the {\@link yfiles.layout.PortCandidate#direction direction} of this {\@link yfiles.layout.PortCandidate}.
 * </p>
 * <p>
 * If this {\@link yfiles.layout.PortCandidate} is {\@link yfiles.layout.PortCandidate#fixed fixed}, the resulting {\@link yfiles.layout.PortConstraint} will be {\@link yfiles.layout.PortConstraint#strong strong}.
 * </p>
 * @return {!yfiles.layout.PortConstraint} a {\@link } that matches this {\@link }
 */
yfiles.layout.PortCandidate.prototype.toPortConstraint = function() {};

/**
 * A utility method that converts the current {\@link yfiles.layout.PortCandidate} instance to a {\@link yfiles.layout.PortConstraint} with
 * respect to the given {\@link yfiles.layout.OrientationLayout#orientation layout orientation}.
 * <p>
 * The {\@link yfiles.layout.PortConstraint#side side} of the created {\@link yfiles.layout.PortConstraint} is the {\@link yfiles.layout.PortCandidate#direction direction} of this {\@link yfiles.layout.PortCandidate} interpreted
 * for the given orientation.
 * </p>
 * <p>
 * If this {\@link yfiles.layout.PortCandidate} is {\@link yfiles.layout.PortCandidate#fixed fixed}, the resulting {\@link yfiles.layout.PortConstraint} will be {\@link yfiles.layout.PortConstraint#strong strong}.
 * </p>
 * @param {yfiles.layout.LayoutOrientation} layoutOrientation
 * @return {!yfiles.layout.PortConstraint} a {\@link } that matches this {\@link } with respect to the given orientation
 */
yfiles.layout.PortCandidate.prototype.toPortConstraintForLayoutOrientation = function(layoutOrientation) {};
/**
 * @record
 * @struct
 */
yfiles.layout.IPortCandidateMatcher = function() {};

/**
 * Returns the next best matching {\@link yfiles.layout.IPortCandidateSetEntry} for the given parameters.
 * @abstract
 * Returns the next best matching {\@link yfiles.layout.IPortCandidateSetEntry} for the given parameters.
 * @abstract
 * Returns the next best matching {\@link yfiles.layout.IPortCandidateSetEntry}.
 * @abstract
 * @param {!yfiles.algorithms.Edge=} edge the edge for which to find a candidate
 * @param {boolean=} source <code>true</code> if the given edge connects to its source node, <code>false</code> otherwise
 * @param {number|yfiles.layout.PortDirections=} xOffset_or_directionMask the preferred X-offset of the port relative to the center of the node / any combination of default directions defined in {\@link }
 * @param {number=} yOffset the preferred Y-offset of the port relative to the center of the node
 * @param {yfiles.layout.PortDirections=} directionMask any combination of default directions defined in {\@link }
 * @return {?} a matching {\@link } instance
 */
yfiles.layout.IPortCandidateMatcher.prototype.findMatchingCandidate = function(edge, source, xOffset_or_directionMask, yOffset, directionMask) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IPortCandidateMatcher;
/**
 * @record
 * @struct
 */
yfiles.layout.IPortCandidateSetEntry = function() {};
 /** @type {!yfiles.layout.PortCandidate} */
yfiles.layout.IPortCandidateSetEntry.prototype.portCandidate;
 /** @type {number} */
yfiles.layout.IPortCandidateSetEntry.prototype.connections;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IPortCandidateSetEntry;
/**
 * @record
 * @struct
 */
yfiles.layout.PortCandidateSet = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.layout.PortCandidateSet>} */
yfiles.layout.PortCandidateSet.NODE_PORT_CANDIDATE_SET_DP_KEY;
 /** @type {number} */
yfiles.layout.PortCandidateSet.prototype.connectionCount;
 /** @type {?<!Object>} */
yfiles.layout.PortCandidateSet.prototype.entries;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PortCandidateSet.$class;

/**
 * Adds a {\@link yfiles.layout.PortCandidate} with the given capacity to this {\@link yfiles.layout.PortCandidateSet}.
 * <p>
 * The capacity value defines the maximum number of edges allowed to connect to the candidate. If no limitation for this
 * number exists, <code>0x7FFFFFFF</code> can be used.
 * </p>
 * <p>
 * The capacity must be greater than zero.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given capacity is less than or equal to zero
 * @param {!yfiles.layout.PortCandidate} p the {\@link } to add
 * @param {number=} connections
 * @return {void}
 */
yfiles.layout.PortCandidateSet.prototype.add = function(p, connections) {};

/**
 * Creates a {\@link yfiles.layout.IPortCandidateMatcher} that retrieves {\@link yfiles.layout.IPortCandidateSetEntry entries} from this {\@link yfiles.layout.PortCandidateSet}.
 * <p>
 * Each next best matching candidate is determined based on its cost, its current available capacity and based on whether
 * or not its direction is consistent with the desired one.
 * </p>
 * <p>
 * This method may be overridden to support custom implementations of {\@link yfiles.layout.IPortCandidateMatcher}.
 * </p>
 * @return {?} a new {\@link } instance
 */
yfiles.layout.PortCandidateSet.prototype.createMatcher = function() {};

/**
 * Calculates the penalty cost for the usage of the given {\@link yfiles.layout.IPortCandidateSetEntry entry} and the given parameters.
 * <p>
 * The cost is equal to the {\@link yfiles.layout.PortCandidate#cost cost of usage} of the {\@link yfiles.layout.IPortCandidateSetEntry#portCandidate associated port candidate}.
 * </p>
 * <p>
 * This method may be overridden to customize the calculation of the cost of usage of an {\@link yfiles.layout.IPortCandidateSetEntry entry}.
 * </p>
 * @param {?} entry the entry for which the cost is computed
 * @param {!yfiles.algorithms.Edge} edge the edge that will connect to the {\@link } associated with the entry
 * @param {boolean} source <code>true</code> if the given edge connects to its source node, <code>false</code> otherwise
 * @param {number} xOffset the preferred X-offset of the port relative to the center of the node
 * @param {number} yOffset the preferred Y-offset of the port relative to the center of the node
 * @return {number} the penalty cost for the usage of the given {\@link }
 */
yfiles.layout.PortCandidateSet.prototype.getCost = function(entry, edge, source, xOffset, yOffset) {};

/**
 * Calculates the priority of the given {\@link yfiles.layout.IPortCandidateSetEntry entry}.
 * <p>
 * Higher priority means that the entry will be considered earlier by a {\@link yfiles.layout.IPortCandidateMatcher}.
 * </p>
 * <p>
 * This method may be overridden to customize the calculation of the priority of {\@link yfiles.layout.IPortCandidateSetEntry entries}.
 * </p>
 * @param {?} entry the entry for which the cost is computed
 * @param {!yfiles.algorithms.Edge} edge the edge that will connect to the {\@link } associated with the entry
 * @param {boolean} source <code>true</code> if the given edge connects to its source node, <code>false</code> otherwise
 * @return {number} the priority of the given {\@link }
 */
yfiles.layout.PortCandidateSet.prototype.getPriority = function(entry, edge, source) {};

/**
 * Removes the given {\@link yfiles.layout.IPortCandidateSetEntry entry} from the list of candidate entries.
 * @param {?} entry the entry to remove
 * @return {void}
 */
yfiles.layout.PortCandidateSet.prototype.remove = function(entry) {};
/**
 * @record
 * @struct
 */
yfiles.layout.PortConstraint = function() {};
 /** @type {boolean} */
yfiles.layout.PortConstraint.prototype.strong;
 /** @type {yfiles.layout.PortSide} */
yfiles.layout.PortConstraint.prototype.side;
 /** @type {boolean} */
yfiles.layout.PortConstraint.prototype.atNorth;
 /** @type {boolean} */
yfiles.layout.PortConstraint.prototype.atSouth;
 /** @type {boolean} */
yfiles.layout.PortConstraint.prototype.atEast;
 /** @type {boolean} */
yfiles.layout.PortConstraint.prototype.atWest;
 /** @type {boolean} */
yfiles.layout.PortConstraint.prototype.atAnySide;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PortConstraint.$class;

/**
 * Creates a new {\@link yfiles.layout.PortConstraint} that constrains the edge to connect to the given side of a node and that can
 * be either strong or weak.
 * <p>
 * If the {\@link yfiles.layout.PortConstraint} is strong, the layout or routing algorithm should use the port coordinates of this
 * constraint.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if an unknown side is given
 * @param {yfiles.layout.PortSide} side one of the default side specifiers
 * @param {boolean=} strong
 * @return {!yfiles.layout.PortConstraint} a new {\@link } instance
 */
yfiles.layout.PortConstraint.create = function(side, strong) {};

/**
 * Returns the source {\@link yfiles.layout.PortConstraint} associated with the given edge.
 * <p>
 * To retrieve the {\@link yfiles.algorithms.IDataProvider} that holds information about source {\@link yfiles.layout.PortConstraint}s, key {\@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY}
 * is used.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} e the edge
 * @return {!yfiles.layout.PortConstraint} the source {\@link } of the given edge or <code>null</code> if there is none
 */
yfiles.layout.PortConstraint.getSPC = function(graph, e) {};

/**
 * Returns the target {\@link yfiles.layout.PortConstraint} associated with the given edge.
 * <p>
 * To retrieve the {\@link yfiles.algorithms.IDataProvider} that holds information about target {\@link yfiles.layout.PortConstraint}s, key {\@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY}
 * is used.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} e the edge
 * @return {!yfiles.layout.PortConstraint} the target {\@link } of the given edge or <code>null</code> if there is none
 */
yfiles.layout.PortConstraint.getTPC = function(graph, e) {};

/**
 * Checks whether or not there exist source or target {\@link yfiles.layout.PortConstraint}s associated with the given edge.
 * <p>
 * To retrieve the {\@link yfiles.algorithms.IDataProvider}s that hold information about source or target
 * {\@link yfiles.layout.PortConstraint}s, keys {\@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY} and {\@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY}
 * are used.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} e the edge
 * @return {boolean} <code>true</code> if the edge has source or target {\@link }s, <code>false</code> otherwise
 */
yfiles.layout.PortConstraint.hasPC = function(graph, e) {};

/**
 * Checks whether or not there exist source {\@link yfiles.layout.PortConstraint}s associated with the given edge.
 * <p>
 * To retrieve the {\@link yfiles.algorithms.IDataProvider} that holds information about source {\@link yfiles.layout.PortConstraint}s, key {\@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY}
 * is used.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} e the edge
 * @return {boolean} <code>true</code> if the edge has source {\@link }s, <code>false</code> otherwise
 */
yfiles.layout.PortConstraint.hasSPC = function(graph, e) {};

/**
 * Checks whether or not there exist target {\@link yfiles.layout.PortConstraint}s associated with the given edge.
 * <p>
 * To retrieve the {\@link yfiles.algorithms.IDataProvider} that holds information about target {\@link yfiles.layout.PortConstraint}s, key {\@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY}
 * is used.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} e the edge
 * @return {boolean} <code>true</code> if the edge has target {\@link }s, <code>false</code> otherwise
 */
yfiles.layout.PortConstraint.hasTPC = function(graph, e) {};
/**
 * @record
 * @struct
 */
yfiles.layout.PortConstraintConfigurator = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PortConstraintConfigurator.$class;

/**
 * Creates a {\@link yfiles.layout.PortConstraint} for the given edge.
 * <p>
 * The side of the constraint is set up according to the current drawing of the edge within the given graph.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {boolean} source <code>true</code> if a source {\@link } for the given edge will be created, <code>false</code> for a target
 * {\@link }
 * @param {boolean} strong <code>true</code> if a strong {\@link } is created, <code>false</code> for a weak {\@link }
 * @return {!yfiles.layout.PortConstraint} the {\@link } for the given edge whose side is retrieved from the initial drawing
 */
yfiles.layout.PortConstraintConfigurator.prototype.createPortConstraintFromSketch = function(graph, edge, source, strong) {};

/**
 * Creates {\@link yfiles.layout.PortConstraint}s for some edges of the given graph.
 * Creates weak {\@link yfiles.layout.PortConstraint}s for all edges of the given graph.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ec_or_spcMap the {\@link } that provides access to the edges for which to create {\@link }s / the {\@link } that will be used for storing the source {\@link }s of the edges
 * @param {?} spcMap_or_tpcMap the {\@link } that will be used for storing the source {\@link }s of the edges / the {\@link } that will be used for storing the target {\@link }s of the edges
 * @param {boolean=} strongSP <code>true</code> if strong source {\@link }s should be assigned, <code>false</code> otherwise
 * @param {?=} tpcMap the {\@link } that will be used for storing the target {\@link }s of the edges
 * @param {boolean=} strongTP <code>true</code> if strong target {\@link }s should be assigned, <code>false</code> otherwise
 * @return {void}
 */
yfiles.layout.PortConstraintConfigurator.prototype.createPortConstraintsFromSketch = function(graph, ec_or_spcMap, spcMap_or_tpcMap, strongSP, tpcMap, strongTP) {};
/**
 * @record
 * @struct
 */
yfiles.layout.PortConstraintKeys = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.layout.PortConstraint>} */
yfiles.layout.PortConstraintKeys.SOURCE_PORT_CONSTRAINT_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.layout.PortConstraint>} */
yfiles.layout.PortConstraintKeys.TARGET_PORT_CONSTRAINT_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.layout.PortConstraintKeys.SOURCE_GROUP_ID_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.layout.PortConstraintKeys.TARGET_GROUP_ID_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.layout.PortConstraintKeys.SOURCE_PORT_GROUP_ID_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.layout.PortConstraintKeys.TARGET_PORT_GROUP_ID_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PortConstraintKeys.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.PreferredPlacementDescriptor = function() {};
 /** @type {yfiles.layout.LabelPlacements} */
yfiles.layout.PreferredPlacementDescriptor.prototype.placeAlongEdge;
 /** @type {yfiles.layout.LabelPlacements} */
yfiles.layout.PreferredPlacementDescriptor.prototype.sideOfEdge;
 /** @type {yfiles.layout.LabelSideReferences} */
yfiles.layout.PreferredPlacementDescriptor.prototype.sideReference;
 /** @type {number} */
yfiles.layout.PreferredPlacementDescriptor.prototype.angle;
 /** @type {yfiles.layout.LabelAngleReferences} */
yfiles.layout.PreferredPlacementDescriptor.prototype.angleReference;
 /** @type {yfiles.layout.LabelAngleOnRightSideRotations} */
yfiles.layout.PreferredPlacementDescriptor.prototype.angleRotationOnRightSide;
 /** @type {yfiles.layout.LabelAngleOnRightSideOffsets} */
yfiles.layout.PreferredPlacementDescriptor.prototype.angleOffsetOnRightSide;
 /** @type {number} */
yfiles.layout.PreferredPlacementDescriptor.prototype.distanceToEdge;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAtSource;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAtCenter;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAtTarget;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAtSourcePort;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAtTargetPort;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isLeftOfEdge;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isOnEdge;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isRightOfEdge;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAngleAbsolute;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAngleRelativeToEdgeFlow;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAngleOnRightSideCoRotating;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAngleOnRightSideCounterRotating;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAngleOffsetOnRightSideZero;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isAngleOffsetOnRightSide180;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isSideRelativeToEdgeFlow;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isSideAbsoluteWithLeftInNorth;
 /** @type {boolean} */
yfiles.layout.PreferredPlacementDescriptor.prototype.isSideAbsoluteWithRightInNorth;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PreferredPlacementDescriptor.$class;

/**
 * Clones this instance by returning a {\@link Object#memberwiseClone} or this in case this instance is already {\@link yfiles.layout.PreferredPlacementDescriptor#isFrozen frozen}.
 * @return {!Object} An instance of the same type as this instance.
 */
yfiles.layout.PreferredPlacementDescriptor.prototype.clone = function() {};

/**
 * Makes this {\@link yfiles.layout.PreferredPlacementDescriptor} instance immutable.
 * <p>
 * If this instance is immutable, all <code>setter</code> methods will throw an {\@link yfiles.lang.Exception} when invoked.
 * </p>
 * @see yfiles.layout.PreferredPlacementDescriptor#isFrozen
 * @return {void}
 */
yfiles.layout.PreferredPlacementDescriptor.prototype.freeze = function() {};

/**
 * Returns whether or not this is an immutable instance of {\@link yfiles.layout.PreferredPlacementDescriptor}.
 * <p>
 * If this instance is immutable, all <code>setter</code> methods will throw an {\@link yfiles.lang.Exception} when invoked.
 * </p>
 * @see yfiles.layout.PreferredPlacementDescriptor#freeze
 * @return {boolean} <code>true</code> if this instance is immutable, <code>false</code> otherwise
 */
yfiles.layout.PreferredPlacementDescriptor.prototype.isFrozen = function() {};

/**
 * Returns an immutable descriptor instance for the specified placement.
 * <p>
 * Descriptor instances returned by this method will use default values for all properties but {\@link yfiles.layout.PreferredPlacementDescriptor#placeAlongEdge placement along edge} and
 * {\@link yfiles.layout.PreferredPlacementDescriptor#sideOfEdge side of edge}.
 * </p>
 * @see yfiles.layout.PreferredPlacementDescriptor#isFrozen
 * @see yfiles.layout.PreferredPlacementDescriptor#placeAlongEdge
 * @see yfiles.layout.PreferredPlacementDescriptor#sideOfEdge
 * @param {yfiles.layout.LabelPlacements} placement a combination of valid placements along the edge and valid sides of the edge
 * @return {!yfiles.layout.PreferredPlacementDescriptor} an immutable descriptor instance for the specified placement
 */
yfiles.layout.PreferredPlacementDescriptor.newSharedInstance = function(placement) {};
/**
 * @record
 * @struct
 */
yfiles.layout.RemoveCollinearBendsStage = function() {};
 /** @type {number} */
yfiles.layout.RemoveCollinearBendsStage.prototype.scale;
 /** @type {boolean} */
yfiles.layout.RemoveCollinearBendsStage.prototype.removeStraightOnly;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.RemoveCollinearBendsStage.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ReverseEdgesStage = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.layout.ReverseEdgesStage.AFFECTED_EDGES_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ReverseEdgesStage.$class;

/**
 * Marks edges in a tree-structured graph component that need to be reversed to make the specified node the root of the
 * tree component.
 * <p>
 * Only edges in the graph component to which the specified node belongs will be marked.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the specified root node is <code>null</code> or does not belong to the specified graph
 * @see yfiles.layout.ReverseEdgesStage#AFFECTED_EDGES_DP_KEY
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the specified node belongs
 * @param {!yfiles.algorithms.Node} root the node to be considered the root of its tree component
 * @param {?} reversedEdges a {\@link } to mark edges for reversal
 * @return {void}
 */
yfiles.layout.ReverseEdgesStage.findReversedTreeEdges = function(graph, root, reversedEdges) {};

/**
 * Reverses the specified edge in the specified graph.
 * <p>
 * The layout of the specified edge is reversed as specified in
 * {\@link yfiles.layout.LayoutGraphUtilities#reverseEdgeLayout}. Moreover, the positions of all labels associated with the
 * specified edge are adjusted to match the pre-reversal position as closely as possible. (Depending on a label's model it
 * might not always be possible to achieve an exact match.)
 * </p>
 * @see yfiles.layout.LayoutGraphUtilities#reverseEdgeLayout
 * @param {!yfiles.layout.LayoutGraph} graph the graph to which the specified edge belongs
 * @param {!yfiles.algorithms.Edge} edge the edge to be reversed
 * @return {void}
 */
yfiles.layout.ReverseEdgesStage.prototype.reverseEdge = function(graph, edge) {};

/**
 * Reverses <em>selected</em> edges in the specified graph.
 * <p>
 * <em>Selected</em> edges are marked in a {\@link yfiles.algorithms.IDataProvider} registered with
 * {\@link yfiles.layout.ReverseEdgesStage#AFFECTED_EDGES_DP_KEY}.
 * </p>
 * <p>
 * Implementation detail: This method calls {\@link yfiles.layout.ReverseEdgesStage#reverseEdge} in order to reverse a <em>selected</em> edge.
 * </p>
 * @see yfiles.layout.ReverseEdgesStage#AFFECTED_EDGES_DP_KEY
 * @see yfiles.layout.ReverseEdgesStage#reverseEdge
 * @param {!yfiles.layout.LayoutGraph} graph the graph in which to reverse edges.
 * @return {void}
 */
yfiles.layout.ReverseEdgesStage.prototype.reverseEdges = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.SelfLoopRouter = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.layout.SelfLoopRouter.KEEP_SELF_LOOP_LAYOUT_DP_KEY;
 /** @type {number} */
yfiles.layout.SelfLoopRouter.prototype.cornerApproximationPointsCount;
 /** @type {number} */
yfiles.layout.SelfLoopRouter.prototype.lineDistance;
 /** @type {boolean} */
yfiles.layout.SelfLoopRouter.prototype.smartSelfLoopPlacement;
 /** @type {yfiles.layout.SelfLoopStyle} */
yfiles.layout.SelfLoopRouter.prototype.layoutStyle;
 /** @type {boolean} */
yfiles.layout.SelfLoopRouter.prototype.keepAllSelfLoopRoutes;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.SelfLoopRouter.$class;

/**
 * Calculates the routes of the self-loops in the given graph.
 * <p>
 * This method will only change the routes of self-loops that are not marked to be {\@link yfiles.layout.SelfLoopRouter#KEEP_SELF_LOOP_LAYOUT_DP_KEY kept}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.layout.SelfLoopRouter#applyLayout} after the {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm} has arranged the graph
 * and all self-loops have been reinserted into the graph. It may be overridden to introduce custom self-loop styles.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.SelfLoopRouter.prototype.layoutSelfLoops = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.SequentialLayout = function() {};
 /** @type {?<?>} */
yfiles.layout.SequentialLayout.prototype.layouts;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.SequentialLayout.$class;

/**
 * Appends the given {\@link yfiles.layout.ILayoutAlgorithm layout algorithm} to the end of the chain.
 * @param {?} layouter the {\@link  layout algorithm} to append
 * @return {void}
 */
yfiles.layout.SequentialLayout.prototype.appendLayout = function(layouter) {};

/**
 * Appends the specified list of {\@link yfiles.layout.ILayoutAlgorithm layout algorithms} to the end of the chain.
 * @param {?<?>} layouters the list of {\@link  layout algorithms} to append
 * @return {void}
 */
yfiles.layout.SequentialLayout.prototype.appendLayouts = function(layouters) {};

/**
 * Executes all {\@link yfiles.layout.ILayoutAlgorithm layout algorithms} in the chain, one after the other.
 * <p>
 * The order of the layout algorithms is defined by the order in which they were appended.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.layout.SequentialLayout.prototype.applyLayout = function(graph) {};

/**
 * Clears the current chain of {\@link yfiles.layout.ILayoutAlgorithm layout algorithms} and therefore removes all layout algorithms.
 * @return {void}
 */
yfiles.layout.SequentialLayout.prototype.removeAll = function() {};
/**
 * @record
 * @struct
 */
yfiles.layout.SimpleProfitModel = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.SimpleProfitModel.$class;

/**
 *
 * @param {!yfiles.layout.LabelCandidate} candidate
 * @return {number}
 */
yfiles.layout.SimpleProfitModel.prototype.getProfit = function(candidate) {};
/**
 * @record
 * @struct
 */
yfiles.layout.SliderEdgeLabelLayoutModel = function() {};
 /** @type {yfiles.layout.SliderMode} */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.mode;
 /** @type {boolean} */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.distanceRelativeToEdge;
 /** @type {number} */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.distance;
 /** @type {boolean} */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.autoRotationEnabled;
 /** @type {boolean} */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.autoFlipping;
 /** @type {number} */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.angle;
 /** @type {!Object} */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.defaultParameter;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.SliderEdgeLabelLayoutModel.$class;

/**
 *
 * @param {!yfiles.algorithms.YOrientedRectangle} labelBounds
 * @param {?} edgeLayout
 * @param {?} sourceNode
 * @param {?} targetNode
 * @return {!Object}
 */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.createModelParameter = function(labelBounds, edgeLayout, sourceNode, targetNode) {};

/**
 * Returns all {\@link yfiles.layout.EdgeLabelCandidate}s that describe valid label positions within this model.
 * <p>
 * The number of candidates and their respective locations are computed depending on the geometries of both label and
 * edge.
 * </p>
 * @param {?} labelLayout the label for which candidates should be generated
 * @param {?} edgeLayout the layout of the edge to which the label belongs
 * @param {?} sourceLayout the layout of the source node of the label-owning edge
 * @param {?} targetLayout the layout of the target node of the label-owning edge
 * @return {!yfiles.algorithms.YList} a list of {\@link } instances
 */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.getLabelCandidates = function(labelLayout, edgeLayout, sourceLayout, targetLayout) {};

/**
 *
 * @param {!yfiles.algorithms.YDimension} labelSize
 * @param {?} edgeLayout
 * @param {?} sourceNode
 * @param {?} targetNode
 * @param {!Object} para
 * @return {!yfiles.algorithms.YOrientedRectangle}
 */
yfiles.layout.SliderEdgeLabelLayoutModel.prototype.getLabelPlacement = function(labelSize, edgeLayout, sourceNode, targetNode, para) {};
/**
 * @record
 * @struct
 */
yfiles.layout.SubgraphLayout = function() {};
 /** @type {!Object} */
yfiles.layout.SubgraphLayout.prototype.affectedNodesDpKey;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.SubgraphLayout.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.SwimlaneRepresentative = function() {};
 /** @type {number} */
yfiles.layout.SwimlaneRepresentative.prototype.swimlanePos;
 /** @type {boolean} */
yfiles.layout.SwimlaneRepresentative.prototype.allowRearrangement;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.SwimlaneRepresentative.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.Swimlanes = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.Swimlanes.$class;

/**
 * Calculates an ordering of the swimlanes considering the specified ordering mode.
 * <p>
 * Depending on the swimlane mode, the ordering will try to reduce:
 * </p>
 * <ol>
 * <li>the number of swimlanes traversed by edges</li>
 * <li>the number of swimlanes spanned by {\@link yfiles.layout.GroupingSupport#isGroupNode group nodes}</li>
 * </ol>
 * @see yfiles.layout.SwimlaneRepresentative
 * @see yfiles.layout.GroupingSupport
 * Calculates an ordering of the swimlanes.
 * <p>
 * The ordering will try to reduce:
 * </p>
 * <ol>
 * <li>the number of swimlanes traversed by edges</li>
 * <li>the number of swimlanes spanned by {\@link yfiles.layout.GroupingSupport#isGroupNode group nodes}</li>
 * </ol>
 * @see yfiles.layout.SwimlaneRepresentative
 * @see yfiles.layout.GroupingSupport
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @param {?} node2Swimlane the assignment of nodes to swimlanes
 * @param {number=} iterations the number of iterations performed by the heuristic.
 * @param {yfiles.layout.SwimlanesMode=} mode one of the valid swimlane ordering mode specifier
 * @return {void}
 */
yfiles.layout.Swimlanes.arrangeSwimlanes = function(graph, node2Swimlane, iterations, mode) {};

/** @const */
yfiles.layout.OperationType = {};
/** @const {number} */
yfiles.layout.OperationType.MIRROR_X_AXIS;
/** @const {number} */
yfiles.layout.OperationType.MIRROR_Y_AXIS;
/** @const {number} */
yfiles.layout.OperationType.ROTATE;
/** @const {number} */
yfiles.layout.OperationType.SCALE;
/** @const {number} */
yfiles.layout.OperationType.TRANSLATE;
/**
 * @record
 * @struct
 */
yfiles.layout.GraphTransformer = function() {};
 /** @type {?} */
yfiles.layout.GraphTransformer.prototype.coreLayout;
 /** @type {yfiles.layout.OperationType} */
yfiles.layout.GraphTransformer.prototype.operation;
 /** @type {number} */
yfiles.layout.GraphTransformer.prototype.rotationAngle;
 /** @type {boolean} */
yfiles.layout.GraphTransformer.prototype.bestFitRotationEnabled;
 /** @type {number} */
yfiles.layout.GraphTransformer.prototype.preferredHeight;
 /** @type {number} */
yfiles.layout.GraphTransformer.prototype.preferredWidth;
 /** @type {boolean} */
yfiles.layout.GraphTransformer.prototype.scaleNodeSize;
 /** @type {number} */
yfiles.layout.GraphTransformer.prototype.scaleFactor;
 /** @type {number} */
yfiles.layout.GraphTransformer.prototype.scaleFactorY;
 /** @type {number} */
yfiles.layout.GraphTransformer.prototype.scaleFactorX;
 /** @type {number} */
yfiles.layout.GraphTransformer.prototype.translateX;
 /** @type {number} */
yfiles.layout.GraphTransformer.prototype.translateY;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.GraphTransformer.$class;

/**
 * Rotates the given graph so its resulting bounding box fits best to the given bounds.
 * @see yfiles.layout.GraphTransformer#bestFitRotationEnabled
 * @param {!yfiles.layout.LayoutGraph} graph the graph that is rotated
 * @param {number} width the width of the preferred layout bounds
 * @param {number} height the height of the preferred layout bounds
 * @return {number} the rotation angle
 */
yfiles.layout.GraphTransformer.applyBestFitRotationAngle = function(graph, width, height) {};

/**
 * Returns the rotation angle for the graph that will result in a layout that fits best to the given bounds.
 * @see yfiles.layout.GraphTransformer#applyBestFitRotationAngle
 * @param {!yfiles.layout.LayoutGraph} graph the graph that is rotated
 * @param {number} width the width of the preferred layout bounds
 * @param {number} height the height of the preferred layout bounds
 * @return {number} the rotation angle
 */
yfiles.layout.GraphTransformer.findBestFitRotationAngle = function(graph, width, height) {};

/**
 * Specifies the preferred size of the layout.
 * <p>
 * If performing a {\@link yfiles.layout.OperationType#ROTATE rotation} and this rotation should be
 * {\@link yfiles.layout.GraphTransformer#bestFitRotationEnabled automatically fitted}, then the given preferred size defines the aspect ratio that will be used for fitting the layout
 * rotation.
 * </p>
 * <p>
 * The preferred width and height need to be non-negative.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the specified width or height is negative
 * @see yfiles.layout.GraphTransformer#preferredWidth
 * @see yfiles.layout.GraphTransformer#preferredHeight
 * @see yfiles.layout.GraphTransformer#bestFitRotationEnabled
 * @see yfiles.layout.GraphTransformer#operation
 * @see yfiles.layout.OperationType#ROTATE
 * @param {number} width the preferred width of the layout
 * @param {number} height the preferred height of the layout
 * @return {void}
 */
yfiles.layout.GraphTransformer.prototype.preferredLayoutSize = function(width, height) {};

/**
 * Fits the given graph into the specified rectangular bounds.
 * <p>
 * If the bounding box fits in the given bounds, nothing is done. Otherwise, the graph is scaled and optionally moved to
 * fit.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the graph to modify
 * @param {number} x the upper left x-coordinate of the bounds
 * @param {number} y the upper left y-coordinate of the bounds
 * @param {number} w the width of the bounds
 * @param {number} h the height of the bounds
 * @return {void}
 */
yfiles.layout.GraphTransformer.setMaximalBounds = function(graph, x, y, w, h) {};

/**
 * Specifies the horizontal and vertical scaling factor used for the {\@link yfiles.layout.OperationType#SCALE scale operation}.
 * <p>
 * Only positive scaling factors are allowed.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if one the specified scaling factors is negative or <code>0</code>
 * @see yfiles.layout.GraphTransformer#scaleFactorX
 * @see yfiles.layout.GraphTransformer#scaleFactorY
 * @see yfiles.layout.GraphTransformer#operation
 * @see yfiles.layout.OperationType#SCALE
 * @param {number} xFactor the horizontal scaling factor
 * @param {number} yFactor the vertical scaling factor
 * @return {void}
 */
yfiles.layout.GraphTransformer.prototype.setScaleFactors = function(xFactor, yFactor) {};

/**
 * Translates the layout coordinates by the given vector.
 * @see yfiles.layout.OperationType#TRANSLATE
 * @see yfiles.layout.GraphTransformer#operation
 * @param {!yfiles.layout.LayoutGraph} graph the graph that is translated
 * @param {number} dx the horizontal distance the given graph is moved
 * @param {number} dy the vertical distance the given graph is moved
 * @return {void}
 */
yfiles.layout.GraphTransformer.translate = function(graph, dx, dy) {};
/**
 * @record
 * @struct
 */
yfiles.layout.FixGroupLayoutStage = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.layout.FixGroupLayoutStage.FIXED_GROUP_NODES_DP_KEY;
 /** @type {yfiles.layout.InterEdgeRoutingStyle} */
yfiles.layout.FixGroupLayoutStage.prototype.interEdgeRoutingStyle;
 /** @type {?} */
yfiles.layout.FixGroupLayoutStage.prototype.interEdgeRouter;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.FixGroupLayoutStage.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.IPartitionFinder = function() {};

/**
 * Returns a partition ID for each node of an input graph.
 * <p>
 * Nodes that share a common partition ID are considered to belong to the same partition.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} partitionIDMap the map that is filled with the resulting partition IDs
 * @return {void}
 */
yfiles.layout.IPartitionFinder.prototype.findPartitions = function(graph, partitionIDMap) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IPartitionFinder;
/**
 * @record
 * @struct
 */
yfiles.layout.IPartitionPlacer = function() {};

/**
 * Arranges the graph while taking partition IDs and inter-edge information into account.
 * <p>
 * Edges which connect nodes that belong to two different partitions are called inter-edges
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} partitionIDDP the partition ID for each node in the graph
 * @param {?} interEdgeDP the map which marks inter-edges
 * @return {void}
 */
yfiles.layout.IPartitionPlacer.prototype.placePartitions = function(graph, partitionIDDP, interEdgeDP) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.layout.IPartitionPlacer;
/**
 * @record
 * @struct
 */
yfiles.layout.PartitionLayout = function() {};
 /** @type {?} */
yfiles.layout.PartitionLayout.prototype.partitionFinder;
 /** @type {?} */
yfiles.layout.PartitionLayout.prototype.partitionPlacer;
 /** @type {?} */
yfiles.layout.PartitionLayout.prototype.interEdgeRouter;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PartitionLayout.$class;

/**
 * Creates a {\@link yfiles.layout.IPartitionPlacer} that uses {\@link yfiles.layout.ComponentLayout} to place the partitions.
 * @param {!yfiles.layout.ComponentLayout=} componentLayout
 * @return {?}
 */
yfiles.layout.PartitionLayout.createComponentPartitionPlacer = function(componentLayout) {};

/**
 * Creates a {\@link yfiles.layout.IPartitionFinder} that uses {\@link yfiles.algorithms.Groups#edgeBetweennessClustering} as strategy for
 * finding graph partitions.
 * Creates a {\@link yfiles.layout.IPartitionFinder} that uses {\@link yfiles.algorithms.Groups#edgeBetweennessClustering} as strategy for
 * finding graph partitions.
 * @param {number|{minimumPartitionCount: number, maximumPartitionCount: number}=} minimumPartitionCount_or_options
 * @param {number=} maximumPartitionCount
 * @return {?}
 */
yfiles.layout.PartitionLayout.createEdgeBetweennessPartitionFinder = function(minimumPartitionCount_or_options, maximumPartitionCount) {};
/**
 * @record
 * @struct
 */
yfiles.layout.PortPlacementStage = function() {};
 /** @type {boolean} */
yfiles.layout.PortPlacementStage.prototype.pathCorrection;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PortPlacementStage.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ComponentLayoutData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.layout.ComponentLayoutData.prototype.affectedComponents;
 /** @type {!yfiles.layout.ItemMapping<?, ?>} */
yfiles.layout.ComponentLayoutData.prototype.componentIds;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.layout.ComponentLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.layout.ComponentLayoutData.prototype.abortHandler;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ComponentLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.CompositeLayoutData = function() {};
 /** @type {?<!yfiles.layout.LayoutData>} */
yfiles.layout.CompositeLayoutData.prototype.items;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.CompositeLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ContextItemMapping = function() {};
 /** @type {function(TItem, TContext): TValue} */
yfiles.layout.ContextItemMapping.prototype.contextDelegate;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ContextItemMapping.$class;

/**
 * Provides a mapper mapping the items to values.
 * @param {!yfiles.layout.LayoutGraphAdapter} adapter The graph adapter the mapper shall be provided for.
 * @param {?} layout The layout using the mapper.
 * @param {TContext} context The context object passed to the {\@link #contextDelegate}.
 * @return {?<TItem, TValue>} A mapper mapping the items to values.
 */
yfiles.layout.ContextItemMapping.prototype.provideMapperForContext = function(adapter, layout, context) {};
/**
 * @record
 * @struct
 */
yfiles.layout.DataProviderAdapter = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.DataProviderAdapter.$class;

/**
 *
 * @param {!Object} dataHolder
 * @return {!Object}
 */
yfiles.layout.DataProviderAdapter.prototype.get = function(dataHolder) {};

/**
 *
 * @param {!Object} dataHolder
 * @return {boolean}
 */
yfiles.layout.DataProviderAdapter.prototype.getBoolean = function(dataHolder) {};

/**
 *
 * @param {!Object} dataHolder
 * @return {number}
 */
yfiles.layout.DataProviderAdapter.prototype.getInt = function(dataHolder) {};

/**
 *
 * @param {!Object} dataHolder
 * @return {number}
 */
yfiles.layout.DataProviderAdapter.prototype.getNumber = function(dataHolder) {};
/**
 * @record
 * @struct
 */
yfiles.layout.DataMapAdapter = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.DataMapAdapter.$class;

/**
 *
 * @param {!Object} dataHolder
 * @param {!Object} value
 * @return {void}
 */
yfiles.layout.DataMapAdapter.prototype.set = function(dataHolder, value) {};

/**
 *
 * @param {!Object} dataHolder
 * @param {boolean} value
 * @return {void}
 */
yfiles.layout.DataMapAdapter.prototype.setBoolean = function(dataHolder, value) {};

/**
 *
 * @param {!Object} dataHolder
 * @param {number} value
 * @return {void}
 */
yfiles.layout.DataMapAdapter.prototype.setInt = function(dataHolder, value) {};

/**
 *
 * @param {!Object} dataHolder
 * @param {number} value
 * @return {void}
 */
yfiles.layout.DataMapAdapter.prototype.setNumber = function(dataHolder, value) {};
/**
 * @record
 * @struct
 */
yfiles.layout.DpKeyItemCollection = function() {};
 /** @type {!yfiles.algorithms.DpKeyBase<boolean>} */
yfiles.layout.DpKeyItemCollection.prototype.dpKey;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.DpKeyItemCollection.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ExtendedEdgeLabelCandidate = function() {};
 /** @type {?} */
yfiles.layout.ExtendedEdgeLabelCandidate.prototype.descriptor;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ExtendedEdgeLabelCandidate.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ExtendedLabelCandidateProfitModel = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ExtendedLabelCandidateProfitModel.$class;

/**
 * Returns the profit for placing a label-candidate.
 * <p>
 * This implementation returns the profit for instances of {\@link yfiles.layout.ExtendedNodeLabelCandidate} or 0.0 for other
 * {\@link yfiles.layout.LabelCandidate}s.
 * </p>
 * @param {!yfiles.layout.LabelCandidate} candidate a label candidate
 * @return {number} a value between 0 and 1.
 */
yfiles.layout.ExtendedLabelCandidateProfitModel.prototype.getProfit = function(candidate) {};
/**
 * @record
 * @struct
 */
yfiles.layout.ExtendedNodeLabelCandidate = function() {};
 /** @type {?} */
yfiles.layout.ExtendedNodeLabelCandidate.prototype.descriptor;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ExtendedNodeLabelCandidate.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.FixGroupLayoutData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.layout.FixGroupLayoutData.prototype.fixedGroupNodes;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.layout.FixGroupLayoutData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.layout.FixGroupLayoutData.prototype.targetPortConstraints;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.FixGroupLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.FixNodeLayoutData = function() {};
 /** @type {!yfiles.layout.SingleItemCollection<?>} */
yfiles.layout.FixNodeLayoutData.prototype.fixedNode;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.FixNodeLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ItemCollection = function() {};
 /** @type {?<TItem, boolean>} */
yfiles.layout.ItemCollection.prototype.mapper;
 /** @type {function(TItem): boolean} */
yfiles.layout.ItemCollection.prototype.delegate;
 /** @type {?<TItem>} */
yfiles.layout.ItemCollection.prototype.items;
 /** @type {?<TItem>} */
yfiles.layout.ItemCollection.prototype.source;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ItemCollection.$class;

/**
 * Provides a mapper describing which elements are contained in this {\@link yfiles.layout.ItemCollection.<T>}.
 * @param {!yfiles.layout.LayoutGraphAdapter} adapter The graph adapter the mapper shall be provided for.
 * @param {?} layout The layout using the item collection.
 * @return {?<TItem, boolean>}
 */
yfiles.layout.ItemCollection.prototype.provideMapper = function(adapter, layout) {};
/**
 * @record
 * @struct
 */
yfiles.layout.ItemMapping = function() {};
 /** @type {function(TItem): TValue} */
yfiles.layout.ItemMapping.prototype.delegate;
 /** @type {?<TItem, TValue>} */
yfiles.layout.ItemMapping.prototype.mapper;
 /** @type {TValue} */
yfiles.layout.ItemMapping.prototype.constant;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ItemMapping.$class;

/**
 * Provides a mapper mapping the items to values.
 * <p>
 * This implementation returns the {\@link yfiles.layout.ItemMapping.<TItem,TValue>#mapper} if one has been set, otherwise it will create a mapper from the {\@link yfiles.layout.ItemMapping.<TItem,TValue>#delegate} if one has been
 * specified or uses a constant mapper if a {\@link yfiles.layout.ItemMapping.<TItem,TValue>#constant} has been specified. If none have been specified, <code>null</code> is returned.
 * </p>
 * @param {!yfiles.layout.LayoutGraphAdapter} adapter The graph adapter the mapper shall be provided for.
 * @param {?} layout The layout using the mapper.
 * @return {?<TItem, TValue>} A mapper that maps items to values or <code>null</code>.
 */
yfiles.layout.ItemMapping.prototype.provideMapper = function(adapter, layout) {};
/**
 * @record
 * @struct
 */
yfiles.layout.LayoutData = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LayoutData.$class;

/**
 * Applies this layout data to the specified <code>layoutGraphAdapter</code>.
 * <p>
 * This method should be called before a layout is executed. It will configure the adapter and graph for to the layout.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraphAdapter} layoutGraphAdapter The adapter to add the layout data to.
 * @param {?} layout The layout that shall use this layout data.
 * @param {!yfiles.layout.CopiedLayoutGraph} layoutGraph The layout graph used for the layout calculation.
 * @return {void}
 */
yfiles.layout.LayoutData.prototype.apply = function(layoutGraphAdapter, layout, layoutGraph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.LayoutExecutor = function() {};
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.layout.LayoutExecutor.prototype.abortHandler;
 /** @type {!yfiles.layout.TableLayoutConfigurator} */
yfiles.layout.LayoutExecutor.prototype.tableLayoutConfigurator;
 /** @type {boolean} */
yfiles.layout.LayoutExecutor.prototype.configureTableLayout;
 /** @type {!yfiles.lang.TimeSpan} */
yfiles.layout.LayoutExecutor.prototype.duration;
 /** @type {boolean} */
yfiles.layout.LayoutExecutor.prototype.automaticEdgeGrouping;
 /** @type {boolean} */
yfiles.layout.LayoutExecutor.prototype.fixPorts;
 /** @type {boolean} */
yfiles.layout.LayoutExecutor.prototype.animateViewport;
 /** @type {boolean} */
yfiles.layout.LayoutExecutor.prototype.considerViewportLimiter;
 /** @type {boolean} */
yfiles.layout.LayoutExecutor.prototype.easedAnimation;
 /** @type {!yfiles.geometry.Insets} */
yfiles.layout.LayoutExecutor.prototype.targetBoundsInsets;
 /** @type {boolean} */
yfiles.layout.LayoutExecutor.prototype.updateContentRect;
 /** @type {boolean} */
yfiles.layout.LayoutExecutor.prototype.running;
 /** @type {!yfiles.layout.LayoutData} */
yfiles.layout.LayoutExecutor.prototype.layoutData;
 /** @type {?<?>} */
yfiles.layout.LayoutExecutor.prototype.selectionModel;
 /** @type {!yfiles.layout.CopiedLayoutGraph} */
yfiles.layout.LayoutExecutor.prototype.layoutGraph;
 /** @type {!yfiles.view.GraphComponent} */
yfiles.layout.LayoutExecutor.prototype.graphComponent;
 /** @type {?} */
yfiles.layout.LayoutExecutor.prototype.layout;
 /** @type {?} */
yfiles.layout.LayoutExecutor.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LayoutExecutor.$class;

/**
 * Creates an instance of {\@link yfiles.algorithms.AbortHandler}.
 * <p>
 * This method is called upon first access to the {\@link yfiles.layout.LayoutExecutor#abortHandler} property.
 * </p>
 * @protected
 * @return {!yfiles.algorithms.AbortHandler} A new {\@link } instance to use during layout calculation.
 */
yfiles.layout.LayoutExecutor.prototype.createAbortHandler = function() {};

/**
 * Factory method that creates the {\@link yfiles.view.IAnimation} that will be used by this instance after the layout has been
 * calculated.
 * @see yfiles.layout.LayoutExecutor#duration
 * @see yfiles.layout.LayoutExecutor#animateViewport
 * @see yfiles.layout.LayoutExecutor#createMorphAnimation
 * @see yfiles.layout.LayoutExecutor#createViewportAnimation
 * @protected
 * @return {?} The animation to use after the layout.
 */
yfiles.layout.LayoutExecutor.prototype.createAnimation = function() {};

/**
 * Factory method that creates the animation for the {\@link yfiles.graph.IGraph}.
 * @see yfiles.layout.LayoutExecutor#createAnimation
 * @protected
 * @return {?} The animation instance.
 */
yfiles.layout.LayoutExecutor.prototype.createMorphAnimation = function() {};

/**
 * Creates an animation that morphs the layout of all {\@link yfiles.graph.ITable}s in the graph.
 * @see yfiles.view.TableAnimation
 * @see yfiles.layout.LayoutExecutor#configureTableLayout
 * @protected
 * @return {?}
 */
yfiles.layout.LayoutExecutor.prototype.createTableAnimations = function() {};

/**
 * Create a new instance of {\@link yfiles.layout.TableLayoutConfigurator} that is used if {\@link yfiles.layout.LayoutExecutor#configureTableLayout} is enabled.
 * <p>
 * This method is called upon first access to the {\@link yfiles.layout.LayoutExecutor#tableLayoutConfigurator} property.
 * </p>
 * @protected
 * @return {!yfiles.layout.TableLayoutConfigurator} A new instance of the {\@link } class.
 */
yfiles.layout.LayoutExecutor.prototype.createTableLayoutConfigurator = function() {};

/**
 * Factory method that creates the animation for the {\@link yfiles.view.CanvasComponent#viewport}.
 * @see yfiles.layout.LayoutExecutor#createAnimation
 * @protected
 * @param {!yfiles.geometry.Rect} targetBounds The target bounds of the animation.
 * @return {?} The animation instance.
 */
yfiles.layout.LayoutExecutor.prototype.createViewportAnimation = function(targetBounds) {};

/**
 * Callback method that performs the actual layout.
 * @protected
 * @return {void}
 */
yfiles.layout.LayoutExecutor.prototype.execute = function() {};

/**
 * Calculate the target bounds to be used for the {\@link yfiles.view.CanvasComponent#contentRect} as well as the {\@link yfiles.view.ViewportAnimation} after the layout has
 * finished.
 * <p>
 * By default, the value is computed with {\@link yfiles.layout.LayoutGraphUtilities#getBoundingBox} with labels and {\@link yfiles.layout.LayoutExecutor#targetBoundsInsets} taken into
 * account.
 * </p>
 * @protected
 * @return {!yfiles.geometry.Rect} The desired content rectangle and the bounds for a viewport animation.
 */
yfiles.layout.LayoutExecutor.prototype.getTargetBounds = function() {};

/**
 * Set up {\@link yfiles.layout.LayoutExecutor#tableLayoutConfigurator} for a layout.
 * <p>
 * This implementation configures {\@link yfiles.layout.TableLayoutConfigurator#horizontalLayout} according to the {\@link yfiles.layout.MultiStageLayout#layoutOrientation} and calls {\@link yfiles.layout.TableLayoutConfigurator#prepare}
 * </p>
 * @protected
 * @return {void}
 */
yfiles.layout.LayoutExecutor.prototype.prepareTableLayout = function() {};

/**
 * Writes the table layout information provided through {\@link yfiles.layout.LayoutExecutor#tableLayoutConfigurator} back to all tables.
 * <p>
 * This method is only called when the layout is not animated.
 * </p>
 * @see yfiles.layout.LayoutExecutor#prepareTableLayout
 * @protected
 * @return {void}
 */
yfiles.layout.LayoutExecutor.prototype.restoreTableLayout = function() {};

/**
 * Actually starts the layout calculation and the optional animation asynchronously using a Promise.
 * <p>
 * This method will ultimately call the {\@link yfiles.layout.LayoutExecutor#execute} method. If the {\@link yfiles.layout.LayoutExecutor#duration} is zero no animation will be
 * performed.
 * </p>
 * <p>
 * If this instance is already running, this method returns immedetaly without doing anything and returns the previous
 * Promise.
 * </p>
 * @see yfiles.layout.LayoutExecutor#execute
 * @return {!Promise<!Object>} A Promise that will be fulfilled once the layout and optional animation is done.
 */
yfiles.layout.LayoutExecutor.prototype.start = function() {};

/**
 * Stops a currently running layout calculation or animation.
 * <p>
 * If a layout calculation is still running, it will be requested to stopped via {\@link yfiles.algorithms.AbortHandler#stop} and
 * the animation will not run. If the layout calculation was already completed, the animation will be aborted immediately
 * and the layout result will be shown immediately.
 * </p>
 * <p>
 * To just skip the animation but let the calculation finish normally, the {\@link yfiles.layout.LayoutExecutor#duration} can be set to zero at any time before the
 * animation was started.
 * </p>
 * @return {!Promise<!Object>}
 */
yfiles.layout.LayoutExecutor.prototype.stop = function() {};
/**
 * @record
 * @struct
 */
yfiles.layout.LayoutGraphAdapter = function() {};
 /** @type {!yfiles.algorithms.IEdgeLabelLayoutDpKey<!yfiles.layout.PreferredPlacementDescriptor>} */
yfiles.layout.LayoutGraphAdapter.EDGE_LABEL_LAYOUT_PREFERRED_PLACEMENT_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.layout.LayoutGraphAdapter.ORIGINAL_NODE_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<?>} */
yfiles.layout.LayoutGraphAdapter.ORIGINAL_EDGE_DP_KEY;
 /** @type {!yfiles.algorithms.INodeLabelLayoutDpKey<?>} */
yfiles.layout.LayoutGraphAdapter.ORIGINAL_NODE_LABEL_DP_KEY;
 /** @type {!yfiles.algorithms.IEdgeLabelLayoutDpKey<?>} */
yfiles.layout.LayoutGraphAdapter.ORIGINAL_EDGE_LABEL_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<?>} */
yfiles.layout.LayoutGraphAdapter.ORIGINAL_SOURCE_PORT_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<?>} */
yfiles.layout.LayoutGraphAdapter.ORIGINAL_TARGET_PORT_DP_KEY;
 /** @type {!yfiles.algorithms.GraphObjectDpKey<?<?>>} */
yfiles.layout.LayoutGraphAdapter.UNCONNECTED_PORTS_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.layout.LayoutGraphAdapter.PORT_DUMMY_NODE_DP_KEY;
 /** @type {?} */
yfiles.layout.LayoutGraphAdapter.prototype.adaptedGraph;
 /** @type {?<?>} */
yfiles.layout.LayoutGraphAdapter.prototype.selectionModel;
 /** @type {!yfiles.geometry.Size} */
yfiles.layout.LayoutGraphAdapter.prototype.edgePortNodeSize;
 /** @type {boolean} */
yfiles.layout.LayoutGraphAdapter.prototype.hideEdgesAtEdges;
 /** @type {boolean} */
yfiles.layout.LayoutGraphAdapter.prototype.automaticEdgeGrouping;
 /** @type {boolean} */
yfiles.layout.LayoutGraphAdapter.prototype.fixPorts;
 /** @type {!Array<!Object>} */
yfiles.layout.LayoutGraphAdapter.prototype.dataProviderKeys;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.LayoutGraphAdapter.$class;

/**
 * Registers a data provider with the graph using the given look-up key and wrapping the given mapper.
 * <p>
 * If a mapper is already registered under the given key, it is overwritten.
 * </p>
 * Type parameter <code>K</code>: The type of the key to use.
 * Type parameter <code>V</code>: The type of the value to use.
 * @template K, V
 * @param {!yfiles.lang.Class} keyType The type of the key to use.
 * @param {!yfiles.lang.Class} valueType The type of the value to use.
 * @param {!Object} dataKey The look-up key to register the data provider with.
 * @param {?<K, V>} mapper The mapper wrapped as data provider.
 * @return {?}
 */
yfiles.layout.LayoutGraphAdapter.prototype.addDataProvider = function(keyType, valueType, dataKey, mapper) {};

/**
 * Convenience method that applies a {\@link yfiles.layout.ILayoutAlgorithm layout algorithm} to an {\@link yfiles.graph.IGraph}, optionally applying some
 * {\@link yfiles.layout.LayoutData}.
 * @param {?} layout The layout algorithm to apply.
 * @param {!yfiles.layout.LayoutData=} layoutData
 * @return {void}
 */
yfiles.layout.LayoutGraphAdapter.prototype.applyLayout = function(layout, layoutData) {};

/**
 * Static convenience method that applies a {\@link yfiles.layout.ILayoutAlgorithm layout algorithm} to an {\@link yfiles.graph.IGraph}.
 * @param {?} graph The graph to compute the layout on.
 * @param {?} layout The layout algorithm to apply.
 * @param {!yfiles.layout.LayoutData=} layoutData
 * @return {void}
 */
yfiles.layout.LayoutGraphAdapter.applyLayout = function(graph, layout, layoutData) {};

/**
 * Creates a {\@link yfiles.layout.CopiedLayoutGraph} for this instance.
 * @return {!yfiles.layout.CopiedLayoutGraph} An instance whose {\@link #commitLayoutToOriginalGraph} will update this instance.
 */
yfiles.layout.LayoutGraphAdapter.prototype.createCopiedLayoutGraph = function() {};

/**
 * Creates the {\@link yfiles.layout.EdgeLabelCandidate} for a given label and {\@link yfiles.graph.ILabelModelParameter} combination.
 * @param {?} originalLabel The original label.
 * @param {?} dummyLabel The dummy label that describes the current laid out label.
 * @param {?} layoutParameter The parameter to create a candidate for.
 * @param {?} labelLayout The {\@link } of the label to pass to the candidate.
 * @return {!yfiles.layout.EdgeLabelCandidate} A candidate to yield for the labeling algorithms or <code>null</code>.
 */
yfiles.layout.LayoutGraphAdapter.prototype.createEdgeLabelCandidate = function(originalLabel, dummyLabel, layoutParameter, labelLayout) {};

/**
 * Factory method that creates an {\@link yfiles.layout.IEdgeLayout} implementation that wraps the given {\@link yfiles.graph.IEdge}
 * @protected
 * @param {?} edge The edge to wrap.
 * @return {?} A wrapper instance.
 */
yfiles.layout.LayoutGraphAdapter.prototype.createEdgeLayout = function(edge) {};

/**
 * Callback factory method that creates the {\@link yfiles.layout.INodeLayout} for the given {\@link yfiles.graph.IPort} that is used as a
 * dummy to represent the port at the {\@link yfiles.graph.IEdge} that owns <code>port</code>.
 * @see yfiles.layout.LayoutGraphAdapter#edgePortNodeSize
 * @see yfiles.layout.LayoutGraphAdapter#hideEdgesAtEdges
 * @protected
 * @param {?} port The port to create the layout for.
 * @return {?} A suitable implementation of {\@link } that uses the {\@link #location port's location} as the center of the node.
 */
yfiles.layout.LayoutGraphAdapter.prototype.createEdgePortLayout = function(port) {};

/**
 * Creates a {\@link yfiles.layout.NodeLabelCandidate} for a given label and {\@link yfiles.graph.ILabelModelParameter} combination.
 * @param {?} originalLabel The original label.
 * @param {?} dummyLabel The dummy label that describes the current laid out label.
 * @param {?} layoutParameter The parameter to create a candidate for.
 * @param {?} ownerLayout The {\@link } of the label to pass to the candidate.
 * @return {!yfiles.layout.NodeLabelCandidate} A candidate to yield for the labeling algorithms or <code>null</code>.
 */
yfiles.layout.LayoutGraphAdapter.prototype.createNodeLabelCandidate = function(originalLabel, dummyLabel, layoutParameter, ownerLayout) {};

/**
 * Factory method that creates a {\@link yfiles.layout.INodeLayout} implementation that wraps the given {\@link yfiles.graph.INode}
 * @protected
 * @param {?} node The node to wrap.
 * @return {?} A wrapper instance.
 */
yfiles.layout.LayoutGraphAdapter.prototype.createNodeLayout = function(node) {};

/**
 *
 * @return {?<!Object>}
 */
yfiles.layout.LayoutGraphAdapter.prototype.edgeObjects = function() {};

/**
 *
 * @param {!Object} dataKey
 * @return {?}
 */
yfiles.layout.LayoutGraphAdapter.prototype.getDataProvider = function(dataKey) {};

/**
 *
 * @param {!Object} edge
 * @return {!Array<?>}
 */
yfiles.layout.LayoutGraphAdapter.prototype.getEdgeLabelLayout = function(edge) {};

/**
 *
 * @param {!Object} edge
 * @return {?}
 */
yfiles.layout.LayoutGraphAdapter.prototype.getEdgeLayout = function(edge) {};

/**
 * Callback that retrieves the label candidate descriptor for the given label and parameter.
 * @see yfiles.layout.LayoutGraphAdapter#createNodeLabelCandidate
 * @see yfiles.layout.LayoutGraphAdapter#createEdgeLabelCandidate
 * @see yfiles.layout.LayoutGraphAdapter#getLabelCandidateDescriptorProvider
 * @protected
 * @param {?} originalLabel The original label to which a parameter will be applied.
 * @param {?} dummyLabel The dummy label to which the parameter will be applied.
 * @param {?} layoutParameter The parameter to apply.
 * @return {?} A descriptor or <code>null</code>.
 */
yfiles.layout.LayoutGraphAdapter.prototype.getLabelCandidateDescriptor = function(originalLabel, dummyLabel, layoutParameter) {};

/**
 * Callback method that gets the label candidate descriptor provider for the given {\@link yfiles.graph.IGraph}.
 * <p>
 * This implementation uses the {\@link yfiles.graph.IGraph}'s {\@link yfiles.graph.ILookup} to find an implementation of the
 * {\@link yfiles.graph.ILabelCandidateDescriptorProvider}.
 * </p>
 * @protected
 * @param {?} graph The graph.
 * @return {?} The result of a {\@link #lookup} query on <code>graph</code> for the {\@link } type.
 */
yfiles.layout.LayoutGraphAdapter.prototype.getLabelCandidateDescriptorProvider = function(graph) {};

/**
 *
 * @param {!Object} node
 * @return {!Array<?>}
 */
yfiles.layout.LayoutGraphAdapter.prototype.getNodeLabelLayout = function(node) {};

/**
 *
 * @param {!Object} o
 * @return {?}
 */
yfiles.layout.LayoutGraphAdapter.prototype.getNodeLayout = function(o) {};

/**
 *
 * @param {!Object} edgeObject
 * @return {!Object}
 */
yfiles.layout.LayoutGraphAdapter.prototype.getSource = function(edgeObject) {};

/**
 *
 * @param {!Object} edgeObject
 * @return {!Object}
 */
yfiles.layout.LayoutGraphAdapter.prototype.getTarget = function(edgeObject) {};

/**
 *
 * @return {?<!Object>}
 */
yfiles.layout.LayoutGraphAdapter.prototype.nodeObjects = function() {};

/**
 * Callback method that assigns a new location that matches <code>newLocation</code> to <code>port</code>.
 * <p>
 * This method is called only for ports which are owned by edges. These are represented by dummy nodes during the layout,
 * and <code>newLocation</code> is the position of the dummy node after the layout.
 * </p>
 * @protected
 * @param {?} port The edge port that should be placed.
 * @param {!yfiles.geometry.Point} newLocation The new location of the port as calculated by the layout algorithm.
 * @return {void}
 */
yfiles.layout.LayoutGraphAdapter.prototype.setEdgePortLocation = function(port, newLocation) {};

/**
 * Callback method that assigns a new relative location to <code>port</code>.
 * <p>
 * The default implementation calls {\@link yfiles.graph.IGraph#setRelativePortLocation} with
 * <code>newRelativeLocation</code>. Depending on the port location model, the actual resulting port location may be different.
 * </p>
 * @protected
 * @param {?} port The port that should be placed.
 * @param {!yfiles.geometry.Point} newRelativeLocation The new coordinate offsets relative to the center of the node's {\@link #layout}'s center.
 * @return {void}
 */
yfiles.layout.LayoutGraphAdapter.prototype.setRelativePortLocation = function(port, newRelativeLocation) {};
/**
 * @record
 * @struct
 */
yfiles.layout.PartitionGridData = function() {};
 /** @type {!yfiles.layout.PartitionGrid} */
yfiles.layout.PartitionGridData.prototype.grid;
 /** @type {!yfiles.layout.ContextItemMapping<?, !yfiles.layout.PartitionCellId, !yfiles.layout.PartitionGrid>} */
yfiles.layout.PartitionGridData.prototype.cellIds;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.layout.PartitionGridData.prototype.rowIndices;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.layout.PartitionGridData.prototype.columnIndices;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PartitionGridData.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.PartitionLayoutData = function() {};
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.layout.PartitionLayoutData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.layout.PartitionLayoutData.prototype.targetPortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.layout.PartitionLayoutData.prototype.sourcePortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.layout.PartitionLayoutData.prototype.targetPortCandidates;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.PartitionLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.RecursiveGroupLayoutData = function() {};
 /** @type {!yfiles.layout.ItemMapping<?, ?>} */
yfiles.layout.RecursiveGroupLayoutData.prototype.groupNodeLayouts;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.layout.RecursiveGroupLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.layout.RecursiveGroupLayoutData.prototype.sourceSplitIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.layout.RecursiveGroupLayoutData.prototype.targetSplitIds;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.layout.RecursiveGroupLayoutData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.layout.RecursiveGroupLayoutData.prototype.targetPortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.layout.RecursiveGroupLayoutData.prototype.sourcePortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.layout.RecursiveGroupLayoutData.prototype.targetPortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortCandidateSet>} */
yfiles.layout.RecursiveGroupLayoutData.prototype.nodePortCandidateSets;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.layout.RecursiveGroupLayoutData.prototype.abortHandler;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.RecursiveGroupLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.ReverseEdgesStageData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.layout.ReverseEdgesStageData.prototype.affectedEdges;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.layout.ReverseEdgesStageData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.layout.ReverseEdgesStageData.prototype.targetPortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.layout.ReverseEdgesStageData.prototype.sourceGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.layout.ReverseEdgesStageData.prototype.targetGroupIds;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.ReverseEdgesStageData.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.SingleItemCollection = function() {};
 /** @type {V} */
yfiles.layout.SingleItemCollection.prototype.item;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.SingleItemCollection.$class;
/**
 * @record
 * @struct
 */
yfiles.layout.TableLayoutConfigurator = function() {};
 /** @type {number} */
yfiles.layout.TableLayoutConfigurator.prototype.minimumTableDistance;
 /** @type {boolean} */
yfiles.layout.TableLayoutConfigurator.prototype.compaction;
 /** @type {boolean} */
yfiles.layout.TableLayoutConfigurator.prototype.horizontalLayout;
 /** @type {boolean} */
yfiles.layout.TableLayoutConfigurator.prototype.fromSketch;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.TableLayoutConfigurator.$class;

/**
 * Destroy all information that results from a previous {\@link yfiles.layout.TableLayoutConfigurator#prepare} and a subsequent
 * layout
 * @param {?} graph
 * @return {void}
 */
yfiles.layout.TableLayoutConfigurator.prototype.cleanUp = function(graph) {};

/**
 * Return the sizes of all <b>leaf</b> rows.
 * <p>
 * This method does not modify <code>originalTable</code>. You also need to call {\@link yfiles.layout.TableLayoutConfigurator#cleanUp}
 * explicitly if you don't need the {\@link yfiles.layout.TableLayoutConfigurator} anymore.
 * </p>
 * @param {?} originalTable The table
 * @param {!yfiles.geometry.Rect} nodeLayout The final layout of the node that owns the table
 * @return {!Array<number>} The sizes of all <b>leaf</b> rows in <code>originalTable</code>, in their natural order.
 */
yfiles.layout.TableLayoutConfigurator.prototype.getColumnLayout = function(originalTable, nodeLayout) {};

/**
 * Return the sizes of all <b>leaf</b> rows.
 * <p>
 * This method does not modify <code>originalTable</code>. You also need to call {\@link yfiles.layout.TableLayoutConfigurator#cleanUp}
 * explicitly if you don't need the {\@link yfiles.layout.TableLayoutConfigurator} anymore.
 * </p>
 * @param {?} originalTable The table
 * @param {!yfiles.geometry.Rect} nodeLayout The final layout of the node that owns the table
 * @return {!Array<number>} The sizes of all <b>leaf</b> rows in <code>originalTable</code>, in their natural order.
 */
yfiles.layout.TableLayoutConfigurator.prototype.getRowLayout = function(originalTable, nodeLayout) {};

/**
 * Setup partition grid information from a graph that contains table structures
 * @param {?} graph
 * @return {void}
 */
yfiles.layout.TableLayoutConfigurator.prototype.prepare = function(graph) {};

/**
 * Write back all information from the partition grid
 * @param {?} graph
 * @return {void}
 */
yfiles.layout.TableLayoutConfigurator.prototype.restore = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.layout.YGraphAdapter = function() {};
 /** @type {!yfiles.algorithms.Graph} */
yfiles.layout.YGraphAdapter.prototype.yGraph;
 /** @type {?} */
yfiles.layout.YGraphAdapter.prototype.originalGraph;
 /** @type {!yfiles.lang.Class} */
yfiles.layout.YGraphAdapter.$class;

/**
 * Creates an {\@link yfiles.algorithms.IDataMap} that delegates to the provided {\@link yfiles.collections.IMapper.<K,V>} when queried for items in the {\@link yfiles.layout.YGraphAdapter#yGraph}.
 * <p>
 * This method is useful where algorithms require {\@link yfiles.algorithms.IDataMap}s as input and that input can be obtained from
 * {\@link yfiles.collections.IMapper.<K,V>} instances that provide and accept values for the {\@link yfiles.layout.YGraphAdapter#getOriginalNode original nodes} and {\@link yfiles.layout.YGraphAdapter#getOriginalEdge edges}.
 * </p>
 * Type parameter <code>K</code>: The type of the keys in the mapper.
 * Type parameter <code>V</code>: The type of the values in the mapper.
 * @see yfiles.layout.YGraphAdapter#createDataProvider
 * @template K, V
 * @param {!yfiles.lang.Class} keyType The type of the keys in the mapper.
 * @param {!yfiles.lang.Class} valueType The type of the values in the mapper.
 * @param {?<K, V>} mapper The mapper to direct requests to.
 * @return {?} An {\@link } that will delegate the functionality to the <code>mapper</code>.
 */
yfiles.layout.YGraphAdapter.prototype.createDataMap = function(keyType, valueType, mapper) {};

/**
 * Creates an {\@link yfiles.algorithms.IDataProvider} that delegates to the provided delegate when queried for items in the {\@link yfiles.layout.YGraphAdapter#yGraph}.
 * <p>
 * This method is useful where algorithms require {\@link yfiles.algorithms.IDataProvider}s as input and that input can be through a
 * dynamic callback that provides the values for the {\@link yfiles.layout.YGraphAdapter#getOriginalNode original nodes} and {\@link yfiles.layout.YGraphAdapter#getOriginalEdge edges}.
 * </p>
 * Type parameter <code>K</code>: The type of the keys in the mapper.
 * Type parameter <code>V</code>: The type of the values in the mapper.
 * Creates an {\@link yfiles.algorithms.IDataProvider} that delegates to the provided {\@link yfiles.collections.IMapper.<K,V>} when queried for items in the {\@link yfiles.layout.YGraphAdapter#yGraph}.
 * <p>
 * This method is useful where algorithms require {\@link yfiles.algorithms.IDataProvider}s as input and that input can be obtained
 * from {\@link yfiles.collections.IMapper.<K,V>} instances that provide the values for the {\@link yfiles.layout.YGraphAdapter#getOriginalNode original nodes} and {\@link yfiles.layout.YGraphAdapter#getOriginalEdge edges}.
 * </p>
 * Type parameter <code>K</code>: The type of the keys in the mapper.
 * Type parameter <code>V</code>: The type of the values in the mapper.
 * @template K, V
 * @param {!yfiles.lang.Class} keyType The type of the keys in the mapper.
 * @param {!yfiles.lang.Class} valueType The type of the values in the mapper.
 * @param {function(K): V|?<K, V>} getter_or_mapper The mapper delegate to direct requests to. / The mapper to direct requests to.
 * @return {?} A DataProvider that will delegate requests to the <code>getter</code>. / A DataProvider that will delegate requests to the <code>mapper</code>.
 */
yfiles.layout.YGraphAdapter.prototype.createDataProvider = function(keyType, valueType, getter_or_mapper) {};

/**
 * Creates an {\@link yfiles.collections.IEnumerable.<T> enumerable of edges} that maps the edges from the {\@link yfiles.algorithms.EdgeList} to their {\@link yfiles.layout.YGraphAdapter#getOriginalEdge original} ones.
 * <p>
 * This method is useful where algorithms yield {\@link yfiles.algorithms.EdgeList} instances as results and the result needs to be
 * interpreted in terms of the {\@link yfiles.layout.YGraphAdapter#originalGraph}.
 * </p>
 * @param {!yfiles.algorithms.EdgeList} edges The edge list.
 * @return {?<?>} An enumerable that contains the {\@link #getOriginalEdge original} edges for the ones in the list.
 */
yfiles.layout.YGraphAdapter.prototype.createEdgeEnumerable = function(edges) {};

/**
 * Creates an {\@link yfiles.algorithms.EdgeList} that maps the edges from the {\@link yfiles.collections.IEnumerable.<T>} to their {\@link yfiles.layout.YGraphAdapter#getCopiedEdge copied} ones.
 * <p>
 * This method is useful where algorithms require {\@link yfiles.algorithms.EdgeList} instances as input and those edges are
 * available as {\@link yfiles.collections.IEnumerable.<T>}s in the {\@link yfiles.layout.YGraphAdapter#originalGraph}.
 * </p>
 * @param {?<?>} edges The edges from the {\@link #originalGraph}.
 * @return {!yfiles.algorithms.EdgeList} An {\@link } that contains the {\@link #getCopiedEdge copied} edges for the ones in the enumerable.
 */
yfiles.layout.YGraphAdapter.prototype.createEdgeList = function(edges) {};

/**
 * Creates an {\@link yfiles.algorithms.IEdgeMap} that delegates to the provided delegate when queried for {\@link yfiles.algorithms.Edge}s
 * in the {\@link yfiles.layout.YGraphAdapter#yGraph}.
 * <p>
 * This method is useful where algorithms require {\@link yfiles.algorithms.IEdgeMap}s as input and this can be mapped to a
 * corresponding dynamic callback that provides the values for the {\@link yfiles.layout.YGraphAdapter#getOriginalEdge original edges}.
 * </p>
 * Type parameter <code>V</code>: The type of the values in the mapper.
 * Creates an {\@link yfiles.algorithms.IEdgeMap} that delegates to the provided {\@link yfiles.collections.IMapper.<K,V>} when queried for {\@link yfiles.algorithms.Edge}s in the {\@link yfiles.layout.YGraphAdapter#yGraph}.
 * <p>
 * This method is useful where algorithms require {\@link yfiles.algorithms.IEdgeMap}s as input and this can be mapped to
 * corresponding {\@link yfiles.collections.IMapper.<K,V>} instances that provide and accept the values for the {\@link yfiles.layout.YGraphAdapter#getOriginalEdge original edges}.
 * </p>
 * Type parameter <code>V</code>: The type of the values in the mapper.
 * @template V
 * @param {function(?): V|?<?, V>} getter_or_mapper The mapper delegate to direct read requests to. / The mapper to direct requests to.
 * @return {?} An {\@link } that will delegate reads to the <code>getter</code>. / An {\@link } that will delegate reads and writes to the <code>mapper</code>.
 */
yfiles.layout.YGraphAdapter.prototype.createEdgeMap = function(getter_or_mapper) {};

/**
 * Creates an {\@link yfiles.collections.IMapper.<K,V>} that delegates to the provided {\@link yfiles.algorithms.INodeMap} when queried for items in the
 * {\@link yfiles.graph.IGraph}.
 * <p>
 * This method is useful where algorithms yield {\@link yfiles.algorithms.INodeMap}s and their values should be provided using {\@link yfiles.collections.IMapper.<K,V>}
 * instances that use the {\@link yfiles.layout.YGraphAdapter#getOriginalNode original nodes}.
 * </p>
 * Type parameter <code>T</code>: The type of the values in the mapper.
 * @template T
 * @param {?} nodeMap The map to direct requests to.
 * @return {?<?, T>} A mapper that will delegate requests to the <code>nodeMap</code>.
 */
yfiles.layout.YGraphAdapter.prototype.createEdgeMapper = function(nodeMap) {};

/**
 * Creates an {\@link yfiles.collections.IMapper.<K,V>} that delegates to the provided {\@link yfiles.algorithms.IDataProvider} when queried for items in the
 * {\@link yfiles.graph.IGraph}.
 * <p>
 * This method is useful where algorithms yield {\@link yfiles.algorithms.IDataProvider}s and their values should be provided using
 * {\@link yfiles.collections.IMapper.<K,V>} instances that use the {\@link yfiles.layout.YGraphAdapter#getOriginalEdge original edges} and the {\@link yfiles.layout.YGraphAdapter#getOriginalNode original nodes}.
 * </p>
 * Type parameter <code>T</code>: The type of the values in the mapper.
 * @template T
 * @param {?} dataProvider The provider to direct requests to.
 * @return {?<?, T>} A mapper that will delegate requests to the <code>dataProvider</code>.
 */
yfiles.layout.YGraphAdapter.prototype.createMapper = function(dataProvider) {};

/**
 * Creates an {\@link yfiles.collections.IEnumerable.<T> enumerable of nodes} that maps the nodes from the {\@link yfiles.algorithms.NodeList} to their {\@link yfiles.layout.YGraphAdapter#getOriginalNode original} ones.
 * <p>
 * This method is useful where algorithms yield {\@link yfiles.algorithms.NodeList} instances as results and the result needs to be
 * interpreted in terms of the {\@link yfiles.layout.YGraphAdapter#originalGraph}.
 * </p>
 * @param {!yfiles.algorithms.NodeList} nodes The node list.
 * @return {?<?>} An enumerable that contains the {\@link #getOriginalNode original} nodes for the ones in the list.
 */
yfiles.layout.YGraphAdapter.prototype.createNodeEnumerable = function(nodes) {};

/**
 * Creates a {\@link yfiles.algorithms.NodeList} that maps the nodes from the {\@link yfiles.collections.IEnumerable.<T>} to their {\@link yfiles.layout.YGraphAdapter#getCopiedNode copied} ones.
 * <p>
 * This method is useful where algorithms require {\@link yfiles.algorithms.NodeList} instances as input and those nodes are
 * available as {\@link yfiles.collections.IEnumerable.<T>}s in the {\@link yfiles.layout.YGraphAdapter#originalGraph}.
 * </p>
 * @param {?<?>} nodes The nodes from the {\@link #originalGraph}.
 * @return {!yfiles.algorithms.NodeList} A {\@link } that contains the {\@link #getCopiedNode copied} nodes for the ones in the enumerable.
 */
yfiles.layout.YGraphAdapter.prototype.createNodeList = function(nodes) {};

/**
 * Creates an {\@link yfiles.algorithms.INodeMap} that delegates to the provided delegate when queried for {\@link yfiles.algorithms.Node}s
 * in the {\@link yfiles.layout.YGraphAdapter#yGraph}.
 * <p>
 * This method is useful where algorithms require {\@link yfiles.algorithms.INodeMap}s as input and this can be mapped to a
 * corresponding dynamic callback that provides the values for the {\@link yfiles.layout.YGraphAdapter#getOriginalNode original nodes}.
 * </p>
 * Type parameter <code>V</code>: The type of the values in the mapper.
 * Creates an {\@link yfiles.algorithms.INodeMap} that delegates to the provided {\@link yfiles.collections.IMapper.<K,V>} when queried for {\@link yfiles.algorithms.Node}s in the {\@link yfiles.layout.YGraphAdapter#yGraph}.
 * <p>
 * This method is useful where algorithms require {\@link yfiles.algorithms.INodeMap}s as input and this can be mapped to
 * corresponding {\@link yfiles.collections.IMapper.<K,V>} instances that provide and accept the values for the {\@link yfiles.layout.YGraphAdapter#getOriginalNode original nodes}.
 * </p>
 * Type parameter <code>V</code>: The type of the values in the mapper.
 * @template V
 * @param {function(?): V|?<?, V>} getter_or_mapper The mapper delegate to direct read requests to. / The mapper to direct requests to.
 * @return {?} An {\@link } that will delegate reads to the <code>getter</code>. / An {\@link } that will delegate reads and writes to the <code>mapper</code>.
 */
yfiles.layout.YGraphAdapter.prototype.createNodeMap = function(getter_or_mapper) {};

/**
 * Creates an {\@link yfiles.collections.IMapper.<K,V>} that delegates to the provided {\@link yfiles.algorithms.IEdgeMap} when queried for items in the
 * {\@link yfiles.graph.IGraph}.
 * <p>
 * This method is useful where algorithms yield {\@link yfiles.algorithms.IDataProvider}s and their values should be provided using
 * {\@link yfiles.collections.IMapper.<K,V>} instances that use the {\@link yfiles.layout.YGraphAdapter#getOriginalEdge original edges}.
 * </p>
 * Type parameter <code>T</code>: The type of the values in the mapper.
 * @template T
 * @param {?} edgeMap The map to direct requests to.
 * @return {?<?, T>} A mapper that will delegate requests to the <code>edgeMap</code>.
 */
yfiles.layout.YGraphAdapter.prototype.createNodeMapper = function(edgeMap) {};

/**
 * Yields the edge that has been created as a copy in {\@link yfiles.layout.YGraphAdapter#yGraph} to represent the given edge.
 * @param {?} edge The edge for which the representation is returned.
 * @return {!yfiles.algorithms.Edge} The edge that represents <code>edge</code> in {\@link #yGraph}.
 */
yfiles.layout.YGraphAdapter.prototype.getCopiedEdge = function(edge) {};

/**
 * Yields the node that has been created as a copy in {\@link yfiles.layout.YGraphAdapter#yGraph} to represent the given node.
 * @param {?} node The node for which the representation is returned.
 * @return {!yfiles.algorithms.Node} The node that represents <code>node</code> in {\@link #yGraph}.
 */
yfiles.layout.YGraphAdapter.prototype.getCopiedNode = function(node) {};

/**
 * Yields the original edge from the {\@link yfiles.layout.YGraphAdapter#originalGraph original IGraph} that the given edge has been created for.
 * @param {!yfiles.algorithms.Edge} edge The edge for which the original instance will be returned.
 * @return {?} The original instance.
 */
yfiles.layout.YGraphAdapter.prototype.getOriginalEdge = function(edge) {};

/**
 * Yields the original node from the {\@link yfiles.layout.YGraphAdapter#originalGraph original IGraph} that the given node has been created for.
 * @param {!yfiles.algorithms.Node} node The node for which the original instance will be returned.
 * @return {?} The original instance.
 */
yfiles.layout.YGraphAdapter.prototype.getOriginalNode = function(node) {};
/** @const */
yfiles.hierarchic = {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ILayerConstraint = function() {};
 /** @type {number} */
yfiles.hierarchic.ILayerConstraint.prototype.priority;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.ILayerConstraint;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ILayerConstraintFactory = function() {};
 /** @type {!Object} */
yfiles.hierarchic.ILayerConstraintFactory.prototype.memento;

/**
 * Adds a constraint that forces the {\@link yfiles.algorithms.Node} with ID <code>aboveId</code> to lie at least <code>minDistance</code> layers above the {\@link yfiles.algorithms.Node}
 * with ID <code>referenceId</code> with a given weight penalty for larger layer differences.
 * <p>
 * The minimum distance includes potentially empty layers that are removed by the {\@link yfiles.hierarchic.ILayerer} instance. In
 * that case, the actual layer difference may be smaller than the minimum distance.
 * </p>
 * @see yfiles.hierarchic.ILayerConstraint
 * @abstract
 * Adds a constraint that forces the {\@link yfiles.algorithms.Node} with ID <code>aboveId</code> to lie above the {\@link yfiles.algorithms.Node} with ID
 * <code>referenceId</code>.
 * @see yfiles.hierarchic.ILayerConstraint
 * @abstract
 * @param {!Object} referenceId the ID of the reference node
 * @param {!Object} aboveId the ID of the node that should lie above
 * @param {number=} minDistance the minimum layer distance between the node and its reference node
 * @param {number=} weight
 * @return {?} a {\@link } object that represents the constraint
 */
yfiles.hierarchic.ILayerConstraintFactory.prototype.addPlaceNodeAboveConstraint = function(referenceId, aboveId, minDistance, weight) {};

/**
 * Adds a constraint that places a {\@link yfiles.algorithms.Node} on the bottom layer.
 * @see yfiles.hierarchic.ILayerConstraint
 * @abstract
 * @param {!Object} nodeId the ID of the node that should lie on the bottom layer
 * @return {?} a {\@link } object that represents the constraint
 */
yfiles.hierarchic.ILayerConstraintFactory.prototype.addPlaceNodeAtBottomConstraint = function(nodeId) {};

/**
 * Adds a constraint that places a {\@link yfiles.algorithms.Node} on the topmost layer.
 * @see yfiles.hierarchic.ILayerConstraint
 * @abstract
 * @param {!Object} nodeId the ID of the node that should lie on the top layer
 * @return {?} a {\@link } object that represents the constraint
 */
yfiles.hierarchic.ILayerConstraintFactory.prototype.addPlaceNodeAtTopConstraint = function(nodeId) {};

/**
 * Adds a constraint that forces the {\@link yfiles.algorithms.Node} with ID <code>belowId</code> to lie at least <code>minDistance</code> layers below the {\@link yfiles.algorithms.Node}
 * with ID <code>referenceId</code> with a given weight penalty for larger layer differences.
 * <p>
 * The minimum distance includes potentially empty layers that are removed by the {\@link yfiles.hierarchic.ILayerer} instance. In
 * that case, the actual layer difference may be smaller than the minimum distance.
 * </p>
 * @see yfiles.hierarchic.ILayerConstraint
 * @abstract
 * Adds a constraint that forces a {\@link yfiles.algorithms.Node} with ID <code>belowId</code> to lie below the {\@link yfiles.algorithms.Node} with ID
 * <code>referenceId</code>.
 * @see yfiles.hierarchic.ILayerConstraint
 * @abstract
 * @param {!Object} referenceId the ID of the reference node
 * @param {!Object} belowId the ID of the node that should lie below
 * @param {number=} minDistance the minimum layer distance between the node and its reference node
 * @param {number=} weight
 * @return {?} a {\@link } object that represents the constraint
 */
yfiles.hierarchic.ILayerConstraintFactory.prototype.addPlaceNodeBelowConstraint = function(referenceId, belowId, minDistance, weight) {};

/**
 * Adds a constraint that forces the {\@link yfiles.algorithms.Node} with ID <code>sameLayerId</code> to lie in the same layer as the {\@link yfiles.algorithms.Node}
 * with ID <code>referenceId</code>.
 * @see yfiles.hierarchic.ILayerConstraint
 * @abstract
 * @param {!Object} referenceId the ID of the reference node
 * @param {!Object} sameLayerId the ID of the node that should lie in the same layer
 * @return {?} a {\@link } object that represents the constraint
 */
yfiles.hierarchic.ILayerConstraintFactory.prototype.addPlaceNodeInSameLayerConstraint = function(referenceId, sameLayerId) {};

/**
 * Disposes this factory.
 * <p>
 * This method should be called when this factory is not needed anymore, i.e. after the layout has been calculated. Calling
 * this method also clears all constraints.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.hierarchic.ILayerConstraintFactory.prototype.dispose = function() {};

/**
 * Clears all constraints for a given {\@link yfiles.algorithms.Node}.
 * @see yfiles.hierarchic.ILayerConstraint
 * @abstract
 * @param {!Object} nodeId the ID of the node for which all constraints should be cleared
 * @return {void}
 */
yfiles.hierarchic.ILayerConstraintFactory.prototype.removeConstraints = function(nodeId) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.ILayerConstraintFactory;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ISequenceConstraintFactory = function() {};
 /** @type {!Object} */
yfiles.hierarchic.ISequenceConstraintFactory.prototype.memento;

/**
 * Adds a constraint that forces the {\@link yfiles.algorithms.Node} or {\@link yfiles.algorithms.Edge} with id <code>after</code> to lie after the {\@link yfiles.algorithms.Node}
 * or {\@link yfiles.algorithms.Edge} with id <code>reference</code>.
 * @abstract
 * @param {!Object} referenceId the ID of the reference node or edge
 * @param {!Object} afterId the ID of the node or edge that should be placed after the reference element
 * @return {void}
 */
yfiles.hierarchic.ISequenceConstraintFactory.prototype.addPlaceAfterConstraint = function(referenceId, afterId) {};

/**
 * Adds a constraint that places a {\@link yfiles.algorithms.Node} or {\@link yfiles.algorithms.Edge} at the start of the sequence.
 * @abstract
 * @param {!Object} id the ID of the node or edge that should be placed at the start
 * @return {void}
 */
yfiles.hierarchic.ISequenceConstraintFactory.prototype.addPlaceAtHeadConstraint = function(id) {};

/**
 * Adds a constraint that places a {\@link yfiles.algorithms.Node} or {\@link yfiles.algorithms.Edge} at the end of the sequence.
 * @abstract
 * @param {!Object} id the ID of the node or edge that should be placed at the end
 * @return {void}
 */
yfiles.hierarchic.ISequenceConstraintFactory.prototype.addPlaceAtTailConstraint = function(id) {};

/**
 * Adds a constraint that forces the {\@link yfiles.algorithms.Node} or {\@link yfiles.algorithms.Edge} with id <code>before</code> to lie before the {\@link yfiles.algorithms.Node}
 * or {\@link yfiles.algorithms.Edge} with id <code>reference</code>.
 * @abstract
 * @param {!Object} referenceId the ID of the reference node or edge
 * @param {!Object} beforeId the ID of the node or edge that should be placed before the reference element
 * @return {void}
 */
yfiles.hierarchic.ISequenceConstraintFactory.prototype.addPlaceBeforeConstraint = function(referenceId, beforeId) {};

/**
 * Disposes of the {\@link yfiles.hierarchic.ISequenceConstraintFactory}.
 * <p>
 * This method should be called when the factory is not needed anymore, i.e. after the layout has been calculated. Calling
 * this method also clears all constraints.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.hierarchic.ISequenceConstraintFactory.prototype.dispose = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.ISequenceConstraintFactory;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.AsIsLayerer = function() {};
 /** @type {number} */
yfiles.hierarchic.AsIsLayerer.prototype.nodeScalingFactor;
 /** @type {number} */
yfiles.hierarchic.AsIsLayerer.prototype.maximumNodeSize;
 /** @type {number} */
yfiles.hierarchic.AsIsLayerer.prototype.minimumNodeSize;
 /** @type {number} */
yfiles.hierarchic.AsIsLayerer.prototype.nodeHalo;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.AsIsLayerer.$class;

/**
 * Assigns all nodes of the graph to layers by analyzing already existing node coordinates and adds them to the {\@link yfiles.hierarchic.ILayers}
 * instance.
 * <p>
 * Nodes whose bounding boxes overlap in the main layout direction are assigned to the same layer. To influence to which
 * amount the boxes need to overlap, the nodes can temporarily be {\@link yfiles.hierarchic.AsIsLayerer#nodeScalingFactor scaled}.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } instance that will be filled with the results of the calculation
 * @param {?} ldp the {\@link } used for querying information about the nodes and edges
 * @return {void}
 */
yfiles.hierarchic.AsIsLayerer.prototype.assignLayers = function(graph, layers, ldp) {};

/**
 * Callback used for calculating the lower (max) value of a given node.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {!yfiles.algorithms.Node} node the node
 * @return {number} the lower (max) of a given node
 */
yfiles.hierarchic.AsIsLayerer.prototype.getMax = function(graph, node) {};

/**
 * Callback used for calculating the upper (min) value of a given node.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {!yfiles.algorithms.Node} node the node
 * @return {number} the upper (min) value of a given node
 */
yfiles.hierarchic.AsIsLayerer.prototype.getMin = function(graph, node) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.AsIsSequencer = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.AsIsSequencer.$class;

/**
 * Calculates the sequence of the nodes within each layer using the nodes' coordinates.
 * <p>
 * This method is called by {\@link yfiles.hierarchic.HierarchicLayoutCore} and finally writes back the calculated sequence using
 * method {\@link yfiles.hierarchic.ILayer#setNodeOrder}.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance that defines the layering structure
 * @param {?} ldp the {\@link } containing information about the nodes and edges of the graph
 * @param {?} itemFactory the {\@link } used for creating and destroying helper structures
 * @return {void}
 */
yfiles.hierarchic.AsIsSequencer.prototype.sequenceNodeLayers = function(graph, layers, ldp, itemFactory) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.AspectRatioComponentLayerer = function() {};
 /** @type {?} */
yfiles.hierarchic.AspectRatioComponentLayerer.prototype.singleComponentLayerer;
 /** @type {boolean} */
yfiles.hierarchic.AspectRatioComponentLayerer.prototype.considerNodeSize;
 /** @type {number} */
yfiles.hierarchic.AspectRatioComponentLayerer.prototype.desiredAspectRatio;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.AspectRatioComponentLayerer.$class;

/**
 * Assigns all nodes of the graph to layers and registers them to the {\@link yfiles.hierarchic.ILayers} instance based on the given
 * aspect ratio.
 * <p>
 * If the graph consists of multiple components, they will be identified and each of the components will be layered
 * separately using the delegate {\@link yfiles.hierarchic.ILayerer} instance. After that, they will all be merged such that the
 * desired aspect ratio is best fulfilled.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } instance that will be filled with the results of the calculation
 * @param {?} ldp the {\@link } used for query information about the nodes and edges
 * @return {void}
 */
yfiles.hierarchic.AspectRatioComponentLayerer.prototype.assignLayers = function(graph, layers, ldp) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.BFSLayerer = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.hierarchic.BFSLayerer.CORE_NODES_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.BFSLayerer.$class;

/**
 * Assigns all nodes of the graph to layers and adds them to the {\@link yfiles.hierarchic.ILayers} instance.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } instance that will be filled with the results of the calculation
 * @param {?} ldp the {\@link } used for query information about the nodes and edges
 * @return {void}
 */
yfiles.hierarchic.BFSLayerer.prototype.assignLayers = function(graph, layers, ldp) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ConstraintIncrementalLayerer = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.hierarchic.ConstraintIncrementalLayerer.ADDITIONAL_EDGE_WEIGHT_DP_KEY;
 /** @type {boolean} */
yfiles.hierarchic.ConstraintIncrementalLayerer.prototype.allowSameLayerEdges;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.ConstraintIncrementalLayerer.$class;

/**
 * Assigns all nodes of the graph to layers and adds them to the {\@link yfiles.hierarchic.ILayers} instance based on relative and
 * absolute layering constraints defined by the given layering constraints.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } instance that will be filled with the results of the calculation
 * @param {?} ldp the {\@link } used for query information about the nodes and edges
 * @return {void}
 */
yfiles.hierarchic.ConstraintIncrementalLayerer.prototype.assignLayers = function(graph, layers, ldp) {};

/**
 * Checks if the current setting of constraints is consistent (i.e.
 * <p>
 * the induced constraint graph has no cycles).
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the constraint graph is inconsistent
 * @protected
 * @return {void}
 */
yfiles.hierarchic.ConstraintIncrementalLayerer.prototype.checkConstraints = function() {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.DefaultDrawingDistanceCalculator = function() {};
 /** @type {boolean} */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.prototype.adaptiveMinimumEdgeDistanceEnabled;
 /** @type {boolean} */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.prototype.compaction;
 /** @type {number} */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.prototype.nodeToNodeDistance;
 /** @type {number} */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.prototype.nodeToEdgeDistance;
 /** @type {number} */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.prototype.edgeToEdgeDistance;
 /** @type {boolean} */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.prototype.optimizeSwimlaneDistances;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.$class;

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} layers
 * @param {?} ldp
 * @return {void}
 */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.prototype.dispose = function(graph, layers, ldp) {};

/**
 * Determines the minimum distance between two {\@link yfiles.algorithms.Node}s of the same layer.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layer the {\@link } object that will be used during subsequent calls
 * @param {?} ldp the {\@link } used for querying information
 * @param {!yfiles.algorithms.Node} left the left of the two {\@link }s whose minimum distance is to be determined or <code>null</code> if only the left border
 * of the right {\@link } is of interest
 * @param {!yfiles.algorithms.Node} right the right of the two {\@link }s whose minimum distance is to be determined or <code>null</code> if only the right border
 * of the left {\@link } is of interest
 * @return {number} the minimum distances between {\@link }s of same layer
 */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.prototype.getMinDistance = function(graph, layer, ldp, left, right) {};

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} layers
 * @param {?} ldp
 * @return {void}
 */
yfiles.hierarchic.DefaultDrawingDistanceCalculator.prototype.initialize = function(graph, layers, ldp) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.DefaultLayerSequencer = function() {};
 /** @type {boolean} */
yfiles.hierarchic.DefaultLayerSequencer.prototype.transposition;
 /** @type {boolean} */
yfiles.hierarchic.DefaultLayerSequencer.prototype.groupTransposition;
 /** @type {yfiles.hierarchic.WeightHeuristic} */
yfiles.hierarchic.DefaultLayerSequencer.prototype.weightHeuristic;
 /** @type {number} */
yfiles.hierarchic.DefaultLayerSequencer.prototype.maximumDuration;
 /** @type {number} */
yfiles.hierarchic.DefaultLayerSequencer.prototype.randomizationRounds;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.DefaultLayerSequencer.$class;

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} glayers
 * @param {?} ldp
 * @param {?} itemFactory
 * @return {void}
 */
yfiles.hierarchic.DefaultLayerSequencer.prototype.sequenceNodeLayers = function(graph, glayers, ldp, itemFactory) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.DefaultLayeredComponentsMerger = function() {};
 /** @type {yfiles.hierarchic.MergingPolicy} */
yfiles.hierarchic.DefaultLayeredComponentsMerger.prototype.policy;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.DefaultLayeredComponentsMerger.$class;

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} ldp
 * @param {?} srcLayers
 * @param {?} targetLayers
 * @return {void}
 */
yfiles.hierarchic.DefaultLayeredComponentsMerger.prototype.merge = function(graph, ldp, srcLayers, targetLayers) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.DefaultPortAllocator = function() {};
 /** @type {number} */
yfiles.hierarchic.DefaultPortAllocator.prototype.defaultPortBorderGapRatio;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.DefaultPortAllocator.$class;

/**
 * Assigns source and target port coordinates to each edge of the graph.
 * <p>
 * This method assigns:
 * </p>
 * <ul>
 * <li>{\@link yfiles.layout.PortSide#ANY} ports to appropriate sides.</li>
 * <li>{\@link yfiles.layout.PortConstraint#strong Weak} ports to appropriate positions between strong ones.</li>
 * </ul>
 * <p>
 * This method is called by {\@link yfiles.hierarchic.HierarchicLayoutCore} after the sequencing phase.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance containing the layering structure
 * @param {?} ldp the {\@link } containing information about the nodes and edges of the graph
 * @param {?} itemFactory the {\@link } used for creating and destroying helper structures
 * @return {void}
 */
yfiles.hierarchic.DefaultPortAllocator.prototype.assignPorts = function(graph, layers, ldp, itemFactory) {};

/**
 * Callback method used for determining the port border gap for each node and side.
 * <p>
 * It may be overridden for a custom calculation of port border gap on a given node.
 * </p>
 * @see yfiles.hierarchic.DefaultPortAllocator#getPortDistanceDelta
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ldp the {\@link } containing information about the nodes and edges of the graph
 * @param {!yfiles.algorithms.Node} node the given node
 * @param {number} sideIndex the zero-based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)
 * @param {number} sideLength the width/height of the side
 * @param {number} edgeCount the number of edges/ports that connect to this side
 * @return {number} the absolute gap on both sides of the ports
 */
yfiles.hierarchic.DefaultPortAllocator.prototype.getPortBorderGap = function(graph, ldp, node, sideIndex, sideLength, edgeCount) {};

/**
 * Callback method used for determining the port border gap ratio.
 * <p>
 * See {\@link yfiles.hierarchic.DefaultPortAllocator#defaultPortBorderGapRatio} for an explanation.
 * </p>
 * <p>
 * It may be overridden for a custom calculation of port border gap ratio on a given node.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ldp the {\@link } containing information about the nodes and edges of the graph
 * @param {!yfiles.algorithms.Node} node the given node
 * @param {number} sideIndex the zero-based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)
 * @param {number} sideLength the width/height of the side
 * @param {number} edgeCount the number of edges/ports that connect to this side
 * @return {number} the border gap ratio
 */
yfiles.hierarchic.DefaultPortAllocator.prototype.getPortBorderGapRatio = function(graph, ldp, node, sideIndex, sideLength, edgeCount) {};

/**
 * Callback method used for determining the distance between two adjacent ports.
 * <p>
 * It may be overridden for a custom calculation of the distance between two adjacent ports..
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ldp the {\@link } containing information about the nodes and edges of the graph
 * @param {!yfiles.algorithms.Node} node the given node
 * @param {number} sideIndex the zero-based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)
 * @param {number} sideLength the width/height of the side
 * @param {number} edgeCount the number of edges/ports that connect to this side
 * @param {number} portBorderGap the previously calculated port border gap
 * @return {number} the absolute distance between two adjacent ports
 */
yfiles.hierarchic.DefaultPortAllocator.prototype.getPortDistanceDelta = function(graph, ldp, node, sideIndex, sideLength, edgeCount, portBorderGap) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.EdgeLayoutDescriptor = function() {};
 /** @type {number} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.minimumFirstSegmentLength;
 /** @type {number} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.minimumLastSegmentLength;
 /** @type {number} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.minimumLength;
 /** @type {number} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.minimumDistance;
 /** @type {number} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.minimumSlope;
 /** @type {boolean} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.sourcePortOptimization;
 /** @type {boolean} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.targetPortOptimization;
 /** @type {!yfiles.hierarchic.RoutingStyle} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.routingStyle;
 /** @type {number} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.minimumOctilinearSegmentLength;
 /** @type {yfiles.hierarchic.RecursiveEdgeStyle} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.recursiveEdgeStyle;
 /** @type {boolean} */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.directGroupContentEdgeRouting;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.EdgeLayoutDescriptor.$class;

/**
 * Creates a copy of this {\@link yfiles.hierarchic.EdgeLayoutDescriptor} instance.
 * @return {!yfiles.hierarchic.EdgeLayoutDescriptor} a copy of this {\@link } instance
 */
yfiles.hierarchic.EdgeLayoutDescriptor.prototype.createCopy = function() {};

/** @const */
yfiles.hierarchic.WeightHeuristic = {};
/** @const {number} */
yfiles.hierarchic.WeightHeuristic.BARYCENTER;
/** @const {number} */
yfiles.hierarchic.WeightHeuristic.MEDIAN;

/** @const */
yfiles.hierarchic.MergingPolicy = {};
/** @const {number} */
yfiles.hierarchic.MergingPolicy.ADD_BELOW;
/** @const {number} */
yfiles.hierarchic.MergingPolicy.ADD_ABOVE;
/** @const {number} */
yfiles.hierarchic.MergingPolicy.ADD_RIGHT_TOP_ALIGNED;
/** @const {number} */
yfiles.hierarchic.MergingPolicy.ADD_RIGHT_BOTTOM_ALIGNED;
/** @const {number} */
yfiles.hierarchic.MergingPolicy.ADD_RIGHT_CENTER_ALIGNED;
/** @const {number} */
yfiles.hierarchic.MergingPolicy.ADD_LEFT_TOP_ALIGNED;
/** @const {number} */
yfiles.hierarchic.MergingPolicy.ADD_LEFT_BOTTOM_ALIGNED;
/** @const {number} */
yfiles.hierarchic.MergingPolicy.ADD_LEFT_CENTER_ALIGNED;

/** @const */
yfiles.hierarchic.EdgeDataType = {};
/** @const {number} */
yfiles.hierarchic.EdgeDataType.NORMAL;
/** @const {number} */
yfiles.hierarchic.EdgeDataType.SOURCE_GROUP_NODE_CONNECTOR;
/** @const {number} */
yfiles.hierarchic.EdgeDataType.TARGET_GROUP_NODE_CONNECTOR;
/** @const {number} */
yfiles.hierarchic.EdgeDataType.GROUP_NODE_INTERCONNECTOR;
/** @const {number} */
yfiles.hierarchic.EdgeDataType.DIRECT_SAME_LAYER_EDGE;
/** @const {number} */
yfiles.hierarchic.EdgeDataType.NON_DIRECT_SAME_LAYER_EDGE;
/** @const {number} */
yfiles.hierarchic.EdgeDataType.BORDER_EDGE;
/** @const {number} */
yfiles.hierarchic.EdgeDataType.REDIRECTED_GROUP_EDGE;

/** @const */
yfiles.hierarchic.RecursiveEdgeStyle = {};
/** @const {number} */
yfiles.hierarchic.RecursiveEdgeStyle.OFF;
/** @const {number} */
yfiles.hierarchic.RecursiveEdgeStyle.DIRECTED;
/** @const {number} */
yfiles.hierarchic.RecursiveEdgeStyle.UNDIRECTED;

/** @const */
yfiles.hierarchic.ComponentArrangementPolicy = {};
/** @const {number} */
yfiles.hierarchic.ComponentArrangementPolicy.COMPACT;
/** @const {number} */
yfiles.hierarchic.ComponentArrangementPolicy.TOPMOST;

/** @const */
yfiles.hierarchic.LayoutMode = {};
/** @const {number} */
yfiles.hierarchic.LayoutMode.INCREMENTAL;
/** @const {number} */
yfiles.hierarchic.LayoutMode.FROM_SCRATCH;

/** @const */
yfiles.hierarchic.LayeringStrategy = {};
/** @const {number} */
yfiles.hierarchic.LayeringStrategy.HIERARCHICAL_TOPMOST;
/** @const {number} */
yfiles.hierarchic.LayeringStrategy.HIERARCHICAL_OPTIMAL;
/** @const {number} */
yfiles.hierarchic.LayeringStrategy.HIERARCHICAL_TIGHT_TREE;
/** @const {number} */
yfiles.hierarchic.LayeringStrategy.HIERARCHICAL_DOWNSHIFT;
/** @const {number} */
yfiles.hierarchic.LayeringStrategy.BFS;
/** @const {number} */
yfiles.hierarchic.LayeringStrategy.FROM_SKETCH;
/** @const {number} */
yfiles.hierarchic.LayeringStrategy.USER_DEFINED;
/** @const {number} */
yfiles.hierarchic.LayeringStrategy.UNKNOWN;

/** @const */
yfiles.hierarchic.GroupAlignmentPolicy = {};
/** @const {number} */
yfiles.hierarchic.GroupAlignmentPolicy.TOP;
/** @const {number} */
yfiles.hierarchic.GroupAlignmentPolicy.CENTER;
/** @const {number} */
yfiles.hierarchic.GroupAlignmentPolicy.BOTTOM;

/** @const */
yfiles.hierarchic.LayerType = {};
/** @const {number} */
yfiles.hierarchic.LayerType.NORMAL;
/** @const {number} */
yfiles.hierarchic.LayerType.LABEL;
/** @const {number} */
yfiles.hierarchic.LayerType.SOURCE_GROUP_NODES;
/** @const {number} */
yfiles.hierarchic.LayerType.TARGET_GROUP_NODES;
/** @const {number} */
yfiles.hierarchic.LayerType.UPPER_GROUP_CONNECTOR_NODES;
/** @const {number} */
yfiles.hierarchic.LayerType.LOWER_GROUP_CONNECTOR_NODES;

/** @const */
yfiles.hierarchic.NodeDataType = {};
/** @const {number} */
yfiles.hierarchic.NodeDataType.NORMAL;
/** @const {number} */
yfiles.hierarchic.NodeDataType.BEND;
/** @const {number} */
yfiles.hierarchic.NodeDataType.SIDE_PROXY;
/** @const {number} */
yfiles.hierarchic.NodeDataType.SAME_LAYER_SIDE_PROXY;
/** @const {number} */
yfiles.hierarchic.NodeDataType.LABEL;
/** @const {number} */
yfiles.hierarchic.NodeDataType.GROUP;
/** @const {number} */
yfiles.hierarchic.NodeDataType.SOURCE_GROUP_NODE;
/** @const {number} */
yfiles.hierarchic.NodeDataType.TARGET_GROUP_NODE;
/** @const {number} */
yfiles.hierarchic.NodeDataType.SOURCE_BACK_LOOP_PROXY;
/** @const {number} */
yfiles.hierarchic.NodeDataType.TARGET_BACK_LOOP_PROXY;
/** @const {number} */
yfiles.hierarchic.NodeDataType.SAME_LAYER_CENTER_NODE;
/** @const {number} */
yfiles.hierarchic.NodeDataType.DISTANCE_NODE;
/** @const {number} */
yfiles.hierarchic.NodeDataType.GROUP_BEGIN;
/** @const {number} */
yfiles.hierarchic.NodeDataType.GROUP_END;
/** @const {number} */
yfiles.hierarchic.NodeDataType.GROUP_LAYER_DUMMY;
/** @const {number} */
yfiles.hierarchic.NodeDataType.PROXY_FOR_EDGE_AT_GROUP;
/** @const {number} */
yfiles.hierarchic.NodeDataType.PROXY_FOR_CONTENT_EDGE_AT_GROUP;
/** @const {number} */
yfiles.hierarchic.NodeDataType.RECURSIVE_EDGE_DUMMY;

/** @const */
yfiles.hierarchic.PortAssignmentMode = {};
/** @const {number} */
yfiles.hierarchic.PortAssignmentMode.DEFAULT;
/** @const {number} */
yfiles.hierarchic.PortAssignmentMode.ON_GRID;
/** @const {number} */
yfiles.hierarchic.PortAssignmentMode.ON_SUBGRID;

/** @const */
yfiles.hierarchic.NodeLabelMode = {};
/** @const {number} */
yfiles.hierarchic.NodeLabelMode.NEVER;
/** @const {number} */
yfiles.hierarchic.NodeLabelMode.CONSIDER_FOR_SELF_LOOPS;
/** @const {number} */
yfiles.hierarchic.NodeLabelMode.CONSIDER_FOR_DRAWING;
/** @const {number} */
yfiles.hierarchic.NodeLabelMode.CONSIDER_FOR_ROUTING;

/** @const */
yfiles.hierarchic.EdgeRoutingStyle = {};
/** @const {number} */
yfiles.hierarchic.EdgeRoutingStyle.ORTHOGONAL;
/** @const {number} */
yfiles.hierarchic.EdgeRoutingStyle.OCTILINEAR;
/** @const {number} */
yfiles.hierarchic.EdgeRoutingStyle.POLYLINE;

/** @const */
yfiles.hierarchic.GroupCompactionPolicy = {};
/** @const {number} */
yfiles.hierarchic.GroupCompactionPolicy.NONE;
/** @const {number} */
yfiles.hierarchic.GroupCompactionPolicy.MAXIMAL;

/** @const */
yfiles.hierarchic.RankingPolicy = {};
/** @const {number} */
yfiles.hierarchic.RankingPolicy.NO_RERANKING;
/** @const {number} */
yfiles.hierarchic.RankingPolicy.DOWN_SHIFT;
/** @const {number} */
yfiles.hierarchic.RankingPolicy.TIGHT_TREE;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.GivenLayersLayerer = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.hierarchic.GivenLayersLayerer.LAYER_ID_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.GivenLayersLayerer.$class;

/**
 * Assigns all nodes of the graph to layers and adds them to the {\@link yfiles.hierarchic.ILayers} instance.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } instance that will be filled with the results of the calculation
 * @param {?} ldp the {\@link } used for querying information about the nodes and edges
 * @return {void}
 */
yfiles.hierarchic.GivenLayersLayerer.prototype.assignLayers = function(graph, layers, ldp) {};

/**
 * Convenience method that removes empty layers and ensures that the smallest layer has value <code>0</code>.
 * @param {!yfiles.algorithms.Graph} graph the graph
 * @param {?} layerId the {\@link } that returns an integer value (layer) for each node; the first layer has the number
 * <code>0</code>
 * @param {?} normalizedLayerId the {\@link } that will be filled by the layout algorithm and holds an integer value (layer ID
 * after normalization) for each node
 * @return {number} the number of layers after the removal of empty layers
 */
yfiles.hierarchic.GivenLayersLayerer.prototype.normalize = function(graph, layerId, normalizedLayerId) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.GivenSequenceSequencer = function() {};
 /** @type {?<!Object>} */
yfiles.hierarchic.GivenSequenceSequencer.prototype.sequenceComparer;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.GivenSequenceSequencer.$class;

/**
 * Calculates the sequence of the nodes within a {\@link yfiles.hierarchic.ILayers} instance based on the given {\@link yfiles.collections.IComparer.<T>} instance.
 * <p>
 * This method is called by {\@link yfiles.hierarchic.HierarchicLayoutCore} during the sequencing phase and finally writes back the
 * calculated sequence using the {\@link yfiles.hierarchic.ILayer#setNodeOrder} method.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance containing the elements of the layers
 * @param {?} ldp the {\@link } containing information about the nodes and edges of the graph
 * @param {?} itemFactory the {\@link } used for creating and destroying helper structures
 * @return {void}
 */
yfiles.hierarchic.GivenSequenceSequencer.prototype.sequenceNodeLayers = function(graph, layers, ldp, itemFactory) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.IVisitor = function() {};

/**
 * Visits the descendants of a group node.
 * @abstract
 * @param {!yfiles.algorithms.Node} node A descandant of the group node.
 * @param {!yfiles.algorithms.Node} parentNode A group node.
 * @return {void}
 */
yfiles.hierarchic.IVisitor.prototype.visit = function(node, parentNode) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.IVisitor;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.GroupingSupport = function() {};
 /** @type {number} */
yfiles.hierarchic.GroupingSupport.prototype.minimumGroupDistance;
 /** @type {boolean} */
yfiles.hierarchic.GroupingSupport.prototype.active;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.GroupingSupport.$class;

/**
 * Assigns edge group nodes to groups based on a given {\@link yfiles.hierarchic.ILayers} instance.
 * @see yfiles.hierarchic.NodeDataType#SOURCE_GROUP_NODE
 * @see yfiles.hierarchic.NodeDataType#TARGET_GROUP_NODE
 * @param {?} layers the given {\@link } instance containing the elements in the layering
 * @return {void}
 */
yfiles.hierarchic.GroupingSupport.prototype.assignEdgeGroupNodesToGroups = function(layers) {};

/**
 * Assigns label nodes to groups.
 * @see yfiles.hierarchic.NodeDataType#LABEL
 * @see yfiles.hierarchic.NodeDataType#BEND
 * @see yfiles.hierarchic.NodeDataType#GROUP_BEGIN
 * @see yfiles.hierarchic.NodeDataType#GROUP_END
 * @param {?} layers the given {\@link } instance containing the elements in the layering
 * @param {?} itemFactory the {\@link } used temporarily for modifying the graph instance
 * @return {void}
 */
yfiles.hierarchic.GroupingSupport.prototype.assignLabelNodesToGroups = function(layers, itemFactory) {};

/**
 * Returns the direct children of the given group node.
 * @param {!yfiles.algorithms.Node} groupNode the given group node
 * @return {!yfiles.algorithms.NodeList} a {\@link } of all direct children or <code>null</code> if {\@link } {\@link #active is not active}
 */
yfiles.hierarchic.GroupingSupport.prototype.getChildren = function(groupNode) {};

/**
 * Returns the descendant {\@link yfiles.algorithms.Node}s of the given group node.
 * <p>
 * The descendants are all direct or indirect children of a group node.
 * </p>
 * @param {!yfiles.algorithms.Node} groupNode the given group node
 * @return {!yfiles.algorithms.NodeList} a {\@link } of all descendants or <code>null</code> if {\@link } {\@link #active is not active}
 */
yfiles.hierarchic.GroupingSupport.prototype.getDescendants = function(groupNode) {};

/**
 * Returns the parent group node of the given {\@link yfiles.algorithms.Node} or <code>null</code> if the given node is a top-level node.
 * @param {!yfiles.algorithms.Node} node the given {\@link }
 * @return {!yfiles.algorithms.Node} the parent group node or <code>null</code> if the given node is a top-level node or if {\@link }
 * {\@link #active is not active}
 */
yfiles.hierarchic.GroupingSupport.prototype.getParentNode = function(node) {};

/**
 * Hides the group nodes and incident edges from the graph.
 * @return {void}
 */
yfiles.hierarchic.GroupingSupport.prototype.hideGroupNodes = function() {};

/**
 * Returns whether or not the given node is a descendant {\@link yfiles.algorithms.Node} of the given group node.
 * <p>
 * The descendants are all direct or indirect children of a group node.
 * </p>
 * @param {!yfiles.algorithms.Node} node the given node
 * @param {!yfiles.algorithms.Node} groupNode the given group node
 * @return {boolean} <code>true</code> if the given node is a descendant of the given group node, <code>false</code> otherwise
 */
yfiles.hierarchic.GroupingSupport.prototype.isDescendant = function(node, groupNode) {};

/**
 * Returns whether or not the given {\@link yfiles.algorithms.Node} is a non-empty group node.
 * @param {!yfiles.algorithms.Node} node the given {\@link }
 * @return {boolean} <code>true</code> if the given node is a non-empty group node, <code>false</code> otherwise
 */
yfiles.hierarchic.GroupingSupport.prototype.isGroupNode = function(node) {};

/**
 * Removes the current assignment of source/target edge groups from a given {\@link yfiles.hierarchic.ILayers} instance.
 * @see yfiles.hierarchic.NodeDataType#SOURCE_GROUP_NODE
 * @see yfiles.hierarchic.NodeDataType#TARGET_GROUP_NODE
 * @param {?} layers the given {\@link } instance containing the elements in the layering
 * @return {void}
 */
yfiles.hierarchic.GroupingSupport.prototype.removeEdgeGroupAssignment = function(layers) {};

/**
 * Un-hides all previously hidden group nodes and incident edges.
 * @return {void}
 */
yfiles.hierarchic.GroupingSupport.prototype.unhideGroupNodes = function() {};

/**
 * Visits all descendant {\@link yfiles.algorithms.Node}s of the given group node.
 * <p>
 * The descendants are all direct or indirect children of a group node.
 * </p>
 * @param {!yfiles.algorithms.Node} groupNode the given group node
 * @param {?} visitor a {\@link } implementation
 * @return {void}
 */
yfiles.hierarchic.GroupingSupport.prototype.visitDescendants = function(groupNode, visitor) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.HierarchicLayout = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.hierarchic.HierarchicLayout.EDGE_DIRECTEDNESS_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.hierarchic.HierarchicLayout.CRITICAL_EDGE_PRIORITY_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.hierarchic.HierarchicLayout.EDGE_THICKNESS_DP_KEY;
 /** @type {!yfiles.algorithms.GraphObjectDpKey<!Object>} */
yfiles.hierarchic.HierarchicLayout.INCREMENTAL_HINTS_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.hierarchic.HierarchicLayout.LAYER_INDEX_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.hierarchic.HierarchicLayout.SEQUENCE_INDEX_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.hierarchic.SwimlaneDescriptor>} */
yfiles.hierarchic.HierarchicLayout.SWIMLANE_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.algorithms.YRectangle>} */
yfiles.hierarchic.HierarchicLayout.ALTERNATIVE_GROUP_BOUNDS_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.algorithms.YPointPath>} */
yfiles.hierarchic.HierarchicLayout.ALTERNATIVE_EDGE_PATH_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.hierarchic.HierarchicLayout.FOLDER_NODES_DP_KEY;
 /** @type {!yfiles.algorithms.GraphDpKey<!Object>} */
yfiles.hierarchic.HierarchicLayout.SEQUENCE_CONSTRAINTS_MEMENTO_DP_KEY;
 /** @type {!yfiles.algorithms.GraphDpKey<!Object>} */
yfiles.hierarchic.HierarchicLayout.LAYER_CONSTRAINTS_MEMENTO_DP_KEY;
 /** @type {yfiles.hierarchic.GroupAlignmentPolicy} */
yfiles.hierarchic.HierarchicLayout.prototype.groupAlignmentPolicy;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.compactGroups;
 /** @type {yfiles.hierarchic.ComponentArrangementPolicy} */
yfiles.hierarchic.HierarchicLayout.prototype.componentArrangementPolicy;
 /** @type {number} */
yfiles.hierarchic.HierarchicLayout.prototype.maximumDuration;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.recursiveGroupLayering;
 /** @type {number} */
yfiles.hierarchic.HierarchicLayout.prototype.gridSpacing;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.backLoopRouting;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.backLoopRoutingForSelfLoops;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.automaticEdgeGrouping;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.orthogonalRouting;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.integratedEdgeLabeling;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.considerNodeLabels;
 /** @type {number} */
yfiles.hierarchic.HierarchicLayout.prototype.minimumLayerDistance;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.stopAfterLayering;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.stopAfterSequencing;
 /** @type {number} */
yfiles.hierarchic.HierarchicLayout.prototype.nodeToNodeDistance;
 /** @type {number} */
yfiles.hierarchic.HierarchicLayout.prototype.nodeToEdgeDistance;
 /** @type {number} */
yfiles.hierarchic.HierarchicLayout.prototype.edgeToEdgeDistance;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayout.prototype.separateLayers;
 /** @type {!yfiles.hierarchic.DefaultDrawingDistanceCalculator} */
yfiles.hierarchic.HierarchicLayout.prototype.defaultDrawingDistanceCalculator;
 /** @type {!yfiles.hierarchic.HierarchicLayoutCore} */
yfiles.hierarchic.HierarchicLayout.prototype.hierarchicLayoutCore;
 /** @type {yfiles.hierarchic.LayeringStrategy} */
yfiles.hierarchic.HierarchicLayout.prototype.fromScratchLayeringStrategy;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayout.prototype.fromScratchLayerer;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayout.prototype.fromScratchSequencer;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayout.prototype.nodePlacer;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayout.prototype.fixedElementsLayerer;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayout.prototype.fixedElementsSequencer;
 /** @type {yfiles.hierarchic.LayoutMode} */
yfiles.hierarchic.HierarchicLayout.prototype.layoutMode;
 /** @type {!yfiles.hierarchic.EdgeLayoutDescriptor} */
yfiles.hierarchic.HierarchicLayout.prototype.edgeLayoutDescriptor;
 /** @type {!yfiles.hierarchic.NodeLayoutDescriptor} */
yfiles.hierarchic.HierarchicLayout.prototype.nodeLayoutDescriptor;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.HierarchicLayout.$class;

/**
 * Configures the core layout algorithm with the settings of this {\@link yfiles.hierarchic.HierarchicLayout} instance.
 * <p>
 * This method is called by {\@link yfiles.hierarchic.HierarchicLayout#applyLayoutCore} before the actual layout is calculated. It
 * may be overridden in order to manually reconfigure the core layout algorithm.
 * </p>
 * <p>
 * This implementation will temporarily set a {\@link yfiles.hierarchic.PortCandidateOptimizer} if a {\@link yfiles.algorithms.IDataProvider}
 * is registered with {\@link yfiles.layout.PortCandidateSet#NODE_PORT_CANDIDATE_SET_DP_KEY} and no {\@link yfiles.hierarchic.HierarchicLayoutCore#portConstraintOptimizer} is assigned.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.hierarchic.HierarchicLayoutCore} coreLayouter the given core layout algorithm instance
 * @return {void}
 */
yfiles.hierarchic.HierarchicLayout.prototype.configureCoreLayout = function(graph, coreLayouter) {};

/**
 * Returns a new {\@link yfiles.hierarchic.EdgeLayoutDescriptor} instance that will be used during the various phases of the layout
 * algorithm to determine the drawing details of the edges of the graph.
 * <p>
 * This method may be overridden to create a new {\@link yfiles.hierarchic.EdgeLayoutDescriptor} instance with different
 * configuration settings.
 * </p>
 * @protected
 * @return {!yfiles.hierarchic.EdgeLayoutDescriptor} a new {\@link } instance
 */
yfiles.hierarchic.HierarchicLayout.prototype.createEdgeLayoutDescriptor = function() {};

/**
 * Returns a new {\@link yfiles.hierarchic.HierarchicLayoutCore} instance.
 * <p>
 * This method may be overridden to create a new {\@link yfiles.hierarchic.HierarchicLayoutCore} object with different configuration
 * settings.
 * </p>
 * <p>
 * This factory method provides the initial {\@link yfiles.hierarchic.HierarchicLayoutCore} instance.
 * </p>
 * @protected
 * @return {!yfiles.hierarchic.HierarchicLayoutCore} a new {\@link } instance
 */
yfiles.hierarchic.HierarchicLayout.prototype.createHierarchicLayoutCore = function() {};

/**
 * Returns a {\@link yfiles.hierarchic.IIncrementalHintsFactory} instance that must be used to obtain hints to be associated with
 * graph elements that should be laid out incrementally.
 * <p>
 * Use this factory and a {\@link yfiles.algorithms.IDataProvider} that is registered to the graph using the {\@link yfiles.hierarchic.HierarchicLayout#INCREMENTAL_HINTS_DP_KEY}
 * key to associate appropriate hints with the graph elements that should be laid out incrementally by the algorithm.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#createIncrementalHintsFactory
 * @see yfiles.hierarchic.HierarchicLayout#INCREMENTAL_HINTS_DP_KEY
 * @see yfiles.algorithms.Graph#addDataProvider
 * @see yfiles.hierarchic.HierarchicLayout#layoutMode
 * @see yfiles.hierarchic.LayoutMode#INCREMENTAL
 * @return {?} a new {\@link } instance
 */
yfiles.hierarchic.HierarchicLayout.prototype.createIncrementalHintsFactory = function() {};

/**
 * Creates and registers an incremental layer constraint factory for an {\@link yfiles.graph.IGraph}.
 * Returns a {\@link yfiles.hierarchic.ILayerConstraintFactory} instance that can be used for specifying layer constraints for the
 * given graph.
 * <p>
 * The instance is usually bound to {\@link yfiles.algorithms.Graph} instance
 * <code>graph</code>, i.e., if the input graph for the layerer changes, a new instance must be retrieved. This instance can be used for
 * creating constraints for this graph instance.
 * </p>
 * <p>
 * You can create an instance without binding it to a graph instance initially by passing a <code>null</code> parameter. In that case,
 * you <b>must</b> bind the returned instance to the graph, see {\@link yfiles.hierarchic.HierarchicLayout#LAYER_CONSTRAINTS_MEMENTO_DP_KEY}
 * and {\@link yfiles.hierarchic.ILayerConstraintFactory#memento}.
 * </p>
 * @param {?|!yfiles.algorithms.Graph} graph The graph for which the factory is created / the input graph
 * @return {?} the sequence constraint factory / a new {\@link } instance
 */
yfiles.hierarchic.HierarchicLayout.prototype.createLayerConstraintFactory = function(graph) {};

/**
 * Returns a new {\@link yfiles.hierarchic.NodeLayoutDescriptor} instance that will be used during the various phases of the layout
 * algorithm to determine the drawing details of the nodes of the graph.
 * <p>
 * This method may be overridden to create a new {\@link yfiles.hierarchic.NodeLayoutDescriptor} instance with different
 * configuration settings.
 * </p>
 * @protected
 * @return {!yfiles.hierarchic.NodeLayoutDescriptor} a new {\@link } instance
 */
yfiles.hierarchic.HierarchicLayout.prototype.createNodeLayoutDescriptor = function() {};

/**
 * Creates and registers a sequencer constraint factory for an {\@link yfiles.graph.IGraph}.
 * Returns a {\@link yfiles.hierarchic.ISequenceConstraintFactory} instance that can be used for specifying sequence constraints for
 * the given graph.
 * <p>
 * For these sequence constraints to have any effect, the {\@link yfiles.hierarchic.ISequencer} that determines the in-layer node
 * order (<em>sequence</em>) has to support constraints. Both, {\@link yfiles.hierarchic.DefaultLayerSequencer DefaultLayerSequencer} and the incremental sequencer used internally support
 * sequence constraints.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayout#fromScratchSequencer
 * @see yfiles.hierarchic.HierarchicLayout#fixedElementsSequencer
 * @param {?|!yfiles.layout.LayoutGraph} graph The graph. / the input graph
 * @return {?} the sequence constraint factory / a {\@link } instance
 */
yfiles.hierarchic.HierarchicLayout.prototype.createSequenceConstraintFactory = function(graph) {};

/**
 * Disposes of the core layout algorithm.
 * <p>
 * This method is called by {\@link yfiles.hierarchic.HierarchicLayout#applyLayoutCore} after the actual layout is calculated. It
 * may be overridden in order to revert a custom configuration made in
 * {\@link yfiles.hierarchic.HierarchicLayout#configureCoreLayout}.
 * </p>
 * <p>
 * This implementation will remove the {\@link yfiles.hierarchic.PortCandidateOptimizer} that was created in case a {\@link yfiles.algorithms.IDataProvider}
 * is registered with {\@link yfiles.layout.PortCandidateSet#NODE_PORT_CANDIDATE_SET_DP_KEY} and no {\@link yfiles.hierarchic.HierarchicLayoutCore#portConstraintOptimizer} was initially assigned.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.hierarchic.HierarchicLayoutCore} coreLayouter the given core layout algorithm instance
 * @return {void}
 */
yfiles.hierarchic.HierarchicLayout.prototype.disposeCoreLayout = function(graph, coreLayouter) {};

/**
 * Returns the mirror mask of the {\@link yfiles.layout.MultiStageLayout#orientationLayout orientation layouter}.
 * <p>
 * It may be overridden in order to configure a different mirror mask.
 * </p>
 * @protected
 * @return {yfiles.layout.MirrorModes} the mirror mask
 */
yfiles.hierarchic.HierarchicLayout.prototype.getMirrorMode = function() {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.HierarchicLayoutCore = function() {};
 /** @type {!yfiles.algorithms.GraphObjectDpKey<!Object>} */
yfiles.hierarchic.HierarchicLayoutCore.INCREMENTAL_HINTS_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.hierarchic.EdgeLayoutDescriptor>} */
yfiles.hierarchic.HierarchicLayoutCore.EDGE_LAYOUT_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.hierarchic.NodeLayoutDescriptor>} */
yfiles.hierarchic.HierarchicLayoutCore.NODE_LAYOUT_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.hierarchic.SwimlaneDescriptor>} */
yfiles.hierarchic.HierarchicLayoutCore.SWIMLANE_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.hierarchic.HierarchicLayoutCore.LAYER_INDEX_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.hierarchic.HierarchicLayoutCore.SEQUENCE_INDEX_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.hierarchic.HierarchicLayoutCore.INCREMENTAL_NODES_DP_KEY;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createLabelLayout;
 /** @type {boolean} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.componentLayoutEnabled;
 /** @type {number} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.maximumDuration;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.layerer;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.sequencer;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.nodePlacer;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.portAllocator;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.portConstraintOptimizer;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.drawingDistanceCalculator;
 /** @type {number} */
yfiles.hierarchic.HierarchicLayoutCore.prototype.gridSpacing;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.HierarchicLayoutCore.$class;

/**
 * Factory method that is called lazily upon first usage by {\@link yfiles.hierarchic.HierarchicLayoutCore#drawingDistanceCalculator} if the given {\@link yfiles.hierarchic.IDrawingDistanceCalculator}
 * instance is <code>null</code>.
 * <p>
 * The default implementation returns a {\@link yfiles.hierarchic.DefaultDrawingDistanceCalculator} instance. It may be overridden
 * to return a custom {\@link yfiles.hierarchic.DefaultDrawingDistanceCalculator} instance.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#drawingDistanceCalculator
 * @protected
 * @return {?} a {\@link } instance
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createDrawingDistanceCalculator = function() {};

/**
 * Factory method called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore} and reates an appropriate {\@link yfiles.hierarchic.IEdgeReverser}
 * implementation.
 * <p>
 * By default, a suitable private implementation of {\@link yfiles.hierarchic.IEdgeReverser} is returned. It may be overridden to
 * return a custom {\@link yfiles.hierarchic.IEdgeReverser} implementation.
 * </p>
 * @protected
 * @return {?} an implementation
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createEdgeReverser = function() {};

/**
 * Factory method that is called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore} and creates a {\@link yfiles.layout.GroupingSupport}
 * instance in case of a grouped graph.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {!yfiles.layout.GroupingSupport} a {\@link } instance or <code>null</code> if the graph is not grouped
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createGrouping = function(graph) {};

/**
 * Creates an {\@link yfiles.hierarchic.IIncrementalHintsFactory} implementation used for obtaining hint objects associated with
 * nodes and edges of the graph prior to the invocation of the layout algorithm.
 * <p>
 * Incremental hints can be obtained from a {\@link yfiles.algorithms.IDataProvider} that is registered with the graph using key
 * {\@link yfiles.hierarchic.HierarchicLayoutCore#INCREMENTAL_HINTS_DP_KEY}.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#INCREMENTAL_HINTS_DP_KEY
 * @return {?} an {\@link } instance
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createIncrementalHintsFactory = function() {};

/**
 * Factory method called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore} and creates an appropriate {\@link yfiles.hierarchic.ILayerer}
 * implementation.
 * <p>
 * By default, a {\@link yfiles.hierarchic.ConstraintIncrementalLayerer} instance with a {\@link yfiles.hierarchic.TopologicalLayerer}
 * instance as argument is returned. This method may be overridden to return a custom {\@link yfiles.hierarchic.ILayerer}
 * implementation.
 * </p>
 * @protected
 * @return {?} a {\@link } implementation
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createIncrementalLayerer = function() {};

/**
 * Callback method that is called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore}, creates the {\@link yfiles.hierarchic.INodeData}
 * and {\@link yfiles.hierarchic.IEdgeData} instances and binds them to the elements using the given {\@link yfiles.hierarchic.IItemFactory itemFactory}.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} g the input graph
 * @param {?} itemFactory the given {\@link } instance
 * @return {void}
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createItemData = function(g, itemFactory) {};

/**
 * Creates a {\@link yfiles.hierarchic.ILayerConstraintFactory layer constraint factory} that allows to create hints that affect the assignment of the nodes to layers.
 * <p>
 * By default, a suitable private implementation of {\@link yfiles.hierarchic.ILayerConstraintFactory} is returned.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {?} a {\@link } instance
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createLayerConstraintFactory = function(graph) {};

/**
 * Factory method that is called lazily upon first usage by {\@link yfiles.hierarchic.HierarchicLayoutCore#layerer} if no {\@link yfiles.hierarchic.ILayerer} instance is given as input.
 * <p>
 * The default implementation returns a <code>new MultiComponentLayerer(new WeightedLayerer())</code> instance. It may be overridden to
 * return a custom {\@link yfiles.hierarchic.ILayerer} instance.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#layerer
 * @see yfiles.hierarchic.MultiComponentLayerer
 * @see yfiles.hierarchic.WeightedLayerer
 * @protected
 * @return {?} a {\@link } instance
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createLayerer = function() {};

/**
 * Factory method called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore} and creates an appropriate {\@link yfiles.hierarchic.ILayers}
 * implementation using the given {\@link yfiles.hierarchic.ILayoutDataProvider} instance.
 * <p>
 * By default, a suitable private implementation of {\@link yfiles.hierarchic.ILayers} is returned. It may be overridden to return
 * custom implementations of the {\@link yfiles.hierarchic.ILayers} interface.
 * </p>
 * @protected
 * @param {?} ldp the given {\@link } instance
 * @return {?} a {\@link } implementation
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createLayers = function(ldp) {};

/**
 * Factory method that is called lazily upon first usage by {\@link yfiles.hierarchic.HierarchicLayoutCore#nodePlacer} if the given {\@link yfiles.hierarchic.INodePlacer} instance is <code>null</code>.
 * <p>
 * The default implementation returns a {\@link yfiles.hierarchic.SimplexNodePlacer} instance. It may be overridden to return a
 * custom {\@link yfiles.hierarchic.INodePlacer} instance.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#nodePlacer
 * @see yfiles.hierarchic.SimplexNodePlacer
 * @protected
 * @return {?} a {\@link } instance
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createNodePlacer = function() {};

/**
 * Factory method that is called lazily upon first usage by {\@link yfiles.hierarchic.HierarchicLayoutCore#portAllocator} if the given {\@link yfiles.hierarchic.IPortAllocator} instance is
 * <code>null</code>.
 * <p>
 * The default implementation returns a {\@link yfiles.hierarchic.DefaultPortAllocator} instance. It may be overridden to return a
 * custom {\@link yfiles.hierarchic.IPortAllocator} instance.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#portAllocator
 * @protected
 * @return {?} a {\@link } instance
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createPortAllocator = function() {};

/**
 * Factory method that is called lazily upon first usage by {\@link yfiles.hierarchic.HierarchicLayoutCore#portConstraintOptimizer} if the given {\@link yfiles.hierarchic.IPortConstraintOptimizer}
 * instance is <code>null</code>.
 * <p>
 * The default implementation returns <code>null</code>. It may be overridden to return a custom {\@link yfiles.hierarchic.IPortConstraintOptimizer}
 * instance.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#portConstraintOptimizer
 * @protected
 * @return {?} <code>null</code>
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createPortConstraintOptimizer = function() {};

/**
 * Creates sequence constraints that affect the sequence of the nodes within each layer.
 * <p>
 * By default, a suitable private implementation of {\@link yfiles.hierarchic.ISequenceConstraintFactory} is returned.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the given graph
 * @return {?} a {\@link } instance
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createSequenceConstraintFactory = function(graph) {};

/**
 * Factory method that is called lazily upon first usage by {\@link yfiles.hierarchic.HierarchicLayoutCore#sequencer} if the given {\@link yfiles.hierarchic.ISequencer} instance is <code>null</code>.
 * <p>
 * The default implementation returns a {\@link yfiles.hierarchic.DefaultLayerSequencer} instance. It may be overridden to return a
 * custom {\@link yfiles.hierarchic.ISequencer} instance.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#sequencer
 * @see yfiles.hierarchic.DefaultLayerSequencer
 * @protected
 * @return {?} a {\@link } instance
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createSequencer = function() {};

/**
 * Factory method called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore} and creates a {\@link yfiles.hierarchic.ISequencer}
 * implementation that can sequence subgraphs incrementally.
 * <p>
 * By default, a suitable private implementation of {\@link yfiles.hierarchic.ISequencer} is returned. It may be overridden to
 * return custom implementations of the {\@link yfiles.hierarchic.ISequencer} interface.
 * </p>
 * @protected
 * @return {?} a {\@link } implementation
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.createSubgraphLayerSequencer = function() {};

/**
 * Provides access to implementation specific properties of the algorithms used.
 * <p>
 * Used for internal purposes.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#setAlgorithmProperty
 * @param {!Object} key the key to a property
 * @return {!Object} the associated value or <code>null</code>
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.getAlgorithmProperty = function(key) {};

/**
 * Callback method called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore} and returns a {\@link yfiles.algorithms.IDataProvider}
 * that holds the {\@link yfiles.hierarchic.EdgeLayoutDescriptor} information.
 * <p>
 * The {\@link yfiles.algorithms.IDataProvider} holding the information about the node layout is registered with the graph using key
 * {\@link yfiles.hierarchic.HierarchicLayoutCore#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}.
 * </p>
 * @see yfiles.hierarchic.EdgeLayoutDescriptor
 * @see yfiles.hierarchic.HierarchicLayoutCore#EDGE_LAYOUT_DESCRIPTOR_DP_KEY
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {?} a {\@link } instance or <code>null</code>
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.getEdgeLayoutDescriptors = function(graph) {};

/**
 * Callback method called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore} and returns a {\@link yfiles.algorithms.IDataProvider}
 * that holds the incremental hints information.
 * <p>
 * The {\@link yfiles.algorithms.IDataProvider} holding the information about incremental hints is registered with the graph using
 * key {\@link yfiles.hierarchic.HierarchicLayoutCore#INCREMENTAL_HINTS_DP_KEY}.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#INCREMENTAL_HINTS_DP_KEY
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {?} a {\@link } instance or <code>null</code>
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.getIncrementalHints = function(graph) {};

/**
 * Callback method called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore} and returns a {\@link yfiles.algorithms.IDataProvider}
 * that holds the {\@link yfiles.hierarchic.NodeLayoutDescriptor} information.
 * <p>
 * The {\@link yfiles.algorithms.IDataProvider} holding the information about the node layout is registered with the graph using key
 * {\@link yfiles.hierarchic.HierarchicLayoutCore#NODE_LAYOUT_DESCRIPTOR_DP_KEY}.
 * </p>
 * @see yfiles.hierarchic.NodeLayoutDescriptor
 * @see yfiles.hierarchic.HierarchicLayoutCore#NODE_LAYOUT_DESCRIPTOR_DP_KEY
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {?} a {\@link } instance or <code>null</code>
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.getNodeLayoutDescriptors = function(graph) {};

/**
 * Callback method called during {\@link yfiles.hierarchic.HierarchicLayoutCore#applyLayoutCore} and returns a {\@link yfiles.algorithms.IDataProvider}
 * that holds the {\@link yfiles.hierarchic.SwimlaneDescriptor} information.
 * <p>
 * The {\@link yfiles.algorithms.IDataProvider} holding the information about swimlanes is registered with the graph using key
 * {\@link yfiles.hierarchic.HierarchicLayoutCore#SWIMLANE_DESCRIPTOR_DP_KEY}.
 * </p>
 * @see yfiles.hierarchic.SwimlaneDescriptor
 * @see yfiles.hierarchic.HierarchicLayoutCore#SWIMLANE_DESCRIPTOR_DP_KEY
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {?} a {\@link } instance or <code>null</code>
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.getSwimLaneDescriptors = function(graph) {};

/**
 * Callback method that publishes the layering information.
 * <p>
 * The layering information is stored in a {\@link yfiles.algorithms.IDataProvider} registered with the graph using key
 * {\@link yfiles.hierarchic.HierarchicLayoutCore#LAYER_INDEX_DP_KEY}.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#LAYER_INDEX_DP_KEY
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } implementation that provides the layering information
 * @return {void}
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.publishLayers = function(graph, layers) {};

/**
 * Callback method that publishes the sequencing information.
 * <p>
 * The sequencing information is stored in a {\@link yfiles.algorithms.IDataProvider} registered with the graph using key
 * {\@link yfiles.hierarchic.HierarchicLayoutCore#SEQUENCE_INDEX_DP_KEY}.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#LAYER_INDEX_DP_KEY
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } implementation that provides the layering information
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @return {void}
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.publishSequences = function(graph, layers, ldp) {};

/**
 * Removes the bends which are obviously not necessary.
 * <p>
 * By default, this method removes collinear bends from the graph. A bend point is considered to be collinear if it lies on
 * a line with its preceding and succeeding bend point. It may be overridden for a custom implementation of bend removal.
 * </p>
 * @protected
 * Removes the bends which are obviously not necessary.
 * <p>
 * By default, this method removes collinear bends from the graph. A bend point is considered to be collinear if it lies on
 * a line with its preceding and succeeding bend point. It may be overridden for a custom implementation of bend removal.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {number=} bendReductionThreshold this method removes a bend, if its horizontal/vertical distance to the closest collinear bend is above this value
 * @return {void}
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.reduceBendCount = function(graph, bendReductionThreshold) {};

/**
 * Provides access to implementation specific properties of the algorithms used.
 * <p>
 * Used for internal purposes.
 * </p>
 * @see yfiles.hierarchic.HierarchicLayoutCore#setAlgorithmProperty
 * @param {!Object} key the key to a property
 * @param {!Object} value the value to associate with the key
 * @return {void}
 */
yfiles.hierarchic.HierarchicLayoutCore.prototype.setAlgorithmProperty = function(key, value) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.IDrawingDistanceCalculator = function() {};

/**
 * Disposes of internal data structures.
 * <p>
 * Implementations should release internally held data structures when they are not needed any more.
 * </p>
 * @see yfiles.hierarchic.IDrawingDistanceCalculator#initialize
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph that contains all elements that are used during the node placement
 * @param {?} layers the {\@link } object that will be used during subsequent calls
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @return {void}
 */
yfiles.hierarchic.IDrawingDistanceCalculator.prototype.dispose = function(graph, layers, ldp) {};

/**
 * Main interface method called by {\@link yfiles.hierarchic.INodePlacer} instances to determine the minimum distance between
 * {\@link yfiles.algorithms.Node}s of same layer.
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layer the {\@link } object that will be used during subsequent calls
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {!yfiles.algorithms.Node} left the left of the two {\@link }s whose minimum distance is to be determined or <code>null</code> if only the left border
 * of the right {\@link } is of interest
 * @param {!yfiles.algorithms.Node} right the right of the two {\@link }s whose minimum distance is to be determined or <code>null</code> if only the right border
 * of the left {\@link } is of interest
 * @return {number} the minimum distance between two {\@link }s of the same layer
 */
yfiles.hierarchic.IDrawingDistanceCalculator.prototype.getMinDistance = function(graph, layer, ldp, left, right) {};

/**
 * Initializes internal data structures.
 * <p>
 * Implementations may cache lengthy calculations in the initialization phase.
 * </p>
 * @see yfiles.hierarchic.IDrawingDistanceCalculator#dispose
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph that contains all elements that are used during the node placement
 * @param {?} layers the {\@link } object that will be used during subsequent calls
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @return {void}
 */
yfiles.hierarchic.IDrawingDistanceCalculator.prototype.initialize = function(graph, layers, ldp) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.IDrawingDistanceCalculator;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.IEdgeData = function() {};
 /** @type {yfiles.hierarchic.EdgeDataType} */
yfiles.hierarchic.IEdgeData.prototype.type;
 /** @type {!yfiles.algorithms.Node} */
yfiles.hierarchic.IEdgeData.prototype.associatedNode;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.hierarchic.IEdgeData.prototype.associatedEdge;
 /** @type {!yfiles.layout.PortConstraint} */
yfiles.hierarchic.IEdgeData.prototype.sourcePortConstraint;
 /** @type {!Object} */
yfiles.hierarchic.IEdgeData.prototype.sourcePortGroup;
 /** @type {?<!Object>} */
yfiles.hierarchic.IEdgeData.prototype.sourcePortCandidates;
 /** @type {!yfiles.layout.PortConstraint} */
yfiles.hierarchic.IEdgeData.prototype.targetPortConstraint;
 /** @type {!Object} */
yfiles.hierarchic.IEdgeData.prototype.targetPortGroup;
 /** @type {?<!Object>} */
yfiles.hierarchic.IEdgeData.prototype.targetPortCandidates;
 /** @type {!Object} */
yfiles.hierarchic.IEdgeData.prototype.sourceGroup;
 /** @type {!Object} */
yfiles.hierarchic.IEdgeData.prototype.targetGroup;
 /** @type {!Object} */
yfiles.hierarchic.IEdgeData.prototype.group;
 /** @type {boolean} */
yfiles.hierarchic.IEdgeData.prototype.reversed;
 /** @type {boolean} */
yfiles.hierarchic.IEdgeData.prototype.upperSameLayerEdge;
 /** @type {!yfiles.hierarchic.EdgeLayoutDescriptor} */
yfiles.hierarchic.IEdgeData.prototype.edgeLayoutDescriptor;
 /** @type {boolean} */
yfiles.hierarchic.IEdgeData.prototype.fallbackUpperSameLayerEdge;
 /** @type {number} */
yfiles.hierarchic.IEdgeData.prototype.thickness;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.IEdgeData;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.IEdgeReverser = function() {};

/**
 * Reverses all edges which point to the wrong direction.
 * <p>
 * It is called after the layering phase of the {\@link yfiles.hierarchic.HierarchicLayoutCore hierarchic layout algorithm}.
 * </p>
 * <p>
 * An edge is reversed if the layer index of its source node is greater than the layer index of its target node.
 * </p>
 * @see yfiles.hierarchic.ILayoutDataProvider#getNodeData
 * @see yfiles.hierarchic.INodeData#layer
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ldp the {\@link } containing layering information about the nodes and edges of the graph
 * @return {void}
 */
yfiles.hierarchic.IEdgeReverser.prototype.normalizeEdges = function(graph, ldp) {};

/**
 * Restores the original direction of edges marked as reversed.
 * <p>
 * It is called at the end of the {\@link yfiles.hierarchic.HierarchicLayoutCore hierarchic layout algorithm}.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ldp the {\@link } containing information about the nodes and edges of the graph
 * @return {void}
 */
yfiles.hierarchic.IEdgeReverser.prototype.restoreEdgeDirections = function(graph, ldp) {};

/**
 * Reverses a given edge which points to the wrong direction.
 * <p>
 * It may be called by the incremental parts of the {\@link yfiles.hierarchic.HierarchicLayoutCore hierarchic layout algorithm}.
 * </p>
 * @see yfiles.hierarchic.ILayoutDataProvider#getNodeData
 * @see yfiles.hierarchic.INodeData#layer
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ldp the {\@link } containing layering information about the nodes and edges of the graph
 * @param {!yfiles.algorithms.Edge} edge the edge to be reversed
 * @return {void}
 */
yfiles.hierarchic.IEdgeReverser.prototype.reverse = function(graph, ldp, edge) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.IEdgeReverser;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.IIncrementalHintsFactory = function() {};

/**
 * Creates a hint {\@link Object} for a group {\@link yfiles.algorithms.Node} that should be inserted incrementally during the layering phase.
 * <p>
 * The group will be placed on a suitable position. The descendants of the group may be associated with hints created by
 * methods {\@link yfiles.hierarchic.IIncrementalHintsFactory#createLayerIncrementallyHint}, {\@link yfiles.hierarchic.IIncrementalHintsFactory#createSequenceIncrementallyHint}
 * or this method (if the descendant is an inner group).
 * </p>
 * <p>
 * All hints of the descendants of a group are interpreted relative to the group node. Descendants without hints maintain
 * their relative order within the group node (but not with elements outside the group).
 * </p>
 * <p>
 * The positions of groups without incremental hints depend on the position of their descendants (i.e., the group is not
 * interpreted as fixed - it is simply ignored).
 * </p>
 * @abstract
 * @param {!Object} forItemId the group node to be inserted incrementally
 * @return {!Object} an {\@link } that can be interpreted as a hint by {\@link }
 */
yfiles.hierarchic.IIncrementalHintsFactory.prototype.createIncrementalGroupHint = function(forItemId) {};

/**
 * Creates a hint {\@link Object} for a {\@link yfiles.algorithms.Node} that should be inserted incrementally during the layering phase.
 * <p>
 * This will place the node in a suitable layer, possibly creating new layers.
 * </p>
 * <p>
 * Neighbors of this node may be also marked such that they are laid out incrementally. This makes it possible to
 * incrementally add whole subgraphs to the current layout.
 * </p>
 * @abstract
 * @param {!Object} forNodeId the node to be layered and sequenced incrementally
 * @return {!Object} an {\@link } that can be interpreted as a hint by {\@link }
 */
yfiles.hierarchic.IIncrementalHintsFactory.prototype.createLayerIncrementallyHint = function(forNodeId) {};

/**
 * Creates a hint {\@link Object} for a {\@link yfiles.algorithms.Node} or {\@link yfiles.algorithms.Edge} that should be inserted incrementally during the
 * sequencing phase.
 * <p>
 * All nodes that are not incrementally inserted during the layering phase (see
 * {\@link yfiles.hierarchic.IIncrementalHintsFactory#createLayerIncrementallyHint}) stay in their current layer. More precisely,
 * the default {\@link yfiles.hierarchic.HierarchicLayout#fixedElementsLayerer} implementation is an instance of {\@link yfiles.hierarchic.AsIsLayerer} that determines the layer of the "fixed"
 * nodes by analyzing the current node coordinates. Note that for the other nodes, the layout algorithm may insert new
 * layers in between the existing layers.
 * </p>
 * <p>
 * For edges associated with this hint (or which are incident to an incremental node), the algorithm automatically
 * calculates a suitable sequencing (position within the layer). For edges between two non-incremental nodes that do not
 * have a hint, the sequencing phase considers the current route.
 * </p>
 * @abstract
 * @param {!Object} forItemId the node or edge to be sequenced/inserted incrementally
 * @return {!Object} an {\@link } that can be interpreted as a hint by {\@link }
 */
yfiles.hierarchic.IIncrementalHintsFactory.prototype.createSequenceIncrementallyHint = function(forItemId) {};

/**
 * Creates a hint {\@link Object} for a {\@link yfiles.algorithms.Node} that should be inserted incrementally into the graph on its exact current
 * position.
 * <p>
 * As for nodes without hints, the algorithm uses the {\@link yfiles.hierarchic.HierarchicLayout#fixedElementsLayerer} instance to determine the layer of such nodes and the {\@link yfiles.hierarchic.HierarchicLayout#fixedElementsSequencer} instance to
 * determine the position within the layer. By default, both implementations use the current coordinates of the nodes to
 * derive the layer/position. However, for nodes marked with this hint, the algorithm should also preserve the exact
 * coordinates while for nodes without hints the coordinates may be changed (these nodes only keep their relative
 * positions).
 * </p>
 * @see yfiles.hierarchic.IIncrementalHintsFactory#createUseExactSequenceCoordinatesHint
 * @see yfiles.hierarchic.IIncrementalHintsFactory#createUseExactLayerCoordinatesHint
 * @see yfiles.hierarchic.SimplexNodePlacer#exactPlacement
 * @abstract
 * @param {!Object} forNodeId the node to be placed on its exact current position
 * @return {!Object} an {\@link } that can be interpreted as a hint by {\@link }
 */
yfiles.hierarchic.IIncrementalHintsFactory.prototype.createUseExactCoordinatesHint = function(forNodeId) {};

/**
 * Creates a hint {\@link Object} for a {\@link yfiles.algorithms.Node} that should be inserted incrementally into the graph on its exact current
 * layer position.
 * <p>
 * The algorithm uses the {\@link yfiles.hierarchic.HierarchicLayout#fixedElementsLayerer} instance to determine the layer of such nodes and the {\@link yfiles.hierarchic.HierarchicLayout#fromScratchSequencer} instance to determine the sequencing.
 * </p>
 * @see yfiles.hierarchic.IIncrementalHintsFactory#createUseExactCoordinatesHint
 * @see yfiles.hierarchic.IIncrementalHintsFactory#createUseExactSequenceCoordinatesHint
 * @see yfiles.hierarchic.SimplexNodePlacer#exactPlacement
 * @abstract
 * @param {!Object} forNodeId the node to be placed on its exact current layer position
 * @return {!Object} an {\@link } that can be interpreted as a hint by {\@link }
 */
yfiles.hierarchic.IIncrementalHintsFactory.prototype.createUseExactLayerCoordinatesHint = function(forNodeId) {};

/**
 * Creates a hint {\@link Object} for a {\@link yfiles.algorithms.Node} that should be inserted incrementally into the graph on its exact current
 * sequence position.
 * <p>
 * The algorithm uses the {\@link yfiles.hierarchic.HierarchicLayout#fromScratchLayerer} instance to determine the layer of such nodes and the {\@link yfiles.hierarchic.HierarchicLayout#fixedElementsSequencer} instance to determine the sequencing.
 * </p>
 * @see yfiles.hierarchic.IIncrementalHintsFactory#createUseExactCoordinatesHint
 * @see yfiles.hierarchic.IIncrementalHintsFactory#createUseExactLayerCoordinatesHint
 * @see yfiles.hierarchic.SimplexNodePlacer#exactPlacement
 * @abstract
 * @param {!Object} forNodeId the node to be placed on its exact current sequence position
 * @return {!Object} an {\@link } that can be interpreted as a hint by {\@link }
 */
yfiles.hierarchic.IIncrementalHintsFactory.prototype.createUseExactSequenceCoordinatesHint = function(forNodeId) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.IIncrementalHintsFactory;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.IItemFactory = function() {};

/**
 * Converts a given {\@link yfiles.algorithms.Node} to a label node.
 * @abstract
 * @param {!yfiles.algorithms.Node} dummyNode the given {\@link } to be converted
 * @return {void}
 */
yfiles.hierarchic.IItemFactory.prototype.convertToLabelNode = function(dummyNode) {};

/**
 * Creates a bend {\@link yfiles.algorithms.Node} for the given {\@link yfiles.algorithms.Edge} in the given {\@link yfiles.hierarchic.ILayer} and
 * assigns it to the given {\@link yfiles.hierarchic.SwimlaneDescriptor} instance.
 * @abstract
 * @param {?} layer the given {\@link } instance
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @param {!yfiles.hierarchic.SwimlaneDescriptor=} laneDescriptor
 * @return {!yfiles.algorithms.Node} the new bend {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createBendNode = function(layer, edge, laneDescriptor) {};

/**
 * Creates a {\@link yfiles.hierarchic.INodeData} object for a bend {\@link yfiles.algorithms.Node} and associates it with the
 * {\@link yfiles.algorithms.Node}.
 * <p>
 * The bend is assigned to the given {\@link yfiles.hierarchic.SwimlaneDescriptor} instance.
 * </p>
 * @abstract
 * @param {!yfiles.algorithms.Node} node the given {\@link }
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @param {!yfiles.hierarchic.SwimlaneDescriptor=} laneDescriptor
 * @return {?} a {\@link } object for the given bend {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createBendNodeData = function(node, edge, laneDescriptor) {};

/**
 * Creates a dummy {\@link yfiles.algorithms.Node} that mimics a connector to a group {\@link yfiles.algorithms.Node}.
 * @abstract
 * @param {!yfiles.algorithms.Node} groupNode the given group {\@link }
 * @param {!Object} groupId the given group ID
 * @param {?} layer the given {\@link } instance
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @return {!yfiles.algorithms.Node} the new {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createConnectorProxyForGroup = function(groupNode, groupId, layer, edge) {};

/**
 * Creates a dummy node that mimics a connector to a group node from a descendant.
 * @abstract
 * @param {!yfiles.algorithms.Node} groupNode the group node to which the edge is connected
 * @param {!Object} groupId the id of the group node
 * @param {?} layer the layer to which the dummy node will be assigned
 * @param {!yfiles.algorithms.Edge} e the edge that connects to the dummy node
 * @return {!yfiles.algorithms.Node} the dummy node
 */
yfiles.hierarchic.IItemFactory.prototype.createContentConnectorProxyForGroup = function(groupNode, groupId, layer, e) {};

/**
 * Creates a spacer {\@link yfiles.algorithms.Node} for the drawing phase using the given bounds in the given
 * {\@link yfiles.hierarchic.ILayer}.
 * @abstract
 * @param {?} layer the given {\@link } instance
 * @param {!yfiles.algorithms.Rectangle2D} size the given bounds
 * @param {!Array<!yfiles.algorithms.Edge>} edges an array of {\@link }s
 * @return {!yfiles.algorithms.Node} the new spacer {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createDistanceNode = function(layer, size, edges) {};

/**
 * Creates a dummy {\@link yfiles.algorithms.Edge} using the given data.
 * @abstract
 * @param {!yfiles.algorithms.Node} newSource the source node of the {\@link }
 * @param {!yfiles.algorithms.Node} newTarget the target node of the {\@link }
 * @param {!yfiles.algorithms.Edge} oldEdge the old {\@link } from which to retrieve the data
 * @param {boolean} sourceEnd <code>true</code> if the source node of the edge is referred, <code>false</code> otherwise
 * @param {boolean} targetEnd <code>true</code> if the target node of the edge is referred, <code>false</code> otherwise
 * @return {!yfiles.algorithms.Edge} a new dummy {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createDummyEdge = function(newSource, newTarget, oldEdge, sourceEnd, targetEnd) {};

/**
 * Creates an edge group {\@link yfiles.algorithms.Node} in the given {\@link yfiles.hierarchic.ILayer}.
 * @abstract
 * @param {?} layer the given {\@link } instance
 * @param {!Object} groupId the ID of the edge group
 * @return {!yfiles.algorithms.Node} the new group {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createEdgeGroupNode = function(layer, groupId) {};

/**
 * Creates a {\@link yfiles.hierarchic.INodeData} object for an edge group {\@link yfiles.algorithms.Node} and associates it with the
 * {\@link yfiles.algorithms.Node}.
 * @abstract
 * @param {!yfiles.algorithms.Node} node the given {\@link }
 * @param {!Object} groupId the given group ID
 * @param {boolean} source <code>true</code> if the edge group is referred to the source node, <code>false</code> otherwise
 * @return {?} a {\@link } object for the given edge group {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createEdgeGroupNodeData = function(node, groupId, source) {};

/**
 * Creates an {\@link yfiles.algorithms.Edge} that connects two group border {\@link yfiles.algorithms.Node}s.
 * @abstract
 * @param {!yfiles.algorithms.Node} source the source {\@link }
 * @param {!yfiles.algorithms.Node} target the target {\@link }
 * @return {!yfiles.algorithms.Edge} the new {\@link } connecting the two group {\@link }s
 */
yfiles.hierarchic.IItemFactory.prototype.createGroupBorderEdge = function(source, target) {};

/**
 * Creates a group boundary {\@link yfiles.algorithms.Node} for a group node in the given {\@link yfiles.hierarchic.ILayer}.
 * @abstract
 * @param {!yfiles.algorithms.Node} groupNode the given group {\@link }
 * @param {?} layer the given {\@link }
 * @param {yfiles.hierarchic.NodeDataType} type one of {\@link #GROUP_BEGIN} or {\@link #GROUP_END}
 * @return {!yfiles.algorithms.Node} the new group boundary {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createGroupBorderNode = function(groupNode, layer, type) {};

/**
 * Create a dummy {\@link yfiles.algorithms.Node} for a group {\@link yfiles.hierarchic.ILayer layer}.
 * @abstract
 * @return {!yfiles.algorithms.Node} a new dummy {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createGroupLayerDummyNode = function() {};

/**
 * Creates a group node connector {\@link yfiles.algorithms.Edge} between two group {\@link yfiles.algorithms.Node}s.
 * @abstract
 * @param {!yfiles.algorithms.Node} groupNode1 the first group node
 * @param {!yfiles.algorithms.Node} groupNode2 the first group node
 * @param {!yfiles.algorithms.Edge} representative the given representative {\@link }
 * @return {!yfiles.algorithms.Edge} a new connector {\@link } between two group {\@link }s
 */
yfiles.hierarchic.IItemFactory.prototype.createGroupNodeConnectorEdge = function(groupNode1, groupNode2, representative) {};

/**
 * Creates an {\@link yfiles.hierarchic.IEdgeData} object for a normal {\@link yfiles.algorithms.Edge} and associates it with the edge.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @return {?} an {\@link } object for the given {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createNormalEdgeData = function(edge) {};

/**
 * Creates a {\@link yfiles.hierarchic.INodeData} object for a normal {\@link yfiles.algorithms.Node} and associates it with the
 * {\@link yfiles.algorithms.Node}.
 * @abstract
 * @param {!yfiles.algorithms.Node} node the given {\@link }
 * @return {?} a {\@link } object for the given {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createNormalNodeData = function(node) {};

/**
 * Creates a proxy {\@link yfiles.algorithms.Node} for an {\@link yfiles.algorithms.Edge} during the drawing phase, changing the {\@link yfiles.algorithms.Edge}
 * to end/start at the proxy and assigns it to a {\@link yfiles.hierarchic.SwimlaneDescriptor} instance.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @param {boolean} source <code>true</code> if the node is the source node of the edge, <code>false</code> otherwise
 * @param {!yfiles.hierarchic.SwimlaneDescriptor=} laneDescriptor
 * @return {!yfiles.algorithms.Node} the new proxy {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createProxyNode = function(edge, source, laneDescriptor) {};

/**
 * Creates a {\@link yfiles.hierarchic.INodeData} object for a proxy {\@link yfiles.algorithms.Node} and associates it with the proxy node.
 * @abstract
 * @param {!yfiles.algorithms.Node} node the given {\@link }
 * @param {!yfiles.algorithms.Node} proxy the given proxy node
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @return {?} a {\@link } object for the given proxy node
 */
yfiles.hierarchic.IItemFactory.prototype.createProxyNodeData = function(node, proxy, edge) {};

/**
 * Creates a dummy edge that belongs to a recursive {\@link yfiles.algorithms.Edge}.
 * @abstract
 * @param {!yfiles.algorithms.Node} newSource the source node of the {\@link }
 * @param {!yfiles.algorithms.Node} newTarget the target node of the {\@link }
 * @param {!yfiles.algorithms.Edge} oldEdge the old {\@link } from which to retrieve the data
 * @param {boolean} sourceEnd <code>true</code> if the source node of the edge is referred, <code>false</code> otherwise
 * @param {boolean} targetEnd <code>true</code> if the target node of the edge is referred, <code>false</code> otherwise
 * @return {!yfiles.algorithms.Edge} a new dummy {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createRecursiveDummyEdge = function(newSource, newTarget, oldEdge, sourceEnd, targetEnd) {};

/**
 * Creates a dummy {\@link yfiles.algorithms.Node} that represents a bend node of a recursive {\@link yfiles.algorithms.Edge}.
 * @abstract
 * @param {?} layer the given {\@link } to which the dummy {\@link } is assigned
 * @param {!yfiles.algorithms.Edge} edge the given {\@link } to which the dummy {\@link } belongs
 * @param {!yfiles.hierarchic.SwimlaneDescriptor} laneDescriptor the given {\@link } instance
 * @return {!yfiles.algorithms.Node} the new {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createRecursiveEdgeDummy = function(layer, edge, laneDescriptor) {};

/**
 * Creates a {\@link yfiles.hierarchic.INodeData} for a dummy {\@link yfiles.algorithms.Node} of a recursive {\@link yfiles.algorithms.Edge}.
 * @abstract
 * @param {!yfiles.algorithms.Node} node the given {\@link }
 * @param {!yfiles.algorithms.Edge} edge the given {\@link } to which the dummy {\@link } belongs
 * @param {!yfiles.hierarchic.SwimlaneDescriptor} laneDescriptor the given {\@link } instance
 * @return {?} the new {\@link } instance
 */
yfiles.hierarchic.IItemFactory.prototype.createRecursiveEdgeNodeData = function(node, edge, laneDescriptor) {};

/**
 * Creates an {\@link yfiles.hierarchic.IEdgeData} object for a same-layer recursive {\@link yfiles.algorithms.Edge} and associates it with
 * the edge.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @param {?} originalEdgeData the {\@link } object of the original edge
 * @param {boolean} isUpper <code>true</code> is the recursive edge is an upper same layer edge, <code>false</code> otherwise
 * @return {?} an {\@link } object for the recursive same-layer {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createRecursiveSameLayerEdgeData = function(edge, originalEdgeData, isUpper) {};

/**
 * Creates a redirected {\@link yfiles.algorithms.Edge} to replace an {\@link yfiles.algorithms.Edge} connected to a group
 * {\@link yfiles.algorithms.Node}.
 * @abstract
 * @param {!yfiles.algorithms.Node} newSource the source node of the {\@link }
 * @param {!yfiles.algorithms.Node} newTarget the target node of the {\@link }
 * @param {!yfiles.algorithms.Edge} groupEdge the given group {\@link }
 * @return {!yfiles.algorithms.Edge} a new redirected {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createRedirectedGroupEdge = function(newSource, newTarget, groupEdge) {};

/**
 * Creates a reversed dummy {\@link yfiles.algorithms.Edge} using the given data.
 * @abstract
 * @param {!yfiles.algorithms.Node} newSource the source node of the {\@link }
 * @param {!yfiles.algorithms.Node} newTarget the target node of the {\@link }
 * @param {!yfiles.algorithms.Edge} oldEdge the old {\@link } from which to retrieve the data
 * @param {boolean} sourceEnd <code>true</code> if the source node of the edge is referred, <code>false</code> otherwise
 * @param {boolean} targetEnd <code>true</code> if the target node of the edge is referred, <code>false</code> otherwise
 * @return {!yfiles.algorithms.Edge} a new reversed dummy {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createReverseDummyEdge = function(newSource, newTarget, oldEdge, sourceEnd, targetEnd) {};

/**
 * Creates an {\@link yfiles.hierarchic.IEdgeData} object for a same-layer {\@link yfiles.algorithms.Edge} and associates it with the edge.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @return {?} an {\@link } object for the same-layer {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createSameLayerEdgeData = function(edge) {};

/**
 * Creates a same-layer {\@link yfiles.algorithms.Edge} proxy connecting a newly created proxy {\@link yfiles.algorithms.Node} and a given
 * proxy {\@link yfiles.algorithms.Node} in the given {\@link yfiles.hierarchic.ILayer}.
 * @abstract
 * @param {?} layer the given {\@link }
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @param {!yfiles.algorithms.Node} toProxy the given proxy {\@link }
 * @return {!yfiles.algorithms.Edge} a new redefined same-layer {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createSameLayerProxy = function(layer, edge, toProxy) {};

/**
 * Creates a proxy {\@link yfiles.algorithms.Node} for a same-layer {\@link yfiles.algorithms.Edge} during the drawing phase that ends at the
 * side of a node.
 * @abstract
 * @param {?} inLayer the given {\@link } instance
 * @param {!yfiles.algorithms.Node} forNode the given {\@link }
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @param {!yfiles.hierarchic.SwimlaneDescriptor=} sld
 * @return {!yfiles.algorithms.Node} the new proxy {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createSameLayerSideProxy = function(inLayer, forNode, edge, sld) {};

/**
 * Creates a same-layer switch proxy {\@link yfiles.algorithms.Node} (switching between two same-layer
 * {\@link yfiles.algorithms.Edge}s on two different sides of the layer).
 * @abstract
 * @param {?} layer the given {\@link }
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @return {!yfiles.algorithms.Node} the new same-layer switch proxy {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createSameLayerSwitchProxy = function(layer, edge) {};

/**
 * Creates an {\@link yfiles.hierarchic.IEdgeData} object for a self-loop {\@link yfiles.algorithms.Edge} and associates it with the edge.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @return {?} an {\@link } object for a self-loop {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.createSelfLoopEdgeData = function(edge) {};

/**
 * Destroys a spacer {\@link yfiles.algorithms.Node} for the drawing phase created using
 * {\@link yfiles.hierarchic.IItemFactory#createDistanceNode}.
 * @abstract
 * @param {!yfiles.algorithms.Node} distanceNode the {\@link } to be destroyed
 * @return {void}
 */
yfiles.hierarchic.IItemFactory.prototype.destroyDistanceNode = function(distanceNode) {};

/**
 * Removes the given layer for proxies at groups to handle direct group content connector edges between a node in the
 * first/last layer of the group node and the groups border.
 * @see yfiles.hierarchic.EdgeLayoutDescriptor#directGroupContentEdgeRouting
 * @abstract
 * @param {?} layer the layer to destroy
 * @param {boolean} useInEdges whether the incoming edges should be used as the resulting edges
 * @return {void}
 */
yfiles.hierarchic.IItemFactory.prototype.destroyGroupConnectorLayer = function(layer, useInEdges) {};

/**
 * Destroys a previously created label layer
 * @abstract
 * @param {?} layer the layer to destroy
 * @param {boolean} useInEdges whether the incoming edges should be used as the resulting edges
 * @return {void}
 */
yfiles.hierarchic.IItemFactory.prototype.destroyLabelNodeLayer = function(layer, useInEdges) {};

/**
 * Destroys a proxy {\@link yfiles.algorithms.Node} created using {\@link yfiles.hierarchic.IItemFactory#createProxyNode} for the drawing
 * phase.
 * @abstract
 * @param {!yfiles.algorithms.Node} proxyNode the proxy {\@link } to be destroyed
 * @return {!yfiles.algorithms.Edge}
 */
yfiles.hierarchic.IItemFactory.prototype.destroyProxyNode = function(proxyNode) {};

/**
 * Destroys a same-layer {\@link yfiles.algorithms.Edge} proxy created using {\@link yfiles.hierarchic.IItemFactory#createSameLayerProxy}.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the {\@link } whose proxy will be destroyed
 * @return {!yfiles.algorithms.Edge} the redefined {\@link } after the removal of the proxy {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.destroySameLayerProxy = function(edge) {};

/**
 * Destroys a proxy {\@link yfiles.algorithms.Node} created using {\@link yfiles.hierarchic.IItemFactory#createProxyNode} for the drawing
 * phase.
 * @abstract
 * @param {!yfiles.algorithms.Node} proxyNode the proxy {\@link } to be destroyed
 * @return {void}
 */
yfiles.hierarchic.IItemFactory.prototype.destroySameLayerSideProxy = function(proxyNode) {};

/**
 * Destroys a same-layer switch proxy {\@link yfiles.algorithms.Node} created using
 * {\@link yfiles.hierarchic.IItemFactory#createSameLayerSwitchProxy}.
 * @abstract
 * @param {!yfiles.algorithms.Node} node the {\@link } to be destroyed
 * @return {!yfiles.algorithms.Edge} the redefined {\@link } after the removal of the same-layer switch proxy {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.destroySameLayerSwitchProxy = function(node) {};

/**
 * Inserts a same-layer {\@link yfiles.algorithms.Edge} or an {\@link yfiles.algorithms.Edge} that may span multiple layers into the data
 * structure and returns the resulting list of
 * {\@link yfiles.algorithms.Edge}s that has been created if this edge spans multiple layers.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @return {!yfiles.algorithms.EdgeList} the resulting list of {\@link }s that has been created if this edge spans multiple layers
 */
yfiles.hierarchic.IItemFactory.prototype.insertEdge = function(edge) {};

/**
 * Inserts a layer for proxies at groups to handle direct group content connector edges between a node in the first/last
 * layer of the group node and the groups border.
 * @see yfiles.hierarchic.EdgeLayoutDescriptor#directGroupContentEdgeRouting
 * @abstract
 * @param {boolean} top <code>true</code> if this layer is placed above a group nodes, <code>false</code> if placed below
 * @param {number} index the index where the layer is inserted
 * @return {?} the new layer
 */
yfiles.hierarchic.IItemFactory.prototype.insertGroupConnectorLayer = function(top, index) {};

/**
 * Inserts a {\@link yfiles.hierarchic.ILayer layer} for group {\@link yfiles.algorithms.Node}s.
 * @abstract
 * @param {boolean} source <code>true</code> if the group refers to the source node of an edge, <code>false</code> otherwise
 * @param {number} index the index at which the specified {\@link  layer} is to be inserted
 * @return {?} a {\@link  layer} instance
 */
yfiles.hierarchic.IItemFactory.prototype.insertGroupNodeLayer = function(source, index) {};

/**
 * Inserts a {\@link yfiles.hierarchic.ILayer} for labels.
 * @abstract
 * @param {boolean} source <code>true</code> if the source node of the edge, <code>false</code> otherwise
 * @param {number} index the index at which the specified {\@link } is to be inserted
 * @return {?} a {\@link  layer} instance
 */
yfiles.hierarchic.IItemFactory.prototype.insertLabelNodeLayer = function(source, index) {};

/**
 * Registers an {\@link yfiles.algorithms.Edge} as a same-layer {\@link yfiles.algorithms.Edge} appropriately into all data structures.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link } to be registered
 * @return {void}
 */
yfiles.hierarchic.IItemFactory.prototype.registerSameLayerEdge = function(edge) {};

/**
 * Converts a same-layer {\@link yfiles.algorithms.Edge} to an {\@link yfiles.algorithms.Edge} of type
 * {\@link yfiles.hierarchic.EdgeDataType#DIRECT_SAME_LAYER_EDGE}.
 * @abstract
 * @param {!yfiles.algorithms.Edge} sameLayerEdge the given same-layer {\@link }
 * @return {void}
 */
yfiles.hierarchic.IItemFactory.prototype.setDirectlyConnectSameLayerEdge = function(sameLayerEdge) {};

/**
 * Specifies an edge group constraint for an {\@link yfiles.algorithms.Edge} and assigns it to an {\@link yfiles.hierarchic.IEdgeData}
 * object.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @param {!Object} sgId the ID of the edge group at the source node
 * @param {!Object} tgId the ID of the edge group at the target node
 * @return {?} an {\@link } object
 */
yfiles.hierarchic.IItemFactory.prototype.setTemporaryEdgeGroups = function(edge, sgId, tgId) {};

/**
 * Specifies the thickness for an {\@link yfiles.algorithms.Edge} and defines it in an {\@link yfiles.hierarchic.IEdgeData} object.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @param {number} thickness the new edge thickness
 * @return {?} an {\@link } object with an adjusted {\@link }
 */
yfiles.hierarchic.IItemFactory.prototype.setTemporaryEdgeThickness = function(edge, thickness) {};

/**
 * Specifies a port constraint for an {\@link yfiles.algorithms.Edge} at the given side and assigns it to an {\@link yfiles.hierarchic.IEdgeData}
 * object.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given {\@link }
 * @param {boolean} source <code>true</code> of the port constraint is defined on the source node of the {\@link }, <code>false</code> otherwise
 * @param {!yfiles.layout.PortConstraint} pc the given {\@link } instance
 * @return {?} an {\@link } object
 */
yfiles.hierarchic.IItemFactory.prototype.setTemporaryPortConstraint = function(edge, source, pc) {};

/**
 * Reverts a label node to the normal {\@link yfiles.algorithms.Node}.
 * @abstract
 * @param {!yfiles.algorithms.Node} labelNode the given label node to be converted
 * @return {void}
 */
yfiles.hierarchic.IItemFactory.prototype.unconvertToLabelNode = function(labelNode) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.IItemFactory;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ILayer = function() {};
 /** @type {!yfiles.algorithms.YList} */
yfiles.hierarchic.ILayer.prototype.sameLayerEdges;
 /** @type {!yfiles.algorithms.NodeList} */
yfiles.hierarchic.ILayer.prototype.list;
 /** @type {yfiles.hierarchic.LayerType} */
yfiles.hierarchic.ILayer.prototype.type;
 /** @type {number} */
yfiles.hierarchic.ILayer.prototype.index;
 /** @type {!yfiles.layout.RowDescriptor} */
yfiles.hierarchic.ILayer.prototype.row;

/**
 * Adds a newly created {\@link yfiles.algorithms.Node} to this {\@link yfiles.hierarchic.ILayer} instance.
 * @abstract
 * @param {!yfiles.algorithms.Node} node the {\@link } to be added
 * @return {void}
 */
yfiles.hierarchic.ILayer.prototype.add = function(node) {};

/**
 * Adds a same-layer {\@link yfiles.algorithms.Edge} to this {\@link yfiles.hierarchic.ILayer} instance.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the same-layer {\@link } to be added
 * @return {void}
 */
yfiles.hierarchic.ILayer.prototype.addSameLayerEdge = function(edge) {};

/**
 * Removes a {\@link yfiles.algorithms.Node} from this {\@link yfiles.hierarchic.ILayer} instance.
 * @abstract
 * Removes the current layer from the {\@link yfiles.hierarchic.ILayers list of layers}.
 * @abstract
 * @param {!yfiles.algorithms.Node=} node the {\@link } to be removed
 * @return {void}
 */
yfiles.hierarchic.ILayer.prototype.remove = function(node) {};

/**
 * Adjusts the order of the {\@link yfiles.algorithms.Node}s of this {\@link yfiles.hierarchic.ILayer} instance according to the given
 * order.
 * @abstract
 * @param {!yfiles.algorithms.YList} list the given list to be used
 * @return {void}
 */
yfiles.hierarchic.ILayer.prototype.setNodeOrder = function(list) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.ILayer;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ILayeredComponentsMerger = function() {};

/**
 * Merges two {\@link yfiles.hierarchic.ILayers} instances.
 * <p>
 * All nodes that belong to the source and target {\@link yfiles.hierarchic.ILayers} are part of the graph at the moment of
 * invocation.
 * </p>
 * <p>
 * The state of the source {\@link yfiles.hierarchic.ILayers} instance is discarded after this call and does not need to be updated
 * to reflect the changes. The target {\@link yfiles.hierarchic.ILayers} instance must be updated accordingly.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the graph containing the nodes of source and target {\@link } instances
 * @param {?} ldp the {\@link } used for querying the layer indices
 * @param {?} srcLayers the source {\@link } instance that will be merged into the target {\@link } instance
 * @param {?} targetLayers the {\@link } instance that will be modified to contain the resulting layering
 * @return {void}
 */
yfiles.hierarchic.ILayeredComponentsMerger.prototype.merge = function(graph, ldp, srcLayers, targetLayers) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.ILayeredComponentsMerger;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ILayerer = function() {};

/**
 * Assigns all nodes of the graph to layers and adds them to the {\@link yfiles.hierarchic.ILayers} instance.
 * <p>
 * In order to create new layers, factory method {\@link yfiles.hierarchic.ILayers#insert} has to be used.
 * </p>
 * <p>
 * Information about the nodes is provided by a {\@link yfiles.hierarchic.ILayoutDataProvider}. However, positional information (see
 * {\@link yfiles.hierarchic.INodeData#position} and {\@link yfiles.hierarchic.INodeData#layer}) is not available during this phase.
 * </p>
 * @see yfiles.hierarchic.ILayers#insert
 * @see yfiles.hierarchic.ILayer#add
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } instance that will be filled with the results of the calculation
 * @param {?} ldp the {\@link } used for querying information about the nodes and edges
 * @return {void}
 */
yfiles.hierarchic.ILayerer.prototype.assignLayers = function(graph, layers, ldp) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.ILayerer;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ILayers = function() {};

/**
 * Creates a new and empty {\@link yfiles.hierarchic.ILayers} instance that can be used on the same graph instance for temporary
 * results.
 * @abstract
 * @return {?} a new and empty {\@link } instance
 */
yfiles.hierarchic.ILayers.prototype.createInstance = function() {};

/**
 * Returns the {\@link yfiles.hierarchic.ILayer layer} at the specified position in this {\@link yfiles.hierarchic.ILayers list of layers}.
 * @abstract
 * @param {number} i the zero-based index of the {\@link  layer} to return
 * @return {?} the {\@link  layer} at the specified position
 */
yfiles.hierarchic.ILayers.prototype.getLayer = function(i) {};

/**
 * Creates, inserts and returns a {\@link yfiles.hierarchic.ILayer layer} of a given type associated with this {\@link yfiles.hierarchic.ILayers list of layers}.
 * @abstract
 * @param {yfiles.hierarchic.LayerType} type one of the predefined layer types as defined in {\@link } interface
 * @param {number} position the index at which the specified {\@link  layer} is to be inserted
 * @return {?} a new {\@link } instance
 */
yfiles.hierarchic.ILayers.prototype.insert = function(type, position) {};

/**
 * Removes the {\@link yfiles.hierarchic.ILayer layer} at the specified position from this {\@link yfiles.hierarchic.ILayers list of layers}.
 * @abstract
 * @param {number} index the zero-based index of the {\@link  layer} to remove
 * @return {void}
 */
yfiles.hierarchic.ILayers.prototype.remove = function(index) {};

/**
 * Returns the number of {\@link yfiles.hierarchic.ILayer layers} associated with this {\@link yfiles.hierarchic.ILayers} instance.
 * @abstract
 * @return {number} the number of layers of this {\@link } instance
 */
yfiles.hierarchic.ILayers.prototype.size = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.ILayers;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ILayoutDataProvider = function() {};

/**
 * Returns the {\@link yfiles.hierarchic.IEdgeData} instance associated with the given {\@link yfiles.algorithms.Edge}.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @return {?} the {\@link } instance associated with the edge
 */
yfiles.hierarchic.ILayoutDataProvider.prototype.getEdgeData = function(edge) {};

/**
 * Returns the {\@link yfiles.hierarchic.INodeData} instance associated with the given {\@link yfiles.algorithms.Node}.
 * @abstract
 * @param {!yfiles.algorithms.Node} node the given node
 * @return {?} the {\@link } instance associated with the node
 */
yfiles.hierarchic.ILayoutDataProvider.prototype.getNodeData = function(node) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.ILayoutDataProvider;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.INodeData = function() {};
 /** @type {!yfiles.algorithms.Node} */
yfiles.hierarchic.INodeData.prototype.groupNode;
 /** @type {!yfiles.algorithms.ListCell} */
yfiles.hierarchic.INodeData.prototype.firstSameLayerEdgeCell;
 /** @type {yfiles.hierarchic.NodeDataType} */
yfiles.hierarchic.INodeData.prototype.type;
 /** @type {!Object} */
yfiles.hierarchic.INodeData.prototype.groupId;
 /** @type {!yfiles.algorithms.Node} */
yfiles.hierarchic.INodeData.prototype.associatedNode;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.hierarchic.INodeData.prototype.associatedEdge;
 /** @type {number} */
yfiles.hierarchic.INodeData.prototype.layer;
 /** @type {number} */
yfiles.hierarchic.INodeData.prototype.position;
 /** @type {!yfiles.algorithms.Node} */
yfiles.hierarchic.INodeData.prototype.parentGroupNode;
 /** @type {?} */
yfiles.hierarchic.INodeData.prototype.groupLayers;
 /** @type {!Object} */
yfiles.hierarchic.INodeData.prototype.incrementalHint;
 /** @type {!yfiles.hierarchic.NodeLayoutDescriptor} */
yfiles.hierarchic.INodeData.prototype.nodeLayoutDescriptor;
 /** @type {!yfiles.hierarchic.SwimlaneDescriptor} */
yfiles.hierarchic.INodeData.prototype.swimLaneDescriptor;

/**
 * Creates, stores and returns a {\@link yfiles.algorithms.BorderLine} for the given side or returns the current {\@link yfiles.algorithms.BorderLine}
 * instance if it already exists.
 * <p>
 * Not every {\@link yfiles.hierarchic.INodeData#type type} of node supports this operation. {\@link yfiles.hierarchic.NodeDataType#NORMAL} supports
 * {\@link yfiles.algorithms.BorderLine}s.
 * </p>
 * <p>
 * Side value must be inside <code>[0,3]</code> interval, where <code>0</code> corresponds to the top side, <code>1</code> to the right side, <code>2</code> to the bottom side
 * and <code>3</code> to the left side.
 * </p>
 * @throws {Stubs.Exceptions.NotSupportedError} if this {\@link yfiles.hierarchic.INodeData#type type} of node does not support node borders
 * @see yfiles.hierarchic.INodeData#getNormalizedBorderLine
 * @abstract
 * @param {number} side an integer value from <code>[0,3]</code> interval
 * @param {?} nodeLayout the {\@link } of the current node
 * @return {!yfiles.algorithms.BorderLine} a {\@link } instance
 */
yfiles.hierarchic.INodeData.prototype.createBorderLine = function(side, nodeLayout) {};

/**
 * Returns a {\@link yfiles.algorithms.BorderLine} for the given side which is treated as if the position of the node is at (0,0).
 * <p>
 * Clients may modify this instance but should always reset it to the original position, since this is a shared instance.
 * </p>
 * <p>
 * It may return <code>null</code> to indicate that the {\@link yfiles.algorithms.BorderLine} can be determined through the {\@link yfiles.layout.INodeLayout}
 * instance.
 * </p>
 * <p>
 * Side value must be inside <code>[0,3]</code> interval, where <code>0</code> corresponds to the top side, <code>1</code> to the right side, <code>2</code> to the bottom side
 * and <code>3</code> to the left side.
 * </p>
 * @see yfiles.hierarchic.INodeData#createBorderLine
 * @abstract
 * @param {number} side an integer value from <code>[0,3]</code> interval
 * @return {!yfiles.algorithms.BorderLine} a {\@link } instance or <code>null</code>
 */
yfiles.hierarchic.INodeData.prototype.getNormalizedBorderLine = function(side) {};

/**
 * Returns the number of same-layer edges associated with the {\@link yfiles.algorithms.Node} of this {\@link yfiles.hierarchic.INodeData}
 * instance.
 * @abstract
 * @return {number} the number of same-layer edges associated with the node
 */
yfiles.hierarchic.INodeData.prototype.sameLayerEdgeCount = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.INodeData;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.INodePlacer = function() {};

/**
 * Assigns preliminary y-coordinates for each layer of a hierarchic layout.
 * <p>
 * The distance between two layers will be adjusted later by the edge routing algorithm. This method is responsible for
 * assigning the relative positions of the nodes within each layer.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layoutDataProvider the {\@link } containing information about the elements
 * @param {?} layers the {\@link } instance that will be calculated by this method
 * @return {void}
 */
yfiles.hierarchic.INodePlacer.prototype.assignLayerCoordinates = function(graph, layoutDataProvider, layers) {};

/**
 * Determines the resulting x-coordinates of a hierarchic layout.
 * <p>
 * The minimum distance between each pair of nodes of the graph is determined by a {\@link yfiles.hierarchic.IDrawingDistanceCalculator}
 * instance.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layoutDataProvider the {\@link } containing information about the elements
 * @param {?} layers the {\@link } instance that will be calculated by this method
 * @param {?} drawingDistanceCalculator the given {\@link } instance
 * @return {void}
 */
yfiles.hierarchic.INodePlacer.prototype.assignSequenceCoordinates = function(graph, layoutDataProvider, layers, drawingDistanceCalculator) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.INodePlacer;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.IPortAllocator = function() {};

/**
 * Assigns to each edge of the graph a source port and target port coordinate pair.
 * <p>
 * This method is called by {\@link yfiles.hierarchic.HierarchicLayoutCore} after the sequencing phase.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance containing the elements in the layering
 * @param {?} ldp the {\@link } containing layering information about the nodes and edges of the graph
 * @param {?} itemFactory the {\@link } used temporarily for modifying the graph instance
 * @return {void}
 */
yfiles.hierarchic.IPortAllocator.prototype.assignPorts = function(graph, layers, ldp, itemFactory) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.IPortAllocator;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.IPortConstraintOptimizer = function() {};

/**
 * Assigns new temporary port constraints after the layering information has been determined.
 * @see yfiles.hierarchic.IItemFactory#setTemporaryPortConstraint
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance
 * @param {?} ldp the {\@link } containing information about the elements
 * @param {?} itemFactory the {\@link } to set the temporary port constraints with
 * @return {void}
 */
yfiles.hierarchic.IPortConstraintOptimizer.prototype.optimizeAfterLayering = function(graph, layers, ldp, itemFactory) {};

/**
 * Assigns new temporary port constraints after the sequence of the nodes has been determined.
 * @see yfiles.hierarchic.IItemFactory#setTemporaryPortConstraint
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance
 * @param {?} ldp the {\@link } containing information about the elements
 * @param {?} itemFactory the {\@link } to set the temporary port constraints with
 * @return {void}
 */
yfiles.hierarchic.IPortConstraintOptimizer.prototype.optimizeAfterSequencing = function(graph, layers, ldp, itemFactory) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.IPortConstraintOptimizer;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.ISequencer = function() {};

/**
 * Calculates the sequence of the nodes within each {\@link yfiles.hierarchic.ILayers layer}.
 * <p>
 * This method is called by {\@link yfiles.hierarchic.HierarchicLayoutCore} during the second phase and finally writes back the
 * calculated sequence using the {\@link yfiles.hierarchic.ILayer#setNodeOrder} method.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance containing the elements in the layering
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {?} itemFactory the {\@link } used temporarily for modifying the graph instance
 * @return {void}
 */
yfiles.hierarchic.ISequencer.prototype.sequenceNodeLayers = function(graph, layers, ldp, itemFactory) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.hierarchic.ISequencer;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.MultiComponentLayerer = function() {};
 /** @type {?} */
yfiles.hierarchic.MultiComponentLayerer.prototype.singleComponentLayerer;
 /** @type {?} */
yfiles.hierarchic.MultiComponentLayerer.prototype.merger;
 /** @type {?<!Object>} */
yfiles.hierarchic.MultiComponentLayerer.prototype.componentComparer;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.MultiComponentLayerer.$class;

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} layers
 * @param {?} ldp
 * @return {void}
 */
yfiles.hierarchic.MultiComponentLayerer.prototype.assignLayers = function(graph, layers, ldp) {};

/**
 * Sorts an array which consists of
 * {\@link yfiles.algorithms.NodeList}s each of which contains nodes that belong to the same component.
 * <p>
 * It is called during {\@link yfiles.hierarchic.MultiComponentLayerer#assignLayers}.
 * </p>
 * <p>
 * By default this method uses the {\@link yfiles.hierarchic.MultiComponentLayerer#componentComparer ComponentComparator} to sort the list and has no effect if the instance is <code>null</code>.
 * </p>
 * @protected
 * @param {!Array<!yfiles.algorithms.NodeList>} nodeLists the array of {\@link }s each of which containing nodes that belong to the same component
 * @param {?} componentIndexProvider the {\@link } that returns an object (the component index) for each node (this value can be either
 * integer or object)
 * @return {void}
 */
yfiles.hierarchic.MultiComponentLayerer.prototype.sort = function(nodeLists, componentIndexProvider) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.NodeLayoutDescriptor = function() {};
 /** @type {number} */
yfiles.hierarchic.NodeLayoutDescriptor.prototype.portBorderGapRatios;
 /** @type {number} */
yfiles.hierarchic.NodeLayoutDescriptor.prototype.layerAlignment;
 /** @type {yfiles.hierarchic.NodeLabelMode} */
yfiles.hierarchic.NodeLayoutDescriptor.prototype.nodeLabelMode;
 /** @type {number} */
yfiles.hierarchic.NodeLayoutDescriptor.prototype.minimumLayerHeight;
 /** @type {number} */
yfiles.hierarchic.NodeLayoutDescriptor.prototype.minimumDistance;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.hierarchic.NodeLayoutDescriptor.prototype.gridReference;
 /** @type {yfiles.hierarchic.PortAssignmentMode} */
yfiles.hierarchic.NodeLayoutDescriptor.prototype.portAssignment;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.NodeLayoutDescriptor.$class;

/**
 * Returns the port border gap ratio for the port distribution at a given side of the node.
 * <p>
 * This ratio determines the gap between a corner of the node and the first assigned port.
 * </p>
 * <p>
 * The ratio should be greater than <code>0</code>.
 * </p>
 * <p>
 * A value of <code>0.0d</code> results in ports being placed directly on the corner of the node (if there is more than one port).
 * </p>
 * <p>
 * A value of <code>0.5d</code> results in ports being distributed along the side of the node so that the distance between the corner of
 * the node and the first port is half as wide as the distance between two adjacent ports.
 * </p>
 * <p>
 * A value of <code>Double.POSITIVE_INFINITY</code> results in all ports being centered at the side in one point.
 * </p>
 * @see yfiles.hierarchic.NodeLayoutDescriptor#portBorderGapRatios
 * @see yfiles.hierarchic.NodeLayoutDescriptor#setPortBorderGapRatio
 * @param {number} side the zero-based clockwise side index for top-to-bottom layouts (i.e., top is 0)
 * @return {number} the border gap ratio of a given side
 */
yfiles.hierarchic.NodeLayoutDescriptor.prototype.getPortBorderGapRatio = function(side) {};

/**
 * Specifies the port border gap ratio for the port distribution at a given side of the node.
 * <p>
 * This ratio determines the gap between a corner of the node and the first assigned port.
 * </p>
 * <p>
 * The ratio should be greater than <code>0</code>.
 * </p>
 * <p>
 * A value of <code>0.0d</code> results in ports being placed directly on the corner of the node (if there is more than one port).
 * </p>
 * <p>
 * A value of <code>0.5d</code> results in ports being distributed along the side of the node so that the distance between the corner of
 * the node and the first port is half as wide as the distance between two adjacent ports.
 * </p>
 * <p>
 * A value of <code>Double.POSITIVE_INFINITY</code> results in all ports being centered at the side in one point.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given ratio is negative
 * @see yfiles.hierarchic.NodeLayoutDescriptor#portBorderGapRatios
 * @param {number} side the zero-based clockwise side index for top-to-bottom layouts (i.e., top is 0)
 * @param {number} ratio the given ratio
 * @return {void}
 */
yfiles.hierarchic.NodeLayoutDescriptor.prototype.setPortBorderGapRatio = function(side, ratio) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.PartitionGridLayoutStage = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.PartitionGridLayoutStage.$class;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.PortCandidateOptimizer = function() {};
 /** @type {boolean} */
yfiles.hierarchic.PortCandidateOptimizer.prototype.deterministic;
 /** @type {number} */
yfiles.hierarchic.PortCandidateOptimizer.prototype.backLoopPenalty;
 /** @type {number} */
yfiles.hierarchic.PortCandidateOptimizer.prototype.crossingPenalty;
 /** @type {number} */
yfiles.hierarchic.PortCandidateOptimizer.prototype.overUsagePenalty;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.PortCandidateOptimizer.$class;

/**
 * Returns the data provider that provides the port candidate sets for nodes.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph The graph that stores the data provider
 * @return {?}
 */
yfiles.hierarchic.PortCandidateOptimizer.prototype.getPortCandidateSetDataProvider = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.PortConstraintOptimizerSameLayerData = function() {};
 /** @type {!yfiles.algorithms.NodeList} */
yfiles.hierarchic.PortConstraintOptimizerSameLayerData.prototype.dummyNodes;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.PortConstraintOptimizerSameLayerData.$class;

/**
 * Adds a given dummy {\@link yfiles.algorithms.Node} to this {\@link yfiles.hierarchic.PortConstraintOptimizerSameLayerData} instance and
 * associates it with the given original (same-layer) {\@link yfiles.algorithms.Edge}.
 * @param {!yfiles.algorithms.Node} sameLayerDummy a dummy node
 * @param {!yfiles.algorithms.Edge} originalEdge the original (same-layer) edge
 * @return {void}
 */
yfiles.hierarchic.PortConstraintOptimizerSameLayerData.prototype.addDummyNode = function(sameLayerDummy, originalEdge) {};

/**
 * Returns the original (same-layer) edge associated with the given dummy {\@link yfiles.algorithms.Node}.
 * @param {!yfiles.algorithms.Node} sameLayerDummy a given dummy node
 * @return {!yfiles.algorithms.Edge} the original (same-layer) edge associated with the given dummy node
 */
yfiles.hierarchic.PortConstraintOptimizerSameLayerData.prototype.getOriginalEdge = function(sameLayerDummy) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.PortConstraintOptimizerBase = function() {};
 /** @type {yfiles.layout.MirrorModes} */
yfiles.hierarchic.PortConstraintOptimizerBase.prototype.mirrorMode;
 /** @type {yfiles.layout.LayoutOrientation} */
yfiles.hierarchic.PortConstraintOptimizerBase.prototype.layoutOrientation;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.PortConstraintOptimizerBase.$class;

/**
 * Inserts a same-layer edge structure for each same-layer edge of the original graph.
 * @see yfiles.hierarchic.IItemFactory#setTemporaryPortConstraint
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance holding the layering information
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {?} itemFactory the {\@link  factory} that sets the temporary port constraints
 * @return {!yfiles.hierarchic.PortConstraintOptimizerSameLayerData}
 */
yfiles.hierarchic.PortConstraintOptimizerBase.prototype.insertSameLayerStructures = function(graph, layers, ldp, itemFactory) {};

/**
 * Assigns new temporary port constraints after the nodes have been assigned to layers.
 * <p>
 * More precisely, it is called after the layering information has been determined. In this phase, it is possible to create
 * back-loops by assigning incoming edges to the south (i.e. bottom) side or outgoing edges to the north (i.e. top) side,
 * respectively.
 * </p>
 * @see yfiles.hierarchic.IItemFactory#setTemporaryPortConstraint
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance holding the layering information
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {?} itemFactory the {\@link  factory} that sets the temporary port constraints
 * @return {void}
 */
yfiles.hierarchic.PortConstraintOptimizerBase.prototype.optimizeAfterLayering = function(graph, layers, ldp, itemFactory) {};

/**
 * Assigns new temporary port constraints after the order of the nodes in each layer has been determined.
 * <p>
 * More precisely, it is called after the sequence of the nodes has been determined. It {\@link yfiles.hierarchic.PortConstraintOptimizerBase#insertSameLayerStructures inserts the same-layer structures},
 * invokes {\@link yfiles.hierarchic.PortConstraintOptimizerBase#optimizeAfterSequencingForSingleNode the hook} in which the custom port assignment should be done, and finally {\@link yfiles.hierarchic.PortConstraintOptimizerBase#removeSameLayerStructures restores the original state} of the
 * layout graph by removing the temporary edges.
 * </p>
 * @see yfiles.hierarchic.PortConstraintOptimizerBase#insertSameLayerStructures
 * @see yfiles.hierarchic.PortConstraintOptimizerBase#optimizeAfterSequencing
 * @see yfiles.hierarchic.PortConstraintOptimizerBase#removeSameLayerStructures
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the given {\@link } instance holding the layering information
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {?} itemFactory the {\@link  factory} that sets the temporary port constraints
 * @return {void}
 */
yfiles.hierarchic.PortConstraintOptimizerBase.prototype.optimizeAfterSequencing = function(graph, layers, ldp, itemFactory) {};

/**
 * Assigns new temporary port constraints after the order of the nodes in each layer has been determined.
 * <p>
 * More precisely, it is called after the sequence of the nodes has been determined. It invokes {\@link yfiles.hierarchic.PortConstraintOptimizerBase#optimizeAfterSequencingForSingleNode}
 * for every node of the original layout graph and omits the nodes of the same-layer structures.
 * </p>
 * <p>
 * Incoming and outgoing edges are sorted using {\@link yfiles.collections.IComparer.<T>} instances which define the preferred ordering of the incoming and outgoing
 * edges from left to right.
 * </p>
 * @see yfiles.hierarchic.PortConstraintOptimizerBase#optimizeAfterSequencing
 * @protected
 * @param {?<!Object>} inEdgeOrder a given {\@link } instance for incoming edges
 * @param {?<!Object>} outEdgeOrder a given {\@link } instance for outgoing edges
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {?} itemFactory the {\@link  factory} that sets the temporary port constraints
 * @return {void}
 */
yfiles.hierarchic.PortConstraintOptimizerBase.prototype.optimizeAfterSequencingForAllNodes = function(inEdgeOrder, outEdgeOrder, graph, layers, ldp, itemFactory) {};

/**
 * Assigns new temporary port constraints to a given node of the graph after the order of the nodes in each layer has been
 * determined.
 * <p>
 * More precisely, it is called after the sequence of the nodes has been determined.
 * </p>
 * <p>
 * Incoming and outgoing edges are sorted using {\@link yfiles.collections.IComparer.<T>} instances which define the preferred ordering of the incoming and outgoing
 * edges from left to right.
 * </p>
 * @see yfiles.hierarchic.PortConstraintOptimizerBase#optimizeAfterSequencing
 * @protected
 * @abstract
 * @param {!yfiles.algorithms.Node} node the original node to set temporary port constraints
 * @param {?<!Object>} inEdgeOrder a given {\@link } instance for incoming edges
 * @param {?<!Object>} outEdgeOrder a given {\@link } instance for outgoing edges
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {?} itemFactory the {\@link  factory} that sets the temporary port constraints
 * @return {void}
 */
yfiles.hierarchic.PortConstraintOptimizerBase.prototype.optimizeAfterSequencingForSingleNode = function(node, inEdgeOrder, outEdgeOrder, graph, ldp, itemFactory) {};

/**
 * Removes the same-layer edge structure created using
 * {\@link yfiles.hierarchic.PortConstraintOptimizerBase#insertSameLayerStructures}.
 * @see yfiles.hierarchic.IItemFactory#setTemporaryPortConstraint
 * @protected
 * @param {!yfiles.hierarchic.PortConstraintOptimizerSameLayerData} sameLayerData a given {\@link } instance holding the information about the same-layer
 * structures.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {?} itemFactory the {\@link  factory} that sets the temporary port constraints
 * @return {void}
 */
yfiles.hierarchic.PortConstraintOptimizerBase.prototype.removeSameLayerStructures = function(sameLayerData, graph, ldp, itemFactory) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.RoutingStyle = function() {};
 /** @type {yfiles.hierarchic.EdgeRoutingStyle} */
yfiles.hierarchic.RoutingStyle.prototype.backLoopRoutingStyle;
 /** @type {yfiles.hierarchic.EdgeRoutingStyle} */
yfiles.hierarchic.RoutingStyle.prototype.edgeGroupRoutingStyle;
 /** @type {yfiles.hierarchic.EdgeRoutingStyle} */
yfiles.hierarchic.RoutingStyle.prototype.defaultEdgeRoutingStyle;
 /** @type {yfiles.hierarchic.EdgeRoutingStyle} */
yfiles.hierarchic.RoutingStyle.prototype.sameLayerEdgeRoutingStyle;
 /** @type {yfiles.hierarchic.EdgeRoutingStyle} */
yfiles.hierarchic.RoutingStyle.prototype.selfLoopRoutingStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.RoutingStyle.$class;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.SelfLoopCalculator = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.hierarchic.SelfLoopCalculator.MINIMUM_NODE_DISTANCE_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.hierarchic.SelfLoopCalculator.OCTILINEAR_EDGES_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.hierarchic.SelfLoopCalculator.MINIMUM_OCTILINEAR_SEGMENT_LENGTH_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.hierarchic.SelfLoopCalculator.MINIMUM_FIRST_SEGMENT_LENGTH_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.hierarchic.SelfLoopCalculator.MINIMUM_LAST_SEGMENT_LENGTH_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.hierarchic.SelfLoopCalculator.MINIMUM_EDGE_DISTANCE_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.SelfLoopCalculator.$class;

/**
 * Convenience method that calculates a list of self-loops that belong to a given node.
 * <p>
 * The current port positions will be used for determining the start and end ports. The {\@link yfiles.algorithms.IDataProvider}
 * instances hold information about the source/target ports of the edges and can be used for specifying the direction of
 * first and last segments.
 * </p>
 * Calculates all self-loops at the given node of the given input graph.
 * <p>
 * The current port positions will be used for determining the start and end ports. The {\@link yfiles.algorithms.IDataProvider}
 * instances hold information about the source/target ports of the edges and can be used for specifying the direction of
 * first and last segments.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} node the node whose self-loops will be routed
 * @param {!yfiles.algorithms.YList|?} selfLoops_or_spc a list of {\@link }s that will be routed / the {\@link } that returns the {\@link } object associated with the source
 * ports of the edges
 * @param {?} spc_or_tpc the {\@link } that returns the {\@link } object associated with the source
 * ports of the edges / the {\@link } that returns the {\@link } object associated with the target
 * ports of the edges
 * @param {?=} tpc the {\@link } that returns the {\@link } object associated with the target
 * ports of the edges
 * @return {void}
 */
yfiles.hierarchic.SelfLoopCalculator.prototype.calculateSelfLoops = function(graph, node, selfLoops_or_spc, spc_or_tpc, tpc) {};

/**
 * Returns the minimum length between two edges associated with the given edge.
 * <p>
 * The value is fetched from the corresponding {\@link yfiles.algorithms.IDataProvider} registered with the graph with key
 * {\@link yfiles.hierarchic.SelfLoopCalculator#MINIMUM_EDGE_DISTANCE_DP_KEY}.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @return {number} the minimum length between two edges
 */
yfiles.hierarchic.SelfLoopCalculator.prototype.getMinimumDistance = function(graph, edge) {};

/**
 * Returns the minimum length of the first segment of the given edge.
 * <p>
 * The value is fetched from the corresponding {\@link yfiles.algorithms.IDataProvider} registered with the graph with key
 * {\@link yfiles.hierarchic.SelfLoopCalculator#MINIMUM_FIRST_SEGMENT_LENGTH_DP_KEY}.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @return {number} the minimum length of the first segment of an edge
 */
yfiles.hierarchic.SelfLoopCalculator.prototype.getMinimumFirstSegmentLength = function(graph, edge) {};

/**
 * Returns the minimum length of the last segment of the given edge.
 * <p>
 * The value is fetched from the corresponding {\@link yfiles.algorithms.IDataProvider} registered with the graph with key
 * {\@link yfiles.hierarchic.SelfLoopCalculator#MINIMUM_LAST_SEGMENT_LENGTH_DP_KEY}.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @return {number} the minimum length of the last segment of the given edge
 */
yfiles.hierarchic.SelfLoopCalculator.prototype.getMinimumLastSegmentLength = function(graph, edge) {};

/**
 * Returns the minimum distance between two nodes associated with the given node.
 * <p>
 * The value is fetched from the corresponding {\@link yfiles.algorithms.IDataProvider} registered with the graph with key
 * {\@link yfiles.hierarchic.SelfLoopCalculator#MINIMUM_NODE_DISTANCE_DP_KEY}.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} node the given node
 * @return {number} the minimum distance between two nodes
 */
yfiles.hierarchic.SelfLoopCalculator.prototype.getMinimumNodeDistance = function(graph, node) {};

/**
 * Returns the minimum octilinear segment length of the given edge.
 * <p>
 * The value is fetched from the corresponding {\@link yfiles.algorithms.IDataProvider} registered with the graph with key
 * {\@link yfiles.hierarchic.SelfLoopCalculator#MINIMUM_OCTILINEAR_SEGMENT_LENGTH_DP_KEY}.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @return {number} the minimum octilinear segment length of the given edge
 */
yfiles.hierarchic.SelfLoopCalculator.prototype.getMinimumOctilinearSegmentLength = function(graph, edge) {};

/**
 * Returns whether or not the given edge is octilinear.
 * <p>
 * The value is fetched from the corresponding {\@link yfiles.algorithms.IDataProvider} registered with the graph with key
 * {\@link yfiles.hierarchic.SelfLoopCalculator#OCTILINEAR_EDGES_DP_KEY}.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @return {boolean} <code>true</code> if the edge is octilinear, <code>false</code> otherwise
 */
yfiles.hierarchic.SelfLoopCalculator.prototype.isOctilinearEdge = function(graph, edge) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.SimplexNodePlacer = function() {};
 /** @type {boolean} */
yfiles.hierarchic.SimplexNodePlacer.prototype.nodeCompaction;
 /** @type {number} */
yfiles.hierarchic.SimplexNodePlacer.prototype.minimumSublayerDistance;
 /** @type {boolean} */
yfiles.hierarchic.SimplexNodePlacer.prototype.labelCompaction;
 /** @type {boolean} */
yfiles.hierarchic.SimplexNodePlacer.prototype.bendReduction;
 /** @type {boolean} */
yfiles.hierarchic.SimplexNodePlacer.prototype.horizontalCompaction;
 /** @type {boolean} */
yfiles.hierarchic.SimplexNodePlacer.prototype.straightenEdges;
 /** @type {yfiles.hierarchic.GroupCompactionPolicy} */
yfiles.hierarchic.SimplexNodePlacer.prototype.groupCompactionStrategy;
 /** @type {boolean} */
yfiles.hierarchic.SimplexNodePlacer.prototype.exactPlacement;
 /** @type {boolean} */
yfiles.hierarchic.SimplexNodePlacer.prototype.fromSketchLayerAssignment;
 /** @type {number} */
yfiles.hierarchic.SimplexNodePlacer.prototype.maximumDuration;
 /** @type {number} */
yfiles.hierarchic.SimplexNodePlacer.prototype.swimLaneCrossingWeight;
 /** @type {boolean} */
yfiles.hierarchic.SimplexNodePlacer.prototype.barycenterMode;
 /** @type {boolean} */
yfiles.hierarchic.SimplexNodePlacer.prototype.breakLongSegments;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.SimplexNodePlacer.$class;

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} layoutDataProvider
 * @param {?} layers
 * @return {void}
 */
yfiles.hierarchic.SimplexNodePlacer.prototype.assignLayerCoordinates = function(graph, layoutDataProvider, layers) {};

/**
 * Assigns the nodes of a given layer to the corresponding upper/lower sublayer if {\@link yfiles.hierarchic.SimplexNodePlacer#nodeCompaction node compaction} is enabled.
 * <p>
 * Information about sublayers is given by a {\@link yfiles.algorithms.INodeMap} whose GetBool method has to return <code>true</code> for each
 * node that should be placed in the lower sublayer (values are set by this method).
 * </p>
 * @see yfiles.hierarchic.SimplexNodePlacer#nodeCompaction
 * @protected
 * @param {!yfiles.algorithms.NodeList} layerNodes a {\@link  list} of all \@link y.layout.hierarchic.incremental.NodeData#TYPE_NORMAL normal nodes} of a layer
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {!yfiles.layout.LayoutGraph} graph the given graph
 * @param {?} lowerSublayer the {\@link } holding sublayer information
 * @return {void}
 */
yfiles.hierarchic.SimplexNodePlacer.prototype.assignNodesToSublayer = function(layerNodes, ldp, graph, lowerSublayer) {};

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} layoutDataProvider
 * @param {?} layers
 * @param {?} drawingDistanceCalculator
 * @return {void}
 */
yfiles.hierarchic.SimplexNodePlacer.prototype.assignSequenceCoordinates = function(graph, layoutDataProvider, layers, drawingDistanceCalculator) {};

/**
 * Returns the alignment of the node with a specified layer.
 * <p>
 * This callback method used by {\@link yfiles.hierarchic.SimplexNodePlacer#assignLayerCoordinates}.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {!yfiles.algorithms.Node} node the given node
 * @param {number} layerIndex the index of the layer
 * @param {number} minLayerHeight the minimum height of the layer
 * @return {number}
 */
yfiles.hierarchic.SimplexNodePlacer.prototype.getLayerAlignment = function(graph, ldp, node, layerIndex, minLayerHeight) {};

/**
 * Specifies the minimum allowed distance between two nodes of the same given layer.
 * <p>
 * This callback method is used by {\@link yfiles.hierarchic.SimplexNodePlacer#assignSequenceCoordinates}.
 * </p>
 * @see yfiles.hierarchic.IDrawingDistanceCalculator
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the graph that contains the nodes
 * @param {?} layer the layer that contains the nodes
 * @param {!yfiles.algorithms.Node} predNode the node to the left of the other one, may be <code>null</code> to indicate a border line
 * @param {!yfiles.algorithms.Node} succ the node to the right of the other one, may be <code>null</code> to indicate a border line
 * @return {number} the minimum distance allowed between those two nodes ( >=0 )
 */
yfiles.hierarchic.SimplexNodePlacer.prototype.getMinDistance = function(graph, layer, predNode, succ) {};

/**
 * Returns the minimum height of a given {\@link yfiles.hierarchic.ILayer layer}.
 * <p>
 * This callback method is used by {\@link yfiles.hierarchic.SimplexNodePlacer#assignLayerCoordinates}.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the given graph
 * @param {?} ldp the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {?} layer the given {\@link } object
 * @return {number} the minimum height
 */
yfiles.hierarchic.SimplexNodePlacer.prototype.getMinimumLayerHeight = function(graph, ldp, layer) {};

/**
 * Returns whether or not the given node should be treated as a node with fixed (given) coordinates.
 * <p>
 * This callback method is used by both {\@link yfiles.hierarchic.SimplexNodePlacer#assignLayerCoordinates} and
 * {\@link yfiles.hierarchic.SimplexNodePlacer#assignSequenceCoordinates}.
 * </p>
 * <p>
 * If <code>inLayer</code> argument is <code>true</code>, this method is called from within the {\@link yfiles.hierarchic.SimplexNodePlacer#assignLayerCoordinates}
 * method.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the given graph
 * @param {?} provider the {\@link } implementation which provides access to the {\@link } and {\@link }
 * instances
 * @param {!yfiles.algorithms.Node} node the given node
 * @param {boolean} inLayer <code>true</code> if the layer coordinate of the node is queried, <code>false</code> if the sequence coordinate is queried
 * @return {boolean} <code>true</code> if the node should be treated as fixed, <code>false</code> otherwise
 */
yfiles.hierarchic.SimplexNodePlacer.prototype.isFixedNode = function(graph, provider, node, inLayer) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.SwimlaneDescriptor = function() {};
 /** @type {boolean} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.indexFixed;
 /** @type {!Object} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.clientObject;
 /** @type {number} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.laneTightness;
 /** @type {?<!Object>} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.comparer;
 /** @type {number} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.minimumLaneWidth;
 /** @type {number} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.leftLaneInset;
 /** @type {number} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.rightLaneInset;
 /** @type {number} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.computedLanePosition;
 /** @type {number} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.computedLaneWidth;
 /** @type {number} */
yfiles.hierarchic.SwimlaneDescriptor.prototype.computedLaneIndex;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.SwimlaneDescriptor.$class;

/**
 * Implements the {\@link yfiles.lang.IComparable} interface using the {\@link yfiles.hierarchic.SwimlaneDescriptor#comparer} and {\@link yfiles.hierarchic.SwimlaneDescriptor#clientObject} fields.
 * @param {!Object} o
 * @return {number}
 */
yfiles.hierarchic.SwimlaneDescriptor.prototype.compareTo = function(o) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.TopLevelGroupToSwimlaneStage = function() {};
 /** @type {number} */
yfiles.hierarchic.TopLevelGroupToSwimlaneStage.prototype.spacing;
 /** @type {boolean} */
yfiles.hierarchic.TopLevelGroupToSwimlaneStage.prototype.orderSwimlanesFromSketch;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.TopLevelGroupToSwimlaneStage.$class;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.TopologicalLayerer = function() {};
 /** @type {yfiles.hierarchic.RankingPolicy} */
yfiles.hierarchic.TopologicalLayerer.prototype.rankingPolicy;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.TopologicalLayerer.$class;

/**
 * Assigns all nodes of the graph to layers and adds them to the {\@link yfiles.hierarchic.ILayers} instance.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } instance that will be filled with the results of the calculation
 * @param {?} ldp the {\@link } used for querying information about the nodes and edges
 * @return {void}
 */
yfiles.hierarchic.TopologicalLayerer.prototype.assignLayers = function(graph, layers, ldp) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator = function() {};
 /** @type {boolean} */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator.prototype.compaction;
 /** @type {number} */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator.prototype.nodeToNodeDistance;
 /** @type {number} */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator.prototype.nodeToEdgeDistance;
 /** @type {number} */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator.prototype.edgeToEdgeDistance;
 /** @type {number} */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator.prototype.minimumFirstSegmentLength;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator.$class;

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} layers
 * @param {?} ldp
 * @return {void}
 */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator.prototype.dispose = function(graph, layers, ldp) {};

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} layer
 * @param {?} ldp
 * @param {!yfiles.algorithms.Node} left
 * @param {!yfiles.algorithms.Node} right
 * @return {number}
 */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator.prototype.getMinDistance = function(graph, layer, ldp, left, right) {};

/**
 *
 * @param {!yfiles.layout.LayoutGraph} graph
 * @param {?} layers
 * @param {?} ldp
 * @return {void}
 */
yfiles.hierarchic.TypeBasedDrawingDistanceCalculator.prototype.initialize = function(graph, layers, ldp) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.WeightedLayerer = function() {};
 /** @type {?} */
yfiles.hierarchic.WeightedLayerer.prototype.weight;
 /** @type {!Object} */
yfiles.hierarchic.WeightedLayerer.prototype.key;
 /** @type {boolean} */
yfiles.hierarchic.WeightedLayerer.prototype.weightedCycleRemoval;
 /** @type {number} */
yfiles.hierarchic.WeightedLayerer.prototype.maximumDuration;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.WeightedLayerer.$class;

/**
 * Assigns all nodes of the graph to layers and adds them to the {\@link yfiles.hierarchic.ILayers} instance.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} layers the {\@link } instance that will be filled with the results of the calculation
 * @param {?} ldp the {\@link } used for querying information about the nodes and edges
 * @return {void}
 */
yfiles.hierarchic.WeightedLayerer.prototype.assignLayers = function(graph, layers, ldp) {};

/**
 * Assigns all nodes of the graph to layers.
 * @param {!yfiles.algorithms.Graph} graph the graph for which the layers are determined
 * @param {?} layerID the {\@link } that will be filled by the layout algorithm and returns a zero-based layer index for each
 * node
 * @return {number} the number of layers
 */
yfiles.hierarchic.WeightedLayerer.prototype.assignLayersFast = function(graph, layerID) {};

/**
 * Assigns all nodes of the graph to layers.
 * @param {!yfiles.algorithms.Graph} graph the graph for which the layers are determined
 * @param {?} layerID the {\@link } that will be filled by the layout algorithm and returns the zero-based index of the layer
 * to which each node belongs
 * @return {number} the number of layers
 */
yfiles.hierarchic.WeightedLayerer.prototype.assignLayersToMap = function(graph, layerID) {};

/**
 * Assigns all nodes of the graph to layers.
 * @param {!yfiles.layout.LayoutGraph} graph the graph for which the layers are determined
 * @param {?} layerID the {\@link } that will be filled by the layout algorithm and returns a zero-based layer index for each
 * node
 * @param {!yfiles.algorithms.EdgeList} reversedEdges an {\@link } containing the edges which had been reversed
 * @param {?} weight the {\@link } that returns an integer value (weight) for each edge
 * @return {number} the number of layers
 */
yfiles.hierarchic.WeightedLayerer.prototype.assignNodeLayerWithDataProvider = function(graph, layerID, reversedEdges, weight) {};

/**
 * Returns the edge weight of the given edge using the weight based cycle removal heuristic.
 * <p>
 * By default, all edges are considered to have weight <code>1.0</code>.
 * </p>
 * <p>
 * It may be overridden if non-uniform weights are desired.
 * </p>
 * @see yfiles.hierarchic.WeightedLayerer#weightedCycleRemoval
 * @see yfiles.hierarchic.WeightedLayerer#weightedCycleRemoval
 * @protected
 * @param {!yfiles.algorithms.Edge} edge given edge
 * @return {number} the edge weight of the specified edge
 */
yfiles.hierarchic.WeightedLayerer.prototype.getWeight = function(edge) {};

/**
 * Removes cycles from the graph using a depth first search.
 * @param {!yfiles.algorithms.Graph} graph the graph
 * @param {!yfiles.algorithms.EdgeList} reversedEdges an {\@link } containing the edges which will be reversed
 * @return {void}
 */
yfiles.hierarchic.WeightedLayerer.prototype.makeDFSAcyclic = function(graph, reversedEdges) {};
/**
 * @record
 * @struct
 */
yfiles.hierarchic.HierarchicLayoutData = function() {};
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.algorithms.YPointPath>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.alternativeEdgePath;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.algorithms.YRectangle>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.alternativeGroupBounds;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.criticalEdgePriorities;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.folderNodes;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.hierarchic.EdgeLayoutDescriptor>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.edgeLayoutDescriptors;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.hierarchic.NodeLayoutDescriptor>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.nodeLayoutDescriptors;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.targetPortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.sourcePortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.targetPortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortCandidateSet>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.nodePortCandidateSets;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.sourceGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.sourcePortGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.targetGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.targetPortGroupIds;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayoutData.prototype.layerConstraintFactory;
 /** @type {?} */
yfiles.hierarchic.HierarchicLayoutData.prototype.sequenceConstraintFactory;
 /** @type {!yfiles.hierarchic.IncrementalHintItemMapping} */
yfiles.hierarchic.HierarchicLayoutData.prototype.incrementalHints;
 /** @type {?<?, number>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.layerIndices;
 /** @type {?<?, number>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.sequenceIndices;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.hierarchic.HierarchicLayoutData.prototype.abortHandler;
 /** @type {!yfiles.layout.PartitionGridData} */
yfiles.hierarchic.HierarchicLayoutData.prototype.partitionGridData;
 /** @type {!yfiles.hierarchic.SelfLoopCalculatorData} */
yfiles.hierarchic.HierarchicLayoutData.prototype.selfLoopCalculatorData;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.constraintIncrementalLayererAdditionalEdgeWeights;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.bfsLayererCoreNodes;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.givenLayersLayererIds;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.edgeDirectedness;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.edgeThickness;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PreferredPlacementDescriptor>} */
yfiles.hierarchic.HierarchicLayoutData.prototype.edgeLabelPreferredPlacement;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.HierarchicLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.IncrementalHintItemMapping = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.hierarchic.IncrementalHintItemMapping.prototype.incrementalLayeringNodes;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.hierarchic.IncrementalHintItemMapping.prototype.incrementalSequencingItems;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.IncrementalHintItemMapping.$class;
/**
 * @record
 * @struct
 */
yfiles.hierarchic.SelfLoopCalculatorData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.hierarchic.SelfLoopCalculatorData.prototype.octilinearEdges;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.SelfLoopCalculatorData.prototype.minimumNodeDistances;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.SelfLoopCalculatorData.prototype.minimumEdgeDistances;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.SelfLoopCalculatorData.prototype.minimumFirstSegmentLengths;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.SelfLoopCalculatorData.prototype.minimumLastSegmentLengths;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.hierarchic.SelfLoopCalculatorData.prototype.minimumOctilinearSegmentLengths;
 /** @type {!yfiles.lang.Class} */
yfiles.hierarchic.SelfLoopCalculatorData.$class;
/** @const */
yfiles.labeling = {};

/** @const */
yfiles.labeling.OptimizationStrategy = {};
/** @const {number} */
yfiles.labeling.OptimizationStrategy.BALANCED;
/** @const {number} */
yfiles.labeling.OptimizationStrategy.NODE_OVERLAP;
/** @const {number} */
yfiles.labeling.OptimizationStrategy.LABEL_OVERLAP;
/** @const {number} */
yfiles.labeling.OptimizationStrategy.EDGE_OVERLAP;
/** @const {number} */
yfiles.labeling.OptimizationStrategy.PREFERRED_PLACEMENT;
/** @const {number} */
yfiles.labeling.OptimizationStrategy.NONE;
/**
 * @record
 * @struct
 */
yfiles.labeling.GenericLabeling = function() {};
 /** @type {boolean} */
yfiles.labeling.GenericLabeling.prototype.deterministic;
 /** @type {number} */
yfiles.labeling.GenericLabeling.prototype.maximumDuration;
 /** @type {!yfiles.lang.Class} */
yfiles.labeling.GenericLabeling.$class;
/**
 * @record
 * @struct
 */
yfiles.labeling.LabelingBase = function() {};
 /** @type {!yfiles.algorithms.ILabelLayoutDpKey<!Object>} */
yfiles.labeling.LabelingBase.LABEL_MODEL_DP_KEY;
 /** @type {?} */
yfiles.labeling.LabelingBase.prototype.profitModel;
 /** @type {boolean} */
yfiles.labeling.LabelingBase.prototype.moveInternalNodeLabels;
 /** @type {boolean} */
yfiles.labeling.LabelingBase.prototype.reduceLabelOverlaps;
 /** @type {boolean} */
yfiles.labeling.LabelingBase.prototype.removeNodeOverlaps;
 /** @type {boolean} */
yfiles.labeling.LabelingBase.prototype.removeEdgeOverlaps;
 /** @type {boolean} */
yfiles.labeling.LabelingBase.prototype.placeNodeLabels;
 /** @type {boolean} */
yfiles.labeling.LabelingBase.prototype.placeEdgeLabels;
 /** @type {!Object} */
yfiles.labeling.LabelingBase.prototype.affectedLabelsDpKey;
 /** @type {boolean} */
yfiles.labeling.LabelingBase.prototype.autoFlipping;
 /** @type {boolean} */
yfiles.labeling.LabelingBase.prototype.edgeGroupOverlapAllowed;
 /** @type {!yfiles.lang.Class} */
yfiles.labeling.LabelingBase.$class;

/**
 * Returns the profit for placing a {\@link yfiles.layout.LabelCandidate} with respect to the current {\@link yfiles.labeling.LabelingBase#profitModel profit model}.
 * <p>
 * Method {\@link yfiles.layout.IProfitModel#getProfit} on the current profit model will be invoked to compute the actual profit
 * value.
 * </p>
 * <p>
 * The higher the profit (rank) of a candidate is, the more likely it will be chosen as actual position by the algorithm.
 * </p>
 * @param {!yfiles.layout.LabelCandidate} candidate a label candidate
 * @return {number} the profit value between <code>0</code> and <code>1</code>
 */
yfiles.labeling.LabelingBase.prototype.getProfit = function(candidate) {};

/**
 * Places the labels of the input graph restricting the placement to labels contained in the given lists.
 * <p>
 * The {\@link yfiles.labeling.LabelingBase#affectedLabelsDpKey selection} will not be considered; the given lists will define the selection of labels that are to be placed.
 * </p>
 * Places the labels of the input graph using a {\@link yfiles.algorithms.IDataProvider} registered to the input graph with the
 * given key for determining which labels to place.
 * <p>
 * Instead of considering the current {\@link yfiles.labeling.LabelingBase#affectedLabelsDpKey selection key}, the {\@link yfiles.algorithms.IDataProvider} registered with the given key will
 * be used for selecting labels. Invoking this method has the same effect as first {\@link yfiles.labeling.LabelingBase#affectedLabelsDpKey specifying the key} as selection key and
 * then invoking {\@link yfiles.labeling.LabelingBase#label}.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.YList|!Object=} nodeLabels_or_key a list of {\@link }s defining the set of node labels that will be placed
 * @param {!yfiles.algorithms.YList=} edgeLabels a list of {\@link }s defining the set of edge labels that will be placed
 * @return {void}
 */
yfiles.labeling.LabelingBase.prototype.label = function(graph, nodeLabels_or_key, edgeLabels) {};
/**
 * @record
 * @struct
 */
yfiles.labeling.MISLabelingBase = function() {};
 /** @type {!yfiles.layout.LayoutGraph} */
yfiles.labeling.MISLabelingBase.prototype.graph;
 /** @type {!yfiles.algorithms.Graph} */
yfiles.labeling.MISLabelingBase.prototype.conflictGraph;
 /** @type {?} */
yfiles.labeling.MISLabelingBase.prototype.nodesToBoxes;
 /** @type {?<!Object, !Object>} */
yfiles.labeling.MISLabelingBase.prototype.boxesToNodes;
 /** @type {?} */
yfiles.labeling.MISLabelingBase.prototype.nodesToID;
 /** @type {number} */
yfiles.labeling.MISLabelingBase.prototype.customProfitModelRatio;
 /** @type {yfiles.labeling.OptimizationStrategy} */
yfiles.labeling.MISLabelingBase.prototype.optimizationStrategy;
 /** @type {boolean} */
yfiles.labeling.MISLabelingBase.prototype.removeNodeOverlaps;
 /** @type {boolean} */
yfiles.labeling.MISLabelingBase.prototype.removeEdgeOverlaps;
 /** @type {boolean} */
yfiles.labeling.MISLabelingBase.prototype.reduceAmbiguity;
 /** @type {!yfiles.lang.Class} */
yfiles.labeling.MISLabelingBase.$class;

/**
 * Returns a {\@link yfiles.algorithms.INodeMap} which assigns a profit value to each node in the {\@link yfiles.labeling.MISLabelingBase#conflictGraph conflict graph}.
 * <p>
 * As the conflict graph's nodes represent {\@link yfiles.layout.LabelCandidate}s, this mapping gives the profit value of label
 * candidates. The assigned value is defined as the difference between the {\@link yfiles.labeling.LabelingBase#getProfit profit induced by the profit model} and the
 * candidate's {\@link yfiles.layout.LabelCandidate#overlapPenalty overlap penalty}.
 * </p>
 * <p>
 * The returned map is a mapping from each {\@link yfiles.algorithms.Node} (representing a label candidate) in the {\@link yfiles.labeling.MISLabelingBase#conflictGraph}
 * to a {\@link number} representing the profit value of the candidate.
 * </p>
 * @return {?} a mapping from nodes (i.e. label candidates) to their profit value
 */
yfiles.labeling.MISLabelingBase.prototype.assignProfit = function() {};

/**
 * Creates the edges in the conflict graph, i.e., one edge between two nodes if the corresponding
 * {\@link yfiles.layout.LabelCandidate}s intersect.
 * <p>
 * The nodes of the {\@link yfiles.labeling.MISLabelingBase#conflictGraph conflict graph} represent
 * {\@link yfiles.layout.LabelCandidate}s. An edge between candidates signals that they overlap. A maximum independent set will be
 * computed on the conflict graph to choose candidates such that no two candidates overlap.
 * </p>
 * <p>
 * This method may be overridden to change the structure of the {\@link yfiles.labeling.MISLabelingBase#conflictGraph conflict graph}. Edges between two
 * {\@link yfiles.layout.LabelCandidate}s in the conflict graph signal that the two candidates should not be selected together. By
 * overriding this method, arbitrary reasons for indicating that two label candidates should not be chosen at the same time
 * can be modeled.
 * </p>
 * @see yfiles.labeling.MISLabelingBase#conflictGraph
 * @see yfiles.labeling.MISLabelingBase#nodesToBoxes
 * @see yfiles.labeling.MISLabelingBase#boxesToNodes
 * @see yfiles.labeling.MISLabelingBase#nodesToID
 * @protected
 * @return {void}
 */
yfiles.labeling.MISLabelingBase.prototype.createEdges = function() {};

/**
 * Indicates that an overlap between a {\@link yfiles.layout.LabelCandidate} and an {\@link yfiles.algorithms.Edge} of the input graph has
 * been found.
 * <p>
 * This method is called when finding overlaps while {\@link yfiles.labeling.MISLabelingBase#createEdges creating edges} of the {\@link yfiles.labeling.MISLabelingBase#conflictGraph conflict graph}. It will store a factor
 * indicating how much the two elements overlap. The factor influences the {\@link yfiles.labeling.LabelingBase#getProfit profit} assigned to the given label candidate.
 * </p>
 * <p>
 * This method may be overridden to realize a custom strategy for reacting to overlaps between label candidates and edges.
 * </p>
 * @see yfiles.labeling.MISLabelingBase#conflictGraph
 * @see yfiles.labeling.MISLabelingBase#createEdges
 * @param {!yfiles.layout.LabelCandidate} labelCandidate the {\@link } overlapping with the given {\@link }
 * @param {!yfiles.algorithms.Edge} edge the {\@link } overlapping with the given {\@link }
 * @param {!yfiles.algorithms.LineSegment} eSegment the {\@link } of the given edge overlapping with the given candidate
 * @return {void}
 */
yfiles.labeling.MISLabelingBase.prototype.foundEdgeOverlap = function(labelCandidate, edge, eSegment) {};

/**
 * Indicates that an overlap between a {\@link yfiles.layout.LabelCandidate} and a {\@link yfiles.layout.NodeHalo} of the input graph has
 * been found.
 * <p>
 * This method is called when finding overlaps while {\@link yfiles.labeling.MISLabelingBase#createEdges creating edges} of the {\@link yfiles.labeling.MISLabelingBase#conflictGraph conflict graph}. It will store a factor
 * indicating how much the two elements overlap. The factor influences the {\@link yfiles.labeling.LabelingBase#getProfit profit} assigned to the given label candidate.
 * </p>
 * <p>
 * This method may be overridden to realize a custom strategy for reacting to overlaps between label candidates and node
 * halos.
 * </p>
 * @see yfiles.labeling.MISLabelingBase#conflictGraph
 * @see yfiles.labeling.MISLabelingBase#createEdges
 * @param {!yfiles.layout.LabelCandidate} labelCandidate the {\@link } overlapping with a node halo
 * @param {!yfiles.algorithms.Node} node the {\@link } whose {\@link } is overlapping with the given label candidate
 * @param {!yfiles.algorithms.YRectangle} haloRect the bounding box of the {\@link } overlapping with the given label candidate
 * @return {void}
 */
yfiles.labeling.MISLabelingBase.prototype.foundHaloOverlap = function(labelCandidate, node, haloRect) {};

/**
 * Indicates that an overlap between two {\@link yfiles.layout.LabelCandidate}s has been found.
 * <p>
 * This method is called when finding overlaps while {\@link yfiles.labeling.MISLabelingBase#createEdges creating edges} of the
 * {\@link yfiles.labeling.MISLabelingBase#conflictGraph conflict graph}. It will store a factor indicating how much the two candidates overlap. The factor influences the penalty
 * assigned when both candidates are chosen, i.e., the penalty for the corresponding overlap.
 * </p>
 * <p>
 * This method may be overridden to realize a custom strategy for reacting to overlaps among
 * {\@link yfiles.layout.LabelCandidate}s.
 * </p>
 * @see yfiles.labeling.MISLabelingBase#conflictGraph
 * @see yfiles.labeling.MISLabelingBase#createEdges
 * @param {!yfiles.layout.LabelCandidate} candidate1 the first overlapping {\@link }
 * @param {!yfiles.layout.LabelCandidate} candidate2 the second overlapping {\@link }
 * @param {!yfiles.algorithms.Edge} edge the {\@link } in {\@link #conflictGraph} representing the found overlap
 * @return {void}
 */
yfiles.labeling.MISLabelingBase.prototype.foundLabelOverlap = function(candidate1, candidate2, edge) {};

/**
 * Indicates that an overlap between a {\@link yfiles.layout.LabelCandidate} and a {\@link yfiles.algorithms.Node} of the input graph has
 * been found.
 * <p>
 * This method is called when finding overlaps while {\@link yfiles.labeling.MISLabelingBase#createEdges creating edges} of the {\@link yfiles.labeling.MISLabelingBase#conflictGraph conflict graph}. It will store a factor
 * indicating how much the two elements overlap. The factor influences the {\@link yfiles.labeling.LabelingBase#getProfit profit} assigned to the given label candidate.
 * </p>
 * <p>
 * This method may be overridden to realize a custom strategy for reacting to overlaps between label candidates and nodes.
 * </p>
 * @see yfiles.labeling.MISLabelingBase#conflictGraph
 * @see yfiles.labeling.MISLabelingBase#createEdges
 * @param {!yfiles.layout.LabelCandidate} labelCandidate the {\@link } overlapping with the given node
 * @param {!yfiles.algorithms.Node} node the {\@link } overlapping with the given label candidate
 * @param {!yfiles.algorithms.YRectangle} nodeBox the bounding box of the given node
 * @return {void}
 */
yfiles.labeling.MISLabelingBase.prototype.foundNodeOverlap = function(labelCandidate, node, nodeBox) {};
/**
 * @record
 * @struct
 */
yfiles.labeling.LabelingData = function() {};
 /** @type {!yfiles.layout.DpKeyItemCollection<?>} */
yfiles.labeling.LabelingData.prototype.affectedLabels;
 /** @type {!yfiles.layout.ItemMapping<?, ?>} */
yfiles.labeling.LabelingData.prototype.nodeLabelModels;
 /** @type {!yfiles.layout.ItemMapping<?, ?>} */
yfiles.labeling.LabelingData.prototype.edgeLabelModels;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.labeling.LabelingData.prototype.sourceGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.labeling.LabelingData.prototype.targetGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.labeling.LabelingData.prototype.nodeHalos;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.labeling.LabelingData.prototype.abortHandler;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PreferredPlacementDescriptor>} */
yfiles.labeling.LabelingData.prototype.edgeLabelPreferredPlacement;
 /** @type {!yfiles.lang.Class} */
yfiles.labeling.LabelingData.$class;
/** @const */
yfiles.organic = {};

/** @const */
yfiles.organic.InitialPlacement = {};
/** @const {number} */
yfiles.organic.InitialPlacement.RANDOM;
/** @const {number} */
yfiles.organic.InitialPlacement.ZERO;
/** @const {number} */
yfiles.organic.InitialPlacement.AS_IS;

/** @const */
yfiles.organic.GroupsPolicy = {};
/** @const {number} */
yfiles.organic.GroupsPolicy.LAYOUT;
/** @const {number} */
yfiles.organic.GroupsPolicy.FIXED;
/** @const {number} */
yfiles.organic.GroupsPolicy.IGNORE;

/** @const */
yfiles.organic.Scope = {};
/** @const {number} */
yfiles.organic.Scope.ALL;
/** @const {number} */
yfiles.organic.Scope.MAINLY_SUBSET;
/** @const {number} */
yfiles.organic.Scope.SUBSET;

/** @const */
yfiles.organic.HorizontalOverlapCriterion = {};
/** @const {number} */
yfiles.organic.HorizontalOverlapCriterion.INTERSECTION_BOX;
/** @const {number} */
yfiles.organic.HorizontalOverlapCriterion.NODE_CENTER;
/** @const {number} */
yfiles.organic.HorizontalOverlapCriterion.LESS_MOVEMENT;

/** @const */
yfiles.organic.ChainSubstructureStyle = {};
/** @const {number} */
yfiles.organic.ChainSubstructureStyle.NONE;
/** @const {number} */
yfiles.organic.ChainSubstructureStyle.RECTANGULAR;
/** @const {number} */
yfiles.organic.ChainSubstructureStyle.STRAIGHT_LINE;

/** @const */
yfiles.organic.StarSubstructureStyle = {};
/** @const {number} */
yfiles.organic.StarSubstructureStyle.NONE;
/** @const {number} */
yfiles.organic.StarSubstructureStyle.RADIAL;
/** @const {number} */
yfiles.organic.StarSubstructureStyle.SEPARATED_RADIAL;
/** @const {number} */
yfiles.organic.StarSubstructureStyle.CIRCULAR;

/** @const */
yfiles.organic.ParallelSubstructureStyle = {};
/** @const {number} */
yfiles.organic.ParallelSubstructureStyle.NONE;
/** @const {number} */
yfiles.organic.ParallelSubstructureStyle.RECTANGULAR;
/** @const {number} */
yfiles.organic.ParallelSubstructureStyle.RADIAL;
/** @const {number} */
yfiles.organic.ParallelSubstructureStyle.STRAIGHT_LINE;

/** @const */
yfiles.organic.CycleSubstructureStyle = {};
/** @const {number} */
yfiles.organic.CycleSubstructureStyle.NONE;
/** @const {number} */
yfiles.organic.CycleSubstructureStyle.CIRCULAR;

/** @const */
yfiles.organic.GroupNodeMode = {};
/** @const {number} */
yfiles.organic.GroupNodeMode.NORMAL;
/** @const {number} */
yfiles.organic.GroupNodeMode.FIX_BOUNDS;
/** @const {number} */
yfiles.organic.GroupNodeMode.FIX_CONTENTS;
/**
 * @record
 * @struct
 */
yfiles.organic.ShuffleLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.organic.ShuffleLayout.MINIMUM_DISTANCE_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.organic.ShuffleLayout.FIXED_NODE_DP_KEY;
 /** @type {?} */
yfiles.organic.ShuffleLayout.prototype.coreLayout;
 /** @type {yfiles.organic.HorizontalOverlapCriterion} */
yfiles.organic.ShuffleLayout.prototype.horizontalOverlapCriterion;
 /** @type {number} */
yfiles.organic.ShuffleLayout.prototype.minimumNodeDistance;
 /** @type {boolean} */
yfiles.organic.ShuffleLayout.prototype.simpleMode;
 /** @type {boolean} */
yfiles.organic.ShuffleLayout.prototype.barycenterMode;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.ShuffleLayout.$class;

/**
 * Performs the overlap removal (shuffle) algorithm on the given graph, after the {\@link yfiles.organic.ShuffleLayout#coreLayout core layout algorithm} was applied to it.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.organic.ShuffleLayout.prototype.applyLayout = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.organic.ClassicOrganicLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.organic.ClassicOrganicLayout.AFFECTED_NODES_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.organic.ClassicOrganicLayout.FIXED_GROUP_NODES_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.organic.ClassicOrganicLayout.PREFERRED_EDGE_LENGTH_DP_KEY;
 /** @type {number} */
yfiles.organic.ClassicOrganicLayout.prototype.repulsion;
 /** @type {number} */
yfiles.organic.ClassicOrganicLayout.prototype.attraction;
 /** @type {?} */
yfiles.organic.ClassicOrganicLayout.prototype.groupBoundsCalculator;
 /** @type {number} */
yfiles.organic.ClassicOrganicLayout.prototype.groupNodeCompactness;
 /** @type {yfiles.organic.GroupsPolicy} */
yfiles.organic.ClassicOrganicLayout.prototype.groupNodePolicy;
 /** @type {number} */
yfiles.organic.ClassicOrganicLayout.prototype.initialTemperature;
 /** @type {number} */
yfiles.organic.ClassicOrganicLayout.prototype.finalTemperature;
 /** @type {boolean} */
yfiles.organic.ClassicOrganicLayout.prototype.deterministic;
 /** @type {boolean} */
yfiles.organic.ClassicOrganicLayout.prototype.activateTreeBeautifier;
 /** @type {number} */
yfiles.organic.ClassicOrganicLayout.prototype.gravityFactor;
 /** @type {yfiles.organic.Scope} */
yfiles.organic.ClassicOrganicLayout.prototype.scope;
 /** @type {yfiles.organic.InitialPlacement} */
yfiles.organic.ClassicOrganicLayout.prototype.initialPlacement;
 /** @type {number} */
yfiles.organic.ClassicOrganicLayout.prototype.maximumDuration;
 /** @type {number} */
yfiles.organic.ClassicOrganicLayout.prototype.iterationFactor;
 /** @type {number} */
yfiles.organic.ClassicOrganicLayout.prototype.preferredEdgeLength;
 /** @type {boolean} */
yfiles.organic.ClassicOrganicLayout.prototype.considerNodeSizes;
 /** @type {boolean} */
yfiles.organic.ClassicOrganicLayout.prototype.orientationLayoutEnabled;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.ClassicOrganicLayout.$class;

/**
 * Frees internal resources which were in use during a previous algorithm run.
 * @return {void}
 */
yfiles.organic.ClassicOrganicLayout.prototype.dispose = function() {};
/**
 * @record
 * @struct
 */
yfiles.organic.InteractiveOrganicLayoutExecutionContext = function() {};

/**
 * Starts the layout calculation, continuing where it has stopped before and allowing a certain maximum duration in
 * milliseconds.
 * @abstract
 * @param {number} duration the duration in milliseconds the layout calculation is allowed to run
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayoutExecutionContext.prototype.continueLayout = function(duration) {};

/**
 * Stops the layout calculation.
 * @abstract
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayoutExecutionContext.prototype.stopLayout = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.organic.InteractiveOrganicLayoutExecutionContext;
/**
 * @record
 * @struct
 */
yfiles.organic.InteractiveOrganicLayout = function() {};
 /** @type {number} */
yfiles.organic.InteractiveOrganicLayout.prototype.lastWakeupTime;
 /** @type {boolean} */
yfiles.organic.InteractiveOrganicLayout.prototype.stopped;
 /** @type {boolean} */
yfiles.organic.InteractiveOrganicLayout.prototype.sleeping;
 /** @type {boolean} */
yfiles.organic.InteractiveOrganicLayout.prototype.running;
 /** @type {number} */
yfiles.organic.InteractiveOrganicLayout.prototype.workingRatio;
 /** @type {number} */
yfiles.organic.InteractiveOrganicLayout.prototype.preferredEdgeLength;
 /** @type {number} */
yfiles.organic.InteractiveOrganicLayout.prototype.preferredNodeDistance;
 /** @type {number} */
yfiles.organic.InteractiveOrganicLayout.prototype.maximumDuration;
 /** @type {number} */
yfiles.organic.InteractiveOrganicLayout.prototype.qualityTimeRatio;
 /** @type {!yfiles.organic.OutputRestriction} */
yfiles.organic.InteractiveOrganicLayout.prototype.outputRestriction;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.InteractiveOrganicLayout.$class;

/**
 * Schedules an update for the structure of the graph, which will automatically be executed at a later point in the
 * life-cycle of this algorithm.
 * <p>
 * The given event handler will be queued and executed at a specific time. The event handler can make structural changes
 * (e.g. removal/creation of edges or nodes). They will be synchronized with the rest of the layout algorithm.
 * </p>
 * @param {function(!Object, !yfiles.lang.EventArgs): void} handler The handler delegate that will be invoked using <code>null</code> as the sender and <code>args</code> as the event arguments
 * @param {!yfiles.lang.EventArgs} evt The event argument that will be piped to the <code>handler</code> invocation.
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.addStructureUpdate = function(handler, evt) {};

/**
 * Calculates an organic layout for the given input graph, however, the layout is <b>not automatically applied</b> to the graph.
 * <p>
 * Changes have to be {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions committed} to update the graph with the actual calculated positions.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#startLayout
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.applyLayout = function(graph) {};

/**
 * Writes calculated intermediate locations of nodes and edges to the actual graph.
 * <p>
 * Update methods like {\@link yfiles.organic.InteractiveOrganicLayout#setCenter} schedule changes which cause that the whole layout
 * will internally be adjusted. All adjustments are stored as intermediate results. This method immediately transfers all
 * these intermediate results to the actual input graph.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#commitPositionsSmoothly
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.commitPositions = function() {};

/**
 * Writes calculated intermediate locations of nodes and edges to the actual graph and returns the largest movement value.
 * <p>
 * Update methods like {\@link yfiles.organic.InteractiveOrganicLayout#setCenter} schedule changes which cause that the whole layout
 * will internally be adjusted. All adjustments are stored as intermediate results. This method smoothly transfers all
 * these intermediate results to the actual input graph.
 * </p>
 * <p>
 * Positions are, however, <b>not transferred directly</b> (use {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions} if that is intended). Instead, the
 * nodes are moved towards the calculated position. The movement is restricted to the given maximum distance.
 * </p>
 * <p>
 * The movement will be calculated as <em>(movement) = (factor) * (distance between calculated and actual location)</em>
 * </p>
 * <p>
 * The returned largest movement can be used for estimating the difference between calculated layout and actual positions.
 * If the return value is <code>0</code>, the calculated layout was completely transferred.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#commitPositions
 * @param {number} maxMovement the maximum distance a node will be moved
 * @param {number} factor a factor that determines the node movement
 * @return {number} the largest movement value or <code>0</code>, if the calculated layout has been transferred completely
 */
yfiles.organic.InteractiveOrganicLayout.prototype.commitPositionsSmoothly = function(maxMovement, factor) {};

/**
 * Disables all predefined {\@link yfiles.layout.ILayoutStage}s so that upon {\@link yfiles.organic.InteractiveOrganicLayout#applyLayout}
 * only the internal organic layout algorithm will be executed.
 * <p>
 * This method is called upon construction of this class so that by default additional
 * {\@link yfiles.layout.ILayoutStage}s are deactivated. This method may be overridden if the additional stages should stay active
 * (e.g. override the method and return silently).
 * </p>
 * @see yfiles.layout.MultiStageLayout#disableAllStages
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.disableAllStages = function() {};

/**
 * Polls the current coordinates of the center of the given node.
 * <p>
 * The returned coordinates do not necessarily correspond to the actual location of the node in the input graph. They may
 * only be intermediate results stored in the algorithm. This will be the case if scheduled updates were not yet completely
 * {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions committed} to the actual graph.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#setCenter
 * @param {!yfiles.algorithms.Node} node the node for which the center should be polled
 * @return {!yfiles.algorithms.YPoint} the {\@link } representing the center location of the given node, or <code>null</code> if nothing about the node is
 * known
 */
yfiles.organic.InteractiveOrganicLayout.prototype.getCenter = function(node) {};

/**
 * Polls the current x-coordinate of the center location of the given node.
 * <p>
 * The returned coordinate is not necessarily the actual x-coordinate of the node in the input graph but only an
 * intermediate result stored in the algorithm. This will be the case if scheduled updates were not yet completely {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions committed}
 * to the actual graph.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#setCenterX
 * @param {!yfiles.algorithms.Node} node the node for which the x-coordinate should be polled
 * @return {number} the x-coordinate of the center location of the given node
 */
yfiles.organic.InteractiveOrganicLayout.prototype.getCenterX = function(node) {};

/**
 * Polls the current y-coordinate of the center location of the given node.
 * <p>
 * The returned coordinate is not necessarily the actual y-coordinate of the node in the input graph but only an
 * intermediate result stored in the algorithm. This will be the case if scheduled updates were not yet completely {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions committed}
 * to the actual graph.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#setCenterY
 * @param {!yfiles.algorithms.Node} node the node for which the y-coordinate should be polled
 * @return {number} the y-coordinate of the center location of the given node
 */
yfiles.organic.InteractiveOrganicLayout.prototype.getCenterY = function(node) {};

/**
 * Polls the current stress value of a given node.
 * <p>
 * The stress value indicates how far a node will possibly move. The higher the stress of a node is, the farther it may
 * move.
 * </p>
 * <p>
 * The stress value is defined to be a value from the interval <code>[0,1]</code>.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#setStress
 * @param {!yfiles.algorithms.Node} node the node for which the stress value should be polled
 * @return {number} the stress value of the given node
 */
yfiles.organic.InteractiveOrganicLayout.prototype.getStress = function(node) {};

/**
 * Schedules an update for the center location of the given node.
 * <p>
 * This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the
 * change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be
 * committed to the graph while the algorithm is running using methods {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions}
 * or {\@link yfiles.organic.InteractiveOrganicLayout#commitPositionsSmoothly}.
 * </p>
 * @param {!yfiles.algorithms.Node} node the node that should be updated
 * @param {number} x the desired x-coordinate of the given node
 * @param {number} y the desired y-coordinate of the given node
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.setCenter = function(node, x, y) {};

/**
 * Schedules an update for the center location's x-coordinate of the given node.
 * <p>
 * This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the
 * change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be
 * committed to the graph while the algorithm is running using methods {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions}
 * or {\@link yfiles.organic.InteractiveOrganicLayout#commitPositionsSmoothly}.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#setCenterY
 * @see yfiles.organic.InteractiveOrganicLayout#setCenter
 * @param {!yfiles.algorithms.Node} node the node that should be updated
 * @param {number} x the desired x-coordinate of the given node
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.setCenterX = function(node, x) {};

/**
 * Schedules an update for the center location's y-coordinate of the given node.
 * <p>
 * This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the
 * change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be
 * committed to the graph while the algorithm is running using methods {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions}
 * or {\@link yfiles.organic.InteractiveOrganicLayout#commitPositionsSmoothly}.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#setCenterX
 * @see yfiles.organic.InteractiveOrganicLayout#setCenter
 * @param {!yfiles.algorithms.Node} node the node that should be updated
 * @param {number} y the desired y-coordinate of the given node
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.setCenterY = function(node, y) {};

/**
 * Schedules an update for the inertia of the given node.
 * <p>
 * The inertia is defined to be a value from the interval <code>[0,1]</code>.
 * </p>
 * <ul>
 * <li><code>1.0</code>: The node will not move.</li>
 * <li><code>0.5</code>: The node will only move half as far as it would with an inertia of <code>0.0</code>.</li>
 * <li><code>0.0</code>: The node will move as fast as possible.</li>
 * </ul>
 * <p>
 * This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the
 * change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be
 * committed to the graph while the algorithm is running using methods {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions}
 * or {\@link yfiles.organic.InteractiveOrganicLayout#commitPositionsSmoothly}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given inertia value is negative or greater than <code>1</code>
 * @param {!yfiles.algorithms.Node} node the node whose inertia to set
 * @param {number} inertia an inertia value between <code>0</code> and <code>1</code>
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.setInertia = function(node, inertia) {};

/**
 * Schedules an update for the preferred length of the given edge.
 * <p>
 * This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the
 * change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be
 * committed to the graph while the algorithm is running using methods {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions}
 * or {\@link yfiles.organic.InteractiveOrganicLayout#commitPositionsSmoothly}.
 * </p>
 * @param {!yfiles.algorithms.Edge} edge the edge whose preferred length should be updated
 * @param {number} newEdgeLength the new preferred edge length
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.setPreferredEdgeLength = function(edge, newEdgeLength) {};

/**
 * Schedules an update for the radius of the given node.
 * <p>
 * This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the
 * change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be
 * committed to the graph while the algorithm is running using methods {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions}
 * or {\@link yfiles.organic.InteractiveOrganicLayout#commitPositionsSmoothly}.
 * </p>
 * @param {!yfiles.algorithms.Node} node the node whose radius should be updated
 * @param {number} radius the desired radius for the given node
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.setRadius = function(node, radius) {};

/**
 * Schedules an update for the stress value of the given node.
 * <p>
 * The stress value indicates how far a node will possibly move. The higher the stress of a node is, the farther it may
 * move.
 * </p>
 * <p>
 * This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the
 * change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be
 * committed to the graph while the algorithm is running using methods {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions}
 * or {\@link yfiles.organic.InteractiveOrganicLayout#commitPositionsSmoothly}.
 * </p>
 * <p>
 * The stress value is defined to be a value from the interval <code>[0,1]</code>.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given stress value is negative or greater than <code>1</code>
 * @param {!yfiles.algorithms.Node} node the node whose stress value should be updated
 * @param {number} stress a stress value from the interval <code>[0,1]</code>
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.setStress = function(node, stress) {};

/**
 * Creates a {\@link yfiles.organic.InteractiveOrganicLayoutExecutionContext context object} that provides methods to continue and {\@link yfiles.organic.InteractiveOrganicLayoutExecutionContext#stopLayout stop} the layout calculation for running this layout
 * algorithm in a single-threaded environment.
 * <p>
 * <em>Usage:</em> Call doLayout(long) on the created instance to run the actual layout calculation for some specified period of time,
 * whenever the layout should be recalculated. To actually transfer the changes, {\@link yfiles.organic.InteractiveOrganicLayout#commitPositions}
 * should be called subsequently.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayoutExecutionContext
 * @see yfiles.organic.InteractiveOrganicLayout#applyLayout
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {?} a {\@link  context instance} to control layout calculation
 */
yfiles.organic.InteractiveOrganicLayout.prototype.startLayout = function(graph) {};

/**
 * Stops the layout algorithm.
 * <p>
 * In contrast to
 * {\@link yfiles.organic.InteractiveOrganicLayout#stopAndWait}, the algorithm terminates immediately and will not wait until the
 * ongoing layout calculation is finished.
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#stopped
 * @see yfiles.organic.InteractiveOrganicLayout#stopAndWait
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.stop = function() {};

/**
 * Stops a previously {\@link yfiles.organic.InteractiveOrganicLayout#startLayout started} algorithm and then blocks until the current layout calculation is completed.
 * @see yfiles.organic.InteractiveOrganicLayout#stopped
 * @see yfiles.organic.InteractiveOrganicLayout#stop
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.stopAndWait = function() {};

/**
 * Synchronizes the structure of the graph copy with the original graph.
 * @throws {Stubs.Exceptions.InvalidOperationError} if the currently handled graph is not of type {\@link yfiles.layout.CopiedLayoutGraph}
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.syncStructure = function() {};

/**
 * Wakes up the algorithm with the effect that it will restart/continue the layout calculation.
 * <p>
 * This method is useful if the layouter is {\@link yfiles.organic.InteractiveOrganicLayout#sleeping sleeping} but should be notified of changes (e.g. due to user interaction).
 * </p>
 * @see yfiles.organic.InteractiveOrganicLayout#sleeping
 * @return {void}
 */
yfiles.organic.InteractiveOrganicLayout.prototype.wakeUp = function() {};
/**
 * @record
 * @struct
 */
yfiles.organic.OrganicLayout = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.organic.OrganicLayout.EDGE_DIRECTEDNESS_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.organic.OrganicLayout.AFFECTED_NODES_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<yfiles.organic.GroupNodeMode>} */
yfiles.organic.OrganicLayout.GROUP_NODE_MODE_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.organic.OrganicLayout.PREFERRED_EDGE_LENGTH_DP_KEY;
 /** @type {number} */
yfiles.organic.OrganicLayout.prototype.groupNodeCompactness;
 /** @type {boolean} */
yfiles.organic.OrganicLayout.prototype.automaticGroupNodeCompaction;
 /** @type {boolean} */
yfiles.organic.OrganicLayout.prototype.clusterNodes;
 /** @type {number} */
yfiles.organic.OrganicLayout.prototype.clusteringQuality;
 /** @type {boolean} */
yfiles.organic.OrganicLayout.prototype.considerNodeLabels;
 /** @type {?} */
yfiles.organic.OrganicLayout.prototype.groupBoundsCalculator;
 /** @type {boolean} */
yfiles.organic.OrganicLayout.prototype.smartComponentLayout;
 /** @type {boolean} */
yfiles.organic.OrganicLayout.prototype.nodeEdgeOverlapAvoided;
 /** @type {boolean} */
yfiles.organic.OrganicLayout.prototype.orientationLayoutEnabled;
 /** @type {number} */
yfiles.organic.OrganicLayout.prototype.qualityTimeRatio;
 /** @type {number} */
yfiles.organic.OrganicLayout.prototype.maximumDuration;
 /** @type {yfiles.organic.Scope} */
yfiles.organic.OrganicLayout.prototype.scope;
 /** @type {yfiles.organic.ChainSubstructureStyle} */
yfiles.organic.OrganicLayout.prototype.chainSubstructureStyle;
 /** @type {yfiles.organic.CycleSubstructureStyle} */
yfiles.organic.OrganicLayout.prototype.cycleSubstructureStyle;
 /** @type {yfiles.organic.ParallelSubstructureStyle} */
yfiles.organic.OrganicLayout.prototype.parallelSubstructureStyle;
 /** @type {yfiles.organic.StarSubstructureStyle} */
yfiles.organic.OrganicLayout.prototype.starSubstructureStyle;
 /** @type {number} */
yfiles.organic.OrganicLayout.prototype.compactnessFactor;
 /** @type {number} */
yfiles.organic.OrganicLayout.prototype.preferredEdgeLength;
 /** @type {number} */
yfiles.organic.OrganicLayout.prototype.preferredMinimumNodeToEdgeDistance;
 /** @type {boolean} */
yfiles.organic.OrganicLayout.prototype.considerNodeSizes;
 /** @type {boolean} */
yfiles.organic.OrganicLayout.prototype.deterministic;
 /** @type {number} */
yfiles.organic.OrganicLayout.prototype.minimumNodeDistance;
 /** @type {boolean} */
yfiles.organic.OrganicLayout.prototype.nodeOverlapsAllowed;
 /** @type {!yfiles.organic.OutputRestriction} */
yfiles.organic.OrganicLayout.prototype.outputRestriction;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.OrganicLayout.$class;

/**
 * Configures the given {\@link yfiles.layout.ComponentLayout} to take fixed nodes in components into account.
 * <p>
 * Components that contain fixed nodes will not be rearranged.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.organic.OrganicLayout#applyLayout} before the actual layout is calculated. It may be
 * overridden in order to manually configure the {\@link yfiles.layout.ComponentLayout}.
 * </p>
 * @see yfiles.organic.OrganicLayout#smartComponentLayout
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.layout.ComponentLayout} layouter the {\@link } instance to reconfigure
 * @return {void}
 */
yfiles.organic.OrganicLayout.prototype.configureComponentLayout = function(graph, layouter) {};

/**
 * Disposes of the {\@link yfiles.layout.ComponentLayout} instance.
 * <p>
 * This method is called by {\@link yfiles.organic.OrganicLayout#applyLayout} after the actual layout is calculated. It may be
 * overridden in order to revert a custom configuration made in {\@link yfiles.organic.OrganicLayout#configureComponentLayout}.
 * </p>
 * @see yfiles.organic.OrganicLayout#smartComponentLayout
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.layout.ComponentLayout} layouter the {\@link } to reset
 * @return {void}
 */
yfiles.organic.OrganicLayout.prototype.disposeComponentLayout = function(graph, layouter) {};
/**
 * @record
 * @struct
 */
yfiles.organic.OrganicPartitionGridLayoutStage = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.organic.OrganicPartitionGridLayoutStage.$class;
/**
 * @record
 * @struct
 */
yfiles.organic.OrganicRemoveOverlapsStage = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.organic.OrganicRemoveOverlapsStage.FIXED_NODE_DP_KEY;
 /** @type {number} */
yfiles.organic.OrganicRemoveOverlapsStage.prototype.maximumDuration;
 /** @type {number} */
yfiles.organic.OrganicRemoveOverlapsStage.prototype.minimumNodeDistance;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.OrganicRemoveOverlapsStage.$class;
/**
 * @record
 * @struct
 */
yfiles.organic.OutputRestriction = function() {};
 /** @type {!yfiles.organic.OutputRestriction} */
yfiles.organic.OutputRestriction.NONE;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.OutputRestriction.$class;

/**
 * Creates an {\@link yfiles.organic.OutputRestriction} that confines the layout result to a rectangular area which roughly complies
 * with the given <em>aspect ratio</em>.
 * <p>
 * The aspect ratio is defined as the ratio between the width and the height of a layout.
 * </p>
 * <ul>
 * <li>aspect ratio 1: width and height of the layout should be equal</li>
 * <li>aspect ratio between 0 and 1: the height of a layout should be greater than its width</li>
 * <li>aspect ratio larger than 1: the width of a layout should be greater than its height</li>
 * </ul>
 * <p>
 * The aspect ratio needs to be strictly positive.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given aspect ratio is <code>0</code> or negative
 * @see yfiles.organic.OrganicLayout#outputRestriction
 * @see yfiles.organic.InteractiveOrganicLayout#outputRestriction
 * @param {number} ratio the preferred aspect ratio of the output
 * @return {!yfiles.organic.OutputRestriction} an {\@link } imposing the given aspect ratio on the layout
 */
yfiles.organic.OutputRestriction.createAspectRatioRestriction = function(ratio) {};

/**
 * Creates an {\@link yfiles.organic.OutputRestriction} that confines the layout result to a circle.
 * <p>
 * The actual <em>restriction circle</em> is defined by the given coordinates and radius.
 * </p>
 * <p>
 * The radius of the restriction circle needs to be greater than zero.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given radius is less than or equal to zero
 * @see yfiles.organic.OrganicLayout#outputRestriction
 * @see yfiles.organic.InteractiveOrganicLayout#outputRestriction
 * @param {number} x the x-coordinate of the restriction circle's center
 * @param {number} y the y-coordinate of the restriction circle's center
 * @param {number} radius the radius of the restriction circle
 * @return {!yfiles.organic.OutputRestriction} the {\@link } confining the layout to a circular area
 */
yfiles.organic.OutputRestriction.createCircularCageRestriction = function(x, y, radius) {};

/**
 * Creates an {\@link yfiles.organic.OutputRestriction} that confines the layout result to an elliptical area.
 * <p>
 * The <em>restriction ellipse</em> is defined by its bounding box specified by the given coordinates and size values.
 * </p>
 * <p>
 * The main axes of the ellipse are parallel to the coordinate axes.
 * </p>
 * <p>
 * The values for height and width of the ellipse's bounding box need to be greater than zero.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given width or height is <code>0</code> or negative
 * @see yfiles.organic.OrganicLayout#outputRestriction
 * @see yfiles.organic.InteractiveOrganicLayout#outputRestriction
 * @param {number} x the x-coordinate of the bounding box's upper left corner
 * @param {number} y the y-coordinate of the bounding box's upper left corner
 * @param {number} w the width of the bounding box
 * @param {number} h the height of the bounding box
 * @return {!yfiles.organic.OutputRestriction} the {\@link } confining the layout to an elliptical area
 */
yfiles.organic.OutputRestriction.createEllipticalCageRestriction = function(x, y, w, h) {};

/**
 * Creates an {\@link yfiles.organic.OutputRestriction} that confines the layout to a rectangular area.
 * <p>
 * This <em>restriction rectangle</em> is defined by the given coordinates and size values.
 * </p>
 * <p>
 * The values for height and width of the rectangle need to be greater than zero.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given width or height is less than or equal to zero
 * @see yfiles.organic.OrganicLayout#outputRestriction
 * @see yfiles.organic.InteractiveOrganicLayout#outputRestriction
 * @param {number} x the x-coordinate of the restriction rectangle's upper-left corner
 * @param {number} y the y-coordinate of the restriction rectangle's upper-left corner
 * @param {number} w width of the restriction rectangle
 * @param {number} h height of the restriction rectangle
 * @return {!yfiles.organic.OutputRestriction} the {\@link } confining the layout to a rectangular area
 */
yfiles.organic.OutputRestriction.createRectangularCageRestriction = function(x, y, w, h) {};
/**
 * @record
 * @struct
 */
yfiles.organic.RecursiveShuffleLayout = function() {};
 /** @type {?} */
yfiles.organic.RecursiveShuffleLayout.prototype.groupBoundsCalculator;
 /** @type {?} */
yfiles.organic.RecursiveShuffleLayout.prototype.shuffleLayout;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.RecursiveShuffleLayout.$class;
/**
 * @record
 * @struct
 */
yfiles.organic.RemoveOverlapsStage = function() {};
 /** @type {number} */
yfiles.organic.RemoveOverlapsStage.prototype.minimumNodeDistance;
 /** @type {?} */
yfiles.organic.RemoveOverlapsStage.prototype.coreLayout;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.RemoveOverlapsStage.$class;

/**
 * Removes node overlaps and displaces nodes of the given graph such that they keep the specified {\@link yfiles.organic.RemoveOverlapsStage#minimumNodeDistance minimum distance} to each
 * other.
 * <p>
 * If a {\@link yfiles.organic.RemoveOverlapsStage#coreLayout core layout algorithm} is specified, it will be executed first.
 * </p>
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.organic.RemoveOverlapsStage.prototype.applyLayout = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.organic.SplitEdgeStage = function() {};
 /** @type {!Object} */
yfiles.organic.SplitEdgeStage.prototype.affectedEdgesDpKey;
 /** @type {!Object} */
yfiles.organic.SplitEdgeStage.prototype.splitNodesDpKey;
 /** @type {number} */
yfiles.organic.SplitEdgeStage.prototype.splitSegmentLength;
 /** @type {number} */
yfiles.organic.SplitEdgeStage.prototype.splitNodeSize;
 /** @type {?} */
yfiles.organic.SplitEdgeStage.prototype.coreLayout;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.SplitEdgeStage.$class;

/**
 * Replaces the edges of the given graph by a path of split-edges, executes the {\@link yfiles.organic.SplitEdgeStage#coreLayout core layout algorithm} and restores the
 * original edges, introducing bends at the locations of the split-nodes.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.organic.SplitEdgeStage.prototype.applyLayout = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.organic.OrganicLayoutData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.organic.OrganicLayoutData.prototype.affectedNodes;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.organic.OrganicLayoutData.prototype.preferredEdgeLengths;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.organic.OrganicLayoutData.prototype.minimumNodeDistances;
 /** @type {!yfiles.layout.ItemMapping<?, yfiles.organic.GroupNodeMode>} */
yfiles.organic.OrganicLayoutData.prototype.groupNodeModes;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.organic.OrganicLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.organic.OrganicLayoutData.prototype.abortHandler;
 /** @type {!yfiles.layout.PartitionGridData} */
yfiles.organic.OrganicLayoutData.prototype.partitionGridData;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.organic.OrganicLayoutData.prototype.edgeDirectedness;
 /** @type {!yfiles.lang.Class} */
yfiles.organic.OrganicLayoutData.$class;
/** @const */
yfiles.router = {};
/**
 * @record
 * @struct
 */
yfiles.router.ParallelEdgeRouter = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.router.ParallelEdgeRouter.AFFECTED_EDGES_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.router.ParallelEdgeRouter.LEADING_EDGE_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeList} */
yfiles.router.ParallelEdgeRouter.prototype.hiddenEdges;
 /** @type {?} */
yfiles.router.ParallelEdgeRouter.prototype.parallelEdges;
 /** @type {boolean} */
yfiles.router.ParallelEdgeRouter.prototype.directedMode;
 /** @type {boolean} */
yfiles.router.ParallelEdgeRouter.prototype.adaptiveLineDistances;
 /** @type {number} */
yfiles.router.ParallelEdgeRouter.prototype.lineDistance;
 /** @type {boolean} */
yfiles.router.ParallelEdgeRouter.prototype.joinEnds;
 /** @type {number} */
yfiles.router.ParallelEdgeRouter.prototype.absJoinEndDistance;
 /** @type {number} */
yfiles.router.ParallelEdgeRouter.prototype.relJoinEndDistance;
 /** @type {boolean} */
yfiles.router.ParallelEdgeRouter.prototype.adjustLeadingEdge;
 /** @type {!yfiles.lang.Class} */
yfiles.router.ParallelEdgeRouter.$class;

/**
 * Hides all parallel edges leaving a master edge in the graph.
 * <p>
 * {\@link yfiles.router.ParallelEdgeRouter} detects parallel edges of the given graph. From each set of parallel edges it hides all
 * but one edge from the given graph.
 * </p>
 * <p>
 * This method is called before invoking the {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm}. It may be overridden to change the selection of leading
 * edges. Hidden edges should be stored in {\@link yfiles.router.ParallelEdgeRouter#hiddenEdges} to enable un-hiding later on.
 * </p>
 * @see yfiles.router.ParallelEdgeRouter#directedMode
 * @see yfiles.router.ParallelEdgeRouter#AFFECTED_EDGES_DP_KEY
 * @protected
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {void}
 */
yfiles.router.ParallelEdgeRouter.prototype.findAndHideParallelEdges = function(graph) {};

/**
 * Assigns a layout to all parallel edges.
 * <p>
 * The layout for each parallel edge follows the layout of the master edge which was not removed from the
 * {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm}.
 * </p>
 * <p>
 * This method is called when the {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm} is finished. It may be overridden to introduce a custom routing for
 * parallel edges.
 * </p>
 * @see yfiles.router.ParallelEdgeRouter#joinEnds
 * @see yfiles.router.ParallelEdgeRouter#adaptiveLineDistances
 * @see yfiles.router.ParallelEdgeRouter#adjustLeadingEdge
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the graph after the core layout
 * @param {?} parallelEdges the map that provides all parallel edges for each master edge
 * @return {void}
 */
yfiles.router.ParallelEdgeRouter.prototype.layoutParallelEdges = function(graph, parallelEdges) {};

/** @const */
yfiles.router.Scope = {};
/** @const {number} */
yfiles.router.Scope.ROUTE_ALL_EDGES;
/** @const {number} */
yfiles.router.Scope.ROUTE_AFFECTED_EDGES;
/** @const {number} */
yfiles.router.Scope.ROUTE_EDGES_AT_AFFECTED_NODES;

/** @const */
yfiles.router.MonotonicPathRestriction = {};
/** @const {number} */
yfiles.router.MonotonicPathRestriction.NONE;
/** @const {number} */
yfiles.router.MonotonicPathRestriction.VERTICAL;
/** @const {number} */
yfiles.router.MonotonicPathRestriction.HORIZONTAL;
/** @const {number} */
yfiles.router.MonotonicPathRestriction.BOTH;
/**
 * @record
 * @struct
 */
yfiles.router.StraightLineEdgeRouter = function() {};
 /** @type {yfiles.router.Scope} */
yfiles.router.StraightLineEdgeRouter.prototype.scope;
 /** @type {!Object} */
yfiles.router.StraightLineEdgeRouter.prototype.affectedNodesDpKey;
 /** @type {!Object} */
yfiles.router.StraightLineEdgeRouter.prototype.affectedEdgesDpKey;
 /** @type {!yfiles.lang.Class} */
yfiles.router.StraightLineEdgeRouter.$class;
/**
 * @record
 * @struct
 */
yfiles.router.CellEntrance = function() {};
 /** @type {!yfiles.router.PartitionCell} */
yfiles.router.CellEntrance.prototype.cell;
 /** @type {!yfiles.router.CellEntrance} */
yfiles.router.CellEntrance.prototype.previousEntrance;
 /** @type {!yfiles.router.OrthogonalInterval} */
yfiles.router.CellEntrance.prototype.enterInterval;
 /** @type {!yfiles.layout.Direction} */
yfiles.router.CellEntrance.prototype.enterDirection;
 /** @type {number} */
yfiles.router.CellEntrance.prototype.costs;
 /** @type {number} */
yfiles.router.CellEntrance.prototype.heuristicCosts;
 /** @type {!yfiles.router.EdgeCellInfo} */
yfiles.router.CellEntrance.prototype.previousEdgeCellInfo;
 /** @type {!yfiles.lang.Class} */
yfiles.router.CellEntrance.$class;
/**
 * @record
 * @struct
 */
yfiles.router.CellSegmentInfo = function() {};
 /** @type {!yfiles.layout.Direction} */
yfiles.router.CellSegmentInfo.prototype.direction;
 /** @type {!yfiles.router.PartitionCell} */
yfiles.router.CellSegmentInfo.prototype.cell;
 /** @type {!yfiles.lang.Class} */
yfiles.router.CellSegmentInfo.$class;
/**
 * @record
 * @struct
 */
yfiles.router.Channel = function() {};
 /** @type {!yfiles.router.Interval} */
yfiles.router.Channel.prototype.widthInterval;
 /** @type {!yfiles.router.Interval} */
yfiles.router.Channel.prototype.lengthInterval;
 /** @type {boolean} */
yfiles.router.Channel.prototype.vertical;
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.router.Channel.prototype.bounds;
 /** @type {!yfiles.lang.Class} */
yfiles.router.Channel.$class;

/**
 * Adds a new {\@link yfiles.router.SegmentInfo segment info} to the {\@link yfiles.router.Channel channel}.
 * @throws {Stubs.Exceptions.ArgumentError} if the given segment has a different orientation than the other segments already contained in the channel
 * @param {!yfiles.router.SegmentInfo} segment the segment info to be added to this channel
 * @return {void}
 */
yfiles.router.Channel.prototype.addSegment = function(segment) {};

/**
 * Adds a {\@link yfiles.router.SegmentGroup segment group} to this {\@link yfiles.router.Channel channel}.
 * @param {!yfiles.router.SegmentGroup} group the segment group to be added
 * @return {void}
 */
yfiles.router.Channel.prototype.addSegmentGroup = function(group) {};

/**
 * Returns the current location that the given {\@link yfiles.router.SegmentInfo segment info} has been assigned within its {\@link yfiles.router.SegmentInfoBase#locationRange location range}.
 * @see yfiles.router.Channel#setCurrentLocation
 * @param {!yfiles.router.SegmentInfo} segmentInfo the segment info for which the current location will be returned
 * @return {number} the current location of the segment info or {\@link #NaN} if no location has been assigned before
 */
yfiles.router.Channel.prototype.getCurrentLocation = function(segmentInfo) {};

/**
 * Returns the {\@link yfiles.router.SegmentInfo segment info} with the given index in the list of segments of this {\@link yfiles.router.Channel channel}.
 * @param {number} index the index of the segment in the list of segments
 * @return {!yfiles.router.SegmentInfo} the {\@link  segment info} with the given index in the list of segments
 */
yfiles.router.Channel.prototype.getSegment = function(index) {};

/**
 * Returns the {\@link yfiles.router.SegmentGroup segment group} with the given index in this {\@link yfiles.router.Channel channel}.
 * @param {number} index the index of the segment group
 * @return {!yfiles.router.SegmentGroup} the {\@link  segment group} with the given index in this channel
 */
yfiles.router.Channel.prototype.getSegmentGroup = function(index) {};

/**
 * Returns the number of {\@link yfiles.router.SegmentInfo segment infos} in this channel.
 * @return {number} the number of segment infos in this channel
 */
yfiles.router.Channel.prototype.segmentCount = function() {};

/**
 * Returns the number of {\@link yfiles.router.SegmentGroup segment groups} in this {\@link yfiles.router.Channel channel}.
 * @return {number} the number of segment groups in this channel
 */
yfiles.router.Channel.prototype.segmentGroupCount = function() {};

/**
 * Specifies the current location that the given {\@link yfiles.router.SegmentInfo segment info} has been assigned within its {\@link yfiles.router.SegmentInfoBase#locationRange location range}.
 * <p>
 * During the distribution of the segments in the channel, different locations can be assigned but only the last one is
 * finally assigned to the {\@link yfiles.router.SegmentInfo segment info}.
 * </p>
 * @see yfiles.router.SegmentInfoBase#location
 * @param {!yfiles.router.SegmentInfo} segmentInfo the segment info for which the current location will be set
 * @param {number} location the location of the segment info within its location range
 * @return {void}
 */
yfiles.router.Channel.prototype.setCurrentLocation = function(segmentInfo, location) {};
/**
 * @record
 * @struct
 */
yfiles.router.ChannelBasedPathRouting = function() {};
 /** @type {!yfiles.router.PathSearchConfiguration} */
yfiles.router.ChannelBasedPathRouting.prototype.configuration;
 /** @type {!yfiles.lang.Class} */
yfiles.router.ChannelBasedPathRouting.$class;

/**
 * Adjusts the location assigned to a {\@link yfiles.router.SegmentInfo segment info} in the {\@link yfiles.router.Channel channel} considering the preferred alignment of the segment.
 * <p>
 * This method is called after the segments have been distributed in the channel but before the final locations of the
 * segments are assigned to the {\@link yfiles.router.SegmentInfo segment info}s.
 * </p>
 * @see yfiles.router.Channel#getCurrentLocation
 * @see yfiles.router.SegmentInfoBase#preferredAlignment
 * @protected
 * @param {!yfiles.router.Channel} channel the channel that contains the segment infos for which the alignment should be considered
 * @return {void}
 */
yfiles.router.ChannelBasedPathRouting.prototype.adjustSegmentLocations = function(channel) {};

/**
 * Calculates the locations of the {\@link yfiles.router.SegmentInfo segment infos} in the given {\@link yfiles.router.Channel channel}.
 * <p>
 * This method is called after the order of the {\@link yfiles.router.SegmentInfo segment infos} within a channel has been {\@link yfiles.router.ChannelBasedPathRouting#optimizeSegmentOrder optimized}.
 * </p>
 * @see yfiles.router.Channel#setCurrentLocation
 * @protected
 * @param {!yfiles.router.Channel} channel the channel that contains the segment infos for which the locations will be calculated
 * @return {void}
 */
yfiles.router.ChannelBasedPathRouting.prototype.calculateSegmentLocations = function(channel) {};

/**
 * Resets all {\@link yfiles.router.Channel channel} information and the reference to the {\@link yfiles.router.PathSearchConfiguration configuration}.
 * <p>
 * Afterwards, {\@link yfiles.router.ChannelBasedPathRouting} is ready to calculate paths for a new layout.
 * </p>
 * @return {void}
 */
yfiles.router.ChannelBasedPathRouting.prototype.cleanup = function() {};

/**
 * Creates a {\@link yfiles.collections.IComparer.<T> comparator} for sorting the {\@link yfiles.router.SegmentInfo}s in a {\@link yfiles.router.Channel} from left to right (for
 * vertical segments) or top to bottom (for horizontal segments), respectively.
 * <p>
 * This method is called in {\@link yfiles.router.ChannelBasedPathRouting#route} before edge segments are distributed within the
 * channels.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.YList} channels the channels whose segments will be sorted by the {\@link  comparator}
 * @param {!yfiles.router.PathSearchResult} pathSearchResult the {\@link  path search result} containing the {\@link }s with the
 * {\@link }s for which the comparator will be used
 * @param {!yfiles.router.PathSearchConfiguration} configuration the {\@link  configuration} used during this path search
 * @return {?<!Object>} a {\@link  comparator} used for sorting the {\@link }s in a {\@link  channel}
 */
yfiles.router.ChannelBasedPathRouting.prototype.createSegmentInfoComparer = function(channels, pathSearchResult, configuration) {};

/**
 * Initializes this {\@link yfiles.router.ChannelBasedPathRouting} instance for routing paths that have been found with the given
 * {\@link yfiles.router.PathSearchConfiguration configuration}.
 * <p>
 * This method must be called before the edges are {\@link yfiles.router.ChannelBasedPathRouting#route routed}.
 * </p>
 * @see yfiles.router.ChannelBasedPathRouting#route
 * @param {!yfiles.router.PathSearchConfiguration} configuration the {\@link  configuration} used for the following path routing
 * @return {void}
 */
yfiles.router.ChannelBasedPathRouting.prototype.initialize = function(configuration) {};

/**
 * Optimizes the order of the {\@link yfiles.router.SegmentInfo segments} in the given {\@link yfiles.router.Channel channel}.
 * <p>
 * After the segments in the channel have been sorted using the comparator created by method
 * {\@link yfiles.router.ChannelBasedPathRouting#createSegmentInfoComparer}, segments having a common {\@link yfiles.router.SegmentGroup} are
 * replaced by their common {\@link yfiles.router.SegmentGroup#commonSegmentInfo representative segment info}.
 * </p>
 * <p>
 * This method further improves the order of the resulting segment info list to make sure that the subsequent {\@link yfiles.router.ChannelBasedPathRouting#calculateSegmentLocations location calculation}
 * is able to respect the {\@link yfiles.router.SegmentInfoBase#locationRange location ranges} of the
 * {\@link yfiles.router.SegmentInfo}s and, if possible, the minimum edge to edge distances and possible grid constraints for the
 * segments.
 * </p>
 * @protected
 * @param {!yfiles.router.Channel} channel the channel for which the order of the {\@link }s is optimized
 * @return {void}
 */
yfiles.router.ChannelBasedPathRouting.prototype.optimizeSegmentOrder = function(channel) {};

/**
 * Routes the given edges.
 * <p>
 * Before calling this method, method {\@link yfiles.router.ChannelBasedPathRouting#initialize} must have been called.
 * </p>
 * <p>
 * As a first step, the {\@link yfiles.router.SegmentInfo}s of all edge paths are distributed to {\@link yfiles.router.Channel}s. After that,
 * the segments in each of these
 * {\@link yfiles.router.Channel}s are sorted and locations are assigned respecting the segments' location ranges by calling the
 * subsequent methods:
 * </p>
 * <ol>
 * <li>{\@link yfiles.router.ChannelBasedPathRouting#optimizeSegmentOrder}</li>
 * <li>{\@link yfiles.router.ChannelBasedPathRouting#calculateSegmentLocations}</li>
 * <li>{\@link yfiles.router.ChannelBasedPathRouting#adjustSegmentLocations}</li>
 * </ol>
 * <p>
 * Finally, the control points for the paths are calculated.
 * </p>
 * @throws {Stubs.Exceptions.InvalidOperationError} if the locations are not within the segment's location range
 * @see yfiles.router.PathSearchResult#getPath
 * @see yfiles.router.SegmentInfoBase#locationRange
 * @see yfiles.router.SegmentInfoBase#location
 * @param {!yfiles.algorithms.EdgeList} edges the {\@link  list of edges} to be routed
 * @param {!yfiles.router.PathSearchResult} pathSearchResult the {\@link  path search result} containing the {\@link } objects for the edges
 * @return {void}
 */
yfiles.router.ChannelBasedPathRouting.prototype.route = function(edges, pathSearchResult) {};

/**
 * Sorts the given list of {\@link yfiles.router.SegmentInfo}s using the given {\@link yfiles.collections.IComparer.<T> comparator}.
 * <p>
 * This method is called in {\@link yfiles.router.ChannelBasedPathRouting#route} when the edge segments are distributed within the
 * channels.
 * </p>
 * @protected
 * @param {?<!Object>} segmentInfos the list of {\@link }s to be sorted
 * @param {?<!Object>} segmentInfoComparer the comparator used for sorting the list of {\@link }s
 * @return {void}
 */
yfiles.router.ChannelBasedPathRouting.prototype.sortSegmentInfos = function(segmentInfos, segmentInfoComparer) {};
/**
 * @record
 * @struct
 */
yfiles.router.DynamicObstacleDecomposition = function() {};
 /** @type {number} */
yfiles.router.DynamicObstacleDecomposition.prototype.cutObstacleCost;
 /** @type {number} */
yfiles.router.DynamicObstacleDecomposition.prototype.unbalancedObstaclesCost;
 /** @type {number} */
yfiles.router.DynamicObstacleDecomposition.prototype.unbalancedRatioCost;
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.router.DynamicObstacleDecomposition.prototype.bounds;
 /** @type {!yfiles.lang.Class} */
yfiles.router.DynamicObstacleDecomposition.$class;

/**
 * Adds the given {\@link yfiles.router.IDecompositionListener dynamic decomposition listener} to receive {\@link yfiles.router.PartitionCell} subdivision and creation events
 * from this decomposition.
 * <p>
 * These events occur when the decomposition changes the partition by subdividing cells into sub-cells or when new cells
 * are created.
 * </p>
 * @see yfiles.router.IDecompositionListener
 * @param {?} listener the dynamic decomposition listener to add
 * @return {void}
 */
yfiles.router.DynamicObstacleDecomposition.prototype.addDynamicDecompositionListener = function(listener) {};

/**
 * Clears the partition data such that the {\@link yfiles.router.DynamicObstacleDecomposition} can be reused and {\@link yfiles.router.DynamicObstacleDecomposition#init initialized} with
 * new {\@link yfiles.router.Obstacle}s.
 * @see yfiles.router.DynamicObstacleDecomposition#init
 * @return {void}
 */
yfiles.router.DynamicObstacleDecomposition.prototype.clear = function() {};

/**
 * Notifies all registered {\@link yfiles.router.IDecompositionListener dynamic decomposition listeners} that the given {\@link yfiles.router.PartitionCell partition cell} has been created.
 * <p>
 * This method is also called in {\@link yfiles.router.DynamicObstacleDecomposition#init}.
 * </p>
 * @see yfiles.router.IDecompositionListener
 * @protected
 * @param {!yfiles.router.PartitionCell} createdCell the newly created cell
 * @return {void}
 */
yfiles.router.DynamicObstacleDecomposition.prototype.fireCreateCellEvent = function(createdCell) {};

/**
 * Notifies all registered {\@link yfiles.router.IDecompositionListener dynamic decomposition listeners} that the given {\@link yfiles.router.PartitionCell partition cell} has been finalized.
 * @see yfiles.router.IDecompositionListener
 * @protected
 * @param {!yfiles.router.PartitionCell} finalizedCell the cell that has been finalized
 * @return {void}
 */
yfiles.router.DynamicObstacleDecomposition.prototype.fireFinalizeCellEvent = function(finalizedCell) {};

/**
 * Notifies all registered {\@link yfiles.router.IDecompositionListener dynamic decomposition listeners} of a subdivision of a given {\@link yfiles.router.PartitionCell partition cell}.
 * @see yfiles.router.IDecompositionListener
 * @protected
 * @param {!yfiles.router.PartitionCell} cell the cell that has been subdivided
 * @param {?<!Object>} subCells the new sub-cells resulting from the subdivision of the given cell
 * @return {void}
 */
yfiles.router.DynamicObstacleDecomposition.prototype.fireSubdividedEvent = function(cell, subCells) {};

/**
 * Returns a list of all {\@link yfiles.router.PartitionCell}s that intersect or cover the given rectangle.
 * @param {!yfiles.algorithms.YRectangle} rect the rectangular area whose (partially) covered cells will be returned
 * @return {?<!Object>} a list of {\@link }s that (partially) cover the given rectangular area
 */
yfiles.router.DynamicObstacleDecomposition.prototype.getCells = function(rect) {};

/**
 * Returns all {\@link yfiles.router.PartitionCell partition cells} that are completely covered by the given {\@link yfiles.router.Obstacle}.
 * @param {!yfiles.router.Obstacle} obstacle the obstacle for which the covered cells will be returned
 * @return {?<!Object>} an unmodifiable list of {\@link } instances that are completely covered by the given obstacle
 */
yfiles.router.DynamicObstacleDecomposition.prototype.getCellsForObstacle = function(obstacle) {};

/**
 * Calculates the cost of a cut with respect to the geometry of the sub-cells.
 * <p>
 * The cost can take values between <code>0</code> and <code>1</code>.
 * </p>
 * <p>
 * This method is called while a {\@link yfiles.router.PartitionCell} is divided into upper and lower or left and right child cells
 * depending on the cut costs (during {\@link yfiles.router.DynamicObstacleDecomposition#getCellsForObstacle}, {\@link yfiles.router.DynamicObstacleDecomposition#getCells}
 * and {\@link yfiles.router.DynamicObstacleDecomposition#getNeighbors} methods).
 * </p>
 * @protected
 * @param {number} cut the coordinate of the cut
 * @param {number} min the left side of the subdivided cell
 * @param {number} max the right side of the subdivided cell
 * @param {number} orthogonalMin the upper side of the subdivided cell
 * @param {number} orthogonalMax the lower side of the subdivided cell
 * @return {number} the cost of a cut with respect to the geometry of the sub-cells
 */
yfiles.router.DynamicObstacleDecomposition.prototype.getGeometricCutCosts = function(cut, min, max, orthogonalMin, orthogonalMax) {};

/**
 * Returns the neighbor {\@link yfiles.router.PartitionCell partition cells} of the given cell.
 * @param {!yfiles.router.PartitionCell} cell the cell whose neighbors will be returned
 * @return {?<!Object>} the neighbor cells of the given cell
 */
yfiles.router.DynamicObstacleDecomposition.prototype.getNeighbors = function(cell) {};

/**
 * Calculates the cost of a cut with respect to the subdivided obstacles.
 * <p>
 * The cost can take values between <code>0</code> and <code>1</code>.
 * </p>
 * <p>
 * This method is called while a {\@link yfiles.router.PartitionCell} is divided into upper and lower or left and right child cells
 * depending on the cut costs (during {\@link yfiles.router.DynamicObstacleDecomposition#getCellsForObstacle}, {\@link yfiles.router.DynamicObstacleDecomposition#getCells}
 * and {\@link yfiles.router.DynamicObstacleDecomposition#getNeighbors} methods).
 * </p>
 * @protected
 * @param {number} numObstaclesInFirstHalf the number of obstacles that lie completely in the first half
 * @param {number} numObstaclesInSecondHalf the number of obstacles that lie completely in the second half
 * @param {number} numObstaclesOnCut the number of obstacles that lie on the cut
 * @return {number} the cost of a cut with respect to the subdivided obstacles
 */
yfiles.router.DynamicObstacleDecomposition.prototype.getObstacleCutCosts = function(numObstaclesInFirstHalf, numObstaclesInSecondHalf, numObstaclesOnCut) {};

/**
 * Returns all {\@link yfiles.router.Obstacle}s that cover the given {\@link yfiles.router.PartitionCell partition cell}.
 * @param {!yfiles.router.PartitionCell} cell the partition cell for which the obstacles will be returned
 * @return {?<!Object>} an unmodifiable list of {\@link } instances that cover the given cell
 */
yfiles.router.DynamicObstacleDecomposition.prototype.getObstacles = function(cell) {};

/**
 * Initializes this {\@link yfiles.router.DynamicObstacleDecomposition} instance with the given obstacles and partition bounds.
 * <p>
 * This method must be called before any other method is invoked.
 * </p>
 * @param {?<!Object>} obstacles a list of {\@link } objects
 * @param {!yfiles.algorithms.YRectangle} partitionBounds the bounds of the partition
 * @return {void}
 */
yfiles.router.DynamicObstacleDecomposition.prototype.init = function(obstacles, partitionBounds) {};

/**
 * Removes the given {\@link yfiles.router.IDecompositionListener dynamic decomposition listener} such that it no longer receives {\@link yfiles.router.PartitionCell} subdivision
 * and creation events from this decomposition.
 * @see yfiles.router.IDecompositionListener
 * @param {?} listener the dynamic decomposition listener to remove
 * @return {void}
 */
yfiles.router.DynamicObstacleDecomposition.prototype.removeDynamicDecompositionListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.router.EdgeCellInfo = function() {};
 /** @type {number} */
yfiles.router.EdgeCellInfo.prototype.bendCount;
 /** @type {yfiles.router.RoutingType} */
yfiles.router.EdgeCellInfo.prototype.type;
 /** @type {number} */
yfiles.router.EdgeCellInfo.prototype.enterSegmentIndex;
 /** @type {number} */
yfiles.router.EdgeCellInfo.prototype.exitSegmentIndex;
 /** @type {!yfiles.router.SegmentGroup} */
yfiles.router.EdgeCellInfo.prototype.enterSegmentGroup;
 /** @type {!yfiles.router.SegmentGroup} */
yfiles.router.EdgeCellInfo.prototype.exitSegmentGroup;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.router.EdgeCellInfo.prototype.edge;
 /** @type {!yfiles.router.PartitionCell} */
yfiles.router.EdgeCellInfo.prototype.cell;
 /** @type {!yfiles.router.OrthogonalInterval} */
yfiles.router.EdgeCellInfo.prototype.enterInterval;
 /** @type {!yfiles.router.OrthogonalInterval} */
yfiles.router.EdgeCellInfo.prototype.exitInterval;
 /** @type {!yfiles.layout.Direction} */
yfiles.router.EdgeCellInfo.prototype.enterDirection;
 /** @type {!yfiles.layout.Direction} */
yfiles.router.EdgeCellInfo.prototype.exitDirection;
 /** @type {!yfiles.algorithms.YList} */
yfiles.router.EdgeCellInfo.prototype.cellSegmentInfos;
 /** @type {!yfiles.lang.Class} */
yfiles.router.EdgeCellInfo.$class;
/**
 * @record
 * @struct
 */
yfiles.router.EdgeInfo = function() {};
 /** @type {boolean} */
yfiles.router.EdgeInfo.prototype.fixed;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.router.EdgeInfo.prototype.edge;
 /** @type {?<!Object>} */
yfiles.router.EdgeInfo.prototype.edgeCellInfos;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.router.EdgeInfo.prototype.strongSourcePort;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.router.EdgeInfo.prototype.strongTargetPort;
 /** @type {!yfiles.lang.Class} */
yfiles.router.EdgeInfo.$class;

/**
 * Calculates an array of {\@link yfiles.algorithms.LineSegment}s created by the {\@link yfiles.router.EdgeInfo#calculatePathPoints calculated path points}.
 * @return {!Array<!yfiles.algorithms.LineSegment>} an array of {\@link }s created by the calculated path points
 */
yfiles.router.EdgeInfo.prototype.calculateLineSegments = function() {};

/**
 * Calculates a list of {\@link yfiles.algorithms.YPoint}s containing the source port, bend and target port locations.
 * @return {!yfiles.algorithms.YList} a list of {\@link }s containing the source port, bend and target port locations
 */
yfiles.router.EdgeInfo.prototype.calculatePathPoints = function() {};

/**
 * Returns the {\@link yfiles.router.EdgeCellInfo} of the given {\@link yfiles.router.CellEntrance} in the path.
 * @param {!yfiles.router.CellEntrance} entrance the entrance for which the {\@link } will be returned
 * @return {!yfiles.router.EdgeCellInfo} the {\@link } of the given {\@link } in the path
 */
yfiles.router.EdgeInfo.prototype.getEdgeCellInfo = function(entrance) {};

/**
 * Returns the {\@link yfiles.router.SegmentInfo} of the segment following the segment of the given {\@link yfiles.router.SegmentInfo}.
 * @param {!yfiles.router.SegmentInfo} segment the segment info for which the next segment info will be returned
 * @return {!yfiles.router.SegmentInfo} the segment info of the segment following the segment of the given segment info
 */
yfiles.router.EdgeInfo.prototype.getNextSegment = function(segment) {};

/**
 * Returns the {\@link yfiles.router.SegmentInfo} of the segment preceding the segment of the given {\@link yfiles.router.SegmentInfo}.
 * @param {!yfiles.router.SegmentInfo} segment the segment info for which the previous segment info will be returned
 * @return {!yfiles.router.SegmentInfo} the segment info of the segment preceding the segment of the given segment info
 */
yfiles.router.EdgeInfo.prototype.getPreviousSegment = function(segment) {};

/**
 * Returns the {\@link yfiles.router.SegmentInfo} of the edge segment with the given index.
 * @param {number} segmentIndex the index of the edge segment for which the segment info will be returned
 * @return {!yfiles.router.SegmentInfo} the {\@link } of the edge segment with the given index
 */
yfiles.router.EdgeInfo.prototype.getSegmentInfo = function(segmentIndex) {};

/**
 * Returns the number of segments of the edge.
 * @return {number} the number of segments of the edge
 */
yfiles.router.EdgeInfo.prototype.segmentCount = function() {};
/**
 * @record
 * @struct
 */
yfiles.router.EdgeLayoutDescriptor = function() {};
 /** @type {number} */
yfiles.router.EdgeLayoutDescriptor.prototype.minimumFirstSegmentLength;
 /** @type {number} */
yfiles.router.EdgeLayoutDescriptor.prototype.minimumLastSegmentLength;
 /** @type {number} */
yfiles.router.EdgeLayoutDescriptor.prototype.minimumEdgeToEdgeDistance;
 /** @type {number} */
yfiles.router.EdgeLayoutDescriptor.prototype.minimumNodeCornerDistance;
 /** @type {yfiles.router.MonotonicPathRestriction} */
yfiles.router.EdgeLayoutDescriptor.prototype.monotonicPathRestriction;
 /** @type {!yfiles.router.PenaltySettings} */
yfiles.router.EdgeLayoutDescriptor.prototype.penaltySettings;
 /** @type {!yfiles.lang.Class} */
yfiles.router.EdgeLayoutDescriptor.$class;

/**
 * Creates a copy of this {\@link yfiles.router.EdgeLayoutDescriptor} instance.
 * @return {!yfiles.router.EdgeLayoutDescriptor} a copy of this {\@link } instance
 */
yfiles.router.EdgeLayoutDescriptor.prototype.createCopy = function() {};
/**
 * @record
 * @struct
 */
yfiles.router.EdgeRouter = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.router.EdgeLayoutDescriptor>} */
yfiles.router.EdgeRouter.EDGE_LAYOUT_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.ILabelLayoutDpKey<number>} */
yfiles.router.EdgeRouter.LABEL_CROSSING_PENALTY_FACTOR_DP_KEY;
 /** @type {number} */
yfiles.router.EdgeRouter.prototype.maximumDuration;
 /** @type {!yfiles.router.EdgeLayoutDescriptor} */
yfiles.router.EdgeRouter.prototype.defaultEdgeLayoutDescriptor;
 /** @type {boolean} */
yfiles.router.EdgeRouter.prototype.polylineRouting;
 /** @type {number} */
yfiles.router.EdgeRouter.prototype.preferredPolylineSegmentLength;
 /** @type {number} */
yfiles.router.EdgeRouter.prototype.maximumPolylineSegmentRatio;
 /** @type {boolean} */
yfiles.router.EdgeRouter.prototype.rerouting;
 /** @type {yfiles.router.Scope} */
yfiles.router.EdgeRouter.prototype.scope;
 /** @type {!Object} */
yfiles.router.EdgeRouter.prototype.affectedNodesDpKey;
 /** @type {!Object} */
yfiles.router.EdgeRouter.prototype.affectedEdgesDpKey;
 /** @type {?<!Object>} */
yfiles.router.EdgeRouter.prototype.edgeComparer;
 /** @type {boolean} */
yfiles.router.EdgeRouter.prototype.considerNodeLabels;
 /** @type {boolean} */
yfiles.router.EdgeRouter.prototype.ignoreInnerNodeLabels;
 /** @type {boolean} */
yfiles.router.EdgeRouter.prototype.considerEdgeLabels;
 /** @type {!yfiles.router.Grid} */
yfiles.router.EdgeRouter.prototype.grid;
 /** @type {number} */
yfiles.router.EdgeRouter.prototype.minimumNodeToEdgeDistance;
 /** @type {?<!Object>} */
yfiles.router.EdgeRouter.prototype.registeredPartitionExtensions;
 /** @type {?<!Object>} */
yfiles.router.EdgeRouter.prototype.registeredPathSearchExtensions;
 /** @type {!yfiles.router.GraphPartition} */
yfiles.router.EdgeRouter.prototype.partition;
 /** @type {!yfiles.lang.Class} */
yfiles.router.EdgeRouter.$class;

/**
 * Checks the sizes of the nodes to be non-zero.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} g The graph to check.
 * @return {void}
 */
yfiles.router.EdgeRouter.prototype.checkNodeSize = function(g) {};

/**
 * Removes all registered {\@link yfiles.router.IGraphPartitionExtension}s from a given {\@link yfiles.router.GraphPartition} instance.
 * <p>
 * This method is called by {\@link yfiles.router.EdgeRouter#applyLayout} after the edge routes are calculated. It may be overridden
 * in order to provide a custom implementation for cleaning up a {\@link yfiles.router.GraphPartition} instance.
 * </p>
 * @see yfiles.router.EdgeRouter#configureGraphPartition
 * @see yfiles.router.EdgeRouter#registeredPartitionExtensions
 * @protected
 * @param {!yfiles.router.GraphPartition} partition the given {\@link } instance
 * @return {void}
 */
yfiles.router.EdgeRouter.prototype.cleanUpGraphPartition = function(partition) {};

/**
 * Adds all registered {\@link yfiles.router.IGraphPartitionExtension}s instances to a given {\@link yfiles.router.GraphPartition} instance.
 * <p>
 * This method is called by {\@link yfiles.router.EdgeRouter#applyLayout} before the edge routes are calculated. It may be
 * overridden in order to adjust the configuration of the {\@link yfiles.router.GraphPartition} instance.
 * </p>
 * @see yfiles.router.EdgeRouter#registeredPartitionExtensions
 * @see yfiles.router.EdgeRouter#cleanUpGraphPartition
 * @protected
 * @param {!yfiles.router.GraphPartition} partition the given {\@link } instance
 * @return {void}
 */
yfiles.router.EdgeRouter.prototype.configureGraphPartition = function(partition) {};

/**
 * Adds all registered {\@link yfiles.router.PathSearchExtension}s to a given {\@link yfiles.router.PathSearch} instance.
 * <p>
 * This method is called by {\@link yfiles.router.EdgeRouter#applyLayout} before the edge routes are calculated. It may be
 * overridden in order to adjust the configuration of a {\@link yfiles.router.PathSearch} instance.
 * </p>
 * @see yfiles.router.EdgeRouter#createPathSearch
 * @see yfiles.router.EdgeRouter#registeredPathSearchExtensions
 * @protected
 * @param {!yfiles.router.PathSearch} pathSearch a {\@link } instance
 * @return {void}
 */
yfiles.router.EdgeRouter.prototype.configurePathSearch = function(pathSearch) {};

/**
 * Creates a {\@link yfiles.router.PathSearchConfiguration} that is used during the path searching process.
 * <p>
 * This method is called by {\@link yfiles.router.EdgeRouter#applyLayout} before the edge routes are calculated. It may be
 * overridden in order to create a new {\@link yfiles.router.PathSearchConfiguration} object with custom configuration.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.layout.GroupingSupport} grouping the grouping structure of the graph
 * @return {!yfiles.router.PathSearchConfiguration} a {\@link } instance
 */
yfiles.router.EdgeRouter.prototype.createConfiguration = function(graph, grouping) {};

/**
 * Creates a default {\@link yfiles.collections.IComparer.<T>} instance to determine the order of the edges according to which they will be routed.
 * <p>
 * This method is called by {\@link yfiles.router.EdgeRouter#applyLayout} before the edge routes are calculated. It may be
 * overridden in order to create a new {\@link yfiles.collections.IComparer.<T>} object with a custom configuration.
 * </p>
 * <p>
 * By default, this method returns an instance of the default implementation.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.router.PathSearchConfiguration} configuration the given configuration for the path searching process
 * @return {?<!Object>} a {\@link } instance
 */
yfiles.router.EdgeRouter.prototype.createDefaultEdgeOrderComparer = function(graph, configuration) {};

/**
 * Creates a {\@link yfiles.router.GraphPartition} instance that divides the area of the graph into several rectangles.
 * <p>
 * This implementation creates a {\@link yfiles.router.GraphPartition} using the current {\@link yfiles.router.IObstaclePartition} instance.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.router.EdgeRouter#applyLayout} before the edge routes are calculated. It may be
 * overridden in order to create a new {\@link yfiles.router.GraphPartition} object with a custom configuration.
 * </p>
 * @see yfiles.router.EdgeRouter#configureGraphPartition
 * @see yfiles.router.EdgeRouter#registeredPartitionExtensions
 * @param {?} decomposition the current {\@link }
 * @return {!yfiles.router.GraphPartition} a {\@link } instance
 */
yfiles.router.EdgeRouter.prototype.createGraphPartition = function(decomposition) {};

/**
 * Creates a {\@link yfiles.router.DynamicObstacleDecomposition} that is used by the {\@link yfiles.router.GraphPartition} to divide the
 * graph area in rectangles.
 * <p>
 * This method is called by {\@link yfiles.router.EdgeRouter#applyLayout} before the edge routes are calculated. It may be
 * overridden in order to create a new {\@link yfiles.router.DynamicObstacleDecomposition} object with custom configuration.
 * </p>
 * @see yfiles.router.EdgeRouter#createGraphPartition
 * @protected
 * @return {!yfiles.router.DynamicObstacleDecomposition} a {\@link } instance
 */
yfiles.router.EdgeRouter.prototype.createObstacleDecomposition = function() {};

/**
 * Creates a {\@link yfiles.router.ChannelBasedPathRouting} instance that routes the edges using pre-calculated {\@link yfiles.router.Path}
 * objects.
 * <p>
 * This method is called by {\@link yfiles.router.EdgeRouter#applyLayout} before the edge routes are calculated. It may be
 * overridden in order to create a new {\@link yfiles.router.ChannelBasedPathRouting} object with custom configuration.
 * </p>
 * @protected
 * @return {!yfiles.router.ChannelBasedPathRouting} a {\@link } instance
 */
yfiles.router.EdgeRouter.prototype.createPathRouting = function() {};

/**
 * Creates a {\@link yfiles.router.PathSearch} instance that finds the paths of the edges through the {\@link yfiles.router.GraphPartition}.
 * <p>
 * This method may be overridden in order to create a new {\@link yfiles.router.PathSearch} object with custom configuration.
 * </p>
 * @see yfiles.router.EdgeRouter#configurePathSearch
 * @see yfiles.router.EdgeRouter#registeredPathSearchExtensions
 * @protected
 * @return {!yfiles.router.PathSearch} a {\@link } instance
 */
yfiles.router.EdgeRouter.prototype.createPathSearch = function() {};

/**
 * Creates a {\@link yfiles.router.PathSearchContext} that provides context information for the path searching algorithm.
 * <p>
 * This method is called by {\@link yfiles.router.EdgeRouter#applyLayout} before the edge routes are calculated. It may be
 * overridden in order to create a new {\@link yfiles.router.PathSearchContext} object with custom configuration.
 * </p>
 * @protected
 * @param {!yfiles.router.PathSearch} pathSearch a given {\@link } instance
 * @param {!yfiles.router.PathSearchConfiguration} configuration a given configuration for the path searching process
 * @return {!yfiles.router.PathSearchContext} a {\@link } instance
 */
yfiles.router.EdgeRouter.prototype.createPathSearchContext = function(pathSearch, configuration) {};

/**
 * Returns the {\@link yfiles.router.EdgeLayoutDescriptor} instance for a given edge that is provided by a {\@link yfiles.algorithms.IDataProvider}
 * which is registered with the graph with key {\@link yfiles.router.EdgeRouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}.
 * <p>
 * For all those edges that do not have a specific layout descriptor assigned, the default layout descriptor returned by {\@link yfiles.router.EdgeRouter#defaultEdgeLayoutDescriptor}
 * will be assigned.
 * </p>
 * <p>
 * This method may be overridden in order to create an {\@link yfiles.router.EdgeLayoutDescriptor} with custom configuration.
 * </p>
 * @see yfiles.router.EdgeRouter#defaultEdgeLayoutDescriptor
 * @see yfiles.router.EdgeRouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @return {!yfiles.router.EdgeLayoutDescriptor} the current {\@link } instance for a given edge
 */
yfiles.router.EdgeRouter.prototype.getEdgeLayoutDescriptor = function(edge) {};

/**
 * Returns whether or not a given edge is selected.
 * <p>
 * If all the edges of the graph will be routed by {\@link yfiles.router.EdgeRouter}, i.e., the {\@link yfiles.router.EdgeRouter#scope scope} is set to
 * {\@link yfiles.router.Scope#ROUTE_ALL_EDGES}, this utility method returns <code>true</code> for all edges.
 * </p>
 * <p>
 * This method may be overridden in order to determine differently whether or not a given edge is considered to be
 * selected.
 * </p>
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {boolean} <code>true</code> if the given edge is selected, <code>false</code> otherwise
 */
yfiles.router.EdgeRouter.prototype.isAffected = function(edge, graph) {};

/** @const */
yfiles.router.Alignment = {};
/** @const {number} */
yfiles.router.Alignment.MIN;
/** @const {number} */
yfiles.router.Alignment.MAX;
/** @const {number} */
yfiles.router.Alignment.ANY;

/** @const */
yfiles.router.RoutingType = {};
/** @const {number} */
yfiles.router.RoutingType.STRAIGHT;
/** @const {number} */
yfiles.router.RoutingType.STRAIGHT_BENDING;
/** @const {number} */
yfiles.router.RoutingType.BENDING;
/** @const {number} */
yfiles.router.RoutingType.U_TURN;
/** @const {number} */
yfiles.router.RoutingType.END;
/**
 * @record
 * @struct
 */
yfiles.router.GraphPartition = function() {};
 /** @type {?} */
yfiles.router.GraphPartition.prototype.partition;
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.router.GraphPartition.prototype.bounds;
 /** @type {!yfiles.lang.Class} */
yfiles.router.GraphPartition.$class;

/**
 * Adds the given listener to the {\@link yfiles.router.GraphPartition}.
 * <p>
 * The listener will be notified upon dynamic decomposition events. If it is a {\@link yfiles.router.IGraphPartitionExtension},
 * method {\@link yfiles.router.IGraphPartitionExtension#preparePartition} is called during {\@link yfiles.router.GraphPartition#init initialization}.
 * </p>
 * @param {?} listener the listener to be added
 * @return {void}
 */
yfiles.router.GraphPartition.prototype.addDynamicDecompositionListener = function(listener) {};

/**
 * Clears the {\@link yfiles.router.GraphPartition partition} data such that the {\@link yfiles.router.GraphPartition} can be reused and {\@link yfiles.router.GraphPartition#init initialized} with a new
 * configuration.
 * <p>
 * All {\@link yfiles.router.IGraphPartitionExtension}s are {\@link yfiles.router.IGraphPartitionExtension#cleanup cleaned up}; partition listeners and obstacles are {\@link yfiles.router.GraphPartition#removeDynamicDecompositionListener removed}.
 * </p>
 * @see yfiles.router.GraphPartition#init
 * @return {void}
 */
yfiles.router.GraphPartition.prototype.clear = function() {};

/**
 * Creates and returns a new {\@link yfiles.router.Obstacle} using the given bounds and data.
 * <p>
 * All obstacles created via this method are delegated to the {\@link yfiles.router.GraphPartition#partition inner partition} upon {\@link yfiles.router.GraphPartition#init initialization}.
 * </p>
 * @param {!yfiles.algorithms.YRectangle} bounds the bounds of the obstacle
 * @param {!Object} data the additional data that should be associated with the obstacle
 * @return {!yfiles.router.Obstacle} a new {\@link } using the given bounds and data
 */
yfiles.router.GraphPartition.prototype.createObstacle = function(bounds, data) {};

/**
 * Returns a list of all {\@link yfiles.router.PartitionCell}s that intersect or cover the given rectangle by delegating to the
 * corresponding method of the {\@link yfiles.router.GraphPartition#partition inner partition}.
 * @see yfiles.router.IPartition#getCells
 * @param {!yfiles.algorithms.YRectangle} rect the rectangular area whose (partially) covered cells will be returned
 * @return {?<!Object>} a list containing (partially) covered {\@link }s
 */
yfiles.router.GraphPartition.prototype.getCells = function(rect) {};

/**
 * Returns all {\@link yfiles.router.PartitionCell}s that are completely covered by the bounds of the given node.
 * @throws {Stubs.Exceptions.ArgumentError} if the node is unknown
 * @param {!yfiles.algorithms.Node} node the node for which the covered cells will be returned
 * @return {?<!Object>} an unmodifiable list of {\@link } instances that are completely covered by the bounds of the given
 * node
 */
yfiles.router.GraphPartition.prototype.getCellsForNode = function(node) {};

/**
 * Returns a list of all
 * {\@link yfiles.router.PartitionCell}s that are neighbors of the given cell, i.e., those cells that have a common border segment
 * with the given cell.
 * @param {!yfiles.router.PartitionCell} cell the cell whose neighbors will be returned
 * @return {?<!Object>} a list of {\@link }s that are neighbors of the given cell
 */
yfiles.router.GraphPartition.prototype.getNeighbors = function(cell) {};

/**
 * Returns a list of all {\@link yfiles.algorithms.Node}s whose bounds intersect or cover the bounds of the given cell.
 * @param {!yfiles.router.PartitionCell} cell the cell
 * @return {?<!Object>} a list of {\@link }s that are intersected by the given cell
 */
yfiles.router.GraphPartition.prototype.getNodes = function(cell) {};

/**
 * Returns the {\@link yfiles.router.Obstacle} that has been created earlier for the given data object.
 * @param {!Object} data the given data for which the obstacle will be returned
 * @return {!yfiles.router.Obstacle} the {\@link } that has been created earlier for the given data object
 */
yfiles.router.GraphPartition.prototype.getObstacle = function(data) {};

/**
 * Returns all {\@link yfiles.router.Obstacle}s covering the given {\@link yfiles.router.PartitionCell} by delegating to the corresponding
 * method of the {\@link yfiles.router.GraphPartition#partition inner partition}.
 * @see yfiles.router.IObstaclePartition#getObstacles
 * @param {!yfiles.router.PartitionCell} cell the cell whose obstacles will be returned
 * @return {?<!Object>} a list of {\@link }s that cover the given cell
 */
yfiles.router.GraphPartition.prototype.getObstacles = function(cell) {};

/**
 * Initializes the {\@link yfiles.router.GraphPartition} with the given graph instance based on the given {\@link yfiles.router.PathSearchConfiguration configuration} used by path
 * search algorithms.
 * <p>
 * Before calling this method, any old partitioning information must be {\@link yfiles.router.GraphPartition#clear cleared}.
 * </p>
 * <p>
 * This initialization method calls {\@link yfiles.router.IGraphPartitionExtension#preparePartition} of all registered extensions.
 * Then, the {\@link yfiles.router.GraphPartition#partition inner delegate partition} is initialized passing all {\@link yfiles.router.GraphPartition#createObstacle added} obstacles as well as the given graph's bounds
 * extended by a small padding.
 * </p>
 * <p>
 * In the case where the {\@link yfiles.router.GraphPartition#partition delegate partition} is of type {\@link yfiles.router.IDynamicDecomposition}, this {\@link yfiles.router.GraphPartition}
 * will also be added as {\@link yfiles.router.IDecompositionListener} to it.
 * </p>
 * @see yfiles.router.GraphPartition#clear
 * @see yfiles.router.IGraphPartitionExtension#preparePartition
 * @see yfiles.router.GraphPartition#addDynamicDecompositionListener
 * @param {!yfiles.router.PathSearchConfiguration} configuration the configuration used by path search algorithms
 * @return {void}
 */
yfiles.router.GraphPartition.prototype.init = function(configuration) {};

/**
 * Re-dispatches the event of the creation of a new {\@link yfiles.router.PartitionCell} to all registered
 * {\@link yfiles.router.IDecompositionListener}s.
 * <p>
 * This method is a callback after a {\@link yfiles.router.PartitionCell} has been created.
 * </p>
 * @param {!yfiles.router.PartitionCell} createdCell the newly created {\@link }
 * @return {void}
 */
yfiles.router.GraphPartition.prototype.onCellCreated = function(createdCell) {};

/**
 * Re-dispatches the event of having completed the process of subdivisions of a given {\@link yfiles.router.PartitionCell} to all
 * registered {\@link yfiles.router.IDecompositionListener}s.
 * <p>
 * This method is a callback after a {\@link yfiles.router.PartitionCell} has been finalized and won't be further subdivided.
 * </p>
 * @param {!yfiles.router.PartitionCell} finalizedCell the cell that has been finalized
 * @return {void}
 */
yfiles.router.GraphPartition.prototype.onCellFinalized = function(finalizedCell) {};

/**
 * Re-dispatches the event of the subdivision of a given {\@link yfiles.router.PartitionCell} into several sub-cells to all
 * registered {\@link yfiles.router.IDecompositionListener}s.
 * <p>
 * This method is a callback after a {\@link yfiles.router.PartitionCell} has been subdivided into several sub-cells.
 * </p>
 * @param {!yfiles.router.PartitionCell} cell the cell that has been subdivided
 * @param {?<!Object>} subCells the sub-cells resulting from the subdivision of the given {\@link }
 * @return {void}
 */
yfiles.router.GraphPartition.prototype.onCellSubdivided = function(cell, subCells) {};

/**
 * Removes the given listener from the {\@link yfiles.router.GraphPartition}.
 * <p>
 * The listener will not be notified of dynamic decomposition events anymore.
 * </p>
 * @param {?} listener the listener to be removed
 * @return {void}
 */
yfiles.router.GraphPartition.prototype.removeDynamicDecompositionListener = function(listener) {};
/**
 * @record
 * @struct
 */
yfiles.router.GraphPartitionExtensionAdapter = function() {};
 /** @type {!yfiles.router.GraphPartition} */
yfiles.router.GraphPartitionExtensionAdapter.prototype.graphPartition;
 /** @type {!yfiles.router.PathSearchConfiguration} */
yfiles.router.GraphPartitionExtensionAdapter.prototype.configuration;
 /** @type {!yfiles.lang.Class} */
yfiles.router.GraphPartitionExtensionAdapter.$class;

/**
 *
 * @return {void}
 */
yfiles.router.GraphPartitionExtensionAdapter.prototype.cleanup = function() {};

/**
 *
 * @param {!yfiles.router.PartitionCell} createdCell
 * @return {void}
 */
yfiles.router.GraphPartitionExtensionAdapter.prototype.onCellCreated = function(createdCell) {};

/**
 *
 * @param {!yfiles.router.PartitionCell} finalizedCell
 * @return {void}
 */
yfiles.router.GraphPartitionExtensionAdapter.prototype.onCellFinalized = function(finalizedCell) {};

/**
 *
 * @param {!yfiles.router.PartitionCell} cell
 * @param {?<!Object>} subCells
 * @return {void}
 */
yfiles.router.GraphPartitionExtensionAdapter.prototype.onCellSubdivided = function(cell, subCells) {};

/**
 * Stores the given {\@link yfiles.router.PathSearchConfiguration} and {\@link yfiles.router.GraphPartition} such that they are accessible
 * through {\@link yfiles.router.GraphPartitionExtensionAdapter#configuration} and {\@link yfiles.router.GraphPartitionExtensionAdapter#graphPartition}, respectively.
 * @param {!yfiles.router.PathSearchConfiguration} configuration the configuration used for the path search
 * @param {!yfiles.router.GraphPartition} graphPartition the graph partition that uses this extension
 * @return {void}
 */
yfiles.router.GraphPartitionExtensionAdapter.prototype.preparePartition = function(configuration, graphPartition) {};
/**
 * @record
 * @struct
 */
yfiles.router.Grid = function() {};
 /** @type {number} */
yfiles.router.Grid.prototype.originX;
 /** @type {number} */
yfiles.router.Grid.prototype.originY;
 /** @type {number} */
yfiles.router.Grid.prototype.spacing;
 /** @type {!yfiles.lang.Class} */
yfiles.router.Grid.$class;
/**
 * @record
 * @struct
 */
yfiles.router.IDynamicDecomposition = function() {};

/**
 * Adds the given {\@link yfiles.router.IDecompositionListener} that will be notified of dynamic decomposition events to the
 * {\@link yfiles.router.IPartition}.
 * @abstract
 * @param {?} listener the listener to be added
 * @return {void}
 */
yfiles.router.IDynamicDecomposition.prototype.addDynamicDecompositionListener = function(listener) {};

/**
 * Removes the given {\@link yfiles.router.IDecompositionListener} from the {\@link yfiles.router.IPartition}.
 * <p>
 * The {\@link yfiles.router.IDecompositionListener} will be no more notified of dynamic decomposition events.
 * </p>
 * @abstract
 * @param {?} listener the listener to be removed
 * @return {void}
 */
yfiles.router.IDynamicDecomposition.prototype.removeDynamicDecompositionListener = function(listener) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.router.IDynamicDecomposition;
/**
 * @record
 * @struct
 */
yfiles.router.IDecompositionListener = function() {};

/**
 * Callback after the new given {\@link yfiles.router.PartitionCell} has been created.
 * @abstract
 * @param {!yfiles.router.PartitionCell} createdCell the newly created {\@link }
 * @return {void}
 */
yfiles.router.IDecompositionListener.prototype.onCellCreated = function(createdCell) {};

/**
 * Callback after the given {\@link yfiles.router.PartitionCell} has been finalized and won't be further subdivided.
 * @abstract
 * @param {!yfiles.router.PartitionCell} finalizedCell the cell that has been finalized
 * @return {void}
 */
yfiles.router.IDecompositionListener.prototype.onCellFinalized = function(finalizedCell) {};

/**
 * Callback after the given {\@link yfiles.router.PartitionCell} has been subdivided into several sub-cells.
 * <p>
 * {\@link yfiles.router.IDecompositionListener} may not modify the list of sub-cells.
 * </p>
 * @abstract
 * @param {!yfiles.router.PartitionCell} cell the cell that has been subdivided
 * @param {?<!Object>} subCells the sub-cells resulting from the subdivision of the given {\@link }
 * @return {void}
 */
yfiles.router.IDecompositionListener.prototype.onCellSubdivided = function(cell, subCells) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.router.IDecompositionListener;
/**
 * @record
 * @struct
 */
yfiles.router.IEnterIntervalCalculator = function() {};

/**
 * Appends additional enter intervals to the given list of enter intervals for moving from the {\@link yfiles.router.PartitionCell partition cell} of the
 * current {\@link yfiles.router.CellEntrance} to the neighboring cell.
 * @abstract
 * @param {!yfiles.router.CellEntrance} currentEntrance the current {\@link } that is exited
 * @param {!yfiles.router.PartitionCell} enteredCell the neighboring cell that will be entered
 * @param {!yfiles.router.OrthogonalInterval} commonInterval the common interval of the left and entered partition cells
 * @param {?<!Object>} allEnterIntervals the list to which additional enter intervals have to be appended
 * @param {!yfiles.router.PathSearchContext} context the context of the path search
 * @return {void}
 */
yfiles.router.IEnterIntervalCalculator.prototype.appendEnterIntervals = function(currentEntrance, enteredCell, commonInterval, allEnterIntervals, context) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.router.IEnterIntervalCalculator;
/**
 * @record
 * @struct
 */
yfiles.router.IGraphPartitionExtension = function() {};

/**
 * Cleans up the extension from the last partitioning with the current {\@link yfiles.router.PathSearchConfiguration configuration} and {\@link yfiles.router.GraphPartition}.
 * @abstract
 * @return {void}
 */
yfiles.router.IGraphPartitionExtension.prototype.cleanup = function() {};

/**
 * Adds a {\@link yfiles.router.IGraphPartitionExtension} to the {\@link yfiles.router.GraphPartition}.
 * <p>
 * It is called by the given {\@link yfiles.router.GraphPartition} upon initialization before its {\@link yfiles.router.IObstaclePartition}
 * is initialized. Implementations may use the graph upon which the given {\@link yfiles.router.GraphPartition} is based to
 * initialize themselves and/or to {\@link yfiles.router.GraphPartition#createObstacle add obstacles} to the list with which {\@link yfiles.router.IObstaclePartition} is initialized.
 * </p>
 * @abstract
 * @param {!yfiles.router.PathSearchConfiguration} configuration the configuration used for the path search
 * @param {!yfiles.router.GraphPartition} graphPartition the graph partition that uses this extension
 * @return {void}
 */
yfiles.router.IGraphPartitionExtension.prototype.preparePartition = function(configuration, graphPartition) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.router.IGraphPartitionExtension;
/**
 * @record
 * @struct
 */
yfiles.router.IObstaclePartition = function() {};

/**
 * Clears the partition data such that the {\@link yfiles.router.IObstaclePartition} can be reused and {\@link yfiles.router.IObstaclePartition#init initialized} with new
 * {\@link yfiles.router.Obstacle}s.
 * @see yfiles.router.IObstaclePartition#init
 * @abstract
 * @return {void}
 */
yfiles.router.IObstaclePartition.prototype.clear = function() {};

/**
 * Returns all {\@link yfiles.router.PartitionCell}s that are completely covered by the given {\@link yfiles.router.Obstacle}.
 * @abstract
 * @param {!yfiles.router.Obstacle} obstacle the obstacle for which the covered cells will be returned
 * @return {?<!Object>} an unmodifiable list of {\@link } instances that are completely covered by the given obstacle
 */
yfiles.router.IObstaclePartition.prototype.getCellsForObstacle = function(obstacle) {};

/**
 * Returns all {\@link yfiles.router.Obstacle}s that cover the given {\@link yfiles.router.PartitionCell}.
 * @abstract
 * @param {!yfiles.router.PartitionCell} cell the partition cell for which the obstacles will be returned
 * @return {?<!Object>} an unmodifiable list of {\@link } instances that cover the given cell
 */
yfiles.router.IObstaclePartition.prototype.getObstacles = function(cell) {};

/**
 * Initializes a new {\@link yfiles.router.IObstaclePartition} of the area with the given bounds using the given list of
 * {\@link yfiles.router.Obstacle}s.
 * <p>
 * Unused partitions must be cleared using method {\@link yfiles.router.IObstaclePartition#clear}.
 * </p>
 * @see yfiles.router.IObstaclePartition#clear
 * @abstract
 * @param {?<!Object>} obstacles a list of {\@link }s that have to be considered by the partition
 * @param {!yfiles.algorithms.YRectangle} bounds the bounds of the partition
 * @return {void}
 */
yfiles.router.IObstaclePartition.prototype.init = function(obstacles, bounds) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.router.IObstaclePartition;
/**
 * @record
 * @struct
 */
yfiles.router.IPartition = function() {};
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.router.IPartition.prototype.bounds;

/**
 * Returns a list of all {\@link yfiles.router.PartitionCell}s that intersect or cover the given rectangle.
 * @abstract
 * @param {!yfiles.algorithms.YRectangle} rect the rectangular area whose (partially) covered cells will be returned
 * @return {?<!Object>} a list of {\@link }s that (partially) cover the given rectangular area
 */
yfiles.router.IPartition.prototype.getCells = function(rect) {};

/**
 * Returns a list of all
 * {\@link yfiles.router.PartitionCell}s that are neighbors of the given cell, i.e., those cells that have a common border segment
 * with the given cell.
 * @abstract
 * @param {!yfiles.router.PartitionCell} cell the cell whose neighbors will be returned
 * @return {?<!Object>} a list of {\@link }s that are neighbors of the given cell
 */
yfiles.router.IPartition.prototype.getNeighbors = function(cell) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.router.IPartition;
/**
 * @record
 * @struct
 */
yfiles.router.Interval = function() {};
 /** @type {number} */
yfiles.router.Interval.prototype.min;
 /** @type {number} */
yfiles.router.Interval.prototype.max;
 /** @type {number} */
yfiles.router.Interval.prototype.center;
 /** @type {number} */
yfiles.router.Interval.prototype.size;
 /** @type {!yfiles.lang.Class} */
yfiles.router.Interval.$class;

/**
 * Returns the bridging {\@link yfiles.router.Interval interval} between the given {\@link yfiles.router.Interval intervals}.
 * <p>
 * The bridging interval is <code>null</code> if the given intervals intersect each other. Otherwise, the bridging interval is
 * <code>[minimum of upper bounds, maximum of lower bounds]</code>.
 * </p>
 * @param {!yfiles.router.Interval} i1 the first interval
 * @param {!yfiles.router.Interval} i2 the second interval
 * @return {!yfiles.router.Interval} the bridging interval between the given intervals or <code>null</code> if the intervals intersect
 */
yfiles.router.Interval.calculateBridge = function(i1, i2) {};

/**
 * Returns the intersection of the given {\@link yfiles.router.Interval intervals}.
 * <p>
 * The intersection is <code>null</code> if the given intervals do not intersect each other. Otherwise, the intersection is
 * <code>[maximum of lower bounds, minimum of upper bounds]</code>.
 * </p>
 * @param {!yfiles.router.Interval} i1 the first interval
 * @param {!yfiles.router.Interval} i2 the second interval
 * @return {!yfiles.router.Interval} the intersection of the given intervals or <code>null</code> if the intervals do not intersect
 */
yfiles.router.Interval.calculateIntersection = function(i1, i2) {};

/**
 * Returns the spanning rectangle between the given {\@link yfiles.router.Interval intervals}.
 * <p>
 * The first interval spans the rectangle in horizontal dimension, the second interval in vertical dimension.
 * </p>
 * @param {!yfiles.router.Interval} horizontal the interval that defines the location and length of the rectangle in horizontal dimension
 * @param {!yfiles.router.Interval} vertical the interval that defines the location and length of the rectangle in vertical dimension
 * @return {!yfiles.algorithms.YRectangle} the spanning rectangle between the given intervals
 */
yfiles.router.Interval.calculateSpanningRectangle = function(horizontal, vertical) {};

/**
 * Returns the union of the given {\@link yfiles.router.Interval intervals} and the given value.
 * <p>
 * The union is between the minimum of the lower bound of the given interval and the given value and the maximum of the
 * upper bound of the given interval and the given value.
 * </p>
 * Returns the union of the given {\@link yfiles.router.Interval intervals}.
 * <p>
 * The union is <code>[minimum of lower bounds, maximum of upper bounds]</code>.
 * </p>
 * @param {!yfiles.router.Interval} interval_or_i1 the interval to be extended / the first interval
 * @param {number|!yfiles.router.Interval} value_or_i2 the value to be in the union / the second interval
 * @return {!yfiles.router.Interval} the union of the given interval and the given value / the union of the given intervals
 */
yfiles.router.Interval.calculateUnion = function(interval_or_i1, value_or_i2) {};

/**
 * Checks whether or not the given value lies within the interval.
 * @param {number} value the value to check
 * @return {boolean} <code>true</code> if the value lies within the interval, <code>false</code> otherwise
 */
yfiles.router.Interval.prototype.contains = function(value) {};

/**
 * Checks whether or not the given {\@link yfiles.router.Interval interval} fully covers this {\@link yfiles.router.Interval interval} given a small epsilon value.
 * <p>
 * The given interval covers this interval, if <code>other lower bound - epsilon &lt;= this lower bound</code> and
 * <code>this upper bound &lt;= other upper bound + epsilon</code>.
 * </p>
 * @param {!yfiles.router.Interval} other the other interval
 * @param {number=} eps
 * @return {boolean} <code>true</code> if this interval is fully covered by the other interval, <code>false</code> otherwise
 */
yfiles.router.Interval.prototype.coveredBy = function(other, eps) {};

/**
 * Returns the distance between this {\@link yfiles.router.Interval interval} and the given {\@link yfiles.router.Interval interval}.
 * <p>
 * If the intervals {\@link yfiles.router.Interval#intersects intersect}, the distance is <code>0</code>. Otherwise, it is equal to
 * <code>dist(minimum of upper bounds, maximum of lower bounds)</code>.
 * </p>
 * Returns the distance between the value and this {\@link yfiles.router.Interval interval}.
 * <p>
 * If this interval contains the specified value, the distance is <code>0</code>. Otherwise, it is the minimum of <code>dist(value, lower bound)</code>
 * and <code>dist(value, upper bound)</code>.
 * </p>
 * @param {!yfiles.router.Interval|number} other_or_value the other interval to which the distance is calculated / the value to which the distance is calculated
 * @return {number} the distance between this interval and the given interval / the distance between the value and the interval
 */
yfiles.router.Interval.prototype.distanceTo = function(other_or_value) {};

/**
 * Returns the {\@link yfiles.router.Interval interval} bound that is closest to the given value.
 * @param {number} value the value for which the closest interval bound will be returned
 * @return {number} 
 * <ul>
 * <li>the <code>value</code>, if the given value lies within the interval, or</li>
 * <li>the lower bound, if the given value is smaller than or equal to the lower bound, or</li>
 * <li>the upper bound, if the given value is greater than or equal to the upper bound</li>
 * </ul>
 */
yfiles.router.Interval.prototype.getClosest = function(value) {};

/**
 * Checks whether or not this {\@link yfiles.router.Interval interval} and the given {\@link yfiles.router.Interval interval} cover the same range.
 * <p>
 * The intervals are considered to cover the same range, if their minimum values as well as their maximum values differ
 * only in the given epsilon value.
 * </p>
 * @param {!yfiles.router.Interval} other the other interval
 * @param {number=} eps
 * @return {boolean} <code>true</code> if the intervals cover the same range, <code>false</code> otherwise
 */
yfiles.router.Interval.prototype.hasSameRange = function(other, eps) {};

/**
 * Checks whether or not this {\@link yfiles.router.Interval interval} intersects with the given
 * {\@link yfiles.router.Interval interval}, considering the given minimum intersection length.
 * @param {!yfiles.router.Interval} other the other interval to check
 * @param {number=} minIntersection
 * @return {boolean} <code>true</code> if the intervals intersect at least by the given minimum length, <code>false</code> otherwise
 */
yfiles.router.Interval.prototype.intersects = function(other, minIntersection) {};

/**
 * Checks whether or not the lower bound of this {\@link yfiles.router.Interval interval} is greater than the upper bound of the given interval.
 * @param {!yfiles.router.Interval} other the interval to compare
 * @return {boolean} <code>true</code> if the current interval is on the right of the given one, <code>false</code> otherwise
 */
yfiles.router.Interval.prototype.isGreaterThan = function(other) {};

/**
 * Checks whether or not the upper bound of this {\@link yfiles.router.Interval interval} is smaller than the lower bound of the given interval.
 * @param {!yfiles.router.Interval} other the interval to compare
 * @return {boolean} <code>true</code> if the current interval is on the left of the given one, <code>false</code> otherwise
 */
yfiles.router.Interval.prototype.isLessThan = function(other) {};
/**
 * @record
 * @struct
 */
yfiles.router.Obstacle = function() {};
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.router.Obstacle.prototype.bounds;
 /** @type {!Object} */
yfiles.router.Obstacle.prototype.data;
 /** @type {!yfiles.lang.Class} */
yfiles.router.Obstacle.$class;
/**
 * @record
 * @struct
 */
yfiles.router.OrthogonalInterval = function() {};
 /** @type {boolean} */
yfiles.router.OrthogonalInterval.prototype.vertical;
 /** @type {number} */
yfiles.router.OrthogonalInterval.prototype.min;
 /** @type {number} */
yfiles.router.OrthogonalInterval.prototype.max;
 /** @type {number} */
yfiles.router.OrthogonalInterval.prototype.size;
 /** @type {!yfiles.router.Interval} */
yfiles.router.OrthogonalInterval.prototype.range;
 /** @type {number} */
yfiles.router.OrthogonalInterval.prototype.location;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.router.OrthogonalInterval.prototype.center;
 /** @type {!yfiles.lang.Class} */
yfiles.router.OrthogonalInterval.$class;

/**
 * Calculates the intersection of the given {\@link yfiles.router.OrthogonalInterval orthogonal intervals}.
 * <p>
 * If the returned orthogonal interval is vertical, it will have the same horizontal location as <code>i2</code> and the shared vertical
 * range of both intervals. If it is horizontal, it will have the same vertical location as <code>i2</code> and the shared horizontal
 * range of both intervals. The orthogonal intervals must have same orientation.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the orthogonal intervals have different orientations
 * @see yfiles.router.OrthogonalInterval#intersects
 * @param {!yfiles.router.OrthogonalInterval} i1 the first orthogonal interval
 * @param {!yfiles.router.OrthogonalInterval} i2 the second orthogonal interval
 * @return {!yfiles.router.OrthogonalInterval} the shared orthogonal interval of both given orthogonal intervals
 */
yfiles.router.OrthogonalInterval.calculateIntersection = function(i1, i2) {};

/**
 * Calculates the union of the given {\@link yfiles.router.OrthogonalInterval orthogonal intervals}.
 * <p>
 * If the returned orthogonal interval is vertical, it will have the same horizontal location as <code>i2</code> and the shared vertical
 * range of both orthogonal intervals. If it is horizontal, it will have the same vertical location as <code>i2</code> and the shared
 * vertical range of both orthogonal intervals. The orthogonal intervals must have same orientation.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the orthogonal intervals have different orientations
 * @see yfiles.router.OrthogonalInterval#intersects
 * @param {!yfiles.router.OrthogonalInterval} i1 the first orthogonal interval
 * @param {!yfiles.router.OrthogonalInterval} i2 the second orthogonal interval
 * @return {!yfiles.router.OrthogonalInterval} the union of both given orthogonal intervals
 */
yfiles.router.OrthogonalInterval.calculateUnion = function(i1, i2) {};

/**
 * Checks whether or not this {\@link yfiles.router.OrthogonalInterval orthogonal interval} is fully covered by the given {\@link yfiles.router.OrthogonalInterval orthogonal interval}.
 * <p>
 * The given orthogonal interval covers this orthogonal interval, if this interval's range is covered by the given
 * interval's range. The location of both orthogonal intervals is ignored. The orthogonal intervals must have the same
 * orientation.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the orthogonal intervals have different orientations
 * @see yfiles.router.PartitionCell
 * @param {!yfiles.router.OrthogonalInterval} other the other orthogonal interval
 * @return {boolean} <code>true</code> if this orthogonal interval is fully covered by the other orthogonal interval, <code>false</code> otherwise
 */
yfiles.router.OrthogonalInterval.prototype.coveredBy = function(other) {};

/**
 * Determines whether or not this {\@link yfiles.router.OrthogonalInterval orthogonal interval} crosses the given one.
 * <p>
 * The orthogonal intervals must have different orientations.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the given orthogonal intervals have the same orientation
 * @param {!yfiles.router.OrthogonalInterval} other the other orthogonal interval
 * @return {boolean} <code>true</code> if this orthogonal interval crosses the given one, <code>false</code> otherwise
 */
yfiles.router.OrthogonalInterval.prototype.crosses = function(other) {};

/**
 * Returns the distance of the {\@link yfiles.router.OrthogonalInterval#range ranges} of this {\@link yfiles.router.OrthogonalInterval orthogonal interval} and the given {\@link yfiles.router.OrthogonalInterval orthogonal interval}.
 * <p>
 * The orthogonal intervals must have the same orientation.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the orthogonal intervals have different orientations
 * @param {!yfiles.router.OrthogonalInterval} other the other orthogonal interval
 * @return {number} <code>0</code> if the orthogonal intervals {\@link #intersects intersect} each other, otherwise the minimal distance between the orthogonal intervals is
 * returned
 */
yfiles.router.OrthogonalInterval.prototype.distanceTo = function(other) {};

/**
 * Checks whether or not this {\@link yfiles.router.OrthogonalInterval orthogonal interval} and the given {\@link yfiles.router.OrthogonalInterval orthogonal interval} cover the same range.
 * <p>
 * If both orthogonal intervals cover the same range, they are considered the same. The location of both orthogonal
 * intervals is ignored. The orthogonal intervals must have the same orientation.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the orthogonal intervals have different orientations
 * @see yfiles.router.PartitionCell
 * @param {!yfiles.router.OrthogonalInterval} other the other orthogonal interval
 * @return {boolean} <code>true</code> if the orthogonal intervals cover the same range, <code>false</code> otherwise
 */
yfiles.router.OrthogonalInterval.prototype.hasSameRange = function(other) {};

/**
 * Checks whether or not this {\@link yfiles.router.OrthogonalInterval orthogonal interval} intersects the given {\@link yfiles.router.OrthogonalInterval orthogonal interval} and the intersection has a given
 * minimum intersection size.
 * <p>
 * Orthogonal intervals intersect each other, if their ranges intersect each other by at least the given minimum
 * intersection size. The location of both orthogonal intervals is ignored. The orthogonal intervals must have the same
 * orientation.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if the orthogonal intervals have different orientations
 * @see yfiles.router.PartitionCell
 * @param {!yfiles.router.OrthogonalInterval} other the other orthogonal interval
 * @param {number=} minIntersection
 * @return {boolean} <code>true</code> if this interval intersects the given other orthogonal interval, <code>false</code> otherwise
 */
yfiles.router.OrthogonalInterval.prototype.intersects = function(other, minIntersection) {};

/**
 * Returns the Manhattan distance of this {\@link yfiles.router.OrthogonalInterval orthogonal interval} and the given {\@link yfiles.router.OrthogonalInterval orthogonal interval}.
 * <p>
 * If both intervals have the same orientation, the Manhattan distance is the sum of the distance between the intervals'
 * ranges and the distance between the intervals' locations.
 * </p>
 * <p>
 * If the intervals have different orientations, the Manhattan distance is the sum of the distances between one interval's
 * range and the other interval's location.
 * </p>
 * @param {!yfiles.router.OrthogonalInterval} other the other orthogonal interval
 * @return {number} the Manhattan distance between this interval and the given one
 */
yfiles.router.OrthogonalInterval.prototype.manhattanDistanceTo = function(other) {};
/**
 * @record
 * @struct
 */
yfiles.router.PartitionCellBorder = function() {};
 /** @type {!yfiles.router.PartitionCellBorder} */
yfiles.router.PartitionCellBorder.NORTH;
 /** @type {!yfiles.router.PartitionCellBorder} */
yfiles.router.PartitionCellBorder.SOUTH;
 /** @type {!yfiles.router.PartitionCellBorder} */
yfiles.router.PartitionCellBorder.EAST;
 /** @type {!yfiles.router.PartitionCellBorder} */
yfiles.router.PartitionCellBorder.WEST;
 /** @type {!yfiles.router.PartitionCellBorder} */
yfiles.router.PartitionCellBorder.prototype.mirrorBorder;
 /** @type {!yfiles.lang.Class} */
yfiles.router.PartitionCellBorder.$class;

/**
 * Returns the type of the border that is passed through when entering a {\@link yfiles.router.PartitionCell} in the given
 * direction.
 * @see yfiles.router.PartitionCell
 * @param {!yfiles.layout.Direction} direction the direction in which a {\@link } has been entered
 * @return {!yfiles.router.PartitionCellBorder} the type of the border that is passed through when entering a {\@link }
 */
yfiles.router.PartitionCellBorder.valueOfEnterDirection = function(direction) {};

/**
 * Returns the type of the border that is passed through when exiting a {\@link yfiles.router.PartitionCell} in the given
 * direction.
 * @see yfiles.router.PartitionCell
 * @param {!yfiles.layout.Direction} direction the direction in which a {\@link } has been exited
 * @return {!yfiles.router.PartitionCellBorder} the type of the border that is passed through when exiting a {\@link }
 */
yfiles.router.PartitionCellBorder.valueOfExitDirection = function(direction) {};

/**
 * Returns the type of the border that is defined by the given {\@link yfiles.layout.PortCandidate}.
 * <p>
 * The border type corresponds to the {\@link yfiles.layout.PortCandidate#direction direction} of the given {\@link yfiles.layout.PortCandidate}.
 * </p>
 * @see yfiles.layout.PortCandidate
 * @param {!yfiles.layout.PortCandidate} pc the port candidate for which the border type is returned
 * @return {!yfiles.router.PartitionCellBorder} the type of the border that is defined by the given port candidate
 */
yfiles.router.PartitionCellBorder.valueOfPortCandidate = function(pc) {};

/**
 * Returns the type of the border that is defined by the given {\@link yfiles.layout.PortConstraint}.
 * <p>
 * The border type corresponds to the {\@link yfiles.layout.PortConstraint#side side} of the given {\@link yfiles.layout.PortConstraint}.
 * </p>
 * @see yfiles.layout.PortConstraint
 * @param {!yfiles.layout.PortConstraint} pc the port constraint for which the border type is returned
 * @return {!yfiles.router.PartitionCellBorder} the type of the border that is defined by the given port constraint
 */
yfiles.router.PartitionCellBorder.valueOfPortConstraint = function(pc) {};
/**
 * @record
 * @struct
 */
yfiles.router.PartitionCell = function() {};
 /** @type {?} */
yfiles.router.PartitionCell.prototype.partition;
 /** @type {number} */
yfiles.router.PartitionCell.prototype.id;
 /** @type {!yfiles.algorithms.YRectangle} */
yfiles.router.PartitionCell.prototype.bounds;
 /** @type {number} */
yfiles.router.PartitionCell.prototype.minX;
 /** @type {number} */
yfiles.router.PartitionCell.prototype.minY;
 /** @type {number} */
yfiles.router.PartitionCell.prototype.maxX;
 /** @type {number} */
yfiles.router.PartitionCell.prototype.maxY;
 /** @type {number} */
yfiles.router.PartitionCell.prototype.width;
 /** @type {number} */
yfiles.router.PartitionCell.prototype.height;
 /** @type {!yfiles.lang.Class} */
yfiles.router.PartitionCell.$class;

/**
 * Clears all additional data for this {\@link yfiles.router.PartitionCell}.
 * @see yfiles.router.PartitionCell#getData
 * @see yfiles.router.PartitionCell#putData
 * @see yfiles.router.PartitionCell#removeData
 * @return {void}
 */
yfiles.router.PartitionCell.prototype.clearData = function() {};

/**
 * Returns an {\@link yfiles.router.OrthogonalInterval} that defines the location, the size and the orientation of the given
 * {\@link yfiles.router.PartitionCellBorder}.
 * <p>
 * The values defining the border are:
 * </p>
 * <ul>
 * <li>{\@link yfiles.router.PartitionCellBorder#WEST}</li>
 * <li>{\@link yfiles.router.PartitionCellBorder#EAST}</li>
 * <li>{\@link yfiles.router.PartitionCellBorder#NORTH}</li>
 * <li>{\@link yfiles.router.PartitionCellBorder#SOUTH}</li>
 * </ul>
 * @see yfiles.router.PartitionCellBorder
 * @param {!yfiles.router.PartitionCellBorder} border a border of this partition cell
 * @return {!yfiles.router.OrthogonalInterval} an {\@link } that defines the location, the size and the orientation of the given border
 */
yfiles.router.PartitionCell.prototype.createBorderInterval = function(border) {};

/**
 * Returns the additional data associated with the given key for this {\@link yfiles.router.PartitionCell}.
 * @see yfiles.router.PartitionCell#putData
 * @see yfiles.router.PartitionCell#removeData
 * @see yfiles.router.PartitionCell#clearData
 * @see yfiles.router.PartitionCellKeys
 * @param {!Object} key the key whose associated data will be returned
 * @return {!Object} the additional data associated with the given key or <code>null</code> if there is no data associated with the given key
 */
yfiles.router.PartitionCell.prototype.getData = function(key) {};

/**
 * Stores the additional data associated with the given key for this {\@link yfiles.router.PartitionCell}.
 * @see yfiles.router.PartitionCell#getData
 * @see yfiles.router.PartitionCell#removeData
 * @see yfiles.router.PartitionCell#clearData
 * @see yfiles.router.PartitionCellKeys
 * @param {!Object} key the key with which the additional data will be associated
 * @param {!Object} data the additional data
 * @return {!Object} the previous data associated with the given key or <code>null</code> if there was no data associated with the given key
 */
yfiles.router.PartitionCell.prototype.putData = function(key, data) {};

/**
 * Removes the additional data associated with the given key for this {\@link yfiles.router.PartitionCell}.
 * @see yfiles.router.PartitionCell#getData
 * @see yfiles.router.PartitionCell#putData
 * @see yfiles.router.PartitionCell#clearData
 * @see yfiles.router.PartitionCellKeys
 * @param {!Object} key the key for which the associated data will be removed
 * @return {!Object} the additional data associated with the given key or <code>null</code> if there is no data associated with the given key
 */
yfiles.router.PartitionCell.prototype.removeData = function(key) {};
/**
 * @record
 * @struct
 */
yfiles.router.PartitionCellKeys = function() {};
 /** @type {!Object} */
yfiles.router.PartitionCellKeys.NODES_KEY;
 /** @type {!Object} */
yfiles.router.PartitionCellKeys.NODES_IN_NODE_TO_EDGE_DISTANCE_KEY;
 /** @type {!Object} */
yfiles.router.PartitionCellKeys.NODE_LABEL_LAYOUTS_KEY;
 /** @type {!Object} */
yfiles.router.PartitionCellKeys.NODE_LABEL_CROSSING_COST_FACTORS_KEY;
 /** @type {!Object} */
yfiles.router.PartitionCellKeys.EDGE_LABEL_LAYOUTS_KEY;
 /** @type {!Object} */
yfiles.router.PartitionCellKeys.EDGE_LABEL_CROSSING_COST_FACTORS_KEY;
 /** @type {!Object} */
yfiles.router.PartitionCellKeys.PARTITION_GRID_CELL_ID_KEY;
 /** @type {!Object} */
yfiles.router.PartitionCellKeys.PARTITION_GRID_ROW_INDEX_KEY;
 /** @type {!Object} */
yfiles.router.PartitionCellKeys.PARTITION_GRID_COLUMN_INDEX_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.router.PartitionCellKeys.$class;
/**
 * @record
 * @struct
 */
yfiles.router.Path = function() {};
 /** @type {!yfiles.algorithms.Edge} */
yfiles.router.Path.prototype.edge;
 /** @type {number} */
yfiles.router.Path.prototype.cost;
 /** @type {!yfiles.lang.Class} */
yfiles.router.Path.$class;

/**
 * Returns the {\@link yfiles.router.CellEntrance} at the given position of this path.
 * @see yfiles.router.Path#setEntrance
 * @param {number} position the position of the {\@link } to return
 * @return {!yfiles.router.CellEntrance} the {\@link } at the given position of this path
 */
yfiles.router.Path.prototype.getEntrance = function(position) {};

/**
 * Returns the number of {\@link yfiles.router.CellEntrance} objects in this path.
 * @return {number} the number of {\@link } objects in this path
 */
yfiles.router.Path.prototype.length = function() {};

/**
 * Returns the position of the first occurrence of the given {\@link yfiles.router.CellEntrance} in this path, or <code>-1</code> if this path
 * does not contain this {\@link yfiles.router.CellEntrance}.
 * @param {!yfiles.router.CellEntrance} entrance the {\@link } for which the position is retrieved
 * @return {number} the position of the first occurrence of the given {\@link } in this path, or <code>-1</code> if this path does not
 * contain this {\@link }
 */
yfiles.router.Path.prototype.positionOf = function(entrance) {};

/**
 * Replaces the {\@link yfiles.router.CellEntrance} at the given position of this path with the given {\@link yfiles.router.CellEntrance}.
 * @see yfiles.router.Path#getEntrance
 * @param {number} position the position of the {\@link } to replace
 * @param {!yfiles.router.CellEntrance} entrance the {\@link } to be stored at the given position
 * @return {void}
 */
yfiles.router.Path.prototype.setEntrance = function(position, entrance) {};
/**
 * @record
 * @struct
 */
yfiles.router.PathSearch = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.router.PathSearch.$class;

/**
 * Adds a new interval calculator to the list of registered {\@link yfiles.router.IEnterIntervalCalculator}s.
 * <p>
 * {\@link yfiles.router.IEnterIntervalCalculator}s may add
 * {\@link yfiles.router.CellEntrance}s with narrowed intervals to the queue. The interval is more specific and will be judged with
 * lower costs.
 * </p>
 * @param {?} enterIntervalCalculator the calculator to add
 * @return {boolean} <code>true</code> if the calculator was successfully added, <code>false</code> otherwise
 */
yfiles.router.PathSearch.prototype.addAdditionalEnterIntervalCalculator = function(enterIntervalCalculator) {};

/**
 * Adds the given extension to the list of {\@link yfiles.router.PathSearchExtension}s.
 * <p>
 * An extension can influence the pathfinding process by adding costs for entering certain {\@link yfiles.router.CellEntrance}s.
 * </p>
 * @param {!yfiles.router.PathSearchExtension} extension the extension to add to this path search
 * @return {boolean} <code>true</code> if the extension has been added, <code>false</code> otherwise
 */
yfiles.router.PathSearch.prototype.addPathSearchExtension = function(extension) {};

/**
 * Calculates the costs for moving from the current {\@link yfiles.router.CellEntrance} to the neighboring {\@link yfiles.router.PartitionCell}
 * using different enter intervals.
 * <p>
 * It is called by {\@link yfiles.router.PathSearch#handleNeighbor} to determine the costs for all
 * {\@link yfiles.router.CellEntrance}s that it will create and enqueue afterwards.
 * </p>
 * <p>
 * The costs for the given enter intervals are retrieved from all registered
 * {\@link yfiles.router.PathSearchExtension}s. The calculation stops when it reaches the given maximum cost value.
 * </p>
 * @see yfiles.router.PathSearchExtension#calculateCosts
 * @protected
 * @param {!yfiles.router.CellEntrance} currentEntrance the current cell entrance
 * @param {!yfiles.router.PartitionCell} enteredCell the partition cell to enter
 * @param {!Array<!yfiles.router.OrthogonalInterval>} enterIntervals the different entering intervals of the entered cell
 * @param {!Array<!yfiles.router.EdgeCellInfo>} lastEdgeCellInfos the information about how the last cell was crossed
 * @param {!yfiles.router.PathSearchContext} context the context information
 * @param {!Array<number>} costs the array in which the calculated costs for entering the neighbor cell via the according enter intervals shall be
 * written
 * @param {!Array<number>} maxAllowedCosts the maximum costs an enter interval may induce. If this cost is exceeded, no further additional costs for this interval
 * are calculated. Note that the entries in this array get modified during cost calculation
 * @return {void}
 */
yfiles.router.PathSearch.prototype.calculateCosts = function(currentEntrance, enteredCell, enterIntervals, lastEdgeCellInfos, context, costs, maxAllowedCosts) {};

/**
 * Returns the estimated costs for the rest of the path when using the given {\@link yfiles.router.CellEntrance} for the next step
 * in the path search.
 * <p>
 * It is called by {\@link yfiles.router.PathSearch#handleNeighbor} to determine the heuristic part of the costs with which the
 * entrance will be enqueued.
 * </p>
 * <p>
 * The heuristic costs for the given entrance are retrieved from all registered {\@link yfiles.router.PathSearchExtension}s.
 * </p>
 * @see yfiles.router.PathSearchExtension#calculateHeuristicCosts
 * @protected
 * @param {!yfiles.router.CellEntrance} entrance the current entrance
 * @param {!yfiles.router.PathSearchContext} context the context information
 * @return {number} the heuristic costs for the rest of the path if the given entrance is used
 */
yfiles.router.PathSearch.prototype.calculateHeuristicCosts = function(entrance, context) {};

/**
 * Resets all registered {\@link yfiles.router.PathSearchExtension}s and {\@link yfiles.algorithms.DataProviders} added to this
 * {\@link yfiles.router.PathSearch}.
 * <p>
 * So, {\@link yfiles.router.PathSearch} is ready to calculate paths for a new layout.
 * </p>
 * @see yfiles.router.PathSearchExtension#cleanUp
 * @return {void}
 */
yfiles.router.PathSearch.prototype.clear = function() {};

/**
 * Decreases the given penalty settings for the current edge.
 * <p>
 * If finding a path for the current edge takes too long according to the {\@link yfiles.router.EdgeRouter#maximumDuration maximum duration} of the {\@link yfiles.router.EdgeRouter edge routing algorithm},
 * the path search for the current edge is canceled and restarted using decreased penalties. The <code>decreaseFactor</code> indicates,
 * how much the penalties shall be reduced.
 * </p>
 * <p>
 * This method is called by
 * {\@link yfiles.router.PathSearch#findPathsForCurrentEdge}. If overriding this method, note that the penalty for creating bends
 * should not be reduced as this results in more possible turns of the edge path and, therefore, a longer runtime of the
 * path search. Furthermore, not all penalties should be decreased equally as these decreases would neutralize each other.
 * </p>
 * <p>
 * The <code>decreaseFactor</code> takes values from <code>[0,1]</code>, where <code>0</code> means no reduction while <code>1</code> means the strongest reduction.
 * </p>
 * @protected
 * @param {!yfiles.router.PenaltySettings} penaltySettings the penalty settings whose penalties shall be reduced
 * @param {number} decreaseFactor the factor with values between <code>0</code> and <code>1</code> that indicates how strong to reduce the penalties
 * @param {!yfiles.router.PathSearchContext} context the context information of the current path search
 * @return {void}
 */
yfiles.router.PathSearch.prototype.decreasePenaltySettings = function(penaltySettings, decreaseFactor, context) {};

/**
 * Informs all registered path search extensions about completing a path by calling their {\@link yfiles.router.PathSearchExtension#finalizePath finalizePath(Path)} method.
 * <p>
 * That way, extensions can collect data about this path to use it later during path search.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.router.PathSearch#findPathsForCurrentEdge} and may be overridden to use a custom
 * finalization step.
 * </p>
 * @protected
 * @param {!yfiles.router.Path} path the path to finalize
 * @return {void}
 */
yfiles.router.PathSearch.prototype.finalizePath = function(path) {};

/**
 * Finds paths for the edges in the given context and stores them in its {\@link yfiles.router.PathSearchContext#pathSearchResult PathSearchResult}.
 * <p>
 * This is the main method of {\@link yfiles.router.PathSearch}.
 * </p>
 * <p>
 * It initializes its extensions using {\@link yfiles.router.PathSearchExtension#initializeEdges} and delegates the path search for
 * each edge to {\@link yfiles.router.PathSearch#findPathsForCurrentEdge}.
 * </p>
 * <p>
 * The path calculations for all edges are finalized by calling the extensions' {\@link yfiles.router.PathSearchExtension#finalizeEdges}
 * method and, after that, the path search result is filled with the path for each edge.
 * </p>
 * <p>
 * At last, the extensions are asked to finalize the path search result using their {\@link yfiles.router.PathSearchExtension#finalizePathSearchResult}
 * callback.
 * </p>
 * @see yfiles.router.PathSearchContext#edges
 * @see yfiles.router.PathSearchContext#pathSearchResult
 * @param {!yfiles.router.PathSearchContext} context the context to use during the path search
 * @return {void}
 */
yfiles.router.PathSearch.prototype.findPaths = function(context) {};

/**
 * Finds the path for the current edge in the given context.
 * <p>
 * This method:
 * </p>
 * <ul>
 * <li>Calls {\@link yfiles.router.PathSearchExtension#initializeCurrentEdge} for all extensions.</li>
 * <li>Collects and enqueues all start entrances.</li>
 * <li>Iteratively processes the next cheapest cell entrance and</li>
 * <li>Calls {\@link yfiles.router.PathSearchExtension#finalizeCurrentEdge} for all extensions.</li>
 * </ul>
 * <p>
 * It is called by {\@link yfiles.router.PathSearch#findPaths} and may be overridden to skip certain edges or implement a custom
 * path search.
 * </p>
 * @protected
 * @param {!yfiles.router.PathSearchContext} context the context information needed for finding a path
 * @return {void}
 */
yfiles.router.PathSearch.prototype.findPathsForCurrentEdge = function(context) {};

/**
 * Returns the path for the given edge if it has already been finalized.
 * <p>
 * The path is finalized if the {\@link yfiles.router.PathSearch} chose it as the best result for the edge.
 * </p>
 * @param {!yfiles.algorithms.Edge} edge the edge for which the path is returned
 * @return {!yfiles.router.Path} the finalized path for the given edge or <code>null</code> if no path has been found and finalized
 */
yfiles.router.PathSearch.prototype.getFinalizedPath = function(edge) {};

/**
 * Adds
 * {\@link yfiles.router.CellEntrance}s for every interval through which the neighboring cell can be entered from the current
 * entrance to the queue.
 * <p>
 * The algorithm calls this method in every step for each neighbor of the current cell to collect all next possible
 * entrances for the current path. This path consists of several entrances where each knows the entrance through which it
 * has been entered.
 * </p>
 * <p>
 * After calculating all possible enter intervals to the given neighboring cell, each interval gets rated with costs. If
 * there is already an entrance for the neighboring cell whose interval is the same with one of these intervals, this
 * entrance will be used and re-enqueued, so that the path search can still reach it. The current entrance is set as its
 * predecessor within the current path and its enter interval and costs will be updated.
 * </p>
 * <p>
 * If there is an entrance for the neighboring cell whose interval is intersected by a current interval, new entrances will
 * be created with the new enter intervals and enqueued. The same happens if there is no entrance that has been matched
 * with one of the current intervals, yet. Costs will be added. If there are some entries afterwards that are intersected
 * by the current interval and have higher costs, they will be removed from the queue.
 * </p>
 * <p>
 * This method is called during cost calculation. It may be overridden to change the interval handling for the
 * {\@link yfiles.router.CellEntrance}s.
 * </p>
 * @see yfiles.router.PathSearch#calculateCosts
 * @see yfiles.router.PathSearch#calculateHeuristicCosts
 * @protected
 * @param {!yfiles.router.CellEntrance} currentEntrance the current cell entrance
 * @param {!yfiles.router.PartitionCell} neighborCell the neighboring cell that is handled.
 * @param {!yfiles.router.PathSearchContext} context the context information
 * @return {void}
 */
yfiles.router.PathSearch.prototype.handleNeighbor = function(currentEntrance, neighborCell, context) {};

/**
 * Initializes the fields of this {\@link yfiles.router.PathSearch}.
 * <p>
 * This method also calls {\@link yfiles.router.PathSearchExtension#initialize} for all registered path search extensions.
 * </p>
 * @param {!yfiles.router.PathSearchConfiguration} configuration the configuration that the path search shall use
 * @return {void}
 */
yfiles.router.PathSearch.prototype.init = function(configuration) {};

/**
 * Removes the given interval calculator from the list of registered {\@link yfiles.router.IEnterIntervalCalculator}s.
 * @param {?} enterIntervalCalculator the calculator to remove
 * @return {boolean} <code>true</code> if an interval calculator was removed as a result of this call, <code>false</code> if the given calculator was not part of the
 * list
 */
yfiles.router.PathSearch.prototype.removeAdditionalEnterIntervalCalculator = function(enterIntervalCalculator) {};

/**
 * Removes the given extension from the list of {\@link yfiles.router.PathSearchExtension}s.
 * @param {!yfiles.router.PathSearchExtension} extension the extension to remove from the path search
 * @return {boolean} <code>true</code> if an extension was removed as a result of this call, <code>false</code> if the given extension was not contained in the list
 */
yfiles.router.PathSearch.prototype.removePathSearchExtension = function(extension) {};
/**
 * @record
 * @struct
 */
yfiles.router.PathSearchConfiguration = function() {};
 /** @type {!yfiles.layout.LayoutGraph} */
yfiles.router.PathSearchConfiguration.prototype.graph;
 /** @type {!yfiles.layout.GroupingSupport} */
yfiles.router.PathSearchConfiguration.prototype.grouping;
 /** @type {!yfiles.router.EdgeRouter} */
yfiles.router.PathSearchConfiguration.prototype.edgeRouter;
 /** @type {number} */
yfiles.router.PathSearchConfiguration.prototype.remainingTime;
 /** @type {!yfiles.lang.Class} */
yfiles.router.PathSearchConfiguration.$class;
/**
 * @record
 * @struct
 */
yfiles.router.PathSearchContext = function() {};
 /** @type {!yfiles.router.PathSearch} */
yfiles.router.PathSearchContext.prototype.pathSearch;
 /** @type {!yfiles.router.PathSearchConfiguration} */
yfiles.router.PathSearchContext.prototype.configuration;
 /** @type {?} */
yfiles.router.PathSearchContext.prototype.edges;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.router.PathSearchContext.prototype.currentEdge;
 /** @type {!yfiles.router.EdgeLayoutDescriptor} */
yfiles.router.PathSearchContext.prototype.currentEdgeLayoutDescriptor;
 /** @type {!yfiles.router.PartitionCell} */
yfiles.router.PathSearchContext.prototype.combinedSourceCell;
 /** @type {!yfiles.router.PartitionCell} */
yfiles.router.PathSearchContext.prototype.combinedTargetCell;
 /** @type {!yfiles.router.PathSearchResult} */
yfiles.router.PathSearchContext.prototype.pathSearchResult;
 /** @type {!yfiles.lang.Class} */
yfiles.router.PathSearchContext.$class;

/**
 * Adds an additional source cell of the {\@link yfiles.router.PathSearchContext#currentEdge current edge} if it is not already contained in the list of source cells.
 * @see yfiles.router.PathSearchContext#sourceCellCount
 * @see yfiles.router.PathSearchContext#getSourceCell
 * @param {!yfiles.router.PartitionCell} cell the new source cell to add
 * @return {void}
 */
yfiles.router.PathSearchContext.prototype.addSourceCell = function(cell) {};

/**
 * Adds an additional target cell of the {\@link yfiles.router.PathSearchContext#currentEdge current edge} if it is not already contained in the list of target cells.
 * @see yfiles.router.PathSearchContext#targetCellCount
 * @see yfiles.router.PathSearchContext#getTargetCell
 * @param {!yfiles.router.PartitionCell} cell the new target cell to add
 * @return {void}
 */
yfiles.router.PathSearchContext.prototype.addTargetCell = function(cell) {};

/**
 * Returns the source cell with the given index in the list of all cells that are covered by the source node of the
 * {\@link yfiles.router.PathSearchContext#currentEdge current edge}.
 * @param {number} index the index of the source cell
 * @return {!yfiles.router.PartitionCell} the source cell with the given index in the list of all source cells
 */
yfiles.router.PathSearchContext.prototype.getSourceCell = function(index) {};

/**
 * Returns the target cell with the given index in the list of all cells that are covered by the target node of the
 * {\@link yfiles.router.PathSearchContext#currentEdge current edge}.
 * @param {number} index the index of the target cell
 * @return {!yfiles.router.PartitionCell} the target cell with the given index in the list of all cells that are covered by the target node of the {\@link #currentEdge current edge}
 */
yfiles.router.PathSearchContext.prototype.getTargetCell = function(index) {};

/**
 * Determines whether or not the given cell is a source cell of the {\@link yfiles.router.PathSearchContext#currentEdge current edge}.
 * @see yfiles.router.PathSearchContext#sourceCellCount
 * @see yfiles.router.PathSearchContext#getSourceCell
 * @param {!yfiles.router.PartitionCell} cell the cell
 * @return {boolean} <code>true</code> if the given cell is in the list of source cells, <code>false</code> otherwise
 */
yfiles.router.PathSearchContext.prototype.isSourceCell = function(cell) {};

/**
 * Determines whether or not the given cell is a target cell of the {\@link yfiles.router.PathSearchContext#currentEdge current edge}.
 * @see yfiles.router.PathSearchContext#targetCellCount
 * @see yfiles.router.PathSearchContext#getTargetCell
 * @param {!yfiles.router.PartitionCell} cell the cell
 * @return {boolean} <code>true</code> if the given cell is in the list of target cells, <code>false</code> otherwise
 */
yfiles.router.PathSearchContext.prototype.isTargetCell = function(cell) {};

/**
 * Specifies the edges that shall be routed.
 * @param {!yfiles.algorithms.EdgeList} edges the list of edges that shall be routed
 * @return {void}
 */
yfiles.router.PathSearchContext.prototype.setEdges = function(edges) {};

/**
 * Returns the number of all cells that are covered by the source node of the {\@link yfiles.router.PathSearchContext#currentEdge current edge}.
 * @return {number} the number of all cells that are covered by the source node
 */
yfiles.router.PathSearchContext.prototype.sourceCellCount = function() {};

/**
 * Returns the number of all cells that are covered by the target node of the {\@link yfiles.router.PathSearchContext#currentEdge current edge}.
 * @return {number} the number of all cells that are covered by the target node
 */
yfiles.router.PathSearchContext.prototype.targetCellCount = function() {};
/**
 * @record
 * @struct
 */
yfiles.router.PathSearchExtension = function() {};
 /** @type {!yfiles.router.PathSearchConfiguration} */
yfiles.router.PathSearchExtension.prototype.configuration;
 /** @type {!yfiles.router.PathSearchContext} */
yfiles.router.PathSearchExtension.prototype.context;
 /** @type {!yfiles.lang.Class} */
yfiles.router.PathSearchExtension.$class;

/**
 * Appends additional start {\@link yfiles.router.CellEntrance entrances} for the path search of the current edge to the given list of all previously generated
 * entrances.
 * <p>
 * This method is called before starting the actual path search to determine possible starting points. The current
 * implementation doesn't add any {\@link yfiles.router.CellEntrance}s. It may be overridden to add {\@link yfiles.router.CellEntrance}s with
 * specific enter intervals, e.g., to consider {\@link yfiles.layout.PortConstraint}s.
 * </p>
 * @param {?<!Object>} allStartEntrances a list of all previously generated entrances
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.appendStartEntrances = function(allStartEntrances) {};

/**
 * Calculates the costs for entering the given {\@link yfiles.router.PartitionCell} via the given enter
 * {\@link yfiles.router.OrthogonalInterval}.
 * <p>
 * The given {\@link yfiles.router.EdgeCellInfo} describes how the partition cell that has been entered by the current entrance
 * would be traversed if this enter interval to the neighboring cell would be chosen.
 * </p>
 * <p>
 * The <code>maxAllowedCosts</code> describe the maximum costs that entering the neighboring cell via the given enter interval may
 * induce. If the maximum cost is exceeded, calculations that may further increase its cost may be skipped because this
 * interval won't be chosen anyway.
 * </p>
 * <p>
 * This implementation doesn't add any costs. It may be overridden to add costs, e.g., if entering through the given
 * interval would create a bend.
 * </p>
 * @protected
 * @param {!yfiles.router.CellEntrance} currentEntrance the entrance that was used for entering the current cell
 * @param {!yfiles.router.PartitionCell} enteredCell the neighboring cell that shall be entered
 * @param {!yfiles.router.OrthogonalInterval} enterInterval the interval that shall be used for entering the neighboring cell
 * @param {!yfiles.router.EdgeCellInfo} edgeCellInfo the information about how the current cell would be traversed if the neighboring cell would be entered by this enter
 * interval
 * @param {number} maxAllowedCosts the maximum allowed costs for this enter interval
 * @return {number} the costs for entering the neighboring cell via the enter interval
 */
yfiles.router.PathSearchExtension.prototype.calculateCosts = function(currentEntrance, enteredCell, enterInterval, edgeCellInfo, maxAllowedCosts) {};

/**
 * Calculates the heuristic costs for the given {\@link yfiles.router.CellEntrance} that describe the minimal costs that will arise
 * to finish the path if the given cell entrance is used as next step.
 * <p>
 * After evaluating the costs for each enter interval to a neighboring cell, this method is called for each of the
 * resulting {\@link yfiles.router.CellEntrance}s.
 * </p>
 * <p>
 * This implementation doesn't add any costs. It may be overridden to add some heuristic costs, e.g., if the edge would
 * have to bend to reach the target node from the given {\@link yfiles.router.CellEntrance}.
 * </p>
 * @param {!yfiles.router.CellEntrance} entrance the entrance to calculate the heuristic costs for the rest of the path
 * @return {number} the minimal costs that will arise to finish the path if the given cell entrance is used as next step
 */
yfiles.router.PathSearchExtension.prototype.calculateHeuristicCosts = function(entrance) {};

/**
 * Returns the cost for starting the path in the given entrance.
 * <p>
 * This method is called for each start entrance of the current edge.
 * </p>
 * <p>
 * The current implementation doesn't add any costs for the given {\@link yfiles.router.CellEntrance}. It may be overridden to make
 * start entrances with less specific intervals more expensive. For example, intervals that allow more than just the {\@link yfiles.layout.PortConstraint}
 * location to connect to the source node become more expensive.
 * </p>
 * @param {!yfiles.router.CellEntrance} startEntrance the start entrance for which the cost is calculated
 * @return {number} the cost for starting the path in the given entrance
 */
yfiles.router.PathSearchExtension.prototype.calculateStartEntranceCost = function(startEntrance) {};

/**
 * Handles the cancellation of the path search for the current edge.
 * <p>
 * This callback notifies the extension when the path search for the current edge is canceled. Then, the path search will
 * proceed with altering the penalties of the current edge and reinitializing it again.
 * </p>
 * <p>
 * This implementation does nothing. It may be overridden to reset some edge specific information, e.g., removing
 * previously added listeners.
 * </p>
 * @see yfiles.router.PathSearchExtension#initializeCurrentEdge
 * @see yfiles.router.PathSearchExtension#finalizeEdges
 * @param {!yfiles.router.PathSearchContext} context the context containing the current edge for which the path search has been canceled
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.cancelCurrentEdge = function(context) {};

/**
 * Cleans up the extension from the path searches with the current {\@link yfiles.router.PathSearchExtension#configuration configuration} and {\@link yfiles.router.PathSearchExtension#context context}.
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.cleanUp = function() {};

/**
 * Handles the completion of the path search for the current edge.
 * <p>
 * This callback notifies the extension when enough paths are found for the current edge. After that, the path search
 * either proceeds with initializing the next current edge in the context's edge list or calls {\@link yfiles.router.PathSearchExtension#finalizeEdges}
 * if all edges in this list have been handled.
 * </p>
 * <p>
 * This implementation does nothing. It may be overridden to add/reset some edge specific information, e.g., removing
 * previously added listeners or adding new start entrances.
 * </p>
 * @see yfiles.router.PathSearchExtension#initializeCurrentEdge
 * @see yfiles.router.PathSearchExtension#finalizeEdges
 * @param {!yfiles.router.PathSearchContext} context the context containing the current edge for which the path search has been finished
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.finalizeCurrentEdge = function(context) {};

/**
 * Handles the completion of all marked edges.
 * <p>
 * This callback notifies the extension if enough paths have been found for all edges in the context's edge list.
 * </p>
 * @see yfiles.router.PathSearchContext#edges
 * @param {!yfiles.router.PathSearchContext} context the context containing the list of edges for which paths have been found
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.finalizeEdges = function(context) {};

/**
 * After finding a valid target entrance and creating a {\@link yfiles.router.Path}, the extension is notified of the found path.
 * <p>
 * If the path search is configured to calculate several possible paths for an edge, the path search proceeds with choosing
 * another unhandled {\@link yfiles.router.CellEntrance}.
 * </p>
 * <p>
 * This implementation does nothing. It may be overridden to collect some information about the given path that may
 * influence the path search of later edges.
 * </p>
 * @see yfiles.router.PathSearchContext#currentEdge
 * @param {!yfiles.router.Path} path the path found for the current edge in the context
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.finalizePath = function(path) {};

/**
 * Completes the path search result.
 * <p>
 * This callback notifies the extensions of the paths chosen for the edges in the current context. After calling
 * {\@link yfiles.router.PathSearchExtension#finalizeEdges finalizeEdges}, the {\@link yfiles.router.PathSearch} decides, which of the found paths to use for each edge and adds them to the
 * {\@link yfiles.router.PathSearchResult}.
 * </p>
 * <p>
 * With this callback, the registered extensions are notified of this result before the path search either initializes the
 * next list of edges to route or ends the path search by calling
 * {\@link yfiles.router.PathSearchExtension#cleanUp}. This implementation does nothing.
 * </p>
 * @see yfiles.router.PathSearchExtension#initializeEdges
 * @see yfiles.router.PathSearchExtension#cleanUp
 * @param {!yfiles.router.PathSearchResult} pathSearchResult the path search result for the edge in the current context's edge list
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.finalizePathSearchResult = function(pathSearchResult) {};

/**
 * Initializes this extension for path searches using the given configuration.
 * <p>
 * This method is the first one to be called by the {\@link yfiles.router.PathSearch}. It may be overridden to initialize this
 * extension with necessary settings like {\@link yfiles.layout.GroupingSupport}.
 * </p>
 * @param {!yfiles.router.PathSearchConfiguration} configuration the configuration to use for the following path searches
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.initialize = function(configuration) {};

/**
 * Initializes this extension with the current edge set in the given context.
 * <p>
 * This method is called for each edge of the {\@link yfiles.router.PathSearchExtension#context context}. Each call will be balanced by a call to either {\@link yfiles.router.PathSearchExtension#finalizeCurrentEdge}
 * or {\@link yfiles.router.PathSearchExtension#cancelCurrentEdge}.
 * </p>
 * <p>
 * It may be overridden to initialize/reset the settings for the current edge (e.g. minimum distances).
 * </p>
 * @see yfiles.router.PathSearchContext#currentEdge
 * @param {!yfiles.router.PathSearchContext} context the context containing the current edge
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.initializeCurrentEdge = function(context) {};

/**
 * Initializes this extension with the context that contains the list of edges for which paths are calculated.
 * <p>
 * This method may be called several times during a path search. Each call will be balanced by calls to {\@link yfiles.router.PathSearchExtension#finalizeEdges}
 * and {\@link yfiles.router.PathSearchExtension#finalizePathSearchResult}.
 * </p>
 * <p>
 * It may be overridden to initialize/reset the settings for the routed edges (e.g. minimum distances).
 * </p>
 * @see yfiles.router.PathSearchContext#edges
 * @param {!yfiles.router.PathSearchContext} context the context containing the list of edges for which paths shall be found
 * @return {void}
 */
yfiles.router.PathSearchExtension.prototype.initializeEdges = function(context) {};

/**
 * Determines whether or not this extension considers the given {\@link yfiles.router.CellEntrance} as a valid target entrance,
 * i.e., the path may end with the given entrance.
 * <p>
 * Each time a {\@link yfiles.router.CellEntrance} is chosen as next step, all registered extensions are asked if this entrance is a
 * valid target entrance. Only if none of the extensions returns <code>false</code>, a {\@link yfiles.router.Path} is created.
 * </p>
 * <p>
 * This implementation accepts all
 * {\@link yfiles.router.CellEntrance}s as valid targets. It may be overridden to only activate the target if the route fulfills a
 * certain condition.
 * </p>
 * @param {!yfiles.router.CellEntrance} entrance the entrance to decide if it is a valid target entrance
 * @return {boolean} <code>true</code> if the path may end with this entrance, <code>false</code> otherwise
 */
yfiles.router.PathSearchExtension.prototype.isValidTargetEntrance = function(entrance) {};
/**
 * @record
 * @struct
 */
yfiles.router.PathSearchResult = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.router.PathSearchResult.$class;

/**
 * Returns an {\@link yfiles.router.EdgeInfo} for the given edge.
 * <p>
 * If the given edge shall be routed but no path has been set for it, yet, <code>null</code> is returned. If no {\@link yfiles.router.EdgeInfo}
 * has been created for the path by this context before, a new one is instantiated, otherwise the stored one is returned.
 * </p>
 * @see yfiles.router.PathSearchResult#setPath
 * Returns an {\@link yfiles.router.EdgeInfo} for the given path.
 * <p>
 * If no {\@link yfiles.router.EdgeInfo} has been created for this path by this context before, a new one is instantiated, otherwise
 * the stored one is returned.
 * </p>
 * @param {!yfiles.algorithms.Edge|!yfiles.router.Path} edge_or_path the edge for which the {\@link } will be returned / the path for which the {\@link } will be returned
 * @return {!yfiles.router.EdgeInfo} an {\@link } describing the path of the edge / an {\@link } describing the given path
 */
yfiles.router.PathSearchResult.prototype.getEdgeInfo = function(edge_or_path) {};

/**
 * Returns the previously registered path found for the edge.
 * @param {!yfiles.algorithms.Edge} edge the edge for which the path is provided
 * @return {!yfiles.router.Path} the previously registered path found for the edge or <code>null</code> if no path has been registered, yet
 */
yfiles.router.PathSearchResult.prototype.getPath = function(edge) {};

/**
 * Specifies a found path for an edge.
 * @param {!yfiles.algorithms.Edge} edge the edge for which the path is set
 * @param {!yfiles.router.Path} path the found path
 * @return {void}
 */
yfiles.router.PathSearchResult.prototype.setPath = function(edge, path) {};
/**
 * @record
 * @struct
 */
yfiles.router.PenaltySettings = function() {};
 /** @type {!yfiles.router.PenaltySettings} */
yfiles.router.PenaltySettings.OPTIMIZATION_BALANCED;
 /** @type {!yfiles.router.PenaltySettings} */
yfiles.router.PenaltySettings.OPTIMIZATION_EDGE_BENDS;
 /** @type {!yfiles.router.PenaltySettings} */
yfiles.router.PenaltySettings.OPTIMIZATION_EDGE_CROSSINGS;
 /** @type {!yfiles.router.PenaltySettings} */
yfiles.router.PenaltySettings.OPTIMIZATION_EDGE_LENGTHS;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.edgeLengthPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.bendPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.edgeCrossingPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.nodeCrossingPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.groupNodeCrossingPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.nodeLabelCrossingPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.edgeLabelCrossingPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.minimumNodeToEdgeDistancePenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.minimumGroupNodeToEdgeDistancePenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.minimumEdgeToEdgeDistancePenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.minimumNodeCornerDistancePenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.minimumFirstLastSegmentLengthPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.bendsInNodeToEdgeDistancePenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.monotonyViolationPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.partitionGridCellReentrancePenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.portViolationPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.invalidEdgeGroupingPenalty;
 /** @type {number} */
yfiles.router.PenaltySettings.prototype.singleSideSelfLoopPenalty;
 /** @type {!yfiles.lang.Class} */
yfiles.router.PenaltySettings.$class;

/**
 * Creates a copy of this {\@link yfiles.router.PenaltySettings} instance.
 * <p>
 * This implementation uses method {\@link yfiles.router.PenaltySettings#newInstance} to obtain a new instance which adopts all
 * settings.
 * </p>
 * @return {!yfiles.router.PenaltySettings} a copy of this instance
 */
yfiles.router.PenaltySettings.prototype.createCopy = function() {};

/**
 * Creates a new instance of {\@link yfiles.router.PenaltySettings}.
 * <p>
 * This factory method is used by
 * {\@link yfiles.router.PenaltySettings#createCopy}. Subclasses can override this method in order to return a more specialized
 * version.
 * </p>
 * @protected
 * @return {!yfiles.router.PenaltySettings} a specialized {\@link }
 */
yfiles.router.PenaltySettings.prototype.newInstance = function() {};
/**
 * @record
 * @struct
 */
yfiles.router.PolylineLayoutStage = function() {};
 /** @type {!Object} */
yfiles.router.PolylineLayoutStage.prototype.affectedNodesDpKey;
 /** @type {!Object} */
yfiles.router.PolylineLayoutStage.prototype.affectedEdgesDpKey;
 /** @type {yfiles.router.Scope} */
yfiles.router.PolylineLayoutStage.prototype.scope;
 /** @type {number} */
yfiles.router.PolylineLayoutStage.prototype.minimumNodeToEdgeDistance;
 /** @type {number} */
yfiles.router.PolylineLayoutStage.prototype.maximumNonOrthogonalSegmentRatio;
 /** @type {number} */
yfiles.router.PolylineLayoutStage.prototype.preferredPolylineSegmentLength;
 /** @type {!yfiles.lang.Class} */
yfiles.router.PolylineLayoutStage.$class;
/**
 * @record
 * @struct
 */
yfiles.router.SegmentGroup = function() {};
 /** @type {!yfiles.router.Interval} */
yfiles.router.SegmentGroup.prototype.commonLocationRange;
 /** @type {?<!Object>} */
yfiles.router.SegmentGroup.prototype.segmentInfos;
 /** @type {!yfiles.router.SegmentInfo} */
yfiles.router.SegmentGroup.prototype.commonSegmentInfo;
 /** @type {!yfiles.lang.Class} */
yfiles.router.SegmentGroup.$class;
/**
 * @record
 * @struct
 */
yfiles.router.SegmentInfo = function() {};
 /** @type {!yfiles.router.SegmentGroup} */
yfiles.router.SegmentInfo.prototype.segmentGroup;
 /** @type {boolean} */
yfiles.router.SegmentInfo.prototype.atStrongPortConstraint;
 /** @type {!yfiles.lang.Class} */
yfiles.router.SegmentInfo.$class;

/**
 * Returns the number of {\@link yfiles.router.CellSegmentInfo} of this segment info.
 * @return {number} the number of {\@link } of this segment info
 */
yfiles.router.SegmentInfo.prototype.cellSegmentInfoCount = function() {};

/**
 * Returns the {\@link yfiles.router.CellSegmentInfo} at the given index of this segment info.
 * @param {number} index the index of the {\@link } to return
 * @return {!yfiles.router.CellSegmentInfo} the {\@link } at the given index of this segment info
 */
yfiles.router.SegmentInfo.prototype.getCellSegmentInfo = function(index) {};
/**
 * @record
 * @struct
 */
yfiles.router.SegmentInfoBase = function() {};
 /** @type {!yfiles.router.Interval} */
yfiles.router.SegmentInfoBase.prototype.minExtension;
 /** @type {!yfiles.router.Interval} */
yfiles.router.SegmentInfoBase.prototype.maxExtension;
 /** @type {!yfiles.router.Interval} */
yfiles.router.SegmentInfoBase.prototype.locationRange;
 /** @type {yfiles.router.Alignment} */
yfiles.router.SegmentInfoBase.prototype.preferredAlignment;
 /** @type {number} */
yfiles.router.SegmentInfoBase.prototype.location;
 /** @type {boolean} */
yfiles.router.SegmentInfoBase.prototype.fixed;
 /** @type {boolean} */
yfiles.router.SegmentInfoBase.prototype.vertical;
 /** @type {!yfiles.layout.Direction} */
yfiles.router.SegmentInfoBase.prototype.direction;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.router.SegmentInfoBase.prototype.edge;
 /** @type {number} */
yfiles.router.SegmentInfoBase.prototype.segmentIndex;
 /** @type {!yfiles.router.SegmentGroup} */
yfiles.router.SegmentInfoBase.prototype.segmentGroup;
 /** @type {!yfiles.lang.Class} */
yfiles.router.SegmentInfoBase.$class;
/**
 * @record
 * @struct
 */
yfiles.router.BusDescriptor = function() {};
 /** @type {!Object} */
yfiles.router.BusDescriptor.prototype.busId;
 /** @type {!Object} */
yfiles.router.BusDescriptor.prototype.sourceGroupId;
 /** @type {!Object} */
yfiles.router.BusDescriptor.prototype.targetGroupId;
 /** @type {boolean} */
yfiles.router.BusDescriptor.prototype.fixed;
 /** @type {!yfiles.lang.Class} */
yfiles.router.BusDescriptor.$class;
/**
 * @record
 * @struct
 */
yfiles.router.BusRepresentations = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.router.BusRepresentations.SOURCE_ID_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.router.BusRepresentations.TARGET_ID_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.router.BusRepresentations.$class;

/**
 * Changes the representation of buses from hubs to complete subgraphs by creating new edges between regular nodes and
 * removing the hubs.
 * <p>
 * This method respects multiple connections of nodes and creates appropriate
 * {\@link yfiles.router.BusDescriptor}s consisting of the bus ID as well as source and target group IDs.
 * </p>
 * <p>
 * The path of each new edge follows the route defined by the component of the hubs. If the subgraph of hubs is not a tree,
 * these paths are ambiguous. In this case, an arbitrary tree is computed from the hub's subgraph which defines all the
 * paths.
 * </p>
 * Changes the representation of buses from hubs to complete subgraphs.
 * <p>
 * This method delegates to {\@link yfiles.router.BusRepresentations#replaceHubsBySubgraph}.
 * </p>
 * @see yfiles.router.BusRepresentations#replaceHubsBySubgraph
 * @see yfiles.router.BusRepresentations#toEdgeLists
 * @param {!yfiles.layout.LayoutGraph} graph the graph of the bus
 * @param {!Array<!yfiles.algorithms.EdgeList>|?} hubEdgesLists_or_hubMarker an array of {\@link }s each containing the edges of a bus / a {\@link } that marks hub nodes
 * @param {?} hubMarker_or_descriptorAcceptor a {\@link } that marks hub nodes / a {\@link } for storing the created bus descriptors
 * @param {?=} fixedMarker a {\@link } that marks fixed edges
 * @param {?=} descriptorAcceptor a {\@link } for storing the created bus descriptors
 * @return {!yfiles.algorithms.EdgeList} a list of the created edges
 */
yfiles.router.BusRepresentations.replaceHubsBySubgraph = function(graph, hubEdgesLists_or_hubMarker, hubMarker_or_descriptorAcceptor, fixedMarker, descriptorAcceptor) {};

/**
 * Changes the representation of buses from complete subgraphs to hubs by replacing intersection points by hubs.
 * <p>
 * The edges of the given graph must form an orthogonal, cycle-free bus, otherwise an {\@link yfiles.lang.Exception} is thrown.
 * </p>
 * @throws {Stubs.Exceptions.InvalidOperationError} if the path of an edge is not orthogonal or if some paths form a cycle
 * @param {!yfiles.layout.LayoutGraph} graph the graph where each bus is represented by a complete subgraph of the corresponding nodes
 * @param {?} edgeCursor an {\@link } of the regular edges
 * @param {?} descriptorProvider a {\@link } that provides a {\@link } for each edge
 * @param {?} busIDAcceptor an optional {\@link } that stores the bus ID for each new edge
 * @return {void}
 */
yfiles.router.BusRepresentations.replaceSubgraphByHubs = function(graph, edgeCursor, descriptorProvider, busIDAcceptor) {};

/**
 * Calculates for every bus represented by hubs a list of all of its edges.
 * @param {!yfiles.algorithms.Graph} graph the graph where buses are represented by means of hubs
 * @param {?} hubMarker a {\@link } which marks hub nodes
 * @return {!Array<!yfiles.algorithms.EdgeList>} an array of {\@link }s where each list contains all edges of a bus
 */
yfiles.router.BusRepresentations.toEdgeLists = function(graph, hubMarker) {};
/**
 * @record
 * @struct
 */
yfiles.router.BusRouter = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.router.BusDescriptor>} */
yfiles.router.BusRouter.EDGE_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.router.BusRouter.DEFAULT_AFFECTED_EDGES_DP_KEY;
 /** @type {number} */
yfiles.router.BusRouter.prototype.gridSpacing;
 /** @type {boolean} */
yfiles.router.BusRouter.prototype.gridRouting;
 /** @type {number} */
yfiles.router.BusRouter.prototype.minimumDistanceToNode;
 /** @type {number} */
yfiles.router.BusRouter.prototype.minimumDistanceToEdge;
 /** @type {number} */
yfiles.router.BusRouter.prototype.crossingCost;
 /** @type {boolean} */
yfiles.router.BusRouter.prototype.rerouting;
 /** @type {number} */
yfiles.router.BusRouter.prototype.preferredBackboneSegmentCount;
 /** @type {number} */
yfiles.router.BusRouter.prototype.minimumBackboneSegmentLength;
 /** @type {number} */
yfiles.router.BusRouter.prototype.minimumBusConnectionsCount;
 /** @type {boolean} */
yfiles.router.BusRouter.prototype.removeCollinearBends;
 /** @type {!Object} */
yfiles.router.BusRouter.prototype.affectedEdgesDpKey;
 /** @type {yfiles.router.Scope} */
yfiles.router.BusRouter.prototype.scope;
 /** @type {!yfiles.lang.Class} */
yfiles.router.BusRouter.$class;
/**
 * @record
 * @struct
 */
yfiles.router.ChannelEdgeRouter = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.router.ChannelEdgeRouter.AFFECTED_EDGES_DP_KEY;
 /** @type {?} */
yfiles.router.ChannelEdgeRouter.prototype.pathFinderStrategy;
 /** @type {?} */
yfiles.router.ChannelEdgeRouter.prototype.edgeDistributionStrategy;
 /** @type {!yfiles.lang.Class} */
yfiles.router.ChannelEdgeRouter.$class;

/**
 * Checks the sizes of the nodes to be non-zero.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} g The graph to check.
 * @return {void}
 */
yfiles.router.ChannelEdgeRouter.prototype.checkNodeSize = function(g) {};
/**
 * @record
 * @struct
 */
yfiles.router.OrganicEdgeRouter = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.router.OrganicEdgeRouter.AFFECTED_EDGES_DP_KEY;
 /** @type {boolean} */
yfiles.router.OrganicEdgeRouter.prototype.edgeNodeOverlapAllowed;
 /** @type {?} */
yfiles.router.OrganicEdgeRouter.prototype.coreLayout;
 /** @type {number} */
yfiles.router.OrganicEdgeRouter.prototype.minimumDistance;
 /** @type {boolean} */
yfiles.router.OrganicEdgeRouter.prototype.keepExistingBends;
 /** @type {boolean} */
yfiles.router.OrganicEdgeRouter.prototype.routeAllEdges;
 /** @type {!yfiles.lang.Class} */
yfiles.router.OrganicEdgeRouter.$class;

/**
 * Performs the organic routing of the edges of the input graph.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.router.OrganicEdgeRouter.prototype.applyLayout = function(graph) {};

/**
 * Checks the sizes of the nodes to be non-zero.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} g The graph to check.
 * @return {void}
 */
yfiles.router.OrganicEdgeRouter.prototype.checkNodeSize = function(g) {};

/**
 * Returns a {\@link yfiles.layout.ILayoutStage} which temporarily increases the sizes of the nodes to avoid overlaps.
 * <p>
 * The edges will keep a greater distance to the nodes. Therefore, they won't cross them.
 * </p>
 * @return {?} the {\@link } that resizes the nodes
 */
yfiles.router.OrganicEdgeRouter.prototype.createNodeEnlargementStage = function() {};
/**
 * @record
 * @struct
 */
yfiles.router.OrthogonalPatternEdgeRouter = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.router.OrthogonalPatternEdgeRouter.DEFAULT_AFFECTED_EDGES_DP_KEY;
 /** @type {yfiles.router.MonotonicPathRestriction} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.monotonicPathRestriction;
 /** @type {!Object} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.affectedEdgesDpKey;
 /** @type {number} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.minimumDistance;
 /** @type {number} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.gridSpacing;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.gridOrigin;
 /** @type {boolean} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.gridRouting;
 /** @type {number} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.edgeCrossingCost;
 /** @type {number} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.nodeCrossingCost;
 /** @type {number} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.bendCost;
 /** @type {number} */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.edgeOverlapCost;
 /** @type {!yfiles.lang.Class} */
yfiles.router.OrthogonalPatternEdgeRouter.$class;

/**
 * Calculates the costs for all bends of the given path.
 * <p>
 * This method is called by {\@link yfiles.router.OrthogonalPatternEdgeRouter#calculateCost}. The default implementation multiplies
 * the number of bends with the according {\@link yfiles.router.OrthogonalPatternEdgeRouter#bendCost costs}. It may be overridden to change the calculation of these costs.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Edge} edge the edge for which the costs are calculated
 * @param {!yfiles.algorithms.YList} path the path of the given edge
 * @param {!yfiles.layout.PortCandidate} spc the source {\@link } for this edge
 * @param {!yfiles.layout.PortCandidate} tpc the target {\@link } for this edge
 * @return {number} the costs for the bends of this path
 */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.calculateBendCost = function(edge, path, spc, tpc) {};

/**
 * Calculates the edge cost of a possible edge path, in order to determine which path is the best, i.e., the cheapest.
 * <p>
 * This method is called by {\@link yfiles.router.OrthogonalPatternEdgeRouter#applyLayout} in order to decide which path is the
 * best. The default implementation considers the edge length, the number of bends, edge crossings,
 * {\@link yfiles.layout.PortCandidate}s and monotonic path restrictions. It may be overridden to apply a different set of costs or
 * a different weighting.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Edge} edge the edge whose costs to calculate
 * @param {!yfiles.algorithms.YList} path the edge's path
 * @param {!yfiles.layout.PortCandidate} spc the source {\@link } for this edge
 * @param {!yfiles.layout.PortCandidate} tpc the target {\@link } for this edge
 * @return {number} the sum of all costs for this edge's path
 */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.calculateCost = function(edge, path, spc, tpc) {};

/**
 * Calculates the overall crossing costs of the given path, including edge crossings, edge overlaps and node crossings.
 * <p>
 * This method is called by
 * {\@link yfiles.router.OrthogonalPatternEdgeRouter#calculateCost}. The default implementation will determine overlaps and
 * crossings between edge segments and nodes and sum up the costs. It may be overridden to use a different combination of
 * costs.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Edge} edge the edge for which the costs are calculated
 * @param {!yfiles.algorithms.YList} path the path of the given edge
 * @param {!yfiles.layout.PortCandidate} spc the source {\@link } for this edge
 * @param {!yfiles.layout.PortCandidate} tpc the target {\@link } for this edge
 * @return {number} the overall crossing costs of the given path, including edge crossings, edge overlaps and node crossings
 */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.calculateCrossingCosts = function(edge, path, spc, tpc) {};

/**
 * Calculates the costs for the length of the given path.
 * <p>
 * This method is called by {\@link yfiles.router.OrthogonalPatternEdgeRouter#calculateCost}. The default implementation returns
 * costs between <code>0</code> for short paths and <code>1</code> for long paths. Hence, it has relatively little impact on the overall costs. The
 * method may be overridden to introduce a different weighting of the edge length.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Edge} edge the edge for which the costs are calculated
 * @param {!yfiles.algorithms.YList} path the path of the given edge
 * @param {!yfiles.layout.PortCandidate} spc the source {\@link } for this edge
 * @param {!yfiles.layout.PortCandidate} tpc the target {\@link } for this edge
 * @return {number} the costs for the length of the given path
 */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.calculateEdgeLength = function(edge, path, spc, tpc) {};

/**
 * Calculates the costs for the chosen {\@link yfiles.layout.PortCandidate}s.
 * <p>
 * This method is called by {\@link yfiles.router.OrthogonalPatternEdgeRouter#calculateCost}. The default implementation will return
 * the {\@link yfiles.layout.PortCandidate#cost candidates' costs}. It may be overridden to change the calculation of these costs.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Edge} edge the edge for which the costs are calculated
 * @param {!yfiles.algorithms.YList} path the path of the given edge
 * @param {!yfiles.layout.PortCandidate} spc the source {\@link } for this edge
 * @param {!yfiles.layout.PortCandidate} tpc the target {\@link } for this edge
 * @return {number} the costs for the {\@link }s
 */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.calculatePortCandidateCost = function(edge, path, spc, tpc) {};

/**
 * Calculates the extra penalty that is added to the path's cost if the edge is a self-loop and source and target ports
 * have the same direction.
 * <p>
 * This method is called by
 * {\@link yfiles.router.OrthogonalPatternEdgeRouter#calculateCost}. The default implementation adds costs for another bend if
 * source and target ports share the same node side. In this manner, paths with different source and target directions are
 * cheaper and thus preferred. The method may be overridden to change the calculation of this penalty.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Edge} edge the edge for which the costs are calculated
 * @param {!yfiles.algorithms.YList} path the path of the given edge
 * @param {!yfiles.layout.PortCandidate} spc the source {\@link } for this edge
 * @param {!yfiles.layout.PortCandidate} tpc the target {\@link } for this edge
 * @return {number} an extra penalty for specific self-loop paths
 */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.calculateSelfLoopSelfSidePenaltyCost = function(edge, path, spc, tpc) {};

/**
 * Checks the sizes of the nodes to be non-zero.
 * @protected
 * @param {!yfiles.layout.LayoutGraph} g The graph to check.
 * @return {void}
 */
yfiles.router.OrthogonalPatternEdgeRouter.prototype.checkNodeSize = function(g) {};
/**
 * @record
 * @struct
 */
yfiles.router.OrthogonalSegmentDistributionStage = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.router.OrthogonalSegmentDistributionStage.DEFAULT_AFFECTED_EDGES_DP_KEY;
 /** @type {!Object} */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.affectedEdgesDpKey;
 /** @type {boolean} */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.flexiblePreferredDistance;
 /** @type {boolean} */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.flexibleGridSpacing;
 /** @type {boolean} */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.gridRouting;
 /** @type {number} */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.gridSpacing;
 /** @type {number} */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.gridOriginX;
 /** @type {number} */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.gridOriginY;
 /** @type {boolean} */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.lockFirstAndLastSegment;
 /** @type {number} */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.preferredDistance;
 /** @type {!yfiles.lang.Class} */
yfiles.router.OrthogonalSegmentDistributionStage.$class;

/**
 * Specifies the coordinates of the origin of the grid.
 * <p>
 * The grid coordinates will be multiples of the {\@link yfiles.router.OrthogonalSegmentDistributionStage#gridSpacing grid spacing} added to this origin.
 * </p>
 * @see yfiles.router.OrthogonalSegmentDistributionStage#gridRouting
 * @param {number} offsetX the x-coordinate of the grid origin
 * @param {number} offsetY the y-coordinate of the grid origin
 * @return {void}
 */
yfiles.router.OrthogonalSegmentDistributionStage.prototype.setGridOrigin = function(offsetX, offsetY) {};
/**
 * @record
 * @struct
 */
yfiles.router.SnapOuterPortsToNodeBorderStage = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.router.SnapOuterPortsToNodeBorderStage.$class;
/**
 * @record
 * @struct
 */
yfiles.router.BusRouterData = function() {};
 /** @type {!yfiles.layout.DpKeyItemCollection<?>} */
yfiles.router.BusRouterData.prototype.affectedEdges;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.router.BusDescriptor>} */
yfiles.router.BusRouterData.prototype.edgeDescriptors;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.router.BusRouterData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.router.BusRouterData.prototype.targetPortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.router.BusRouterData.prototype.sourcePortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.router.BusRouterData.prototype.targetPortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortCandidateSet>} */
yfiles.router.BusRouterData.prototype.nodePortCandidateSets;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.router.BusRouterData.prototype.abortHandler;
 /** @type {!yfiles.lang.Class} */
yfiles.router.BusRouterData.$class;
/**
 * @record
 * @struct
 */
yfiles.router.ChannelEdgeRouterData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.router.ChannelEdgeRouterData.prototype.affectedEdges;
 /** @type {!yfiles.lang.Class} */
yfiles.router.ChannelEdgeRouterData.$class;
/**
 * @record
 * @struct
 */
yfiles.router.OrganicEdgeRouterData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.router.OrganicEdgeRouterData.prototype.affectedEdges;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.router.OrganicEdgeRouterData.prototype.abortHandler;
 /** @type {!yfiles.lang.Class} */
yfiles.router.OrganicEdgeRouterData.$class;
/**
 * @record
 * @struct
 */
yfiles.router.OrthogonalPatternEdgeRouterData = function() {};
 /** @type {!yfiles.layout.DpKeyItemCollection<?>} */
yfiles.router.OrthogonalPatternEdgeRouterData.prototype.affectedEdges;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.router.OrthogonalPatternEdgeRouterData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.router.OrthogonalPatternEdgeRouterData.prototype.targetPortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.router.OrthogonalPatternEdgeRouterData.prototype.sourcePortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.router.OrthogonalPatternEdgeRouterData.prototype.targetPortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortCandidateSet>} */
yfiles.router.OrthogonalPatternEdgeRouterData.prototype.nodePortCandidateSets;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.router.OrthogonalPatternEdgeRouterData.prototype.abortHandler;
 /** @type {!yfiles.lang.Class} */
yfiles.router.OrthogonalPatternEdgeRouterData.$class;
/**
 * @record
 * @struct
 */
yfiles.router.ParallelEdgeRouterData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.router.ParallelEdgeRouterData.prototype.affectedEdges;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.router.ParallelEdgeRouterData.prototype.leadingEdges;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.router.ParallelEdgeRouterData.prototype.abortHandler;
 /** @type {!yfiles.lang.Class} */
yfiles.router.ParallelEdgeRouterData.$class;
/**
 * @record
 * @struct
 */
yfiles.router.PolylineEdgeRouterData = function() {};
 /** @type {!yfiles.layout.DpKeyItemCollection<?>} */
yfiles.router.PolylineEdgeRouterData.prototype.affectedEdges;
 /** @type {!yfiles.layout.DpKeyItemCollection<?>} */
yfiles.router.PolylineEdgeRouterData.prototype.affectedNodes;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.router.PolylineEdgeRouterData.prototype.ignoredLabels;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.router.EdgeLayoutDescriptor>} */
yfiles.router.PolylineEdgeRouterData.prototype.edgeLayoutDescriptors;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.router.PolylineEdgeRouterData.prototype.labelCrossingPenaltyFactors;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.router.PolylineEdgeRouterData.prototype.nodeHalos;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.router.PolylineEdgeRouterData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.router.PolylineEdgeRouterData.prototype.targetPortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.router.PolylineEdgeRouterData.prototype.sourcePortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.router.PolylineEdgeRouterData.prototype.targetPortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortCandidateSet>} */
yfiles.router.PolylineEdgeRouterData.prototype.nodePortCandidateSets;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.router.PolylineEdgeRouterData.prototype.sourceGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.router.PolylineEdgeRouterData.prototype.targetGroupIds;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.router.PolylineEdgeRouterData.prototype.abortHandler;
 /** @type {!yfiles.layout.PartitionGridData} */
yfiles.router.PolylineEdgeRouterData.prototype.partitionGridData;
 /** @type {!yfiles.lang.Class} */
yfiles.router.PolylineEdgeRouterData.$class;
/**
 * @record
 * @struct
 */
yfiles.router.StraightLineEdgeRouterData = function() {};
 /** @type {!yfiles.layout.DpKeyItemCollection<?>} */
yfiles.router.StraightLineEdgeRouterData.prototype.affectedEdges;
 /** @type {!yfiles.layout.DpKeyItemCollection<?>} */
yfiles.router.StraightLineEdgeRouterData.prototype.affectedNodes;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.router.StraightLineEdgeRouterData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.router.StraightLineEdgeRouterData.prototype.targetPortConstraints;
 /** @type {!yfiles.lang.Class} */
yfiles.router.StraightLineEdgeRouterData.$class;
/** @const */
yfiles.partial = {};

/** @const */
yfiles.partial.EdgeRoutingStrategy = {};
/** @const {number} */
yfiles.partial.EdgeRoutingStrategy.ORTHOGONAL;
/** @const {number} */
yfiles.partial.EdgeRoutingStrategy.STRAIGHTLINE;
/** @const {number} */
yfiles.partial.EdgeRoutingStrategy.AUTOMATIC;
/** @const {number} */
yfiles.partial.EdgeRoutingStrategy.ORGANIC;
/** @const {number} */
yfiles.partial.EdgeRoutingStrategy.OCTILINEAR;

/** @const */
yfiles.partial.ComponentAssignmentStrategy = {};
/** @const {number} */
yfiles.partial.ComponentAssignmentStrategy.SINGLE;
/** @const {number} */
yfiles.partial.ComponentAssignmentStrategy.CONNECTED;
/** @const {number} */
yfiles.partial.ComponentAssignmentStrategy.CLUSTERING;
/** @const {number} */
yfiles.partial.ComponentAssignmentStrategy.CUSTOMIZED;

/** @const */
yfiles.partial.SubgraphPlacement = {};
/** @const {number} */
yfiles.partial.SubgraphPlacement.BARYCENTER;
/** @const {number} */
yfiles.partial.SubgraphPlacement.FROM_SKETCH;

/** @const */
yfiles.partial.LayoutOrientation = {};
/** @const {number} */
yfiles.partial.LayoutOrientation.TOP_TO_BOTTOM;
/** @const {number} */
yfiles.partial.LayoutOrientation.BOTTOM_TO_TOP;
/** @const {number} */
yfiles.partial.LayoutOrientation.LEFT_TO_RIGHT;
/** @const {number} */
yfiles.partial.LayoutOrientation.RIGHT_TO_LEFT;
/** @const {number} */
yfiles.partial.LayoutOrientation.AUTO_DETECT;
/** @const {number} */
yfiles.partial.LayoutOrientation.NONE;
/**
 * @record
 * @struct
 */
yfiles.partial.PartialLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.partial.PartialLayout.AFFECTED_NODES_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.partial.PartialLayout.DIRECTED_EDGES_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.partial.PartialLayout.AFFECTED_EDGES_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.partial.PartialLayout.ROUTE_EDGE_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!Object>} */
yfiles.partial.PartialLayout.COMPONENT_ID_DP_KEY;
 /** @type {?} */
yfiles.partial.PartialLayout.prototype.coreLayout;
 /** @type {number} */
yfiles.partial.PartialLayout.prototype.maximumDuration;
 /** @type {boolean} */
yfiles.partial.PartialLayout.prototype.routeInterEdgesImmediately;
 /** @type {boolean} */
yfiles.partial.PartialLayout.prototype.componentCompaction;
 /** @type {boolean} */
yfiles.partial.PartialLayout.prototype.resizeFixedGroups;
 /** @type {yfiles.partial.SubgraphPlacement} */
yfiles.partial.PartialLayout.prototype.subgraphPlacement;
 /** @type {number} */
yfiles.partial.PartialLayout.prototype.minimumNodeDistance;
 /** @type {boolean} */
yfiles.partial.PartialLayout.prototype.considerNodeAlignment;
 /** @type {yfiles.partial.ComponentAssignmentStrategy} */
yfiles.partial.PartialLayout.prototype.componentAssignmentStrategy;
 /** @type {boolean} */
yfiles.partial.PartialLayout.prototype.optimizeOrientation;
 /** @type {?} */
yfiles.partial.PartialLayout.prototype.edgeRouter;
 /** @type {yfiles.partial.EdgeRoutingStrategy} */
yfiles.partial.PartialLayout.prototype.edgeRoutingStrategy;
 /** @type {yfiles.partial.LayoutOrientation} */
yfiles.partial.PartialLayout.prototype.layoutOrientation;
 /** @type {boolean} */
yfiles.partial.PartialLayout.prototype.allowMirroring;
 /** @type {!yfiles.lang.Class} */
yfiles.partial.PartialLayout.$class;

/**
 * This method is called each time when edges are routed with an edge router.
 * <p>
 * Subclasses may modify the configuration of the given edge router instance.
 * </p>
 * <p>
 * The type of the given instance depends on the edge routing strategy, i.e., if the routing strategy is set to {\@link yfiles.partial.EdgeRoutingStrategy#OCTILINEAR}
 * or {\@link yfiles.partial.EdgeRoutingStrategy#ORTHOGONAL} it's an instance of {\@link yfiles.router.EdgeRouter}, if the routing strategy
 * is set to {\@link yfiles.partial.EdgeRoutingStrategy#ORGANIC} it's an instance of {\@link yfiles.organic.OrganicLayout}, and, if the
 * routing strategy is set to {\@link yfiles.partial.EdgeRoutingStrategy#STRAIGHTLINE} it's an instance of a private
 * {\@link yfiles.router.StraightLineEdgeRouter}. If the edge routing strategy is set to
 * {\@link yfiles.partial.EdgeRoutingStrategy#AUTOMATIC}, the layout algorithm chooses one of the above strategies that best fits
 * the routing style of the fixed edges.
 * </p>
 * @see yfiles.partial.PartialLayout#edgeRouter
 * @see yfiles.partial.PartialLayout#edgeRoutingStrategy
 * @protected
 * @param {?} edgeRouter the instance used for routing the edges
 * @return {void}
 */
yfiles.partial.PartialLayout.prototype.configureEdgeRouter = function(edgeRouter) {};

/**
 * This method is called during the {\@link yfiles.partial.PartialLayout#applyLayout layout process} and calculates the layout for the given subgraph component using the
 * specified {\@link yfiles.partial.PartialLayout#coreLayout core layout algorithm}.
 * <p>
 * It is called once for each subgraph component.
 * </p>
 * <p>
 * Subclasses may implement a custom layout strategy or add some additional data.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} subGraph the subgraph component
 * @return {void}
 */
yfiles.partial.PartialLayout.prototype.layoutSubgraph = function(subGraph) {};

/**
 * This method is called during the {\@link yfiles.partial.PartialLayout#applyLayout layout process} and places the subgraph components one-by-one onto the drawing area.
 * <p>
 * Therefore, it considers the {\@link yfiles.partial.PartialLayout#subgraphPlacement specified objective} for finding a suitable position.
 * </p>
 * <p>
 * Subclasses may implement a custom placement strategy or add some additional data. However, they must not modify the
 * given subgraph component lists.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!Array<!yfiles.algorithms.NodeList>} subgraphComponents each entry contains a {\@link } that induces a subgraph component
 * @return {void}
 */
yfiles.partial.PartialLayout.prototype.placeSubgraphs = function(graph, subgraphComponents) {};

/**
 * This method is called during the {\@link yfiles.partial.PartialLayout#applyLayout layout process} and routes all partial edges that connect two fixed elements.
 * <p>
 * It either uses a {\@link yfiles.partial.PartialLayout#edgeRouter custom edge router} or an internal edge router that produces routes according to the specified
 * {\@link yfiles.partial.PartialLayout#edgeRoutingStrategy routing strategy}.
 * </p>
 * <p>
 * Subclasses may implement a custom routing strategy or add some additional data.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the subgraph of the input graph induced by the fixed nodes
 * @param {!yfiles.algorithms.EdgeList} partialEdges the {\@link  list of partial edges} to be routed
 * @return {void}
 */
yfiles.partial.PartialLayout.prototype.routeEdgesBetweenFixedElements = function(graph, partialEdges) {};

/**
 * This method is called during the {\@link yfiles.partial.PartialLayout#applyLayout layout process} and routes all inter-edges.
 * <p>
 * <i>Inter-edges</i> are edges between different subgraph components including edges between fixed and partial elements. For the routing,
 * this method uses the edge router instance set with method {\@link yfiles.partial.PartialLayout#edgeRouter}. If no edge router was specified by the user, it uses an
 * internal edge router with routing strategy {\@link yfiles.partial.PartialLayout#edgeRoutingStrategy}.
 * </p>
 * <p>
 * Subclasses may implement a custom routing strategy or add some additional data.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the relevant subgraph
 * @param {!yfiles.algorithms.EdgeList} interEdges the {\@link  list of inter-edges} to be routed
 * @return {void}
 */
yfiles.partial.PartialLayout.prototype.routeInterEdges = function(graph, interEdges) {};
/**
 * @record
 * @struct
 */
yfiles.partial.PartialLayoutData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.partial.PartialLayoutData.prototype.affectedNodes;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.partial.PartialLayoutData.prototype.affectedEdges;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.partial.PartialLayoutData.prototype.directedEdges;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.partial.PartialLayoutData.prototype.componentIds;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.partial.PartialLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.partial.PartialLayoutData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.partial.PartialLayoutData.prototype.targetPortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.partial.PartialLayoutData.prototype.sourcePortCandidates;
 /** @type {!yfiles.layout.ItemMapping<?, ?<!yfiles.layout.PortCandidate>>} */
yfiles.partial.PartialLayoutData.prototype.targetPortCandidates;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.partial.PartialLayoutData.prototype.abortHandler;
 /** @type {!yfiles.layout.PartitionGridData} */
yfiles.partial.PartialLayoutData.prototype.partitionGridData;
 /** @type {!yfiles.lang.Class} */
yfiles.partial.PartialLayoutData.$class;
/** @const */
yfiles.tree = {};
/**
 * @record
 * @struct
 */
yfiles.tree.BalloonLayoutNodeInfo = function() {};
 /** @type {number} */
yfiles.tree.BalloonLayoutNodeInfo.prototype.upperAngle;
 /** @type {number} */
yfiles.tree.BalloonLayoutNodeInfo.prototype.lowerAngle;
 /** @type {number} */
yfiles.tree.BalloonLayoutNodeInfo.prototype.gapAngle;
 /** @type {number} */
yfiles.tree.BalloonLayoutNodeInfo.prototype.dist;
 /** @type {number} */
yfiles.tree.BalloonLayoutNodeInfo.prototype.angleSum;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.BalloonLayoutNodeInfo.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.BalloonLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.tree.BalloonLayout.INTERLEAVED_NODES_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.tree.BalloonLayout.SELECTED_ROOT_DP_KEY;
 /** @type {!yfiles.layout.LayoutGraph} */
yfiles.tree.BalloonLayout.prototype.graph;
 /** @type {?<!Object>} */
yfiles.tree.BalloonLayout.prototype.comparer;
 /** @type {yfiles.tree.ChildOrderingPolicy} */
yfiles.tree.BalloonLayout.prototype.childOrderingPolicy;
 /** @type {number} */
yfiles.tree.BalloonLayout.prototype.minimumNodeDistance;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.fromSketchMode;
 /** @type {yfiles.tree.RootNodePolicy} */
yfiles.tree.BalloonLayout.prototype.rootNodePolicy;
 /** @type {number} */
yfiles.tree.BalloonLayout.prototype.preferredChildWedge;
 /** @type {number} */
yfiles.tree.BalloonLayout.prototype.preferredRootWedge;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.allowOverlaps;
 /** @type {number} */
yfiles.tree.BalloonLayout.prototype.compactnessFactor;
 /** @type {number} */
yfiles.tree.BalloonLayout.prototype.minimumEdgeLength;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.considerNodeLabels;
 /** @type {yfiles.tree.InterleavedMode} */
yfiles.tree.BalloonLayout.prototype.interleavedMode;
 /** @type {yfiles.tree.ChildAlignmentPolicy} */
yfiles.tree.BalloonLayout.prototype.childAlignmentPolicy;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.integratedNodeLabeling;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.integratedEdgeLabeling;
 /** @type {yfiles.tree.NodeLabelingPolicy} */
yfiles.tree.BalloonLayout.prototype.nodeLabelingPolicy;
 /** @type {number} */
yfiles.tree.BalloonLayout.prototype.nodeLabelSpacing;
 /** @type {number} */
yfiles.tree.BalloonLayout.prototype.edgeLabelSpacing;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.chainStraighteningMode;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.componentLayoutEnabled;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.hideGroupsStageEnabled;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.orientationLayoutEnabled;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.parallelEdgeRouterEnabled;
 /** @type {boolean} */
yfiles.tree.BalloonLayout.prototype.selfLoopRouterEnabled;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.BalloonLayout.$class;

/**
 * Calculates the wedge angle that has to be reserved for the subtree rooted at the given node scaling the {\@link yfiles.tree.BalloonLayoutNodeInfo#dist distance} with
 * the given scale factor.
 * <p>
 * Given some {\@link yfiles.tree.BalloonLayoutNodeInfo#dist distance} the {\@link yfiles.tree.BalloonLayoutNodeInfo#upperAngle upper angle} and {\@link yfiles.tree.BalloonLayoutNodeInfo#lowerAngle lower angle} of the wedge belonging to the subtree rooted at <code>root</code> will be
 * calculated and stored in the {\@link yfiles.tree.BalloonLayoutNodeInfo} instance associated with <code>root</code>
 * ({\@link yfiles.tree.BalloonLayout#getInfo}).
 * </p>
 * <p>
 * This method may be overridden to perform a custom wedge angle assignment scheme. The method is called when
 * {\@link yfiles.tree.BalloonLayout#calculateChildArrangement arranging child nodes}. Large edge labels on the incoming edge to <code>root</code> need to be considered, if {\@link yfiles.tree.BalloonLayout#integratedEdgeLabeling integrated edge labeling}
 * should still work properly.
 * </p>
 * @see yfiles.tree.BalloonLayout#calculateChildArrangement
 * @protected
 * @param {!yfiles.algorithms.Node} root the node for which the wedge angles are calculated
 * @param {number=} scaleFactor
 * @return {number} the sum of the upper and lower wedge angle of the subtree rooted at the given root node
 */
yfiles.tree.BalloonLayout.prototype.calculateAngles = function(root, scaleFactor) {};

/**
 * Calculates a child node arrangement for a given root node of the tree.
 * <p>
 * During the arrangement, child nodes of <code>root</code> will be {\@link yfiles.tree.BalloonLayout#sortChildNodes sorted}. Furthermore, distances of the child nodes will be chosen
 * such that the wedge of the subtree of <code>root</code> fits into the preferred wedge angle, which is either defined via {\@link yfiles.tree.BalloonLayout#preferredRootWedge} or {\@link yfiles.tree.BalloonLayout#preferredChildWedge}.
 * Calculated distances are stored in {\@link yfiles.tree.BalloonLayoutNodeInfo#dist}.
 * </p>
 * <p>
 * The angle values - upper and lower wedge angle - may also be updated during this process and stored in {\@link yfiles.tree.BalloonLayoutNodeInfo#upperAngle}
 * and {\@link yfiles.tree.BalloonLayoutNodeInfo#lowerAngle}, respectively. To compute the angles of wedges, method {\@link yfiles.tree.BalloonLayout#calculateAngles}
 * is used.
 * </p>
 * <p>
 * This method may be overridden to perform a custom child node arrangement. If support for available features like {\@link yfiles.tree.BalloonLayout#interleavedMode interleaving}
 * should be maintained, then these features need to be carefully considered during the arrangement.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} root the node for whose children to compute an arrangement
 * @return {void}
 */
yfiles.tree.BalloonLayout.prototype.calculateChildArrangement = function(root) {};

/**
 * Determines the root node of {\@link yfiles.tree.BalloonLayout#graph} according to the chosen {\@link yfiles.tree.BalloonLayout#rootNodePolicy root node policy}.
 * <p>
 * This method may be overridden to implement some other strategy for choosing the root node of the input graph. It is
 * called before the rest of the layout process within {\@link yfiles.tree.BalloonLayout#applyLayoutCore}.
 * </p>
 * @see yfiles.tree.BalloonLayout#rootNodePolicy
 * @protected
 * @return {!yfiles.algorithms.Node} the root node of {\@link #graph}
 */
yfiles.tree.BalloonLayout.prototype.determineRoot = function() {};

/**
 * Returns the {\@link yfiles.tree.BalloonLayoutNodeInfo} object associated with the given node while the layout algorithm is
 * active.
 * <p>
 * The returned object contains detailed information describing the placement of a node in the layout being computed, e.g.,
 * a node's distance to its parent or the wedge angle of the subtree rooted at a node.
 * </p>
 * <p>
 * Subclasses may want to override this method to realize another node information setup. This method is called throughout
 * the algorithm, each time some information associated with a node needs to be retrieved or stored.
 * </p>
 * @see yfiles.tree.BalloonLayoutNodeInfo
 * @param {!yfiles.algorithms.Node} node the node whose information object should be retrieved
 * @return {!yfiles.tree.BalloonLayoutNodeInfo} the {\@link } instance associated to the given node
 */
yfiles.tree.BalloonLayout.prototype.getInfo = function(node) {};

/**
 * Returns the preferred radial amount (wedge) in degrees that child nodes may in total occupy around the given node.
 * <p>
 * The wedge angle controls the degree to which the child nodes may radiate from the center of layout. A value close to <code>360</code>
 * means that the child nodes may radiate in (almost) any direction from their parent node, edge lengths can in consequence
 * stay rather small. On the other hand, a small value means that children are restricted to a small angle; thus, edges
 * lengths (and drawings) may become large.
 * </p>
 * <p>
 * This method returns the {\@link yfiles.tree.BalloonLayout#preferredRootWedge preferred root wedge} if node <code>root</code> was selected as global root node ({\@link yfiles.tree.BalloonLayout#rootNodePolicy}). Otherwise, it either
 * returns {\@link yfiles.tree.BalloonLayout#preferredChildWedge} or if the given node has an outdegree equal to <code>2</code>, it returns the minimum of {\@link yfiles.tree.BalloonLayout#preferredChildWedge} and <code>180</code>.
 * </p>
 * <p>
 * This method may be overridden to provide a custom child wedge function.
 * </p>
 * @see yfiles.tree.BalloonLayout#preferredChildWedge
 * @see yfiles.tree.BalloonLayout#preferredRootWedge
 * @protected
 * @param {!yfiles.algorithms.Node} root the node to get the preferred wedge angle for
 * @return {number} the preferred wedge angle for <code>root</code> in degrees
 */
yfiles.tree.BalloonLayout.prototype.getPreferredChildWedge = function(root) {};

/**
 * Sorts the child nodes (successors) of the given node.
 * <p>
 * This implementation uses the original node coordinates if {\@link yfiles.tree.BalloonLayout#fromSketchMode From Sketch mode} is enabled. Otherwise it uses {\@link yfiles.tree.BalloonLayout#comparer the specified comparator}
 * to sort the outgoing edges and thus the children of <code>root</code>. If there is no such comparator, then the sorting depends on
 * whether or not the child nodes are placed in an {\@link yfiles.tree.BalloonLayout#interleavedMode interleaved} fashion:
 * </p>
 * <ul>
 * <li>Normal: Children are sorted according to the chosen {\@link yfiles.tree.BalloonLayout#childOrderingPolicy child ordering policy}.</li>
 * <li>
 * Interleaved: Children are sorted such that the resulting interleaved node placement is compact, while children inducing
 * larger subgraphs are placed next to smaller ones.
 * </li>
 * </ul>
 * <p>
 * This method may be overridden to realize a custom child node ordering. It gets called in method {\@link yfiles.tree.BalloonLayout#calculateChildArrangement}
 * before coordinates are assigned and just after the wedge sizes for all subtrees rooted at <code>root</code> are determined.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} root the node whose child nodes will be sorted
 * @return {void}
 */
yfiles.tree.BalloonLayout.prototype.sortChildNodes = function(root) {};

/** @const */
yfiles.tree.FillStyle = {};
/** @const {number} */
yfiles.tree.FillStyle.LEADING;
/** @const {number} */
yfiles.tree.FillStyle.CENTERED;
/** @const {number} */
yfiles.tree.FillStyle.JUSTIFY;
/** @const {number} */
yfiles.tree.FillStyle.TRAILING;

/** @const */
yfiles.tree.RootPlacement = {};
/** @const {number} */
yfiles.tree.RootPlacement.TOP;
/** @const {number} */
yfiles.tree.RootPlacement.CORNER;
/** @const {number} */
yfiles.tree.RootPlacement.CORNER_SIDE;
/** @const {number} */
yfiles.tree.RootPlacement.CORNER_TOP;

/** @const */
yfiles.tree.SubtreeArrangement = {};
/** @const {number} */
yfiles.tree.SubtreeArrangement.HORIZONTAL;
/** @const {number} */
yfiles.tree.SubtreeArrangement.VERTICAL;

/** @const */
yfiles.tree.InterleavedMode = {};
/** @const {number} */
yfiles.tree.InterleavedMode.OFF;
/** @const {number} */
yfiles.tree.InterleavedMode.ALL_NODES;
/** @const {number} */
yfiles.tree.InterleavedMode.MARKED_NODES;

/** @const */
yfiles.tree.NodeLabelingPolicy = {};
/** @const {number} */
yfiles.tree.NodeLabelingPolicy.RAY_LIKE;
/** @const {number} */
yfiles.tree.NodeLabelingPolicy.RAY_LIKE_LEAVES;
/** @const {number} */
yfiles.tree.NodeLabelingPolicy.HORIZONTAL;

/** @const */
yfiles.tree.ChildAlignmentPolicy = {};
/** @const {number} */
yfiles.tree.ChildAlignmentPolicy.PLAIN;
/** @const {number} */
yfiles.tree.ChildAlignmentPolicy.SAME_CENTER;
/** @const {number} */
yfiles.tree.ChildAlignmentPolicy.COMPACT;
/** @const {number} */
yfiles.tree.ChildAlignmentPolicy.SMART;

/** @const */
yfiles.tree.ChildOrderingPolicy = {};
/** @const {number} */
yfiles.tree.ChildOrderingPolicy.COMPACT;
/** @const {number} */
yfiles.tree.ChildOrderingPolicy.SYMMETRIC;

/** @const */
yfiles.tree.RootNodePolicy = {};
/** @const {number} */
yfiles.tree.RootNodePolicy.DIRECTED_ROOT;
/** @const {number} */
yfiles.tree.RootNodePolicy.CENTER_ROOT;
/** @const {number} */
yfiles.tree.RootNodePolicy.WEIGHTED_CENTER_ROOT;
/** @const {number} */
yfiles.tree.RootNodePolicy.SELECTED_ROOT;

/** @const */
yfiles.tree.ChildPlacement = {};
/** @const {number} */
yfiles.tree.ChildPlacement.VERTICAL_TO_LEFT;
/** @const {number} */
yfiles.tree.ChildPlacement.VERTICAL_TO_RIGHT;
/** @const {number} */
yfiles.tree.ChildPlacement.HORIZONTAL_UPWARD;
/** @const {number} */
yfiles.tree.ChildPlacement.HORIZONTAL_DOWNWARD;

/** @const */
yfiles.tree.RootAlignment = {};
/** @const {number} */
yfiles.tree.RootAlignment.LEADING_OFFSET;
/** @const {number} */
yfiles.tree.RootAlignment.LEADING;
/** @const {number} */
yfiles.tree.RootAlignment.CENTER;
/** @const {number} */
yfiles.tree.RootAlignment.MEDIAN;
/** @const {number} */
yfiles.tree.RootAlignment.TRAILING;
/** @const {number} */
yfiles.tree.RootAlignment.TRAILING_OFFSET;
/** @const {number} */
yfiles.tree.RootAlignment.TRAILING_ON_BUS;
/** @const {number} */
yfiles.tree.RootAlignment.LEADING_ON_BUS;

/** @const */
yfiles.tree.RoutingStyle = {};
/** @const {number} */
yfiles.tree.RoutingStyle.FORK;
/** @const {number} */
yfiles.tree.RoutingStyle.FORK_AT_ROOT;
/** @const {number} */
yfiles.tree.RoutingStyle.STRAIGHT;
/** @const {number} */
yfiles.tree.RoutingStyle.POLYLINE;

/** @const */
yfiles.tree.PortAssignmentMode = {};
/** @const {number} */
yfiles.tree.PortAssignmentMode.PORT_CONSTRAINT;
/** @const {number} */
yfiles.tree.PortAssignmentMode.DISTRIBUTED_NORTH;
/** @const {number} */
yfiles.tree.PortAssignmentMode.DISTRIBUTED_SOUTH;
/** @const {number} */
yfiles.tree.PortAssignmentMode.DISTRIBUTED_EAST;
/** @const {number} */
yfiles.tree.PortAssignmentMode.DISTRIBUTED_WEST;
/** @const {number} */
yfiles.tree.PortAssignmentMode.NONE;

/** @const */
yfiles.tree.ConnectorDirection = {};
/** @const {number} */
yfiles.tree.ConnectorDirection.NORTH;
/** @const {number} */
yfiles.tree.ConnectorDirection.EAST;
/** @const {number} */
yfiles.tree.ConnectorDirection.SOUTH;
/** @const {number} */
yfiles.tree.ConnectorDirection.WEST;

/** @const */
yfiles.tree.BorderLineSide = {};
/** @const {number} */
yfiles.tree.BorderLineSide.NORTH;
/** @const {number} */
yfiles.tree.BorderLineSide.EAST;
/** @const {number} */
yfiles.tree.BorderLineSide.SOUTH;
/** @const {number} */
yfiles.tree.BorderLineSide.WEST;

/** @const */
yfiles.tree.LayeredRoutingStyle = {};
/** @const {number} */
yfiles.tree.LayeredRoutingStyle.STRAIGHT;
/** @const {number} */
yfiles.tree.LayeredRoutingStyle.ORTHOGONAL;

/** @const */
yfiles.tree.MultiParentRoutingStyle = {};
/** @const {number} */
yfiles.tree.MultiParentRoutingStyle.POLYLINE;
/** @const {number} */
yfiles.tree.MultiParentRoutingStyle.ORTHOGONAL;
/** @const {number} */
yfiles.tree.MultiParentRoutingStyle.STRAIGHT;

/** @const */
yfiles.tree.ParentConnectorDirection = {};
/** @const {number} */
yfiles.tree.ParentConnectorDirection.NONE;
/** @const {number} */
yfiles.tree.ParentConnectorDirection.ANY;
/** @const {number} */
yfiles.tree.ParentConnectorDirection.NORTH;
/** @const {number} */
yfiles.tree.ParentConnectorDirection.EAST;
/** @const {number} */
yfiles.tree.ParentConnectorDirection.SOUTH;
/** @const {number} */
yfiles.tree.ParentConnectorDirection.WEST;

/** @const */
yfiles.tree.PortStyle = {};
/** @const {number} */
yfiles.tree.PortStyle.NODE_CENTER;
/** @const {number} */
yfiles.tree.PortStyle.BORDER_CENTER;
/** @const {number} */
yfiles.tree.PortStyle.BORDER_DISTRIBUTED;
/** @const {number} */
yfiles.tree.PortStyle.PORT_CONSTRAINTS_AWARE;

/** @const */
yfiles.tree.EdgeRoutingStyle = {};
/** @const {number} */
yfiles.tree.EdgeRoutingStyle.PLAIN;
/** @const {number} */
yfiles.tree.EdgeRoutingStyle.ORTHOGONAL;

/** @const */
yfiles.tree.LeafPlacement = {};
/** @const {number} */
yfiles.tree.LeafPlacement.LEAVES_STACKED;
/** @const {number} */
yfiles.tree.LeafPlacement.LEAVES_STACKED_LEFT;
/** @const {number} */
yfiles.tree.LeafPlacement.LEAVES_STACKED_RIGHT;
/** @const {number} */
yfiles.tree.LeafPlacement.LEAVES_STACKED_LEFT_AND_RIGHT;
/** @const {number} */
yfiles.tree.LeafPlacement.ALL_LEAVES_ON_SAME_LAYER;
/** @const {number} */
yfiles.tree.LeafPlacement.SIBLINGS_ON_SAME_LAYER;
/**
 * @record
 * @struct
 */
yfiles.tree.AspectRatioNodePlacer = function() {};
 /** @type {boolean} */
yfiles.tree.AspectRatioNodePlacer.prototype.horizontal;
 /** @type {number} */
yfiles.tree.AspectRatioNodePlacer.prototype.verticalDistance;
 /** @type {number} */
yfiles.tree.AspectRatioNodePlacer.prototype.horizontalDistance;
 /** @type {number} */
yfiles.tree.AspectRatioNodePlacer.prototype.aspectRatio;
 /** @type {yfiles.tree.FillStyle} */
yfiles.tree.AspectRatioNodePlacer.prototype.fillStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.AspectRatioNodePlacer.$class;

/**
 * Creates an {\@link yfiles.collections.IComparer.<T> edge comparator} which takes the initial coordinates of the nodes into account.
 * <p>
 * This {\@link yfiles.collections.IComparer.<T>} defines the order of the outgoing edges of a node before the actual placement of the node's subtree is calculated.
 * It also considers whether or not the rows are placed {\@link yfiles.tree.AspectRatioNodePlacer#horizontal horiontally}.
 * </p>
 * @return {?<!Object>} the {\@link } for the edges
 */
yfiles.tree.AspectRatioNodePlacer.prototype.createFromSketchComparer = function() {};
/**
 * @record
 * @struct
 */
yfiles.tree.AspectRatioTreeLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.tree.AspectRatioTreeLayout.SUBTREE_ASPECT_RATIO_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<yfiles.tree.RootPlacement>} */
yfiles.tree.AspectRatioTreeLayout.ROOT_PLACEMENT_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<yfiles.tree.SubtreeArrangement>} */
yfiles.tree.AspectRatioTreeLayout.SUBTREE_ROUTING_POLICY_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.tree.AspectRatioTreeLayout.SELECTED_ROOT_DP_KEY;
 /** @type {!yfiles.layout.LayoutGraph} */
yfiles.tree.AspectRatioTreeLayout.prototype.graph;
 /** @type {number} */
yfiles.tree.AspectRatioTreeLayout.prototype.horizontalDistance;
 /** @type {number} */
yfiles.tree.AspectRatioTreeLayout.prototype.verticalDistance;
 /** @type {boolean} */
yfiles.tree.AspectRatioTreeLayout.prototype.componentLayoutEnabled;
 /** @type {boolean} */
yfiles.tree.AspectRatioTreeLayout.prototype.hideGroupsStageEnabled;
 /** @type {boolean} */
yfiles.tree.AspectRatioTreeLayout.prototype.parallelEdgeRouterEnabled;
 /** @type {boolean} */
yfiles.tree.AspectRatioTreeLayout.prototype.selfLoopRouterEnabled;
 /** @type {?<!Object>} */
yfiles.tree.AspectRatioTreeLayout.prototype.comparer;
 /** @type {number} */
yfiles.tree.AspectRatioTreeLayout.prototype.aspectRatio;
 /** @type {yfiles.tree.RootPlacement} */
yfiles.tree.AspectRatioTreeLayout.prototype.rootPlacement;
 /** @type {yfiles.tree.SubtreeArrangement} */
yfiles.tree.AspectRatioTreeLayout.prototype.subtreeArrangement;
 /** @type {number} */
yfiles.tree.AspectRatioTreeLayout.prototype.bendDistance;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.AspectRatioTreeLayout.$class;

/**
 * Adds bends to the given {\@link yfiles.layout.IEdgeLayout}.
 * <p>
 * This method is called by {\@link yfiles.tree.AspectRatioTreeLayout#applyLayoutCore} for each edge, after the nodes are placed, to
 * route the path of the edges. It may be overridden to apply a custom routing style.
 * </p>
 * @protected
 * @param {?} edgeLayout the layout of the edge that is routed
 * @param {!yfiles.algorithms.Node} localRoot the local root of the subtree
 * @param {!yfiles.algorithms.Node} child the child connected to the local root with the given edge
 * @param {yfiles.tree.RootPlacement} rootPlacement the placement specifier of the local root
 * @param {yfiles.tree.SubtreeArrangement} routingPolicy the direction specifier for the routing
 * @return {void}
 */
yfiles.tree.AspectRatioTreeLayout.prototype.createBends = function(edgeLayout, localRoot, child, rootPlacement, routingPolicy) {};

/**
 * Retrieves the aspect ratio for the subtree that is rooted at the given node.
 * <p>
 * If there is an individual aspect ratio for the subtree provided by a {\@link yfiles.algorithms.IDataProvider} registered with key
 * {\@link yfiles.tree.AspectRatioTreeLayout#SUBTREE_ASPECT_RATIO_DP_KEY}, that ratio will be returned. Otherwise, the {\@link yfiles.tree.AspectRatioTreeLayout#aspectRatio default aspect ratio}
 * will be returned.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.AspectRatioTreeLayout#applyLayoutCore} before a subtree is arranged. It may be
 * overridden to use another approach to define the aspect ratio for subtrees.
 * </p>
 * @see yfiles.tree.AspectRatioTreeLayout#SUBTREE_ASPECT_RATIO_DP_KEY
 * @see yfiles.tree.AspectRatioTreeLayout#aspectRatio
 * @protected
 * @param {!yfiles.algorithms.Node} localRoot the root node of the subtree
 * @return {number} the aspect ratio of the subtree rooted at the local root node
 */
yfiles.tree.AspectRatioTreeLayout.prototype.getAspectRatio = function(localRoot) {};

/**
 * Retrieves the root placement for the subtree that is rooted at the given node.
 * <p>
 * Either an individual root placement for the subtree (defined via a {\@link yfiles.algorithms.IDataProvider} registered with
 * {\@link yfiles.tree.AspectRatioTreeLayout#ROOT_PLACEMENT_DP_KEY}), or if there is none, the {\@link yfiles.tree.AspectRatioTreeLayout#rootPlacement default root placement} is returned.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.AspectRatioTreeLayout#applyLayoutCore} after a subtree is arranged to align the
 * local root node. It may be overridden to use another approach to define the root placement for a subtree.
 * </p>
 * @see yfiles.tree.AspectRatioTreeLayout#ROOT_PLACEMENT_DP_KEY
 * @see yfiles.tree.AspectRatioTreeLayout#rootPlacement
 * @protected
 * @param {!Object} localRoot the root of the subtree
 * @return {yfiles.tree.RootPlacement} the root placement of the subtree
 */
yfiles.tree.AspectRatioTreeLayout.prototype.getRootPlacement = function(localRoot) {};

/**
 * Retrieves the routing for the subtree that is rooted at the given node.
 * <p>
 * Either an individual routing for the subtree (defined via a {\@link yfiles.algorithms.IDataProvider} registered with
 * {\@link yfiles.tree.AspectRatioTreeLayout#SUBTREE_ROUTING_POLICY_DP_KEY}), or if there is none, the {\@link yfiles.tree.AspectRatioTreeLayout#subtreeArrangement default routing} is returned.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.AspectRatioTreeLayout#applyLayoutCore} to determine the direction of the subtrees.
 * It may be overridden to use another approach to define the routing for a subtree.
 * </p>
 * @see yfiles.tree.AspectRatioTreeLayout#SUBTREE_ROUTING_POLICY_DP_KEY
 * @see yfiles.tree.AspectRatioTreeLayout#subtreeArrangement
 * @protected
 * @param {!Object} localRoot the root of the subtree
 * @return {yfiles.tree.SubtreeArrangement} the routing policy for the subtree
 */
yfiles.tree.AspectRatioTreeLayout.prototype.getSubtreeArrangement = function(localRoot) {};

/**
 * Retrieves all children of the given local root.
 * <p>
 * This method is called by {\@link yfiles.tree.AspectRatioTreeLayout#applyLayoutCore} to arrange the subtrees below the local
 * root.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} localRoot the root of a subtree
 * @return {?} all successors of the given node
 */
yfiles.tree.AspectRatioTreeLayout.prototype.getSuccessors = function(localRoot) {};
/**
 * @record
 * @struct
 */
yfiles.tree.AssistantNodePlacer = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.tree.AssistantNodePlacer.ASSISTANT_NODE_DP_KEY;
 /** @type {number} */
yfiles.tree.AssistantNodePlacer.prototype.spacing;
 /** @type {?} */
yfiles.tree.AssistantNodePlacer.prototype.childNodePlacer;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.AssistantNodePlacer.$class;

/**
 * Creates a {\@link yfiles.collections.IComparer.<T>} that compares outgoing edges connecting to assistant nodes and edges connecting to non-assistant nodes
 * separately.
 * @param {?<!Object>} assistantComparer the {\@link } for edges connecting to <em>assistant</em> nodes
 * @param {?<!Object>} childComparer the {\@link } for edges connecting to <em>non-assistant</em> nodes
 * @return {?<!Object>} a {\@link } that compares edges to assistant nodes separately from edges to non-assistant nodes
 */
yfiles.tree.AssistantNodePlacer.createCompoundComparer = function(assistantComparer, childComparer) {};
/**
 * @record
 * @struct
 */
yfiles.tree.BusNodePlacer = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.tree.BusNodePlacer.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.ClassicTreeLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.tree.ClassicTreeLayout.SELECTED_ROOT_DP_KEY;
 /** @type {boolean} */
yfiles.tree.ClassicTreeLayout.prototype.enforceGlobalLayering;
 /** @type {yfiles.tree.LeafPlacement} */
yfiles.tree.ClassicTreeLayout.prototype.leafPlacement;
 /** @type {boolean} */
yfiles.tree.ClassicTreeLayout.prototype.groupingSupported;
 /** @type {?<!Object>} */
yfiles.tree.ClassicTreeLayout.prototype.comparer;
 /** @type {yfiles.tree.PortStyle} */
yfiles.tree.ClassicTreeLayout.prototype.portStyle;
 /** @type {yfiles.tree.EdgeRoutingStyle} */
yfiles.tree.ClassicTreeLayout.prototype.edgeRoutingStyle;
 /** @type {number} */
yfiles.tree.ClassicTreeLayout.prototype.minimumNodeDistance;
 /** @type {number} */
yfiles.tree.ClassicTreeLayout.prototype.minimumLayerDistance;
 /** @type {boolean} */
yfiles.tree.ClassicTreeLayout.prototype.considerNodeLabels;
 /** @type {boolean} */
yfiles.tree.ClassicTreeLayout.prototype.integratedEdgeLabeling;
 /** @type {number} */
yfiles.tree.ClassicTreeLayout.prototype.busAlignment;
 /** @type {number} */
yfiles.tree.ClassicTreeLayout.prototype.verticalAlignment;
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.ClassicTreeLayout.prototype.modificationMatrix;
 /** @type {boolean} */
yfiles.tree.ClassicTreeLayout.prototype.componentLayoutEnabled;
 /** @type {boolean} */
yfiles.tree.ClassicTreeLayout.prototype.parallelEdgeRouterEnabled;
 /** @type {boolean} */
yfiles.tree.ClassicTreeLayout.prototype.selfLoopRouterEnabled;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.ClassicTreeLayout.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.DefaultNodePlacer = function() {};
 /** @type {yfiles.tree.ChildPlacement} */
yfiles.tree.DefaultNodePlacer.prototype.childPlacement;
 /** @type {yfiles.tree.RootAlignment} */
yfiles.tree.DefaultNodePlacer.prototype.rootAlignment;
 /** @type {number} */
yfiles.tree.DefaultNodePlacer.prototype.verticalAlignment;
 /** @type {yfiles.tree.RoutingStyle} */
yfiles.tree.DefaultNodePlacer.prototype.routingStyle;
 /** @type {number} */
yfiles.tree.DefaultNodePlacer.prototype.verticalDistance;
 /** @type {number} */
yfiles.tree.DefaultNodePlacer.prototype.minimumFirstSegmentLength;
 /** @type {number} */
yfiles.tree.DefaultNodePlacer.prototype.minimumLastSegmentLength;
 /** @type {number} */
yfiles.tree.DefaultNodePlacer.prototype.minimumSlope;
 /** @type {number} */
yfiles.tree.DefaultNodePlacer.prototype.minimumSlopeHeight;
 /** @type {number} */
yfiles.tree.DefaultNodePlacer.prototype.horizontalDistance;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.DefaultNodePlacer.$class;

/**
 * Calculates the bends for the connector to the parent node.
 * <p>
 * This implementation adds bends to the connector for edges that route the edges around the child node in case there are
 * {\@link yfiles.layout.PortConstraint}s that conflict with the direction of the {\@link yfiles.tree.DefaultNodePlacer#childPlacement child placement}.
 * </p>
 * <p>
 * This method is called in {\@link yfiles.tree.DefaultNodePlacer#placeSubtreeOfNode} to route the edges after the
 * {\@link yfiles.tree.SubtreeShape}s are arranged. It may be overridden to customize the routing style.
 * </p>
 * @see yfiles.tree.NodePlacerBase#determineChildConnectors
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} localRoot the local root node whose connector is calculated and stored in the given subtree shape
 * @param {?} rootLayout the {\@link } of the root node
 * @param {!yfiles.tree.SubtreeShape} subtreeShape the shape of the whole subtree of the local root
 * @param {!yfiles.algorithms.Edge} parentEdge the incoming edge of the local root node that will be the connector for the given subtree shape
 * @param {?} parentEdgeLayout the current {\@link } of the connector edge
 * @param {number} direction the direction specifier as defined in the {\@link } interface which should be used for the connector
 * @return {void}
 */
yfiles.tree.DefaultNodePlacer.prototype.calculateParentConnector = function(graph, localRoot, rootLayout, subtreeShape, parentEdge, parentEdgeLayout, direction) {};

/**
 * Calculates the routing of the source side of the edge to the given child node.
 * <p>
 * This method delegates to {\@link yfiles.tree.DefaultNodePlacer#calculateSourceEdgeLayout} if the {\@link yfiles.tree.DefaultNodePlacer#routingStyle routing style} is not
 * {\@link yfiles.tree.RoutingStyle#FORK}. It may be overridden to implement a custom routing style.
 * </p>
 * @protected
 * @param {?} rootLayout the {\@link } of the local root node
 * @param {!yfiles.tree.SubtreeShape} childShape the {\@link } instance of the corresponding child's subtree
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {number} childForkCoordinate the y-coordinate of the second (= last) bend of the edge if the placement is horizontal, the x-coordinate otherwise
 * @param {number} rootForkCoordinate the y-coordinate of the first bend of the edge if the placement is horizontal, the x-coordinate otherwise
 * @return {void}
 */
yfiles.tree.DefaultNodePlacer.prototype.calculateSlopedSourceEdgeLayout = function(rootLayout, childShape, edge, childForkCoordinate, rootForkCoordinate) {};

/**
 * Calculates the routing of the source side of the edge to the given child node.
 * <p>
 * This implementation adds bends to the {\@link yfiles.layout.IEdgeLayout} of the given edge according to the specified {\@link yfiles.tree.DefaultNodePlacer#routingStyle routing style}
 * and {\@link yfiles.tree.DefaultNodePlacer#childPlacement child placement}. It also updates the target points in the {\@link yfiles.tree.SubtreeShape}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.DefaultNodePlacer#calculateSlopedSourceEdgeLayout} to route the edges. It may be
 * overridden to implement a custom edge routing style.
 * </p>
 * @protected
 * @param {?} rootLayout the {\@link } of the local root node
 * @param {!yfiles.tree.SubtreeShape} childShape the {\@link } of the child's subtree that is connected through the given edge
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {void}
 */
yfiles.tree.DefaultNodePlacer.prototype.calculateSourceEdgeLayout = function(rootLayout, childShape, edge) {};

/**
 * Calculates the routing of the target side of the edge to the given child node.
 * <p>
 * This implementation just resets the current {\@link yfiles.layout.IEdgeLayout}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.DefaultNodePlacer#placeSubtreeOfNode} after the {\@link yfiles.tree.SubtreeShape shapes} of the local root's children
 * are placed. It may be overridden to add some {\@link yfiles.tree.SubtreeShape#addTargetPoint target points} to the edge.
 * </p>
 * @protected
 * @param {?} rootLayout the {\@link } of the local root node
 * @param {!yfiles.tree.SubtreeShape} childShape the {\@link } of the child's subtree that is connected through the given edge
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {void}
 */
yfiles.tree.DefaultNodePlacer.prototype.calculateTargetEdgeLayout = function(rootLayout, childShape, edge) {};

/**
 * Creates a {\@link yfiles.collections.IComparer.<T>} for outgoing edges which takes the initial coordinates of the edges' targets into account.
 * <p>
 * Child nodes are sorted in a way that the layout will resemble the current arrangement of the nodes. This is especially
 * useful for interactive or incremental layout calculation.
 * </p>
 * @return {?<!Object>} a {\@link } that considers the initial coordinates of the nodes
 */
yfiles.tree.DefaultNodePlacer.prototype.createComparer = function() {};

/**
 * Delegates to {\@link yfiles.tree.DefaultNodePlacer#createComparer}.
 * @see yfiles.tree.DefaultNodePlacer#createComparer
 * @return {?<!Object>} the From Sketch {\@link }
 */
yfiles.tree.DefaultNodePlacer.prototype.createFromSketchComparer = function() {};
/**
 * @record
 * @struct
 */
yfiles.tree.DefaultPortAssignment = function() {};
 /** @type {yfiles.tree.PortAssignmentMode} */
yfiles.tree.DefaultPortAssignment.prototype.mode;
 /** @type {number} */
yfiles.tree.DefaultPortAssignment.prototype.borderGapToPortGapRatio;
 /** @type {boolean} */
yfiles.tree.DefaultPortAssignment.prototype.reversedPortOrder;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.DefaultPortAssignment.$class;

/**
 * Assigns relative coordinates to the source port of the outgoing edge to a child of the given node.
 * <p>
 * This method is called by {\@link yfiles.tree.DefaultPortAssignment#assignPorts} for each outgoing edge of the given node. It may
 * be overridden to assign a custom location to the source port of outgoing edges.
 * </p>
 * @see yfiles.layout.IEdgeLayout#sourcePoint
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} node the node
 * @param {!yfiles.algorithms.Edge} edge the edge to the child node
 * @param {number} index the zero-based index of the child edge
 * @return {void}
 */
yfiles.tree.DefaultPortAssignment.prototype.assignChildEdgeSourcePort = function(graph, node, edge, index) {};

/**
 * Assigns relative coordinates to the target port of the incoming edge from the parent of the given node.
 * <p>
 * This method is called by {\@link yfiles.tree.DefaultPortAssignment#assignPorts} if the given node has a parent node. It may be
 * overridden to assign a custom location to the target port of the incoming edge.
 * </p>
 * @see yfiles.layout.IEdgeLayout#targetPoint
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} node the node
 * @param {!yfiles.algorithms.Edge} edge the edge from the parent node
 * @return {void}
 */
yfiles.tree.DefaultPortAssignment.prototype.assignParentEdgeTargetPort = function(graph, node, edge) {};

/**
 * Places the ports of edges connecting to the given node according to the {\@link yfiles.tree.DefaultPortAssignment#mode port assignment mode}.
 * @see yfiles.tree.DefaultPortAssignment#mode
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} node the node whose adjacent edges' ports should be placed
 * @return {void}
 */
yfiles.tree.DefaultPortAssignment.prototype.assignPorts = function(graph, node) {};

/**
 * Determines the distance between the outer ports and the border of the node.
 * <p>
 * This implementation calculates the gap according to the number of edges at one side of the node. It also includes the
 * {\@link yfiles.tree.DefaultPortAssignment#borderGapToPortGapRatio ratio between border gap and port gap}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.DefaultPortAssignment#assignChildEdgeSourcePort} to calculate the location of the
 * first port. It may be overridden to implement a different distribution of ports on the node's side.
 * </p>
 * @see yfiles.tree.DefaultPortAssignment#assignChildEdgeSourcePort
 * @see yfiles.tree.DefaultPortAssignment#borderGapToPortGapRatio
 * @protected
 * @param {number} sideLength the width/height of the side
 * @param {number} edgeCount the number of edges that connect to this side
 * @return {number} the absolute gap to be used on both sides of the ports
 */
yfiles.tree.DefaultPortAssignment.prototype.getPortBorderGap = function(sideLength, edgeCount) {};

/**
 * Determines the distance between two adjacent ports.
 * <p>
 * This implementation calculates the gap according to the number of edges at one side of the node. The edges are
 * distributed keeping the given gap to the border of the node.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.DefaultPortAssignment#assignChildEdgeSourcePort} to calculate the distance between
 * two ports. It may be overridden to implement a different distribution of ports on the node's side.
 * </p>
 * @see yfiles.tree.DefaultPortAssignment#assignChildEdgeSourcePort
 * @see yfiles.tree.DefaultPortAssignment#getPortBorderGap
 * @protected
 * @param {number} sideLength the width/height of the side
 * @param {number} edgeCount the number of edges/ports that connect to this side
 * @param {number} portBorderGap the port border gap (i.e. calculated by {\@link #getPortBorderGap})
 * @return {number} the absolute distance to be used between two adjacent ports
 */
yfiles.tree.DefaultPortAssignment.prototype.getPortDistanceDelta = function(sideLength, edgeCount, portBorderGap) {};

/**
 * Retrieves the source {\@link yfiles.layout.PortConstraint} for the given edge.
 * <p>
 * This implementation accesses the {\@link yfiles.algorithms.IDataProvider} registered with
 * {\@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.DefaultPortAssignment#assignChildEdgeSourcePort} in
 * {\@link yfiles.tree.PortAssignmentMode#PORT_CONSTRAINT}.
 * </p>
 * @see yfiles.layout.PortConstraint
 * @see yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY
 * @see yfiles.tree.DefaultPortAssignment#assignChildEdgeSourcePort
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @param {number} index the index of the child that is the target of the given edge
 * @return {!yfiles.layout.PortConstraint} the source {\@link } or <code>null</code> if no source {\@link } is specified
 */
yfiles.tree.DefaultPortAssignment.prototype.getSourcePortConstraint = function(graph, edge, index) {};

/**
 * Retrieves the target {\@link yfiles.layout.PortConstraint} for the given edge.
 * <p>
 * This implementation accesses the {\@link yfiles.algorithms.IDataProvider} registered with
 * {\@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.DefaultPortAssignment#assignParentEdgeTargetPort} in
 * {\@link yfiles.tree.PortAssignmentMode#PORT_CONSTRAINT}.
 * </p>
 * @see yfiles.layout.PortConstraint
 * @see yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY
 * @see yfiles.tree.DefaultPortAssignment#assignParentEdgeTargetPort
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the edge
 * @return {!yfiles.layout.PortConstraint} the target {\@link } or <code>null</code> if no target {\@link } is specified
 */
yfiles.tree.DefaultPortAssignment.prototype.getTargetPortConstraint = function(graph, edge) {};
/**
 * @record
 * @struct
 */
yfiles.tree.DelegatingNodePlacer = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.tree.DelegatingNodePlacer.PRIMARY_NODES_DP_KEY;
 /** @type {?} */
yfiles.tree.DelegatingNodePlacer.prototype.secondaryPlacer;
 /** @type {?} */
yfiles.tree.DelegatingNodePlacer.prototype.primaryPlacer;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.DelegatingNodePlacer.$class;

/**
 * Returns all upper-left children of the local root node.
 * <p>
 * Which children belong to this list is determined using the {\@link yfiles.algorithms.IDataProvider} registered with
 * {\@link yfiles.tree.DelegatingNodePlacer#PRIMARY_NODES_DP_KEY}. If no such {\@link yfiles.algorithms.IDataProvider} is registered, the
 * first half of the children is returned.
 * </p>
 * <p>
 * These children are placed using the {\@link yfiles.tree.INodePlacer} returned by {\@link yfiles.tree.DelegatingNodePlacer#primaryPlacer}.
 * </p>
 * @see yfiles.tree.DelegatingNodePlacer#PRIMARY_NODES_DP_KEY
 * @param {!yfiles.algorithms.Node} localRoot the local root node
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {!yfiles.algorithms.NodeList} the list of upper-left child {\@link }s
 */
yfiles.tree.DelegatingNodePlacer.prototype.primaryChildren = function(localRoot, graph) {};

/**
 * Returns all lower-right children of the local root node.
 * <p>
 * Which children belong to this list is determined using the {\@link yfiles.algorithms.IDataProvider} registered with
 * {\@link yfiles.tree.DelegatingNodePlacer#PRIMARY_NODES_DP_KEY}. If no such {\@link yfiles.algorithms.IDataProvider} is registered, the
 * second half of the children is returned.
 * </p>
 * <p>
 * These children are placed using the {\@link yfiles.tree.INodePlacer} returned by {\@link yfiles.tree.DelegatingNodePlacer#secondaryPlacer}.
 * </p>
 * @see yfiles.tree.DelegatingNodePlacer#PRIMARY_NODES_DP_KEY
 * @param {!yfiles.algorithms.Node} localRoot the local root node
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {!yfiles.algorithms.NodeList} the list of lower-right child {\@link }s
 */
yfiles.tree.DelegatingNodePlacer.prototype.secondaryChildren = function(localRoot, graph) {};
/**
 * @record
 * @struct
 */
yfiles.tree.DendrogramNodePlacer = function() {};
 /** @type {number} */
yfiles.tree.DendrogramNodePlacer.prototype.minimumRootDistance;
 /** @type {number} */
yfiles.tree.DendrogramNodePlacer.prototype.minimumSubtreeDistance;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.DendrogramNodePlacer.$class;

/**
 * Creates a {\@link yfiles.collections.IComparer.<T>} that sorts outgoing edges according to the x-coordinate of their target nodes.
 * <p>
 * This {\@link yfiles.collections.IComparer.<T>} can be used for achieving a From Sketch layout.
 * </p>
 * @see yfiles.tree.DendrogramNodePlacer#createFromSketchComparer
 * @return {?<!Object>} the {\@link }
 */
yfiles.tree.DendrogramNodePlacer.prototype.createComparer = function() {};

/**
 * Creates a {\@link yfiles.collections.IComparer.<T>} for the edges which takes the initial x-coordinates of the nodes into account.
 * <p>
 * This implementation delegates to {\@link yfiles.tree.DendrogramNodePlacer#createComparer}.
 * </p>
 * @see yfiles.tree.DendrogramNodePlacer#createComparer
 * @return {?<!Object>} the {\@link } for the edges
 */
yfiles.tree.DendrogramNodePlacer.prototype.createFromSketchComparer = function() {};

/**
 * Creates an optional {\@link yfiles.tree.IProcessor} for pre- and post-processing.
 * <p>
 * This implementation returns <code>null</code>. Hence, no pre- or post-processing is done.
 * </p>
 * @param {!yfiles.tree.TreeLayout} layouter the current {\@link } instance
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} currentRoot the root node handled by this {\@link }
 * @return {?} <code>null</code>
 */
yfiles.tree.DendrogramNodePlacer.prototype.createProcessor = function(layouter, graph, currentRoot) {};

/**
 * Provides {\@link yfiles.tree.ParentConnectorDirection#NORTH} for all children.
 * <p>
 * Edges will always connect to the top of the child nodes.
 * </p>
 * @param {!yfiles.algorithms.Node} localRoot the local root node
 * @param {?} connectorMap the map that is used for storing the direction specifiers of the child nodes
 * @return {void}
 */
yfiles.tree.DendrogramNodePlacer.prototype.determineChildConnectors = function(localRoot, connectorMap) {};

/**
 * Arranges the {\@link yfiles.tree.SubtreeShape SubtreeShapes} of the local root and its children as a dendrogram.
 * @param {?} nodeShapeProvider the {\@link } for obtaining an initial shape of the root node
 * @param {?} subtreeShapeProvider the {\@link } for accessing the pre-calculated shapes of the subtrees
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} localRoot the root of the subtree that should be arranged by this method
 * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction specifier for the connector of the local root node to its parent node
 * @return {!yfiles.tree.SubtreeShape} the combined shape of the whole subtree rooted at the given local root node
 */
yfiles.tree.DendrogramNodePlacer.prototype.placeSubtree = function(nodeShapeProvider, subtreeShapeProvider, graph, localRoot, parentConnectorDirection) {};
/**
 * @record
 * @struct
 */
yfiles.tree.DoubleLineNodePlacer = function() {};
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.DoubleLineNodePlacer.prototype.rootAlignment;
 /** @type {number} */
yfiles.tree.DoubleLineNodePlacer.prototype.doubleLineSpacingRatio;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.DoubleLineNodePlacer.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.FreeNodePlacer = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.tree.FreeNodePlacer.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.GridNodePlacer = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.tree.GridNodePlacer.ROW_INDEX_DP_KEY;
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.GridNodePlacer.prototype.rootAlignment;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.GridNodePlacer.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.GroupedNodePlacer = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.tree.GroupedNodePlacer.$class;

/**
 * Creates a {\@link yfiles.tree.IProcessor} that prepares the graph for edge grouping.
 * <p>
 * In a pre-processing step, the {\@link yfiles.tree.IProcessor} inserts a dummy node for each edge group and connects it to the
 * local root and the edges of the according group. The child node placer is assigned to those dummy nodes and will arrange
 * them during the layout calculation.
 * </p>
 * <p>
 * The changes to the graph are restored in a post-processing step.
 * </p>
 * @see yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY
 * @see yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY
 * @param {!yfiles.tree.TreeLayout} layouter the current {\@link } instance
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} currentRoot the root node handled by this {\@link }
 * @return {?} the {\@link } responsible for preparing the graph
 */
yfiles.tree.GroupedNodePlacer.prototype.createProcessor = function(layouter, graph, currentRoot) {};

/**
 * Delegates to the {\@link yfiles.tree.INodePlacer} responsible for arranging the nodes in one group.
 * @param {!yfiles.algorithms.Node} localRoot the local root node
 * @param {?} connectorMap the map used for storing the direction specifiers of the child nodes
 * @return {void}
 */
yfiles.tree.GroupedNodePlacer.prototype.determineChildConnectors = function(localRoot, connectorMap) {};

/**
 * Places the groups of {\@link yfiles.tree.SubtreeShape}s according to their group IDs.
 * @see yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY
 * @see yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY
 * @param {?} nodeShapeProvider the {\@link } for obtaining an initial shape of the root node
 * @param {?} subtreeShapeProvider the {\@link } for accessing the pre-calculated shapes of the subtrees
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} localRoot the root of the subtree that should be arranged by this method
 * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction specifier for the connector of the local root node to its parent node
 * @return {!yfiles.tree.SubtreeShape} the merged {\@link }s of the local root and its children
 */
yfiles.tree.GroupedNodePlacer.prototype.placeSubtree = function(nodeShapeProvider, subtreeShapeProvider, graph, localRoot, parentConnectorDirection) {};
/**
 * @record
 * @struct
 */
yfiles.tree.IFromSketchNodePlacer = function() {};

/**
 * Creates an {\@link yfiles.collections.IComparer.<T> edge comparator} which takes the initial coordinates of the nodes into account.
 * <p>
 * This {\@link yfiles.collections.IComparer.<T>} defines the order of the outgoing edges of a node before the actual placement of the node's subtree is
 * calculated.
 * </p>
 * @abstract
 * @return {?<!Object>} the {\@link } for the edges
 */
yfiles.tree.IFromSketchNodePlacer.prototype.createFromSketchComparer = function() {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.tree.IFromSketchNodePlacer;
/**
 * @record
 * @struct
 */
yfiles.tree.INodePlacer = function() {};

/**
 * Creates an optional {\@link yfiles.tree.IProcessor} for pre- and post-processing.
 * <p>
 * This method is called by {\@link yfiles.tree.TreeLayout} before arranging the {\@link yfiles.tree.SubtreeShape SubtreeShapes}. If no pre- or post-processing is
 * needed, this method may return <code>null</code>.
 * </p>
 * @abstract
 * @param {!yfiles.tree.TreeLayout} layouter the current {\@link } instance
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} currentRoot the root node handled by this {\@link }
 * @return {?} a {\@link } instance or <code>null</code>
 */
yfiles.tree.INodePlacer.prototype.createProcessor = function(layouter, graph, currentRoot) {};

/**
 * Provides the direction of the connector to the {\@link yfiles.tree.SubtreeShape SubtreeShape} for each child node.
 * <p>
 * This method is called by {\@link yfiles.tree.TreeLayout} before the {\@link yfiles.tree.SubtreeShape SubtreeShapes} for the children of the local root node are
 * calculated. The direction specifiers are stored in the given map for all child nodes of the local root.
 * </p>
 * @abstract
 * @param {!yfiles.algorithms.Node} localRoot the local root node
 * @param {?} connectorMap the map that must be used for storing the direction specifiers of the child nodes
 * @return {void}
 */
yfiles.tree.INodePlacer.prototype.determineChildConnectors = function(localRoot, connectorMap) {};

/**
 * Arranges the {\@link yfiles.tree.SubtreeShape SubtreeShapes} of the local root and its children and routes the edges that connect them.
 * <p>
 * This method is the main method of the tree layout algorithm. It is called by {\@link yfiles.tree.TreeLayout} in each recursion
 * step to place the local root in relation to its children. Their shapes will be merged into one
 * {\@link yfiles.tree.SubtreeShape SubtreeShape}, which is returned by this method.
 * </p>
 * <p>
 * The {\@link yfiles.tree.SubtreeShape SubtreeShape} for the local root can be obtained from the <code>nodeShapeProvider</code>. <code>subtreeShapeProvider</code> contains the {\@link yfiles.tree.SubtreeShape SubtreeShapes}
 * assigned to the child nodes.
 * </p>
 * <p>
 * Due to the order in which the tree nodes are processed, it is guaranteed that at the time of the invocation of this
 * method the {\@link yfiles.tree.SubtreeShape SubtreeShape} of every descendant node has already been calculated.
 * </p>
 * @abstract
 * @param {?} nodeShapeProvider the {\@link } for obtaining an initial shape of the root node
 * @param {?} subtreeShapeProvider the {\@link } for accessing the pre-calculated shapes of the subtrees
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} localRoot the root of the subtree that should be arranged by this method
 * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction specifier for the connector of the local root node to its parent node
 * @return {!yfiles.tree.SubtreeShape} the combined shape of the whole subtree
 */
yfiles.tree.INodePlacer.prototype.placeSubtree = function(nodeShapeProvider, subtreeShapeProvider, graph, localRoot, parentConnectorDirection) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.tree.INodePlacer;
/**
 * @record
 * @struct
 */
yfiles.tree.IPortAssignment = function() {};

/**
 * Places the ports of edges connecting to the given node.
 * <p>
 * This method is called by {\@link yfiles.tree.TreeLayout} before the actual layout calculation takes place. It assigns both the
 * single incoming edge's target port as well as all source ports of all outgoing child edges.
 * </p>
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the graph
 * @param {!yfiles.algorithms.Node} node the node whose adjacent edges' ports should be set
 * @return {void}
 */
yfiles.tree.IPortAssignment.prototype.assignPorts = function(graph, node) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.tree.IPortAssignment;
/**
 * @record
 * @struct
 */
yfiles.tree.IProcessor = function() {};

/**
 * This method is called by the {\@link yfiles.tree.TreeLayout} after the layout has finished.
 * <p>
 * It can be used for cleanup tasks.
 * </p>
 * <p>
 * Changes on the graph structure that have been made in {\@link yfiles.tree.IProcessor#preProcess} can be undone here.
 * </p>
 * @abstract
 * @return {void}
 */
yfiles.tree.IProcessor.prototype.postProcess = function() {};

/**
 * Performs preparations for the actual tree layout in a pre-processing step.
 * <p>
 * This method is called by {\@link yfiles.tree.TreeLayout} before the {\@link yfiles.tree.INodePlacer}s are called recursively. A {\@link yfiles.tree.IProcessor}
 * may change some settings within this method. This can be used for specifying values for the children of the local root,
 * manipulate the graph structure or do anything else that needs to be done.
 * </p>
 * @abstract
 * @param {?} nodePlacerDataProvider the map that stores a {\@link } instance for each node
 * @param {?} portAssignmentDataProvider The map that stores a {\@link } instance for each node
 * @param {?} childComparatorProvider the map that stores a {\@link } instance for each node
 * @return {void}
 */
yfiles.tree.IProcessor.prototype.preProcess = function(nodePlacerDataProvider, portAssignmentDataProvider, childComparatorProvider) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.tree.IProcessor;
/**
 * @record
 * @struct
 */
yfiles.tree.LayeredNodePlacer = function() {};
 /** @type {boolean} */
yfiles.tree.LayeredNodePlacer.prototype.dendrogramStyle;
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.LayeredNodePlacer.prototype.rootAlignment;
 /** @type {number} */
yfiles.tree.LayeredNodePlacer.prototype.verticalAlignment;
 /** @type {!Object} */
yfiles.tree.LayeredNodePlacer.prototype.id;
 /** @type {number} */
yfiles.tree.LayeredNodePlacer.prototype.layerSpacing;
 /** @type {yfiles.tree.LayeredRoutingStyle} */
yfiles.tree.LayeredNodePlacer.prototype.routingStyle;
 /** @type {number} */
yfiles.tree.LayeredNodePlacer.prototype.busAlignment;
 /** @type {boolean} */
yfiles.tree.LayeredNodePlacer.prototype.polylineLabeling;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.LayeredNodePlacer.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.LeafNodePlacer = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.tree.LeafNodePlacer.$class;

/**
 * Creates an optional {\@link yfiles.tree.IProcessor} for pre- and post-processing.
 * <p>
 * This implementation returns <code>null</code>. Hence, no pre- or post-processing is done.
 * </p>
 * @param {!yfiles.tree.TreeLayout} layouter the current {\@link } instance
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} currentRoot the root node handled by this {\@link }
 * @return {?} <code>null</code>
 */
yfiles.tree.LeafNodePlacer.prototype.createProcessor = function(layouter, graph, currentRoot) {};

/**
 * Does nothing because leaf nodes don't have children so there are no child connectors.
 * @param {!yfiles.algorithms.Node} localRoot the local root node
 * @param {?} connectorMap the map that must be used for storing the direction specifiers of the child nodes
 * @return {void}
 */
yfiles.tree.LeafNodePlacer.prototype.determineChildConnectors = function(localRoot, connectorMap) {};

/**
 * Creates a {\@link yfiles.tree.SubtreeShape} for the local root node (a leaf node in this case) and adds target points to the
 * incoming edge.
 * <p>
 * The incoming edge is routed according to possibly assigned {\@link yfiles.layout.PortConstraint}s.
 * </p>
 * @param {?} nodeShapeProvider the {\@link } for obtaining an initial shape of the root node
 * @param {?} subtreeShapeProvider the {\@link } for accessing the pre-calculated shapes of the subtrees
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} localRoot the root of the subtree that should be arranged by this method
 * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction specifier for the connector of the local root node to its parent node
 * @return {!yfiles.tree.SubtreeShape} the {\@link } of the leaf node including the connector
 */
yfiles.tree.LeafNodePlacer.prototype.placeSubtree = function(nodeShapeProvider, subtreeShapeProvider, graph, localRoot, parentConnectorDirection) {};
/**
 * @record
 * @struct
 */
yfiles.tree.LeftRightNodePlacer = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.tree.LeftRightNodePlacer.LEFT_RIGHT_DP_KEY;
 /** @type {number} */
yfiles.tree.LeftRightNodePlacer.prototype.horizontalDistance;
 /** @type {number} */
yfiles.tree.LeftRightNodePlacer.prototype.verticalDistance;
 /** @type {number} */
yfiles.tree.LeftRightNodePlacer.prototype.spacing;
 /** @type {boolean} */
yfiles.tree.LeftRightNodePlacer.prototype.placeLastOnBottom;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.LeftRightNodePlacer.$class;

/**
 * Creates a special {\@link yfiles.algorithms.IDataProvider} that determines whether a given node is placed left or right of the
 * parent node.
 * <p>
 * This {\@link yfiles.algorithms.IDataProvider} can be registered with the graph with key
 * {\@link yfiles.tree.LeftRightNodePlacer#LEFT_RIGHT_DP_KEY}. It calculates the side with respect to the initial coordinates of the
 * nodes in the graph, considering the orientation of the subtree.
 * </p>
 * <p>
 * If a node is assigned to the left side, this {\@link yfiles.algorithms.IDataProvider} will return <code>true</code>. For the right side, it
 * will return <code>false</code>.
 * </p>
 * @param {?} nodePlacerMap a {\@link } containing the corresponding {\@link }s for the node
 * @return {?}
 */
yfiles.tree.LeftRightNodePlacer.createLeftRightDataProvider = function(nodePlacerMap) {};
/**
 * @record
 * @struct
 */
yfiles.tree.MultiParentDescriptor = function() {};
 /** @type {number} */
yfiles.tree.MultiParentDescriptor.prototype.minimumNodeDistance;
 /** @type {number} */
yfiles.tree.MultiParentDescriptor.prototype.minimumBusDistance;
 /** @type {number} */
yfiles.tree.MultiParentDescriptor.prototype.verticalAlignment;
 /** @type {yfiles.tree.MultiParentRoutingStyle} */
yfiles.tree.MultiParentDescriptor.prototype.edgeStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.MultiParentDescriptor.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.NodeOrderComparer = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.tree.NodeOrderComparer.NODE_ORDER_COMPARABLE_DP_KEY;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.NodeOrderComparer.$class;

/**
 * Compares two edges according to their index in the order specified using a {\@link yfiles.algorithms.IDataProvider}.
 * <p>
 * Target nodes for which the {\@link yfiles.algorithms.IDataProvider} registered with {\@link yfiles.tree.NodeOrderComparer#NODE_ORDER_COMPARABLE_DP_KEY}
 * returns <code>null</code> or an {\@link Object} that does not implement {\@link yfiles.lang.IComparable} are treated as being smaller than other target
 * nodes.
 * </p>
 * @see yfiles.tree.NodeOrderComparer#NODE_ORDER_COMPARABLE_DP_KEY
 * @param {!Object} edge1 the first edge
 * @param {!Object} edge2 the second edge
 * @return {number}
 */
yfiles.tree.NodeOrderComparer.prototype.compare = function(edge1, edge2) {};
/**
 * @record
 * @struct
 */
yfiles.tree.NodePlacerBase = function() {};
 /** @type {!yfiles.layout.LayoutGraph} */
yfiles.tree.NodePlacerBase.prototype.graph;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.NodePlacerBase.$class;

/**
 * Returns a clone of this {\@link yfiles.tree.INodePlacer} instance.
 * @return {!Object} an exact copy of this {\@link } instance
 */
yfiles.tree.NodePlacerBase.prototype.clone = function() {};

/**
 * Creates an optional {\@link yfiles.tree.IProcessor} for pre- and post-processing.
 * <p>
 * This implementation returns <code>null</code>. Hence, no pre- or post-processing will be done.
 * </p>
 * @param {!yfiles.tree.TreeLayout} layouter the current {\@link } instance
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} currentRoot the root node handled by this {\@link }
 * @return {?} <code>null</code>
 */
yfiles.tree.NodePlacerBase.prototype.createProcessor = function(layouter, graph, currentRoot) {};

/**
 * Determines a connector direction for the given child node.
 * <p>
 * This method is used in {\@link yfiles.tree.NodePlacerBase#determineChildConnectors} and must be implemented by subclasses.
 * </p>
 * @protected
 * @abstract
 * @param {!yfiles.algorithms.Node} child the child node
 * @return {yfiles.tree.ParentConnectorDirection} a direction specifier as defined in the {\@link } interface
 */
yfiles.tree.NodePlacerBase.prototype.determineChildConnector = function(child) {};

/**
 * Provides the direction of the connector to the {\@link yfiles.tree.SubtreeShape SubtreeShape} for each child node.
 * <p>
 * This implementation uses {\@link yfiles.tree.NodePlacerBase#determineChildConnector} to retrieve the direction for the
 * connectors.
 * </p>
 * @param {!yfiles.algorithms.Node} localRoot the local root node
 * @param {?} connectorMap the map that must be used for storing the direction specifiers of the child nodes
 * @return {void}
 */
yfiles.tree.NodePlacerBase.prototype.determineChildConnectors = function(localRoot, connectorMap) {};

/**
 * Returns the {\@link yfiles.tree.SubtreeShape} for the given node.
 * <p>
 * This is a convenience method that retrieves a {\@link yfiles.tree.SubtreeShape} for a single node from the corresponding
 * {\@link yfiles.algorithms.IDataProvider}.
 * </p>
 * <p>
 * This method is used in {\@link yfiles.tree.NodePlacerBase#placeSubtreeOfNode} for retrieving the {\@link yfiles.tree.SubtreeShape}s for
 * the local root nodes. It may be overridden to return a custom implementation of {\@link yfiles.tree.SubtreeShape}.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} node the node
 * @return {!yfiles.tree.SubtreeShape} the {\@link } for the given node
 */
yfiles.tree.NodePlacerBase.prototype.getNodeShape = function(node) {};

/**
 * Returns the {\@link yfiles.tree.SubtreeShape} for the subtree rooted at the given node.
 * <p>
 * This is a convenience method that retrieves a {\@link yfiles.tree.SubtreeShape} of a complete subtree from the corresponding
 * {\@link yfiles.algorithms.IDataProvider}.
 * </p>
 * <p>
 * This method is used in {\@link yfiles.tree.NodePlacerBase#placeSubtreeOfNode} for retrieving the {\@link yfiles.tree.SubtreeShape}s for
 * the subtrees that are arranged. It may be overridden to return a custom implementation of {\@link yfiles.tree.SubtreeShape}.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} node the local root node
 * @return {!yfiles.tree.SubtreeShape} the {\@link } of the subtree rooted at the given local root node
 */
yfiles.tree.NodePlacerBase.prototype.getSubtreeShape = function(node) {};

/**
 * Initializes the local data structures and then delegates the work to the abstract variant of this method
 * ({\@link yfiles.tree.NodePlacerBase#placeSubtreeOfNode})
 * @see yfiles.tree.NodePlacerBase#placeSubtreeOfNode
 * @param {?} nodeShapeProvider the {\@link } for obtaining an initial shape of the root node
 * @param {?} subtreeShapeProvider the {\@link } for accessing the pre-calculated shapes of the subtrees
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} localRoot the root of the subtree that should be arranged by this method
 * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction specifier for the connector of the local root node to its parent node
 * @return {!yfiles.tree.SubtreeShape} the merged {\@link } for the subtree rooted at the local root node
 */
yfiles.tree.NodePlacerBase.prototype.placeSubtree = function(nodeShapeProvider, subtreeShapeProvider, graph, localRoot, parentConnectorDirection) {};

/**
 * Arranges the local root relative to the {\@link yfiles.tree.SubtreeShape} of its children.
 * <p>
 * This is the main method that must be implemented by subclasses. It is called by
 * {\@link yfiles.tree.NodePlacerBase#placeSubtree}.
 * </p>
 * @protected
 * @abstract
 * @param {!yfiles.algorithms.Node} localRoot the local root node
 * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction of the connector
 * @return {!yfiles.tree.SubtreeShape} a {\@link } instance that describes the shape of the whole subtree rooted at the given local root
 */
yfiles.tree.NodePlacerBase.prototype.placeSubtreeOfNode = function(localRoot, parentConnectorDirection) {};
/**
 * @record
 * @struct
 */
yfiles.tree.RootNodeAlignment = function() {};
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.RootNodeAlignment.CENTER;
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.RootNodeAlignment.MEDIAN;
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.RootNodeAlignment.LEADING;
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.RootNodeAlignment.TRAILING;
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.RootNodeAlignment.LEFT;
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.RootNodeAlignment.RIGHT;
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.RootNodeAlignment.CENTER_OVER_CHILDREN;
 /** @type {!Array<!yfiles.tree.RootNodeAlignment>} */
yfiles.tree.RootNodeAlignment.ALL;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.RootNodeAlignment.$class;

/**
 * Calculates the common bounds of the given subtree shapes.
 * <p>
 * This method can be used when placing the local root above its subtrees in method
 * {\@link yfiles.tree.RootNodeAlignment#placeParentHorizontal}.
 * </p>
 * @protected
 * @param {?<!Object>} shapes a list of rotated subtree shapes
 * @return {!yfiles.algorithms.Rectangle2D} the rectangle describing the bounds containing all given shapes
 */
yfiles.tree.RootNodeAlignment.getBounds = function(shapes) {};

/**
 * Moves the shape of the local root to a suitable position relative to the children's shapes.
 * <p>
 * The movement should only be done on the x-axis (horizontally).
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.RotatableNodePlacerBase}s when they {\@link yfiles.tree.RotatableNodePlacerBase#placeSubtreeOfNode place the subtrees}.
 * </p>
 * @protected
 * @abstract
 * @param {!yfiles.tree.RotatedSubtreeShape} rootShape the shape of the local root node that will be moved
 * @param {?<!Object>} shapes a list of rotated subtree shapes, representing the shapes of the child nodes
 * @param {!yfiles.algorithms.Rectangle2D} shapeBounds accumulated bounds of the shapes of all child nodes
 * @param {number} spacing the spacing value that should be used
 * @return {void}
 */
yfiles.tree.RootNodeAlignment.prototype.placeParentHorizontal = function(rootShape, shapes, shapeBounds, spacing) {};
/**
 * @record
 * @struct
 */
yfiles.tree.RotatableNodePlacerMatrix = function() {};
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.RotatableNodePlacerMatrix.DEFAULT;
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.RotatableNodePlacerMatrix.ROT90;
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.RotatableNodePlacerMatrix.ROT180;
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.RotatableNodePlacerMatrix.ROT270;
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.RotatableNodePlacerMatrix.MIR_HOR;
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.RotatableNodePlacerMatrix.MIR_VERT;
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.RotatableNodePlacerMatrix.MIR_HOR_ROT90;
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.RotatableNodePlacerMatrix.MIR_VERT_ROT90;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.RotatableNodePlacerMatrix.$class;

/**
 * Compares the values of the current {\@link yfiles.tree.RotatableNodePlacerMatrix} with the values of the given
 * {\@link yfiles.tree.RotatableNodePlacerMatrix}.
 * @param {!yfiles.tree.RotatableNodePlacerMatrix} other the matrix
 * @return {boolean} <code>true</code> if this matrix and the given other matrix contain the same values, <code>false</code> otherwise
 */
yfiles.tree.RotatableNodePlacerMatrix.prototype.equalValues = function(other) {};

/**
 * Multiplies this {\@link yfiles.tree.RotatableNodePlacerMatrix} with the given other {\@link yfiles.tree.RotatableNodePlacerMatrix}.
 * @param {!yfiles.tree.RotatableNodePlacerMatrix} other the other matrix
 * @return {!yfiles.tree.RotatableNodePlacerMatrix} the product of both matrices
 */
yfiles.tree.RotatableNodePlacerMatrix.prototype.multiply = function(other) {};
/**
 * @record
 * @struct
 */
yfiles.tree.RotatableNodePlacerBase = function() {};
 /** @type {!yfiles.layout.LayoutGraph} */
yfiles.tree.RotatableNodePlacerBase.prototype.graph;
 /** @type {?} */
yfiles.tree.RotatableNodePlacerBase.prototype.subtreeShapeProvider;
 /** @type {?} */
yfiles.tree.RotatableNodePlacerBase.prototype.nodeShapeProvider;
 /** @type {?<!Object>} */
yfiles.tree.RotatableNodePlacerBase.prototype.createdChildren;
 /** @type {!yfiles.tree.RotatableNodePlacerMatrix} */
yfiles.tree.RotatableNodePlacerBase.prototype.modificationMatrix;
 /** @type {number} */
yfiles.tree.RotatableNodePlacerBase.prototype.spacing;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.RotatableNodePlacerBase.$class;

/**
 * Creates a {\@link yfiles.collections.IComparer.<T>} for outgoing edges that takes the rotation into account.
 * @return {?<!Object>} the {\@link } that considers the rotation
 */
yfiles.tree.RotatableNodePlacerBase.prototype.createComparer = function() {};

/**
 * Delegates to {\@link yfiles.tree.RotatableNodePlacerBase#createComparer}.
 * @see yfiles.tree.RotatableNodePlacerBase#createComparer
 * @return {?<!Object>} the From Sketch {\@link }
 */
yfiles.tree.RotatableNodePlacerBase.prototype.createFromSketchComparer = function() {};

/**
 * Creates an optional {\@link yfiles.tree.IProcessor} for pre- and post-processing.
 * <p>
 * This implementation returns <code>null</code>. Hence, no pre- or post-processing is done.
 * </p>
 * @param {!yfiles.tree.TreeLayout} layouter the current {\@link } instance
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} currentRoot the root node handled by this {\@link }
 * @return {?} <code>null</code>
 */
yfiles.tree.RotatableNodePlacerBase.prototype.createProcessor = function(layouter, graph, currentRoot) {};

/**
 * Determines a connector direction for the given child node.
 * <p>
 * This method is called by {\@link yfiles.tree.RotatableNodePlacerBase#determineChildConnectors} and must be implemented by
 * subclasses. Implementations can assume the default direction (top-to-bottom) for their arrangement.
 * </p>
 * @protected
 * @abstract
 * @param {!yfiles.algorithms.Node} child the child node
 * @return {yfiles.tree.ParentConnectorDirection} a direction specifier as defined in the {\@link } interface
 */
yfiles.tree.RotatableNodePlacerBase.prototype.determineChildConnector = function(child) {};

/**
 * Provides the direction of the connector to the {\@link yfiles.tree.SubtreeShape SubtreeShape} for each child node.
 * <p>
 * This implementation uses {\@link yfiles.tree.RotatableNodePlacerBase#determineChildConnector} and the {\@link yfiles.tree.RotatableNodePlacerBase#modificationMatrix modification matrix} to
 * retrieve the direction for the connectors.
 * </p>
 * @see yfiles.tree.RotatableNodePlacerBase#determineChildConnector
 * @param {!yfiles.algorithms.Node} localRoot the local root
 * @param {?} connectorMap the map that must be used for storing the direction specifiers of the child nodes
 * @return {void}
 */
yfiles.tree.RotatableNodePlacerBase.prototype.determineChildConnectors = function(localRoot, connectorMap) {};

/**
 * Returns the rotated subtree shape for the given node.
 * <p>
 * This is a convenience method that retrieves a rotated subtree shape for a single node from the corresponding
 * {\@link yfiles.algorithms.IDataProvider}. This shape may be modified and returned by
 * {\@link yfiles.tree.RotatableNodePlacerBase#placeSubtreeOfNode}.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} node the node
 * @return {!yfiles.tree.RotatedSubtreeShape} the subtree shape for the given node
 */
yfiles.tree.RotatableNodePlacerBase.prototype.getNodeShape = function(node) {};

/**
 * Returns the target {\@link yfiles.layout.PortConstraint} for the local root's incoming edge.
 * <p>
 * This method translates the {\@link yfiles.layout.PortConstraint} according to the rotation described by the {\@link yfiles.tree.RotatableNodePlacerBase#modificationMatrix modification matrix}.
 * It should be used instead of {\@link yfiles.layout.PortConstraint#getTPC}.
 * </p>
 * <p>
 * This method may be used in {\@link yfiles.tree.RotatableNodePlacerBase#placeSubtreeOfNode} to route the edges to the according
 * port. It may be overridden to provide constant {\@link yfiles.layout.PortConstraint}s for each node.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} localRoot the local root
 * @return {!yfiles.layout.PortConstraint} the {\@link } for the incoming edge of the local root or {\@link #ANY} if no {\@link }
 * is assigned for that edge
 */
yfiles.tree.RotatableNodePlacerBase.prototype.getPortConstraint = function(localRoot) {};

/**
 * Returns the absolute source point of the given edge depending on the rotation of this {\@link yfiles.tree.INodePlacer}.
 * <p>
 * This method translates the source point according to the rotation described by the {\@link yfiles.tree.RotatableNodePlacerBase#modificationMatrix modification matrix}. It should be
 * used instead of {\@link yfiles.layout.LayoutGraph#getSourcePointAbs}.
 * </p>
 * <p>
 * It can be used in an implementation of {\@link yfiles.tree.RotatableNodePlacerBase#placeSubtreeOfNode}.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Edge} edge the edge whose absolute source point should be calculated
 * @return {!yfiles.algorithms.YPoint} the translated absolute source point for the given edge and current modification matrix
 */
yfiles.tree.RotatableNodePlacerBase.prototype.getSourcePointAbs = function(edge) {};

/**
 * Returns the rotated subtree shape for the subtree rooted at the given node.
 * <p>
 * This is a convenience method that retrieves a subtree shape of a complete subtree from the corresponding
 * {\@link yfiles.algorithms.IDataProvider}.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} node the local root node
 * @return {!yfiles.tree.RotatedSubtreeShape} the rotated subtree shape of the subtree rooted at the given local root node
 */
yfiles.tree.RotatableNodePlacerBase.prototype.getSubtreeShape = function(node) {};

/**
 * Initializes the local data structures and then delegates the work to the abstract variant of this method
 * ({\@link yfiles.tree.RotatableNodePlacerBase#placeSubtreeOfNode}).
 * @see yfiles.tree.RotatableNodePlacerBase#placeSubtreeOfNode
 * @param {?} nodeShapeProvider the {\@link } for obtaining an initial shape of the root node
 * @param {?} subtreeShapeProvider the {\@link } for accessing the pre-calculated shapes of the subtrees
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} localRoot the root of the subtree that should be arranged by this method
 * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction specifier for the connector of the local root node to its parent node
 * @return {!yfiles.tree.SubtreeShape} the merged {\@link } for the subtree rooted at the local root node
 */
yfiles.tree.RotatableNodePlacerBase.prototype.placeSubtree = function(nodeShapeProvider, subtreeShapeProvider, graph, localRoot, parentConnectorDirection) {};

/**
 * Arranges the local root relative to the rotated subtree shapes of its children.
 * <p>
 * This is the main method that must be implemented by subclasses. For calculations and locations subclasses should use the
 * corresponding methods of {\@link yfiles.tree.RotatableNodePlacerBase} which already consider the {\@link yfiles.tree.RotatableNodePlacerBase#modificationMatrix modification matrix}.
 * </p>
 * @protected
 * @abstract
 * @param {!yfiles.algorithms.Node} localRoot the local root node
 * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction specifier for the connector of the local root node to its parent node
 * @return {!yfiles.tree.RotatedSubtreeShape} the merged subtree shape that contains the local root node and all its children
 */
yfiles.tree.RotatableNodePlacerBase.prototype.placeSubtreeOfNode = function(localRoot, parentConnectorDirection) {};

/**
 * Translates the given real direction of the resulting layout to the model direction of this
 * {\@link yfiles.tree.RotatableNodePlacerBase}.
 * <p>
 * This method is used in {\@link yfiles.tree.RotatableNodePlacerBase#placeSubtreeOfNode} to be able to retrieve the model direction
 * for the connector
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if translation for the given real direction is not implemented
 * @protected
 * @param {yfiles.tree.ParentConnectorDirection} realDirection the real direction
 * @return {number} the model direction
 */
yfiles.tree.RotatableNodePlacerBase.prototype.translateDirectionToModel = function(realDirection) {};

/**
 * Translates the given model direction to the real direction in the resulting layout.
 * <p>
 * This method is used in {\@link yfiles.tree.RotatableNodePlacerBase#determineChildConnectors} to be able to return the real
 * connector direction.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if translation for the given model direction is not implemented
 * @protected
 * @param {yfiles.tree.ParentConnectorDirection} modelDirection the model direction
 * @return {number} the real direction
 */
yfiles.tree.RotatableNodePlacerBase.prototype.translateDirectionToReal = function(modelDirection) {};

/**
 * Translates a point from the real layout direction to the model direction using the given modification matrix.
 * @param {!yfiles.tree.RotatableNodePlacerMatrix} modificationMatrix the modification matrix to use for the translation
 * @param {!yfiles.algorithms.YPoint} realWorldPoint the point with coordinates from the real world
 * @return {!yfiles.algorithms.YPoint} the translated point with coordinates from the model
 */
yfiles.tree.RotatableNodePlacerBase.translatePoint = function(modificationMatrix, realWorldPoint) {};
/**
 * @record
 * @struct
 */
yfiles.tree.RotatedSubtreeShape = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.tree.RotatedSubtreeShape.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.SimpleNodePlacer = function() {};
 /** @type {!yfiles.tree.RootNodeAlignment} */
yfiles.tree.SimpleNodePlacer.prototype.rootAlignment;
 /** @type {number} */
yfiles.tree.SimpleNodePlacer.prototype.verticalAlignment;
 /** @type {boolean} */
yfiles.tree.SimpleNodePlacer.prototype.createBus;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.SimpleNodePlacer.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.TreeComponentLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.tree.TreeComponentLayout.DUMMY_NODE_DP_KEY;
 /** @type {?} */
yfiles.tree.TreeComponentLayout.prototype.coreLayout;
 /** @type {?} */
yfiles.tree.TreeComponentLayout.prototype.treeComponentCoreLayout;
 /** @type {boolean} */
yfiles.tree.TreeComponentLayout.prototype.optimizeOrientation;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.TreeComponentLayout.$class;

/**
 * Finds the tree components inside the given graph and applies a {\@link yfiles.tree.TreeComponentLayout#treeComponentCoreLayout tree layout} to them.
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {void}
 */
yfiles.tree.TreeComponentLayout.prototype.applyLayout = function(graph) {};

/**
 * Delegates the layout calculation to the {\@link yfiles.tree.TreeComponentLayout#coreLayout core layout algorithm} and handles the dummy nodes.
 * <p>
 * The dummy nodes are marked using the given {\@link yfiles.algorithms.IDataProvider}.
 * </p>
 * <p>
 * This implementation just registers the dummy node {\@link yfiles.algorithms.IDataProvider} with the graph with key
 * {\@link yfiles.tree.TreeComponentLayout#DUMMY_NODE_DP_KEY}, executes the core layout algorithm and finally removes the data
 * provider again.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.tree.TreeComponentLayout#applyLayout} to invoke the core layout algorithm. It may be
 * overridden to customize the handling of the dummy nodes.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} dummyDp the {\@link } which marks the dummy nodes
 * @return {void}
 */
yfiles.tree.TreeComponentLayout.prototype.applyLayoutUsingDummies = function(graph, dummyDp) {};
/**
 * @record
 * @struct
 */
yfiles.tree.SubtreeShape = function() {};
 /** @type {!yfiles.algorithms.Rectangle2D} */
yfiles.tree.SubtreeShape.prototype.coreBounds;
 /** @type {!yfiles.algorithms.Rectangle2D} */
yfiles.tree.SubtreeShape.prototype.bounds;
 /** @type {number} */
yfiles.tree.SubtreeShape.prototype.connectorX;
 /** @type {number} */
yfiles.tree.SubtreeShape.prototype.connectorY;
 /** @type {yfiles.tree.ConnectorDirection} */
yfiles.tree.SubtreeShape.prototype.connectorDirection;
 /** @type {number} */
yfiles.tree.SubtreeShape.prototype.minX;
 /** @type {number} */
yfiles.tree.SubtreeShape.prototype.minY;
 /** @type {number} */
yfiles.tree.SubtreeShape.prototype.maxX;
 /** @type {number} */
yfiles.tree.SubtreeShape.prototype.maxY;
 /** @type {number} */
yfiles.tree.SubtreeShape.prototype.originX;
 /** @type {number} */
yfiles.tree.SubtreeShape.prototype.originY;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.SubtreeShape.$class;

/**
 * Extends this {\@link yfiles.tree.SubtreeShape} instance by the given rectangle.
 * <p>
 * The border lines are updated with this segment.
 * </p>
 * @see yfiles.tree.SubtreeShape#getBorderLine
 * @param {number} x the x-coordinate of the upper-left corner of the rectangle
 * @param {number} y the y-coordinate of the upper-left corner of the rectangle
 * @param {number} width the width of the rectangle
 * @param {number} height the height of the rectangle
 * @return {void}
 */
yfiles.tree.SubtreeShape.prototype.addBoundsToShape = function(x, y, width, height) {};

/**
 * Adds all edge segments of the given edge to this {\@link yfiles.tree.SubtreeShape} instance.
 * <p>
 * The border lines are updated.
 * </p>
 * @see yfiles.tree.SubtreeShape#getBorderLine
 * @see yfiles.tree.SubtreeShape#addLineSegment
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Edge} edge the given edge
 * @return {void}
 */
yfiles.tree.SubtreeShape.prototype.addEdgeSegments = function(graph, edge) {};

/**
 * Extends this {\@link yfiles.tree.SubtreeShape} instance by the given segment.
 * <p>
 * The border lines are updated with this segment.
 * </p>
 * @see yfiles.tree.SubtreeShape#getBorderLine
 * @see yfiles.tree.SubtreeShape#addEdgeSegments
 * @see yfiles.tree.SubtreeShape#updateConnectorShape
 * @param {number} x1 the x-coordinate of the first point of the segment
 * @param {number} y1 the y-coordinate of the first point of the segment
 * @param {number} x2 the x-coordinate of the second point of the segment
 * @param {number} y2 the y-coordinate of the second point of the segment
 * @return {void}
 */
yfiles.tree.SubtreeShape.prototype.addLineSegment = function(x1, y1, x2, y2) {};

/**
 * Adds another point to the connector.
 * <p>
 * The points will appear as bend of the incoming edge. Points are added in reverse direction of the edge. Hence, the last
 * target point is further away from the target node than the points before.
 * </p>
 * @param {number} x the current x-coordinate of the point
 * @param {number} y the current y-coordinate of the point
 * @return {void}
 */
yfiles.tree.SubtreeShape.prototype.addTargetPoint = function(x, y) {};

/**
 * Appends all target points that have previously been added to this shape to the given {\@link yfiles.layout.IEdgeLayout}
 * instance.
 * <p>
 * This method is used by {\@link yfiles.tree.INodePlacer} instances for the final edge paths.
 * </p>
 * @see yfiles.tree.SubtreeShape#addTargetPoint
 * @param {?} edgeLayout the {\@link } that will be modified
 * @return {void}
 */
yfiles.tree.SubtreeShape.prototype.appendTargetPoints = function(edgeLayout) {};

/**
 * Copies the state of this {\@link yfiles.tree.SubtreeShape} instance to the given shape applying a modification matrix.
 * @param {!yfiles.tree.SubtreeShape} toShape the given shape that gets the assigned values
 * @param {!yfiles.tree.RotatableNodePlacerMatrix} modificationMatrix the matrix that may add geometrical modifications
 * @return {void}
 */
yfiles.tree.SubtreeShape.prototype.assignValuesTo = function(toShape, modificationMatrix) {};

/**
 * Creates a clone of this {\@link yfiles.tree.SubtreeShape} instance, modifying it using the provided modification matrix.
 * @see yfiles.tree.RotatableNodePlacerMatrix#DEFAULT
 * @param {!yfiles.tree.RotatableNodePlacerMatrix} matrix the matrix that defines the modification for the new instance
 * @return {!yfiles.tree.SubtreeShape} the clone of this {\@link } instance
 */
yfiles.tree.SubtreeShape.prototype.createCopy = function(matrix) {};

/**
 * Returns the {\@link yfiles.algorithms.BorderLine} instance that describes the {\@link yfiles.tree.SubtreeShape} at the given side.
 * @throws {Stubs.Exceptions.ArgumentError} if the given index is invalid
 * @param {number} index one of the predefined borderline directions
 * @return {!yfiles.algorithms.BorderLine} the {\@link } instance for the given side
 */
yfiles.tree.SubtreeShape.prototype.getBorderLine = function(index) {};

/**
 * Merges the given {\@link yfiles.tree.SubtreeShape} instance with this {\@link yfiles.tree.SubtreeShape} instance.
 * <p>
 * The border lines are updated.
 * </p>
 * @param {!yfiles.tree.SubtreeShape} other the {\@link } to be merged with this {\@link }
 * @return {void}
 */
yfiles.tree.SubtreeShape.prototype.mergeWith = function(other) {};

/**
 * Moves this {\@link yfiles.tree.SubtreeShape} instance and its connector by the given offsets.
 * <p>
 * Border lines are updated.
 * </p>
 * @param {number} dx the delta x-offset by which this shape will be moved
 * @param {number} dy the delta y-offset by which this shape will be moved
 * @return {void}
 */
yfiles.tree.SubtreeShape.prototype.move = function(dx, dy) {};

/**
 * Adds the line segments of the connector to the bounds of this {\@link yfiles.tree.SubtreeShape} instance.
 * <p>
 * The line segments result from the target points.
 * </p>
 * @see yfiles.tree.SubtreeShape#addTargetPoint
 * @return {void}
 */
yfiles.tree.SubtreeShape.prototype.updateConnectorShape = function() {};
/**
 * @record
 * @struct
 */
yfiles.tree.TreeLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.tree.TreeLayout.NODE_PLACER_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.tree.TreeLayout.PORT_ASSIGNMENT_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<?<!Object>>} */
yfiles.tree.TreeLayout.OUT_EDGE_COMPARER_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<number>} */
yfiles.tree.TreeLayout.CRITICAL_EDGE_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.tree.MultiParentDescriptor>} */
yfiles.tree.TreeLayout.MULTI_PARENT_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<boolean>} */
yfiles.tree.TreeLayout.SELECTED_ROOT_DP_KEY;
 /** @type {!yfiles.layout.LayoutGraph} */
yfiles.tree.TreeLayout.prototype.graph;
 /** @type {boolean} */
yfiles.tree.TreeLayout.prototype.groupingSupported;
 /** @type {boolean} */
yfiles.tree.TreeLayout.prototype.componentLayoutEnabled;
 /** @type {boolean} */
yfiles.tree.TreeLayout.prototype.parallelEdgeRouterEnabled;
 /** @type {boolean} */
yfiles.tree.TreeLayout.prototype.selfLoopRouterEnabled;
 /** @type {?} */
yfiles.tree.TreeLayout.prototype.sourcePortConstraintDataAcceptor;
 /** @type {?} */
yfiles.tree.TreeLayout.prototype.targetPortConstraintDataAcceptor;
 /** @type {?} */
yfiles.tree.TreeLayout.prototype.sourceGroupDataAcceptor;
 /** @type {?} */
yfiles.tree.TreeLayout.prototype.targetGroupDataAcceptor;
 /** @type {?} */
yfiles.tree.TreeLayout.prototype.defaultNodePlacer;
 /** @type {?} */
yfiles.tree.TreeLayout.prototype.defaultLeafPlacer;
 /** @type {?} */
yfiles.tree.TreeLayout.prototype.defaultPortAssignment;
 /** @type {?<!Object>} */
yfiles.tree.TreeLayout.prototype.defaultOutEdgeComparer;
 /** @type {boolean} */
yfiles.tree.TreeLayout.prototype.considerNodeLabels;
 /** @type {boolean} */
yfiles.tree.TreeLayout.prototype.integratedEdgeLabeling;
 /** @type {boolean} */
yfiles.tree.TreeLayout.prototype.multiParentAllowed;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.TreeLayout.$class;

/**
 * Creates a {\@link yfiles.tree.SubtreeShape} for the given node that consists only of the bounds of this particular node.
 * <p>
 * It may also include node labels or {\@link yfiles.layout.NodeHalo}s.
 * </p>
 * <p>
 * This method may be overridden to return a custom {\@link yfiles.tree.SubtreeShape} for the given node.
 * </p>
 * @param {!yfiles.algorithms.Node} node the given node
 * @return {!yfiles.tree.SubtreeShape} a {\@link } instance
 */
yfiles.tree.TreeLayout.prototype.createNodeShape = function(node) {};

/**
 * Returns a list of edges that need to be reversed in order to obtain a valid rooted and directed tree from the input
 * graph.
 * <p>
 * The root node of the tree is either a node marked by a {\@link yfiles.algorithms.IDataProvider} registered with the graph with
 * key {\@link yfiles.tree.TreeLayout#SELECTED_ROOT_DP_KEY} or is defined according to {\@link yfiles.algorithms.Trees#getRoot}.
 * </p>
 * <p>
 * This method is called initially to calculate a rooted tree from the input graph. It may be overridden to apply a custom
 * algorithm that determines which edges need to be reversed.
 * </p>
 * @see yfiles.tree.TreeLayout#reverseEdges
 * @protected
 * @return {!yfiles.algorithms.EdgeList} a list of edges that need to be reversed
 */
yfiles.tree.TreeLayout.prototype.directTree = function() {};

/**
 * Returns the {\@link yfiles.tree.INodePlacer} instance that is used for the placement of the local root node and the
 * {\@link yfiles.tree.SubtreeShape}s.
 * <p>
 * The method may be overridden to return custom {\@link yfiles.tree.INodePlacer} instances. It is possible to return a shared
 * instance for multiple different nodes because the instances are not used after subsequent calls to this method.
 * </p>
 * <p>
 * The current implementation returns the {\@link yfiles.tree.INodePlacer} defined by the {\@link yfiles.algorithms.IDataProvider} registered
 * with key {\@link yfiles.tree.TreeLayout#NODE_PLACER_DP_KEY}. It falls back to the default {\@link yfiles.tree.INodePlacer} if there is no
 * specific {\@link yfiles.tree.INodePlacer} for the given node.
 * </p>
 * @see yfiles.tree.TreeLayout#NODE_PLACER_DP_KEY
 * @see yfiles.tree.TreeLayout#defaultNodePlacer
 * @protected
 * @param {!yfiles.algorithms.Node} localRoot the root of the local subtree
 * @return {?} the {\@link } instance that places the subtree below the given local root node
 */
yfiles.tree.TreeLayout.prototype.getNodePlacer = function(localRoot) {};

/**
 * Returns the {\@link yfiles.collections.IComparer.<T>} instance that will sort the outgoing edges connecting to the given node.
 * <p>
 * The {\@link yfiles.collections.IComparer.<T>} can be <code>null</code> in case the initial edge order shall be used.
 * </p>
 * <p>
 * The method may be overridden to return custom {\@link yfiles.collections.IComparer.<T>} instances. It is possible to return a shared instance for multiple
 * different nodes because the instances are not used after subsequent calls to this method.
 * </p>
 * <p>
 * The current implementation returns the {\@link yfiles.collections.IComparer.<T>} defined in the {\@link yfiles.algorithms.IDataProvider} registered with key
 * {\@link yfiles.tree.TreeLayout#OUT_EDGE_COMPARER_DP_KEY}. It falls back to the default {\@link yfiles.collections.IComparer.<T>} if there is no specific {\@link yfiles.collections.IComparer.<T>} for the given
 * node.
 * </p>
 * @see yfiles.tree.TreeLayout#OUT_EDGE_COMPARER_DP_KEY
 * @see yfiles.tree.TreeLayout#defaultOutEdgeComparer
 * @param {!yfiles.algorithms.Node} localRoot the root of the local subtree
 * @return {?<!Object>} the {\@link } or <code>null</code> that sorts the outgoing edges of the given node
 */
yfiles.tree.TreeLayout.prototype.getOutEdgeComparer = function(localRoot) {};

/**
 * Returns the {\@link yfiles.tree.IPortAssignment} instance that places the ports of the connecting edges of the given node.
 * <p>
 * The method may be overridden to return customized {\@link yfiles.tree.IPortAssignment} instances. It is possible to return a
 * shared instance for multiple different nodes because the instances are not used after subsequent calls to this method.
 * </p>
 * <p>
 * The current implementation returns the {\@link yfiles.tree.IPortAssignment} defined by the {\@link yfiles.algorithms.IDataProvider}
 * registered with key {\@link yfiles.tree.TreeLayout#OUT_EDGE_COMPARER_DP_KEY}. It falls back to the default {\@link yfiles.tree.IPortAssignment}
 * if there is no specific {\@link yfiles.tree.IPortAssignment} for the given node.
 * </p>
 * @see yfiles.tree.TreeLayout#PORT_ASSIGNMENT_DP_KEY
 * @see yfiles.tree.TreeLayout#defaultPortAssignment
 * @protected
 * @param {!yfiles.algorithms.Node} localRoot the root of the local subtree
 * @return {?} the {\@link } instance that assigns the ports of the edges at the given node
 */
yfiles.tree.TreeLayout.prototype.getPortAssignment = function(localRoot) {};

/**
 * Returns an array of the nodes that will be laid out.
 * <p>
 * The given node will be considered as the root of the tree. The order of the elements ensures that no parent is processed
 * before one of its successors.
 * </p>
 * <p>
 * This method may be overridden to change the order in which the nodes (and their subtrees) are handled. However, it is
 * important to keep the parents after the successors. Only siblings can change places.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} root the node to be considered as root of the tree
 * @return {!Array<!yfiles.algorithms.Node>} an array of nodes that will be laid out
 */
yfiles.tree.TreeLayout.prototype.getRootsArray = function(root) {};

/**
 * Provides access to the {\@link yfiles.tree.SubtreeShape} for the given node.
 * <p>
 * The {\@link yfiles.tree.SubtreeShape} contains information about the current extent and location of the subtree rooted at the
 * node. It should only be modified during the layout of the parent node. Also, it won't be initialized before the layout
 * of the corresponding subtree is calculated.
 * </p>
 * <p>
 * This method updates the {\@link yfiles.tree.SubtreeShape} in {\@link yfiles.tree.TreeLayout#layoutRoot}.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} localRoot the root of the subtree
 * @return {!yfiles.tree.SubtreeShape} the {\@link } instance if it has already been calculated, <code>null</code> otherwise
 */
yfiles.tree.TreeLayout.prototype.getSubtreeShape = function(localRoot) {};

/**
 * Calculates the layout for the given root node and its subtrees.
 * <p>
 * This method is invoked for each node in the tree exactly once. Thus, children are always handled before their parents.
 * In this manner, the subtrees already have a layout and can be arranged with their parent.
 * </p>
 * <p>
 * To retrieve the shapes of the subtrees of all children of the local root, this method uses
 * {\@link yfiles.tree.TreeLayout#getSubtreeShape}.
 * </p>
 * <p>
 * The method may be overridden to add configuration code.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.Node} localRoot the root of the subtree that whose layout is calculated
 * @return {!yfiles.tree.SubtreeShape} the combined {\@link } of the local root node and all of its children and connecting edges
 */
yfiles.tree.TreeLayout.prototype.layoutRoot = function(localRoot) {};

/**
 * Reverses the direction of given edges.
 * <p>
 * This method will be called initially after the {\@link yfiles.tree.TreeLayout#directTree} method and finally after the layout has
 * been calculated. It may be overridden to additionally reverse data that depends on the direction of the edges.
 * </p>
 * @protected
 * @param {!yfiles.algorithms.EdgeList} reversedEdges the edges that will be reversed
 * @return {void}
 */
yfiles.tree.TreeLayout.prototype.reverseEdges = function(reversedEdges) {};
/**
 * @record
 * @struct
 */
yfiles.tree.TreeReductionStage = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.tree.TreeReductionStage.NON_TREE_EDGES_DP_KEY;
 /** @type {boolean} */
yfiles.tree.TreeReductionStage.prototype.multiParentAllowed;
 /** @type {?} */
yfiles.tree.TreeReductionStage.prototype.nonTreeEdgeRouter;
 /** @type {!Object} */
yfiles.tree.TreeReductionStage.prototype.nonTreeEdgeSelectionKey;
 /** @type {?} */
yfiles.tree.TreeReductionStage.prototype.nonTreeEdgeLabelingAlgorithm;
 /** @type {!Object} */
yfiles.tree.TreeReductionStage.prototype.nonTreeEdgeLabelSelectionKey;
 /** @type {!yfiles.layout.EdgeBundling} */
yfiles.tree.TreeReductionStage.prototype.edgeBundling;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.TreeReductionStage.$class;

/**
 * Creates a routing algorithm that routes edges as a single straight segment.
 * <p>
 * The created instance can be used for {\@link yfiles.tree.TreeReductionStage#nonTreeEdgeRouter routing non-tree edges}.
 * </p>
 * @see yfiles.tree.TreeReductionStage#nonTreeEdgeRouter
 * @return {?} an edge routing algorithm that produces straight-line edges
 */
yfiles.tree.TreeReductionStage.prototype.createStraightLineRouter = function() {};

/**
 * Routes all edges that do not belong to the chosen spanning tree.
 * <p>
 * This method is called by {\@link yfiles.tree.TreeReductionStage#applyLayout} after the tree was arranged by the
 * {\@link yfiles.layout.LayoutStageBase#coreLayout core layout algorithm}. It may be overridden to apply custom edge routes.
 * </p>
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the graph containing tree and non-tree edges
 * @param {?} nonTreeEdgeMap the {\@link } that marks all non-tree edges in the graph
 * @return {void}
 */
yfiles.tree.TreeReductionStage.prototype.routeNonTreeEdges = function(graph, nonTreeEdgeMap) {};
/**
 * @record
 * @struct
 */
yfiles.tree.AspectRatioTreeLayoutData = function() {};
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.tree.AspectRatioTreeLayoutData.prototype.subtreeAspectRatios;
 /** @type {!yfiles.layout.ItemMapping<?, yfiles.tree.RootPlacement>} */
yfiles.tree.AspectRatioTreeLayoutData.prototype.rootPlacements;
 /** @type {!yfiles.layout.ItemMapping<?, yfiles.tree.SubtreeArrangement>} */
yfiles.tree.AspectRatioTreeLayoutData.prototype.subtreeRoutingPolicies;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.AspectRatioTreeLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.BalloonLayoutData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.tree.BalloonLayoutData.prototype.interleavedNodes;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.tree.BalloonLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.tree.BalloonLayoutData.prototype.abortHandler;
 /** @type {!yfiles.layout.ItemMapping<?, boolean>} */
yfiles.tree.BalloonLayoutData.prototype.treeRoot;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PreferredPlacementDescriptor>} */
yfiles.tree.BalloonLayoutData.prototype.edgeLabelPreferredPlacement;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.BalloonLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.TreeLayoutData = function() {};
 /** @type {!yfiles.layout.ItemMapping<?, ?>} */
yfiles.tree.TreeLayoutData.prototype.nodePlacers;
 /** @type {!yfiles.layout.ItemMapping<?, ?>} */
yfiles.tree.TreeLayoutData.prototype.portAssignments;
 /** @type {!yfiles.layout.ItemMapping<?, !Function>} */
yfiles.tree.TreeLayoutData.prototype.outEdgeComparers;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.tree.TreeLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.tree.TreeLayoutData.prototype.sourcePortConstraints;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PortConstraint>} */
yfiles.tree.TreeLayoutData.prototype.targetPortConstraints;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.tree.TreeLayoutData.prototype.assistantNodes;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.tree.TreeLayoutData.prototype.delegatingNodePlacersPrimaryNodes;
 /** @type {!yfiles.layout.ItemMapping<?, boolean>} */
yfiles.tree.TreeLayoutData.prototype.leftRightPlacersLeftNodes;
 /** @type {!yfiles.layout.ItemMapping<?, number>} */
yfiles.tree.TreeLayoutData.prototype.gridNodePlacerRowIndices;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.tree.TreeLayoutData.prototype.abortHandler;
 /** @type {!yfiles.layout.ItemMapping<?, boolean>} */
yfiles.tree.TreeLayoutData.prototype.treeRoot;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PreferredPlacementDescriptor>} */
yfiles.tree.TreeLayoutData.prototype.edgeLabelPreferredPlacement;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.TreeLayoutData.$class;
/**
 * @record
 * @struct
 */
yfiles.tree.TreeReductionStageData = function() {};
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.tree.TreeReductionStageData.prototype.nonTreeEdges;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.EdgeBundleDescriptor>} */
yfiles.tree.TreeReductionStageData.prototype.edgeBundleDescriptors;
 /** @type {!yfiles.lang.Class} */
yfiles.tree.TreeReductionStageData.$class;
/** @const */
yfiles.genealogy = {};
/**
 * @record
 * @struct
 */
yfiles.genealogy.FamilyTreeLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<yfiles.genealogy.FamilyType>} */
yfiles.genealogy.FamilyTreeLayout.FAMILY_TYPE_DP_KEY;
 /** @type {?} */
yfiles.genealogy.FamilyTreeLayout.prototype.topLayout;
 /** @type {number} */
yfiles.genealogy.FamilyTreeLayout.prototype.spacingBetweenFamilyMembers;
 /** @type {number} */
yfiles.genealogy.FamilyTreeLayout.prototype.offsetForFamilyNodes;
 /** @type {boolean} */
yfiles.genealogy.FamilyTreeLayout.prototype.partnerlessBelow;
 /** @type {boolean} */
yfiles.genealogy.FamilyTreeLayout.prototype.familyNodesAlwaysBelow;
 /** @type {yfiles.genealogy.VerticalNodeAlignment} */
yfiles.genealogy.FamilyTreeLayout.prototype.alignment;
 /** @type {boolean} */
yfiles.genealogy.FamilyTreeLayout.prototype.parallelEdgeRouterEnabled;
 /** @type {boolean} */
yfiles.genealogy.FamilyTreeLayout.prototype.selfLoopRouterEnabled;
 /** @type {yfiles.genealogy.FamilyMembersSortingPolicy} */
yfiles.genealogy.FamilyTreeLayout.prototype.familyMembersSortingPolicy;
 /** @type {!yfiles.lang.Class} */
yfiles.genealogy.FamilyTreeLayout.$class;

/** @const */
yfiles.genealogy.FamilyType = {};
/** @const {number} */
yfiles.genealogy.FamilyType.FAMILY;
/** @const {number} */
yfiles.genealogy.FamilyType.MALE;
/** @const {number} */
yfiles.genealogy.FamilyType.FEMALE;

/** @const */
yfiles.genealogy.VerticalNodeAlignment = {};
/** @const {number} */
yfiles.genealogy.VerticalNodeAlignment.TOP;
/** @const {number} */
yfiles.genealogy.VerticalNodeAlignment.CENTER;
/** @const {number} */
yfiles.genealogy.VerticalNodeAlignment.BOTTOM;

/** @const */
yfiles.genealogy.FamilyMembersSortingPolicy = {};
/** @const {number} */
yfiles.genealogy.FamilyMembersSortingPolicy.NO_SORTING;
/** @const {number} */
yfiles.genealogy.FamilyMembersSortingPolicy.FEMALE_FIRST;
/** @const {number} */
yfiles.genealogy.FamilyMembersSortingPolicy.FEMALE_ALWAYS_FIRST;
/** @const {number} */
yfiles.genealogy.FamilyMembersSortingPolicy.MALE_FIRST;
/** @const {number} */
yfiles.genealogy.FamilyMembersSortingPolicy.MALE_ALWAYS_FIRST;
/**
 * @record
 * @struct
 */
yfiles.genealogy.FamilyTreeLayoutData = function() {};
 /** @type {!yfiles.layout.ItemMapping<?, yfiles.genealogy.FamilyType>} */
yfiles.genealogy.FamilyTreeLayoutData.prototype.familyTypes;
 /** @type {!yfiles.lang.Class} */
yfiles.genealogy.FamilyTreeLayoutData.$class;
/** @const */
yfiles.multipage = {};
/**
 * @record
 * @struct
 */
yfiles.multipage.DefaultElementFactory = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.multipage.DefaultElementFactory.$class;

/**
 *
 * @param {!yfiles.multipage.LayoutContext} context
 * @param {!yfiles.algorithms.Node} connector
 * @param {!yfiles.algorithms.Node} opposite
 * @param {!Object} origEdgeId
 * @param {boolean} atTarget
 * @return {!yfiles.algorithms.Edge}
 */
yfiles.multipage.DefaultElementFactory.prototype.createConnectorEdge = function(context, connector, opposite, origEdgeId, atTarget) {};

/**
 *
 * @param {!yfiles.multipage.LayoutContext} context
 * @param {!yfiles.algorithms.YList} edgeIds
 * @param {!Object} representedNodeId
 * @return {!yfiles.algorithms.Node}
 */
yfiles.multipage.DefaultElementFactory.prototype.createConnectorNode = function(context, edgeIds, representedNodeId) {};

/**
 *
 * @param {!yfiles.multipage.LayoutContext} context
 * @param {!yfiles.algorithms.Node} proxyNode
 * @param {!yfiles.algorithms.Node} opposite
 * @param {!Object} replacingEdgeId
 * @param {!Object} origNodeId
 * @return {!yfiles.algorithms.Edge}
 */
yfiles.multipage.DefaultElementFactory.prototype.createProxyEdge = function(context, proxyNode, opposite, replacingEdgeId, origNodeId) {};

/**
 *
 * @param {!yfiles.multipage.LayoutContext} context
 * @param {!Object} origNodeId
 * @return {!yfiles.algorithms.Node}
 */
yfiles.multipage.DefaultElementFactory.prototype.createProxyNode = function(context, origNodeId) {};

/**
 *
 * @param {!yfiles.multipage.LayoutContext} context
 * @param {!yfiles.algorithms.Node} proxyReference
 * @param {!yfiles.algorithms.Node} opposite
 * @param {!Object} referencingCopyId
 * @return {!yfiles.algorithms.Edge}
 */
yfiles.multipage.DefaultElementFactory.prototype.createProxyReferenceEdge = function(context, proxyReference, opposite, referencingCopyId) {};

/**
 *
 * @param {!yfiles.multipage.LayoutContext} context
 * @param {!Object} referringProxyId
 * @return {!yfiles.algorithms.Node}
 */
yfiles.multipage.DefaultElementFactory.prototype.createProxyReferenceNode = function(context, referringProxyId) {};

/**
 * Returns the default size for nodes created by this factory.
 * <p>
 * This method is called from {\@link yfiles.multipage.DefaultElementFactory#createConnectorNode},
 * {\@link yfiles.multipage.DefaultElementFactory#createProxyReferenceNode}, and/or
 * {\@link yfiles.multipage.DefaultElementFactory#createProxyNode}. It must return a non-<code>null</code> size with positive width and height.
 * </p>
 * <p>
 * Subclasses may implement this method to use custom size values.
 * </p>
 * @protected
 * @param {!yfiles.multipage.LayoutContext} context an object providing relevant layout information, for example, the current graph as well as various information about the
 * graph elements
 * @param {!Object} id the element ID
 * @param {number} type the type of the node to be created
 * @return {!yfiles.algorithms.YDimension} the default size of the new node
 */
yfiles.multipage.DefaultElementFactory.prototype.getDefaultNodeSize = function(context, id, type) {};

/** @const */
yfiles.multipage.EdgeType = {};
/** @const {number} */
yfiles.multipage.EdgeType.NORMAL;
/** @const {number} */
yfiles.multipage.EdgeType.CONNECTOR;
/** @const {number} */
yfiles.multipage.EdgeType.PROXY_REFERENCE;
/** @const {number} */
yfiles.multipage.EdgeType.PROXY;

/** @const */
yfiles.multipage.GroupingMode = {};
/** @const {number} */
yfiles.multipage.GroupingMode.IGNORE;
/** @const {number} */
yfiles.multipage.GroupingMode.ORIGINAL_NODES_ONLY;
/** @const {number} */
yfiles.multipage.GroupingMode.ALL_NODES;

/** @const */
yfiles.multipage.EdgeBundleModes = {};
/** @const {number} */
yfiles.multipage.EdgeBundleModes.DISTINGUISH_MULTI_EDGES;
/** @const {number} */
yfiles.multipage.EdgeBundleModes.DISTINGUISH_DIRECTIONS;
/** @const {number} */
yfiles.multipage.EdgeBundleModes.DISTINGUISH_TYPES;

/** @const */
yfiles.multipage.NodeType = {};
/** @const {number} */
yfiles.multipage.NodeType.NORMAL;
/** @const {number} */
yfiles.multipage.NodeType.GROUP;
/** @const {number} */
yfiles.multipage.NodeType.PROXY;
/** @const {number} */
yfiles.multipage.NodeType.PROXY_REFERENCE;
/** @const {number} */
yfiles.multipage.NodeType.CONNECTOR;
/**
 * @record
 * @struct
 */
yfiles.multipage.IEdgeInfo = function() {};
 /** @type {!Object} */
yfiles.multipage.IEdgeInfo.prototype.id;
 /** @type {yfiles.multipage.EdgeType} */
yfiles.multipage.IEdgeInfo.prototype.type;
 /** @type {!yfiles.algorithms.Edge} */
yfiles.multipage.IEdgeInfo.prototype.representedEdge;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.multipage.IEdgeInfo;
/**
 * @record
 * @struct
 */
yfiles.multipage.IEdgeLabelInfo = function() {};
 /** @type {!Object} */
yfiles.multipage.IEdgeLabelInfo.prototype.id;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.multipage.IEdgeLabelInfo;
/**
 * @record
 * @struct
 */
yfiles.multipage.IElementFactory = function() {};

/**
 * Callback method for creating an edge of type {\@link yfiles.multipage.EdgeType#CONNECTOR}.
 * <p>
 * Such an edge connects the given {\@link yfiles.multipage.NodeType#CONNECTOR connector} and opposite node.
 * </p>
 * @see yfiles.multipage.EdgeType#CONNECTOR
 * @see yfiles.multipage.NodeType#CONNECTOR
 * @see yfiles.multipage.LayoutContext#createEdge
 * @abstract
 * @param {!yfiles.multipage.LayoutContext} context an object providing relevant layout information, for example, the current graph as well as various information about the
 * graph elements
 * @param {!yfiles.algorithms.Node} connector the endpoint of the edge that represents the connector node
 * @param {!yfiles.algorithms.Node} opposite the other endpoint of the edge
 * @param {!Object} origEdgeId the ID of the edge that is split by the connector edge
 * @param {boolean} atTarget <code>true</code> if the connector node is the target of the edge, <code>false</code> otherwise
 * @return {!yfiles.algorithms.Edge} the created connector edge
 */
yfiles.multipage.IElementFactory.prototype.createConnectorEdge = function(context, connector, opposite, origEdgeId, atTarget) {};

/**
 * Callback method for creating a node of type {\@link yfiles.multipage.NodeType#CONNECTOR}.
 * @see yfiles.multipage.NodeType#CONNECTOR
 * @see yfiles.multipage.LayoutContext#createNode
 * @see yfiles.multipage.INodeInfo#representedNode
 * @abstract
 * @param {!yfiles.multipage.LayoutContext} context an object providing relevant layout information, for example, the current graph as well as various information about the
 * graph elements
 * @param {!yfiles.algorithms.YList} edgesIds a {\@link  list} that contains the IDs of edges that are split by this connector
 * @param {!Object} representedNodeId the ID of the node that is represented by this connector
 * @return {!yfiles.algorithms.Node} the created connector node
 */
yfiles.multipage.IElementFactory.prototype.createConnectorNode = function(context, edgesIds, representedNodeId) {};

/**
 * Callback method for creating an edge of type {\@link yfiles.multipage.EdgeType#PROXY}.
 * <p>
 * Such an edge should connect the given {\@link yfiles.multipage.NodeType#PROXY proxy} and opposite node.
 * </p>
 * @see yfiles.multipage.EdgeType#PROXY
 * @see yfiles.multipage.NodeType#PROXY
 * @see yfiles.multipage.LayoutContext#createEdge
 * @abstract
 * @param {!yfiles.multipage.LayoutContext} context an object providing relevant layout information, for example, the current graph as well as various information about the
 * graph elements
 * @param {!yfiles.algorithms.Node} proxyNode the endpoint of the edge that represents the proxy node
 * @param {!yfiles.algorithms.Node} opposite the other endpoint of the new edge
 * @param {!Object} replacingEdgeId the ID of the related edge that is connected to the original node
 * @param {!Object} origNodeId the ID of the original node to which the proxy node refers
 * @return {!yfiles.algorithms.Edge} the created proxy edge
 */
yfiles.multipage.IElementFactory.prototype.createProxyEdge = function(context, proxyNode, opposite, replacingEdgeId, origNodeId) {};

/**
 * Callback method for creating a node of type {\@link yfiles.multipage.NodeType#PROXY}.
 * @see yfiles.multipage.LayoutContext#createNode
 * @see yfiles.multipage.NodeType#PROXY_REFERENCE
 * @see yfiles.multipage.NodeType#PROXY
 * @abstract
 * @param {!yfiles.multipage.LayoutContext} context an object providing relevant layout information, for example, the current graph as well as various information about the
 * graph elements
 * @param {!Object} origNodeId the ID of the node for which a proxy has to be created
 * @return {!yfiles.algorithms.Node} the created proxy node
 */
yfiles.multipage.IElementFactory.prototype.createProxyNode = function(context, origNodeId) {};

/**
 * Callback method for creating an edge of type {\@link yfiles.multipage.EdgeType#PROXY_REFERENCE}.
 * <p>
 * Such an (undirected) edge should connect the given {\@link yfiles.multipage.NodeType#PROXY_REFERENCE proxy reference} and opposite node.
 * </p>
 * @see yfiles.multipage.EdgeType#PROXY_REFERENCE
 * @see yfiles.multipage.NodeType#PROXY_REFERENCE
 * @see yfiles.multipage.LayoutContext#createEdge
 * @abstract
 * @param {!yfiles.multipage.LayoutContext} context an object providing relevant layout information, for example, the current graph as well as various information about the
 * graph elements
 * @param {!yfiles.algorithms.Node} proxyReference the endpoint of the edge that represents the proxy reference node
 * @param {!yfiles.algorithms.Node} opposite the other endpoint of the new edge
 * @param {!Object} referencingCopyId the ID of the proxy node that is referenced by the proxy reference node
 * @return {!yfiles.algorithms.Edge} the created proxy reference edge
 */
yfiles.multipage.IElementFactory.prototype.createProxyReferenceEdge = function(context, proxyReference, opposite, referencingCopyId) {};

/**
 * Callback method for creating a node of type {\@link yfiles.multipage.NodeType#PROXY_REFERENCE}.
 * @see yfiles.multipage.NodeType#PROXY_REFERENCE
 * @see yfiles.multipage.LayoutContext#createNode
 * @see yfiles.multipage.NodeType#PROXY
 * @abstract
 * @param {!yfiles.multipage.LayoutContext} context an object providing relevant layout information, for example, the current graph as well as various information about the
 * graph elements
 * @param {!Object} referringProxyId the ID of the proxy to which the created node refers
 * @return {!yfiles.algorithms.Node} the new proxy reference node
 */
yfiles.multipage.IElementFactory.prototype.createProxyReferenceNode = function(context, referringProxyId) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.multipage.IElementFactory;
/**
 * @record
 * @struct
 */
yfiles.multipage.IElementInfoManager = function() {};

/**
 * Returns the edge information object of the given edge.
 * @abstract
 * @param {!yfiles.algorithms.Edge} edge the edge for which the information object should be returned
 * @return {?} the edge information object of the given edge
 */
yfiles.multipage.IElementInfoManager.prototype.getEdgeInfo = function(edge) {};

/**
 * Returns the edge label information object of the given edge label layout.
 * @abstract
 * @param {?} edgeLabelLayout the edge label layout for which the information object should be returned
 * @return {?} the edge label information object of the given edge label layout
 */
yfiles.multipage.IElementInfoManager.prototype.getEdgeLabelInfo = function(edgeLabelLayout) {};

/**
 * Returns the node information object of the given node.
 * @abstract
 * @param {!yfiles.algorithms.Node} node the node for which the information object should be returned
 * @return {?} the node information object of the given node
 */
yfiles.multipage.IElementInfoManager.prototype.getNodeInfo = function(node) {};

/**
 * Returns the node label layout information object of the given node label layout.
 * @abstract
 * @param {?} nodeLabelLayout the node label layout for which the information object should be returned
 * @return {?} the node label information object of the given node label layout
 */
yfiles.multipage.IElementInfoManager.prototype.getNodeLabelInfo = function(nodeLabelLayout) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.multipage.IElementInfoManager;
/**
 * @record
 * @struct
 */
yfiles.multipage.ILayoutCallback = function() {};

/**
 * Invoked from {\@link yfiles.multipage.MultiPageLayout#applyLayout} when a new multi-page layout has been calculated.
 * @see yfiles.multipage.MultiPageLayout#applyLayout
 * @abstract
 * @param {!yfiles.multipage.MultiPageLayoutResult} result the result of the layout calculation
 * @return {void}
 */
yfiles.multipage.ILayoutCallback.prototype.layoutDone = function(result) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.multipage.ILayoutCallback;
/**
 * @record
 * @struct
 */
yfiles.multipage.INodeInfo = function() {};
 /** @type {!yfiles.algorithms.Node} */
yfiles.multipage.INodeInfo.prototype.representedNode;
 /** @type {number} */
yfiles.multipage.INodeInfo.prototype.pageNo;
 /** @type {yfiles.multipage.NodeType} */
yfiles.multipage.INodeInfo.prototype.type;
 /** @type {!Object} */
yfiles.multipage.INodeInfo.prototype.id;
 /** @type {!yfiles.algorithms.Node} */
yfiles.multipage.INodeInfo.prototype.referencingNode;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.multipage.INodeInfo;
/**
 * @record
 * @struct
 */
yfiles.multipage.INodeLabelInfo = function() {};
 /** @type {!Object} */
yfiles.multipage.INodeLabelInfo.prototype.id;
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.multipage.INodeLabelInfo;
/**
 * @record
 * @struct
 */
yfiles.multipage.LayoutContext = function() {};
 /** @type {!yfiles.layout.LayoutGraph} */
yfiles.multipage.LayoutContext.prototype.graph;
 /** @type {!yfiles.multipage.MultiPageLayout} */
yfiles.multipage.LayoutContext.prototype.layout;
 /** @type {!yfiles.lang.Class} */
yfiles.multipage.LayoutContext.$class;

/**
 * Adds a label to a given edge.
 * @param {?} label the label that should be added to the given edge
 * @param {!yfiles.algorithms.Edge} labeledElement the edge to which the label should be added
 * @return {void}
 */
yfiles.multipage.LayoutContext.prototype.addEdgeLabel = function(label, labeledElement) {};

/**
 * Adds a label to a given node.
 * @param {?} label the label that should be added to the given node
 * @param {!yfiles.algorithms.Node} labeledElement the node to which the label should be added
 * @return {void}
 */
yfiles.multipage.LayoutContext.prototype.addNodeLabel = function(label, labeledElement) {};

/**
 * All methods of the {\@link yfiles.multipage.IElementFactory} have to use this method to create an edge.
 * @see yfiles.multipage.IElementFactory
 * @param {!yfiles.algorithms.Node} source the source of the edge
 * @param {!yfiles.algorithms.Node} target the target of the edge
 * @param {!Object} sameDataElementId the ID of the edge whose data should be copied to the created edge (or <code>null</code> if no data should be copied)
 * @return {!yfiles.algorithms.Edge} the created edge
 */
yfiles.multipage.LayoutContext.prototype.createEdge = function(source, target, sameDataElementId) {};

/**
 * All methods of the {\@link yfiles.multipage.IElementFactory} have to use this method to create a node.
 * @see yfiles.multipage.IElementFactory
 * @param {!Object} sameDataElementId the ID of the node whose data should be copied to the created node (or <code>null</code> if no data should be copied)
 * @return {!yfiles.algorithms.Node} the created node
 */
yfiles.multipage.LayoutContext.prototype.createNode = function(sameDataElementId) {};

/**
 *
 * @param {!yfiles.algorithms.Edge} edge
 * @return {?}
 */
yfiles.multipage.LayoutContext.prototype.getEdgeInfo = function(edge) {};

/**
 *
 * @param {?} edgeLabelLayout
 * @return {?}
 */
yfiles.multipage.LayoutContext.prototype.getEdgeLabelInfo = function(edgeLabelLayout) {};

/**
 *
 * @param {!yfiles.algorithms.Node} node
 * @return {?}
 */
yfiles.multipage.LayoutContext.prototype.getNodeInfo = function(node) {};

/**
 *
 * @param {?} nodeLabelLayout
 * @return {?}
 */
yfiles.multipage.LayoutContext.prototype.getNodeLabelInfo = function(nodeLabelLayout) {};

/**
 * Returns the edge of the input graph with the given ID or <code>null</code> if there is no such edge.
 * @param {!Object} id the ID of the edge that should be returned
 * @return {!yfiles.algorithms.Edge} the edge of the input graph with the given ID or <code>null</code> if there is no such edge
 */
yfiles.multipage.LayoutContext.prototype.getOriginalEdge = function(id) {};

/**
 * Returns the node of the input graph with the given ID or <code>null</code> if there is no such node.
 * @param {!Object} id the ID of the node that should be returned
 * @return {!yfiles.algorithms.Node} the node of the input graph with the given ID or <code>null</code> if there is no such node
 */
yfiles.multipage.LayoutContext.prototype.getOriginalNode = function(id) {};

/**
 * Returns the edge of a page graph (a graph that represents the result of the multi-page layout) with the given ID or <code>null</code>
 * if there is no such edge.
 * @param {!Object} id the ID of the edge that should be returned
 * @return {!yfiles.algorithms.Edge} the edge of a page graph with the given ID or <code>null</code> if there is no such edge
 */
yfiles.multipage.LayoutContext.prototype.getPageEdge = function(id) {};

/**
 * Returns the node of a page graph (a graph that represents the result of the multi-page layout) with the given ID or <code>null</code>
 * if there is no such node.
 * @param {!Object} id the ID of the node that should be returned
 * @return {!yfiles.algorithms.Node} the node of a page graph with the given ID or <code>null</code> if there is no such node
 */
yfiles.multipage.LayoutContext.prototype.getPageNode = function(id) {};

/**
 * Removes a label from a given edge.
 * @param {?} label the label that should be removed
 * @param {!yfiles.algorithms.Edge} labeledElement the edge owning the label
 * @return {boolean}
 */
yfiles.multipage.LayoutContext.prototype.removeEdgeLabel = function(label, labeledElement) {};

/**
 * Removes a label from a given node.
 * @param {?} label the label that should be removed
 * @param {!yfiles.algorithms.Node} labeledElement the node owning the label
 * @return {boolean}
 */
yfiles.multipage.LayoutContext.prototype.removeNodeLabel = function(label, labeledElement) {};
/**
 * @record
 * @struct
 */
yfiles.multipage.MultiPageLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<!Object>} */
yfiles.multipage.MultiPageLayout.NODE_CLUSTER_ID_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!Object>} */
yfiles.multipage.MultiPageLayout.NODE_ID_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.multipage.MultiPageLayout.EDGE_ID_DP_KEY;
 /** @type {!yfiles.algorithms.IEdgeLabelLayoutDpKey<!Object>} */
yfiles.multipage.MultiPageLayout.EDGE_LABEL_ID_DP_KEY;
 /** @type {!yfiles.algorithms.INodeLabelLayoutDpKey<!Object>} */
yfiles.multipage.MultiPageLayout.NODE_LABEL_ID_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<!Object>} */
yfiles.multipage.MultiPageLayout.EDGE_TYPE_DP_KEY;
 /** @type {boolean} */
yfiles.multipage.MultiPageLayout.prototype.strictClusterSeparation;
 /** @type {boolean} */
yfiles.multipage.MultiPageLayout.prototype.labelingEnabled;
 /** @type {?} */
yfiles.multipage.MultiPageLayout.prototype.elementFactory;
 /** @type {?} */
yfiles.multipage.MultiPageLayout.prototype.layoutCallback;
 /** @type {yfiles.multipage.EdgeBundleModes} */
yfiles.multipage.MultiPageLayout.prototype.edgeBundleModeMask;
 /** @type {yfiles.multipage.GroupingMode} */
yfiles.multipage.MultiPageLayout.prototype.groupingMode;
 /** @type {number} */
yfiles.multipage.MultiPageLayout.prototype.maximumDuration;
 /** @type {?} */
yfiles.multipage.MultiPageLayout.prototype.labeling;
 /** @type {!yfiles.algorithms.YDimension} */
yfiles.multipage.MultiPageLayout.prototype.maximumPageSize;
 /** @type {!yfiles.lang.Class} */
yfiles.multipage.MultiPageLayout.$class;

/**
 * This method is called to further improve the layout results.
 * <p>
 * The marked nodes have to be placed without changing the coordinates of the fixed (non-marked) elements and without
 * exceeding the specified maximum page size. Furthermore, the basic layout properties should be maintained.
 * </p>
 * <p>
 * Subclasses may implement a custom layout strategy for this step.
 * </p>
 * @see yfiles.multipage.LayoutContext
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {?} incrementalNodesDP a {\@link } that returns a boolean value indicating whether or not a node is marked; the positions
 * of the non-marked nodes are not allowed to change
 * @param {!yfiles.multipage.LayoutContext} context the current layout context
 * @return {void}
 */
yfiles.multipage.MultiPageLayout.prototype.applyIncrementalLayout = function(graph, incrementalNodesDP, context) {};

/**
 * Calculates a new multi-page layout for the specified graph.
 * <p>
 * Unlike method {\@link yfiles.multipage.MultiPageLayout#applyLayout}, this method ignores the registered {\@link yfiles.multipage.MultiPageLayout#layoutCallback layout callback} and
 * directly returns the calculated {\@link yfiles.multipage.MultiPageLayoutResult}.
 * </p>
 * @throws {Stubs.Exceptions.ArgumentError} if for one of the keys {\@link yfiles.multipage.MultiPageLayout#NODE_ID_DP_KEY}, {\@link yfiles.multipage.MultiPageLayout#EDGE_ID_DP_KEY},
 * {\@link yfiles.multipage.MultiPageLayout#NODE_LABEL_ID_DP_KEY} and {\@link yfiles.multipage.MultiPageLayout#EDGE_LABEL_ID_DP_KEY} no {\@link yfiles.algorithms.IDataProvider}
 * is registered with the given graph
 * @see yfiles.multipage.MultiPageLayoutResult
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @return {!yfiles.multipage.MultiPageLayoutResult} an instance of {\@link } that represents the result of the layout run
 */
yfiles.multipage.MultiPageLayout.prototype.calculateLayout = function(graph) {};

/**
 * This method creates the {\@link yfiles.multipage.IElementFactory element factory} for multi-page layouts.
 * <p>
 * It is called once from {\@link yfiles.multipage.MultiPageLayout#elementFactory} if no factory has been explicitly set using {\@link yfiles.multipage.MultiPageLayout#elementFactory}. By default, this method returns an instance of
 * {\@link yfiles.multipage.DefaultElementFactory}.
 * </p>
 * <p>
 * Subclasses may create a custom implementation of the element factory.
 * </p>
 * @see yfiles.multipage.MultiPageLayout#elementFactory
 * @see yfiles.multipage.MultiPageLayout#elementFactory
 * @see yfiles.multipage.IElementFactory
 * @protected
 * @return {?} the created element factory
 */
yfiles.multipage.MultiPageLayout.prototype.createElementFactory = function() {};

/**
 * This method is called during a postprocessing step that reduces the number of connectors.
 * <p>
 * A pair of connectors can be removed if both connector nodes are placed on the same page. The method removes both
 * connector nodes and restores the original edges by calling {\@link yfiles.multipage.MultiPageLayout#routeRestoredEdges}.
 * </p>
 * <p>
 * Subclasses may implement a custom remove/restore strategy.
 * </p>
 * @see yfiles.multipage.MultiPageLayout#routeRestoredEdges
 * @protected
 * @param {!yfiles.algorithms.Node} connector1 the first connector of the connector pair
 * @param {!yfiles.algorithms.Node} connector2 the second connector of the connector pair
 * @param {!yfiles.algorithms.YList} originalEdgeIds the IDs of the original edges that have to be restored
 * @param {!yfiles.multipage.LayoutContext} context the current layout context
 * @return {boolean} <code>true</code> if the removal of the connector pair was successful, <code>false</code> otherwise
 */
yfiles.multipage.MultiPageLayout.prototype.removeConnectorPair = function(connector1, connector2, originalEdgeIds, context) {};

/**
 * This method is called whenever some single edges have to be routed without changing the position of nodes (e.g., by {\@link yfiles.multipage.MultiPageLayout#removeConnectorPair}
 * to route the restored edges).
 * <p>
 * It has to guarantee that the routes are fully contained within the given bounding rectangle.
 * </p>
 * <p>
 * Subclasses may implement a custom routing strategy for the restored edges.
 * </p>
 * @see yfiles.multipage.MultiPageLayout#removeConnectorPair
 * @protected
 * @param {!yfiles.layout.LayoutGraph} graph the relevant graph
 * @param {?} selectedEdgesDP a {\@link } that returns a boolean value indicating whether or not an edge should be rerouted
 * @param {!yfiles.algorithms.YRectangle} boundingRectangle the edge routes should be fully contained within this rectangle
 * @return {void}
 */
yfiles.multipage.MultiPageLayout.prototype.routeRestoredEdges = function(graph, selectedEdgesDP, boundingRectangle) {};
/**
 * @record
 * @struct
 */
yfiles.multipage.MultiPageLayoutResult = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.multipage.MultiPageLayoutResult.$class;

/**
 *
 * @param {!yfiles.algorithms.Edge} edge
 * @return {?}
 */
yfiles.multipage.MultiPageLayoutResult.prototype.getEdgeInfo = function(edge) {};

/**
 *
 * @param {?} edgeLabelLayout
 * @return {?}
 */
yfiles.multipage.MultiPageLayoutResult.prototype.getEdgeLabelInfo = function(edgeLabelLayout) {};

/**
 *
 * @param {!yfiles.algorithms.Node} node
 * @return {?}
 */
yfiles.multipage.MultiPageLayoutResult.prototype.getNodeInfo = function(node) {};

/**
 *
 * @param {?} nodeLabelLayout
 * @return {?}
 */
yfiles.multipage.MultiPageLayoutResult.prototype.getNodeLabelInfo = function(nodeLabelLayout) {};

/**
 * Returns the page graph associated with the given page number.
 * <p>
 * A <i>page graph</i> is a subgraph of the input graph whose layout fits the {\@link yfiles.multipage.MultiPageLayout#maximumPageSize specified maximum page size}.
 * </p>
 * @throws {Stubs.Exceptions.IndexOutOfRangeError} if <code>pageNo >= pageCount</code> or <code>pageNo &lt; 0</code>
 * @see yfiles.multipage.MultiPageLayoutResult#pageCount
 * @param {number} pageNo the given page number
 * @return {!yfiles.layout.LayoutGraph} the page graph associated with the given page number
 */
yfiles.multipage.MultiPageLayoutResult.prototype.getPage = function(pageNo) {};

/**
 * Returns the number of pages available in this {\@link yfiles.multipage.MultiPageLayoutResult}.
 * <p>
 * Each page contains a {\@link yfiles.multipage.MultiPageLayoutResult#getPage page graph} whose layout fits the {\@link yfiles.multipage.MultiPageLayout#maximumPageSize specified maximum page size}.
 * </p>
 * @see yfiles.multipage.MultiPageLayoutResult#getPage
 * @return {number} the number of available pages
 */
yfiles.multipage.MultiPageLayoutResult.prototype.pageCount = function() {};
/**
 * @record
 * @struct
 */
yfiles.multipage.MultiPageLayoutData = function() {};
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.multipage.MultiPageLayoutData.prototype.nodeIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.multipage.MultiPageLayoutData.prototype.edgeIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.multipage.MultiPageLayoutData.prototype.nodeLabelIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.multipage.MultiPageLayoutData.prototype.edgeLabelIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.multipage.MultiPageLayoutData.prototype.nodeClusterIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.multipage.MultiPageLayoutData.prototype.edgeTypes;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.multipage.MultiPageLayoutData.prototype.abortHandler;
 /** @type {!yfiles.lang.Class} */
yfiles.multipage.MultiPageLayoutData.$class;
/** @const */
yfiles.circular = {};
/**
 * @record
 * @struct
 */
yfiles.circular.CircularLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<number>} */
yfiles.circular.CircularLayout.CIRCLE_ID_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<!Object>} */
yfiles.circular.CircularLayout.CUSTOM_GROUPS_DP_KEY;
 /** @type {boolean} */
yfiles.circular.CircularLayout.prototype.considerNodeLabels;
 /** @type {boolean} */
yfiles.circular.CircularLayout.prototype.placeChildrenOnCommonRadius;
 /** @type {boolean} */
yfiles.circular.CircularLayout.prototype.fromSketchMode;
 /** @type {number} */
yfiles.circular.CircularLayout.prototype.maximumDeviationAngle;
 /** @type {yfiles.circular.LayoutStyle} */
yfiles.circular.CircularLayout.prototype.layoutStyle;
 /** @type {!yfiles.circular.SingleCycleLayout} */
yfiles.circular.CircularLayout.prototype.singleCycleLayout;
 /** @type {!yfiles.tree.BalloonLayout} */
yfiles.circular.CircularLayout.prototype.balloonLayout;
 /** @type {yfiles.circular.PartitionStyle} */
yfiles.circular.CircularLayout.prototype.partitionStyle;
 /** @type {boolean} */
yfiles.circular.CircularLayout.prototype.componentLayoutEnabled;
 /** @type {boolean} */
yfiles.circular.CircularLayout.prototype.hideGroupsStageEnabled;
 /** @type {boolean} */
yfiles.circular.CircularLayout.prototype.orientationLayoutEnabled;
 /** @type {boolean} */
yfiles.circular.CircularLayout.prototype.selfLoopRouterEnabled;
 /** @type {!yfiles.layout.EdgeBundling} */
yfiles.circular.CircularLayout.prototype.edgeBundling;
 /** @type {!yfiles.lang.Class} */
yfiles.circular.CircularLayout.$class;

/** @const */
yfiles.circular.LayoutStyle = {};
/** @const {number} */
yfiles.circular.LayoutStyle.BCC_COMPACT;
/** @const {number} */
yfiles.circular.LayoutStyle.BCC_ISOLATED;
/** @const {number} */
yfiles.circular.LayoutStyle.CUSTOM_GROUPS;
/** @const {number} */
yfiles.circular.LayoutStyle.SINGLE_CYCLE;

/** @const */
yfiles.circular.PartitionStyle = {};
/** @const {number} */
yfiles.circular.PartitionStyle.CYCLE;
/** @const {number} */
yfiles.circular.PartitionStyle.DISK;
/** @const {number} */
yfiles.circular.PartitionStyle.ORGANIC;
/**
 * @record
 * @struct
 */
yfiles.circular.SingleCycleLayout = function() {};
 /** @type {number} */
yfiles.circular.SingleCycleLayout.prototype.initialAngle;
 /** @type {boolean} */
yfiles.circular.SingleCycleLayout.prototype.fromSketchModeEnabled;
 /** @type {number} */
yfiles.circular.SingleCycleLayout.prototype.minimumNodeDistance;
 /** @type {number} */
yfiles.circular.SingleCycleLayout.prototype.fixedRadius;
 /** @type {number} */
yfiles.circular.SingleCycleLayout.prototype.minimumRadius;
 /** @type {boolean} */
yfiles.circular.SingleCycleLayout.prototype.automaticRadius;
 /** @type {?} */
yfiles.circular.SingleCycleLayout.prototype.nodeSequencer;
 /** @type {number} */
yfiles.circular.SingleCycleLayout.prototype.lastAppliedRadius;
 /** @type {boolean} */
yfiles.circular.SingleCycleLayout.prototype.orientationLayoutEnabled;
 /** @type {boolean} */
yfiles.circular.SingleCycleLayout.prototype.selfLoopRouterEnabled;
 /** @type {!yfiles.lang.Class} */
yfiles.circular.SingleCycleLayout.$class;
/**
 * @record
 * @struct
 */
yfiles.circular.CircularLayoutData = function() {};
 /** @type {?<?, number>} */
yfiles.circular.CircularLayoutData.prototype.circleIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.circular.CircularLayoutData.prototype.customGroups;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.circular.CircularLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.circular.CircularLayoutData.prototype.abortHandler;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.EdgeBundleDescriptor>} */
yfiles.circular.CircularLayoutData.prototype.edgeBundleDescriptors;
 /** @type {!yfiles.lang.Class} */
yfiles.circular.CircularLayoutData.$class;
/** @const */
yfiles.orthogonal = {};
/**
 * @record
 * @struct
 */
yfiles.orthogonal.EdgeLayoutDescriptor = function() {};
 /** @type {number} */
yfiles.orthogonal.EdgeLayoutDescriptor.prototype.minimumFirstSegmentLength;
 /** @type {number} */
yfiles.orthogonal.EdgeLayoutDescriptor.prototype.minimumLastSegmentLength;
 /** @type {number} */
yfiles.orthogonal.EdgeLayoutDescriptor.prototype.minimumSegmentLength;
 /** @type {!yfiles.lang.Class} */
yfiles.orthogonal.EdgeLayoutDescriptor.$class;

/**
 * Creates a copy of this {\@link yfiles.orthogonal.EdgeLayoutDescriptor} instance.
 * @return {!yfiles.orthogonal.EdgeLayoutDescriptor} a copy of this {\@link } instance
 */
yfiles.orthogonal.EdgeLayoutDescriptor.prototype.createCopy = function() {};

/** @const */
yfiles.orthogonal.LayoutStyle = {};
/** @const {number} */
yfiles.orthogonal.LayoutStyle.NORMAL;
/** @const {number} */
yfiles.orthogonal.LayoutStyle.UNIFORM;
/** @const {number} */
yfiles.orthogonal.LayoutStyle.BOX;
/** @const {number} */
yfiles.orthogonal.LayoutStyle.MIXED;
/** @const {number} */
yfiles.orthogonal.LayoutStyle.NORMAL_TREE;
/** @const {number} */
yfiles.orthogonal.LayoutStyle.FIXED_MIXED;
/** @const {number} */
yfiles.orthogonal.LayoutStyle.FIXED_BOX;
/**
 * @record
 * @struct
 */
yfiles.orthogonal.OrthogonalLayout = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.orthogonal.EdgeLayoutDescriptor>} */
yfiles.orthogonal.OrthogonalLayout.EDGE_LAYOUT_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.EdgeDpKey<boolean>} */
yfiles.orthogonal.OrthogonalLayout.DIRECTED_EDGE_DP_KEY;
 /** @type {!yfiles.orthogonal.EdgeLayoutDescriptor} */
yfiles.orthogonal.OrthogonalLayout.prototype.edgeLayoutDescriptor;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.considerNodeLabels;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.integratedEdgeLabeling;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.randomization;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.alignDegreeOneNodes;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.faceMaximization;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.crossingReduction;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.optimizePerceivedBends;
 /** @type {number} */
yfiles.orthogonal.OrthogonalLayout.prototype.gridSpacing;
 /** @type {yfiles.orthogonal.LayoutStyle} */
yfiles.orthogonal.OrthogonalLayout.prototype.layoutStyle;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.edgeLengthReduction;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.fromSketchMode;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.componentLayoutEnabled;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.hideGroupsStageEnabled;
 /** @type {boolean} */
yfiles.orthogonal.OrthogonalLayout.prototype.orientationLayoutEnabled;
 /** @type {!yfiles.lang.Class} */
yfiles.orthogonal.OrthogonalLayout.$class;

/**
 * Returns a new {\@link yfiles.orthogonal.EdgeLayoutDescriptor} instance that will be used during the various phases of the layout
 * algorithm to determine the drawing details of the edges of the graph.
 * <p>
 * This method may be overridden to create a new {\@link yfiles.orthogonal.EdgeLayoutDescriptor} instance with different
 * configuration settings.
 * </p>
 * @protected
 * @return {!yfiles.orthogonal.EdgeLayoutDescriptor} a new {\@link } instance
 */
yfiles.orthogonal.OrthogonalLayout.prototype.createEdgeLayoutDescriptor = function() {};
/**
 * @record
 * @struct
 */
yfiles.orthogonal.CompactOrthogonalLayout = function() {};
 /** @type {number} */
yfiles.orthogonal.CompactOrthogonalLayout.prototype.gridSpacing;
 /** @type {number} */
yfiles.orthogonal.CompactOrthogonalLayout.prototype.aspectRatio;
 /** @type {!yfiles.lang.Class} */
yfiles.orthogonal.CompactOrthogonalLayout.$class;
/**
 * @record
 * @struct
 */
yfiles.orthogonal.OrthogonalLayoutData = function() {};
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.orthogonal.EdgeLayoutDescriptor>} */
yfiles.orthogonal.OrthogonalLayoutData.prototype.edgeLayoutDescriptors;
 /** @type {!yfiles.layout.ItemCollection<?>} */
yfiles.orthogonal.OrthogonalLayoutData.prototype.directedEdges;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.orthogonal.OrthogonalLayoutData.prototype.sourceGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.orthogonal.OrthogonalLayoutData.prototype.targetGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.orthogonal.OrthogonalLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.orthogonal.OrthogonalLayoutData.prototype.abortHandler;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PreferredPlacementDescriptor>} */
yfiles.orthogonal.OrthogonalLayoutData.prototype.edgeLabelPreferredPlacement;
 /** @type {!yfiles.lang.Class} */
yfiles.orthogonal.OrthogonalLayoutData.$class;
/** @const */
yfiles.radial = {};

/** @const */
yfiles.radial.CenterNodesPolicy = {};
/** @const {number} */
yfiles.radial.CenterNodesPolicy.DIRECTED;
/** @const {number} */
yfiles.radial.CenterNodesPolicy.CENTRALITY;
/** @const {number} */
yfiles.radial.CenterNodesPolicy.WEIGHTED_CENTRALITY;
/** @const {number} */
yfiles.radial.CenterNodesPolicy.CUSTOM;

/** @const */
yfiles.radial.LayeringStrategy = {};
/** @const {number} */
yfiles.radial.LayeringStrategy.BFS;
/** @const {number} */
yfiles.radial.LayeringStrategy.HIERARCHICAL;

/** @const */
yfiles.radial.EdgeRoutingStrategy = {};
/** @const {number} */
yfiles.radial.EdgeRoutingStrategy.POLYLINE;
/** @const {number} */
yfiles.radial.EdgeRoutingStrategy.ARC;
/**
 * @record
 * @struct
 */
yfiles.radial.RadialLayoutNodeInfo = function() {};
 /** @type {number} */
yfiles.radial.RadialLayoutNodeInfo.prototype.circleIndex;
 /** @type {number} */
yfiles.radial.RadialLayoutNodeInfo.prototype.radius;
 /** @type {!yfiles.algorithms.YPoint} */
yfiles.radial.RadialLayoutNodeInfo.prototype.centerOffset;
 /** @type {number} */
yfiles.radial.RadialLayoutNodeInfo.prototype.sectorStart;
 /** @type {number} */
yfiles.radial.RadialLayoutNodeInfo.prototype.sectorSize;
 /** @type {!yfiles.lang.Class} */
yfiles.radial.RadialLayoutNodeInfo.$class;
/**
 * @record
 * @struct
 */
yfiles.radial.RadialLayout = function() {};
 /** @type {!yfiles.algorithms.NodeDpKey<!yfiles.radial.RadialLayoutNodeInfo>} */
yfiles.radial.RadialLayout.NODE_INFO_DP_KEY;
 /** @type {number} */
yfiles.radial.RadialLayout.prototype.minimumNodeToNodeDistance;
 /** @type {number} */
yfiles.radial.RadialLayout.prototype.layerSpacing;
 /** @type {number} */
yfiles.radial.RadialLayout.prototype.minimumLayerDistance;
 /** @type {number} */
yfiles.radial.RadialLayout.prototype.maximumChildSectorAngle;
 /** @type {number} */
yfiles.radial.RadialLayout.prototype.minimumBendAngle;
 /** @type {yfiles.radial.CenterNodesPolicy} */
yfiles.radial.RadialLayout.prototype.centerNodesPolicy;
 /** @type {!Object} */
yfiles.radial.RadialLayout.prototype.centerNodesDpKey;
 /** @type {yfiles.radial.LayeringStrategy} */
yfiles.radial.RadialLayout.prototype.layeringStrategy;
 /** @type {yfiles.radial.EdgeRoutingStrategy} */
yfiles.radial.RadialLayout.prototype.edgeRoutingStrategy;
 /** @type {boolean} */
yfiles.radial.RadialLayout.prototype.considerNodeLabels;
 /** @type {boolean} */
yfiles.radial.RadialLayout.prototype.orientationLayoutEnabled;
 /** @type {!yfiles.layout.EdgeBundling} */
yfiles.radial.RadialLayout.prototype.edgeBundling;
 /** @type {!yfiles.lang.Class} */
yfiles.radial.RadialLayout.$class;
/**
 * @record
 * @struct
 */
yfiles.radial.RadialLayoutData = function() {};
 /** @type {!yfiles.layout.DpKeyItemCollection<?>} */
yfiles.radial.RadialLayoutData.prototype.centerNodes;
 /** @type {?<?, !yfiles.radial.RadialLayoutNodeInfo>} */
yfiles.radial.RadialLayoutData.prototype.nodeInfos;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.radial.RadialLayoutData.prototype.sourceGroups;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.radial.RadialLayoutData.prototype.targetGroups;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.NodeHalo>} */
yfiles.radial.RadialLayoutData.prototype.nodeHalos;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.radial.RadialLayoutData.prototype.abortHandler;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.EdgeBundleDescriptor>} */
yfiles.radial.RadialLayoutData.prototype.edgeBundleDescriptors;
 /** @type {!yfiles.lang.Class} */
yfiles.radial.RadialLayoutData.$class;
/** @const */
yfiles.seriesparallel = {};
/**
 * @record
 * @struct
 */
yfiles.seriesparallel.DefaultOutEdgeComparer = function() {};
 /** @type {!yfiles.lang.Class} */
yfiles.seriesparallel.DefaultOutEdgeComparer.$class;

/**
 * Compares the two given edges considering their {\@link yfiles.layout.PortConstraint}s.
 * <p>
 * The order of edges is kept unless there are
 * {\@link yfiles.layout.PortConstraint}s assigned. Then the edges will be sorted to avoid edge crossings.
 * </p>
 * @param {!Object} o1 the first edge
 * @param {!Object} o2 the second edge
 * @return {number} the order of the given two edges
 */
yfiles.seriesparallel.DefaultOutEdgeComparer.prototype.compare = function(o1, o2) {};
/**
 * @record
 * @struct
 */
yfiles.seriesparallel.DefaultPortAssignment = function() {};
 /** @type {yfiles.seriesparallel.PortAssignmentMode} */
yfiles.seriesparallel.DefaultPortAssignment.prototype.mode;
 /** @type {number} */
yfiles.seriesparallel.DefaultPortAssignment.prototype.borderGapToPortGapRatio;
 /** @type {yfiles.seriesparallel.ForkStyle} */
yfiles.seriesparallel.DefaultPortAssignment.prototype.forkStyle;
 /** @type {!yfiles.lang.Class} */
yfiles.seriesparallel.DefaultPortAssignment.$class;

/**
 * Places the ports of edges connecting to the given node according to the {\@link yfiles.seriesparallel.DefaultPortAssignment#mode port assignment mode}.
 * @see yfiles.seriesparallel.DefaultPortAssignment#mode
 * @param {!yfiles.layout.LayoutGraph} graph the input graph
 * @param {!yfiles.algorithms.Node} node the node whose adjacent edges' ports should be placed
 * @return {void}
 */
yfiles.seriesparallel.DefaultPortAssignment.prototype.assignPorts = function(graph, node) {};

/**
 * Determines the distance between the outer ports and the border of the node.
 * <p>
 * This implementation calculates the gap according to the number of edges at one side of the node. It also includes the
 * {\@link yfiles.seriesparallel.DefaultPortAssignment#borderGapToPortGapRatio ratio between border gap and port gap}.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.seriesparallel.DefaultPortAssignment#assignPorts} to calculate the location of the first
 * port. It may be overridden to implement a different distribution of ports on the node's side.
 * </p>
 * @see yfiles.seriesparallel.DefaultPortAssignment#assignPorts
 * @see yfiles.seriesparallel.DefaultPortAssignment#borderGapToPortGapRatio
 * @protected
 * @param {number} sideLength the width/height of the side
 * @param {number} edgeCount the number of edges that connect to this side
 * @return {number} the absolute gap to be used on both sides of the ports
 */
yfiles.seriesparallel.DefaultPortAssignment.prototype.getPortBorderGap = function(sideLength, edgeCount) {};

/**
 * Determines the distance between two adjacent ports.
 * <p>
 * This implementation calculates the gap according to the number of edges at one side of the node. The edges are
 * distributed keeping the given gap to the border of the node.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.seriesparallel.DefaultPortAssignment#assignPorts} to calculate the distance between two
 * ports. It may be overridden to implement a different distribution of ports on the node's side.
 * </p>
 * @see yfiles.seriesparallel.DefaultPortAssignment#assignPorts
 * @see yfiles.seriesparallel.DefaultPortAssignment#getPortBorderGap
 * @protected
 * @param {number} sideLength the width/height of the side
 * @param {number} edgeCount the number of edges/ports that connect to this side
 * @param {number} portBorderGap the port border gap (i.e. calculated by {\@link #getPortBorderGap})
 * @return {number} the absolute distance to be used between two adjacent ports
 */
yfiles.seriesparallel.DefaultPortAssignment.prototype.getPortDistanceDelta = function(sideLength, edgeCount, portBorderGap) {};
/**
 * @record
 * @struct
 */
yfiles.seriesparallel.EdgeLayoutDescriptor = function() {};
 /** @type {number} */
yfiles.seriesparallel.EdgeLayoutDescriptor.prototype.minimumLength;
 /** @type {number} */
yfiles.seriesparallel.EdgeLayoutDescriptor.prototype.minimumFirstSegmentLength;
 /** @type {number} */
yfiles.seriesparallel.EdgeLayoutDescriptor.prototype.minimumLastSegmentLength;
 /** @type {!yfiles.lang.Class} */
yfiles.seriesparallel.EdgeLayoutDescriptor.$class;

/**
 * Creates a copy of this {\@link yfiles.seriesparallel.EdgeLayoutDescriptor} instance.
 * @return {!yfiles.seriesparallel.EdgeLayoutDescriptor} a copy of this {\@link } instance
 */
yfiles.seriesparallel.EdgeLayoutDescriptor.prototype.createCopy = function() {};

/** @const */
yfiles.seriesparallel.PortAssignmentMode = {};
/** @const {number} */
yfiles.seriesparallel.PortAssignmentMode.CENTER;
/** @const {number} */
yfiles.seriesparallel.PortAssignmentMode.DISTRIBUTED;

/** @const */
yfiles.seriesparallel.ForkStyle = {};
/** @const {number} */
yfiles.seriesparallel.ForkStyle.OUTSIDE_NODE;
/** @const {number} */
yfiles.seriesparallel.ForkStyle.AT_NODE;

/** @const */
yfiles.seriesparallel.RoutingStyle = {};
/** @const {number} */
yfiles.seriesparallel.RoutingStyle.ORTHOGONAL;
/** @const {number} */
yfiles.seriesparallel.RoutingStyle.OCTILINEAR;
/** @const {number} */
yfiles.seriesparallel.RoutingStyle.POLYLINE;
/**
 * @record
 * @struct
 */
yfiles.seriesparallel.IPortAssignment = function() {};

/**
 * Assigns both the incoming edges' target ports as well as all source ports for the outgoing edges.
 * <p>
 * Outgoing edges are sorted according to the specified out-edge comparator from left to right and incoming edges are in
 * the order of the subgraphs they are coming from.
 * </p>
 * <p>
 * This method is called by {\@link yfiles.seriesparallel.SeriesParallelLayout} before the actual layout of the graph takes place.
 * </p>
 * @see yfiles.seriesparallel.SeriesParallelLayout#OUT_EDGE_COMPARER_DP_KEY
 * @see yfiles.seriesparallel.SeriesParallelLayout#defaultOutEdgeComparer
 * @abstract
 * @param {!yfiles.layout.LayoutGraph} graph the graph instance the node is part of
 * @param {!yfiles.algorithms.Node} node the node whose incident edges' ports are assigned
 * @return {void}
 */
yfiles.seriesparallel.IPortAssignment.prototype.assignPorts = function(graph, node) {};
 /** @type {{$class: !yfiles.lang.Class, isInstance: function(!Object): boolean}} */
yfiles.seriesparallel.IPortAssignment;
/**
 * @record
 * @struct
 */
yfiles.seriesparallel.SeriesParallelLayout = function() {};
 /** @type {!yfiles.algorithms.EdgeDpKey<!yfiles.seriesparallel.EdgeLayoutDescriptor>} */
yfiles.seriesparallel.SeriesParallelLayout.EDGE_LAYOUT_DESCRIPTOR_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<?<!Object>>} */
yfiles.seriesparallel.SeriesParallelLayout.OUT_EDGE_COMPARER_DP_KEY;
 /** @type {!yfiles.algorithms.NodeDpKey<?>} */
yfiles.seriesparallel.SeriesParallelLayout.PORT_ASSIGNMENT_DP_KEY;
 /** @type {!yfiles.algorithms.IEdgeLabelLayoutDpKey<boolean>} */
yfiles.seriesparallel.SeriesParallelLayout.NON_SERIES_PARALLEL_EDGE_LABELS_DP_KEY;
 /** @type {boolean} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.considerNodeLabels;
 /** @type {boolean} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.integratedEdgeLabeling;
 /** @type {number} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.verticalAlignment;
 /** @type {boolean} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.generalGraphHandling;
 /** @type {?} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.nonSeriesParallelEdgeRouter;
 /** @type {!Object} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.nonSeriesParallelEdgesDpKey;
 /** @type {?} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.nonSeriesParallelEdgeLabelingAlgorithm;
 /** @type {!Object} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.nonSeriesParallelEdgeLabelSelectionKey;
 /** @type {?} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.defaultPortAssignment;
 /** @type {?<!Object>} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.defaultOutEdgeComparer;
 /** @type {yfiles.seriesparallel.RoutingStyle} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.routingStyle;
 /** @type {number} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.minimumPolylineSegmentLength;
 /** @type {number} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.minimumSlope;
 /** @type {number} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.preferredOctilinearSegmentLength;
 /** @type {!yfiles.seriesparallel.EdgeLayoutDescriptor} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.defaultEdgeLayoutDescriptor;
 /** @type {number} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.minimumNodeToNodeDistance;
 /** @type {number} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.minimumNodeToEdgeDistance;
 /** @type {number} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.minimumEdgeToEdgeDistance;
 /** @type {boolean} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.fromSketchMode;
 /** @type {boolean} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.componentLayoutEnabled;
 /** @type {boolean} */
yfiles.seriesparallel.SeriesParallelLayout.prototype.selfLoopRouterEnabled;
 /** @type {!yfiles.lang.Class} */
yfiles.seriesparallel.SeriesParallelLayout.$class;

/**
 * Determines whether or not the given graph has a series-parallel structure.
 * <p>
 * The current implementation detects the series-parallel graph structure in linear time.
 * </p>
 * @param {!yfiles.algorithms.Graph} graph the input graph
 * @return {boolean} <code>true</code> if the given graph is series-parallel, <code>false</code> otherwise
 */
yfiles.seriesparallel.SeriesParallelLayout.isSeriesParallelGraph = function(graph) {};
/**
 * @record
 * @struct
 */
yfiles.seriesparallel.SeriesParallelLayoutData = function() {};
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.seriesparallel.EdgeLayoutDescriptor>} */
yfiles.seriesparallel.SeriesParallelLayoutData.prototype.edgeLayoutDescriptors;
 /** @type {!yfiles.layout.ItemMapping<?, ?>} */
yfiles.seriesparallel.SeriesParallelLayoutData.prototype.portAssignments;
 /** @type {!yfiles.layout.ItemMapping<?, !Function>} */
yfiles.seriesparallel.SeriesParallelLayoutData.prototype.outEdgeComparers;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.seriesparallel.SeriesParallelLayoutData.prototype.sourceGroupIds;
 /** @type {!yfiles.layout.ItemMapping<?, !Object>} */
yfiles.seriesparallel.SeriesParallelLayoutData.prototype.targetGroupIds;
 /** @type {!yfiles.algorithms.AbortHandler} */
yfiles.seriesparallel.SeriesParallelLayoutData.prototype.abortHandler;
 /** @type {!yfiles.layout.ItemMapping<?, !yfiles.layout.PreferredPlacementDescriptor>} */
yfiles.seriesparallel.SeriesParallelLayoutData.prototype.edgeLabelPreferredPlacement;
 /** @type {!yfiles.lang.Class} */
yfiles.seriesparallel.SeriesParallelLayoutData.$class;

/** @typedef {?} */
var yfiles_namespace;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/algorithms"
/** @const */
tsickle_declare_module.yfiles_algorithms = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_algorithms */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/complete"
/** @const */
tsickle_declare_module.yfiles_complete = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_complete */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/lang"
/** @const */
tsickle_declare_module.yfiles_lang = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_lang */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout"
/** @const */
tsickle_declare_module.yfiles_layout = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-familytree"
/** @const */
tsickle_declare_module.yfiles_layout_familytree = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_familytree */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-hierarchic"
/** @const */
tsickle_declare_module.yfiles_layout_hierarchic = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_hierarchic */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-multipage"
/** @const */
tsickle_declare_module.yfiles_layout_multipage = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_multipage */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-organic"
/** @const */
tsickle_declare_module.yfiles_layout_organic = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_organic */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-orthogonal"
/** @const */
tsickle_declare_module.yfiles_layout_orthogonal = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_orthogonal */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-orthogonal-compact"
/** @const */
tsickle_declare_module.yfiles_layout_orthogonal_compact = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_orthogonal_compact */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-partial"
/** @const */
tsickle_declare_module.yfiles_layout_partial = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_partial */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-radial"
/** @const */
tsickle_declare_module.yfiles_layout_radial = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_radial */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-seriesparallel"
/** @const */
tsickle_declare_module.yfiles_layout_seriesparallel = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_seriesparallel */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/layout-tree"
/** @const */
tsickle_declare_module.yfiles_layout_tree = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_layout_tree */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/router-other"
/** @const */
tsickle_declare_module.yfiles_router_other = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_router_other */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/router-polyline"
/** @const */
tsickle_declare_module.yfiles_router_polyline = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_router_polyline */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/view"
/** @const */
tsickle_declare_module.yfiles_view = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_view */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/view-component"
/** @const */
tsickle_declare_module.yfiles_view_component = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_view_component */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/view-editor"
/** @const */
tsickle_declare_module.yfiles_view_editor = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_view_editor */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/view-folding"
/** @const */
tsickle_declare_module.yfiles_view_folding = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_view_folding */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/view-graphml"
/** @const */
tsickle_declare_module.yfiles_view_graphml = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_view_graphml */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/view-layout-bridge"
/** @const */
tsickle_declare_module.yfiles_view_layout_bridge = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_view_layout_bridge */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "yfiles/view-table"
/** @const */
tsickle_declare_module.yfiles_view_table = {};

/* TODO: ExportAssignment in tsickle_declare_module.yfiles_view_table */
