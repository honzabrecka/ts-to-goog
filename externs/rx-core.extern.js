/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/rx-core/index.d.ts:
/** @const */
var Rx = {};
/**
 * @record
 * @struct
 */
Rx.IPromise = function() {};

/**
 * @template R
 * @param {function(T): !Rx.IPromise<R>|function(T): R=} onFulfilled
 * @param {function(?): !Rx.IPromise<R>|function(?): R=} onRejected
 * @return {!Rx.IPromise<R>}
 */
Rx.IPromise.prototype.then = function(onFulfilled, onRejected) {};
/**
 * @record
 * @struct
 */
Rx.IDisposable = function() {};

/**
 * @return {void}
 */
Rx.IDisposable.prototype.dispose = function() {};
/**
 * @record
 * @struct
 */
Rx.IScheduler = function() {};

/**
 * @param {function(?): boolean} handler
 * @return {!Rx.IScheduler}
 */
Rx.IScheduler.prototype.catch = function(handler) {};

/**
 * @param {function(?): boolean} handler
 * @return {!Rx.IScheduler}
 */
Rx.IScheduler.prototype.catchException = function(handler) {};
/**
 * @record
 * @struct
 */
Rx.Observer = function() {};

/**
 * @return {!Rx.Observer<?>}
 */
Rx.Observer.prototype.checked = function() {};
/**
 * @record
 * @struct
 */
Rx.ObserverStatic = function() {};

/**
 * Schedules the invocation of observer methods on the given scheduler.
 * @template T
 * @param {!Rx.IScheduler} scheduler Scheduler to schedule observer messages on.
 * @return {!Rx.Observer<T>} Observer whose messages are scheduled on the given scheduler.
 */
Rx.ObserverStatic.prototype.notifyOn = function(scheduler) {};
/**
 * @record
 * @struct
 */
Rx.Observable = function() {};

/**
 * @param {!Rx.IScheduler} scheduler
 * @return {!Rx.Observable}
 */
Rx.Observable.prototype.observeOn = function(scheduler) {};

/**
 * @param {!Rx.IScheduler} scheduler
 * @return {!Rx.Observable}
 */
Rx.Observable.prototype.subscribeOn = function(scheduler) {};

/**
 * @param {(!Rx.Observable|!Rx.IPromise<T>)} rightSource
 * @return {!Rx.Observable}
 */
Rx.Observable.prototype.amb = function(rightSource) {};

/**
 * @param {(!Rx.Observable|!Rx.IPromise<T>)} second
 * @return {!Rx.Observable}
 */
Rx.Observable.prototype.onErrorResumeNext = function(second) {};

/**
 * @param {number} count
 * @param {number=} skip
 * @return {!Rx.Observable<!Array<T>>}
 */
Rx.Observable.prototype.bufferWithCount = function(count, skip) {};

/**
 * @param {number} count
 * @param {number=} skip
 * @return {!Rx.Observable<!Rx.Observable>}
 */
Rx.Observable.prototype.windowWithCount = function(count, skip) {};

/**
 * @param {T=} defaultValue
 * @return {!Rx.Observable}
 */
Rx.Observable.prototype.defaultIfEmpty = function(defaultValue) {};

/**
 * @template TKey
 * @param {boolean|function(T): TKey=} skipParameter_or_keySelector
 * @param {function(T): string|function(TKey): string=} valueSerializer_or_keySerializer
 * @return {!Rx.Observable}
 */
Rx.Observable.prototype.distinct = function(skipParameter_or_keySelector, valueSerializer_or_keySerializer) {};

/**
 * @template TKey, TElement
 * @param {function(T): TKey} keySelector
 * @param {boolean|function(T): TElement=} skipElementSelector_or_elementSelector
 * @param {function(TKey): string=} keySerializer
 * @return {!Rx.Observable<!Rx.GroupedObservable<TKey, T>>|!Rx.Observable<!Rx.GroupedObservable<TKey, TElement>>}
 */
Rx.Observable.prototype.groupBy = function(keySelector, skipElementSelector_or_elementSelector, keySerializer) {};

/**
 * @template TKey, TDuration, TElement
 * @param {function(T): TKey} keySelector
 * @param {boolean|function(T): TElement} skipElementSelector_or_elementSelector
 * @param {function(!Rx.GroupedObservable<TKey, T>): !Rx.Observable<TDuration>|function(!Rx.GroupedObservable<TKey, TElement>): !Rx.Observable<TDuration>} durationSelector
 * @param {function(TKey): string=} keySerializer
 * @return {!Rx.Observable<!Rx.GroupedObservable<TKey, T>>|!Rx.Observable<!Rx.GroupedObservable<TKey, TElement>>}
 */
Rx.Observable.prototype.groupByUntil = function(keySelector, skipElementSelector_or_elementSelector, durationSelector, keySerializer) {};
/**
 * @record
 * @struct
 */
Rx.ObservableStatic = function() {};

/**
 * @template TSource, TResource
 * @param {function(): TResource} resourceFactory
 * @param {function(TResource): !Rx.Observable<TSource>} observableFactory
 * @return {!Rx.Observable<TSource>}
 */
Rx.ObservableStatic.prototype.using = function(resourceFactory, observableFactory) {};

/**
 * @template T
 * @param {...!Rx.IPromise<T>|!Rx.Observable<T>|(!Array<!Rx.IPromise<T>>|!Array<!Rx.Observable<T>>)} sources
 * @return {!Rx.Observable<T>}
 */
Rx.ObservableStatic.prototype.amb = function(sources) {};

/**
 * @template T
 * @param {...!Rx.IPromise<T>|!Rx.Observable<T>|(!Array<!Rx.IPromise<T>>|!Array<!Rx.Observable<T>>)} sources
 * @return {!Rx.Observable<T>}
 */
Rx.ObservableStatic.prototype.onErrorResumeNext = function(sources) {};
/**
 * @extends {Rx.Observable}
 * @record
 * @struct
 */
Rx.GroupedObservable = function() {};
 /** @type {TKey} */
Rx.GroupedObservable.prototype.key;
 /** @type {!Rx.Observable<TElement>} */
Rx.GroupedObservable.prototype.underlyingObservable;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "rx-core"
/** @const */
tsickle_declare_module.rx_core = {};

/* TODO: ExportAssignment in tsickle_declare_module.rx_core */
