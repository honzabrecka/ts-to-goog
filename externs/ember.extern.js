/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/ember/index.d.ts:

/* TODO: ImportDeclaration in  */
/** @const */
var EmberStates = {};
/**
 * @record
 * @struct
 */
EmberStates.Transition = function() {};
 /** @type {string} */
EmberStates.Transition.prototype.targetName;
 /** @type {string} */
EmberStates.Transition.prototype.urlMethod;
 /** @type {?} */
EmberStates.Transition.prototype.intent;
 /** @type {?} */
EmberStates.Transition.prototype.params;
 /** @type {?} */
EmberStates.Transition.prototype.pivotHandler;
 /** @type {number} */
EmberStates.Transition.prototype.resolveIndex;
 /** @type {?} */
EmberStates.Transition.prototype.handlerInfos;
 /** @type {?} */
EmberStates.Transition.prototype.resolvedModels;
 /** @type {boolean} */
EmberStates.Transition.prototype.isActive;
 /** @type {?} */
EmberStates.Transition.prototype.state;
 /** @type {?} */
EmberStates.Transition.prototype.queryParams;
 /** @type {boolean} */
EmberStates.Transition.prototype.queryParamsOnly;
 /** @type {boolean} */
EmberStates.Transition.prototype.isTransition;
 /** @type {!RSVP.Promise<?, ?>} */
EmberStates.Transition.prototype.promise;
 /** @type {?} */
EmberStates.Transition.prototype.data;

/**
 * A standard promise hook that resolves if the transition
 * succeeds and rejects if it fails/redirects/aborts.
 * Forwards to the internal `promise` property which you can
 * use in situations where you want to pass around a thennable,
 * but not the Transition itself.
 * \@arg {Function} onFulfilled
 * \@arg {Function} onRejected
 * \@arg {String} label optional string for labeling the promise. Useful for tooling.
 * @param {?} onFulfilled
 * @param {?=} onRejected
 * @param {string=} label
 * @return {!RSVP.Promise<?, ?>}
 */
EmberStates.Transition.prototype.then = function(onFulfilled, onRejected, label) {};

/**
 * Forwards to the internal `promise` property which you can
 * use in situations where you want to pass around a thennable,
 * but not the Transition itself.
 * \@method catch
 * \@arg {Function} onRejection
 * \@arg {String} label optional string for labeling the promise.
 * Useful for tooling.
 * @param {?} onRejection
 * @param {string=} label
 * @return {!RSVP.Promise<?, ?>}
 */
EmberStates.Transition.prototype.catch = function(onRejection, label) {};

/**
 * Forwards to the internal `promise` property which you can
 * use in situations where you want to pass around a thennable,
 * but not the Transition itself.
 * \@method finally
 * \@arg {Function} callback
 * \@arg {String} label optional string for labeling the promise.
 * Useful for tooling.
 * @param {?} callback
 * @param {string=} label
 * @return {!RSVP.Promise<?, ?>}
 */
EmberStates.Transition.prototype.finally = function(callback, label) {};

/**
 * Aborts the Transition. Note you can also implicitly abort a transition
 * by initiating another transition while a previous one is underway.
 * @return {!EmberStates.Transition}
 */
EmberStates.Transition.prototype.abort = function() {};

/**
 * @param {!Ember.StateManager} manager
 * @param {!Array<?>} contexts
 * @return {void}
 */
EmberStates.Transition.prototype.normalize = function(manager, contexts) {};

/**
 * Retries a previously-aborted transition (making sure to abort the
 * transition if it's still active). Returns a new transition that
 * represents the new attempt to transition.
 * @return {!EmberStates.Transition}
 */
EmberStates.Transition.prototype.retry = function() {};

/**
 * Sets the URL-changing method to be employed at the end of a
 * successful transition. By default, a new Transition will just
 * use `updateURL`, but passing 'replace' to this method will
 * cause the URL to update using 'replaceWith' instead. Omitting
 * a parameter will disable the URL change, allowing for transitions
 * that don't update the URL at completion (this is also used for
 * handleURL, since the URL has already changed before the
 * transition took place).
 * \@arg {String} method the type of URL-changing method to use
 * at the end of a transition. Accepted values are 'replace',
 * falsy values, or any other non-falsy value (which is
 * interpreted as an updateURL transition).
 * @param {string} method
 * @return {!EmberStates.Transition}
 */
EmberStates.Transition.prototype.method = function(method) {};

/**
 * Fires an event on the current list of resolved/resolving
 * handlers within this transition. Useful for firing events
 * on route hierarchies that haven't fully been entered yet.
 * Note: This method is also aliased as `send`
 * \@arg {Boolean} [ignoreFailure=false] a boolean specifying whether unhandled events throw an error
 * \@arg {String} name the name of the event to fire
 * Fires an event on the current list of resolved/resolving
 * handlers within this transition. Useful for firing events
 * on route hierarchies that haven't fully been entered yet.
 * Note: This method is also aliased as `send`
 * \@arg {String} name the name of the event to fire
 * @param {boolean|string} ignoreFailure_or_eventName
 * @param {string=} eventName
 * @return {void}
 */
EmberStates.Transition.prototype.trigger = function(ignoreFailure_or_eventName, eventName) {};

/**
 * Transitions are aborted and their promises rejected
 * when redirects occur; this method returns a promise
 * that will follow any redirects that occur and fulfill
 * with the value fulfilled by any redirecting transitions
 * that occur.
 * value that the final redirecting transition fulfills with
 * @return {!RSVP.Promise<?, ?>}
 */
EmberStates.Transition.prototype.followRedirects = function() {};

/** @typedef {!Array<?>} */
var GlobalArray;
/** @const */
var EmberTesting = {};
/** @const */
EmberTesting.Test = {};
/**
 * @constructor
 * @struct
 */
EmberTesting.Test.Adapter = function() {};

/**
 * @return {void}
 */
EmberTesting.Test.Adapter.prototype.asyncEnd = function() {};

/**
 * @return {void}
 */
EmberTesting.Test.Adapter.prototype.asyncStart = function() {};

/**
 * @param {string} error
 * @return {void}
 */
EmberTesting.Test.Adapter.prototype.exception = function(error) {};
/**
 * @extends {EmberTesting.Test.Adapter}
 * @constructor
 * @struct
 */
EmberTesting.Test.QUnitAdapter = function() {};
/**
 * @record
 * @struct
 */
function Function() {}

/**
 * @param {...string} args
 * @return {?}
 */
Function.prototype.observes = function(args) {};

/**
 * @param {...string} args
 * @return {?}
 */
Function.prototype.observesBefore = function(args) {};

/**
 * @param {...string} args
 * @return {?}
 */
Function.prototype.on = function(args) {};

/**
 * @param {...string} args
 * @return {?}
 */
Function.prototype.property = function(args) {};
/**
 * @record
 * @struct
 */
function String() {}

/**
 * @return {string}
 */
String.prototype.camelize = function() {};

/**
 * @return {string}
 */
String.prototype.capitalize = function() {};

/**
 * @return {string}
 */
String.prototype.classify = function() {};

/**
 * @return {string}
 */
String.prototype.dasherize = function() {};

/**
 * @return {string}
 */
String.prototype.decamelize = function() {};

/**
 * @param {...string} args
 * @return {string}
 */
String.prototype.fmt = function(args) {};

/**
 * @return {?}
 */
String.prototype.htmlSafe = function() {};

/**
 * @param {...string} args
 * @return {string}
 */
String.prototype.loc = function(args) {};

/**
 * @return {string}
 */
String.prototype.underscore = function() {};

/**
 * @return {!Array<string>}
 */
String.prototype.w = function() {};
/**
 * @record
 * @struct
 */
function Array() {}
 /** @type {?} */
Array.prototype.reject;

/* TODO: PropertySignature: '[]' */

/* TODO: PropertySignature: '@each' */
 /** @type {boolean} */
Array.prototype.Boolean;
 /** @type {?} */
Array.prototype.firstObject;
 /** @type {boolean} */
Array.prototype.hasEnumerableObservers;
 /** @type {?} */
Array.prototype.lastObject;
 /** @type {?} */
Array.prototype.addObserver;

/**
 * @param {!Array<?>} arr
 * @return {void}
 */
Array.prototype.constructor = function(arr) {};

/**
 * @return {void}
 */
Array.prototype.activate = function() {};

/**
 * @param {?} target
 * @param {?=} opts
 * @return {!Array<?>}
 */
Array.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Array<?>}
 */
Array.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Array.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Array.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Array.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Array.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {boolean}
 */
Array.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.clear = function() {};

/**
 * @return {!Array<?>}
 */
Array.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Array.prototype.contains = function(obj) {};

/**
 * @param {number|(number|!Ember.Enumerable)} start_or_removing
 * @param {(number|!Ember.Enumerable)} removing_or_adding
 * @param {(number|!Ember.Enumerable)=} adding
 * @return {?}
 */
Array.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {(number|!Ember.Enumerable)} removing
 * @param {(number|!Ember.Enumerable)} adding
 * @return {!Ember.Enumerable}
 */
Array.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Array.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Array.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {boolean}
 */
Array.prototype.everyProperty = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {!Array<?>}
 */
Array.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Array.prototype.filterBy = function(key, value) {};

/**
 * Returns the first item in the array for which the callback returns true.
 * This method works similar to the `filter()` method defined in JavaScript 1.6
 * except that it will stop working on the array once a match is found.
 * The callback method you provide should have the following signature (all
 * parameters are optional):
 * ```javascript
 * function(item, index, enumerable);
 * ```
 * - `item` is the current item in the iteration.
 * - `index` is the current index in the iteration.
 * - `enumerable` is the enumerable object itself.
 * It should return the `true` to include the item in the results, `false`
 * otherwise.
 * Note that in addition to a callback, you can also pass an optional target
 * object that will be set as `this` on the context. This is a good way
 * to give your iterator function access to the current object.
 * \@arg callback The callback to execute
 * \@arg {Object} [target] The target object to use
 * @param {?} callback
 * @param {?=} target
 * @return {?}
 */
Array.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Array.prototype.findBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {?}
 */
Array.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Array.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number=} startAt
 * @return {number}
 */
Array.prototype.indexOf = function(object, startAt) {};

/**
 * @param {number} idx
 * @param {?} object
 * @return {!Array<?>}
 */
Array.prototype.insertAt = function(idx, object) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Array.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number=} startAt
 * @return {number}
 */
Array.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {!Array<?>}
 */
Array.prototype.map = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Array.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Array.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Array.prototype.objectAt = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Array.prototype.objectsAt = function(args) {};

/**
 * @return {?}
 */
Array.prototype.popObject = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Array.prototype.pushObject = function(obj) {};

/**
 * @param {...?} args
 * @return {!Array<?>}
 */
Array.prototype.pushObjects = function(args) {};

/**
 * @param {?} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Array.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Array.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Array<?>}
 */
Array.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {number} start
 * @param {number} len
 * @return {?}
 */
Array.prototype.removeAt = function(start, len) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Array<?>}
 */
Array.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {void}
 */
Array.prototype.replace = function(idx, amt, objects) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.reverseObjects = function() {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Array.prototype.setEach = function(key, value) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Array.prototype.setObjects = function(objects) {};

/**
 * @return {?}
 */
Array.prototype.shiftObject = function() {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Array.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Array.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.toArray = function() {};

/**
 * @return {!Array<?>}
 */
Array.prototype.uniq = function() {};

/**
 * @param {?} object
 * @return {?}
 */
Array.prototype.unshiftObject = function(object) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Array.prototype.unshiftObjects = function(objects) {};

/**
 * @param {?} value
 * @return {!Array<?>}
 */
Array.prototype.without = function(value) {};

/**
 * @param {?} object
 * @return {?}
 */
Array.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Array<?>}
 */
Array.prototype.addObjects = function(objects) {};

/**
 * @param {?} object
 * @return {?}
 */
Array.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Array<?>}
 */
Array.prototype.removeObjects = function(objects) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.beginPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Array.prototype.cacheFor = function(keyName) {};

/**
 * @param {string} keyName
 * @param {number=} decrement
 * @return {number}
 */
Array.prototype.decrementProperty = function(keyName, decrement) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.endPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Array.prototype.get = function(keyName) {};

/**
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Array.prototype.getProperties = function(args_or_keys) {};

/**
 * @param {string} keyName
 * @param {?} defaultValue
 * @return {?}
 */
Array.prototype.getWithDefault = function(keyName, defaultValue) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Array.prototype.hasObserverFor = function(key) {};

/**
 * @param {string} keyName
 * @param {number=} increment
 * @return {number}
 */
Array.prototype.incrementProperty = function(keyName, increment) {};

/**
 * @param {string} keyName
 * @return {!Array<?>}
 */
Array.prototype.notifyPropertyChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Array<?>}
 */
Array.prototype.propertyDidChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Array<?>}
 */
Array.prototype.propertyWillChange = function(keyName) {};

/**
 * @param {string} key
 * @param {?} target
 * @param {(string|?)} method
 * @return {!Ember.Observable}
 */
Array.prototype.removeObserver = function(key, target, method) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Array<?>}
 */
Array.prototype.set = function(keyName, value) {};

/**
 * @param {!Object} hash
 * @return {!Array<?>}
 */
Array.prototype.setProperties = function(hash) {};

/**
 * @param {string} keyName
 * @return {?}
 */
Array.prototype.toggleProperty = function(keyName) {};

/**
 * @param {boolean} deep
 * @return {!Array<?>}
 */
Array.prototype.copy = function(deep) {};

/**
 * @return {!Array<?>}
 */
Array.prototype.frozenCopy = function() {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Array.prototype.isAny = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Array.prototype.isEvery = function(key, value) {};
/**
 * @record
 * @struct
 */
function ApplicationCreateArguments() {}
 /** @type {!Object} */
ApplicationCreateArguments.prototype.customEvents;
 /** @type {string} */
ApplicationCreateArguments.prototype.rootElement;
 /** @type {boolean} */
ApplicationCreateArguments.prototype.LOG_TRANSITIONS;
 /** @type {boolean} */
ApplicationCreateArguments.prototype.LOG_TRANSITIONS_INTERNAL;

/** @typedef {?} */
var ApplicationInitializerFunction;
/**
 * @record
 * @struct
 */
function ApplicationInitializerArguments() {}
 /** @type {string} */
ApplicationInitializerArguments.prototype.name;
 /** @type {?} */
ApplicationInitializerArguments.prototype.initialize;
/**
 * @record
 * @struct
 */
function CoreObjectArguments() {}
 /** @type {?} */
CoreObjectArguments.prototype.init;
 /** @type {?} */
CoreObjectArguments.prototype.willDestroy;

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function EnumerableConfigurationOptions() {}
 /** @type {boolean} */
EnumerableConfigurationOptions.prototype.willChange;
 /** @type {boolean} */
EnumerableConfigurationOptions.prototype.didChange;

/** @typedef {?} */
var ItemIndexEnumerableCallbackTarget;

/** @typedef {?} */
var ItemIndexEnumerableCallback;

/** @typedef {?} */
var ReduceCallback;
/**
 * @record
 * @struct
 */
function TransitionsHash() {}
 /** @type {!Array<?>} */
TransitionsHash.prototype.contexts;
 /** @type {!Array<!Ember.State>} */
TransitionsHash.prototype.exitStates;
 /** @type {!Array<!Ember.State>} */
TransitionsHash.prototype.enterStates;
 /** @type {!Ember.State} */
TransitionsHash.prototype.resolveState;
/**
 * @record
 * @struct
 */
function ActionsHash() {}
 /** @type {?} */
ActionsHash.prototype.willTransition;
 /** @type {?} */
ActionsHash.prototype.error;
/**
 * @record
 * @struct
 */
function DisconnectOutletOptions() {}
 /** @type {string} */
DisconnectOutletOptions.prototype.outlet;
 /** @type {string} */
DisconnectOutletOptions.prototype.parentView;
/**
 * @record
 * @struct
 */
function RenderOptions() {}
 /** @type {string} */
RenderOptions.prototype.into;
 /** @type {string} */
RenderOptions.prototype.controller;
 /** @type {?} */
RenderOptions.prototype.model;
 /** @type {string} */
RenderOptions.prototype.outlet;
 /** @type {string} */
RenderOptions.prototype.view;

/** @typedef {?} */
var ModifyObserver;
/** @const */
var Ember = {};
 /** @type {!JQueryStatic<!HTMLElement>} */
Ember.$;

/**
 * Creates an Ember.NativeArray from an Array like object. Does not modify the original object.
 * Ember.A is not needed if Ember.EXTEND_PROTOTYPES is true (the default value). However, it is
 * recommended that you use Ember.A when creating addons for ember or when you can not garentee
 * that Ember.EXTEND_PROTOTYPES will be true.
 * 
 * @param {!Array<?>=} arr
 * @return {!Ember.NativeArray}
 */
Ember.A = function(arr) {};
/**
 * @constructor
 * @struct
 */
Ember.ActionHandlerMixin = function() {};
 /** @type {?} */
Ember.ActionHandlerMixin.prototype.actions;

/**
 * Triggers a named action on the ActionHandler
 * 
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ActionHandlerMixin.prototype.send = function(name, args) {};
/**
 * @extends {Ember.Namespace}
 * @constructor
 * @struct
 */
Ember.Application = function() {};
 /** @type {boolean} */
Ember.Application.isClass;
 /** @type {boolean} */
Ember.Application.isMethod;
 /** @type {!Object} */
Ember.Application.prototype.customEvents;
 /** @type {!Ember.EventDispatcher} */
Ember.Application.prototype.eventDispatcher;
 /** @type {!Ember.DefaultResolver} */
Ember.Application.prototype.resolver;
 /** @type {!HTMLElement} */
Ember.Application.prototype.rootElement;
 /** @type {?} */
Ember.Application.prototype.ready;
 /** @type {!Ember.Router} */
Ember.Application.prototype.Router;
 /** @type {!Ember.Registry} */
Ember.Application.prototype.registry;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Application.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Application.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Application.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Application.metaForProperty = function(key) {};

/**
 * Call advanceReadiness after any asynchronous setup logic has completed.
 * Each call to deferReadiness must be matched by a call to advanceReadiness
 * or the application will never become ready and routing will not begin.
 * 
 * @return {void}
 */
Ember.Application.prototype.advanceReadiness = function() {};

/**
 * Use this to defer readiness until some condition is true.
 * This allows you to perform asynchronous setup logic and defer
 * booting your application until the setup has finished.
 * However, if the setup requires a loading UI, it might be better
 * to use the router for this purpose.
 * @return {void}
 */
Ember.Application.prototype.deferReadiness = function() {};

/**
 * defines an injection or typeInjection
 * 
 * @param {string} factoryNameOrType
 * @param {string} property
 * @param {string} injectionName
 * @return {void}
 */
Ember.Application.prototype.inject = function(factoryNameOrType, property, injectionName) {};

/**
 * This injects the test helpers into the window's scope. If a function of the
 * same name has already been defined it will be cached (so that it can be reset
 * if the helper is removed with `unregisterHelper` or `removeTestHelpers`).
 * Any callbacks registered with `onInjectHelpers` will be called once the
 * helpers have been injected.
 * 
 * @return {void}
 */
Ember.Application.prototype.injectTestHelpers = function() {};

/**
 * registers a factory for later injection
 * @param {string} fullName type:name (e.g., 'model:user')
 * @param {?} factory (e.g., App.Person)
 * 
 * @param {!Object=} options
 * @return {void}
 */
Ember.Application.prototype.register = function(fullName, factory, options) {};

/**
 * This removes all helpers that have been registered, and resets and functions
 * that were overridden by the helpers.
 * 
 * @return {void}
 */
Ember.Application.prototype.removeTestHelpers = function() {};

/**
 * Reset the application. This is typically used only in tests.
 * 
 * @return {void}
 */
Ember.Application.prototype.reset = function() {};

/**
 * This hook defers the readiness of the application, so that you can start
 * the app when your tests are ready to run. It also sets the router's
 * location to 'none', so that the window's location will not be modified
 * (preventing both accidental leaking of state between tests and interference
 * with your testing framework).
 * 
 * @return {void}
 */
Ember.Application.prototype.setupForTesting = function() {};
/**
 * @extends {Ember.Enumerable}
 * @constructor
 * @struct
 */
Ember.Array = function() {};
 /** @type {?} */
Ember.Array.prototype.map;
 /** @type {?} */
Ember.Array.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'@each' */
 /** @type {boolean} */
Ember.Array.prototype.Boolean;

/* TODO: PropertyDeclaration: Ember.'[]' */
 /** @type {?} */
Ember.Array.prototype.firstObject;
 /** @type {boolean} */
Ember.Array.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.Array.prototype.lastObject;
 /** @type {number} */
Ember.Array.prototype.length;

/**
 * @param {?} target
 * @param {?=} opts
 * @return {!Array<?>}
 */
Ember.Array.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Array.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Array.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.Array.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.Array.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Array.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.Array.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Array.prototype.contains = function(obj) {};

/**
 * @param {number|(number|!Ember.Enumerable)} start_or_removing
 * @param {(number|!Ember.Enumerable)} removing_or_adding
 * @param {(number|!Ember.Enumerable)=} adding
 * @return {?}
 */
Ember.Array.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {(number|!Ember.Enumerable)} removing
 * @param {(number|!Ember.Enumerable)} adding
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Array.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Array.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Array.prototype.everyProperty = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.Array.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Array.prototype.filterBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {?}
 */
Ember.Array.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.Array.prototype.findBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {?}
 */
Ember.Array.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Array.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.Array.prototype.indexOf = function(object, startAt) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.Array.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.Array.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Array.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.Array.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.Array.prototype.objectAt = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Ember.Array.prototype.objectsAt = function(args) {};

/**
 * @param {?} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.Array.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Array.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Array<?>}
 */
Ember.Array.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.Array.prototype.setEach = function(key, value) {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Ember.Array.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Array.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.Array.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.uniq = function() {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.Array.prototype.without = function(value) {};
/**
 * @extends {Ember.Object}
 * @extends {Ember.MutableArray}
 * @constructor
 * @struct
 */
Ember.ArrayProxy = function() {};
 /** @type {boolean} */
Ember.ArrayProxy.isClass;
 /** @type {boolean} */
Ember.ArrayProxy.isMethod;
 /** @type {?} */
Ember.ArrayProxy.prototype.map;
 /** @type {?} */
Ember.ArrayProxy.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */

/* TODO: PropertyDeclaration: Ember.'@each' */
 /** @type {boolean} */
Ember.ArrayProxy.prototype.Boolean;
 /** @type {?} */
Ember.ArrayProxy.prototype.firstObject;
 /** @type {boolean} */
Ember.ArrayProxy.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.ArrayProxy.prototype.lastObject;
 /** @type {number} */
Ember.ArrayProxy.prototype.length;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ArrayProxy.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ArrayProxy.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.ArrayProxy.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.ArrayProxy.metaForProperty = function(key) {};

/**
 * @param {?} target
 * @param {?=} opts
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.clear = function() {};

/**
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.contains = function(obj) {};

/**
 * @param {number|(number|!Ember.Enumerable)} start_or_removing
 * @param {(number|!Ember.Enumerable)} removing_or_adding
 * @param {(number|!Ember.Enumerable)=} adding
 * @return {?}
 */
Ember.ArrayProxy.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {(number|!Ember.Enumerable)} removing
 * @param {(number|!Ember.Enumerable)} adding
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.everyProperty = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.filterBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} $target
 * @return {?}
 */
Ember.ArrayProxy.prototype.find = function(callback, $target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.ArrayProxy.prototype.findBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {?}
 */
Ember.ArrayProxy.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.ArrayProxy.prototype.indexOf = function(object, startAt) {};

/**
 * @param {number} idx
 * @param {?} object
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.insertAt = function(idx, object) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.ArrayProxy.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.ArrayProxy.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.ArrayProxy.prototype.objectAt = function(idx) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.ArrayProxy.prototype.objectAtContent = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.objectsAt = function(args) {};

/**
 * @return {?}
 */
Ember.ArrayProxy.prototype.popObject = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Ember.ArrayProxy.prototype.pushObject = function(obj) {};

/**
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.pushObjects = function(args) {};

/**
 * @param {?} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.ArrayProxy.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {number} start
 * @param {number} len
 * @return {?}
 */
Ember.ArrayProxy.prototype.removeAt = function(start, len) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {?}
 */
Ember.ArrayProxy.prototype.replace = function(idx, amt, objects) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {void}
 */
Ember.ArrayProxy.prototype.replaceContent = function(idx, amt, objects) {};

/**
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.reverseObjects = function() {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.ArrayProxy.prototype.setEach = function(key, value) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.setObjects = function(objects) {};

/**
 * @return {?}
 */
Ember.ArrayProxy.prototype.shiftObject = function() {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.ArrayProxy.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.uniq = function() {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.ArrayProxy.prototype.unshiftObject = function(object) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.ArrayProxy.prototype.unshiftObjects = function(objects) {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.ArrayProxy.prototype.without = function(value) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.ArrayProxy.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.ArrayProxy.prototype.addObjects = function(objects) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.ArrayProxy.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.ArrayProxy.prototype.removeObjects = function(objects) {};
 /** @type {boolean} */
Ember.BOOTED;

/**
 * @constructor
 * @struct
 * @param {string} toPath
 * @param {string} fromPath
 */
Ember.Binding = function(toPath, fromPath) {};

/**
 * @param {?} obj
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.connect = function(obj) {};

/**
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.copy = function() {};

/**
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.disconnect = function() {};

/**
 * @param {string} path
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.from = function(path) {};

/**
 * @param {(string|!Array<?>)} path
 * @return {!Ember.Binding}
 */
Ember.Binding.prototype.to = function(path) {};

/**
 * @return {string}
 */
Ember.Binding.prototype.toString = function() {};
/**
 * @extends {Ember.Component}
 * @extends {Ember.TargetActionSupport}
 * @constructor
 * @struct
 */
Ember.Button = function() {};
 /** @type {boolean} */
Ember.Button.isClass;
 /** @type {boolean} */
Ember.Button.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Button.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Button.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Button.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Button.metaForProperty = function(key) {};

/**
 * @param {!Object} opts
 * @return {boolean}
 */
Ember.Button.prototype.triggerAction = function(opts) {};
/**
 * @extends {Ember.Component}
 * @constructor
 * @struct
 */
Ember.Checkbox = function() {};
 /** @type {boolean} */
Ember.Checkbox.isClass;
 /** @type {boolean} */
Ember.Checkbox.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Checkbox.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Checkbox.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Checkbox.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Checkbox.metaForProperty = function(key) {};
/**
 * @constructor
 * @struct
 */
Ember.Comparable = function() {};

/**
 * @param {?} a
 * @param {?} b
 * @return {number}
 */
Ember.Comparable.prototype.compare = function(a, b) {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.Component = function() {};
 /** @type {boolean} */
Ember.Component.isClass;
 /** @type {boolean} */
Ember.Component.isMethod;
 /** @type {!Ember.Controller} */
Ember.Component.prototype.targetObject;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Component.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Component.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Component.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Component.metaForProperty = function(key) {};

/**
 * @param {string} action
 * @param {?} context
 * @return {void}
 */
Ember.Component.prototype.sendAction = function(action, context) {};
/**
 * @constructor
 * @struct
 */
Ember.ComputedProperty = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.ComputedProperty.prototype.get = function(keyName) {};

/**
 * @param {!Object} meta
 * @return {!Ember.ComputedProperty}
 */
Ember.ComputedProperty.prototype.meta = function(meta) {};

/**
 * @param {...string} args
 * @return {!Ember.ComputedProperty}
 */
Ember.ComputedProperty.prototype.property = function(args) {};

/**
 * @return {!Ember.ComputedProperty}
 */
Ember.ComputedProperty.prototype.readOnly = function() {};

/**
 * @param {string} keyName
 * @param {?} newValue
 * @param {string} oldValue
 * @return {?}
 */
Ember.ComputedProperty.prototype.set = function(keyName, newValue, oldValue) {};

/**
 * @return {!Ember.ComputedProperty}
 */
Ember.ComputedProperty.prototype.volatile = function() {};

/**
 * @constructor
 * @struct
 * @param {!Ember.Container} parent
 */
Ember.Container = function(parent) {};
 /** @type {!Ember.Container} */
Ember.Container.prototype.parent;
 /** @type {!Array<?>} */
Ember.Container.prototype.children;
 /** @type {?} */
Ember.Container.prototype.owner;
 /** @type {?} */
Ember.Container.prototype.resolver;
 /** @type {!Ember.Registry} */
Ember.Container.prototype.registry;
 /** @type {!Object} */
Ember.Container.prototype.cache;
 /** @type {!Object} */
Ember.Container.prototype.typeInjections;
 /** @type {!Object} */
Ember.Container.prototype.injections;

/**
 * @return {?}
 */
Ember.Container.prototype.ownerInjection = function() {};

/**
 * @return {!Ember.Container}
 */
Ember.Container.prototype.child = function() {};

/**
 * @param {!Object} object
 * @param {string} key
 * @param {?} value
 * @return {void}
 */
Ember.Container.prototype.set = function(object, key, value) {};

/**
 * registers a factory for later injection
 * @param {string} fullName type:name (e.g., 'model:user')
 * @return {string}
 */
Ember.Container.prototype.describe = function(fullName) {};

/**
 * @param {?} factory
 * @param {string} fullName
 * @return {?}
 */
Ember.Container.prototype.makeToString = function(factory, fullName) {};

/**
 * @param {string} fullName
 * @param {!Object=} options
 * @return {?}
 */
Ember.Container.prototype.lookup = function(fullName, options) {};

/**
 * @param {string} fullName
 * @param {!Object=} options
 * @return {?}
 */
Ember.Container.prototype.lookupFactory = function(fullName, options) {};

/**
 * @return {void}
 */
Ember.Container.prototype.destroy = function() {};

/**
 * @return {void}
 */
Ember.Container.prototype.reset = function() {};
/**
 * @extends {Ember.Object}
 * @extends {Ember.ControllerMixin}
 * @constructor
 * @struct
 */
Ember.Controller = function() {};
 /** @type {!Object} */
Ember.Controller.prototype.controllers;
 /** @type {?} */
Ember.Controller.prototype.model;
 /** @type {!Array<string>} */
Ember.Controller.prototype.needs;
 /** @type {?} */
Ember.Controller.prototype.queryParams;
 /** @type {?} */
Ember.Controller.prototype.target;
 /** @type {?} */
Ember.Controller.prototype.actions;

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.Controller.prototype.replaceRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.Controller.prototype.transitionToRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.Controller.prototype.send = function(name, args) {};
/**
 * @extends {Ember.ActionHandlerMixin}
 * @constructor
 * @struct
 */
Ember.ControllerMixin = function() {};
 /** @type {!Object} */
Ember.ControllerMixin.prototype.controllers;
 /** @type {?} */
Ember.ControllerMixin.prototype.model;
 /** @type {!Array<string>} */
Ember.ControllerMixin.prototype.needs;
 /** @type {?} */
Ember.ControllerMixin.prototype.queryParams;
 /** @type {?} */
Ember.ControllerMixin.prototype.target;

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ControllerMixin.prototype.replaceRoute = function(name, args) {};

/**
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.ControllerMixin.prototype.transitionToRoute = function(name, args) {};
/**
 * @constructor
 * @struct
 */
Ember.Copyable = function() {};

/**
 * @param {boolean} deep
 * @return {!Ember.Copyable}
 */
Ember.Copyable.prototype.copy = function(deep) {};

/**
 * @return {!Ember.Copyable}
 */
Ember.Copyable.prototype.frozenCopy = function() {};
/**
 * @constructor
 * @struct
 */
Ember.CoreObject = function() {};
 /** @type {!Array<?>} */
Ember.CoreObject.prototype.concatenatedProperties;
 /** @type {boolean} */
Ember.CoreObject.prototype.isDestroyed;
 /** @type {boolean} */
Ember.CoreObject.prototype.isDestroying;
 /** @type {boolean} */
Ember.CoreObject.isClass;
 /** @type {boolean} */
Ember.CoreObject.isMethod;

/**
 * An overridable method called when objects are instantiated. By default,
 * does nothing unless it is overridden during class definition.
 * \@method init
 * 
 * @return {void}
 */
Ember.CoreObject.prototype.init = function() {};

/**
 * Destroys an object by setting the `isDestroyed` flag and removing its
 * metadata, which effectively destroys observers and bindings.
 * If you try to set a property on a destroyed object, an exception will be
 * raised.
 * Note that destruction is scheduled for the end of the run loop and does not
 * happen immediately.  It will set an isDestroying flag immediately.
 * \@method destroy
 * @return {!Ember.CoreObject}
 */
Ember.CoreObject.prototype.destroy = function() {};

/**
 * Override to implement teardown.
 * \@method willDestroy
 * @return {void}
 */
Ember.CoreObject.prototype.willDestroy = function() {};

/**
 * Returns a string representation which attempts to provide more information than Javascript's toString
 * typically does, in a generic way for all Ember objects (e.g., "<App.Person:ember1024>").
 * \@method toString
 * 
 * @return {string}
 */
Ember.CoreObject.prototype.toString = function() {};

/**
 * Creates a new subclass.
 * \@method extend
 * 
 * @template T
 * @param {?|!Ember.Mixin=} args_or_mixin1
 * @param {?|!Ember.Mixin=} args_or_mixin2
 * @param {?=} args
 * @return {T}
 */
Ember.CoreObject.extend = function(args_or_mixin1, args_or_mixin2, args) {};

/**
 * Creates a new subclass.
 * \@method extend
 * Non-static method because Ember classes aren't currently 'real' TypeScript classes.
 * 
 * @template T
 * @param {!Ember.Mixin=} mixin1
 * @param {!Ember.Mixin=} mixin2
 * @param {?=} args
 * @return {T}
 */
Ember.CoreObject.prototype.extend = function(mixin1, mixin2, args) {};

/**
 * Equivalent to doing extend(arguments).create(). If possible use the normal create method instead.
 * \@method createWithMixins
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.CoreObject.createWithMixins = function(args) {};

/**
 * Creates an instance of the class.
 * \@method create
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.CoreObject.create = function(args) {};

/**
 * Augments a constructor's prototype with additional properties and functions.
 * To add functions and properties to the constructor itself, see reopenClass.
 * \@method reopen
 * 
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.CoreObject.reopen = function(args) {};

/**
 * Augments a constructor's own properties and functions.
 * To add functions and properties to instances of a constructor by extending the
 * constructor's prototype see reopen.
 * \@method reopenClass
 * 
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.CoreObject.reopenClass = function(args) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.CoreObject.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.CoreObject.detectInstance = function(obj) {};

/**
 * Returns the original hash that was passed to meta().
 * \@method metaForProperty
 * @param {string} key {String} property name
 * 
 * @return {!Object}
 */
Ember.CoreObject.metaForProperty = function(key) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * \@method eachComputedProperty
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.CoreObject.eachComputedProperty = function(callback, binding) {};
/**
 * @constructor
 * @struct
 */
Ember.DAG = function() {};
 /** @type {!Array<?>} */
Ember.DAG.prototype.names;
 /** @type {!Object} */
Ember.DAG.prototype.vertices;

/**
 * @param {string} name
 * @return {?}
 */
Ember.DAG.prototype.add = function(name) {};

/**
 * @param {string} name
 * @param {?} value
 * @return {void}
 */
Ember.DAG.prototype.map = function(name, value) {};

/**
 * @param {string} fromName
 * @param {string} toName
 * @return {void}
 */
Ember.DAG.prototype.addEdge = function(fromName, toName) {};

/**
 * @param {?} fn
 * @return {void}
 */
Ember.DAG.prototype.topsort = function(fn) {};

/**
 * @param {string} name
 * @param {?} value
 * @param {?} before
 * @param {?} after
 * @return {void}
 */
Ember.DAG.prototype.addEdges = function(name, value, before, after) {};

/**
 * @param {string} name
 * @return {?}
 */
Ember.DEFAULT_GETTER_FUNCTION = function(name) {};
/**
 * @constructor
 * @struct
 */
Ember.DefaultResolver = function() {};
 /** @type {!Ember.Application} */
Ember.DefaultResolver.prototype.namespace;

/**
 * @param {string} fullName
 * @return {!Object}
 */
Ember.DefaultResolver.prototype.resolve = function(fullName) {};
/**
 * @constructor
 * @struct
 */
Ember.Descriptor = function() {};
/** @const */
Ember.ENV = {};
 /** @type {?} */
Ember.ENV.EXTEND_PROTOTYPES;
 /** @type {boolean} */
Ember.ENV.LOG_BINDINGS;
 /** @type {boolean} */
Ember.ENV.LOG_STACKTRACE_ON_DEPRECATION;
 /** @type {boolean} */
Ember.ENV.LOG_VERSION;
 /** @type {boolean} */
Ember.ENV.MODEL_FACTORY_INJECTIONS;
 /** @type {boolean} */
Ember.ENV.RAISE_ON_DEPRECATION;
/** @const */
Ember.EXTEND_PROTOTYPES = {};
 /** @type {boolean} */
Ember.EXTEND_PROTOTYPES.Array;
 /** @type {boolean} */
Ember.EXTEND_PROTOTYPES.Function;
 /** @type {boolean} */
Ember.EXTEND_PROTOTYPES.String;
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.EachProxy = function() {};
 /** @type {boolean} */
Ember.EachProxy.isClass;
 /** @type {boolean} */
Ember.EachProxy.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.EachProxy.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.EachProxy.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.EachProxy.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.EachProxy.metaForProperty = function(key) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Array<?>}
 */
Ember.EachProxy.prototype.unknownProperty = function(keyName, value) {};
/**
 * @constructor
 * @struct
 */
Ember.Enumerable = function() {};
 /** @type {?} */
Ember.Enumerable.prototype.map;
 /** @type {?} */
Ember.Enumerable.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */
 /** @type {?} */
Ember.Enumerable.prototype.firstObject;
 /** @type {boolean} */
Ember.Enumerable.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.Enumerable.prototype.lastObject;

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Enumerable.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Enumerable.prototype.anyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Enumerable.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Enumerable.prototype.contains = function(obj) {};

/**
 * @param {number|(number|!Ember.Enumerable)} start_or_removing
 * @param {(number|!Ember.Enumerable)} removing_or_adding
 * @param {(number|!Ember.Enumerable)=} adding
 * @return {?}
 */
Ember.Enumerable.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {(number|!Ember.Enumerable)} removing
 * @param {(number|!Ember.Enumerable)} adding
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Enumerable.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Enumerable.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.Enumerable.prototype.everyProperty = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.filterBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {?}
 */
Ember.Enumerable.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.Enumerable.prototype.findBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {?}
 */
Ember.Enumerable.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.getEach = function(key) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.invoke = function(methodName, args) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.Enumerable.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {?} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.Enumerable.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.Enumerable.prototype.setEach = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.Enumerable.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.Enumerable.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.uniq = function() {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.Enumerable.prototype.without = function(value) {};
 /** @type {?} */
Ember.Error;
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.EventDispatcher = function() {};
 /** @type {boolean} */
Ember.EventDispatcher.isClass;
 /** @type {boolean} */
Ember.EventDispatcher.isMethod;
 /** @type {!Object} */
Ember.EventDispatcher.prototype.events;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.EventDispatcher.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.EventDispatcher.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.EventDispatcher.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.EventDispatcher.metaForProperty = function(key) {};
/**
 * @constructor
 * @struct
 */
Ember.Evented = function() {};

/**
 * @param {string} name
 * @return {boolean}
 */
Ember.Evented.prototype.has = function(name) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {?} method
 * @return {!Ember.Evented}
 */
Ember.Evented.prototype.off = function(name, target, method) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {?} method
 * @return {!Ember.Evented}
 */
Ember.Evented.prototype.on = function(name, target, method) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {?} method
 * @return {!Ember.Evented}
 */
Ember.Evented.prototype.one = function(name, target, method) {};

/**
 * @param {string} name
 * @param {...string} args
 * @return {void}
 */
Ember.Evented.prototype.trigger = function(name, args) {};
 /** @type {string} */
Ember.FROZEN_ERROR;
/**
 * @constructor
 * @struct
 */
Ember.Freezable = function() {};
 /** @type {boolean} */
Ember.Freezable.prototype.isFrozen;

/**
 * @return {!Ember.Freezable}
 */
Ember.Freezable.prototype.freeze = function() {};
 /** @type {string} */
Ember.GUID_KEY;
/** @const */
Ember.Handlebars = {};

/**
 * @param {string|?} string_or_environment
 * @param {?=} options
 * @param {?=} context
 * @param {?=} asObject
 * @return {?}
 */
Ember.Handlebars.compile = function(string_or_environment, options, context, asObject) {};

/**
 * @param {string} string
 * @param {?} options
 * @return {void}
 */
Ember.Handlebars.precompile = function(string, options) {};
/**
 * @constructor
 * @struct
 */
Ember.Handlebars.Compiler = function() {};
/**
 * @constructor
 * @struct
 */
Ember.Handlebars.JavaScriptCompiler = function() {};

/**
 * @param {string} name
 * @param {?} str
 * @return {void}
 */
Ember.Handlebars.registerPartial = function(name, str) {};

/**
 * @return {?}
 */
Ember.Handlebars.K = function() {};

/**
 * @param {?} objec
 * @return {?}
 */
Ember.Handlebars.createFrame = function(objec) {};

/**
 * @param {string} message
 * @return {void}
 */
Ember.Handlebars.Exception = function(message) {};

/**
 * @constructor
 * @struct
 * @param {string} str
 */
Ember.Handlebars.SafeString = function(str) {};

/**
 * @return {string}
 */
Ember.Handlebars.SafeString.toString = function() {};

/**
 * @param {string} string
 * @return {?}
 */
Ember.Handlebars.parse = function(string) {};

/**
 * @param {?} ast
 * @return {void}
 */
Ember.Handlebars.print = function(ast) {};
 /** @type {{assert: function(?): void, debug: function(!Array<?>): void, error: function(!Array<?>): void, info: function(!Array<?>): void, log: function(!Array<?>): void, warn: function(!Array<?>): void}} */
Ember.Handlebars.logger;

/**
 * @param {string} level
 * @param {string} str
 * @return {void}
 */
Ember.Handlebars.log = function(level, str) {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.HashLocation = function() {};
 /** @type {boolean} */
Ember.HashLocation.isClass;
 /** @type {boolean} */
Ember.HashLocation.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.HashLocation.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.HashLocation.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.HashLocation.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.HashLocation.metaForProperty = function(key) {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.HistoryLocation = function() {};
 /** @type {boolean} */
Ember.HistoryLocation.isClass;
 /** @type {boolean} */
Ember.HistoryLocation.isMethod;
 /** @type {string} */
Ember.HistoryLocation.prototype.rootURL;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.HistoryLocation.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.HistoryLocation.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.HistoryLocation.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.HistoryLocation.metaForProperty = function(key) {};
 /** @type {!RegExp} */
Ember.IS_BINDING;
 /** @type {{controller: function(string): !Ember.Controller, service: function(string): !Ember.Service}} */
Ember.inject;
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.Helper = function() {};

/**
 * @param {function(?, ?): ?} h
 * @return {!Ember.Helper}
 */
Ember.Helper.helper = function(h) {};

/**
 * @param {!Array<?>} params
 * @param {?} hash
 * @return {?}
 */
Ember.Helper.prototype.compute = function(params, hash) {};

/**
 * @param {!Array<?>} params
 * @param {?} hash
 * @return {?}
 */
Ember.Helper.prototype.recompute = function(params, hash) {};
/**
 * @constructor
 * @struct
 */
Ember.Instrumentation = function() {};

/**
 * @param {?} obj
 * @param {...!Array<?>|string} list_or_args
 * @return {!Object}
 */
Ember.Instrumentation.prototype.getProperties = function(obj, list_or_args) {};

/**
 * @param {string} name
 * @param {?} payload
 * @param {?} callback
 * @param {?} binding
 * @return {void}
 */
Ember.Instrumentation.prototype.instrument = function(name, payload, callback, binding) {};

/**
 * @return {void}
 */
Ember.Instrumentation.prototype.reset = function() {};

/**
 * @param {string} pattern
 * @param {?} object
 * @return {void}
 */
Ember.Instrumentation.prototype.subscribe = function(pattern, object) {};

/**
 * @param {?} subscriber
 * @return {void}
 */
Ember.Instrumentation.prototype.unsubscribe = function(subscriber) {};
 /** @type {?} */
Ember.K;
 /** @type {boolean} */
Ember.LOG_BINDINGS;
 /** @type {boolean} */
Ember.LOG_STACKTRACE_ON_DEPRECATION;
 /** @type {boolean} */
Ember.LOG_VERSION;
/**
 * @constructor
 * @struct
 */
Ember.Location = function() {};

/**
 * @param {!Object=} options
 * @return {?}
 */
Ember.Location.prototype.create = function(options) {};

/**
 * @param {string} name
 * @param {?} implementation
 * @return {void}
 */
Ember.Location.prototype.registerImplementation = function(name, implementation) {};
 /** @type {{assert: function(?): void, debug: function(!Array<?>): void, error: function(!Array<?>): void, info: function(!Array<?>): void, log: function(!Array<?>): void, warn: function(!Array<?>): void}} */
Ember.Logger;

/**
 * @param {string} value
 * @return {void}
 */
Ember.MANDATORY_SETTER_FUNCTION = function(value) {};
 /** @type {string} */
Ember.META_KEY;
/**
 * @constructor
 * @struct
 */
Ember.Map = function() {};
 /** @type {number} */
Ember.Map.prototype.length;

/**
 * @return {!Ember.Map}
 */
Ember.Map.prototype.copy = function() {};

/**
 * @return {!Ember.Map}
 */
Ember.Map.create = function() {};

/**
 * @param {?} callback
 * @param {?} self
 * @return {void}
 */
Ember.Map.prototype.forEach = function(callback, self) {};

/**
 * @param {?} key
 * @return {?}
 */
Ember.Map.prototype.get = function(key) {};

/**
 * @param {?} key
 * @return {boolean}
 */
Ember.Map.prototype.has = function(key) {};

/**
 * @param {?} key
 * @param {?} value
 * @return {void}
 */
Ember.Map.prototype.set = function(key, value) {};
/**
 * @extends {Ember.Map}
 * @constructor
 * @struct
 */
Ember.MapWithDefault = function() {};

/**
 * @return {!Ember.MapWithDefault}
 */
Ember.MapWithDefault.prototype.copy = function() {};

/**
 * @return {!Ember.MapWithDefault}
 */
Ember.MapWithDefault.create = function() {};
/**
 * @constructor
 * @struct
 */
Ember.Mixin = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Ember.Mixin.prototype.apply = function(obj) {};

/**
 * Creates an instance of the class.
 * @template T
 * @param {...?} args
 * @return {T}
 */
Ember.Mixin.create = function(args) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Mixin.prototype.detect = function(obj) {};

/**
 * @template T
 * @param {!Object=} args
 * @return {T}
 */
Ember.Mixin.prototype.reopen = function(args) {};
/**
 * @extends {Ember.Array}
 * @extends {Ember.MutableEnumberable}
 * @constructor
 * @struct
 */
Ember.MutableArray = function() {};
 /** @type {?} */
Ember.MutableArray.prototype.map;
 /** @type {?} */
Ember.MutableArray.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */

/* TODO: PropertyDeclaration: Ember.'@each' */
 /** @type {boolean} */
Ember.MutableArray.prototype.Boolean;
 /** @type {?} */
Ember.MutableArray.prototype.firstObject;
 /** @type {boolean} */
Ember.MutableArray.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.MutableArray.prototype.lastObject;
 /** @type {number} */
Ember.MutableArray.prototype.length;

/**
 * @param {?} target
 * @param {?=} opts
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableArray.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableArray.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableArray.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.clear = function() {};

/**
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.MutableArray.prototype.contains = function(obj) {};

/**
 * @param {number|(number|!Ember.Enumerable)} start_or_removing
 * @param {(number|!Ember.Enumerable)} removing_or_adding
 * @param {(number|!Ember.Enumerable)=} adding
 * @return {?}
 */
Ember.MutableArray.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {(number|!Ember.Enumerable)} removing
 * @param {(number|!Ember.Enumerable)} adding
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableArray.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableArray.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableArray.prototype.everyProperty = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.filterBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {?}
 */
Ember.MutableArray.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.MutableArray.prototype.findBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {?}
 */
Ember.MutableArray.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.MutableArray.prototype.indexOf = function(object, startAt) {};

/**
 * @param {number} idx
 * @param {?} object
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.insertAt = function(idx, object) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.MutableArray.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.MutableArray.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.MutableArray.prototype.objectAt = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.objectsAt = function(args) {};

/**
 * @return {?}
 */
Ember.MutableArray.prototype.popObject = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Ember.MutableArray.prototype.pushObject = function(obj) {};

/**
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.pushObjects = function(args) {};

/**
 * @param {?} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.MutableArray.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {number} start
 * @param {number} len
 * @return {?}
 */
Ember.MutableArray.prototype.removeAt = function(start, len) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {?}
 */
Ember.MutableArray.prototype.replace = function(idx, amt, objects) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.reverseObjects = function() {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.MutableArray.prototype.setEach = function(key, value) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.setObjects = function(objects) {};

/**
 * @return {?}
 */
Ember.MutableArray.prototype.shiftObject = function() {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableArray.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.uniq = function() {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableArray.prototype.unshiftObject = function(object) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.MutableArray.prototype.unshiftObjects = function(objects) {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.MutableArray.prototype.without = function(value) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableArray.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.MutableArray.prototype.addObjects = function(objects) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableArray.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.MutableArray.prototype.removeObjects = function(objects) {};
/**
 * @extends {Ember.Enumerable}
 * @constructor
 * @struct
 */
Ember.MutableEnumberable = function() {};
 /** @type {?} */
Ember.MutableEnumberable.prototype.map;
 /** @type {?} */
Ember.MutableEnumberable.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */
 /** @type {?} */
Ember.MutableEnumberable.prototype.firstObject;
 /** @type {boolean} */
Ember.MutableEnumberable.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.MutableEnumberable.prototype.lastObject;

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableEnumberable.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.MutableEnumberable.prototype.addObjects = function(objects) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.anyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.contains = function(obj) {};

/**
 * @param {number|(number|!Ember.Enumerable)} start_or_removing
 * @param {(number|!Ember.Enumerable)} removing_or_adding
 * @param {(number|!Ember.Enumerable)=} adding
 * @return {?}
 */
Ember.MutableEnumberable.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {(number|!Ember.Enumerable)} removing
 * @param {(number|!Ember.Enumerable)} adding
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.everyProperty = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.filterBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {?}
 */
Ember.MutableEnumberable.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.MutableEnumberable.prototype.findBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {?}
 */
Ember.MutableEnumberable.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.getEach = function(key) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.invoke = function(methodName, args) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.MutableEnumberable.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {?} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.MutableEnumberable.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.MutableEnumberable.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.MutableEnumberable.prototype.removeObjects = function(objects) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.MutableEnumberable.prototype.setEach = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.MutableEnumberable.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.MutableEnumberable.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.uniq = function() {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.MutableEnumberable.prototype.without = function(value) {};
 /** @type {string} */
Ember.NAME_KEY;
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.Namespace = function() {};
 /** @type {boolean} */
Ember.Namespace.isClass;
 /** @type {boolean} */
Ember.Namespace.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Namespace.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Namespace.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Namespace.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Namespace.metaForProperty = function(key) {};

/**
 * @constructor
 * @struct
 * @param {!Array<?>} arr
 */
Ember.NativeArray = function(arr) {};
 /** @type {?} */
Ember.NativeArray.prototype.map;
 /** @type {?} */
Ember.NativeArray.prototype.reject;

/* TODO: PropertyDeclaration: Ember.'[]' */

/* TODO: PropertyDeclaration: Ember.'@each' */
 /** @type {boolean} */
Ember.NativeArray.prototype.Boolean;
 /** @type {?} */
Ember.NativeArray.prototype.firstObject;
 /** @type {boolean} */
Ember.NativeArray.prototype.hasEnumerableObservers;
 /** @type {?} */
Ember.NativeArray.prototype.lastObject;
 /** @type {number} */
Ember.NativeArray.prototype.length;
 /** @type {?} */
Ember.NativeArray.prototype.addObserver;

/**
 * @return {void}
 */
Ember.NativeArray.activate = function() {};

/**
 * @param {?} target
 * @param {?=} opts
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.addArrayObserver = function(target, opts) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.addEnumerableObserver = function(target, opts) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.NativeArray.prototype.any = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.NativeArray.prototype.anyBy = function(key, value) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.arrayContentDidChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {number} startIdx
 * @param {number} removeAmt
 * @param {number} addAmt
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.arrayContentWillChange = function(startIdx, removeAmt, addAmt) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {boolean}
 */
Ember.NativeArray.prototype.someProperty = function(key, value) {};

/**
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.clear = function() {};

/**
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.compact = function() {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.NativeArray.prototype.contains = function(obj) {};

/**
 * @param {number|(number|!Ember.Enumerable)} start_or_removing
 * @param {(number|!Ember.Enumerable)} removing_or_adding
 * @param {(number|!Ember.Enumerable)=} adding
 * @return {?}
 */
Ember.NativeArray.prototype.enumerableContentDidChange = function(start_or_removing, removing_or_adding, adding) {};

/**
 * @param {(number|!Ember.Enumerable)} removing
 * @param {(number|!Ember.Enumerable)} adding
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.enumerableContentWillChange = function(removing, adding) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.NativeArray.prototype.every = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {boolean}
 */
Ember.NativeArray.prototype.everyBy = function(key, value) {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {boolean}
 */
Ember.NativeArray.prototype.everyProperty = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.filter = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.filterBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?} target
 * @return {?}
 */
Ember.NativeArray.prototype.find = function(callback, target) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {?}
 */
Ember.NativeArray.prototype.findBy = function(key, value) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {?}
 */
Ember.NativeArray.prototype.forEach = function(callback, target) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.getEach = function(key) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.NativeArray.prototype.indexOf = function(object, startAt) {};

/**
 * @param {number} idx
 * @param {?} object
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.insertAt = function(idx, object) {};

/**
 * @param {string} methodName
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.invoke = function(methodName, args) {};

/**
 * @param {?} object
 * @param {number} startAt
 * @return {number}
 */
Ember.NativeArray.prototype.lastIndexOf = function(object, startAt) {};

/**
 * @param {string} key
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.mapBy = function(key) {};

/**
 * @param {number} index
 * @param {?} previousObject
 * @param {?} context
 * @return {?}
 */
Ember.NativeArray.prototype.nextObject = function(index, previousObject, context) {};

/**
 * @param {number} idx
 * @return {?}
 */
Ember.NativeArray.prototype.objectAt = function(idx) {};

/**
 * @param {...number} args
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.objectsAt = function(args) {};

/**
 * @return {?}
 */
Ember.NativeArray.prototype.popObject = function() {};

/**
 * @param {?} obj
 * @return {?}
 */
Ember.NativeArray.prototype.pushObject = function(obj) {};

/**
 * @param {...?} args
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.pushObjects = function(args) {};

/**
 * @param {?} callback
 * @param {?} initialValue
 * @param {string} reducerProperty
 * @return {?}
 */
Ember.NativeArray.prototype.reduce = function(callback, initialValue, reducerProperty) {};

/**
 * @param {string} key
 * @param {string=} value
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.rejectBy = function(key, value) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.removeArrayObserver = function(target, opts) {};

/**
 * @param {number} start
 * @param {number} len
 * @return {?}
 */
Ember.NativeArray.prototype.removeAt = function(start, len) {};

/**
 * @param {?} target
 * @param {?} opts
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.removeEnumerableObserver = function(target, opts) {};

/**
 * @param {number} idx
 * @param {number} amt
 * @param {!Array<?>} objects
 * @return {?}
 */
Ember.NativeArray.prototype.replace = function(idx, amt, objects) {};

/**
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.reverseObjects = function() {};

/**
 * @param {string} key
 * @param {?=} value
 * @return {?}
 */
Ember.NativeArray.prototype.setEach = function(key, value) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.setObjects = function(objects) {};

/**
 * @return {?}
 */
Ember.NativeArray.prototype.shiftObject = function() {};

/**
 * @param {number=} beginIndex
 * @param {number=} endIndex
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.slice = function(beginIndex, endIndex) {};

/**
 * @param {?} callback
 * @param {?=} target
 * @return {boolean}
 */
Ember.NativeArray.prototype.some = function(callback, target) {};

/**
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.toArray = function() {};

/**
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.uniq = function() {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.NativeArray.prototype.unshiftObject = function(object) {};

/**
 * @param {!Array<?>} objects
 * @return {!Array<?>}
 */
Ember.NativeArray.prototype.unshiftObjects = function(objects) {};

/**
 * @param {?} value
 * @return {!Ember.Enumerable}
 */
Ember.NativeArray.prototype.without = function(value) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.NativeArray.prototype.addObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.NativeArray.prototype.addObjects = function(objects) {};

/**
 * @param {?} object
 * @return {?}
 */
Ember.NativeArray.prototype.removeObject = function(object) {};

/**
 * @param {!Ember.Enumerable} objects
 * @return {!Ember.MutableEnumberable}
 */
Ember.NativeArray.prototype.removeObjects = function(objects) {};

/**
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.beginPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.NativeArray.prototype.cacheFor = function(keyName) {};

/**
 * @param {string} keyName
 * @param {number=} decrement
 * @return {number}
 */
Ember.NativeArray.prototype.decrementProperty = function(keyName, decrement) {};

/**
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.endPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.NativeArray.prototype.get = function(keyName) {};

/**
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Ember.NativeArray.prototype.getProperties = function(args_or_keys) {};

/**
 * @param {string} keyName
 * @param {?} defaultValue
 * @return {?}
 */
Ember.NativeArray.prototype.getWithDefault = function(keyName, defaultValue) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Ember.NativeArray.prototype.hasObserverFor = function(key) {};

/**
 * @param {string} keyName
 * @param {number=} increment
 * @return {number}
 */
Ember.NativeArray.prototype.incrementProperty = function(keyName, increment) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.notifyPropertyChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.propertyDidChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.propertyWillChange = function(keyName) {};

/**
 * @param {string} key
 * @param {?} target
 * @param {(string|?)} method
 * @return {void}
 */
Ember.NativeArray.prototype.removeObserver = function(key, target, method) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.set = function(keyName, value) {};

/**
 * @param {!Object} hash
 * @return {!Ember.Observable}
 */
Ember.NativeArray.prototype.setProperties = function(hash) {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.NativeArray.prototype.toggleProperty = function(keyName) {};

/**
 * @param {boolean} deep
 * @return {!Ember.Copyable}
 */
Ember.NativeArray.prototype.copy = function(deep) {};

/**
 * @return {!Ember.Copyable}
 */
Ember.NativeArray.prototype.frozenCopy = function() {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.NoneLocation = function() {};
 /** @type {boolean} */
Ember.NoneLocation.isClass;
 /** @type {boolean} */
Ember.NoneLocation.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.NoneLocation.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.NoneLocation.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.NoneLocation.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.NoneLocation.metaForProperty = function(key) {};
 /** @type {!Array<string>} */
Ember.ORDER_DEFINITION;
/**
 * @extends {Ember.CoreObject}
 * @extends {Ember.Observable}
 * @constructor
 * @struct
 */
Ember.Object = function() {};
 /** @type {?} */
Ember.Object.prototype.addObserver;

/**
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.beginPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Object.prototype.cacheFor = function(keyName) {};

/**
 * @param {string} keyName
 * @param {number=} decrement
 * @return {number}
 */
Ember.Object.prototype.decrementProperty = function(keyName, decrement) {};

/**
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.endPropertyChanges = function() {};

/**
 * Retrieves the value of a property from the object
 * Retrieves the value of a property from the object
 * @template T
 * @param {string} keyName
 * @return {?|T}
 */
Ember.Object.prototype.get = function(keyName) {};

/**
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Ember.Object.prototype.getProperties = function(args_or_keys) {};

/**
 * @param {string} keyName
 * @param {?} defaultValue
 * @return {?}
 */
Ember.Object.prototype.getWithDefault = function(keyName, defaultValue) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Ember.Object.prototype.hasObserverFor = function(key) {};

/**
 * @param {string} keyName
 * @param {number=} increment
 * @return {number}
 */
Ember.Object.prototype.incrementProperty = function(keyName, increment) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.notifyPropertyChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.propertyDidChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.propertyWillChange = function(keyName) {};

/**
 * @param {string} key
 * @param {?} target
 * @param {(string|?)} method
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.removeObserver = function(key, target, method) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.set = function(keyName, value) {};

/**
 * @param {!Object} hash
 * @return {!Ember.Observable}
 */
Ember.Object.prototype.setProperties = function(hash) {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Object.prototype.toggleProperty = function(keyName) {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.ObjectProxy = function() {};
 /** @type {boolean} */
Ember.ObjectProxy.isClass;
 /** @type {boolean} */
Ember.ObjectProxy.isMethod;
 /** @type {!Ember.Object} */
Ember.ObjectProxy.prototype.content;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ObjectProxy.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.ObjectProxy.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.ObjectProxy.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.ObjectProxy.metaForProperty = function(key) {};
/**
 * @constructor
 * @struct
 */
Ember.Observable = function() {};
 /** @type {?} */
Ember.Observable.prototype.addObserver;

/**
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.beginPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Observable.prototype.cacheFor = function(keyName) {};

/**
 * @param {string} keyName
 * @param {number=} decrement
 * @return {number}
 */
Ember.Observable.prototype.decrementProperty = function(keyName, decrement) {};

/**
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.endPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Observable.prototype.get = function(keyName) {};

/**
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Ember.Observable.prototype.getProperties = function(args_or_keys) {};

/**
 * @param {string} keyName
 * @param {?} defaultValue
 * @return {?}
 */
Ember.Observable.prototype.getWithDefault = function(keyName, defaultValue) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Ember.Observable.prototype.hasObserverFor = function(key) {};

/**
 * @param {string} keyName
 * @param {number=} increment
 * @return {number}
 */
Ember.Observable.prototype.incrementProperty = function(keyName, increment) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.notifyPropertyChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.propertyDidChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.propertyWillChange = function(keyName) {};

/**
 * @param {string} key
 * @param {!Object} target
 * @param {(string|?)} method
 * @return {void}
 */
Ember.Observable.prototype.removeObserver = function(key, target, method) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.set = function(keyName, value) {};

/**
 * @param {!Object} hash
 * @return {!Ember.Observable}
 */
Ember.Observable.prototype.setProperties = function(hash) {};

/**
 * Set the value of a boolean property to the opposite of its current value.
 * @param {string} keyName
 * @return {boolean}
 */
Ember.Observable.prototype.toggleProperty = function(keyName) {};
/**
 * @constructor
 * @struct
 */
Ember.OrderedSet = function() {};

/**
 * @param {?} obj
 * @return {void}
 */
Ember.OrderedSet.prototype.add = function(obj) {};

/**
 * @return {void}
 */
Ember.OrderedSet.prototype.clear = function() {};

/**
 * @return {!Ember.OrderedSet}
 */
Ember.OrderedSet.prototype.copy = function() {};

/**
 * @return {!Ember.OrderedSet}
 */
Ember.OrderedSet.create = function() {};

/**
 * @param {?} fn
 * @param {?} self
 * @return {void}
 */
Ember.OrderedSet.prototype.forEach = function(fn, self) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.OrderedSet.prototype.has = function(obj) {};

/**
 * @return {boolean}
 */
Ember.OrderedSet.prototype.isEmpty = function() {};

/**
 * @return {!Array<?>}
 */
Ember.OrderedSet.prototype.toArray = function() {};

/**
 * @constructor
 * @struct
 * @param {?} options
 */
Ember.Registry = function(options) {};
 /** @type {function(?, string, ?): ?} */
Ember.Registry.set;
 /** @type {?} */
Ember.RSVP;
/**
 * @extends {Ember.Object}
 * @extends {Ember.ActionHandlerMixin}
 * @extends {Ember.Evented}
 * @constructor
 * @struct
 */
Ember.Route = function() {};
 /** @type {boolean} */
Ember.Route.isClass;
 /** @type {boolean} */
Ember.Route.isMethod;
 /** @type {?} */
Ember.Route.prototype.activate;
 /** @type {!Ember.Controller} */
Ember.Route.prototype.controller;
 /** @type {string} */
Ember.Route.prototype.controllerName;
 /** @type {?} */
Ember.Route.prototype.deactivate;
 /** @type {!Object} */
Ember.Route.prototype.queryParams;
 /** @type {string} */
Ember.Route.prototype.templateName;
 /** @type {string} */
Ember.Route.prototype.viewName;
 /** @type {?} */
Ember.Route.prototype.actions;

/**
 * This hook is called after this route's model has resolved.
 * It follows identical async/promise semantics to `beforeModel`
 * but is provided the route's resolved model in addition to
 * the `transition`, and is therefore suited to performing
 * logic that can only take place after the model has already
 * resolved.
 * Refer to documentation for `beforeModel` for a description
 * of transition-pausing semantics when a promise is returned
 * from this hook.
 * \@method afterModel
 * or its resolved value if it was a promise
 * a promise, the transition will pause until the transition
 * resolves. Otherwise, non-promise return values are not
 * utilized in any way.
 * @param {?} resolvedModel
 * @param {!EmberStates.Transition} transition
 * @return {!RSVP.Promise<?, ?>}
 */
Ember.Route.prototype.afterModel = function(resolvedModel, transition) {};

/**
 * This hook is the first of the route entry validation hooks
 * called when an attempt is made to transition into a route
 * or one of its children. It is called before `model` and
 * `afterModel`, and is appropriate for cases when:
 * 1) A decision can be made to redirect elsewhere without
 * needing to resolve the model first.
 * 2) Any async operations need to occur first before the
 * model is attempted to be resolved.
 * This hook is provided the current `transition` attempt
 * as a parameter, which can be used to `.abort()` the transition,
 * save it for a later `.retry()`, or retrieve values set
 * on it from a previous hook. You can also just call
 * `this.transitionTo` to another route to implicitly
 * abort the `transition`.
 * You can return a promise from this hook to pause the
 * transition until the promise resolves (or rejects). This could
 * be useful, for instance, for retrieving async code from
 * the server that is required to enter a route.
 * \@method beforeModel
 * a promise, the transition will pause until the transition
 * resolves. Otherwise, non-promise return values are not
 * utilized in any way.
 * @param {!EmberStates.Transition} transition
 * @return {!RSVP.Promise<?, ?>}
 */
Ember.Route.prototype.beforeModel = function(transition) {};

/**
 * Returns the controller for a particular route or name.
 * The controller instance must already have been created, either through entering the
 * associated route or using `generateController`.
 * \@method controllerFor
 * @param {string} name
 * @return {!Ember.Controller}
 */
Ember.Route.prototype.controllerFor = function(name) {};

/**
 * Deserializes value of the query parameter based on defaultValueType
 * \@method deserializeQueryParam
 * @param {?} value
 * @param {string} urlKey
 * @param {string} defaultValueType
 * @return {?}
 */
Ember.Route.prototype.deserializeQueryParam = function(value, urlKey, defaultValueType) {};

/**
 * Disconnects a view that has been rendered into an outlet.
 * You may pass any or all of the following options to `disconnectOutlet`:
 * `outlet`: the name of the outlet to clear (default: 'main')
 * `parentView`: the name of the view containing the outlet to clear
 * (default: the view rendered by the parent route)
 * \@method disconnectOutlet
 * @param {(string|?)} options
 * @return {void}
 */
Ember.Route.prototype.disconnectOutlet = function(options) {};

/**
 * \@method findModel
 * @param {string} type
 * @param {?} value
 * @return {?}
 */
Ember.Route.prototype.findModel = function(type, value) {};

/**
 * Generates a controller for a route.
 * If the optional model is passed then the controller type is determined automatically,
 * e.g., an ArrayController for arrays.
 * \@method generateController
 * @param {string} name
 * @param {!Object} model
 * @return {!Ember.Controller}
 */
Ember.Route.prototype.generateController = function(name, model) {};

/**
 * Perform a synchronous transition into another route without attempting
 * to resolve promises, update the URL, or abort any currently active
 * asynchronous transitions (i.e. regular transitions caused by
 * `transitionTo` or URL changes).
 * This method is handy for performing intermediate transitions on the
 * way to a final destination route, and is called internally by the
 * default implementations of the `error` and `loading` handlers.
 * \@method intermediateTransitionTo
 * to the route.
 * \@since 1.2.0
 * @param {string} name
 * @param {...?} models
 * @return {void}
 */
Ember.Route.prototype.intermediateTransitionTo = function(name, models) {};

/**
 * A hook you can implement to convert the URL into the model for
 * this route.
 * \@method model
 * a promise is returned, the transition will pause until
 * the promise resolves, and the resolved value of the promise
 * will be used as the model for this route.
 * @param {!Object} params
 * @param {!EmberStates.Transition} transition
 * @return {?}
 */
Ember.Route.prototype.model = function(params, transition) {};

/**
 * Returns the model of a parent (or any ancestor) route
 * in a route hierarchy.  During a transition, all routes
 * must resolve a model object, and if a route
 * needs access to a parent route's model in order to
 * resolve a model (or just reuse the model from a parent),
 * it can call `this.modelFor(theNameOfParentRoute)` to
 * retrieve it.
 * \@method modelFor
 * @param {string} name
 * @return {!Object}
 */
Ember.Route.prototype.modelFor = function(name) {};

/**
 * Retrieves parameters, for current route using the state.params
 * variable and getQueryParamsFor, using the supplied routeName.
 * \@method paramsFor
 * @param {string} name
 * @return {?}
 */
Ember.Route.prototype.paramsFor = function(name) {};

/**
 * Refresh the model on this route and any child routes, firing the
 * `beforeModel`, `model`, and `afterModel` hooks in a similar fashion
 * to how routes are entered when transitioning in from other route.
 * The current route params (e.g. `article_id`) will be passed in
 * to the respective model hooks, and if a different model is returned,
 * `setupController` and associated route hooks will re-fire as well.
 * An example usage of this method is re-querying the server for the
 * latest information using the same parameters as when the route
 * was first entered.
 * Note that this will cause `model` hooks to fire even on routes
 * that were provided a model object when the route was initially
 * entered.
 * \@method refresh
 * attempted transition
 * \@since 1.4.0
 * @return {!EmberStates.Transition}
 */
Ember.Route.prototype.redirect = function() {};

/**
 * Refresh the model on this route and any child routes, firing the
 * `beforeModel`, `model`, and `afterModel` hooks in a similar fashion
 * to how routes are entered when transitioning in from other route.
 * The current route params (e.g. `article_id`) will be passed in
 * to the respective model hooks, and if a different model is returned,
 * `setupController` and associated route hooks will re-fire as well.
 * An example usage of this method is re-querying the server for the
 * latest information using the same parameters as when the route
 * was first entered.
 * Note that this will cause `model` hooks to fire even on routes
 * that were provided a model object when the route was initially
 * entered.
 * \@method refresh
 * attempted transition
 * \@since 1.4.0
 * @return {!EmberStates.Transition}
 */
Ember.Route.prototype.refresh = function() {};

/**
 * `render` is used to render a template into a region of another template
 * (indicated by an `{{outlet}}`). `render` is used both during the entry
 * phase of routing (via the `renderTemplate` hook) and later in response to
 * user interaction.
 * \@method render
 * referenced by name. Defaults to the parent template
 * Defaults to 'main'
 * referenced by name or as a controller instance. Defaults to the Route's paired controller
 * Defaults to the return value of the Route's model hook
 * @param {string} name
 * @param {?=} options
 * @return {void}
 */
Ember.Route.prototype.render = function(name, options) {};

/**
 * A hook you can use to render the template for the current route.
 * This method is called with the controller for the current route and the
 * model supplied by the `model` hook. By default, it renders the route's
 * template, configured with the controller for the route.
 * This method can be overridden to set up and render additional or
 * alternative templates.
 * \@method renderTemplate
 * @param {!Ember.Controller} controller
 * @param {!Object} model
 * @return {void}
 */
Ember.Route.prototype.renderTemplate = function(controller, model) {};

/**
 * Transition into another route while replacing the current URL, if possible.
 * This will replace the current history entry instead of adding a new one.
 * Beside that, it is identical to `transitionTo` in all other respects. See
 * 'transitionTo' for additional information regarding multiple models.
 * \@method replaceWith
 * transitioning to the route.
 * attempted transition
 * @param {string} name
 * @param {...?} models
 * @return {void}
 */
Ember.Route.prototype.replaceWith = function(name, models) {};

/**
 * A hook you can use to reset controller values either when the model
 * changes or the route is exiting.
 * \@method resetController
 * \@since 1.7.0
 * @param {!Ember.Controller} controller
 * @param {boolean} isExiting
 * @param {?} transition
 * @return {void}
 */
Ember.Route.prototype.resetController = function(controller, isExiting, transition) {};

/**
 * A hook you can implement to convert the route's model into parameters
 * for the URL.
 * The default `serialize` method will insert the model's `id` into the
 * route's dynamic segment (in this case, `:post_id`) if the segment contains '_id'.
 * If the route has multiple dynamic segments or does not contain '_id', `serialize`
 * will return `Ember.getProperties(model, params)`
 * This method is called when `transitionTo` is called with a context
 * in order to populate the URL.
 * \@method serialize
 * route (in the example, `['post_id']`.
 * @param {!Object} model
 * @param {!Array<string>} params
 * @return {string}
 */
Ember.Route.prototype.serialize = function(model, params) {};

/**
 * Serializes value of the query parameter based on defaultValueType
 * \@method serializeQueryParam
 * @param {?} value
 * @param {string} urlKey
 * @param {string} defaultValueType
 * @return {string}
 */
Ember.Route.prototype.serializeQueryParam = function(value, urlKey, defaultValueType) {};

/**
 * Serializes the query parameter key
 * \@method serializeQueryParamKey
 * @param {string} controllerPropertyName
 * @return {string}
 */
Ember.Route.prototype.serializeQueryParamKey = function(controllerPropertyName) {};

/**
 * A hook you can use to setup the controller for the current route.
 * This method is called with the controller for the current route and the
 * model supplied by the `model` hook.
 * By default, the `setupController` hook sets the `model` property of
 * the controller to the `model`.
 * If you implement the `setupController` hook in your Route, it will
 * prevent this default behavior. If you want to preserve that behavior
 * when implementing your `setupController` function, make sure to call
 * `_super`
 * \@method setupController
 * @param {!Ember.Controller} controller
 * @param {!Object} model
 * @return {void}
 */
Ember.Route.prototype.setupController = function(controller, model) {};

/**
 * Store property provides a hook for data persistence libraries to inject themselves.
 * By default, this store property provides the exact same functionality previously
 * in the model hook.
 * Currently, the required interface is:
 * `store.find(modelName, findArguments)`
 * \@method store
 * @param {?} store
 * @return {?}
 */
Ember.Route.prototype.store = function(store) {};

/**
 * Transition the application into another route. The route may
 * be either a single route or route path
 * \@method transitionTo
 * transitioning to the route.
 * containing a mapping of query parameters
 * attempted transition
 * @param {string} name
 * @param {...?} object
 * @return {!EmberStates.Transition}
 */
Ember.Route.prototype.transitionTo = function(name, object) {};

/**
 * Sends an action to the router, which will delegate it to the currently
 * active route hierarchy per the bubbling rules explained under actions
 * \@method send
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Ember.Route.prototype.send = function(name, args) {};

/**
 * Subscribes to a named event with given function.
 * An optional target can be passed in as the 2nd argument that will
 * be set as the "this" for the callback. This is a good way to give your
 * function access to the object triggering the event. When the target
 * parameter is used the callback becomes the third argument.
 * \@method on
 * @param {string} name
 * @param {?} target
 * @param {?} method
 * @return {!Ember.Evented} this
 */
Ember.Route.prototype.on = function(name, target, method) {};

/**
 * Subscribes a function to a named event and then cancels the subscription
 * after the first time the event is triggered. It is good to use ``one`` when
 * you only care about the first time an event has taken place.
 * This function takes an optional 2nd argument that will become the "this"
 * value for the callback. If this argument is passed then the 3rd argument
 * becomes the function.
 * \@method one
 * @param {string} name
 * @param {?} target
 * @param {?} method
 * @return {!Ember.Evented} this
 */
Ember.Route.prototype.one = function(name, target, method) {};

/**
 * Triggers a named event for the object. Any additional arguments
 * will be passed as parameters to the functions that are subscribed to the
 * event.
 * \@method trigger
 * @param {string} name
 * @param {...string} args
 * @return {void}
 */
Ember.Route.prototype.trigger = function(name, args) {};

/**
 * Cancels subscription for given name, target, and method.
 * \@method off
 * @param {string} name
 * @param {?} target
 * @param {?} method
 * @return {!Ember.Evented} this
 */
Ember.Route.prototype.off = function(name, target, method) {};

/**
 * Checks to see if object has any subscriptions for named event.
 * \@method has
 * @param {string} name
 * @return {boolean}
 */
Ember.Route.prototype.has = function(name) {};
/**
 * @extends {Ember.Object}
 * @constructor
 * @struct
 */
Ember.Router = function() {};
 /** @type {boolean} */
Ember.Router.isClass;
 /** @type {boolean} */
Ember.Router.isMethod;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Router.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.Router.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.Router.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.Router.metaForProperty = function(key) {};

/**
 * @param {?} callback
 * @return {!Ember.Router}
 */
Ember.Router.prototype.map = function(callback) {};
/**
 * @constructor
 * @struct
 */
Ember.RouterDSL = function() {};
 /** @type {boolean} */
Ember.RouterDSL.prototype.explicitIndex;
 /** @type {!Ember.Router} */
Ember.RouterDSL.prototype.router;
 /** @type {?} */
Ember.RouterDSL.prototype.options;

/**
 * @param {string} name
 * @param {!Object|?=} options_or_callback
 * @param {?=} callback
 * @return {void}
 */
Ember.RouterDSL.prototype.resource = function(name, options_or_callback, callback) {};

/**
 * @param {string} name
 * @param {!Object=} options
 * @return {void}
 */
Ember.RouterDSL.prototype.route = function(name, options) {};
/**
 * @extends {Ember.CoreObject}
 * @extends {Ember.Observable}
 * @constructor
 * @struct
 */
Ember.Service = function() {};
 /** @type {?} */
Ember.Service.prototype.addObserver;

/**
 * @return {!Ember.Observable}
 */
Ember.Service.prototype.beginPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Service.prototype.cacheFor = function(keyName) {};

/**
 * @param {string} keyName
 * @param {number=} decrement
 * @return {number}
 */
Ember.Service.prototype.decrementProperty = function(keyName, decrement) {};

/**
 * @return {!Ember.Observable}
 */
Ember.Service.prototype.endPropertyChanges = function() {};

/**
 * @param {string} keyName
 * @return {?}
 */
Ember.Service.prototype.get = function(keyName) {};

/**
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Ember.Service.prototype.getProperties = function(args_or_keys) {};

/**
 * @param {string} keyName
 * @param {?} defaultValue
 * @return {?}
 */
Ember.Service.prototype.getWithDefault = function(keyName, defaultValue) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Ember.Service.prototype.hasObserverFor = function(key) {};

/**
 * @param {string} keyName
 * @param {number=} increment
 * @return {number}
 */
Ember.Service.prototype.incrementProperty = function(keyName, increment) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Service.prototype.notifyPropertyChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Service.prototype.propertyDidChange = function(keyName) {};

/**
 * @param {string} keyName
 * @return {!Ember.Observable}
 */
Ember.Service.prototype.propertyWillChange = function(keyName) {};

/**
 * @param {string} key
 * @param {!Object} target
 * @param {(string|?)} method
 * @return {void}
 */
Ember.Service.prototype.removeObserver = function(key, target, method) {};

/**
 * @param {string} keyName
 * @param {?} value
 * @return {!Ember.Observable}
 */
Ember.Service.prototype.set = function(keyName, value) {};

/**
 * @param {!Object} hash
 * @return {!Ember.Observable}
 */
Ember.Service.prototype.setProperties = function(hash) {};

/**
 * @param {string} keyName
 * @return {boolean}
 */
Ember.Service.prototype.toggleProperty = function(keyName) {};
 /** @type {boolean} */
Ember.STRINGS;
/**
 * @extends {Ember.Object}
 * @extends {Ember.Evented}
 * @constructor
 * @struct
 */
Ember.State = function() {};
 /** @type {boolean} */
Ember.State.isClass;
 /** @type {boolean} */
Ember.State.isMethod;
 /** @type {boolean} */
Ember.State.prototype.hasContext;
 /** @type {boolean} */
Ember.State.prototype.isLeaf;
 /** @type {string} */
Ember.State.prototype.name;
 /** @type {!Ember.State} */
Ember.State.prototype.parentState;
 /** @type {string} */
Ember.State.prototype.path;
 /** @type {?} */
Ember.State.prototype.enter;
 /** @type {?} */
Ember.State.prototype.exit;
 /** @type {?} */
Ember.State.prototype.setup;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.State.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.State.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.State.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.State.metaForProperty = function(key) {};

/**
 * @param {string} name
 * @return {boolean}
 */
Ember.State.prototype.has = function(name) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {?} method
 * @return {!Ember.State}
 */
Ember.State.prototype.off = function(name, target, method) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {?} method
 * @return {!Ember.State}
 */
Ember.State.prototype.on = function(name, target, method) {};

/**
 * @param {string} name
 * @param {?} target
 * @param {?} method
 * @return {!Ember.State}
 */
Ember.State.prototype.one = function(name, target, method) {};

/**
 * @param {string} name
 * @param {...string} args
 * @return {void}
 */
Ember.State.prototype.trigger = function(name, args) {};

/**
 * @param {!Object} stateManager
 * @param {string} path
 * @return {!Object}
 */
Ember.State.prototype.getPathsCache = function(stateManager, path) {};

/**
 * @return {void}
 */
Ember.State.prototype.init = function() {};

/**
 * @param {!Object} stateManager
 * @param {string} path
 * @param {?} transitions
 * @return {void}
 */
Ember.State.prototype.setPathsCache = function(stateManager, path, transitions) {};

/**
 * @param {string} target
 * @return {void}
 */
Ember.State.transitionTo = function(target) {};
/**
 * @extends {Ember.State}
 * @constructor
 * @struct
 */
Ember.StateManager = function() {};
 /** @type {boolean} */
Ember.StateManager.isClass;
 /** @type {boolean} */
Ember.StateManager.isMethod;
 /** @type {string} */
Ember.StateManager.prototype.currentPath;
 /** @type {!Ember.State} */
Ember.StateManager.prototype.currentState;
 /** @type {boolean} */
Ember.StateManager.prototype.errorOnUnhandledEvents;
 /** @type {string} */
Ember.StateManager.prototype.transitionEvent;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.StateManager.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.StateManager.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.StateManager.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.StateManager.metaForProperty = function(key) {};

/**
 * @param {!Ember.State} currentState
 * @param {string} path
 * @return {?}
 */
Ember.StateManager.prototype.contextFreeTransition = function(currentState, path) {};

/**
 * @param {?} transition
 * @return {void}
 */
Ember.StateManager.prototype.enterState = function(transition) {};

/**
 * @param {string} name
 * @return {!Ember.State}
 */
Ember.StateManager.prototype.getState = function(name) {};

/**
 * @param {!Ember.State} root
 * @param {string} path
 * @return {!Ember.State}
 */
Ember.StateManager.prototype.getStateByPath = function(root, path) {};

/**
 * @param {!Ember.State} state
 * @param {string} key
 * @return {?}
 */
Ember.StateManager.prototype.getStateMeta = function(state, key) {};

/**
 * @param {!Ember.State} root
 * @param {string} path
 * @return {!Array<!Ember.State>}
 */
Ember.StateManager.prototype.getStatesInPath = function(root, path) {};

/**
 * @param {string} path
 * @param {?} context
 * @return {void}
 */
Ember.StateManager.prototype.goToState = function(path, context) {};

/**
 * @param {string} event
 * @return {void}
 */
Ember.StateManager.prototype.send = function(event) {};

/**
 * @param {!Ember.State} state
 * @param {string} key
 * @param {?} value
 * @return {?}
 */
Ember.StateManager.prototype.setStateMeta = function(state, key, value) {};

/**
 * @param {!Ember.State} state
 * @return {!Object}
 */
Ember.StateManager.prototype.stateMetaFor = function(state) {};

/**
 * @param {string} path
 * @param {?} context
 * @return {void}
 */
Ember.StateManager.prototype.transitionTo = function(path, context) {};

/**
 * @param {?} transitions
 * @return {void}
 */
Ember.StateManager.prototype.triggerSetupContext = function(transitions) {};

/**
 * @param {!Ember.StateManager} manager
 * @param {string} event
 * @return {?}
 */
Ember.StateManager.prototype.unhandledEvent = function(manager, event) {};
/** @const */
Ember.String = {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.camelize = function(str) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.capitalize = function(str) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.classify = function(str) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.dasherize = function(str) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.decamelize = function(str) {};

/**
 * @param {...string} args
 * @return {string}
 */
Ember.String.fmt = function(args) {};

/**
 * @param {string} str
 * @return {void}
 */
Ember.String.htmlSafe = function(str) {};

/**
 * @param {...string} args
 * @return {string}
 */
Ember.String.loc = function(args) {};

/**
 * @param {string} str
 * @return {string}
 */
Ember.String.underscore = function(str) {};

/**
 * @param {string} str
 * @return {!Array<string>}
 */
Ember.String.w = function(str) {};
 /** @type {!Object} */
Ember.TEMPLATES;
/**
 * @constructor
 * @struct
 */
Ember.TargetActionSupport = function() {};

/**
 * @param {!Object} opts
 * @return {boolean}
 */
Ember.TargetActionSupport.prototype.triggerAction = function(opts) {};
/** @const */
Ember.Test = {};

/**
 * @constructor
 * @struct
 */
Ember.Test.Adapter = function() {};

/**
 * @constructor
 * @struct
 */
Ember.Test.Promise = function() {};

/**
 * @param {?} callback
 * @return {void}
 */
Ember.Test.oninjectHelpers = function(callback) {};

/**
 * @template T, U
 * @param {function(T): ?} resolver
 * @param {string} label
 * @return {!Ember.Test.Promise<T, U>}
 */
Ember.Test.promise = function(resolver, label) {};

/**
 * @param {string} name
 * @return {void}
 */
Ember.Test.unregisterHelper = function(name) {};

/**
 * @param {string} name
 * @param {?} helperMethod
 * @return {void}
 */
Ember.Test.registerHelper = function(name, helperMethod) {};

/**
 * @param {string} name
 * @param {?} helperMethod
 * @return {void}
 */
Ember.Test.registerAsyncHelper = function(name, helperMethod) {};
 /** @type {!Ember.Object} */
Ember.Test.adapter;
 /** @type {!Ember.Object} */
Ember.Test.QUnitAdapter;

/**
 * @param {?} callback_or_context
 * @param {?=} callback
 * @return {void}
 */
Ember.Test.registerWaiter = function(callback_or_context, callback) {};

/**
 * @param {?} callback_or_context
 * @param {?=} callback
 * @return {void}
 */
Ember.Test.unregisterWaiter = function(callback_or_context, callback) {};

/**
 * @template T
 * @param {T} result
 * @return {!Ember.Test.Promise<T, void>}
 */
Ember.Test.resolve = function(result) {};
/**
 * @extends {Ember.Component}
 * @extends {Ember.TextSupport}
 * @constructor
 * @struct
 */
Ember.TextArea = function() {};
 /** @type {boolean} */
Ember.TextArea.isClass;
 /** @type {boolean} */
Ember.TextArea.isMethod;
 /** @type {string} */
Ember.TextArea.prototype.action;
 /** @type {boolean} */
Ember.TextArea.prototype.bubbles;
 /** @type {string} */
Ember.TextArea.prototype.onEvent;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.TextArea.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.TextArea.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.TextArea.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.TextArea.metaForProperty = function(key) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextArea.prototype.cancel = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextArea.prototype.focusIn = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextArea.prototype.focusOut = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextArea.prototype.insertNewLine = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextArea.prototype.keyPress = function(event) {};
/**
 * @extends {Ember.Component}
 * @extends {Ember.TextSupport}
 * @constructor
 * @struct
 */
Ember.TextField = function() {};
 /** @type {boolean} */
Ember.TextField.isClass;
 /** @type {boolean} */
Ember.TextField.isMethod;
 /** @type {string} */
Ember.TextField.prototype.action;
 /** @type {boolean} */
Ember.TextField.prototype.bubbles;
 /** @type {string} */
Ember.TextField.prototype.onEvent;
 /** @type {string} */
Ember.TextField.prototype.pattern;
 /** @type {string} */
Ember.TextField.prototype.size;
 /** @type {string} */
Ember.TextField.prototype.type;
 /** @type {string} */
Ember.TextField.prototype.value;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.TextField.detect = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.TextField.detectInstance = function(obj) {};

/**
 * Iterate over each computed property for the class, passing its name and any
 * associated metadata (see metaForProperty) to the callback.
 * 
 * @param {?} callback
 * @param {!Object} binding
 * @return {void}
 */
Ember.TextField.eachComputedProperty = function(callback, binding) {};

/**
 * Returns the original hash that was passed to meta().
 * @param {string} key property name
 * 
 * @return {!Object}
 */
Ember.TextField.metaForProperty = function(key) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextField.prototype.cancel = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextField.prototype.focusIn = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextField.prototype.focusOut = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextField.prototype.insertNewLine = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextField.prototype.keyPress = function(event) {};
/**
 * @constructor
 * @struct
 */
Ember.TextSupport = function() {};
 /** @type {string} */
Ember.TextSupport.prototype.action;
 /** @type {boolean} */
Ember.TextSupport.prototype.bubbles;
 /** @type {string} */
Ember.TextSupport.prototype.onEvent;

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextSupport.prototype.cancel = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextSupport.prototype.focusIn = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextSupport.prototype.focusOut = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextSupport.prototype.insertNewLine = function(event) {};

/**
 * @param {?} event
 * @return {void}
 */
Ember.TextSupport.prototype.keyPress = function(event) {};
 /** @type {string} */
Ember.VERSION;
/**
 * @extends {Ember.Mixin}
 * @constructor
 * @struct
 */
Ember.ViewTargetActionSupport = function() {};
 /** @type {?} */
Ember.ViewTargetActionSupport.prototype.target;
 /** @type {?} */
Ember.ViewTargetActionSupport.prototype.actionContext;
 /** @type {!Object} */
Ember.ViewUtils;

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {?} target
 * @param {(string|?)} method
 * @param {boolean=} once
 * @return {void}
 */
Ember.addListener = function(obj, eventName, target, method, once) {};
 /** @type {?} */
Ember.addObserver;
 /** @type {function(string, ?): ?} */
Ember.alias;

/**
 * @param {string} methodName
 * @return {!Ember.Descriptor}
 */
Ember.aliasMethod = function(methodName) {};

/**
 * @param {string} desc
 * @param {boolean} test
 * @return {void}
 */
Ember.assert = function(desc, test) {};

/**
 * @return {void}
 */
Ember.beginPropertyChanges = function() {};

/**
 * @param {?} obj
 * @param {string} to
 * @param {string} from
 * @return {!Ember.Binding}
 */
Ember.bind = function(obj, to, from) {};

/**
 * @param {?} obj
 * @param {string} key
 * @return {?}
 */
Ember.cacheFor = function(obj, key) {};

/**
 * @param {?} obj
 * @param {string} methodName
 * @return {boolean}
 */
Ember.canInvoke = function(obj, methodName) {};

/**
 * @param {?} callback
 * @param {?=} binding
 * @return {void}
 */
Ember.changeProperties = function(callback, binding) {};

/**
 * @param {?} v
 * @param {?} w
 * @return {number}
 */
Ember.compare = function(v, w) {};
 /** @type {?} */
Ember.computed;

/**
 * @param {!Ember.Container} container
 * @param {string} controllerName
 * @param {!Object=} lookupOptions
 * @return {!Ember.Controller}
 */
Ember.controllerFor = function(container, controllerName, lookupOptions) {};

/**
 * @param {?} obj
 * @param {boolean} deep
 * @return {?}
 */
Ember.copy = function(obj, deep) {};

/**
 * Creates an instance of the CoreObject class.
 * @param {!Object=} tsickle_arguments
 * @return {!Ember.CoreObject}
 */
Ember.create = function(tsickle_arguments) {};

/**
 * @param {string} message
 * @return {void}
 */
Ember.debug = function(message) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @param {!Object} desc
 * @return {void}
 */
Ember.defineProperty = function(obj, keyName, desc) {};

/**
 * @param {string} message
 * @param {boolean=} test
 * @return {void}
 */
Ember.deprecate = function(message, test) {};

/**
 * @param {string} message
 * @param {?} func
 * @return {?}
 */
Ember.deprecateFunc = function(message, func) {};

/**
 * @param {?} obj
 * @return {void}
 */
Ember.destroy = function(obj) {};
 /** @type {function(string, ?): ?} */
Ember.empty;

/**
 * @return {void}
 */
Ember.endPropertyChanges = function() {};

/**
 * @param {?} obj
 * @return {void}
 */
Ember.finishChains = function(obj) {};

/**
 * @param {!Ember.Container} container
 * @param {string} controllerName
 * @param {?} context
 * @return {!Ember.Controller}
 */
Ember.generateController = function(container, controllerName, context) {};

/**
 * @param {?} obj
 * @param {string=} prefix
 * @return {string}
 */
Ember.generateGuid = function(obj, prefix) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {?}
 */
Ember.get = function(obj, keyName) {};

/**
 * @param {?} obj
 * @param {...string|!Array<string>} args_or_keys
 * @return {!Object}
 */
Ember.getProperties = function(obj, args_or_keys) {};
 /** @type {function(string, ?): ?} */
Ember.getPath;

/**
 * @param {string} root
 * @param {string} key
 * @param {?} defaultValue
 * @return {?}
 */
Ember.getWithDefault = function(root, key, defaultValue) {};

/**
 * @param {?} obj
 * @return {string}
 */
Ember.guidFor = function(obj) {};

/**
 * @param {?} func
 * @param {?} context
 * @return {?}
 */
Ember.handleErrors = function(func, context) {};

/**
 * @param {?} context
 * @param {string} name
 * @return {boolean}
 */
Ember.hasListeners = function(context, name) {};

/**
 * @param {string} prop
 * @return {boolean}
 */
Ember.hasOwnProperty = function(prop) {};

/**
 * @param {?} func
 * @param {...?} propertyNames
 * @return {?}
 */
Ember.immediateObserver = function(func, propertyNames) {};

/**
 * @param {?} obj
 * @return {string}
 */
Ember.inspect = function(obj) {};

/**
 * @param {string} name
 * @param {?} payload
 * @param {?} callback
 * @param {?} binding
 * @return {void}
 */
Ember.instrument = function(name, payload, callback, binding) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.isArray = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.isBlank = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.isEmpty = function(obj) {};

/**
 * @param {?} a
 * @param {?} b
 * @return {boolean}
 */
Ember.isEqual = function(a, b) {};

/**
 * @param {string} path
 * @return {boolean}
 */
Ember.isGlobalPath = function(path) {};
 /** @type {boolean} */
Ember.isNamespace;

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.isNone = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
Ember.isPresent = function(obj) {};

/**
 * @param {!Object} obj
 * @return {boolean}
 */
Ember.isPrototypeOf = function(obj) {};

/**
 * @param {?} obj
 * @param {string} key
 * @return {boolean}
 */
Ember.isWatching = function(obj, key) {};

/**
 * @param {?} obj
 * @return {!Array<?>}
 */
Ember.keys = function(obj) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {!Array<?>} otherActions
 * @return {!Array<?>}
 */
Ember.listenersDiff = function(obj, eventName, otherActions) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @return {!Array<?>}
 */
Ember.listenersFor = function(obj, eventName) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {!Array<?>} otherActions
 * @return {void}
 */
Ember.listenersUnion = function(obj, eventName, otherActions) {};
 /** @type {!Object} */
Ember.lookup;

/**
 * @param {?} obj
 * @return {!Array<?>}
 */
Ember.makeArray = function(obj) {};

/**
 * @param {?} original
 * @param {?} updates
 * @return {?}
 */
Ember.merge = function(original, updates) {};

/**
 * @param {?} obj
 * @return {!Object}
 */
Ember.meta = function(obj) {};

/**
 * @param {?} obj
 * @param {...?} args
 * @return {?}
 */
Ember.mixin = function(obj, args) {};
 /** @type {function(string, ?): ?} */
Ember.none;

/**
 * @param {...?} args
 * @return {?}
 */
Ember.observer = function(args) {};

/**
 * @param {?} obj
 * @param {string} path
 * @return {!Array<?>}
 */
Ember.observersFor = function(obj, path) {};

/**
 * @param {string} name
 * @param {?} callback
 * @return {void}
 */
Ember.onLoad = function(name, callback) {};
 /** @type {!Error} */
Ember.onError;

/**
 * @param {?} error
 * @return {void}
 */
Ember.onerror = function(error) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @param {?} m
 * @return {boolean}
 */
Ember.overrideChains = function(obj, keyName, m) {};
 /** @type {{defineProperty: boolean, hasPropertyAccessors: boolean}} */
Ember.platform;

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {void}
 */
Ember.propertyDidChange = function(obj, keyName) {};

/**
 * @param {string} prop
 * @return {boolean}
 */
Ember.propertyIsEnumerable = function(prop) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {void}
 */
Ember.propertyWillChange = function(obj, keyName) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @param {?} node
 * @return {void}
 */
Ember.removeChainWatcher = function(obj, keyName, node) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {?} target
 * @param {(string|?)} method
 * @return {void}
 */
Ember.removeListener = function(obj, eventName, target, method) {};

/**
 * @param {?} obj
 * @param {string} path
 * @param {?} target
 * @param {?} method
 * @return {?}
 */
Ember.removeObserver = function(obj, path, target, method) {};

/**
 * @return {!Ember.Descriptor}
 */
Ember.required = function() {};

/**
 * @param {?} obj
 * @return {void}
 */
Ember.rewatch = function(obj) {};

/** @typedef {function(!Array<?>): T} */
Ember.RunMethod;
 /** @type {?} */
Ember.run;

/**
 * @param {?} fn
 * @return {void}
 */
Ember.runInDebug = function(fn) {};

/**
 * @param {string} name
 * @param {?} object
 * @return {void}
 */
Ember.runLoadHooks = function(name, object) {};

/**
 * @param {?} obj
 * @param {string} eventName
 * @param {!Array<?>=} params
 * @param {!Array<?>=} actions
 * @return {boolean}
 */
Ember.sendEvent = function(obj, eventName, params, actions) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @param {?} value
 * @return {?}
 */
Ember.set = function(obj, keyName, value) {};
 /** @type {function(string, ?): ?} */
Ember.setPath;

/**
 * @param {?} self
 * @param {!Object} hash
 * @return {?}
 */
Ember.setProperties = function(self, hash) {};

/**
 * @param {string} pattern
 * @param {?} object
 * @return {void}
 */
Ember.subscribe = function(pattern, object) {};

/**
 * @return {string}
 */
Ember.toLocaleString = function() {};

/**
 * @return {string}
 */
Ember.toString = function() {};

/**
 * @param {?} tryable
 * @param {?} catchable
 * @param {?} finalizer
 * @param {?=} binding
 * @return {?}
 */
Ember.tryCatchFinally = function(tryable, catchable, finalizer, binding) {};

/**
 * @param {?} obj
 * @param {string} methodName
 * @param {!Array<?>=} args
 * @return {?}
 */
Ember.tryInvoke = function(obj, methodName, args) {};

/**
 * @param {?} obj
 * @param {string} path
 * @param {?} value
 * @return {void}
 */
Ember.trySet = function(obj, path, value) {};
 /** @type {function(string, ?): ?} */
Ember.trySetPath;

/**
 * @param {?} item
 * @return {string}
 */
Ember.typeOf = function(item) {};

/**
 * @param {?} obj
 * @param {string} keyPath
 * @return {void}
 */
Ember.unwatch = function(obj, keyPath) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {void}
 */
Ember.unwatchKey = function(obj, keyName) {};

/**
 * @param {?} obj
 * @param {string} keyPath
 * @return {void}
 */
Ember.unwatchPath = function(obj, keyPath) {};
 /** @type {number} */
Ember.uuid;

/**
 * @return {!Object}
 */
Ember.valueOf = function() {};

/**
 * @param {string} message
 * @param {boolean=} test
 * @return {void}
 */
Ember.warn = function(message, test) {};

/**
 * @param {?} obj
 * @param {string} keyPath
 * @return {void}
 */
Ember.watch = function(obj, keyPath) {};

/**
 * @param {?} obj
 * @param {string} keyName
 * @return {void}
 */
Ember.watchKey = function(obj, keyName) {};

/**
 * @param {?} obj
 * @param {string} keyPath
 * @return {void}
 */
Ember.watchPath = function(obj, keyPath) {};

/**
 * @param {!Object} obj
 * @return {!Array<?>}
 */
Ember.watchedEvents = function(obj) {};

/**
 * @param {?} func
 * @param {?} superFunc
 * @return {?}
 */
Ember.wrap = function(func, superFunc) {};
 /** @type {!Ember.Mixin} */
Ember._ContainerProxyMixin;
 /** @type {!Ember.Mixin} */
Ember._RegistryProxyMixin;

/**
 * @param {?} object
 * @return {?}
 */
Ember.getOwner = function(object) {};

/**
 * @param {?} object
 * @param {?} owner
 * @return {void}
 */
Ember.setOwner = function(object, owner) {};
 /** @type {boolean} */
Ember.testing;
 /** @type {boolean} */
Ember.MODEL_FACTORY_INJECTIONS;

/**
 * @param {?} original
 * @param {...?} sources
 * @return {?}
 */
Ember.assign = function(original, sources) {};

/* TODO: ExportAssignment in  */
