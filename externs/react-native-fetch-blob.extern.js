/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/react-native-fetch-blob/index.d.ts:
 /** @type {?} */
var RNFetchBlob;

/** @typedef {?} */
var RNFetchBlob;

/* TODO: ExportAssignment in  */
/**
 * @record
 * @struct
 */
function RNFetchBlobStatic() {}
 /** @type {?} */
RNFetchBlobStatic.prototype.base64;
 /** @type {?} */
RNFetchBlobStatic.prototype.android;
 /** @type {?} */
RNFetchBlobStatic.prototype.ios;
 /** @type {?} */
RNFetchBlobStatic.prototype.fs;
 /** @type {?} */
RNFetchBlobStatic.prototype.net;
 /** @type {?} */
RNFetchBlobStatic.prototype.polyfill;
 /** @type {?} */
RNFetchBlobStatic.prototype.JSONStream;

/**
 * @param {string} method
 * @param {string} url
 * @param {?=} headers
 * @param {?=} body
 * @return {?}
 */
RNFetchBlobStatic.prototype.fetch = function(method, url, headers, body) {};

/**
 * @param {?} options
 * @return {?}
 */
RNFetchBlobStatic.prototype.config = function(options) {};

/**
 * @param {string} name
 * @return {!RNFetchBlobSession}
 */
RNFetchBlobStatic.prototype.session = function(name) {};

/**
 * @param {string} path
 * @return {string}
 */
RNFetchBlobStatic.prototype.wrap = function(path) {};
/**
 * @record
 * @struct
 */
function Polyfill() {}
 /** @type {!PolyfillBlob} */
Polyfill.prototype.Blob;
 /** @type {!PolyfillFile} */
Polyfill.prototype.File;
 /** @type {?} */
Polyfill.prototype.XMLHttpRequest;
 /** @type {?} */
Polyfill.prototype.ProgressEvent;
 /** @type {!PolyfillEvent} */
Polyfill.prototype.Event;
 /** @type {?} */
Polyfill.prototype.FileReader;
 /** @type {!PolyfillFetch} */
Polyfill.prototype.Fetch;

/**
 * @constructor
 * @struct
 * @param {?} config
 */
function PolyfillFetch(config) {}

/**
 * @constructor
 * @struct
 * @param {?} config
 */
function RNFetchBlobFetchPolyfill(config) {}

/**
 * @return {function(string, ?): ?}
 */
RNFetchBlobFetchPolyfill.prototype.build = function() {};
/**
 * @record
 * @struct
 */
function RNFetchBlobFetchRepsonse() {}
 /** @type {boolean} */
RNFetchBlobFetchRepsonse.prototype.bodyUsed;
 /** @type {?} */
RNFetchBlobFetchRepsonse.prototype.headers;
 /** @type {boolean} */
RNFetchBlobFetchRepsonse.prototype.ok;
 /** @type {?} */
RNFetchBlobFetchRepsonse.prototype.resp;
 /** @type {?} */
RNFetchBlobFetchRepsonse.prototype.rnfbResp;
 /** @type {?} */
RNFetchBlobFetchRepsonse.prototype.rnfbRespInfo;
 /** @type {number} */
RNFetchBlobFetchRepsonse.prototype.status;
 /** @type {string} */
RNFetchBlobFetchRepsonse.prototype.type;

/**
 * @return {!Promise<!Array<?>>}
 */
RNFetchBlobFetchRepsonse.prototype.arrayBuffer = function() {};

/**
 * @return {!Promise<!PolyfillBlob>}
 */
RNFetchBlobFetchRepsonse.prototype.blob = function() {};

/**
 * @return {!Promise<?>}
 */
RNFetchBlobFetchRepsonse.prototype.json = function() {};

/**
 * @return {!Promise<?>}
 */
RNFetchBlobFetchRepsonse.prototype.rawResp = function() {};

/**
 * @return {!Promise<string>}
 */
RNFetchBlobFetchRepsonse.prototype.text = function() {};
/**
 * @record
 * @struct
 */
function FetchBlobResponse() {}
 /** @type {string} */
FetchBlobResponse.prototype.taskId;
 /** @type {string} */
FetchBlobResponse.prototype.type;
 /** @type {?} */
FetchBlobResponse.prototype.data;
 /** @type {?} */
FetchBlobResponse.prototype.respInfo;

/**
 * get path of response temp file
 * @return {string}
 */
FetchBlobResponse.prototype.path = function() {};

/**
 * Convert result to javascript RNFetchBlob object.
 * @param {string} contentType
 * @param {number} sliceSize
 * @return {!Promise<!PolyfillBlob>}
 */
FetchBlobResponse.prototype.blob = function(contentType, sliceSize) {};

/**
 * Convert result to text.
 * @return {(string|!Promise<?>)}
 */
FetchBlobResponse.prototype.text = function() {};

/**
 * Convert result to JSON object.
 * @return {?}
 */
FetchBlobResponse.prototype.json = function() {};

/**
 * Return BASE64 string directly.
 * @return {?}
 */
FetchBlobResponse.prototype.base64 = function() {};

/**
 * Remove cahced file
 * @return {void}
 */
FetchBlobResponse.prototype.flush = function() {};

/**
 * @param {string} name
 * @return {!RNFetchBlobSession}
 */
FetchBlobResponse.prototype.session = function(name) {};

/**
 * Read file content with given encoding, if the response does not contains
 * a file path, show warning message
 * @param {string} encode
 * @return {!Promise<?>}
 */
FetchBlobResponse.prototype.readFile = function(encode) {};

/**
 * Start read stream from cached file
 * @param {string} encode
 * @return {?}
 */
FetchBlobResponse.prototype.readStream = function(encode) {};
/**
 * @record
 * @struct
 */
function PolyfillFileReader() {}
 /** @type {boolean} */
PolyfillFileReader.prototype.isRNFBPolyFill;
 /** @type {number} */
PolyfillFileReader.prototype.readyState;
 /** @type {number} */
PolyfillFileReader.prototype.result;

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillFileReader.prototype.onloadstart = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillFileReader.prototype.onprogress = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillFileReader.prototype.onload = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillFileReader.prototype.onabort = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillFileReader.prototype.onerror = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillFileReader.prototype.onloadend = function(e) {};

/**
 * @return {void}
 */
PolyfillFileReader.prototype.abort = function() {};

/**
 * @param {!PolyfillBlob} b
 * @return {void}
 */
PolyfillFileReader.prototype.readAsArrayBuffer = function(b) {};

/**
 * @param {!PolyfillBlob} b
 * @return {void}
 */
PolyfillFileReader.prototype.readAsBinaryString = function(b) {};

/**
 * @param {!PolyfillBlob} b
 * @param {string=} label
 * @return {void}
 */
PolyfillFileReader.prototype.readAsText = function(b, label) {};

/**
 * @param {!PolyfillBlob} b
 * @return {void}
 */
PolyfillFileReader.prototype.readAsDataURL = function(b) {};
 /** @type {number} */
PolyfillFileReader.EMPTY;
 /** @type {number} */
PolyfillFileReader.LOADING;
 /** @type {number} */
PolyfillFileReader.DONE;
/**
 * @constructor
 * @struct
 */
function PolyfillEvent() {}
/**
 * @record
 * @struct
 */
function PolyfillProgressEvent() {}
 /** @type {boolean} */
PolyfillProgressEvent.prototype.lengthComputable;
 /** @type {number} */
PolyfillProgressEvent.prototype.loaded;
 /** @type {number} */
PolyfillProgressEvent.prototype.total;

/**
 * @constructor
 * @struct
 * RNFetchBlob Blob polyfill, create a Blob directly from file path, BASE64
 * encoded data, and string. The conversion is done implicitly according to
 * given `mime`. However, the blob creation is asynchronously, to register
 * event `onCreated` is need to ensure the Blob is creadted.
 * 
 * @param {?} data Content of Blob object
 * @param {?} cType Content type settings of Blob object, `text/plain` by default
 * @param {boolean} defer
 */
function PolyfillBlob(data, cType, defer) {}

/**
 * Since Blob content will asynchronously write to a file during creation,
 * use this method to register an event handler for Blob initialized event.
 * @param {function(): void} fn
 * @return {!PolyfillBlob}
 */
PolyfillBlob.prototype.onCreated = function(fn) {};

/**
 * @return {void}
 */
PolyfillBlob.prototype.markAsDerived = function() {};

/**
 * Get file reference of the Blob object.
 * @return {string}
 */
PolyfillBlob.prototype.getRNFetchBlobRef = function() {};

/**
 * Create a Blob object which is sliced from current object
 * @param {number=} start
 * @param {number=} end
 * @param {string=} contentType
 * @return {!PolyfillBlob}
 */
PolyfillBlob.prototype.slice = function(start, end, contentType) {};

/**
 * Read data of the Blob object, this is not standard method.
 * @param {string} encoding
 * @return {!Promise<?>}
 */
PolyfillBlob.prototype.readBlob = function(encoding) {};

/**
 * Release the resource of the Blob object.
 * \@nonstandard
 * @return {!Promise<void>}
 */
PolyfillBlob.prototype.close = function() {};

/**
 * @return {void}
 */
PolyfillBlob.clearCache = function() {};

/**
 * @param {?} data
 * @param {?} cType
 * @return {!Promise<!PolyfillBlob>}
 */
PolyfillBlob.build = function(data, cType) {};

/**
 * @param {number} level
 * @return {void}
 */
PolyfillBlob.setLog = function(level) {};
/**
 * @extends {PolyfillBlob}
 * @constructor
 * @struct
 */
function PolyfillFile() {}
/**
 * @extends {PolyfillXMLHttpRequestEventTarget}
 * @record
 * @struct
 */
function PolyfillXMLHttpRequest() {}
 /** @type {?} */
PolyfillXMLHttpRequest.prototype.upload;
 /** @type {number} */
PolyfillXMLHttpRequest.prototype.UNSENT;
 /** @type {number} */
PolyfillXMLHttpRequest.prototype.OPENED;
 /** @type {number} */
PolyfillXMLHttpRequest.prototype.HEADERS_RECEIVED;
 /** @type {number} */
PolyfillXMLHttpRequest.prototype.LOADING;
 /** @type {number} */
PolyfillXMLHttpRequest.prototype.DONE;
 /** @type {number} */
PolyfillXMLHttpRequest.prototype.readyState;
 /** @type {number} */
PolyfillXMLHttpRequest.prototype.status;
 /** @type {string} */
PolyfillXMLHttpRequest.prototype.statusText;
 /** @type {?} */
PolyfillXMLHttpRequest.prototype.response;
 /** @type {?} */
PolyfillXMLHttpRequest.prototype.responseText;
 /** @type {string} */
PolyfillXMLHttpRequest.prototype.responseURL;
 /** @type {?} */
PolyfillXMLHttpRequest.prototype.responseHeaders;
 /** @type {number} */
PolyfillXMLHttpRequest.prototype.timeout;
 /** @type {string} */
PolyfillXMLHttpRequest.prototype.responseType;

/**
 * XMLHttpRequest.open, always async, user and password not supported. When
 * this method invoked, headers should becomes empty again.
 * @param {string} method
 * @param {string} url
 * @param {boolean} async
 * @param {?} user NOT SUPPORTED
 * @param {?} password NOT SUPPORTED
 * @return {void}
 */
PolyfillXMLHttpRequest.prototype.open = function(method, url, async, user, password) {};

/**
 * Invoke this function to send HTTP request, and set body.
 * @param {?} body Body in RNfetchblob flavor
 * @return {void}
 */
PolyfillXMLHttpRequest.prototype.send = function(body) {};

/**
 * @param {string} mime
 * @return {void}
 */
PolyfillXMLHttpRequest.prototype.overrideMimeType = function(mime) {};

/**
 * @param {string} name
 * @param {string} value
 * @return {void}
 */
PolyfillXMLHttpRequest.prototype.setRequestHeader = function(name, value) {};

/**
 * @return {void}
 */
PolyfillXMLHttpRequest.prototype.abort = function() {};

/**
 * @param {string} field
 * @return {string}
 */
PolyfillXMLHttpRequest.prototype.getResponseHeader = function(field) {};

/**
 * @return {string}
 */
PolyfillXMLHttpRequest.prototype.getAllResponseHeaders = function() {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillXMLHttpRequest.prototype.onreadystatechange = function(e) {};
 /** @type {!Array<string>} */
PolyfillXMLHttpRequest.binaryContentTypes;
 /** @type {number} */
PolyfillXMLHttpRequest.UNSENT;
 /** @type {number} */
PolyfillXMLHttpRequest.OPENED;
 /** @type {number} */
PolyfillXMLHttpRequest.HEADERS_RECEIVED;
 /** @type {number} */
PolyfillXMLHttpRequest.LOADING;
 /** @type {number} */
PolyfillXMLHttpRequest.DONE;

/**
 * @param {number} level
 * @return {void}
 */
PolyfillXMLHttpRequest.setLog = function(level) {};

/**
 * @param {string} substr
 * @return {void}
 */
PolyfillXMLHttpRequest.addBinaryContentType = function(substr) {};

/**
 * @return {void}
 */
PolyfillXMLHttpRequest.removeBinaryContentType = function() {};
/**
 * @record
 * @struct
 */
function PolyfillXMLHttpRequestEventTarget() {}

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillXMLHttpRequestEventTarget.prototype.onabort = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillXMLHttpRequestEventTarget.prototype.onerror = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillXMLHttpRequestEventTarget.prototype.onload = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillXMLHttpRequestEventTarget.prototype.onloadstart = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillXMLHttpRequestEventTarget.prototype.onprogress = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillXMLHttpRequestEventTarget.prototype.ontimeout = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
PolyfillXMLHttpRequestEventTarget.prototype.onloadend = function(e) {};
/**
 * @record
 * @struct
 */
function Net() {}

/**
 * Get cookie according to the given url.
 * @param {string} domain
 * @return {!Promise<!Array<string>>}
 */
Net.prototype.getCookies = function(domain) {};

/**
 * Remove cookies for a specific domain
 * cookies when this is null.
 * @param {string=} domain
 * @return {!Promise<null>}
 */
Net.prototype.removeCookies = function(domain) {};
/**
 * @record
 * @struct
 */
function FS() {}
 /** @type {!RNFetchBlobSession} */
FS.prototype.RNFetchBlobSession;
 /** @type {?} */
FS.prototype.dirs;

/**
 * Remove file at path.
 * @param {string} path
 * @return {!Promise<void>}
 */
FS.prototype.unlink = function(path) {};

/**
 * Create a directory.
 * @param {string} path
 * @return {!Promise<void>}
 */
FS.prototype.mkdir = function(path) {};

/**
 * Get a file cache session
 * @param {string} name
 * @return {!RNFetchBlobSession}
 */
FS.prototype.session = function(name) {};

/**
 * @param {string} path
 * @return {!Promise<!Array<string>>}
 */
FS.prototype.ls = function(path) {};

/**
 * Create file stream from file at `path`.
 * @param {string} path
 * @param {string} encoding
 * @param {number=} bufferSize
 * @param {number=} tick
 * @return {!Promise<?>}
 */
FS.prototype.readStream = function(path, encoding, bufferSize, tick) {};

/**
 * @param {string} path
 * @param {string} dest
 * @return {!Promise<boolean>}
 */
FS.prototype.mv = function(path, dest) {};

/**
 * @param {string} path
 * @param {string} dest
 * @return {!Promise<boolean>}
 */
FS.prototype.cp = function(path, dest) {};

/**
 * Create write stream to a file.
 * @param {string} path
 * @param {string} encoding
 * @param {boolean=} append
 * @return {!Promise<?>}
 */
FS.prototype.writeStream = function(path, encoding, append) {};

/**
 * Write data to file.
 * @param {string} path
 * @param {(string|!Array<number>)} data
 * @param {string=} encoding
 * @return {!Promise<void>}
 */
FS.prototype.writeFile = function(path, data, encoding) {};

/**
 * @param {string} path
 * @param {(string|!Array<number>)} data
 * @param {string=} encoding
 * @return {!Promise<void>}
 */
FS.prototype.appendFile = function(path, data, encoding) {};

/**
 * Wrapper method of readStream.
 * @param {string} path
 * @param {string} encoding
 * @param {number=} bufferSize
 * @return {!Promise<?>}
 */
FS.prototype.readFile = function(path, encoding, bufferSize) {};

/**
 * Check if file exists and if it is a folder.
 * @param {string} path
 * @return {!Promise<boolean>}
 */
FS.prototype.exists = function(path) {};

/**
 * @param {string} path
 * @param {string} data
 * @param {string} encoding
 * @return {!Promise<void>}
 */
FS.prototype.createFile = function(path, data, encoding) {};

/**
 * @param {string} path
 * @return {!Promise<boolean>}
 */
FS.prototype.isDir = function(path) {};

/**
 * Show statistic data of a path.
 * @param {string} path
 * @return {!Promise<!RNFetchBlobStat>}
 */
FS.prototype.stat = function(path) {};

/**
 * @param {string} path
 * @return {!Promise<!Array<!RNFetchBlobStat>>}
 */
FS.prototype.lstat = function(path) {};

/**
 * Android only method, request media scanner to scan the file.
 * @param {!Array<?>} pairs
 * @return {!Promise<void>}
 */
FS.prototype.scanFile = function(pairs) {};

/**
 * @param {string} src
 * @param {string} dest
 * @param {number} start
 * @param {number} end
 * @return {!Promise<void>}
 */
FS.prototype.slice = function(src, dest, start, end) {};

/**
 * @param {string} path
 * @return {string}
 */
FS.prototype.asset = function(path) {};

/**
 * @return {!Promise<?>}
 */
FS.prototype.df = function() {};
/**
 * @record
 * @struct
 */
function Dirs() {}
 /** @type {string} */
Dirs.prototype.DocumentDir;
 /** @type {string} */
Dirs.prototype.CacheDir;
 /** @type {string} */
Dirs.prototype.PictureDir;
 /** @type {string} */
Dirs.prototype.MusicDir;
 /** @type {string} */
Dirs.prototype.MovieDir;
 /** @type {string} */
Dirs.prototype.DownloadDir;
 /** @type {string} */
Dirs.prototype.DCIMDir;
 /** @type {string} */
Dirs.prototype.SDCardDir;
 /** @type {string} */
Dirs.prototype.MainBundleDir;
/**
 * @record
 * @struct
 */
function RNFetchBlobWriteStream() {}
 /** @type {string} */
RNFetchBlobWriteStream.prototype.id;
 /** @type {string} */
RNFetchBlobWriteStream.prototype.encoding;
 /** @type {boolean} */
RNFetchBlobWriteStream.prototype.append;

/**
 * @param {string} data
 * @return {!Promise<void>}
 */
RNFetchBlobWriteStream.prototype.write = function(data) {};

/**
 * @return {void}
 */
RNFetchBlobWriteStream.prototype.close = function() {};
/**
 * @record
 * @struct
 */
function RNFetchBlobReadStream() {}
 /** @type {string} */
RNFetchBlobReadStream.prototype.path;
 /** @type {string} */
RNFetchBlobReadStream.prototype.encoding;
 /** @type {number} */
RNFetchBlobReadStream.prototype.bufferSize;
 /** @type {boolean} */
RNFetchBlobReadStream.prototype.closed;
 /** @type {number} */
RNFetchBlobReadStream.prototype.tick;

/**
 * @return {void}
 */
RNFetchBlobReadStream.prototype.open = function() {};

/**
 * @param {?} fn
 * @return {void}
 */
RNFetchBlobReadStream.prototype.onData = function(fn) {};

/**
 * @param {?} fn
 * @return {void}
 */
RNFetchBlobReadStream.prototype.onError = function(fn) {};

/**
 * @param {?} fn
 * @return {void}
 */
RNFetchBlobReadStream.prototype.onEnd = function(fn) {};

/** @typedef {string} */
var Encoding;
/**
 * @record
 * @struct
 */
function IOSApi() {}

/**
 * Open a file in {\@link https://developer.apple.com/reference/uikit/uidocumentinteractioncontroller UIDocumentInteractionController},
 * this is the default document viewer of iOS, supports several kinds of files. On Android, there's an similar method {\@link android.actionViewIntent}.
 * @param {string} path This is a required field, the path to the document. The path should NOT contains any scheme prefix.
 * @return {void}
 */
IOSApi.prototype.previewDocument = function(path) {};

/**
 * Show options menu for interact with the file.
 * @param {string} path This is a required field, the path to the document. The path should NOT contains any scheme prefix.
 * @return {void}
 */
IOSApi.prototype.openDocument = function(path) {};
/**
 * @record
 * @struct
 */
function AndroidApi() {}

/**
 * When sending an ACTION_VIEW intent with given file path and MIME type, system will try to open an
 * App to handle the file. For example, open Gallery app to view an image, or install APK.
 * @param {string} path Path of the file to be opened.
 * @param {string} mime Basically system will open an app according to this MIME type.
 * @return {!Promise<?>}
 */
AndroidApi.prototype.actionViewIntent = function(path, mime) {};

/** @typedef {string} */
var Methods;
/**
 * @record
 * @struct
 */
function StatefulPromise() {}

/**
 * Cancel the request when invoke this method.
 * @param {?=} cb
 * @return {?}
 */
StatefulPromise.prototype.cancel = function(cb) {};

/**
 * Add an event listener which triggers when data receiving from server.
 * Add an event listener with custom configuration
 * @param {?} callback_or_config
 * @param {?=} callback
 * @return {?}
 */
StatefulPromise.prototype.progress = function(callback_or_config, callback) {};

/**
 * Add an event listener with custom configuration.
 * Add an event listener with custom configuration
 * @param {?} callback_or_config
 * @param {?=} callback
 * @return {?}
 */
StatefulPromise.prototype.uploadProgress = function(callback_or_config, callback) {};

/**
 * An IOS only API, when IOS app turns into background network tasks will be terminated after ~180 seconds,
 * in order to handle these expired tasks, you can register an event handler, which will be called after the
 * app become active.
 * @param {?} callback
 * @return {?}
 */
StatefulPromise.prototype.expire = function(callback) {};

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {!Array<string>} list
 */
function RNFetchBlobSession(name, list) {}
 /** @type {string} */
RNFetchBlobSession.prototype.name;

/**
 * @param {string} path
 * @return {!RNFetchBlobSession}
 */
RNFetchBlobSession.prototype.add = function(path) {};

/**
 * @param {string} path
 * @return {!RNFetchBlobSession}
 */
RNFetchBlobSession.prototype.remove = function(path) {};

/**
 * @return {!Promise<void>}
 */
RNFetchBlobSession.prototype.dispose = function() {};

/**
 * @return {!Array<string>}
 */
RNFetchBlobSession.prototype.list = function() {};

/**
 * @param {string} name
 * @return {?}
 */
RNFetchBlobSession.getSession = function(name) {};

/**
 * @param {string} name
 * @return {void}
 */
RNFetchBlobSession.setSession = function(name) {};

/**
 * @param {string} name
 * @return {void}
 */
RNFetchBlobSession.removeSession = function(name) {};
/**
 * @record
 * @struct
 */
function RNFetchBlobConfig() {}
 /** @type {boolean} */
RNFetchBlobConfig.prototype.overwrite;
 /** @type {number} */
RNFetchBlobConfig.prototype.timeout;
 /** @type {boolean} */
RNFetchBlobConfig.prototype.indicator;
 /** @type {boolean} */
RNFetchBlobConfig.prototype.trusty;
 /** @type {boolean} */
RNFetchBlobConfig.prototype.fileCache;
 /** @type {string} */
RNFetchBlobConfig.prototype.appendExt;
 /** @type {string} */
RNFetchBlobConfig.prototype.path;
 /** @type {string} */
RNFetchBlobConfig.prototype.session;
 /** @type {?} */
RNFetchBlobConfig.prototype.addAndroidDownloads;
/**
 * @record
 * @struct
 */
function AddAndroidDownloads() {}
 /** @type {boolean} */
AddAndroidDownloads.prototype.useDownloadManager;
 /** @type {string} */
AddAndroidDownloads.prototype.title;
 /** @type {string} */
AddAndroidDownloads.prototype.description;
 /** @type {string} */
AddAndroidDownloads.prototype.path;
 /** @type {string} */
AddAndroidDownloads.prototype.mime;
 /** @type {boolean} */
AddAndroidDownloads.prototype.mediaScannable;
 /** @type {boolean} */
AddAndroidDownloads.prototype.notification;
/**
 * @record
 * @struct
 */
function RNFetchBlobResponseInfo() {}
 /** @type {string} */
RNFetchBlobResponseInfo.prototype.taskId;
 /** @type {number} */
RNFetchBlobResponseInfo.prototype.state;
 /** @type {?} */
RNFetchBlobResponseInfo.prototype.headers;
 /** @type {number} */
RNFetchBlobResponseInfo.prototype.status;
 /** @type {string} */
RNFetchBlobResponseInfo.prototype.respType;
 /** @type {string} */
RNFetchBlobResponseInfo.prototype.rnfbEncode;
/**
 * @record
 * @struct
 */
function RNFetchBlobStream() {}

/**
 * @return {void}
 */
RNFetchBlobStream.prototype.onData = function() {};

/**
 * @return {void}
 */
RNFetchBlobStream.prototype.onError = function() {};

/**
 * @return {void}
 */
RNFetchBlobStream.prototype.onEnd = function() {};
/**
 * @constructor
 * @struct
 */
function RNFetchBlobFile() {}
/**
 * @constructor
 * @struct
 */
function RNFetchBlobStat() {}
 /** @type {string} */
RNFetchBlobStat.prototype.lastModified;
 /** @type {string} */
RNFetchBlobStat.prototype.size;
 /** @type {string} */
RNFetchBlobStat.prototype.type;
 /** @type {string} */
RNFetchBlobStat.prototype.path;
 /** @type {string} */
RNFetchBlobStat.prototype.filename;
