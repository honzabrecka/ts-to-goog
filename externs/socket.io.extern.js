/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/socket.io/index.d.ts:
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "socket.io"
/** @const */
tsickle_declare_module.socket_io = {};
 /** @type {!SocketIOStatic} */
tsickle_declare_module.socket_io.server;

/* TODO: ExportAssignment in tsickle_declare_module.socket_io */
/**
 * @record
 * @struct
 */
function SocketIOStatic() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
 /** @type {!SocketIOStatic} */
SocketIOStatic.prototype.listen;
/** @const */
var SocketIO = {};
/**
 * @record
 * @struct
 */
SocketIO.Server = function() {};
 /** @type {{ws: ?}} */
SocketIO.Server.prototype.engine;
 /** @type {!Object<string,!SocketIO.Namespace>} */
SocketIO.Server.prototype.nsps;
 /** @type {!SocketIO.Namespace} */
SocketIO.Server.prototype.sockets;
 /** @type {!SocketIO.Server} */
SocketIO.Server.prototype.json;

/**
 * Server request verification function, that checks for allowed origins
 * @param {?} req The http.IncomingMessage request
 * @param {function(?, boolean): void} fn The callback to be called. It should take one parameter, err,
 * which will be null if there was no problem, and one parameter, success,
 * of type boolean
 * @return {void}
 */
SocketIO.Server.prototype.checkRequest = function(req, fn) {};

/**
 * Gets whether we're serving the client.js file or not
 * \@default true
 * Sets whether we're serving the client.js file or not
 * \@default true
 * @param {boolean=} v True if we want to serve the file, false otherwise
 * @return {boolean|!SocketIO.Server} This Server
 */
SocketIO.Server.prototype.serveClient = function(v) {};

/**
 * Gets the client serving path
 * \@default '/socket.io'
 * Sets the client serving path
 * \@default '/socket.io'
 * @param {string=} v The path to serve the client file on
 * @return {string|!SocketIO.Server} This Server
 */
SocketIO.Server.prototype.path = function(v) {};

/**
 * Gets the adapter that we're going to use for handling rooms
 * \@default typeof Adapter
 * Sets the adapter (class) that we're going to use for handling rooms
 * \@default typeof Adapter
 * @param {?=} v The class for the adapter to create
 * @return {?|!SocketIO.Server} This Server
 */
SocketIO.Server.prototype.adapter = function(v) {};

/**
 * Gets the allowed origins for requests
 * \@default "*:*"
 * Sets the allowed origins for requests
 * \@default "*:*"
 * return This Server
 * @param {string=} v The allowed origins, in host:port form
 * @return {string|!SocketIO.Server}
 */
SocketIO.Server.prototype.origins = function(v) {};

/**
 * Attaches socket.io to a server
 * Attaches socket.io to a port
 * @param {?|number} srv_or_port The http.Server that we want to attach to / The port that we want to attach to
 * @param {!SocketIO.ServerOptions=} opts An optional parameters object
 * @return {!SocketIO.Server} This Server
 */
SocketIO.Server.prototype.attach = function(srv_or_port, opts) {};

/**
 * @see attach( srv, opts )
 * @see attach( port, opts )
 * @param {?|number} srv_or_port
 * @param {!SocketIO.ServerOptions=} opts
 * @return {!SocketIO.Server}
 */
SocketIO.Server.prototype.listen = function(srv_or_port, opts) {};

/**
 * Binds socket.io to an engine.io intsance
 * @param {?} srv
 * @return {!SocketIO.Server} This Server
 */
SocketIO.Server.prototype.bind = function(srv) {};

/**
 * Called with each incoming connection
 * @param {?} socket The Engine.io Socket
 * @return {!SocketIO.Server} This Server
 */
SocketIO.Server.prototype.onconnection = function(socket) {};

/**
 * Looks up/creates a Namespace
 * @param {string} nsp The name of the NameSpace to look up/create. Should start
 * with a '/'
 * @return {!SocketIO.Namespace} The Namespace
 */
SocketIO.Server.prototype.of = function(nsp) {};

/**
 * Closes the server connection
 * @param {function(): void=} fn
 * @return {void}
 */
SocketIO.Server.prototype.close = function(fn) {};

/**
 * The event fired when we get a new connection
 * @see on( 'connection', listener )
 * Base 'on' method to add a listener for an event
 * @param {string} event The event being fired: 'connection' / The event that we want to add a listener for
 * @param {function(!SocketIO.Socket): void|!Function} listener A listener that should take one parameter of type Socket / The callback to call when we get the event. The parameters
 * for the callback depend on the event
 * @return {!SocketIO.Namespace} The default '/' Namespace
 */
SocketIO.Server.prototype.on = function(event, listener) {};

/**
 * Targets a room when emitting to the default '/' Namespace
 * @param {string} room The name of the room that we're targeting
 * @return {!SocketIO.Namespace} The default '/' Namespace
 */
SocketIO.Server.prototype.to = function(room) {};

/**
 * @see to( room )
 * @param {string} room
 * @return {!SocketIO.Namespace}
 */
SocketIO.Server.prototype.in = function(room) {};

/**
 * Registers a middleware function, which is a function that gets executed
 * for every incoming Socket, on the default '/' Namespace
 * @param {function(!SocketIO.Socket, function(?): void): void} fn The function to call when we get a new incoming socket. It should
 * take one parameter of type Socket, and one callback function to call to
 * execute the next middleware function. The callback can take one optional
 * parameter, err, if there was an error. Errors passed to middleware callbacks
 * are sent as special 'error' packets to clients
 * @return {!SocketIO.Namespace} The default '/' Namespace
 */
SocketIO.Server.prototype.use = function(fn) {};

/**
 * Emits an event to the default Namespace
 * @param {string} event The event that we want to emit
 * @param {...?} args Any number of optional arguments to pass with the event. If the
 * last argument is a function, it will be called as an ack. The ack should
 * take whatever data was sent with the packet
 * @return {!SocketIO.Namespace} The default '/' Namespace
 */
SocketIO.Server.prototype.emit = function(event, args) {};

/**
 * Sends a 'message' event
 * @see emit( event, ...args )
 * @param {...?} args
 * @return {!SocketIO.Namespace} The default '/' Namespace
 */
SocketIO.Server.prototype.send = function(args) {};

/**
 * @see send( ...args )
 * @param {...?} args
 * @return {!SocketIO.Namespace}
 */
SocketIO.Server.prototype.write = function(args) {};

/**
 * Gets a list of clients
 * @param {...?} args
 * @return {!SocketIO.Namespace} The default '/' Namespace
 */
SocketIO.Server.prototype.clients = function(args) {};

/**
 * Sets the compress flag
 * @param {...?} args
 * @return {!SocketIO.Namespace} The default '/' Namespace
 */
SocketIO.Server.prototype.compress = function(args) {};
/**
 * @record
 * @struct
 */
SocketIO.ServerOptions = function() {};
 /** @type {string} */
SocketIO.ServerOptions.prototype.path;
 /** @type {boolean} */
SocketIO.ServerOptions.prototype.serveClient;
 /** @type {!SocketIO.Adapter} */
SocketIO.ServerOptions.prototype.adapter;
 /** @type {string} */
SocketIO.ServerOptions.prototype.origins;
 /** @type {number} */
SocketIO.ServerOptions.prototype.pingTimeout;
 /** @type {number} */
SocketIO.ServerOptions.prototype.pingInterval;
 /** @type {number} */
SocketIO.ServerOptions.prototype.maxHttpBufferSize;
 /** @type {function(?, function(number, boolean): void): void} */
SocketIO.ServerOptions.prototype.allowRequest;
 /** @type {!Array<string>} */
SocketIO.ServerOptions.prototype.transports;
 /** @type {boolean} */
SocketIO.ServerOptions.prototype.allowUpgrades;
 /** @type {(boolean|!Object)} */
SocketIO.ServerOptions.prototype.perMessageDeflate;
 /** @type {(boolean|!Object)} */
SocketIO.ServerOptions.prototype.httpCompression;
 /** @type {(string|boolean)} */
SocketIO.ServerOptions.prototype.cookie;
/**
 * @record
 * @struct
 */
SocketIO.Namespace = function() {};
 /** @type {string} */
SocketIO.Namespace.prototype.name;
 /** @type {!SocketIO.Server} */
SocketIO.Namespace.prototype.server;
 /** @type {!Object<string,!SocketIO.Socket>} */
SocketIO.Namespace.prototype.sockets;
 /** @type {!Object<string,!SocketIO.Socket>} */
SocketIO.Namespace.prototype.connected;
 /** @type {!SocketIO.Adapter} */
SocketIO.Namespace.prototype.adapter;
 /** @type {!SocketIO.Namespace} */
SocketIO.Namespace.prototype.json;

/**
 * Registers a middleware function, which is a function that gets executed
 * for every incoming Socket
 * @param {function(!SocketIO.Socket, function(?): void): void} fn The function to call when we get a new incoming socket. It should
 * take one parameter of type Socket, and one callback function to call to
 * execute the next middleware function. The callback can take one optional
 * parameter, err, if there was an error. Errors passed to middleware callbacks
 * are sent as special 'error' packets to clients
 * @return {!SocketIO.Namespace} This Namespace
 */
SocketIO.Namespace.prototype.use = function(fn) {};

/**
 * Targets a room when emitting
 * @param {string} room The name of the room that we're targeting
 * @return {!SocketIO.Namespace} This Namespace
 */
SocketIO.Namespace.prototype.to = function(room) {};

/**
 * @see to( room )
 * @param {string} room
 * @return {!SocketIO.Namespace}
 */
SocketIO.Namespace.prototype.in = function(room) {};

/**
 * Sends a 'message' event
 * @see emit( event, ...args )
 * @param {...?} args
 * @return {!SocketIO.Namespace} This Namespace
 */
SocketIO.Namespace.prototype.send = function(args) {};

/**
 * @see send( ...args )
 * @param {...?} args
 * @return {!SocketIO.Namespace}
 */
SocketIO.Namespace.prototype.write = function(args) {};

/**
 * The event fired when we get a new connection
 * @see on( 'connection', listener )
 * Base 'on' method to add a listener for an event
 * @param {string} event The event being fired: 'connection' / The event that we want to add a listener for
 * @param {function(!SocketIO.Socket): void|!Function} listener A listener that should take one parameter of type Socket / The callback to call when we get the event. The parameters
 * for the callback depend on the event
 * \@ This Namespace
 * @return {Namespace} This Namespace
 */
SocketIO.Namespace.prototype.on = function(event, listener) {};

/**
 * Gets a list of clients.
 * @param {!Function} fn
 * @return {!SocketIO.Namespace} This Namespace
 */
SocketIO.Namespace.prototype.clients = function(fn) {};

/**
 * Sets the compress flag.
 * @param {boolean} compress If `true`, compresses the sending data
 * @return {!SocketIO.Namespace} This Namespace
 */
SocketIO.Namespace.prototype.compress = function(compress) {};
/**
 * @record
 * @struct
 */
SocketIO.Socket = function() {};
 /** @type {!SocketIO.Namespace} */
SocketIO.Socket.prototype.nsp;
 /** @type {!SocketIO.Server} */
SocketIO.Socket.prototype.server;
 /** @type {!SocketIO.Adapter} */
SocketIO.Socket.prototype.adapter;
 /** @type {string} */
SocketIO.Socket.prototype.id;
 /** @type {?} */
SocketIO.Socket.prototype.request;
 /** @type {!SocketIO.Client} */
SocketIO.Socket.prototype.client;
 /** @type {!SocketIO.EngineSocket} */
SocketIO.Socket.prototype.conn;
 /** @type {!Object<string,string>} */
SocketIO.Socket.prototype.rooms;
 /** @type {boolean} */
SocketIO.Socket.prototype.connected;
 /** @type {boolean} */
SocketIO.Socket.prototype.disconnected;
 /** @type {{headers: ?, time: string, address: string, xdomain: boolean, secure: boolean, issued: number, url: string, query: ?}} */
SocketIO.Socket.prototype.handshake;
 /** @type {!SocketIO.Socket} */
SocketIO.Socket.prototype.json;
 /** @type {!SocketIO.Socket} */
SocketIO.Socket.prototype.volatile;
 /** @type {!SocketIO.Socket} */
SocketIO.Socket.prototype.broadcast;

/**
 * Targets a room when broadcasting
 * @param {string} room The name of the room that we're targeting
 * @return {!SocketIO.Socket} This Socket
 */
SocketIO.Socket.prototype.to = function(room) {};

/**
 * @see to( room )
 * @param {string} room
 * @return {!SocketIO.Socket}
 */
SocketIO.Socket.prototype.in = function(room) {};

/**
 * Sends a 'message' event
 * @see emit( event, ...args )
 * @param {...?} args
 * @return {!SocketIO.Socket}
 */
SocketIO.Socket.prototype.send = function(args) {};

/**
 * @see send( ...args )
 * @param {...?} args
 * @return {!SocketIO.Socket}
 */
SocketIO.Socket.prototype.write = function(args) {};

/**
 * Joins a room. You can join multiple rooms, and by default, on connection,
 * you join a room with the same name as your ID
 * @param {string} name The name of the room that we want to join
 * @param {function(?): void=} fn An optional callback to call when we've joined the room. It should
 * take an optional parameter, err, of a possible error
 * @return {!SocketIO.Socket} This Socket
 */
SocketIO.Socket.prototype.join = function(name, fn) {};

/**
 * Leaves a room
 * @param {string} name The name of the room to leave
 * @param {!Function=} fn An optional callback to call when we've left the room. It should
 * take on optional parameter, err, of a possible error
 * @return {!SocketIO.Socket}
 */
SocketIO.Socket.prototype.leave = function(name, fn) {};

/**
 * Leaves all the rooms that we've joined
 * @return {void}
 */
SocketIO.Socket.prototype.leaveAll = function() {};

/**
 * Disconnects this Socket
 * @param {boolean=} close If true, also closes the underlying connection
 * @return {!SocketIO.Socket} This Socket
 */
SocketIO.Socket.prototype.disconnect = function(close) {};

/**
 * Returns all the callbacks for a particular event
 * @param {string} event The event that we're looking for the callbacks of
 * @return {!Array<!Function>} An array of callback Functions, or an empty array if we don't have any
 */
SocketIO.Socket.prototype.listeners = function(event) {};

/**
 * Sets the compress flag
 * @param {boolean} compress If `true`, compresses the sending data
 * @return {!SocketIO.Socket} This Socket
 */
SocketIO.Socket.prototype.compress = function(compress) {};
/**
 * @record
 * @struct
 */
SocketIO.Adapter = function() {};
 /** @type {!SocketIO.Namespace} */
SocketIO.Adapter.prototype.nsp;
 /** @type {!Object<string,{sockets: !Object<string,boolean>, length: number}>} */
SocketIO.Adapter.prototype.rooms;
 /** @type {!Object<string,!Object<string,boolean>>} */
SocketIO.Adapter.prototype.sids;

/**
 * Adds a socket to a room. If the room doesn't exist, it's created
 * @param {string} id The ID of the socket to add
 * @param {string} room The name of the room to add the socket to
 * @param {function(?): void=} callback An optional callback to call when the socket has been
 * added. It should take an optional parameter, error, if there was a problem
 * @return {void}
 */
SocketIO.Adapter.prototype.add = function(id, room, callback) {};

/**
 * Removes a socket from a room. If there are no more sockets in the room,
 * the room is deleted
 * @param {string} id The ID of the socket that we're removing
 * @param {string} room The name of the room to remove the socket from
 * @param {function(?): void=} callback An optional callback to call when the socket has been
 * removed. It should take on optional parameter, error, if there was a problem
 * @return {void}
 */
SocketIO.Adapter.prototype.del = function(id, room, callback) {};

/**
 * Removes a socket from all the rooms that it's joined
 * @param {string} id The ID of the socket that we're removing
 * @return {void}
 */
SocketIO.Adapter.prototype.delAll = function(id) {};

/**
 * Broadcasts a packet
 * @param {?} packet The packet to broadcast
 * @param {{rooms: !Array<string>, except: !Array<string>, flags: !Object<string,boolean>}} opts Any options to send along:
 * 	- rooms: An optional list of rooms to broadcast to. If empty, the packet is broadcast to all sockets
 * 	- except: A list of Socket IDs to exclude
 * 	- flags: Any flags that we want to send along ('json', 'volatile', 'broadcast')
 * @return {void}
 */
SocketIO.Adapter.prototype.broadcast = function(packet, opts) {};
/**
 * @record
 * @struct
 */
SocketIO.Client = function() {};
 /** @type {!SocketIO.Server} */
SocketIO.Client.prototype.server;
 /** @type {!SocketIO.EngineSocket} */
SocketIO.Client.prototype.conn;
 /** @type {string} */
SocketIO.Client.prototype.id;
 /** @type {?} */
SocketIO.Client.prototype.request;
 /** @type {!Object<string,!SocketIO.Socket>} */
SocketIO.Client.prototype.sockets;
 /** @type {!Object<string,!SocketIO.Socket>} */
SocketIO.Client.prototype.nsps;
/**
 * @record
 * @struct
 */
SocketIO.EngineSocket = function() {};
 /** @type {string} */
SocketIO.EngineSocket.prototype.id;
 /** @type {?} */
SocketIO.EngineSocket.prototype.server;
 /** @type {string} */
SocketIO.EngineSocket.prototype.readyState;
 /** @type {string} */
SocketIO.EngineSocket.prototype.remoteAddress;
 /** @type {boolean} */
SocketIO.EngineSocket.prototype.upgraded;
 /** @type {?} */
SocketIO.EngineSocket.prototype.request;
 /** @type {?} */
SocketIO.EngineSocket.prototype.transport;
