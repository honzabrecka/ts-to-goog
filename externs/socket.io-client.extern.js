/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/socket.io-client/index.d.ts:
 /** @type {!SocketIOClientStatic} */
var io;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "socket.io-client"
/** @const */
tsickle_declare_module.socket_io_client = {};

/* TODO: ExportAssignment in tsickle_declare_module.socket_io_client */
/**
 * @record
 * @struct
 */
function SocketIOClientStatic() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
 /** @type {number} */
SocketIOClientStatic.prototype.protocol;
 /** @type {!SocketIOClient.Socket} */
SocketIOClientStatic.prototype.Socket;
 /** @type {!SocketIOClient.ManagerStatic} */
SocketIOClientStatic.prototype.Manager;

/**
 * @see the default constructor (io(uri, opts))
 * @see the default constructor (io(opts))
 * @param {string|!SocketIOClient.ConnectOpts=} uri_or_opts
 * @param {!SocketIOClient.ConnectOpts=} opts
 * @return {!SocketIOClient.Socket}
 */
SocketIOClientStatic.prototype.connect = function(uri_or_opts, opts) {};
/** @const */
var SocketIOClient = {};
/**
 * @record
 * @struct
 */
SocketIOClient.Emitter = function() {};

/**
 * Adds a listener for a particular event. Calling multiple times will add
 * multiple listeners
 * @param {string} event The event that we're listening for
 * @param {!Function} fn The function to call when we get the event. Parameters depend on the
 * event in question
 * @return {!SocketIOClient.Emitter} This Emitter
 */
SocketIOClient.Emitter.prototype.on = function(event, fn) {};

/**
 * @see on( event, fn )
 * @param {string} event
 * @param {!Function} fn
 * @return {!SocketIOClient.Emitter}
 */
SocketIOClient.Emitter.prototype.addEventListener = function(event, fn) {};

/**
 * Adds a listener for a particular event that will be invoked
 * a single time before being automatically removed
 * @param {string} event The event that we're listening for
 * @param {!Function} fn The function to call when we get the event. Parameters depend on
 * the event in question
 * @return {!SocketIOClient.Emitter} This Emitter
 */
SocketIOClient.Emitter.prototype.once = function(event, fn) {};

/**
 * Removes a listener for a particular type of event. This will either
 * remove a specific listener, or all listeners for this type of event
 * @param {string} event The event that we want to remove the listener of
 * @param {!Function=} fn The function to remove, or null if we want to remove all functions
 * @return {!SocketIOClient.Emitter} This Emitter
 */
SocketIOClient.Emitter.prototype.off = function(event, fn) {};

/**
 * @see off( event, fn )
 * @param {string} event
 * @param {!Function=} fn
 * @return {!SocketIOClient.Emitter}
 */
SocketIOClient.Emitter.prototype.removeListener = function(event, fn) {};

/**
 * @see off( event, fn )
 * @param {string} event
 * @param {!Function=} fn
 * @return {!SocketIOClient.Emitter}
 */
SocketIOClient.Emitter.prototype.removeEventListener = function(event, fn) {};

/**
 * Removes all event listeners on this object
 * @return {!SocketIOClient.Emitter} This Emitter
 */
SocketIOClient.Emitter.prototype.removeAllListeners = function() {};

/**
 * Emits 'event' with the given args
 * @param {string} event The event that we want to emit
 * @param {...?} args Optional arguments to emit with the event
 * @return {!SocketIOClient.Emitter} Emitter
 */
SocketIOClient.Emitter.prototype.emit = function(event, args) {};

/**
 * Returns all the callbacks for a particular event
 * @param {string} event The event that we're looking for the callbacks of
 * @return {!Array<!Function>} An array of callback Functions, or an empty array if we don't have any
 */
SocketIOClient.Emitter.prototype.listeners = function(event) {};

/**
 * Returns if we have listeners for a particular event
 * @param {string} event The event that we want to check if we've listeners for
 * @return {boolean} True if we have listeners for this event, false otherwise
 */
SocketIOClient.Emitter.prototype.hasListeners = function(event) {};
/**
 * @record
 * @struct
 */
SocketIOClient.SocketStatic = function() {};

/* TODO: CallSignature: SocketIOClient */

/* TODO: ConstructSignature: SocketIOClient */
/**
 * @extends {SocketIOClient.Emitter}
 * @record
 * @struct
 */
SocketIOClient.Socket = function() {};
 /** @type {!SocketIOClient.Manager} */
SocketIOClient.Socket.prototype.io;
 /** @type {string} */
SocketIOClient.Socket.prototype.nsp;
 /** @type {string} */
SocketIOClient.Socket.prototype.id;
 /** @type {boolean} */
SocketIOClient.Socket.prototype.connected;
 /** @type {boolean} */
SocketIOClient.Socket.prototype.disconnected;

/**
 * Opens our socket so that it connects. If the 'autoConnect' option for io is
 * true (default), then this is called automatically when the Socket is created
 * @return {!SocketIOClient.Socket}
 */
SocketIOClient.Socket.prototype.open = function() {};

/**
 * @see open();
 * @return {!SocketIOClient.Socket}
 */
SocketIOClient.Socket.prototype.connect = function() {};

/**
 * Sends a 'message' event
 * @see emit
 * @param {...?} args Any optional arguments that we want to send
 * @return {!SocketIOClient.Socket} This Socket
 */
SocketIOClient.Socket.prototype.send = function(args) {};

/**
 * An override of the base emit. If the event is one of:
 * 	connect
 * 	connect_error
 * 	connect_timeout
 * 	connecting
 * 	disconnect
 * 	error
 * 	reconnect
 * 	reconnect_attempt
 * 	reconnect_failed
 * 	reconnect_error
 * 	reconnecting
 * 	ping
 * 	pong
 * then the event is emitted normally. Otherwise, if we're connected, the
 * event is sent. Otherwise, it's buffered.
 * 
 * If the last argument is a function, then it will be called
 * as an 'ack' when the response is received. The parameter(s) of the
 * ack will be whatever data is returned from the event
 * @param {string} event The event that we're emitting
 * @param {...?} args Optional arguments to send with the event
 * @return {!SocketIOClient.Socket} This Socket
 */
SocketIOClient.Socket.prototype.emit = function(event, args) {};

/**
 * Disconnects the socket manually
 * @return {!SocketIOClient.Socket} This Socket
 */
SocketIOClient.Socket.prototype.close = function() {};

/**
 * @see close()
 * @return {!SocketIOClient.Socket}
 */
SocketIOClient.Socket.prototype.disconnect = function() {};

/**
 * Sets the compress flag.
 * @param {boolean} compress If `true`, compresses the sending data
 * @return {!SocketIOClient.Socket} this Socket
 */
SocketIOClient.Socket.prototype.compress = function(compress) {};
/**
 * @record
 * @struct
 */
SocketIOClient.ManagerStatic = function() {};

/* TODO: CallSignature: SocketIOClient */

/* TODO: CallSignature: SocketIOClient */

/* TODO: ConstructSignature: SocketIOClient */

/* TODO: ConstructSignature: SocketIOClient */
/**
 * @extends {SocketIOClient.Emitter}
 * @record
 * @struct
 */
SocketIOClient.Manager = function() {};
 /** @type {!Object<string,!SocketIOClient.Socket>} */
SocketIOClient.Manager.prototype.nsps;
 /** @type {!SocketIOClient.ConnectOpts} */
SocketIOClient.Manager.prototype.opts;
 /** @type {string} */
SocketIOClient.Manager.prototype.readyState;
 /** @type {string} */
SocketIOClient.Manager.prototype.uri;
 /** @type {!Array<!SocketIOClient.Socket>} */
SocketIOClient.Manager.prototype.connecting;
 /** @type {boolean} */
SocketIOClient.Manager.prototype.autoConnect;

/**
 * Gets if we should reconnect automatically
 * \@default true
 * Sets if we should reconnect automatically
 * \@default true
 * @param {boolean=} v True if we should reconnect automatically, false otherwise
 * @return {boolean|!SocketIOClient.Manager} This Manager
 */
SocketIOClient.Manager.prototype.reconnection = function(v) {};

/**
 * Gets the number of reconnection attempts we should try before giving up
 * \@default Infinity
 * Sets the number of reconnection attempts we should try before giving up
 * \@default Infinity
 * @param {number=} v The number of attempts we should do before giving up
 * @return {number|!SocketIOClient.Manager} This Manager
 */
SocketIOClient.Manager.prototype.reconnectionAttempts = function(v) {};

/**
 * Gets the delay in milliseconds between each reconnection attempt
 * \@default 1000
 * Sets the delay in milliseconds between each reconnection attempt
 * \@default 1000
 * @param {number=} v The delay in milliseconds
 * @return {number|!SocketIOClient.Manager} This Manager
 */
SocketIOClient.Manager.prototype.reconnectionDelay = function(v) {};

/**
 * Gets the max reconnection delay in milliseconds between each reconnection
 * attempt
 * \@default 5000
 * Sets the max reconnection delay in milliseconds between each reconnection
 * attempt
 * @param {number=} v The max reconnection dleay in milliseconds
 * @return {number|!SocketIOClient.Manager} This Manager
 */
SocketIOClient.Manager.prototype.reconnectionDelayMax = function(v) {};

/**
 * Gets the randomisation factor used in the exponential backoff jitter
 * when reconnecting
 * \@default 0.5
 * Sets the randomisation factor used in the exponential backoff jitter
 * when reconnecting
 * \@default 0.5
 * @param {number=} v
 * @return {number|!SocketIOClient.Manager} This Manager
 */
SocketIOClient.Manager.prototype.randomizationFactor = function(v) {};

/**
 * Gets the timeout in milliseconds for our connection attempts
 * \@default 20000
 * Sets the timeout in milliseconds for our connection attempts
 * @param {number=} v
 * @return {number|!SocketIOClient.Manager} This Manager
 */
SocketIOClient.Manager.prototype.timeout = function(v) {};

/**
 * Sets the current transport socket and opens our connection
 * @param {function(?): void=} fn An optional callback to call when our socket has either opened, or
 * failed. It can take one optional parameter of type Error
 * @return {!SocketIOClient.Manager} This Manager
 */
SocketIOClient.Manager.prototype.open = function(fn) {};

/**
 * @see open( fn );
 * @param {function(?): void=} fn
 * @return {!SocketIOClient.Manager}
 */
SocketIOClient.Manager.prototype.connect = function(fn) {};

/**
 * Creates a new Socket for the given namespace
 * @param {string} nsp The namespace that this Socket is for
 * @return {!SocketIOClient.Socket} A new Socket, or if one has already been created for this namespace,
 * an existing one
 */
SocketIOClient.Manager.prototype.socket = function(nsp) {};
/**
 * @record
 * @struct
 */
SocketIOClient.ConnectOpts = function() {};
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.forceNew;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.multiplex;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.path;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.reconnection;
 /** @type {number} */
SocketIOClient.ConnectOpts.prototype.reconnectionAttempts;
 /** @type {number} */
SocketIOClient.ConnectOpts.prototype.reconnectionDelay;
 /** @type {number} */
SocketIOClient.ConnectOpts.prototype.reconnectionDelayMax;
 /** @type {number} */
SocketIOClient.ConnectOpts.prototype.randomizationFactor;
 /** @type {number} */
SocketIOClient.ConnectOpts.prototype.timeout;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.autoConnect;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.host;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.hostname;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.secure;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.port;
 /** @type {!Object} */
SocketIOClient.ConnectOpts.prototype.query;
 /** @type {(string|boolean)} */
SocketIOClient.ConnectOpts.prototype.agent;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.upgrade;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.forceJSONP;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.jsonp;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.forceBase64;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.enablesXDR;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.timestampParam;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.timestampRequests;
 /** @type {!Array<string>} */
SocketIOClient.ConnectOpts.prototype.transports;
 /** @type {number} */
SocketIOClient.ConnectOpts.prototype.policyPost;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.rememberUpgrade;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.onlyBinaryUpgrades;
 /** @type {!Object} */
SocketIOClient.ConnectOpts.prototype.extraHeaders;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.pfx;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.key;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.passphrase;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.cert;
 /** @type {(string|!Array<string>)} */
SocketIOClient.ConnectOpts.prototype.ca;
 /** @type {string} */
SocketIOClient.ConnectOpts.prototype.ciphers;
 /** @type {boolean} */
SocketIOClient.ConnectOpts.prototype.rejectUnauthorized;
