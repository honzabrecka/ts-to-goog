/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/restify/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */
/**
 * @record
 * @struct
 */
function BunyanOptions() {}
 /** @type {?} */
BunyanOptions.prototype.properties;
 /** @type {?} */
BunyanOptions.prototype.serializers;
 /** @type {?} */
BunyanOptions.prototype.headers;
 /** @type {!Logger} */
BunyanOptions.prototype.log;
/**
 * @record
 * @struct
 */
function ServerOptions() {}
 /** @type {?} */
ServerOptions.prototype.ca;
 /** @type {?} */
ServerOptions.prototype.certificate;
 /** @type {?} */
ServerOptions.prototype.key;
 /** @type {string} */
ServerOptions.prototype.passphrase;
 /** @type {boolean} */
ServerOptions.prototype.requestCert;
 /** @type {string} */
ServerOptions.prototype.ciphers;
 /** @type {?} */
ServerOptions.prototype.formatters;
 /** @type {!Logger} */
ServerOptions.prototype.log;
 /** @type {string} */
ServerOptions.prototype.name;
 /** @type {?} */
ServerOptions.prototype.spdy;
 /** @type {string} */
ServerOptions.prototype.version;
 /** @type {!Array<string>} */
ServerOptions.prototype.versions;
 /** @type {boolean} */
ServerOptions.prototype.handleUpgrades;
 /** @type {?} */
ServerOptions.prototype.httpsServerOptions;
 /** @type {boolean} */
ServerOptions.prototype.handleUncaughtExceptions;
 /** @type {?} */
ServerOptions.prototype.router;
 /** @type {boolean} */
ServerOptions.prototype.socketio;
 /** @type {boolean} */
ServerOptions.prototype.noWriteContinue;
 /** @type {boolean} */
ServerOptions.prototype.rejectUnauthorized;
/**
 * @record
 * @struct
 */
function AddressInterface() {}
 /** @type {number} */
AddressInterface.prototype.port;
 /** @type {string} */
AddressInterface.prototype.family;
 /** @type {string} */
AddressInterface.prototype.address;

/**
 * @constructor
 * @struct
 * Creates a new Server.
 * @param {?=} options
 */
function Server(options) {}
 /** @type {string} */
Server.prototype.name;
 /** @type {!Array<string>} */
Server.prototype.versions;
 /** @type {!Logger} */
Server.prototype.log;
 /** @type {!Array<string>} */
Server.prototype.acceptable;
 /** @type {string} */
Server.prototype.url;

/**
 * Returns the server address. Wraps node's address().
 * @return {?}
 */
Server.prototype.address = function() {};

/**
 * Gets the server up and listening. Wraps node's listen().
 * 
 * You can call like:
 *  server.listen(80)
 *  server.listen(80, '127.0.0.1')
 *  server.listen('/tmp/server.sock')
 * 
 * @throws {TypeError}
 * @param {...?} args
 * @return {?}
 */
Server.prototype.listen = function(args) {};

/**
 * Shuts down this server, and invokes callback (optionally) when done.
 * Wraps node's close().
 * @param {...?} args
 * @return {?}
 */
Server.prototype.close = function(args) {};

/**
 * Returns the number of currently inflight requests.
 * @return {number}
 */
Server.prototype.inflightRequests = function() {};

/**
 * Mounts a chain on the given path against this HTTP verb
 * 
 *                                 if options, the URL to handle, at minimum.
 * @param {(string|!RegExp|?)} opts
 * @param {...(?|!Array<?>)} handlers
 * @return {(boolean|?)}
 */
Server.prototype.del = function(opts, handlers) {};

/**
 * Mounts a chain on the given path against this HTTP verb
 * 
 *                                 if options, the URL to handle, at minimum.
 * @param {(string|!RegExp|?)} opts
 * @param {...(?|!Array<?>)} handlers
 * @return {(boolean|?)}
 */
Server.prototype.get = function(opts, handlers) {};

/**
 * Mounts a chain on the given path against this HTTP verb
 * 
 *                                 if options, the URL to handle, at minimum.
 * @param {(string|!RegExp|?)} opts
 * @param {...(?|!Array<?>)} handlers
 * @return {(boolean|?)}
 */
Server.prototype.head = function(opts, handlers) {};

/**
 * Mounts a chain on the given path against this HTTP verb
 * 
 *                                 if options, the URL to handle, at minimum.
 * @param {(string|!RegExp|?)} opts
 * @param {...(?|!Array<?>)} handlers
 * @return {(boolean|?)}
 */
Server.prototype.opts = function(opts, handlers) {};

/**
 * Mounts a chain on the given path against this HTTP verb
 * 
 *                                 if options, the URL to handle, at minimum.
 * @param {(string|!RegExp|?)} opts
 * @param {...(?|!Array<?>)} handlers
 * @return {(boolean|?)}
 */
Server.prototype.post = function(opts, handlers) {};

/**
 * Mounts a chain on the given path against this HTTP verb
 * 
 *                                 if options, the URL to handle, at minimum.
 * @param {(string|!RegExp|?)} opts
 * @param {...(?|!Array<?>)} handlers
 * @return {(boolean|?)}
 */
Server.prototype.put = function(opts, handlers) {};

/**
 * Mounts a chain on the given path against this HTTP verb
 * 
 *                                 if options, the URL to handle, at minimum.
 * @param {(string|!RegExp|?)} opts
 * @param {...(?|!Array<?>)} handlers
 * @return {(boolean|?)}
 */
Server.prototype.patch = function(opts, handlers) {};

/**
 * Minimal port of the functionality offered by Express.js Route Param
 * Pre-conditions
 * @link http://expressjs.com/guide.html#route-param%20pre-conditions
 * 
 * This basically piggy-backs on the `server.use` method. It attaches a
 * new middleware function that only fires if the specified parameter exists
 * in req.params
 * 
 * Exposes an API:
 *   server.param("user", function (req, res, next) {
 *     // load the user's information here, always making sure to call next()
 *   });
 * 
 * @param {string} name
 * @param {?} fn
 * @return {?}
 */
Server.prototype.param = function(name, fn) {};

/**
 * Piggy-backs on the `server.use` method. It attaches a new middleware
 * function that only fires if the specified version matches the request.
 * 
 * Note that if the client does not request a specific version, the middleware
 * function always fires. If you don't want this set a default version with a
 * pre handler on requests where the client omits one.
 * 
 * Exposes an API:
 *   server.versionedUse("version", function (req, res, next, ver) {
 *     // do stuff that only applies to routes of this API version
 *   });
 * 
 *                                   fourth parameter will be the selected
 *                                   version
 * @param {(string|!Array<string>)} versions
 * @param {?} fn
 * @return {?}
 */
Server.prototype.versionedUse = function(versions, fn) {};

/**
 * Removes a route from the server.
 * You pass in the route 'blob' you got from a mount call.
 * @throws {TypeError} on bad input.
 * @param {string} route
 * @return {boolean}
 */
Server.prototype.rm = function(route) {};

/**
 * Installs a list of handlers to run _before_ the "normal" handlers of all
 * routes.
 * 
 * You can pass in any combination of functions or array of functions.
 * @param {...(?|!Array<?>)} handlers
 * @return {?}
 */
Server.prototype.use = function(handlers) {};

/**
 * Gives you hooks to run _before_ any routes are located.  This gives you
 * a chance to intercept the request and change headers, etc., that routing
 * depends on.  Note that req.params will _not_ be set yet.
 * @param {...(?|!Array<?>)} pre
 * @return {?}
 */
Server.prototype.pre = function(pre) {};

/**
 * toString() the server for easy reading/output.
 * @return {string}
 */
Server.prototype.toString = function() {};

/**
 * Return debug information about the server.
 * \@method getDebugInfo
 * @return {?}
 */
Server.prototype.getDebugInfo = function() {};
/**
 * @record
 * @struct
 */
function RouterOptions() {}
 /** @type {(string|!Array<string>)} */
RouterOptions.prototype.contentType;
 /** @type {boolean} */
RouterOptions.prototype.strictRouting;
 /** @type {!Logger} */
RouterOptions.prototype.log;
 /** @type {string} */
RouterOptions.prototype.version;
 /** @type {!Array<string>} */
RouterOptions.prototype.versions;

/**
 * @constructor
 * @struct
 * @param {?} options
 */
function Router(options) {}
 /** @type {string} */
Router.prototype.name;
 /** @type {?} */
Router.prototype.mounts;
 /** @type {!Array<string>} */
Router.prototype.versions;
 /** @type {!Array<string>} */
Router.prototype.contentType;
 /** @type {?} */
Router.prototype.routes;
 /** @type {!Logger} */
Router.prototype.log;

/**
 * takes an object of route params and query params, and 'renders' a URL.
 * @param {string} routeName
 * @param {?} params
 * @param {?=} query
 * @return {string}
 */
Router.prototype.render = function(routeName, params, query) {};

/**
 * adds a route.
 * @param {?} options
 * @return {(string|boolean)}
 */
Router.prototype.mount = function(options) {};

/**
 * unmounts a route.
 * @param {string} name
 * @return {string}
 */
Router.prototype.unmount = function(name) {};

/**
 * get a route from the router.
 * @param {string} name
 * @param {?} req
 * @param {?} cb
 * @return {void}
 */
Router.prototype.get = function(name, req, cb) {};

/**
 * find a route from inside the router, handles versioned routes.
 * @param {?} req
 * @param {?} res
 * @param {?} callback
 * @return {void}
 */
Router.prototype.find = function(req, res, callback) {};

/**
 * Find a route by path. Scans the route list for a route with the same RegEx.
 * i.e. /foo/:param1/:param2 would match an existing route with different
 * parameter names /foo/:id/:name since the compiled RegExs match.
 * @param {(string|!RegExp)} path
 * @return {?}
 */
Router.prototype.findByPath = function(path) {};

/**
 * toString() serialization.
 * @return {string}
 */
Router.prototype.toString = function() {};

/**
 * Return information about the routes registered in the router.
 * @return {?}
 */
Router.prototype.getDebugInfo = function() {};
/**
 * @record
 * @struct
 */
function RequestFileInterface() {}
 /** @type {string} */
RequestFileInterface.prototype.path;
 /** @type {string} */
RequestFileInterface.prototype.type;
/**
 * @record
 * @struct
 */
function RequestAuthorization() {}
 /** @type {string} */
RequestAuthorization.prototype.scheme;
 /** @type {string} */
RequestAuthorization.prototype.credentials;
 /** @type {?} */
RequestAuthorization.prototype.basic;
/**
 * @record
 * @struct
 */
function Request() {}
 /** @type {!Logger} */
Request.prototype.log;
 /** @type {?} */
Request.prototype.query;
 /** @type {?} */
Request.prototype.body;
 /** @type {?} */
Request.prototype.params;
 /** @type {?} */
Request.prototype.files;
 /** @type {string} */
Request.prototype.username;
 /** @type {?} */
Request.prototype.authorization;

/**
 * checks if the accept header is present and has the value requested.
 * e.g., req.accepts('html');
 * @param {(string|!Array<string>)} types
 * @return {boolean}
 */
Request.prototype.accepts = function(types) {};

/**
 * checks if the request accepts the encoding types.
 * @param {(string|!Array<string>)} types
 * @return {boolean}
 */
Request.prototype.acceptsEncoding = function(types) {};

/**
 * gets the content-length header off the request.
 * @return {number}
 */
Request.prototype.getContentLength = function() {};

/**
 * pass through to getContentLength.
 * @return {number}
 */
Request.prototype.contentLength = function() {};

/**
 * gets the content-type header.
 * @return {string}
 */
Request.prototype.getContentType = function() {};

/**
 * pass through to getContentType.
 * @return {string}
 */
Request.prototype.contentType = function() {};

/**
 * retrieves the complete URI requested by the client.
 * @return {string}
 */
Request.prototype.getHref = function() {};

/**
 * pass through to getHref.
 * @return {string}
 */
Request.prototype.href = function() {};

/**
 * retrieves the request uuid. was created when the request was setup.
 * @return {string}
 */
Request.prototype.getId = function() {};

/**
 * pass through to getId.
 * @return {string}
 */
Request.prototype.id = function() {};

/**
 * retrieves the cleaned up url path.
 * e.g., /foo?a=1  =>  /foo
 * @return {string}
 */
Request.prototype.getPath = function() {};

/**
 * pass through to getPath.
 * @return {string}
 */
Request.prototype.path = function() {};

/**
 * returns the raw query string
 * @return {string}
 */
Request.prototype.getQuery = function() {};

/**
 * returns ms since epoch when request was setup.
 * @return {number}
 */
Request.prototype.time = function() {};

/**
 * returns a parsed URL object.
 * @return {!Url}
 */
Request.prototype.getUrl = function() {};

/**
 * returns the accept-version header.
 * @return {string}
 */
Request.prototype.getVersion = function() {};

/**
 * pass through to getVersion.
 * @return {string}
 */
Request.prototype.version = function() {};

/**
 * returns the version of the route that matched.
 * @return {string}
 */
Request.prototype.matchedVersion = function() {};

/**
 * returns any header off the request. also, 'correct' any
 * correctly spelled 'referrer' header to the actual spelling used.
 * @param {string} name
 * @param {string=} value
 * @return {string}
 */
Request.prototype.header = function(name, value) {};

/**
 * returns any trailer header off the request. also, 'correct' any
 * correctly spelled 'referrer' header to the actual spelling used.
 * @param {string} name
 * @param {string=} value
 * @return {string}
 */
Request.prototype.trailer = function(name, value) {};

/**
 * Check if the incoming request contains the Content-Type header field, and
 * if it contains the given mime type.
 * @param {string} type
 * @return {boolean}
 */
Request.prototype.is = function(type) {};

/**
 * Check if the incoming request is chunked.
 * @return {boolean}
 */
Request.prototype.isChunked = function() {};

/**
 * Check if the incoming request is kept alive.
 * @return {boolean}
 */
Request.prototype.isKeepAlive = function() {};

/**
 * Check if the incoming request is encrypted.
 * @return {boolean}
 */
Request.prototype.isSecure = function() {};

/**
 * Check if the incoming request has been upgraded.
 * @return {boolean}
 */
Request.prototype.isUpgradeRequest = function() {};

/**
 * Check if the incoming request is an upload verb.
 * @return {boolean}
 */
Request.prototype.isUpload = function() {};

/**
 * toString serialization
 * @return {string}
 */
Request.prototype.toString = function() {};

/**
 * retrieves the user-agent header.
 * @return {string}
 */
Request.prototype.userAgent = function() {};

/**
 * Start the timer for a request handler function. You must explicitly invoke
 * endHandlerTimer() after invoking this function. Otherwise timing information
 * will be inaccurate.
 * @param {string} handlerName
 * @return {void}
 */
Request.prototype.startHandlerTimer = function(handlerName) {};

/**
 * Stop the timer for a request handler function.
 * @param {string} handlerName
 * @return {void}
 */
Request.prototype.endHandlerTimer = function(handlerName) {};

/**
 * returns the connection state of the request. current valid values are
 * 'close' and 'aborted'.
 * @return {string}
 */
Request.prototype.connectionState = function() {};

/**
 * returns the route object to which the current request was matched to.
 * Route info object structure:
 * {
 *  path: '/ping/:name',
 *  method: 'GET',
 *  versions: [],
 *  name: 'getpingname'
 * }
 * @return {?}
 */
Request.prototype.getRoute = function() {};
/**
 * @record
 * @struct
 */
function CacheOptions() {}
 /** @type {number} */
CacheOptions.prototype.maxAge;
/**
 * @record
 * @struct
 */
function Response() {}
 /** @type {number} */
Response.prototype.code;
 /** @type {number} */
Response.prototype.contentLength;
 /** @type {string} */
Response.prototype.contentType;
 /** @type {?} */
Response.prototype.headers;
 /** @type {string} */
Response.prototype.id;

/**
 * sets the cache-control header. `type` defaults to _public_,
 * and options currently only takes maxAge.
 * sets the cache-control header. `type` defaults to _public_,
 * and options currently only takes maxAge.
 * @param {string|?=} type_or_options
 * @param {?=} options
 * @return {string}
 */
Response.prototype.cache = function(type_or_options, options) {};

/**
 * turns off all cache related headers.
 * @return {?}
 */
Response.prototype.noCache = function() {};

/**
 * Appends the provided character set to the response's Content-Type.
 * e.g., res.charSet('utf-8');
 * @param {string} type
 * @return {?}
 */
Response.prototype.charSet = function(type) {};

/**
 * retrieves a header off the response.
 * @param {string} name
 * @return {string}
 */
Response.prototype.get = function(name) {};

/**
 * retrieves all headers off the response.
 * @return {?}
 */
Response.prototype.getHeaders = function() {};

/**
 * pass through to getHeaders.
 * @return {?}
 */
Response.prototype.headers = function() {};

/**
 * sets headers on the response.
 * @param {string} name
 * @param {?=} value
 * @return {?}
 */
Response.prototype.header = function(name, value) {};

/**
 * short hand method for:
 *     res.contentType = 'json';
 *     res.send({hello: 'world'});
 * short hand method for:
 *     res.contentType = 'json';
 *     res.send({hello: 'world'});
 * @param {number|?} code_or_object
 * @param {?=} object_or_headers
 * @param {?=} headers
 * @return {?}
 */
Response.prototype.json = function(code_or_object, object_or_headers, headers) {};

/**
 * sets the link heaader.
 * @param {string} l
 * @param {string} rel
 * @return {string}
 */
Response.prototype.link = function(l, rel) {};

/**
 * sends the response object. pass through to internal __send that uses a
 * formatter based on the content-type header.
 * @param {?=} code
 * @param {?=} body
 * @param {?=} headers
 * @return {?}
 */
Response.prototype.send = function(code, body, headers) {};

/**
 * sends the response object. pass through to internal __send that skips
 * formatters entirely and sends the content as is.
 * @param {?=} code
 * @param {?=} body
 * @param {?=} headers
 * @return {?}
 */
Response.prototype.sendRaw = function(code, body, headers) {};

/**
 * sets a header on the response.
 * @param {string} name
 * @param {string} val
 * @return {?}
 */
Response.prototype.set = function(name, val) {};

/**
 * sets the http status code on the response.
 * @param {number} code
 * @return {number}
 */
Response.prototype.status = function(code) {};

/**
 * toString() serialization.
 * @return {string}
 */
Response.prototype.toString = function() {};

/**
 * pass through to native response.writeHead().
 * \@emits header
 * @return {void}
 */
Response.prototype.writeHead = function() {};

/**
 * redirect is sugar method for redirecting.
 * res.redirect(301, 'www.foo.com', next);
 * `next` is mandatory, to complete the response and trigger audit logger.
 * \@emits redirect
 * redirect is sugar method for redirecting.
 * res.redirect({...}, next);
 * `next` is mandatory, to complete the response and trigger audit logger.
 * \@emits redirect
 * @param {number|?} code_or_options
 * @param {string|?} url_or_next
 * @param {?=} next
 * @return {void}
 */
Response.prototype.redirect = function(code_or_options, url_or_next, next) {};
/**
 * @record
 * @struct
 */
function Next() {}

/* TODO: CallSignature:  */

/**
 * @param {?=} err
 * @return {void}
 */
Next.prototype.ifError = function(err) {};
/**
 * @record
 * @struct
 */
function RoutePathRegex() {}
 /** @type {!Array<string>} */
RoutePathRegex.prototype.restifyParams;
/**
 * @record
 * @struct
 */
function RouteSpec() {}
 /** @type {string} */
RouteSpec.prototype.method;
 /** @type {string} */
RouteSpec.prototype.name;
 /** @type {(string|!RegExp)} */
RouteSpec.prototype.path;
 /** @type {!Array<string>} */
RouteSpec.prototype.versions;
/**
 * @record
 * @struct
 */
function Route() {}
 /** @type {string} */
Route.prototype.name;
 /** @type {string} */
Route.prototype.method;
 /** @type {?} */
Route.prototype.path;
 /** @type {?} */
Route.prototype.spec;
 /** @type {!Array<string>} */
Route.prototype.types;
 /** @type {!Array<string>} */
Route.prototype.versions;
/**
 * @record
 * @struct
 */
function RouteOptions() {}
 /** @type {string} */
RouteOptions.prototype.name;
 /** @type {(string|!RegExp)} */
RouteOptions.prototype.path;
 /** @type {(string|!RegExp)} */
RouteOptions.prototype.url;
 /** @type {!RegExp} */
RouteOptions.prototype.urlParamPattern;
 /** @type {(string|!Array<string>)} */
RouteOptions.prototype.contentType;
 /** @type {string} */
RouteOptions.prototype.version;
 /** @type {!Array<string>} */
RouteOptions.prototype.versions;
/**
 * @record
 * @struct
 */
function MountOptions() {}
 /** @type {string} */
MountOptions.prototype.name;
 /** @type {string} */
MountOptions.prototype.method;
 /** @type {(string|!RegExp)} */
MountOptions.prototype.path;
 /** @type {(string|!RegExp)} */
MountOptions.prototype.url;
 /** @type {!RegExp} */
MountOptions.prototype.urlParamPattern;
 /** @type {(string|!Array<string>)} */
MountOptions.prototype.contentType;
 /** @type {string} */
MountOptions.prototype.version;
 /** @type {!Array<string>} */
MountOptions.prototype.versions;

/** @typedef {?} */
var FindRouteCallback;

/** @typedef {?} */
var RequestHandler;

/** @typedef {(?|!Array<?>)} */
var RequestHandlerType;

/**
 * @param {?=} options
 * @return {?}
 */
function bunyan(options) {}

/**
 * @param {?=} options
 * @return {?}
 */
function createServer(options) {}
 /** @type {?} */
var formatters;
/** @const */
var plugins = {};
/** @const */
plugins.pre = {};

/**
 * Provide req.set(key, val) and req.get(key) methods for setting and retrieving context to a specific request.
 * @return {?}
 */
plugins.pre.context = function() {};

/**
 *
 * @return {?}
 */
plugins.pre.dedupeSlashes = function() {};

/**
 * This pre handler fixes issues with node hanging when an asyncHandler is used prior to bodyParser.
 * @return {?}
 */
plugins.pre.pause = function() {};

/**
 * Cleans up duplicate or trailing / on the URL
 * @return {?}
 */
plugins.pre.sanitizePath = function() {};

/**
 * Automatically reuse incoming request header as the request id.
 * @param {?} options
 * @return {?}
 */
plugins.pre.reqIdHeaders = function(options) {};

/**
 * Checks req.urls query params with strict key/val format and rejects non-strict requests with status code 400.
 * @param {?=} options
 * @return {?}
 */
plugins.pre.strictQueryParams = function(options) {};

/**
 * Regexp to capture curl user-agents
 * @param {?=} options
 * @return {?}
 */
plugins.pre.userAgentConnection = function(options) {};

/**
 * Check the client's Accept header can be handled by this server.
 * @param {!Array<string>} accepts
 * @return {?}
 */
plugins.acceptParser = function(accepts) {};
/**
 * @record
 * @struct
 */
plugins.AuditLoggerOptions = function() {};
 /** @type {!Logger} */
plugins.AuditLoggerOptions.prototype.log;
 /** @type {string} */
plugins.AuditLoggerOptions.prototype.event;
 /** @type {?} */
plugins.AuditLoggerOptions.prototype.server;
 /** @type {?} */
plugins.AuditLoggerOptions.prototype.logBuffer;
 /** @type {boolean} */
plugins.AuditLoggerOptions.prototype.printLog;
 /** @type {boolean} */
plugins.AuditLoggerOptions.prototype.body;

/**
 * An audit logger for recording all handled requests
 * @param {?} options
 * @return {?}
 */
plugins.auditLogger = function(options) {};

/**
 * Authorization header
 * @param {?=} options
 * @return {?}
 */
plugins.authorizationParser = function(options) {};

/**
 * Conditional headers (If-*)
 * @return {!Array<?>}
 */
plugins.conditionalRequest = function() {};

/**
 * Handles disappeared CORS headers
 * @return {?}
 */
plugins.fullResponse = function() {};
/**
 * @record
 * @struct
 */
plugins.BodyParserOptions = function() {};
 /** @type {number} */
plugins.BodyParserOptions.prototype.maxBodySize;
 /** @type {boolean} */
plugins.BodyParserOptions.prototype.mapParams;
 /** @type {boolean} */
plugins.BodyParserOptions.prototype.mapFiles;
 /** @type {boolean} */
plugins.BodyParserOptions.prototype.overrideParams;
 /** @type {boolean} */
plugins.BodyParserOptions.prototype.keepExtensions;
 /** @type {string} */
plugins.BodyParserOptions.prototype.uploadDir;
 /** @type {boolean} */
plugins.BodyParserOptions.prototype.multiples;
 /** @type {string} */
plugins.BodyParserOptions.prototype.hash;
 /** @type {boolean} */
plugins.BodyParserOptions.prototype.rejectUnknown;
 /** @type {?} */
plugins.BodyParserOptions.prototype.reviver;
 /** @type {number} */
plugins.BodyParserOptions.prototype.maxFieldsSize;

/**
 * A callback to handle any multipart part which is not a file.
 * If this is omitted, the default handler is invoked which may or may not map the parts into req.params, depending on the mapParams-option.
 * @return {void}
 */
plugins.BodyParserOptions.prototype.multipartHandler = function() {};

/**
 * A callback to handle any multipart file.
 * It will be a file if the part have a Content-Disposition with the filename parameter set.
 * This typically happens when a browser sends a form and there is a parameter similar to <input type="file" />.
 * If this is not provided, the default behaviour is to map the contents into req.params.
 * @return {void}
 */
plugins.BodyParserOptions.prototype.multipartFileHandler = function() {};

/**
 * Parses POST bodies to req.body. automatically uses one of the following parsers based on content type.
 * @param {?=} options
 * @return {!Array<?>}
 */
plugins.bodyParser = function(options) {};

/**
 * Reads the body of the request.
 * @param {?=} options
 * @return {?}
 */
plugins.bodyReader = function(options) {};
/**
 * @record
 * @struct
 */
plugins.UrlEncodedBodyParser = function() {};
 /** @type {boolean} */
plugins.UrlEncodedBodyParser.prototype.mapParams;
 /** @type {boolean} */
plugins.UrlEncodedBodyParser.prototype.overrideParams;

/**
 * Parse the HTTP request body IFF the contentType is application/x-www-form-urlencoded.
 * 
 * If req.params already contains a given key, that key is skipped and an
 * error is logged.
 * @param {?=} options
 * @return {!Array<?>}
 */
plugins.urlEncodedBodyParser = function(options) {};

/**
 * Parses JSON POST bodies
 * @param {?=} options
 * @return {!Array<?>}
 */
plugins.jsonBodyParser = function(options) {};

/**
 * Parses JSONP callback
 * @return {?}
 */
plugins.jsonp = function() {};
/**
 * @record
 * @struct
 */
plugins.MultipartBodyParser = function() {};
 /** @type {boolean} */
plugins.MultipartBodyParser.prototype.overrideParams;
 /** @type {boolean} */
plugins.MultipartBodyParser.prototype.multiples;
 /** @type {boolean} */
plugins.MultipartBodyParser.prototype.keepExtensions;
 /** @type {string} */
plugins.MultipartBodyParser.prototype.uploadDir;
 /** @type {number} */
plugins.MultipartBodyParser.prototype.maxFieldsSize;
 /** @type {string} */
plugins.MultipartBodyParser.prototype.hash;
 /** @type {?} */
plugins.MultipartBodyParser.prototype.multipartFileHandler;
 /** @type {?} */
plugins.MultipartBodyParser.prototype.multipartHandler;
 /** @type {boolean} */
plugins.MultipartBodyParser.prototype.mapParams;
 /** @type {boolean} */
plugins.MultipartBodyParser.prototype.mapFiles;

/**
 * Parses JSONP callback
 * @param {?=} options
 * @return {?}
 */
plugins.multipartBodyParser = function(options) {};
/**
 * @record
 * @struct
 */
plugins.QueryParserOptions = function() {};
 /** @type {boolean} */
plugins.QueryParserOptions.prototype.mapParams;
 /** @type {boolean} */
plugins.QueryParserOptions.prototype.overrideParams;
 /** @type {boolean} */
plugins.QueryParserOptions.prototype.allowDots;
 /** @type {number} */
plugins.QueryParserOptions.prototype.arrayLimit;
 /** @type {number} */
plugins.QueryParserOptions.prototype.depth;
 /** @type {number} */
plugins.QueryParserOptions.prototype.parameterLimit;
 /** @type {boolean} */
plugins.QueryParserOptions.prototype.parseArrays;
 /** @type {boolean} */
plugins.QueryParserOptions.prototype.plainObjects;
 /** @type {boolean} */
plugins.QueryParserOptions.prototype.strictNullHandling;

/**
 * Parses URL query paramters into `req.query`. Many options correspond directly to option defined for the underlying [qs.parse](https://github.com/ljharb/qs)
 * @param {?=} options
 * @return {?}
 */
plugins.queryParser = function(options) {};
/**
 * @record
 * @struct
 */
plugins.RequestLogger = function() {};
 /** @type {?} */
plugins.RequestLogger.prototype.properties;
 /** @type {?} */
plugins.RequestLogger.prototype.serializers;
 /** @type {?} */
plugins.RequestLogger.prototype.headers;
 /** @type {?} */
plugins.RequestLogger.prototype.log;

/**
 * Adds timers for each handler in your request chain
 * 
 * `options.properties` properties to pass to bunyan's `log.child()` method
 * @param {?=} options
 * @return {?}
 */
plugins.requestLogger = function(options) {};

/**
 * expires requests based on current time + delta
 * @param {number=} delta - age in seconds
 * @return {?}
 */
plugins.dateParser = function(delta) {};

/**
 * gzips the response if client send `accept-encoding: gzip`
 * @param {?=} options options to pass to gzlib
 * @return {?}
 */
plugins.gzipResponse = function(options) {};
/**
 * @record
 * @struct
 */
plugins.ServeStatic = function() {};
 /** @type {boolean} */
plugins.ServeStatic.prototype.appendRequestPath;
 /** @type {string} */
plugins.ServeStatic.prototype.directory;
 /** @type {number} */
plugins.ServeStatic.prototype.maxAge;
 /** @type {?} */
plugins.ServeStatic.prototype.match;
 /** @type {string} */
plugins.ServeStatic.prototype.charSet;
 /** @type {string} */
plugins.ServeStatic.prototype.file;
 /** @type {string} */
plugins.ServeStatic.prototype.etag;
 /** @type {?} */
plugins.ServeStatic.prototype.default;
 /** @type {boolean} */
plugins.ServeStatic.prototype.gzip;

/**
 * Used to serve static files
 * @param {?=} options
 * @return {?}
 */
plugins.serveStatic = function(options) {};
/**
 * @record
 * @struct
 */
plugins.ThrottleOptions = function() {};
 /** @type {number} */
plugins.ThrottleOptions.prototype.burst;
 /** @type {number} */
plugins.ThrottleOptions.prototype.rate;
 /** @type {boolean} */
plugins.ThrottleOptions.prototype.ip;
 /** @type {boolean} */
plugins.ThrottleOptions.prototype.username;
 /** @type {boolean} */
plugins.ThrottleOptions.prototype.xff;
 /** @type {?} */
plugins.ThrottleOptions.prototype.tokensTable;
 /** @type {number} */
plugins.ThrottleOptions.prototype.maxKeys;
 /** @type {?} */
plugins.ThrottleOptions.prototype.overrides;
/**
 * @record
 * @struct
 */
plugins.MetricsCallback = function() {};
 /** @type {!Error} */
plugins.MetricsCallback.prototype.err;
 /** @type {?} */
plugins.MetricsCallback.prototype.metrics;
 /** @type {?} */
plugins.MetricsCallback.prototype.req;
 /** @type {?} */
plugins.MetricsCallback.prototype.res;
 /** @type {?} */
plugins.MetricsCallback.prototype.route;

/** @typedef {string} */
plugins.TMetricsCallback;
/**
 * @record
 * @struct
 */
plugins.MetricsCallbackOptions = function() {};
 /** @type {number} */
plugins.MetricsCallbackOptions.prototype.statusCode;
 /** @type {string} */
plugins.MetricsCallbackOptions.prototype.method;
 /** @type {number} */
plugins.MetricsCallbackOptions.prototype.latency;
 /** @type {string} */
plugins.MetricsCallbackOptions.prototype.path;
 /** @type {string} */
plugins.MetricsCallbackOptions.prototype.connectionState;

/**
 * Listens to the server's after event and emits information about that request (5.x compatible only).
 * 
 * ```
 * server.on('after', plugins.metrics( (err, metrics) =>
 * {
 *    // metrics is an object containing information about the request
 * }));
 * ```
 * @param {?} opts
 * @param {?} callback
 * @return {?}
 */
plugins.metrics = function(opts, callback) {};

/**
 * Parse the client's request for an OAUTH2 access tokensTable
 * 
 * Subsequent handlers will see `req.oauth2`, which looks like:
 * ```
 * {
 *    oauth2: {accessToken: 'mF_9.B5f-4.1JqM&p=q'}
 * }
 * ```
 * @return {?}
 */
plugins.oauth2TokenParser = function() {};

/**
 *  throttles responses
 * @param {?=} options
 * @return {?}
 */
plugins.throttle = function(options) {};
/**
 * @record
 * @struct
 */
plugins.RequestExpiryOptions = function() {};
 /** @type {string} */
plugins.RequestExpiryOptions.prototype.absoluteHeader;
 /** @type {string} */
plugins.RequestExpiryOptions.prototype.startHeader;
 /** @type {string} */
plugins.RequestExpiryOptions.prototype.timeoutHeader;

/**
 * A request expiry will use headers to tell if the incoming request has expired or not.
 * 
 * There are two options for this plugin:
 *   1. Absolute Time
 *     * Time in Milliseconds since the Epoch when this request should be considered expired
 *   2. Timeout
 *     * The request start time is supplied
 *     * A timeout, in milliseconds, is given
 *     * The timeout is added to the request start time to arrive at the absolute time
 *       in which the request is considered expires
 * @param {?=} options
 * @return {?}
 */
plugins.requestExpiry = function(options) {};
/** @const */
var pre = {};

/**
 * Provide req.set(key, val) and req.get(key) methods for setting and retrieving context to a specific request.
 * @return {?}
 */
pre.context = function() {};

/**
 *
 * @return {?}
 */
pre.dedupeSlashes = function() {};

/**
 * This pre handler fixes issues with node hanging when an asyncHandler is used prior to bodyParser.
 * @return {?}
 */
pre.pause = function() {};

/**
 * Cleans up duplicate or trailing / on the URL
 * @return {?}
 */
pre.sanitizePath = function() {};

/**
 * Automatically reuse incoming request header as the request id.
 * @param {?} options
 * @return {?}
 */
pre.reqIdHeaders = function(options) {};

/**
 * Checks req.urls query params with strict key/val format and rejects non-strict requests with status code 400.
 * @param {?=} options
 * @return {?}
 */
pre.strictQueryParams = function(options) {};

/**
 * Regexp to capture curl user-agents
 * @param {?=} options
 * @return {?}
 */
pre.userAgentConnection = function(options) {};
