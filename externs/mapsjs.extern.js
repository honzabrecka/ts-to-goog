/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/mapsjs/index.d.ts:

/**
 * Clusters a set of points.
 * @param {?} options
 * @return {!Array<!Object>}
 */
function clusterPoints(options) {}

/**
 * @constructor
 * @struct
 * @param {number} minX
 * @param {number} minY
 * @param {number} maxX
 * @param {number} maxY
 */
function envelope(minX, minY, maxX, maxY) {}

/**
 * Gets the minimum x coordinate of the envelope.
 * @return {number}
 */
envelope.prototype.getMinX = function() {};

/**
 * Gets the minimum y coordinate of the envelope
 * @return {number}
 */
envelope.prototype.getMinY = function() {};

/**
 * Gets the maximum x coordinate of the envelope
 * @return {number}
 */
envelope.prototype.getMaxX = function() {};

/**
 * Gets the maximum y coordinate of the envelope
 * @return {number}
 */
envelope.prototype.getMaxY = function() {};

/**
 * Creates a new envelope from this as deep copy.
 * @return {?}
 */
envelope.prototype.clone = function() {};

/**
 * Creates a new envelope from this one plus x and y margins.
 * @param {number} marginX
 * @param {number} marginY
 * @return {?}
 */
envelope.prototype.createFromMargins = function(marginX, marginY) {};

/**
 * Create a new envelope from this one plus a bleed ratio.
 * @param {number} bleed
 * @return {?}
 */
envelope.prototype.createFromBleed = function(bleed) {};

/**
 * Gets the center point of the envelope.
 * @return {?}
 */
envelope.prototype.getCenter = function() {};

/**
 * Gets the width of the envelope.
 * @return {number}
 */
envelope.prototype.getWidth = function() {};

/**
 * Gets height of the envelope.
 * @return {number}
 */
envelope.prototype.getHeight = function() {};

/**
 * Gets area of the envelope.
 * @return {number}
 */
envelope.prototype.getArea = function() {};

/**
 * Returns the minimum and maximum coordinates of this envelope as an envObject.
 * @return {?}
 */
envelope.prototype.toObject = function() {};

/**
 * Gets upper left coordinate of this envelope.
 * @return {?}
 */
envelope.prototype.getUL = function() {};

/**
 * Gets upper right of this envelope.
 * @return {?}
 */
envelope.prototype.getUR = function() {};

/**
 * Gets lower left of this envelope.
 * @return {?}
 */
envelope.prototype.getLL = function() {};

/**
 * Gets lower right of this envelope.
 * @return {?}
 */
envelope.prototype.getLR = function() {};

/**
 * Gets the aspect of the envelope.
 * @return {number}
 */
envelope.prototype.getAspect = function() {};

/**
 * Equality comparer between this and another envelope.
 * @param {?} env
 * @return {boolean}
 */
envelope.prototype.equals = function(env) {};

/**
 * Method for casting this envelope as a string.
 * @return {string}
 */
envelope.prototype.toString = function() {};

/**
 * Create a closed geometry from this envelope.
 * @return {?}
 */
envelope.prototype.toGeometry = function() {};

/**
 * Tests whether the given point is contained within this envelope.
 * @param {?} pt
 * @return {boolean}
 */
envelope.prototype.contains = function(pt) {};

/**
 * Creates a new envelope from MapDotNet XML.
 * @param {string} xml
 * @return {?}
 */
envelope.createFromMdnXml = function(xml) {};

/**
 * Creates new envelope from two corner points.
 * @param {?} pt1
 * @param {?} pt2
 * @return {?}
 */
envelope.createFromPoints = function(pt1, pt2) {};

/**
 * Creates a new envelope from the x and y coordinates of the center 
 * point and x and y margins from the center point.
 * @param {number} centerPtX
 * @param {number} centerPtY
 * @param {number} marginX
 * @param {number} marginY
 * @return {?}
 */
envelope.createFromCenterAndMargins = function(centerPtX, centerPtY, marginX, marginY) {};

/**
 * Tests whether two given envelopes intersect.
 * @param {?} env1
 * @param {?} env2
 * @return {boolean}
 */
envelope.intersects = function(env1, env2) {};

/**
 * Creates a new envelope from the union of two given envelopes.
 * @param {?} env1
 * @param {?} env2
 * @return {?}
 */
envelope.union = function(env1, env2) {};

/**
 * @constructor
 * @struct
 * @param {boolean=} isPath
 * @param {boolean=} isClosed
 */
function geometry(isPath, isClosed) {}

/**
 * Creates a new polygon or polyline form the geometry according to
 * whether the geometry is closed.
 * @return {?}
 */
geometry.prototype.factoryPoly = function() {};

/**
 * Creates a deep copy of this geometry.
 * @return {?}
 */
geometry.prototype.clone = function() {};

/**
 * Iterates every vertex in the geometry and passes to the supplied 
 * callback. Return true from in the callback will break the iteration.
 * @param {?} action
 * @return {void}
 */
geometry.prototype.foreachVertex = function(action) {};

/**
 * Returns the geometry's bounding box as an envelope.
 * @return {?}
 */
geometry.prototype.getBounds = function() {};

/**
 * Checks whether or not this geometry is closed.
 * @return {boolean}
 */
geometry.prototype.getIsPath = function() {};

/**
 * Checks whether or not this geometry is closed.
 * @return {boolean}
 */
geometry.prototype.getIsClosed = function() {};

/**
 * Gets the number of sets in this geometry.
 * @return {number}
 */
geometry.prototype.getSetCount = function() {};

/**
 * Gets a set from this geometry's set collection by index, or, if no 
 * index is provided, gets the last set. Note: for polygons, first set
 * is primary ring and subsequent ones are holes.
 * @param {number} idx
 * @return {!Array<number>}
 */
geometry.prototype.getSet = function(idx) {};

/**
 * Adds a new set to this geometry's collection of sets.
 * @param {!Array<number>} s
 * @return {void}
 */
geometry.prototype.pushSet = function(s) {};

/**
 * Gets the last set in the geometry's set collection and removes it 
 * from the collection.
 * @return {!Array<number>}
 */
geometry.prototype.popSet = function() {};

/**
 * Creates SVG path data from this geometry if it is a path.
 * @return {string}
 */
geometry.prototype.toSvgPathData = function() {};

/**
 * Adds point to the last set in geometry's set collection. If the
 * geometry is empty, a new set is added to the geometry first.
 * the 0-based index of the set the point was added to and idx is the
 * 0-based index of the point in its set.
 * @param {?} pt
 * @return {?}
 */
geometry.prototype.addPointToLastSet = function(pt) {};

/**
 * Tests the validity of this geometry. An open path geometry is valid
 * if it has at least one set with at least two points. A closed 
 * geometry is valid if it has at least one set with at least three
 * points. A point (non-path) geometry is always valid.
 * @return {boolean}
 */
geometry.prototype.isValid = function() {};

/**
 * Creates a wkt string from this geometry.
 * @return {string}
 */
geometry.prototype.toString = function() {};

/**
 * @return {string}
 */
geometry.prototype.toWkt = function() {};

/**
 * Finds the point in this geometry nearest to the given point.
 * where setIdx is the index of the set the point is in, ptIdx is the
 * index of the point in the set, pt is the point object, and distance
 * is the distance of the point to the reference point in map units.
 * @param {?} pt
 * @return {?}
 */
geometry.prototype.findNearestVertex = function(pt) {};

/**
 * Finds point along boundary of geometry nearest to the given point
 * should be treated as a closed geometry.
 * where setIdx is the index of the set the point is in, ptIdx is the
 * index of the point in the set, pt is the point object, and distance
 * is the distance of the point to the reference point in map units.
 * @param {?} pt
 * @param {boolean=} close
 * @return {?}
 */
geometry.prototype.findNearestSegment = function(pt, close) {};

/**
 * Finds coordinates in map units of the midpoint of this geometry. If
 * this geometry is an open path, the midpoint is the midpoint of the
 * path. If this geometry is a closed path, the midpoint is the centroid
 * of the polygon. If a set index is not provided, finds the labeling
 * point for the last set in this geometry's set collection.
 * @param {number=} idx
 * @return {?}
 */
geometry.prototype.getLabelingPoint = function(idx) {};

/**
 * Tests whether this geometry contains a given point/
 * @param {?} pt
 * @return {boolean}
 */
geometry.prototype.contains = function(pt) {};

/**
 * @constructor
 * @struct
 * @param {?} geom
 */
geometry.polyline = function(geom) {};

/**
 * Gets the underlying geometry of the polyline.
 * @return {?}
 */
geometry.polyline.prototype.getGeometry = function() {};

/**
 * Creates a new polyline object from a deep copy of the underlying geometry.
 * @return {?}
 */
geometry.polyline.prototype.clone = function() {};

/**
 * Gets number of lines in this polyline.
 * @return {number}
 */
geometry.polyline.prototype.getLineCount = function() {};

/**
 * Gets a line from this polyline's liune collection by index, or, 
 * if no index is provided, gets the last line.
 * @param {number} idx
 * @return {!Array<number>}
 */
geometry.polyline.prototype.getLine = function(idx) {};

/**
 * Adds a new line to this polyline's line collection.
 * @param {!Array<number>} s
 * @return {void}
 */
geometry.polyline.prototype.pushLine = function(s) {};

/**
 * Gets the last line in the polyline's set collection and removes it 
 * from the collection.
 * @return {!Array<number>}
 */
geometry.polyline.prototype.popLine = function() {};

/**
 * Calculates distance of a line in a polyline by index according 
 * to projected map cooordinates. If no index is provided, uses
 * the last line in the polyline's set collection.
 * @param {number} idx
 * @return {number}
 */
geometry.polyline.prototype.getProjectedDistance = function(idx) {};

/**
 * Calculates distance of a line in a polyline by index according 
 * to actual distance. If no index is provided, uses the last line 
 * in the polyline's set collection.
 * @param {number=} idx
 * @return {number}
 */
geometry.polyline.prototype.getActualDistance = function(idx) {};

/**
 * Determines whether this polyline intersects a given geometry.
 * @param {?} geom
 * @return {boolean}
 */
geometry.polyline.prototype.intersects = function(geom) {};

/**
 * @constructor
 * @struct
 * @param {?} geom
 */
geometry.polygon = function(geom) {};

/**
 * Gets the underlying geometry of the polygon.
 * @return {?}
 */
geometry.polygon.prototype.getGeometry = function() {};

/**
 * Creates a new polygon object from a deep copy of the underlying geometry.
 * @return {?}
 */
geometry.polygon.prototype.clone = function() {};

/**
 * Gets number of rings in this polygon.
 * @return {number}
 */
geometry.polygon.prototype.getRingCount = function() {};

/**
 * Gets a ring from this polygon's set collection by index, or, 
 * if no index is provided, gets the last ring.
 * @param {number} idx
 * @return {!Array<number>}
 */
geometry.polygon.prototype.getRing = function(idx) {};

/**
 * Adds a new ring to this polygon's ring collection.
 * @param {!Array<number>} s
 * @return {void}
 */
geometry.polygon.prototype.pushRing = function(s) {};

/**
 * Gets the last ring in the polygon's ring collection and removes it 
 * from the collection.
 * @return {!Array<number>}
 */
geometry.polygon.prototype.popRing = function() {};

/**
 * Calculates area of a ring in a polygon by index according 
 * to projected map cooordinates. If no index is provided, uses
 * the last ring in the polygon's ring collection.
 * @param {number} idx
 * @return {number}
 */
geometry.polygon.prototype.getProjectedArea = function(idx) {};

/**
 * Calculates perimeter of a ring in a polygon by index according 
 * to projected map cooordinates. If no index is provided, uses
 * the last ring in the polygon's ring collection.
 * @param {number} idx
 * @return {number}
 */
geometry.polygon.prototype.getProjectedPerimeter = function(idx) {};

/**
 * Calculates area of a ring in a polygon by index according 
 * to the actual area. If no index is provided, uses the last ring
 * in the polygon's ring collection.
 * @param {number=} idx
 * @return {number}
 */
geometry.polygon.prototype.getActualArea = function(idx) {};

/**
 * Calculates perimeter of a ring in a polygon by index according 
 * to actual distance. If no index is provided, uses the last ring
 * in the polygon's ring collection.
 * @param {number=} idx
 * @return {number}
 */
geometry.polygon.prototype.getActualPerimeter = function(idx) {};

/**
 * Determines whether this polygon intersects a given geometry.
 * @param {?} geom
 * @return {boolean}
 */
geometry.polygon.prototype.intersects = function(geom) {};

/**
 * Determines whether this polyline overlaps a given geometry.
 * @param {?} poly
 * @return {boolean}
 */
geometry.polygon.prototype.overlaps = function(poly) {};

/**
 * Convert this polygon into an array of OGC compliant polygons where
 * the first set is a ring and all subsequent contained sets are holes.
 * @return {!Array<?>}
 */
geometry.polygon.prototype.toMultiPolygon = function() {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
function geometryStyle(options) {}

/**
 * Gets path outline thickness in pixels.
 * @return {number}
 */
geometryStyle.prototype.getOutlineThicknessPix = function() {};

/**
 * Sets path outline thickness in pixels.
 * @param {number} t
 * @return {void}
 */
geometryStyle.prototype.setOutlineThicknessPix = function(t) {};

/**
 * Gets path outline color as a CSS style string.
 * @return {string}
 */
geometryStyle.prototype.getOutlineColor = function() {};

/**
 * Sets path outline color from a CSS style string.
 * @param {string} c
 * @return {void}
 */
geometryStyle.prototype.setOutlineColor = function(c) {};

/**
 * Gets path outline opacity in decimal format.
 * @return {number}
 */
geometryStyle.prototype.getOutlineOpacity = function() {};

/**
 * Set path outline opacity to a decimal between 0 and 1.
 * @param {number} o
 * @return {void}
 */
geometryStyle.prototype.setOutlineOpacity = function(o) {};

/**
 * Gets fill color as a CSS style string.
 * @return {string}
 */
geometryStyle.prototype.getFillColor = function() {};

/**
 * Sets fill color as a CSS style string.
 * @param {string} c
 * @return {void}
 */
geometryStyle.prototype.setFillColor = function(c) {};

/**
 * Gets fill opacity in decimal format.
 * @return {number}
 */
geometryStyle.prototype.getFillOpacity = function() {};

/**
 * Sets fill opacity to a decimal between 0 and 1.
 * @param {number} o
 * @return {void}
 */
geometryStyle.prototype.setFillOpacity = function(o) {};

/**
 * Gets the dash array as a string.
 * @return {string}
 */
geometryStyle.prototype.getDashArray = function() {};

/**
 * Sets dash array string from a CSS style string. Defaults to solid
 * stroke if no dash array string is provided.
 * @param {string} da
 * @return {void}
 */
geometryStyle.prototype.setDashArray = function(da) {};
 /** @type {string} */
var license;

/**
 * @constructor
 * @struct
 * @param {number} x
 * @param {number} y
 */
function point(x, y) {}

/**
 * Returns the x coordinate.
 * @return {number}
 */
point.prototype.getX = function() {};

/**
 * Returns the y coordinate.
 * @return {number}
 */
point.prototype.getY = function() {};

/**
 * Returns the x and y coordinates of this point as a pointObject.
 * @return {?}
 */
point.prototype.toProps = function() {};

/**
 * Equality comparer between this point and a given reference point.
 * @param {?} pt
 * @return {boolean}
 */
point.prototype.equals = function(pt) {};

/**
 * Creates a point from this point offset by a given x and y distance.
 * @param {number} dx
 * @param {number} dy
 * @return {?}
 */
point.prototype.createOffsetBy = function(dx, dy) {};

/**
 * Creates new n-sided polygon around this point.
 * @param {number} side
 * @param {number} radius
 * @return {?}
 */
point.prototype.convertToPoly = function(side, radius) {};

/**
 * Gets the wkt representation of this point.
 * @return {string}
 */
point.prototype.toString = function() {};

/**
 * Creates a deep copy of this point.
 * @return {?}
 */
point.prototype.clone = function() {};

/**
 * Returns this point's bounding box.
 * @return {?}
 */
point.prototype.getBounds = function() {};

/**
 * Computes distance between this point and a given point in projected
 * map units.
 * projected map units.
 * @param {?} pt
 * @return {number}
 */
point.prototype.distanceTo = function(pt) {};

/**
 * Computes the distance between two points in coordinate units.
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @return {number}
 */
point.distance = function(x1, y1, x2, y2) {};

/**
 * Computes the midpoint of two points.
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @return {?}
 */
point.midpoint = function(x1, y1, x2, y2) {};
/** @const */
var sphericalMercator = {};

/**
 * Gets the EPSG number for Spherical Mercator.
 * @return {number}
 */
sphericalMercator.getEpsg = function() {};

/**
 * Gets the minimum zoom level for this projection.
 * @return {number}
 */
sphericalMercator.getMinZoomLevel = function() {};

/**
 * Sets the minimum zoom level for this projection. Normally this is 
 * set to 1.0 and should not be altered.
 * @param {number} minZ
 * @return {void}
 */
sphericalMercator.setMinZoomLevel = function(minZ) {};

/**
 * Gets the maxmimum zoom level for this projection.
 * @return {number}
 */
sphericalMercator.getMaxZoomLevel = function() {};

/**
 * Sets the maximum zoom level for this projection. Normally this is 
 * set to 20.0 and should not be altered.
 * @param {number} maxZ
 * @return {void}
 */
sphericalMercator.setMaxZoomLevel = function(maxZ) {};

/**
 * Gets the tile height and width in pixels.
 * @return {number}
 */
sphericalMercator.getTileSizePix = function() {};

/**
 * Gets the display DPI, which defaults to 96. Note: The dpi is 
 * recomputed on page load complete.
 * @return {number}
 */
sphericalMercator.getDpi = function() {};

/**
 * Set the display DPI, which defaults to 96. Note: The DPI is 
 * recomputed on page load complete.
 * @param {number} dpi
 * @return {void}
 */
sphericalMercator.setDpi = function(dpi) {};

/**
 * Return the equitorial radius in meters for this projection.
 * @return {number}
 */
sphericalMercator.getRadius = function() {};

/**
 * Returns equitorial circumference in meters for this projection
 * @return {number}
 */
sphericalMercator.getCircumference = function() {};

/**
 * Returns half the equitorial circumference in meters for this projection
 * @return {number}
 */
sphericalMercator.getHalfCircumference = function() {};

/**
 * Get the envelope in map units for a given quadtree node, i.e. tile,
 * based on the given x, y, and z quadtree coordinates.
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {?}
 */
sphericalMercator.getQuadTreeNodeToMapEnvelope = function(x, y, z) {};

/**
 * Gets the envelope in map units of tiles in the quadtree from an 
 * evelope in map units and a zoom level.
 * @param {?} env
 * @param {number} z
 * @return {?}
 */
sphericalMercator.getQuadTreeNodeRangeFromEnvelope = function(env, z) {};

/**
 * Gets projected map units per pixel for a given zoom level.
 * @param {number} zoomLevel
 * @return {number}
 */
sphericalMercator.getProjectionUnitsPerPixel = function(zoomLevel) {};

/**
 * Gets the required scale transform to apply to shapes so distance 
 * and area computations yield actual Earth-geodesic units instead of 
 * projected map units.
 * @param {number} mapPtY
 * @return {number}
 */
sphericalMercator.getActualShapeScaleTransform = function(mapPtY) {};

/**
 * Gets actual, on-the-ground meters per pixel for a given zoom level 
 * and map point in map units.
 * @param {?} mapPt
 * @param {number} zoomLevel
 * @return {number}
 */
sphericalMercator.getActualUnitsPerPixel = function(mapPt, zoomLevel) {};

/**
 * Gets the optimal zoom level for a given envelope in map units 
 * based on the envelope of visible device area in pixels.
 * @param {?} envelopeMap
 * @param {?} envelopeDevice
 * @return {number}
 */
sphericalMercator.getBestFitZoomLevelByExtents = function(envelopeMap, envelopeDevice) {};

/**
 * Gets a quad-key from x, y, and z coordinates.
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {string}
 */
sphericalMercator.getQuadKeyFromXYZ = function(x, y, z) {};

/**
 * Gets x, y, and z coordinates as an object from a given quad-key.
 * @param {string} key
 * @return {?}
 */
sphericalMercator.getXYZFromQuadKey = function(key) {};

/**
 * Project a point from latitude/longitude to Spherical Mercator.
 * @param {?} lonLat
 * @return {?}
 */
sphericalMercator.projectFromLatLon = function(lonLat) {};

/**
 * Project a point from Spherical Mercator to latitude/longitude.
 * @param {?} mapPt
 * @return {?}
 */
sphericalMercator.deprojectToLatLon = function(mapPt) {};

/**
 * @constructor
 * @struct
 * @param {?} geom
 * @param {?=} gStyle
 */
function styledGeometry(geom, gStyle) {}

/**
 * Set this styledGeometry's geometry.
 * @param {?} g
 * @return {void}
 */
styledGeometry.prototype.setGeometry = function(g) {};

/**
 * Set this styledGeometry's geometryStyle.
 * @param {?} gs
 * @return {void}
 */
styledGeometry.prototype.setGeometryStyle = function(gs) {};

/**
 * Gets the styledGeometry's underlying geometry object.
 * @return {?}
 */
styledGeometry.prototype.getGeometry = function() {};

/**
 * Gets the styledGeometry's underlying geometryStyle object.
 * @return {?}
 */
styledGeometry.prototype.getGeometryStyle = function() {};

/**
 * Gets path outline thickness in pixels.
 * @return {number}
 */
styledGeometry.prototype.getOutlineThicknessPix = function() {};

/**
 * Sets path outline thickness in pixels.
 * @param {number} t
 * @return {void}
 */
styledGeometry.prototype.setOutlineThicknessPix = function(t) {};

/**
 * Gets path outline color as a CSS style string.
 * @return {string}
 */
styledGeometry.prototype.getOutlineColor = function() {};

/**
 * Gets path outline opacity in decimal format.
 * @param {string} c
 * @return {void}
 */
styledGeometry.prototype.setOutlineColor = function(c) {};

/**
 * Gets path outline opacity in decimal format.
 * @return {number}
 */
styledGeometry.prototype.getOutlineOpacity = function() {};

/**
 * Set path outline opacity to a decimal between 0 and 1.
 * @param {number} o
 * @return {void}
 */
styledGeometry.prototype.setOutlineOpacity = function(o) {};

/**
 * Gets fill color as a CSS style string.
 * @return {string}
 */
styledGeometry.prototype.getFillColor = function() {};

/**
 * Sets fill color as a CSS style string.
 * @param {string} c
 * @return {void}
 */
styledGeometry.prototype.setFillColor = function(c) {};

/**
 * Gets fill opacity in decimal format.
 * @return {number}
 */
styledGeometry.prototype.getFillOpacity = function() {};

/**
 * Sets fill opacity to a decimal between 0 and 1.
 * @param {number} o
 * @return {void}
 */
styledGeometry.prototype.setFillOpacity = function(o) {};

/**
 * Gets the dash array as a string.
 * @return {string}
 */
styledGeometry.prototype.getDashArray = function() {};

/**
 * Sets dash array string from a CSS style string. Defaults to solid
 * stroke if no dash array string is provided.
 * @param {string} da
 * @return {void}
 */
styledGeometry.prototype.setDashArray = function(da) {};

/**
 * Gets optional animation function called when SVG node is created.
 * @return {?}
 */
styledGeometry.prototype.getAnimation = function() {};

/**
 * You can use the loopback parameter on complete to call itself and 
 * create repeating animation.
 * @param {?} action
 * @return {void}
 */
styledGeometry.prototype.setAnimation = function(action) {};

/**
 * Renders this geometry as an SVG path. Note: We attach original
 * geometry bounds to svg doc as an expando.
 * @param {string} key
 * @param {number} mapUnitsPerPix
 * @return {!HTMLElement}
 */
styledGeometry.prototype.createSvgPathElement = function(key, mapUnitsPerPix) {};

/**
 * Renders this to a canvas context.
 * @param {!CanvasRenderingContext2D} ctx
 * @return {void}
 */
styledGeometry.prototype.renderPathToCanvasContext = function(ctx) {};
 /** @type {string} */
var version;
/** @const */
var wkt = {};

/**
 * Parses WKT as a point.
 * @param {string} wkt
 * @return {?}
 */
wkt.parsePoint = function(wkt) {};

/**
 * Parses WKT as a multipoint.
 * \@retuns {geometry} The parsed multipoint geometry.
 * @param {string} wkt
 * @return {?}
 */
wkt.parseMultiPoint = function(wkt) {};

/**
 * Parses WKT as an open path geometry with a single set.
 * @param {string} wkt
 * @return {?}
 */
wkt.parseLineString = function(wkt) {};

/**
 * Parses WKT as an open path geometry with multiple sets.
 * @param {string} wkt
 * @return {?}
 */
wkt.parseMultiLineString = function(wkt) {};

/**
 * Parses WKT as a closed path geometry with a single set.
 * @param {string} wkt
 * @return {?}
 */
wkt.parsePolygon = function(wkt) {};

/**
 * Parses WKT as a closed path geometry with multiple sets.
 * @param {string} wkt
 * @return {?}
 */
wkt.parseMultiPolygon = function(wkt) {};

/**
 * Parses WKT as a geometry and determines its type from the string.
 * polygons depending on the WKT.
 * @param {string} wkt
 * @return {?}
 */
wkt.parse = function(wkt) {};

/**
 * Converts an array of polygons to an OGC compliant multipolygon WKT string.
 * @param {!Array<?>} polys
 * @return {string}
 */
wkt.toMultiPolygonString = function(polys) {};
/** @const */
var tile = {};

/**
 * @constructor
 * @struct
 * @param {string} id
 * @param {boolean=} useBackdrop
 * @param {number=} maxConcurrentRequests
 */
tile.layer = function(id, useBackdrop, maxConcurrentRequests) {};

/**
 * Gets ID associated with this tile layer.
 * @return {string}
 */
tile.layer.prototype.getId = function() {};

/**
 * Determines whether this tile layer uses a backdrop.
 * @return {boolean}
 */
tile.layer.prototype.getUseBackdrop = function() {};

/**
 * Returns the tile layer's descriptor, which describes how 
 * requested content is rendered or styled.
 * @return {?}
 */
tile.layer.prototype.getDescriptor = function() {};

/**
 * Sets the tile layer's descriptor, which describes how requested
 * content is rendered or styled.
 * @param {?} d
 * @return {void}
 */
tile.layer.prototype.setDescriptor = function(d) {};

/**
 * Notifies the tile layer to check for changes to its descriptor.
 * @return {void}
 */
tile.layer.prototype.notifyDescriptorChange = function() {};

/**
 * Returns this tile layer's requestor which defines what kind of 
 * content to get and where to get it.
 * @return {?}
 */
tile.layer.prototype.getRequestor = function() {};

/**
 * Sets this tile layer's requestor, which defines what kind of
 * content to get and where to get it.
 * can be set in one call and incur only one content change event.
 * @param {?} req
 * @param {?=} desc
 * @return {void}
 */
tile.layer.prototype.setRequestor = function(req, desc) {};

/**
 * Returns this tile layer's renderer if it exists, which defines 
 * how geometry data for a quadView is rendered.
 * @return {?}
 */
tile.layer.prototype.getRenderer = function() {};

/**
 * Sets optional renderer which defines how geometry data for 
 * quadView is rendered.
 * signature renderer(quadview).
 * @param {?} r
 * @return {void}
 */
tile.layer.prototype.setRenderer = function(r) {};

/**
 * Notifies the tile layer to check for changes to its renderer.
 * @return {void}
 */
tile.layer.prototype.notifyRendererChange = function() {};

/**
 * Gets the visibility state of this tile layer.
 * @return {boolean}
 */
tile.layer.prototype.getIsVisible = function() {};

/**
 * Sets visibility state of this tile layer.
 * @param {boolean} v
 * @return {void}
 */
tile.layer.prototype.setIsVisible = function(v) {};

/**
 * Gets the opacity of this tile layer.
 * @return {number}
 */
tile.layer.prototype.getOpacity = function() {};

/**
 * Sets opacity of this tile layer.
 * @param {number} o
 * @return {void}
 */
tile.layer.prototype.setOpacity = function(o) {};

/**
 * Gets minimum zoom level where this tile layer is visible.
 * @return {number}
 */
tile.layer.prototype.getMinZoomLevel = function() {};

/**
 * Sets minimum zoom level where this tile layer is visible.
 * @param {number} minZ
 * @return {void}
 */
tile.layer.prototype.setMinZoomLevel = function(minZ) {};

/**
 * Gets maximum zoom level where this tile layer is visible.
 * @return {number}
 */
tile.layer.prototype.getMaxZoomLevel = function() {};

/**
 * Sets maximum zoom level where this tile layer is visible.
 * @param {number} maxZ
 * @return {void}
 */
tile.layer.prototype.setMaxZoomLevel = function(maxZ) {};

/**
 * Sets pixel bleed on quadTiles, which defaults to 1. Setting this 
 * to zero for overlay layers with translucent polygon fills is 
 * recommended. Bleed overlap can create faint lines at tile 
 * boundries when fill is not opaque.
 * @param {number} bleed
 * @return {void}
 */
tile.layer.prototype.setTileBleedPix = function(bleed) {};

/**
 * Sets whether or not to retain and display previous level tile 
 * content as you change tile levels to provide a nice zoom level 
 * change effect. Once the next level is loaded the old level 
 * content is always discarded. This should be set to false if there 
 * is translucent content to display. Defaults to true (prior to 
 * version 9.0.0001 this value had the same state as useBackdrop.)
 * @param {boolean} retain
 * @return {void}
 */
tile.layer.prototype.setRetainInterlevelContent = function(retain) {};

/**
 * Enables or disables the fade in on tile content, which defaults to enabled.
 * should be enabled.
 * @param {boolean} fadeIn
 * @return {void}
 */
tile.layer.prototype.setEnableTileFadeIn = function(fadeIn) {};

/**
 * Sets the default action to take on error.
 * @param {?} action
 * @return {void}
 */
tile.layer.prototype.setNotifyErrorAction = function(action) {};

/**
 * Sets an optional function to be called when the tile loading
 * queue for this layer has emptied.
 * @param {?} action
 * @return {void}
 */
tile.layer.prototype.setNotifyLoadingQueueHasEmptiedAction = function(action) {};

/**
 * Sets the optional function to be called by this layer's tile 
 * loader during processing. The supplied progress function takes 
 * tiles loaded and tiles total parameters.
 * @param {?} action
 * @return {void}
 */
tile.layer.prototype.setNotifyLoadingQueueProgressAction = function(action) {};

/**
 * Sets optional request processor for this tile layer. This is 
 * an advanced feature allowing developers to tap into tile 
 * request pipeline for purposes of customizing requests or manage 
 * custom caching. This is also the mechanism used for offline 
 * apps with frameworks such as phonegap.
 * processor(requestor, descriptor, quad, timeoutMs, complete, error)
 * @param {?} processorFunc
 * @return {void}
 */
tile.layer.prototype.setRequestProcessor = function(processorFunc) {};

/**
 * Instructs the tile loader to populate a specified tile pyramid.
 * This is used to fetch content (e.g. bitmap tiles) and preload 
 * it into the browser cache.
 * fetch content.
 * fetch content.
 * @param {?} extents
 * @param {number} startZoomLevel
 * @param {number} endZoomLevel
 * @return {void}
 */
tile.layer.prototype.preload = function(extents, startZoomLevel, endZoomLevel) {};

/**
 * Composes an array of quadtiles with composition information and
 * requestor endpoints. This can be used to create static images
 * or print-ready versions of this tile layer at arbitrary extents
 * (both source and target) For example: If you needed a 5x3 inch 
 * 300 dpi output you can specify extents in device units to be
 * 1500x900. This function determines the correct zoom level so 
 * that the source extents fits in the target extents to the
 * nearest integer zoom level.
 * {quadCollection, endpointCollection, idxMinX, idxMinY, ulX, ulY }
 * where quadCollection is an array of quad objects, endpointCollection
 * is an array of REST endpoints from which to obtain the tiled content,
 * idxMinX and idxMinY are the minimum x and y tile indicies of the
 * collection respectively, and ulX and ulY are the offset in pixels
 * of the upper left tile from the upper left target extents.
 * @param {?} extentsMapUnits
 * @param {?} extentsDeviceUnits
 * @return {?}
 */
tile.layer.prototype.compose = function(extentsMapUnits, extentsDeviceUnits) {};

/**
 * Unbind all associations with this tile layer to facilitate garbage collection
 * @return {void}
 */
tile.layer.prototype.dispose = function() {};

/**
 * @constructor
 * @struct
 * @param {string} id
 * @param {?} options
 */
tile.layerOptions = function(id, options) {};

/**
 * Returns the underlying tile layer.
 * @return {?}
 */
tile.layerOptions.prototype.getTileLayer = function() {};

/**
 * Gets ID associated with the underlying tile layer.
 * @return {string}
 */
tile.layerOptions.prototype.getId = function() {};

/**
 * Gets this layerOptions object as a JavaScript object.
 * @return {?}
 */
tile.layerOptions.prototype.getOptions = function() {};
/**
 * @constructor
 * @struct
 */
tile.quad = function() {};

/**
 * Gets the x coodinate of this quad tile.
 * @return {number}
 */
tile.quad.prototype.getX = function() {};

/**
 * Gets the y coordinate of this quad tile.
 * @return {number}
 */
tile.quad.prototype.getY = function() {};

/**
 * Gets the z coordinate of this quad tile, or depth.
 * @return {number}
 */
tile.quad.prototype.getLevel = function() {};

/**
 * Gets the envelope in map units which encompasses this quad tile.
 * @return {?}
 */
tile.quad.prototype.getEnvelope = function() {};

/**
 * Gets the string representation of this quad tile as a quad key.
 * @return {string}
 */
tile.quad.prototype.toString = function() {};

/**
 * Gets the quad key for this quad tile as a string.
 * @return {string}
 */
tile.quad.prototype.getKey = function() {};

/**
 * Compares this quad tile with another quad tile and determines
 * whether or not they are equal.
 * @param {?} q
 * @return {boolean}
 */
tile.quad.prototype.equals = function(q) {};

/**
 * Generates the quad tile which is a given number of levels above
 * this tile in the pyramid and in which this quad tile is contained.
 * generated tile should be.
 * @param {number} ancestorsBack
 * @return {?}
 */
tile.quad.prototype.factoryParent = function(ancestorsBack) {};

/**
 * Generates a new quad tile based on a given quad key.
 * @param {string} key
 * @return {?} The generated quad tile.
 */
tile.quad.factoryQuadFromKey = function(key) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
tile.renderer = function(options) {};

/**
 * Sets the render point function which takes a point and canvas 
 * context and renders the point to the canvas. The points passed 
 * in are transformed to pixel units and offset to context origin.
 * where shape is the point object to be rendered and context is the 
 * canvas context on which to render.
 * @param {?} func
 * @return {void}
 */
tile.renderer.prototype.setRenderPoint = function(func) {};

/**
 * Sets render geometry function which takes a geometry and canvas 
 * context and renders the geometry to the canvas context. The 
 * geometries passed in are transformed to pixel units and offset 
 * to the context origin.
 * where shape is the geometry to render and context is the canvas
 * context on which to render.
 * @param {?} func
 * @return {void}
 */
tile.renderer.prototype.setRenderGeometry = function(func) {};

/**
 * Sets the render bitmap function which takes a bitmap image and
 * a canvas context and renders the image to the canvas context.
 * func(img, context, contextSize, bleed) where img is the bitmap
 * image to render, context is the canvas context on which to 
 * render the image, contextSize is the size of the canvas context
 * in pixels and bleed is the margin around each tile to bleed.
 * @param {?} func
 * @return {void}
 */
tile.renderer.prototype.setRenderBitmap = function(func) {};

/**
 * @constructor
 * @struct
 */
tile.rendererDensityMap = function() {};

/**
 * Sets the bleed ratio, which is the sets the percentage of the
 * margin around each tile to use in the tile's computation. Note:
 * some bleed (i.e., greater than 1) is required since a heat map
 * relies on adjacent data.
 * @param {number} bleed
 * @return {void}
 */
tile.rendererDensityMap.prototype.setBleed = function(bleed) {};

/**
 * Sets the number of rows and columns of cells to be used for 
 * computation within the grid.
 * the grid.
 * @param {number} gridSize
 * @return {void}
 */
tile.rendererDensityMap.prototype.setGridSize = function(gridSize) {};

/**
 * Sets filter radius corresponding to standard deviations. The
 * filter radius is the cutoff point at which adjacent cells no
 * longer contribute to a cell's calculation.
 * from the mean of a normal distribution to which to give positive 
 * weight.
 * @param {number} filterStdDevRadius
 * @return {void}
 */
tile.rendererDensityMap.prototype.setFilterStdDevRadius = function(filterStdDevRadius) {};

/**
 * Sets color ranges from cold to hot for the renderer.
 * of the form [r,g,b,a], where each array represents a color and
 * colors range from cold to hot. Note: Typically, a dozen colors
 * is sufficient.
 * @param {!Array<!Array<number>>} matrix
 * @return {void}
 */
tile.rendererDensityMap.prototype.setColorMatrix = function(matrix) {};

/**
 * Sets the minimum required cell value for a cell to receive 
 * a color. Default minimum value is 0.
 * @param {number} min
 * @return {void}
 */
tile.rendererDensityMap.prototype.setMinCellValue = function(min) {};

/**
 * Sets an optional action to perform on each row. This enables 
 * processing the values on one or more columns for each row for
 * use in the density map computations.
 * action(row). The value returned from the function will is added
 * to the cell's value.
 * @param {?} action
 * @return {void}
 */
tile.rendererDensityMap.prototype.setRowAction = function(action) {};

/**
 * Tells renderer to re-render density map and recompute ranges. 
 * This should be called if the data changes or if, due to extent
 * changes, the density changes.
 * @param {?=} extents
 * @return {void}
 */
tile.rendererDensityMap.prototype.notifyRecompute = function(extents) {};

/**
 * @constructor
 * @struct
 */
tile.requestor = function() {};

/**
 * Gets formatted endpoint using the supplied quadtile and a descriptor.
 * @param {?} quad
 * @param {?} descriptor
 * @return {string}
 */
tile.requestor.prototype.getFormattedEndpoint = function(quad, descriptor) {};

/**
 * Gets data locally if the requestor supports it.
 * @param {?} quad
 * @param {?} descriptor
 * @return {string}
 */
tile.requestor.prototype.getLocalData = function(quad, descriptor) {};

/**
 * Creates unique sha1 hash from this requestor and the supplied
 * descriptor. This is useful in creating a unique key or folder 
 * for tile caching. This combined with a tile's quad-key can 
 * efficiently and uniquely identify a particular tile.
 * \@params {descriptor} The descriptor for which to create the hash.
 * @param {?} descriptor
 * @return {string}
 */
tile.requestor.prototype.hash = function(descriptor) {};

/**
 * Determines whether or not this requestor returns bitmap images.
 * images.
 * @return {boolean}
 */
tile.requestor.prototype.getIsRestImage = function() {};

/**
 * Sets whether this requestor should return bitmap images.
 * bitmap images.
 * @param {boolean} flag
 * @return {void}
 */
tile.requestor.prototype.setIsRestImage = function(flag) {};

/**
 * Determines whether or not this requestor uses an endpoint 
 * rather than local data.
 * an endpoint.
 * @return {boolean}
 */
tile.requestor.prototype.getUsesEndpoint = function() {};

/**
 * Sets whether or not this requestor uses an endpoint rather than
 * local data.
 * from an endpoint.
 * @param {boolean} flag
 * @return {void}
 */
tile.requestor.prototype.setUsesEndpoint = function(flag) {};

/**
 * Gets format of data returned by REST service.
 * @return {string}
 */
tile.requestor.prototype.getDataFormat = function() {};

/**
 * Sets format of data that should be returned by REST service.
 * should use.
 * @param {string} df
 * @return {void}
 */
tile.requestor.prototype.setDataFormat = function(df) {};

/**
 * Returns whether or not caching is enabled for vector-based 
 * requestors. 
 * @return {boolean}
 */
tile.requestor.prototype.getCacheEnabled = function() {};

/**
 * Sets whether or not caching is enabled for vector-beased requestors. 
 * @param {boolean} flag
 * @return {void}
 */
tile.requestor.prototype.setCacheEnabled = function(flag) {};

/**
 * Gets requestor timeout in miliseconds.
 * @return {number}
 */
tile.requestor.prototype.getTimeoutMs = function() {};

/**
 * Sets requestor timeout in miliseconds.
 * @param {number} ms
 * @return {void}
 */
tile.requestor.prototype.setTimeoutMs = function(ms) {};

/**
 * ???
 * Gets the additional 
 * @return {!Array<!Object>}
 */
tile.requestor.prototype.getKeyVals = function() {};

/**
 * Set any key/value pairs that are attached to the ajax call (such as username and password)
 * @param {!Array<!Object>} options
 * @return {void}
 */
tile.requestor.prototype.setKeyVals = function(options) {};

/**
 * Gets maximum available zoom level content that can be retrieved 
 * from the endpoint this requestor consumes.
 * @return {number}
 */
tile.requestor.prototype.getMaxAvailableZoomLevel = function() {};

/**
 * Sets maximum available zoom level content that can be retrieved
 * from the endpoint this requestor consumes. Note: This defaults
 * to the projection's maximum available zoom level, which is 20
 * in spherical mercator.
 * @param {number} max
 * @return {void}
 */
tile.requestor.prototype.setMaxAvailableZoomLevel = function(max) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
tile.requestorBing = function(options) {};

/**
 * Gets the formatted endpoint uri for Bing maps, e.g. 
 * ecn.t{0}.tiles.virtualearth.net/tiles/{1}{2}{3}?g={4}&mkt={5}&shading=hill.
 * @return {string}
 */
tile.requestorBing.prototype.getEndpoint = function() {};

/**
 * Gets the protocol for the endpoint, either 'http' or 'https'.
 * @return {string}
 */
tile.requestorBing.prototype.getScheme = function() {};

/**
 * Sets endpoint protocol to either 'http' or 'https'.
 * @param {string} s
 * @return {void}
 */
tile.requestorBing.prototype.setScheme = function(s) {};

/**
 * Gets Bing tile generation
 * @return {string}
 */
tile.requestorBing.prototype.getGeneration = function() {};

/**
 * Sets Bing tile generation
 * @param {string} g
 * @return {void}
 */
tile.requestorBing.prototype.setGeneration = function(g) {};

/**
 * Gets the language code for which the tiles are rendered. The
 * default code is 'en-US'.
 * @return {string}
 */
tile.requestorBing.prototype.getMarket = function() {};

/**
 * Sets language code for which to render tiles. For example,
 * 'en-US'.
 * @param {string} m
 * @return {void}
 */
tile.requestorBing.prototype.setMarket = function(m) {};

/**
 * Gets the Bing key associated with this requestor.
 * @return {string}
 */
tile.requestorBing.prototype.getBingKey = function() {};

/**
 * Sets Bing key which then calls Microsoft metadata service and
 * automatically configures content endpoint.
 * @param {string} key
 * @return {void}
 */
tile.requestorBing.prototype.setBingKey = function(key) {};

/**
 * @constructor
 * @struct
 * @param {string} endpoint
 * @param {?=} options
 */
tile.requestorMDNRest = function(endpoint, options) {};

/**
 * Gets uri endpoint for the MapDotNet REST service.
 * @return {string}
 */
tile.requestorMDNRest.prototype.getEndpoint = function() {};

/**
 * @constructor
 * @struct
 * @param {string} mapId
 * @param {?=} options
 */
tile.descriptorMDNRestMap = function(mapId, options) {};

/**
 * Sets the flag to suspend descriptor change notifications. If 
 * set true, all changes to this descriptor will not cause the map
 * to redraw. Setting to false will enable redraws and immediately
 * force a redraw.
 * should be enabled.
 * @param {boolean} flag
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setSuspendDescriptorChangeNotifications = function(flag) {};

/**
 * Gets the map ID.
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getMapId = function() {};

/**
 * Gets the REST service version.
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getVersion = function() {};

/**
 * Sets the REST service version.
 * @param {string} v
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setVersion = function(v) {};

/**
 * Gets image type associated with this descriptor, either 'png',
 * 'png8', or 'jpg'.
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getImageType = function() {};

/**
 * Gets image type associated with this descriptor to one of 'png',
 * 'png8', or 'jpg'.
 * associated with this descriptor.
 * @param {string} t
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setImageType = function(t) {};

/**
 * Gets bleed ratio for the layer associated with this descriptor.
 * @return {number}
 */
tile.descriptorMDNRestMap.prototype.getBleedRatio = function() {};

/**
 * Sets the bleed ratio. Bleeds greater than 1.0 will fetch content 
 * beyond the edge of the tile extents (this is useful for point 
 * features).
 * @param {number} br
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setBleedRatio = function(br) {};

/**
 * Gets the map's cache setting, which is one of 'None', 
 * 'ReadOnly', 'ReadWrite', 'ForceWrite', and 'Default.'
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getMapCacheOption = function() {};

/**
 * Gets the map's cache setting to one of 'None', 
 * 'ReadOnly', 'ReadWrite', 'ForceWrite', and 'Default.'
 * @param {string} mco
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setMapCacheOption = function(mco) {};

/**
 * Gets the optional map cache name.
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getMapCacheName = function() {};

/**
 * Sets the optional map cache name.
 * @param {string} mcn
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setMapCacheName = function(mcn) {};

/**
 * Determines whether the map is flagged to use the quadkey as its
 * map cache name.
 * use the quadkey as its map cache name.
 * @return {boolean}
 */
tile.descriptorMDNRestMap.prototype.getUseQuadKeyForMapCacheName = function() {};

/**
 * Sets the flag that uses the quadkey as its map cache name.
 * to use the quadkey as its map cache name.
 * @param {boolean} flag
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setUseQuadKeyForMapCacheName = function(flag) {};

/**
 * Gets map image background color.
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getBackgroundColorStr = function() {};

/**
 * Sets the map image background color.
 * @param {number} a
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setBackgroundColor = function(a, r, g, b) {};

/**
 * Checks whether or not the map background is transparent.
 * @return {boolean}
 */
tile.descriptorMDNRestMap.prototype.getIsBackgroundTransparent = function() {};

/**
 * Sets a layer's visibility.
 * @param {string} layerId
 * @param {boolean} isVisible
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setLayerVisibility = function(layerId, isVisible) {};

/**
 * Gets a layer's visibility.
 * @param {string} layerId
 * @return {boolean}
 */
tile.descriptorMDNRestMap.prototype.getLayerVisibility = function(layerId) {};

/**
 * Sets a layer's outline color and thickness.
 * @param {string} layerId
 * @param {number} a
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @param {number} thk
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setLayerOutline = function(layerId, a, r, g, b, thk) {};

/**
 * Gets a layer's outline color and thickness.
 * where color is the CSS style string of the outline color and 
 * thickness is the outline thickness in pixels.
 * @param {string} layerId
 * @return {?}
 */
tile.descriptorMDNRestMap.prototype.getLayerOutline = function(layerId) {};

/**
 * Sets a layer's fill color.
 * @param {string} layerId
 * @param {number} a
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setLayerFill = function(layerId, a, r, g, b) {};

/**
 * Sets a layer's fill color as a SQL expression.
 * @param {string} layerId
 * @param {string} exp
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setLayerFillAsExpression = function(layerId, exp) {};

/**
 * Gets a layer's fill color as a CSS style string or as a SQL expression.
 * according to how the layer's fill color was set.
 * @param {string} layerId
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getLayerFill = function(layerId) {};

/**
 * Add or replace the where clause for a layer. The where clause
 * is a SQL expression used to filter rows.
 * with the existing where clause using a SQL AND or to replace
 * the existing where clause with the new one. Defaults to true (merge).
 * @param {string} layerId
 * @param {string} where
 * @param {boolean} merge
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setLayerWhere = function(layerId, where, merge) {};

/**
 * Sets a separator character for the layer where clause expression
 * in the query string. This is set to ',' by default, which is 
 * consistent with SQL.
 * single character.
 * @param {string} sep
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setLayerWhereSep = function(sep) {};

/**
 * Returns the current separator for the layer where clause in the
 * query string. 
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getLayerWhereSep = function() {};

/**
 * Gets the current layer where clause.
 * is in use, this will return an empty string.
 * @param {string} layerId
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getLayerWhere = function(layerId) {};

/**
 * Gets a tag which is used to modify the request URIs to avoid 
 * browser caching
 * @return {string}
 */
tile.descriptorMDNRestMap.prototype.getTag = function() {};

/**
 * Sets the map's tag, which is used modify request URIs to avoid 
 * browser caching.
 * @param {string} tag
 * @return {void}
 */
tile.descriptorMDNRestMap.prototype.setTag = function(tag) {};

/**
 * @constructor
 * @struct
 * @param {string} mapId
 * @param {string} layerId
 * @param {?=} options
 */
tile.descriptorMDNRestFeature = function(mapId, layerId, options) {};

/**
 * Gets the map ID.
 * @return {string}
 */
tile.descriptorMDNRestFeature.prototype.getMapId = function() {};

/**
 * Gets the layer's ID.
 * @return {string}
 */
tile.descriptorMDNRestFeature.prototype.getLayerId = function() {};

/**
 * Gets the version of the REST service.
 * @return {string}
 */
tile.descriptorMDNRestFeature.prototype.getVersion = function() {};

/**
 * Sets the REST service version number.
 * @param {string} v
 * @return {void}
 */
tile.descriptorMDNRestFeature.prototype.setVersion = function(v) {};

/**
 * Gets the bleed ratio.
 * @return {number}
 */
tile.descriptorMDNRestFeature.prototype.getBleedRatio = function() {};

/**
 * Sets the bleed ratio. Bleeds greater than 1.0 will fetch content 
 * beyond the edge of the tile extents (this is useful for point features).
 * @param {number} br
 * @return {void}
 */
tile.descriptorMDNRestFeature.prototype.setBleedRatio = function(br) {};

/**
 * Gets the optional field names to query. This attribute data may
 * be used in dynamic client-side rendering.
 * @return {!Array<string>}
 */
tile.descriptorMDNRestFeature.prototype.getFieldNames = function() {};

/**
 * Sets the optional field names to query. This attribute data may be used in 
 * dynamic client-side rendering.
 * @param {!Array<string>} names
 * @return {void}
 */
tile.descriptorMDNRestFeature.prototype.setFieldNames = function(names) {};

/**
 * Checks the flag whether to clip geometry fetched at the bounds 
 * of the request.
 * @return {boolean}
 */
tile.descriptorMDNRestFeature.prototype.getClipToRenderBounds = function() {};

/**
 * Sets the flag whether to clip geometry fetched at the bounds 
 * of the request. This can greatly improve performance with large
 * complex geometries. Only supported when back-end store is SQL 
 * 2008/2012 or PostGIS.
 * at the bounds of the request.
 * @param {boolean} flag
 * @return {void}
 */
tile.descriptorMDNRestFeature.prototype.setClipToRenderBounds = function(flag) {};

/**
 * Checks the flag whether to simplify paths based on the units per
 * pixel for the quad tile being requested.
 * @return {boolean}
 */
tile.descriptorMDNRestFeature.prototype.getSimplifyEnabled = function() {};

/**
 * Sets the flag whether to simplify paths based on the units per
 * pixel for the quad tile being requested.
 * the units per pixel.
 * @param {boolean} flag
 * @return {void}
 */
tile.descriptorMDNRestFeature.prototype.setSimplifyEnabled = function(flag) {};

/**
 * Sets the action to perform on descriptor change.
 * @param {?} action
 * @return {void}
 */
tile.descriptorMDNRestFeature.prototype.setNotifyDescriptorChangeAction = function(action) {};

/**
 * @constructor
 * @struct
 * @param {string} endpoint
 * @param {!Array<string>} subdomains
 * @param {?=} options
 */
tile.requestorOpen = function(endpoint, subdomains, options) {};

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
tile.requestorLocal = function(options) {};

/**
 * Gets the unparsed source data.
 * @return {!Array<!Object>}
 */
tile.requestorLocal.prototype.getSource = function() {};

/**
 * Sets source data.
 * the requestor source data.
 * @param {!Array<!Object>} data
 * @return {void}
 */
tile.requestorLocal.prototype.setSource = function(data) {};

/**
 * Returns your source data parsed into theformat { Shapes: [],
 * Values: [], Bounds: [] } This may be useful for doing client-side 
 * queries on the local data where all of the WKT has been parsed 
 * into points and geometry. There is also a bounds collection to 
 * do a quick spatial check for complex polygons.
 * @return {?}
 */
tile.requestorLocal.prototype.getParsedData = function() {};

/**
 * @constructor
 * @struct
 * @param {?} options
 */
tile.descriptorLocal = function(options) {};
/**
 * @record
 * @struct
 */
function pointObject() {}
 /** @type {number} */
pointObject.prototype.x;
 /** @type {number} */
pointObject.prototype.y;
/**
 * @record
 * @struct
 */
function envObject() {}
 /** @type {number} */
envObject.prototype.minX;
 /** @type {number} */
envObject.prototype.minY;
 /** @type {number} */
envObject.prototype.maxX;
 /** @type {number} */
envObject.prototype.maxY;
/**
 * @record
 * @struct
 */
function extentChangeStatsObj() {}
 /** @type {number} */
extentChangeStatsObj.prototype.centerX;
 /** @type {number} */
extentChangeStatsObj.prototype.centerY;
 /** @type {number} */
extentChangeStatsObj.prototype.centerLat;
 /** @type {number} */
extentChangeStatsObj.prototype.centerLon;
 /** @type {number} */
extentChangeStatsObj.prototype.zoomLevel;
 /** @type {number} */
extentChangeStatsObj.prototype.mapScale;
 /** @type {number} */
extentChangeStatsObj.prototype.mapScaleProjected;
 /** @type {number} */
extentChangeStatsObj.prototype.mapUnitsPerPixel;
 /** @type {?} */
extentChangeStatsObj.prototype.extents;
/**
 * @record
 * @struct
 */
function repositionStatsObj() {}
 /** @type {number} */
repositionStatsObj.prototype.centerX;
 /** @type {number} */
repositionStatsObj.prototype.centerY;
 /** @type {number} */
repositionStatsObj.prototype.zoomLevel;
 /** @type {number} */
repositionStatsObj.prototype.mapUnitsPerPixel;
/**
 * @record
 * @struct
 */
function beginDigitizeOptions() {}
 /** @type {string} */
beginDigitizeOptions.prototype.key;
 /** @type {string} */
beginDigitizeOptions.prototype.shapeType;
 /** @type {?} */
beginDigitizeOptions.prototype.geometryStyle;
 /** @type {?} */
beginDigitizeOptions.prototype.styledGeometry;
 /** @type {?} */
beginDigitizeOptions.prototype.nodeTapAndHoldAction;
 /** @type {?} */
beginDigitizeOptions.prototype.nodeMoveAction;
 /** @type {?} */
beginDigitizeOptions.prototype.shapeChangeAction;
 /** @type {?} */
beginDigitizeOptions.prototype.envelopeEndAction;
 /** @type {?} */
beginDigitizeOptions.prototype.circleEndAction;
 /** @type {boolean} */
beginDigitizeOptions.prototype.suppressNodeAdd;
 /** @type {boolean} */
beginDigitizeOptions.prototype.leavePath;
/**
 * @record
 * @struct
 */
function styleObj() {}
 /** @type {string} */
styleObj.prototype.fillColor;
 /** @type {number} */
styleObj.prototype.fillOpacity;
 /** @type {string} */
styleObj.prototype.outlineColor;
 /** @type {number} */
styleObj.prototype.outlineOpacity;
 /** @type {number} */
styleObj.prototype.outlineThicknessPix;
 /** @type {string} */
styleObj.prototype.dashArray;
/**
 * @record
 * @struct
 */
function mapsjsWidget() {}

/**
 * Gets the center of the map in spherical mercator. Use 
 * sphericalMercator.deprojectToLatLon static function to convert to a lat/lon.
 * @return {?}
 */
mapsjsWidget.prototype.getMapCenter = function() {};

/**
 * Sets the center of the map in spherical mercator. Use
 * sphericalMercator.projectFromLatLon static function to convert from a lat/lon.
 * @param {?} center
 * @return {void}
 */
mapsjsWidget.prototype.setMapCenter = function(center) {};

/**
 * Same as setMapCenter except will animate from current map center to the 
 * specified location
 * @param {?} center
 * @param {number=} durationMs
 * @param {?=} completeAction
 * @return {void}
 */
mapsjsWidget.prototype.setMapCenterAnimate = function(center, durationMs, completeAction) {};

/**
 * Sets the map center to the current geolocation if supported. The map is
 * animated to the new location.
 * @param {number=} durationMs
 * @param {?=} completeAction
 * @return {void}
 */
mapsjsWidget.prototype.setMapCenterToGeolocationAnimate = function(durationMs, completeAction) {};

/**
 * Offsets the current map center by the specified deltas in pixels. 
 * @param {number} dx
 * @param {number} dy
 * @return {void}
 */
mapsjsWidget.prototype.offsetMapCenterByPixelDelta = function(dx, dy) {};

/**
 * Offsets the current map center by the specified deltas in pixels - animated version.
 * @param {number} dx
 * @param {number} dy
 * @param {number=} durationMs
 * @return {void}
 */
mapsjsWidget.prototype.offsetMapCenterByPixelDeltaAnimate = function(dx, dy, durationMs) {};

/**
 * Gets the current zoom level.
 * @return {number}
 */
mapsjsWidget.prototype.getZoomLevel = function() {};

/**
 * Sets the current zoom level.
 * @param {number} zl
 * @return {void}
 */
mapsjsWidget.prototype.setZoomLevel = function(zl) {};

/**
 * Sets the minimum zoom level for the map.
 * @param {number} zl
 * @return {void}
 */
mapsjsWidget.prototype.setMinZoomLevel = function(zl) {};

/**
 * Sets the maximum zoom level for the map.
 * @param {number} zl
 * @return {void}
 */
mapsjsWidget.prototype.setMaxZoomLevel = function(zl) {};

/**
 * Animates the map from the current zoom level to the given zoom level.
 * completes with signature completeAction().
 * @param {number} zl
 * @param {number=} durationMs
 * @param {?=} completeAction
 * @return {void}
 */
mapsjsWidget.prototype.setZoomLevelAnimate = function(zl, durationMs, completeAction) {};

/**
 * Changes the current zoom level.
 * @param {number} delta
 * @return {void}
 */
mapsjsWidget.prototype.zoomDelta = function(delta) {};

/**
 * Animates a change to the current zoom level.
 * @param {number} delta
 * @param {number=} durationMs
 * @return {void}
 */
mapsjsWidget.prototype.zoomDeltaAnimate = function(delta, durationMs) {};

/**
 * Animates parabolically from the current map center and zoom level
 * to the given map center and zoom level.
 * completes with signature completeAction().
 * @param {?} center
 * @param {number} zl
 * @param {number=} durationMs
 * @param {?=} completeAction
 * @return {void}
 */
mapsjsWidget.prototype.flyTo = function(center, zl, durationMs, completeAction) {};

/**
 * Gets the current map extents in spherical mercator units.
 * @return {?}
 */
mapsjsWidget.prototype.getMapExtents = function() {};

/**
 * Gets the current map units per pixel.
 * @return {number}
 */
mapsjsWidget.prototype.getMapUnitsPerPixel = function() {};

/**
 * Gets the map extents' width and height in pixels.
 * the current extents' width in pixels and h is the current extents'
 * height in pixels.
 * @return {?}
 */
mapsjsWidget.prototype.getViewExtentsInPix = function() {};

/**
 * Gets the current projected map scale. This is the ratio of units on
 * the screen to map units depicted.
 * @return {number}
 */
mapsjsWidget.prototype.getProjectedMapScale = function() {};

/**
 * Gets the current actual map scale. This is the ratio of units on 
 * the screen to actual units on the earth's surface at the latitude 
 * of the current map center.
 * @return {number}
 */
mapsjsWidget.prototype.getActualMapScale = function() {};

/**
 * Gets the best fit zoom level based on the supplied map extents for 
 * the current display extents in pixels.
 * @param {?} extentsNew
 * @return {number}
 */
mapsjsWidget.prototype.getBestFitZoomLevelByExtents = function(extentsNew) {};

/**
 * Forces the map to redraw the currently loaded tile and geometry 
 * content. You should not have to call this as redraws are automatically
 * handled during programatic state changes. This would be for edge cases 
 * where the developer is affecting internal state in an undocumented way.
 * @return {void}
 */
mapsjsWidget.prototype.redraw = function() {};

/**
 * Updates the map to the size of its container. This updates internal 
 * parameters for computing map extents and handling the amount of tile 
 * content to download. This is handled automatically if the browser 
 * window is resized. But if you are sizing the map programatically 
 * (e.g. resizable panel or slider) then call this after the parent 
 * container has resized.
 * @return {void}
 */
mapsjsWidget.prototype.resize = function() {};

/**
 * Pushes a supplied tile layer onto the top of the display stack.
 * @param {?} tl
 * @return {void}
 */
mapsjsWidget.prototype.pushTileLayer = function(tl) {};

/**
 * Removes a tile layer off the top of the display stack
 * @return {?}
 */
mapsjsWidget.prototype.popTileLayer = function() {};

/**
 * Removes a tile layer off the display stack by reference
 * @param {?} tl
 * @return {void}
 */
mapsjsWidget.prototype.removeTileLayer = function(tl) {};

/**
 * Removes all tile layers off the display stack
 * @return {void}
 */
mapsjsWidget.prototype.removeAllTileLayers = function() {};

/**
 * Gets the current number of tile layers in the display stack.
 * @return {number}
 */
mapsjsWidget.prototype.getTileLayerCount = function() {};

/**
 * Gets a tile layer from the display stack by its key.
 * if no tile layer is associated with the key.
 * @param {string} key
 * @return {?}
 */
mapsjsWidget.prototype.getTileLayer = function(key) {};

/**
 * Gets a point in map units from supplied coordinates pixel units 
 * with respect to the currently displayed extents.
 * @param {number} x
 * @param {number} y
 * @return {?}
 */
mapsjsWidget.prototype.computeMapPointFromPixelLocation = function(x, y) {};

/**
 * Flags whether or not map extent changes can occur through gestures 
 * like mouse or touch drag, mouse wheel, or pinch zoom.
 * extent changes.
 * @param {boolean} flag
 * @return {void}
 */
mapsjsWidget.prototype.setSuspendMapExtentChangesByGestures = function(flag) {};

/**
 * Sets the z-order of drawn content in relation to the gesture capture 
 * panel. The default behavior (false) is to have fixed content and 
 * geometry underneath the gesture panel in the DOM. If false, all 
 * pointer events are handled by the gesture capture panel and
 * optionally parents of the map control. If true, drawn content will
 * receive pointer events first and will block gestures to the map. If 
 * true, digitizing will not function and polygons will block map 
 * navigation. In some scenarios you may want to set this to true if you
 * are placing fixed content (such as point features) on the map and 
 * need to handle gestures on the placed content. You can call this 
 * function at any time to change the order.
 * reside above the gesture layer.
 * @param {boolean} flag
 * @return {void}
 */
mapsjsWidget.prototype.setDrawnContentZorderToTop = function(flag) {};

/**
 * Add a fixed element to the content area which resides at a z-level 
 * above tiled map content. These elements do not scale with the map
 * scale. This is used to place markers or callouts on the map
 * DOM element has been placed with signature addAction(element).
 * useElementInsteadOfNewGestureOverlay, downAction, moveAction, upAction, 
 * wheelAction } where dragEnabled flags whether dragging should be
 * enabled on the element, and downAction, moveAction, upAction, and 
 * wheelAction are callback functions invoked on mousedown, mousemove,
 * mouseup, and scroll events respectively.
 * @param {!HTMLElement} element
 * @param {number} mapUnitsX
 * @param {number} mapUnitsY
 * @param {?=} addAction
 * @param {?=} dragOptions
 * @return {void}
 */
mapsjsWidget.prototype.addFixedContentElement = function(element, mapUnitsX, mapUnitsY, addAction, dragOptions) {};

/**
 * Move an existing fixed content element.
 * @param {!HTMLElement} element
 * @param {number} mapUnitsX
 * @param {number} mapUnitsY
 * @return {void}
 */
mapsjsWidget.prototype.moveFixedContentElement = function(element, mapUnitsX, mapUnitsY) {};

/**
 * Removes a fixed content element.
 * must be the same element added by addFixedContentElement.
 * @param {!HTMLElement} element
 * @return {void}
 */
mapsjsWidget.prototype.removeFixedContentElement = function(element) {};

/**
 * Add a styled path geometry to the content area which resides at a z-level 
 * above tiled map content. The geometry is converted to SVG and added to the 
 * content area DOM. If an attempt to add a geometry is made with the same 
 * key, the geometry is swapped out. You must remove using removePathGeometry 
 * for resource cleanup.
 * rendering in the DOM.
 * @param {?} styledGeom
 * @param {string} key
 * @param {?=} addAction
 * @param {?=} removeAction
 * @return {!SVGElement}
 */
mapsjsWidget.prototype.addPathGeometry = function(styledGeom, key, addAction, removeAction) {};

/**
 * Updates an existing path geometry to reflect a style change.
 * @param {?} styleNew
 * @param {string} key
 * @return {void}
 */
mapsjsWidget.prototype.updatePathGeometryStyle = function(styleNew, key) {};

/**
 * Removes a styledGeometry from display.
 * @param {string=} key
 * @return {!SVGElement}
 */
mapsjsWidget.prototype.removePathGeometry = function(key) {};

/**
 * Initiates digitization on the map control. This creates a new
 * geometry and adds verticies to the geometry accord to mouse
 * click locations.
 * shapeType, geometryStyle, styledGeometry, nodeTapAndHoldAction, nodeMoveAction,
 * shapeChangeAction, envelopeEndAction, circleEndAction, supressNodeAdd, leavePath }
 * where key is a a string associated with this geometry, shapeType
 * is the type of shape this geometry is, one of 'polygon', 'polyline', 'multipoint', 'envelope' or 'circle', 
 * geometryStyle is a geometryStyle which should be applied
 * to the digitized geometry, styledGeometry is an optional styledGeometry for existing paths to edit, set this to enter edit mode,
 * nodeTapAndHoldAction is a callback invoked
 * when any point in the geometry is clicked and held and has the
 * signature nodeTapAndHoldAction(setIdx, idx), nodeMoveAction is a
 * callback invoked after any node is dragged to a new location and
 * has signature nodeMoveAction(x, y, actionType), shapeChangeAction
 * is a callback that is invoked after the geometry shape changes and,
 * has signature shapeChangeAction(shape), envelopeEndAction is a callback 
 * invoked after an envelope is created and has signature envelopeEndAction(envelope), 
 * circleEndAction is similar to envelopeEndAction but takes a geometry.polygon representing the circle,
 * and leavePath is a flag that indicates whether the digitized shape
 * should be left on the map after digitization is complete.
 * @param {?} options
 * @return {void}
 */
mapsjsWidget.prototype.beginDigitize = function(options) {};

/**
 * @return {void}
 */
mapsjsWidget.prototype.endDigitize = function() {};

/**
 * Gets a snapshot copy of the currently digitizing path.
 * @return {?}
 */
mapsjsWidget.prototype.getDigitizeSnapshot = function() {};

/**
 * Forces additional digitized points to be pushed to a new set of the
 * currently digitizing geometry.
 * @return {void}
 */
mapsjsWidget.prototype.pushSetOnDigitizePath = function() {};

/**
 * Removes the last set from the currently digitizing path.
 * in the form [xn,yn].
 * @return {!Array<number>}
 */
mapsjsWidget.prototype.popSetFromDigitizePath = function() {};

/**
 * Programmatically delete a node from the currently digitizing path.
 * @param {number} setIdx
 * @param {number} nodeIdx
 * @return {void}
 */
mapsjsWidget.prototype.deleteNodeOnDigitizePath = function(setIdx, nodeIdx) {};

/**
 * Determines whether a shape is currently being digitized.
 * @return {boolean}
 */
mapsjsWidget.prototype.isDigitizingEnabled = function() {};

/**
 * Set the function called when the map extents have stopped changing 
 * (e.g. after an animated pan or zoom).
 * finish changing with signature action(object) where object is of
 * the form { centerX, centerY, centerLat, centerLon, zoomLevel, mapScale,
 * mapScaleProjected, mapUnitsPerPixel, extents }.
 * @param {?} action
 * @return {void}
 */
mapsjsWidget.prototype.setExtentChangeCompleteAction = function(action) {};

/**
 * Set the function called when map content (map tiles and fixed elements) are 
 * re-positioned in the DOM. This is done automatically as the map is panned 
 * beyond existing content and zoomed to a new level requiring content.
 * completes repositioning with signature action(object) where object
 * is of the form { centerX, centerY, zoomLevel, mapUnitsPerPixel }.
 * @param {?} action
 * @return {void}
 */
mapsjsWidget.prototype.setContentRepositionAction = function(action) {};

/**
 * Sets function called when map is clicked or tapped.
 * with signature action(point).
 * @param {?} action
 * @return {void}
 */
mapsjsWidget.prototype.setPointerClickAction = function(action) {};

/**
 * Sets function called when the map pointer hovers over the map.
 * signature action(point).
 * @param {?} action
 * @return {void}
 */
mapsjsWidget.prototype.setPointerHoverAction = function(action) {};

/**
 * Sets the margin around the map in pixels for extra content fetched so that tile 
 * rebuilding of the display is minimized. This is an advanced property and does not 
 * generally need to be adjusted. The default is 128 pixels, or half the width
 * of a tile. This should be increased for maps which are very large in pixels
 * or where panning is constant. This should be decreased for very small maps,
 * such as on mobile devices, or where panning is minimal.
 * @param {number} cem
 * @return {void}
 */
mapsjsWidget.prototype.setContentExtentsMarginInPixels = function(cem) {};

/**
 * Sets the background color of the map using a css color string
 * @param {string} b
 * @return {void}
 */
mapsjsWidget.prototype.setBackground = function(b) {};
/**
 * @record
 * @struct
 */
function JQuery() {}

/**
 * @param {?=} command
 * @param {?=} param
 * @param {?=} param2
 * @param {?=} param3
 * @param {?=} param4
 * @param {?=} param5
 * @return {?}
 */
JQuery.prototype.rimMap = function(command, param, param2, param3, param4, param5) {};

/**
 * @return {?}
 */
JQuery.prototype.getMapsjs = function() {};
