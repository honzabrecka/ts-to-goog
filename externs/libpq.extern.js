/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/libpq/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */
/** @const */
var Libpq = {};
/**
 * @record
 * @struct
 */
Libpq.NotifyMsg = function() {};
 /** @type {string} */
Libpq.NotifyMsg.prototype.relname;
 /** @type {string} */
Libpq.NotifyMsg.prototype.extra;
 /** @type {number} */
Libpq.NotifyMsg.prototype.be_pid;
/**
 * @record
 * @struct
 */
Libpq.ResultError = function() {};
 /** @type {string} */
Libpq.ResultError.prototype.severity;
 /** @type {string} */
Libpq.ResultError.prototype.sqlState;
 /** @type {string} */
Libpq.ResultError.prototype.messagePrimary;
 /** @type {string} */
Libpq.ResultError.prototype.messageDetail;
 /** @type {string} */
Libpq.ResultError.prototype.messageHint;
 /** @type {string} */
Libpq.ResultError.prototype.statementPosition;
 /** @type {string} */
Libpq.ResultError.prototype.internalPosition;
 /** @type {string} */
Libpq.ResultError.prototype.internalQuery;
 /** @type {string} */
Libpq.ResultError.prototype.context;
 /** @type {string} */
Libpq.ResultError.prototype.schemaName;
 /** @type {string} */
Libpq.ResultError.prototype.tableName;
 /** @type {string} */
Libpq.ResultError.prototype.dataTypeName;
 /** @type {string} */
Libpq.ResultError.prototype.constraintName;
 /** @type {string} */
Libpq.ResultError.prototype.sourceFile;
 /** @type {string} */
Libpq.ResultError.prototype.sourceLine;
 /** @type {string} */
Libpq.ResultError.prototype.sourceFunction;
 /** @type {boolean} */
Libpq.prototype.connected;

/**
 * Issues a request to cancel the currently executing query on this instance of libpq.
 * 
 *                             the cancel request failed for any reason. The string will
 *                             contain the error message provided by libpq.
 * @return {(string|boolean)}
 */
Libpq.prototype.cancel = function() {};

/**
 * Manually frees the memory associated with a PGresult pointer. Generally this is called
 * for you, but if you absolutely want to free the pointer yourself, you can.
 * @return {void}
 */
Libpq.prototype.clear = function() {};

/**
 *                   if you inserted 3 rows.
 * @return {string}
 */
Libpq.prototype.cmdStatus = function() {};

/**
 *                   number, it is returned as a string to mirror libpq's behavior.
 * @return {string}
 */
Libpq.prototype.cmdTuples = function() {};

/**
 * (async) Connects to a PostgreSQL backend server process.
 * 
 * This function actually calls the PQconnectdb blocking connection method in a background
 * thread within node's internal thread-pool. There is a way to do non-blocking network I/O
 * for some of the connecting with libpq directly, but it still blocks when your local file
 * system looking for config files, SSL certificates, .pgpass file, and doing possible dns
 * resolution. Because of this, the best way to get fully non-blocking is to juse use
 * libuv_queue_work and let node do it's magic and so that's what I do. This function does
 * not block.
 * 
 *                            established.
 * @param {string|function(!Error): void} connectParams_or_callback
 * @param {function(!Error): void=} callback
 * @return {void}
 */
Libpq.prototype.connect = function(connectParams_or_callback, callback) {};

/**
 * (sync) Attempts to connect to a PostgreSQL server. BLOCKS until it either succeedes, or
 * fails. If it fails it will throw an exception.
 * 
 * @param {string=} connectionParams
 * @return {void}
 */
Libpq.prototype.connectSync = function(connectionParams) {};

/**
 * Reads waiting data from the socket. If the socket is not readable and you call this it will
 * block so be careful and only call it within the readable callback for the most part.
 * 
 *                    error details with [[Libpq.errorMessage]].
 * @return {boolean}
 */
Libpq.prototype.consumeInput = function() {};

/**
 * Retrieves the last error message from the connection. This is intended to be used after most
 * functions which return an error code to get more detailed error information about the
 * connection. You can also check this before issuing queries to see if your connection has
 * been lost.
 * 
 * @return {string}
 */
Libpq.prototype.errorMessage = function() {};

/**
 * Exact copy of the PQescapeIdentifier function within libpq. Requires an established
 * connection but does not perform any I/O.
 * 
 * @param {string} input
 * @return {string}
 */
Libpq.prototype.escapeIdentifier = function(input) {};

/**
 * Exact copy of the PQescapeLiteral function within libpq. Requires an established connection
 * but does not perform any I/O.
 * 
 * @param {string} input
 * @return {string}
 */
Libpq.prototype.escapeLiteral = function(input) {};

/**
 * (sync) Sends a command to the backend and blocks until a result is received.
 * 
 * @param {string=} commandText
 * @return {void}
 */
Libpq.prototype.exec = function(commandText) {};

/**
 * (sync) Sends a command and parameters to the backend and blocks until a result is received.
 * 
 *                                                  corresponding to each parameter in the
 *                                                  commandText.
 * @param {string=} commandText
 * @param {!Array<(string|number)>=} parameters
 * @return {void}
 */
Libpq.prototype.execParams = function(commandText, parameters) {};

/**
 * (sync) Sends a command to the server to execute a previously prepared statement. Blocks
 * until the results are returned.
 * 
 *                                                  statement.
 * @param {string=} statementName
 * @param {!Array<(string|number)>=} parameters
 * @return {void}
 */
Libpq.prototype.execPrepared = function(statementName, parameters) {};

/**
 * Disconnects from the backend and cleans up all memory used by the libpq connection.
 * @return {void}
 */
Libpq.prototype.finish = function() {};

/**
 * Flushes buffered data to the socket.
 * 
 *                   [[Libpq.writable]] with a callback and wait for the socket to be writable
 *                   and then call [[Libpq.flush]] again; 0 if all data was flushed; -1 if
 *                   there was an error.
 * @return {number}
 */
Libpq.prototype.flush = function() {};

/**
 * Retrieve the name of the field (column) at the given offset. Offset starts at 0.
 * 
 * @param {number} fieldNumber
 * @return {string}
 */
Libpq.prototype.fname = function(fieldNumber) {};

/**
 * Retrieve the Oid of the field (column) at the given offset. Offset starts at 0.
 * 
 * @param {number} fieldNumber
 * @return {number}
 */
Libpq.prototype.ftype = function(fieldNumber) {};

/**
 * After issuing a successfuly command like COPY table TO stdout gets copy data from the
 * connection.
 * 
 *                                backend. Defaults to false.
 * 
 *                          progress (only if you have called [[Libpq.setNonBlocking]](true));
 *                          -1 if the copy is completed; -2 if there was an error.
 * @param {boolean=} async
 * @return {(number|?)}
 */
Libpq.prototype.getCopyData = function(async) {};

/**
 *                    returns false. This is because [[Libpq.getvalue]] returns an empty
 *                    string for both an actual empty string and for a null value. Weird, huh?
 * @param {number} tupleNumber
 * @param {number} fieldNumber
 * @return {boolean}
 */
Libpq.prototype.getisnull = function(tupleNumber, fieldNumber) {};

/**
 * Parses received data from the server into a PGresult struct and sets a pointer internally to
 * the connection object to this result.
 * 
 * Warning: this function will block if libpq is waiting on async results to be returned from
 * the server. Call [[Libpq.isBusy]] to determine if this command will block.
 * 
 *                    false if there are no results waiting to be parsed. Generally doing async
 *                    style queries you'll call this repeadedly until it returns false and then
 *                    use the result accessor methods to pull results out of the current result
 *                    set.
 * @return {boolean}
 */
Libpq.prototype.getResult = function() {};

/**
 * Retrieve the text value at a given tuple (row) and field (column) offset. Both offsets start
 * at 0. A null value is returned as the empty string ''.
 * 
 * @param {number} tupleNumber
 * @param {number=} fieldNumber
 * @return {string}
 */
Libpq.prototype.getvalue = function(tupleNumber, fieldNumber) {};

/**
 * data; false if all data has been read from the socket. Once this returns false it is
 * safe to call [[Libpq.getResult]].
 * @return {boolean}
 */
Libpq.prototype.isBusy = function() {};

/**
 * @return {boolean}
 */
Libpq.prototype.isNonBlocking = function() {};

/**
 * Retrieve the number of fields (columns) from the result.
 * 
 * @return {number}
 */
Libpq.prototype.nfields = function() {};

/**
 * Checks for NOTIFY messages that have come in. If any have been received they will be in the
 * following format:
 * 
 * \@example ```ts
 * 
 * var msg = {
 *   relname: 'name of channel',
 *   extra: 'message passed to notify command',
 *   be_pid: 130
 * }
 * ```
 * 
 * @return {!Libpq.NotifyMsg}
 */
Libpq.prototype.notifies = function() {};

/**
 * Retrieve the number of tuples (rows) from the result.
 * 
 * @return {number}
 */
Libpq.prototype.ntuples = function() {};

/**
 * After issuing a successful command like COPY table FROM stdin you can start putting buffers
 * directly into the databse with this function.
 * 
 *                        Buffer('column1\tcolumn2\n')
 * 
 *                   called [[Libpq.setNonBlocking]](true)); -1 if there was an error sending
 *                   the command.
 * @param {?} buffer
 * @return {number}
 */
Libpq.prototype.putCopyData = function(buffer) {};

/**
 * Signals the backed your copy procedure is complete. If you pass errorMessage it will be sent
 * to the backend and effectively cancel the copy operation.
 * 
 * 
 *                   called [[Libpq.setNonBlocking]](true)); -1 if there was an error sending
 *                   the command.
 * @param {string=} errorMessage
 * @return {number}
 */
Libpq.prototype.putCopyEnd = function(errorMessage) {};

/**
 * (sync) Sends a named statement to the server to be prepared for later execution. blocks
 * until a result from the prepare operation is received.
 * 
 * @param {string} statementName
 * @param {string} commandText
 * @param {number} nParams
 * @return {void}
 */
Libpq.prototype.prepare = function(statementName, commandText, nParams) {};

/**
 * Retrieves detailed error information from the current result object. Very similar to
 * PQresultErrorField() except instead of passing a fieldCode and retrieving a single field,
 * retrieves all fields from the error at once on a single object. The object returned is a
 * simple hash, not an instance of an error object.
 * 
 * If you wanted to access PG_DIAG_MESSAGE_DETAIL you would do the following:
 * \@example ```ts
 * 
 * console.log(pq.errorFields().messageDetail);
 * ```
 * @return {!Libpq.ResultError}
 */
Libpq.prototype.resultErrorFields = function() {};

/**
 * Retrieves the error message from the result. This will return null if the result does not
 * have an error.
 * 
 * @return {string}
 */
Libpq.prototype.resultErrorMessage = function() {};

/**
 * the last executed command.
 * @return {string}
 */
Libpq.prototype.resultStatus = function() {};

/**
 * (async) Sends a query to the server to be processed.
 * 
 * @param {string=} commandText
 * @return {boolean}
 */
Libpq.prototype.sendQuery = function(commandText) {};

/**
 * (async) Sends a query and to the server to be processed.
 * 
 *                                                  the parameterized query.
 * @param {string=} commandText
 * @param {!Array<(string|number)>=} parameters
 * @return {boolean}
 */
Libpq.prototype.sendQueryParams = function(commandText, parameters) {};

/**
 * (async) Sends a request to the backend to prepare a named statement with the given name.
 * 
 * @param {string} statementName
 * @param {string} commandText
 * @param {number} nParams
 * @return {boolean}
 */
Libpq.prototype.sendPrepare = function(statementName, commandText, nParams) {};

/**
 * (async) Sends a request to execute a previously prepared statement.
 * 
 * @param {string=} statementName
 * @param {!Array<string>=} parameters
 * @return {boolean}
 */
Libpq.prototype.sendQueryPrepared = function(statementName, parameters) {};

/**
 * @return {number} the version of the connected PostgreSQL backend server as a number.
 */
Libpq.prototype.serverVersion = function() {};

/**
 * Toggle the socket blocking on write.
 * 
 *                                use blocking writes.
 * 
 *                    an error.
 * @param {boolean=} nonBlocking
 * @return {boolean}
 */
Libpq.prototype.setNonBlocking = function(nonBlocking) {};

/**
 *                   the connection.
 * @return {number}
 */
Libpq.prototype.socket = function() {};

/**
 * This uses libuv to start a read watcher on the socket open to the backend. As soon as this
 * socket becomes readable the pq instance will emit a readable event. It is up to you to call
 * [[Libpq.consumeInput]] one or more times to clear this read notification or it will
 * continue to emit read events over and over and over. The exact flow is outlined [here] under
 * the documentation for PQisBusy.
 * @return {void}
 */
Libpq.prototype.startReader = function() {};

/**
 * Tells libuv to stop the read watcher on the connection socket.
 * @return {void}
 */
Libpq.prototype.stopReader = function() {};

/**
 * Call this to make sure the socket has flushed all data to the operating system. Once the
 * socket is writable, your callback will be called. Usefully when using PQsetNonBlocking
 * and PQflush for async writing.
 * 
 * 
 * @param {function(): void} callback
 * @return {Libpq}
 */
Libpq.prototype.writable = function(callback) {};

/* TODO: ExportAssignment in  */
