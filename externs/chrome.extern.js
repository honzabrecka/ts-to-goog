/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/chrome/index.d.ts:
 /** @type {?} */
Window.prototype.chrome;
/** @const */
var chrome = {};
/** @const */
chrome.accessibilityFeatures = {};
/**
 * @record
 * @struct
 */
chrome.accessibilityFeatures.AccessibilityFeaturesGetArg = function() {};
 /** @type {boolean} */
chrome.accessibilityFeatures.AccessibilityFeaturesGetArg.prototype.incognito;
/**
 * @record
 * @struct
 */
chrome.accessibilityFeatures.AccessibilityFeaturesCallbackArg = function() {};
 /** @type {?} */
chrome.accessibilityFeatures.AccessibilityFeaturesCallbackArg.prototype.value;
 /** @type {string} */
chrome.accessibilityFeatures.AccessibilityFeaturesCallbackArg.prototype.levelOfControl;
 /** @type {boolean} */
chrome.accessibilityFeatures.AccessibilityFeaturesCallbackArg.prototype.incognitoSpecific;
/**
 * @record
 * @struct
 */
chrome.accessibilityFeatures.AccessibilityFeaturesSetArg = function() {};
 /** @type {?} */
chrome.accessibilityFeatures.AccessibilityFeaturesSetArg.prototype.value;
 /** @type {string} */
chrome.accessibilityFeatures.AccessibilityFeaturesSetArg.prototype.scope;
/**
 * @record
 * @struct
 */
chrome.accessibilityFeatures.AccessibilityFeaturesClearArg = function() {};
 /** @type {string} */
chrome.accessibilityFeatures.AccessibilityFeaturesClearArg.prototype.scope;
/**
 * @record
 * @struct
 */
chrome.accessibilityFeatures.AccessibilityFeaturesSetting = function() {};

/**
 * Gets the value of a setting.
 * @param {!chrome.accessibilityFeatures.AccessibilityFeaturesGetArg} details Which setting to consider.
 * @param {function(!chrome.accessibilityFeatures.AccessibilityFeaturesCallbackArg): void} callback The callback parameter should be a function that looks like this:
 * function(object details) {...};
 * @return {void}
 */
chrome.accessibilityFeatures.AccessibilityFeaturesSetting.prototype.get = function(details, callback) {};

/**
 * Sets the value of a setting.
 * @param {!chrome.accessibilityFeatures.AccessibilityFeaturesSetArg} details Which setting to change.
 * @param {function(): void=} callback Called at the completion of the set operation.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.accessibilityFeatures.AccessibilityFeaturesSetting.prototype.set = function(details, callback) {};

/**
 * Clears the setting, restoring any default value.
 * @param {!chrome.accessibilityFeatures.AccessibilityFeaturesClearArg} details Which setting to clear.
 * @param {function(): void=} callback Called at the completion of the clear operation.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.accessibilityFeatures.AccessibilityFeaturesSetting.prototype.clear = function(details, callback) {};
 /** @type {!chrome.accessibilityFeatures.AccessibilityFeaturesSetting} */
chrome.accessibilityFeatures.spokenFeedback;
 /** @type {!chrome.accessibilityFeatures.AccessibilityFeaturesSetting} */
chrome.accessibilityFeatures.largeCursor;
 /** @type {!chrome.accessibilityFeatures.AccessibilityFeaturesSetting} */
chrome.accessibilityFeatures.stickyKeys;
 /** @type {!chrome.accessibilityFeatures.AccessibilityFeaturesSetting} */
chrome.accessibilityFeatures.highContrast;
 /** @type {!chrome.accessibilityFeatures.AccessibilityFeaturesSetting} */
chrome.accessibilityFeatures.screenMagnifier;
 /** @type {!chrome.accessibilityFeatures.AccessibilityFeaturesSetting} */
chrome.accessibilityFeatures.autoclick;
 /** @type {!chrome.accessibilityFeatures.AccessibilityFeaturesSetting} */
chrome.accessibilityFeatures.virtualKeyboard;
 /** @type {!chrome.accessibilityFeatures.AccessibilityFeaturesSetting} */
chrome.accessibilityFeatures.animationPolicy;
/** @const */
chrome.alarms = {};
/**
 * @record
 * @struct
 */
chrome.alarms.AlarmCreateInfo = function() {};
 /** @type {number} */
chrome.alarms.AlarmCreateInfo.prototype.delayInMinutes;
 /** @type {number} */
chrome.alarms.AlarmCreateInfo.prototype.periodInMinutes;
 /** @type {number} */
chrome.alarms.AlarmCreateInfo.prototype.when;
/**
 * @record
 * @struct
 */
chrome.alarms.Alarm = function() {};
 /** @type {number} */
chrome.alarms.Alarm.prototype.periodInMinutes;
 /** @type {number} */
chrome.alarms.Alarm.prototype.scheduledTime;
 /** @type {string} */
chrome.alarms.Alarm.prototype.name;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.alarms.AlarmEvent = function() {};

/**
 * Creates an alarm. Near the time(s) specified by alarmInfo, the onAlarm event is fired. If there is another alarm with the same name (or no name if none is specified), it will be cancelled and replaced by this alarm.
 * In order to reduce the load on the user's machine, Chrome limits alarms to at most once every 1 minute but may delay them an arbitrary amount more. That is, setting delayInMinutes or periodInMinutes to less than 1 will not be honored and will cause a warning. when can be set to less than 1 minute after "now" without warning but won't actually cause the alarm to fire for at least 1 minute.
 * To help you debug your app or extension, when you've loaded it unpacked, there's no limit to how often the alarm can fire.
 * Creates an alarm. Near the time(s) specified by alarmInfo, the onAlarm event is fired. If there is another alarm with the same name (or no name if none is specified), it will be cancelled and replaced by this alarm.
 * In order to reduce the load on the user's machine, Chrome limits alarms to at most once every 1 minute but may delay them an arbitrary amount more. That is, setting delayInMinutes or periodInMinutes to less than 1 will not be honored and will cause a warning. when can be set to less than 1 minute after "now" without warning but won't actually cause the alarm to fire for at least 1 minute.
 * To help you debug your app or extension, when you've loaded it unpacked, there's no limit to how often the alarm can fire.
 * @param {!chrome.alarms.AlarmCreateInfo|string} alarmInfo_or_name Describes when the alarm should fire. The initial time must be specified by either when or delayInMinutes (but not both). If periodInMinutes is set, the alarm will repeat every periodInMinutes minutes after the initial event. If neither when or delayInMinutes is set for a repeating alarm, periodInMinutes is used as the default for delayInMinutes. / Optional name to identify this alarm. Defaults to the empty string.
 * @param {!chrome.alarms.AlarmCreateInfo=} alarmInfo Describes when the alarm should fire. The initial time must be specified by either when or delayInMinutes (but not both). If periodInMinutes is set, the alarm will repeat every periodInMinutes minutes after the initial event. If neither when or delayInMinutes is set for a repeating alarm, periodInMinutes is used as the default for delayInMinutes.
 * @return {void}
 */
chrome.alarms.create = function(alarmInfo_or_name, alarmInfo) {};

/**
 * Gets an array of all the alarms.
 * @param {function(!Array<!chrome.alarms.Alarm>): void} callback The callback parameter should be a function that looks like this:
 * function(array of Alarm alarms) {...};
 * @return {void}
 */
chrome.alarms.getAll = function(callback) {};

/**
 * Clears all alarms.
 * @param {function(boolean): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean wasCleared) {...};
 * @return {void}
 */
chrome.alarms.clearAll = function(callback) {};

/**
 * Clears the alarm with the given name.
 * Clears the alarm without a name.
 * @param {string|function(boolean): void=} name_or_callback The name of the alarm to clear. Defaults to the empty string. / If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean wasCleared) {...};
 * @param {function(boolean): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean wasCleared) {...};
 * @return {void}
 */
chrome.alarms.clear = function(name_or_callback, callback) {};

/**
 * Retrieves details about the specified alarm.
 * Retrieves details about the specified alarm.
 * @param {function(!chrome.alarms.Alarm): void|string} callback_or_name The callback parameter should be a function that looks like this:
 * function( Alarm alarm) {...}; / The name of the alarm to get. Defaults to the empty string.
 * @param {function(!chrome.alarms.Alarm): void=} callback The callback parameter should be a function that looks like this:
 * function( Alarm alarm) {...};
 * @return {void}
 */
chrome.alarms.get = function(callback_or_name, callback) {};
 /** @type {!chrome.alarms.AlarmEvent} */
chrome.alarms.onAlarm;
/** @const */
chrome.browser = {};
/**
 * @record
 * @struct
 */
chrome.browser.Options = function() {};
 /** @type {string} */
chrome.browser.Options.prototype.url;

/**
 * Opens a new tab in a browser window associated with the current application
 * and Chrome profile. If no browser window for the Chrome profile is opened,
 * a new one is opened prior to creating the new tab.
 * Opens a new tab in a browser window associated with the current application
 * and Chrome profile. If no browser window for the Chrome profile is opened,
 * a new one is opened prior to creating the new tab. Since Chrome 42 only.
 * @param {!chrome.browser.Options} options Configures how the tab should be opened.
 * @param {function(): void=} callback Called when the tab was successfully
 * created, or failed to be created. If failed, runtime.lastError will be set.
 * @return {void}
 */
chrome.browser.openTab = function(options, callback) {};
/** @const */
chrome.bookmarks = {};
/**
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkTreeNode = function() {};
 /** @type {number} */
chrome.bookmarks.BookmarkTreeNode.prototype.index;
 /** @type {number} */
chrome.bookmarks.BookmarkTreeNode.prototype.dateAdded;
 /** @type {string} */
chrome.bookmarks.BookmarkTreeNode.prototype.title;
 /** @type {string} */
chrome.bookmarks.BookmarkTreeNode.prototype.url;
 /** @type {number} */
chrome.bookmarks.BookmarkTreeNode.prototype.dateGroupModified;
 /** @type {string} */
chrome.bookmarks.BookmarkTreeNode.prototype.id;
 /** @type {string} */
chrome.bookmarks.BookmarkTreeNode.prototype.parentId;
 /** @type {!Array<!chrome.bookmarks.BookmarkTreeNode>} */
chrome.bookmarks.BookmarkTreeNode.prototype.children;
 /** @type {?} */
chrome.bookmarks.BookmarkTreeNode.prototype.unmodifiable;
/**
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkRemoveInfo = function() {};
 /** @type {number} */
chrome.bookmarks.BookmarkRemoveInfo.prototype.index;
 /** @type {string} */
chrome.bookmarks.BookmarkRemoveInfo.prototype.parentId;
/**
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkMoveInfo = function() {};
 /** @type {number} */
chrome.bookmarks.BookmarkMoveInfo.prototype.index;
 /** @type {number} */
chrome.bookmarks.BookmarkMoveInfo.prototype.oldIndex;
 /** @type {string} */
chrome.bookmarks.BookmarkMoveInfo.prototype.parentId;
 /** @type {string} */
chrome.bookmarks.BookmarkMoveInfo.prototype.oldParentId;
/**
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkChangeInfo = function() {};
 /** @type {string} */
chrome.bookmarks.BookmarkChangeInfo.prototype.url;
 /** @type {string} */
chrome.bookmarks.BookmarkChangeInfo.prototype.title;
/**
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkReorderInfo = function() {};
 /** @type {!Array<string>} */
chrome.bookmarks.BookmarkReorderInfo.prototype.childIds;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkRemovedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkImportEndedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkMovedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkImportBeganEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkChangedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkCreatedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkChildrenReordered = function() {};
/**
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkSearchQuery = function() {};
 /** @type {string} */
chrome.bookmarks.BookmarkSearchQuery.prototype.query;
 /** @type {string} */
chrome.bookmarks.BookmarkSearchQuery.prototype.url;
 /** @type {string} */
chrome.bookmarks.BookmarkSearchQuery.prototype.title;
/**
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkCreateArg = function() {};
 /** @type {string} */
chrome.bookmarks.BookmarkCreateArg.prototype.parentId;
 /** @type {number} */
chrome.bookmarks.BookmarkCreateArg.prototype.index;
 /** @type {string} */
chrome.bookmarks.BookmarkCreateArg.prototype.title;
 /** @type {string} */
chrome.bookmarks.BookmarkCreateArg.prototype.url;
/**
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkDestinationArg = function() {};
 /** @type {string} */
chrome.bookmarks.BookmarkDestinationArg.prototype.parentId;
 /** @type {number} */
chrome.bookmarks.BookmarkDestinationArg.prototype.index;
/**
 * @record
 * @struct
 */
chrome.bookmarks.BookmarkChangesArg = function() {};
 /** @type {string} */
chrome.bookmarks.BookmarkChangesArg.prototype.title;
 /** @type {string} */
chrome.bookmarks.BookmarkChangesArg.prototype.url;
 /** @type {number} */
chrome.bookmarks.MAX_WRITE_OPERATIONS_PER_HOUR;
 /** @type {number} */
chrome.bookmarks.MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE;

/**
 * Searches for BookmarkTreeNodes matching the given query. Queries specified with an object produce BookmarkTreeNodes matching all specified properties.
 * Searches for BookmarkTreeNodes matching the given query. Queries specified with an object produce BookmarkTreeNodes matching all specified properties.
 * @param {string|!chrome.bookmarks.BookmarkSearchQuery} query A string of words and quoted phrases that are matched against bookmark URLs and titles. / An object with one or more of the properties query, url, and title specified. Bookmarks matching all specified properties will be produced.
 * @param {function(!Array<!chrome.bookmarks.BookmarkTreeNode>): void} callback The callback parameter should be a function that looks like this:
 * function(array of BookmarkTreeNode results) {...};
 * @return {void}
 */
chrome.bookmarks.search = function(query, callback) {};

/**
 * Retrieves the entire Bookmarks hierarchy.
 * @param {function(!Array<!chrome.bookmarks.BookmarkTreeNode>): void} callback The callback parameter should be a function that looks like this:
 * function(array of BookmarkTreeNode results) {...};
 * @return {void}
 */
chrome.bookmarks.getTree = function(callback) {};

/**
 * Retrieves the recently added bookmarks.
 * @param {number} numberOfItems The maximum number of items to return.
 * @param {function(!Array<!chrome.bookmarks.BookmarkTreeNode>): void} callback The callback parameter should be a function that looks like this:
 * function(array of BookmarkTreeNode results) {...};
 * @return {void}
 */
chrome.bookmarks.getRecent = function(numberOfItems, callback) {};

/**
 * Retrieves the specified BookmarkTreeNode.
 * Retrieves the specified BookmarkTreeNode.
 * @param {string|!Array<string>} id_or_idList A single string-valued id / An array of string-valued ids
 * @param {function(!Array<!chrome.bookmarks.BookmarkTreeNode>): void} callback The callback parameter should be a function that looks like this:
 * function(array of BookmarkTreeNode results) {...};
 * @return {void}
 */
chrome.bookmarks.get = function(id_or_idList, callback) {};

/**
 * Creates a bookmark or folder under the specified parentId. If url is NULL or missing, it will be a folder.
 * @param {!chrome.bookmarks.BookmarkCreateArg} bookmark
 * @param {function(!chrome.bookmarks.BookmarkTreeNode): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function( BookmarkTreeNode result) {...};
 * @return {void}
 */
chrome.bookmarks.create = function(bookmark, callback) {};

/**
 * Moves the specified BookmarkTreeNode to the provided location.
 * @param {string} id
 * @param {!chrome.bookmarks.BookmarkDestinationArg} destination
 * @param {function(!chrome.bookmarks.BookmarkTreeNode): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function( BookmarkTreeNode result) {...};
 * @return {void}
 */
chrome.bookmarks.move = function(id, destination, callback) {};

/**
 * Updates the properties of a bookmark or folder. Specify only the properties that you want to change; unspecified properties will be left unchanged. Note: Currently, only 'title' and 'url' are supported.
 * @param {string} id
 * @param {!chrome.bookmarks.BookmarkChangesArg} changes
 * @param {function(!chrome.bookmarks.BookmarkTreeNode): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function( BookmarkTreeNode result) {...};
 * @return {void}
 */
chrome.bookmarks.update = function(id, changes, callback) {};

/**
 * Removes a bookmark or an empty bookmark folder.
 * @param {string} id
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.bookmarks.remove = function(id, callback) {};

/**
 * Retrieves the children of the specified BookmarkTreeNode id.
 * @param {string} id
 * @param {function(!Array<!chrome.bookmarks.BookmarkTreeNode>): void} callback The callback parameter should be a function that looks like this:
 * function(array of BookmarkTreeNode results) {...};
 * @return {void}
 */
chrome.bookmarks.getChildren = function(id, callback) {};

/**
 * Since Chrome 14.
 * Retrieves part of the Bookmarks hierarchy, starting at the specified node.
 * @param {string} id The ID of the root of the subtree to retrieve.
 * @param {function(!Array<!chrome.bookmarks.BookmarkTreeNode>): void} callback The callback parameter should be a function that looks like this:
 * function(array of BookmarkTreeNode results) {...};
 * @return {void}
 */
chrome.bookmarks.getSubTree = function(id, callback) {};

/**
 * Recursively removes a bookmark folder.
 * @param {string} id
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.bookmarks.removeTree = function(id, callback) {};
 /** @type {!chrome.bookmarks.BookmarkRemovedEvent} */
chrome.bookmarks.onRemoved;
 /** @type {!chrome.bookmarks.BookmarkImportEndedEvent} */
chrome.bookmarks.onImportEnded;
 /** @type {!chrome.bookmarks.BookmarkImportBeganEvent} */
chrome.bookmarks.onImportBegan;
 /** @type {!chrome.bookmarks.BookmarkChangedEvent} */
chrome.bookmarks.onChanged;
 /** @type {!chrome.bookmarks.BookmarkMovedEvent} */
chrome.bookmarks.onMoved;
 /** @type {!chrome.bookmarks.BookmarkCreatedEvent} */
chrome.bookmarks.onCreated;
 /** @type {!chrome.bookmarks.BookmarkChildrenReordered} */
chrome.bookmarks.onChildrenReordered;
/** @const */
chrome.browserAction = {};
/**
 * @record
 * @struct
 */
chrome.browserAction.BadgeBackgroundColorDetails = function() {};
 /** @type {?} */
chrome.browserAction.BadgeBackgroundColorDetails.prototype.color;
 /** @type {number} */
chrome.browserAction.BadgeBackgroundColorDetails.prototype.tabId;
/**
 * @record
 * @struct
 */
chrome.browserAction.BadgeTextDetails = function() {};
 /** @type {string} */
chrome.browserAction.BadgeTextDetails.prototype.text;
 /** @type {number} */
chrome.browserAction.BadgeTextDetails.prototype.tabId;
/**
 * @record
 * @struct
 */
chrome.browserAction.TitleDetails = function() {};
 /** @type {string} */
chrome.browserAction.TitleDetails.prototype.title;
 /** @type {number} */
chrome.browserAction.TitleDetails.prototype.tabId;
/**
 * @record
 * @struct
 */
chrome.browserAction.TabDetails = function() {};
 /** @type {number} */
chrome.browserAction.TabDetails.prototype.tabId;
/**
 * @record
 * @struct
 */
chrome.browserAction.TabIconDetails = function() {};
 /** @type {?} */
chrome.browserAction.TabIconDetails.prototype.path;
 /** @type {number} */
chrome.browserAction.TabIconDetails.prototype.tabId;
 /** @type {!ImageData} */
chrome.browserAction.TabIconDetails.prototype.imageData;
/**
 * @record
 * @struct
 */
chrome.browserAction.PopupDetails = function() {};
 /** @type {number} */
chrome.browserAction.PopupDetails.prototype.tabId;
 /** @type {string} */
chrome.browserAction.PopupDetails.prototype.popup;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.browserAction.BrowserClickedEvent = function() {};

/**
 * Since Chrome 22.
 * Enables the browser action for a tab. By default, browser actions are enabled.
 * @param {number=} tabId The id of the tab for which you want to modify the browser action.
 * @return {void}
 */
chrome.browserAction.enable = function(tabId) {};

/**
 * Sets the background color for the badge.
 * @param {!chrome.browserAction.BadgeBackgroundColorDetails} details
 * @return {void}
 */
chrome.browserAction.setBadgeBackgroundColor = function(details) {};

/**
 * Sets the badge text for the browser action. The badge is displayed on top of the icon.
 * @param {!chrome.browserAction.BadgeTextDetails} details
 * @return {void}
 */
chrome.browserAction.setBadgeText = function(details) {};

/**
 * Sets the title of the browser action. This shows up in the tooltip.
 * @param {!chrome.browserAction.TitleDetails} details
 * @return {void}
 */
chrome.browserAction.setTitle = function(details) {};

/**
 * Since Chrome 19.
 * Gets the badge text of the browser action. If no tab is specified, the non-tab-specific badge text is returned.
 * @param {!chrome.browserAction.TabDetails} details
 * @param {function(string): void} callback The callback parameter should be a function that looks like this:
 * function(string result) {...};
 * @return {void}
 */
chrome.browserAction.getBadgeText = function(details, callback) {};

/**
 * Sets the html document to be opened as a popup when the user clicks on the browser action's icon.
 * @param {!chrome.browserAction.PopupDetails} details
 * @return {void}
 */
chrome.browserAction.setPopup = function(details) {};

/**
 * Since Chrome 22.
 * Disables the browser action for a tab.
 * @param {number=} tabId The id of the tab for which you want to modify the browser action.
 * @return {void}
 */
chrome.browserAction.disable = function(tabId) {};

/**
 * Since Chrome 19.
 * Gets the title of the browser action.
 * @param {!chrome.browserAction.TabDetails} details
 * @param {function(string): void} callback The callback parameter should be a function that looks like this:
 * function(string result) {...};
 * @return {void}
 */
chrome.browserAction.getTitle = function(details, callback) {};

/**
 * Since Chrome 19.
 * Gets the background color of the browser action.
 * @param {!chrome.browserAction.TabDetails} details
 * @param {function(!Array<number>): void} callback The callback parameter should be a function that looks like this:
 * function( ColorArray result) {...};
 * @return {void}
 */
chrome.browserAction.getBadgeBackgroundColor = function(details, callback) {};

/**
 * Since Chrome 19.
 * Gets the html document set as the popup for this browser action.
 * @param {!chrome.browserAction.TabDetails} details
 * @param {function(string): void} callback The callback parameter should be a function that looks like this:
 * function(string result) {...};
 * @return {void}
 */
chrome.browserAction.getPopup = function(details, callback) {};

/**
 * Sets the icon for the browser action. The icon can be specified either as the path to an image file or as the pixel data from a canvas element, or as dictionary of either one of those. Either the path or the imageData property must be specified.
 * @param {!chrome.browserAction.TabIconDetails} details
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browserAction.setIcon = function(details, callback) {};
 /** @type {!chrome.browserAction.BrowserClickedEvent} */
chrome.browserAction.onClicked;
/** @const */
chrome.browsingData = {};
/**
 * @record
 * @struct
 */
chrome.browsingData.OriginTypes = function() {};
 /** @type {boolean} */
chrome.browsingData.OriginTypes.prototype.protectedWeb;
 /** @type {boolean} */
chrome.browsingData.OriginTypes.prototype.extension;
 /** @type {boolean} */
chrome.browsingData.OriginTypes.prototype.unprotectedWeb;
/**
 * @record
 * @struct
 */
chrome.browsingData.RemovalOptions = function() {};
 /** @type {!chrome.browsingData.OriginTypes} */
chrome.browsingData.RemovalOptions.prototype.originTypes;
 /** @type {number} */
chrome.browsingData.RemovalOptions.prototype.since;
/**
 * @record
 * @struct
 */
chrome.browsingData.DataTypeSet = function() {};
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.webSQL;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.indexedDB;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.cookies;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.passwords;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.serverBoundCertificates;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.downloads;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.cache;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.appcache;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.fileSystems;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.pluginData;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.localStorage;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.formData;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.history;
 /** @type {boolean} */
chrome.browsingData.DataTypeSet.prototype.serviceWorkers;
/**
 * @record
 * @struct
 */
chrome.browsingData.SettingsCallback = function() {};
 /** @type {!chrome.browsingData.RemovalOptions} */
chrome.browsingData.SettingsCallback.prototype.options;
 /** @type {!chrome.browsingData.DataTypeSet} */
chrome.browsingData.SettingsCallback.prototype.dataToRemove;
 /** @type {!chrome.browsingData.DataTypeSet} */
chrome.browsingData.SettingsCallback.prototype.dataRemovalPermitted;

/**
 * Since Chrome 26.
 * Reports which types of data are currently selected in the 'Clear browsing data' settings UI. Note: some of the data types included in this API are not available in the settings UI, and some UI settings control more than one data type listed here.
 * @param {function(!chrome.browsingData.SettingsCallback): void} callback The callback parameter should be a function that looks like this:
 * function(object result) {...};
 * @return {void}
 */
chrome.browsingData.settings = function(callback) {};

/**
 * Clears plugins' data.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when plugins' data has been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removePluginData = function(options, callback) {};

/**
 * Clears the browser's stored form data (autofill).
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when the browser's form data has been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeFormData = function(options, callback) {};

/**
 * Clears websites' file system data.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when websites' file systems have been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeFileSystems = function(options, callback) {};

/**
 * Clears various types of browsing data stored in a user's profile.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {!chrome.browsingData.DataTypeSet} dataToRemove The set of data types to remove.
 * @param {function(): void=} callback Called when deletion has completed.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.remove = function(options, dataToRemove, callback) {};

/**
 * Clears the browser's stored passwords.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when the browser's passwords have been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removePasswords = function(options, callback) {};

/**
 * Clears the browser's cookies and server-bound certificates modified within a particular timeframe.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when the browser's cookies and server-bound certificates have been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeCookies = function(options, callback) {};

/**
 * Clears websites' WebSQL data.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when websites' WebSQL databases have been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeWebSQL = function(options, callback) {};

/**
 * Clears websites' appcache data.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when websites' appcache data has been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeAppcache = function(options, callback) {};

/**
 * Clears the browser's list of downloaded files (not the downloaded files themselves).
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when the browser's list of downloaded files has been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeDownloads = function(options, callback) {};

/**
 * Clears websites' local storage data.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when websites' local storage has been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeLocalStorage = function(options, callback) {};

/**
 * Clears the browser's cache.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when the browser's cache has been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeCache = function(options, callback) {};

/**
 * Clears the browser's history.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when the browser's history has cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeHistory = function(options, callback) {};

/**
 * Clears websites' IndexedDB data.
 * @param {!chrome.browsingData.RemovalOptions} options
 * @param {function(): void=} callback Called when websites' IndexedDB data has been cleared.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.browsingData.removeIndexedDB = function(options, callback) {};
/** @const */
chrome.commands = {};
/**
 * @record
 * @struct
 */
chrome.commands.Command = function() {};
 /** @type {string} */
chrome.commands.Command.prototype.name;
 /** @type {string} */
chrome.commands.Command.prototype.description;
 /** @type {string} */
chrome.commands.Command.prototype.shortcut;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.commands.CommandEvent = function() {};

/**
 * Returns all the registered extension commands for this extension and their shortcut (if active).
 * @param {function(!Array<!chrome.commands.Command>): void} callback Called to return the registered commands.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(array of Command commands) {...};
 * @return {void}
 */
chrome.commands.getAll = function(callback) {};
 /** @type {!chrome.commands.CommandEvent} */
chrome.commands.onCommand;
/** @const */
chrome.contentSettings = {};
/**
 * @record
 * @struct
 */
chrome.contentSettings.ClearDetails = function() {};
 /** @type {string} */
chrome.contentSettings.ClearDetails.prototype.scope;
/**
 * @record
 * @struct
 */
chrome.contentSettings.SetDetails = function() {};
 /** @type {!chrome.contentSettings.ResourceIdentifier} */
chrome.contentSettings.SetDetails.prototype.resourceIdentifier;
 /** @type {?} */
chrome.contentSettings.SetDetails.prototype.setting;
 /** @type {string} */
chrome.contentSettings.SetDetails.prototype.secondaryPattern;
 /** @type {string} */
chrome.contentSettings.SetDetails.prototype.scope;
 /** @type {string} */
chrome.contentSettings.SetDetails.prototype.primaryPattern;
/**
 * @record
 * @struct
 */
chrome.contentSettings.GetDetails = function() {};
 /** @type {string} */
chrome.contentSettings.GetDetails.prototype.secondaryUrl;
 /** @type {!chrome.contentSettings.ResourceIdentifier} */
chrome.contentSettings.GetDetails.prototype.resourceIdentifier;
 /** @type {boolean} */
chrome.contentSettings.GetDetails.prototype.incognito;
 /** @type {string} */
chrome.contentSettings.GetDetails.prototype.primaryUrl;
/**
 * @record
 * @struct
 */
chrome.contentSettings.ReturnedDetails = function() {};
 /** @type {?} */
chrome.contentSettings.ReturnedDetails.prototype.setting;
/**
 * @record
 * @struct
 */
chrome.contentSettings.ContentSetting = function() {};

/**
 * Clear all content setting rules set by this extension.
 * @param {!chrome.contentSettings.ClearDetails} details
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.contentSettings.ContentSetting.prototype.clear = function(details, callback) {};

/**
 * Applies a new content setting rule.
 * @param {!chrome.contentSettings.SetDetails} details
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.contentSettings.ContentSetting.prototype.set = function(details, callback) {};

/**
 * @param {function(!Array<!chrome.contentSettings.ResourceIdentifier>): void} callback The callback parameter should be a function that looks like this:
 * function(array of ResourceIdentifier resourceIdentifiers) {...};
 * Parameter resourceIdentifiers: A list of resource identifiers for this content type, or undefined if this content type does not use resource identifiers.
 * @return {void}
 */
chrome.contentSettings.ContentSetting.prototype.getResourceIdentifiers = function(callback) {};

/**
 * Gets the current content setting for a given pair of URLs.
 * @param {!chrome.contentSettings.GetDetails} details
 * @param {function(!chrome.contentSettings.ReturnedDetails): void} callback The callback parameter should be a function that looks like this:
 * function(object details) {...};
 * @return {void}
 */
chrome.contentSettings.ContentSetting.prototype.get = function(details, callback) {};
/**
 * @record
 * @struct
 */
chrome.contentSettings.ResourceIdentifier = function() {};
 /** @type {string} */
chrome.contentSettings.ResourceIdentifier.prototype.id;
 /** @type {string} */
chrome.contentSettings.ResourceIdentifier.prototype.description;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.cookies;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.popups;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.javascript;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.notifications;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.plugins;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.images;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.location;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.fullscreen;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.mouselock;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.unsandboxedPlugins;
 /** @type {!chrome.contentSettings.ContentSetting} */
chrome.contentSettings.automaticDownloads;
/** @const */
chrome.contextMenus = {};
/**
 * @record
 * @struct
 */
chrome.contextMenus.OnClickData = function() {};
 /** @type {string} */
chrome.contextMenus.OnClickData.prototype.selectionText;
 /** @type {boolean} */
chrome.contextMenus.OnClickData.prototype.checked;
 /** @type {?} */
chrome.contextMenus.OnClickData.prototype.menuItemId;
 /** @type {string} */
chrome.contextMenus.OnClickData.prototype.frameUrl;
 /** @type {boolean} */
chrome.contextMenus.OnClickData.prototype.editable;
 /** @type {string} */
chrome.contextMenus.OnClickData.prototype.mediaType;
 /** @type {boolean} */
chrome.contextMenus.OnClickData.prototype.wasChecked;
 /** @type {string} */
chrome.contextMenus.OnClickData.prototype.pageUrl;
 /** @type {string} */
chrome.contextMenus.OnClickData.prototype.linkUrl;
 /** @type {?} */
chrome.contextMenus.OnClickData.prototype.parentMenuItemId;
 /** @type {string} */
chrome.contextMenus.OnClickData.prototype.srcUrl;
/**
 * @record
 * @struct
 */
chrome.contextMenus.CreateProperties = function() {};
 /** @type {!Array<string>} */
chrome.contextMenus.CreateProperties.prototype.documentUrlPatterns;
 /** @type {boolean} */
chrome.contextMenus.CreateProperties.prototype.checked;
 /** @type {string} */
chrome.contextMenus.CreateProperties.prototype.title;
 /** @type {!Array<string>} */
chrome.contextMenus.CreateProperties.prototype.contexts;
 /** @type {boolean} */
chrome.contextMenus.CreateProperties.prototype.enabled;
 /** @type {!Array<string>} */
chrome.contextMenus.CreateProperties.prototype.targetUrlPatterns;
 /** @type {function(!chrome.contextMenus.OnClickData, !chrome.tabs.Tab): void} */
chrome.contextMenus.CreateProperties.prototype.onclick;
 /** @type {?} */
chrome.contextMenus.CreateProperties.prototype.parentId;
 /** @type {string} */
chrome.contextMenus.CreateProperties.prototype.type;
 /** @type {string} */
chrome.contextMenus.CreateProperties.prototype.id;
/**
 * @record
 * @struct
 */
chrome.contextMenus.UpdateProperties = function() {};
 /** @type {!Array<string>} */
chrome.contextMenus.UpdateProperties.prototype.documentUrlPatterns;
 /** @type {boolean} */
chrome.contextMenus.UpdateProperties.prototype.checked;
 /** @type {string} */
chrome.contextMenus.UpdateProperties.prototype.title;
 /** @type {!Array<string>} */
chrome.contextMenus.UpdateProperties.prototype.contexts;
 /** @type {boolean} */
chrome.contextMenus.UpdateProperties.prototype.enabled;
 /** @type {!Array<string>} */
chrome.contextMenus.UpdateProperties.prototype.targetUrlPatterns;
 /** @type {!Function} */
chrome.contextMenus.UpdateProperties.prototype.onclick;
 /** @type {?} */
chrome.contextMenus.UpdateProperties.prototype.parentId;
 /** @type {string} */
chrome.contextMenus.UpdateProperties.prototype.type;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.contextMenus.MenuClickedEvent = function() {};
 /** @type {number} */
chrome.contextMenus.ACTION_MENU_TOP_LEVEL_LIMIT;

/**
 * Removes all context menu items added by this extension.
 * @param {function(): void=} callback Called when removal is complete.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.contextMenus.removeAll = function(callback) {};

/**
 * Creates a new context menu item. Note that if an error occurs during creation, you may not find out until the creation callback fires (the details will be in chrome.runtime.lastError).
 * @param {!chrome.contextMenus.CreateProperties} createProperties
 * @param {function(): void=} callback Called when the item has been created in the browser. If there were any problems creating the item, details will be available in chrome.runtime.lastError.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.contextMenus.create = function(createProperties, callback) {};

/**
 * Updates a previously created context menu item.
 * Updates a previously created context menu item.
 * @param {string|number} id The ID of the item to update.
 * @param {!chrome.contextMenus.UpdateProperties} updateProperties The properties to update. Accepts the same values as the create function.
 * @param {function(): void=} callback Called when the context menu has been updated.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.contextMenus.update = function(id, updateProperties, callback) {};

/**
 * Removes a context menu item.
 * Removes a context menu item.
 * @param {string|number} menuItemId The ID of the context menu item to remove.
 * @param {function(): void=} callback Called when the context menu has been removed.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.contextMenus.remove = function(menuItemId, callback) {};
 /** @type {!chrome.contextMenus.MenuClickedEvent} */
chrome.contextMenus.onClicked;
/** @const */
chrome.cookies = {};
/**
 * @record
 * @struct
 */
chrome.cookies.Cookie = function() {};
 /** @type {string} */
chrome.cookies.Cookie.prototype.domain;
 /** @type {string} */
chrome.cookies.Cookie.prototype.name;
 /** @type {string} */
chrome.cookies.Cookie.prototype.storeId;
 /** @type {string} */
chrome.cookies.Cookie.prototype.value;
 /** @type {boolean} */
chrome.cookies.Cookie.prototype.session;
 /** @type {boolean} */
chrome.cookies.Cookie.prototype.hostOnly;
 /** @type {number} */
chrome.cookies.Cookie.prototype.expirationDate;
 /** @type {string} */
chrome.cookies.Cookie.prototype.path;
 /** @type {boolean} */
chrome.cookies.Cookie.prototype.httpOnly;
 /** @type {boolean} */
chrome.cookies.Cookie.prototype.secure;
/**
 * @record
 * @struct
 */
chrome.cookies.CookieStore = function() {};
 /** @type {string} */
chrome.cookies.CookieStore.prototype.id;
 /** @type {!Array<number>} */
chrome.cookies.CookieStore.prototype.tabIds;
/**
 * @record
 * @struct
 */
chrome.cookies.GetAllDetails = function() {};
 /** @type {string} */
chrome.cookies.GetAllDetails.prototype.domain;
 /** @type {string} */
chrome.cookies.GetAllDetails.prototype.name;
 /** @type {string} */
chrome.cookies.GetAllDetails.prototype.url;
 /** @type {string} */
chrome.cookies.GetAllDetails.prototype.storeId;
 /** @type {boolean} */
chrome.cookies.GetAllDetails.prototype.session;
 /** @type {string} */
chrome.cookies.GetAllDetails.prototype.path;
 /** @type {boolean} */
chrome.cookies.GetAllDetails.prototype.secure;
/**
 * @record
 * @struct
 */
chrome.cookies.SetDetails = function() {};
 /** @type {string} */
chrome.cookies.SetDetails.prototype.domain;
 /** @type {string} */
chrome.cookies.SetDetails.prototype.name;
 /** @type {string} */
chrome.cookies.SetDetails.prototype.url;
 /** @type {string} */
chrome.cookies.SetDetails.prototype.storeId;
 /** @type {string} */
chrome.cookies.SetDetails.prototype.value;
 /** @type {number} */
chrome.cookies.SetDetails.prototype.expirationDate;
 /** @type {string} */
chrome.cookies.SetDetails.prototype.path;
 /** @type {boolean} */
chrome.cookies.SetDetails.prototype.httpOnly;
 /** @type {boolean} */
chrome.cookies.SetDetails.prototype.secure;
/**
 * @record
 * @struct
 */
chrome.cookies.Details = function() {};
 /** @type {string} */
chrome.cookies.Details.prototype.name;
 /** @type {string} */
chrome.cookies.Details.prototype.url;
 /** @type {string} */
chrome.cookies.Details.prototype.storeId;
/**
 * @record
 * @struct
 */
chrome.cookies.CookieChangeInfo = function() {};
 /** @type {!chrome.cookies.Cookie} */
chrome.cookies.CookieChangeInfo.prototype.cookie;
 /** @type {boolean} */
chrome.cookies.CookieChangeInfo.prototype.removed;
 /** @type {string} */
chrome.cookies.CookieChangeInfo.prototype.cause;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.cookies.CookieChangedEvent = function() {};

/**
 * Lists all existing cookie stores.
 * @param {function(!Array<!chrome.cookies.CookieStore>): void} callback The callback parameter should be a function that looks like this:
 * function(array of CookieStore cookieStores) {...};
 * Parameter cookieStores: All the existing cookie stores.
 * @return {void}
 */
chrome.cookies.getAllCookieStores = function(callback) {};

/**
 * Retrieves all cookies from a single cookie store that match the given information. The cookies returned will be sorted, with those with the longest path first. If multiple cookies have the same path length, those with the earliest creation time will be first.
 * @param {!chrome.cookies.GetAllDetails} details Information to filter the cookies being retrieved.
 * @param {function(!Array<!chrome.cookies.Cookie>): void} callback The callback parameter should be a function that looks like this:
 * function(array of Cookie cookies) {...};
 * Parameter cookies: All the existing, unexpired cookies that match the given cookie info.
 * @return {void}
 */
chrome.cookies.getAll = function(details, callback) {};

/**
 * Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
 * @param {!chrome.cookies.SetDetails} details Details about the cookie being set.
 * @param {function(!chrome.cookies.Cookie): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function( Cookie cookie) {...};
 * Optional parameter cookie: Contains details about the cookie that's been set. If setting failed for any reason, this will be "null", and "chrome.runtime.lastError" will be set.
 * @return {void}
 */
chrome.cookies.set = function(details, callback) {};

/**
 * Deletes a cookie by name.
 * @param {!chrome.cookies.Details} details Information to identify the cookie to remove.
 * @param {function(!chrome.cookies.Details): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(object details) {...};
 * @return {void}
 */
chrome.cookies.remove = function(details, callback) {};

/**
 * Retrieves information about a single cookie. If more than one cookie of the same name exists for the given URL, the one with the longest path will be returned. For cookies with the same path length, the cookie with the earliest creation time will be returned.
 * @param {!chrome.cookies.Details} details Details to identify the cookie being retrieved.
 * @param {function(!chrome.cookies.Cookie): void} callback The callback parameter should be a function that looks like this:
 * function( Cookie cookie) {...};
 * Parameter cookie: Contains details about the cookie. This parameter is null if no such cookie was found.
 * @return {void}
 */
chrome.cookies.get = function(details, callback) {};
 /** @type {!chrome.cookies.CookieChangedEvent} */
chrome.cookies.onChanged;
/** @const */
chrome.declarativeContent = {};
/**
 * @record
 * @struct
 */
chrome.declarativeContent.PageStateUrlDetails = function() {};
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.hostContains;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.hostEquals;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.hostPrefix;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.hostSuffix;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.pathContains;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.pathEquals;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.pathPrefix;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.pathSuffix;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.queryContains;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.queryEquals;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.queryPrefix;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.querySuffix;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.urlContains;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.urlEquals;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.urlMatches;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.originAndPathMatches;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.urlPrefix;
 /** @type {string} */
chrome.declarativeContent.PageStateUrlDetails.prototype.urlSuffix;
 /** @type {!Array<string>} */
chrome.declarativeContent.PageStateUrlDetails.prototype.schemes;
 /** @type {!Array<(number|!Array<number>)>} */
chrome.declarativeContent.PageStateUrlDetails.prototype.ports;
/**
 * @record
 * @struct
 */
chrome.declarativeContent.PageStateMatcher = function() {};
 /** @type {!chrome.declarativeContent.PageStateUrlDetails} */
chrome.declarativeContent.PageStateMatcher.prototype.pageUrl;
 /** @type {!Array<string>} */
chrome.declarativeContent.PageStateMatcher.prototype.css;
 /** @type {boolean} */
chrome.declarativeContent.PageStateMatcher.prototype.isBookmarked;
/** @const */
chrome.declarativeWebRequest = {};
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.HeaderFilter = function() {};
 /** @type {string} */
chrome.declarativeWebRequest.HeaderFilter.prototype.nameEquals;
 /** @type {?} */
chrome.declarativeWebRequest.HeaderFilter.prototype.valueContains;
 /** @type {string} */
chrome.declarativeWebRequest.HeaderFilter.prototype.nameSuffix;
 /** @type {string} */
chrome.declarativeWebRequest.HeaderFilter.prototype.valueSuffix;
 /** @type {string} */
chrome.declarativeWebRequest.HeaderFilter.prototype.valuePrefix;
 /** @type {?} */
chrome.declarativeWebRequest.HeaderFilter.prototype.nameContains;
 /** @type {string} */
chrome.declarativeWebRequest.HeaderFilter.prototype.valueEquals;
 /** @type {string} */
chrome.declarativeWebRequest.HeaderFilter.prototype.namePrefix;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.AddResponseHeader = function() {};
 /** @type {string} */
chrome.declarativeWebRequest.AddResponseHeader.prototype.name;
 /** @type {string} */
chrome.declarativeWebRequest.AddResponseHeader.prototype.value;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RemoveResponseCookie = function() {};
 /** @type {!chrome.declarativeWebRequest.ResponseCookie} */
chrome.declarativeWebRequest.RemoveResponseCookie.prototype.filter;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RemoveResponseHeader = function() {};
 /** @type {string} */
chrome.declarativeWebRequest.RemoveResponseHeader.prototype.name;
 /** @type {string} */
chrome.declarativeWebRequest.RemoveResponseHeader.prototype.value;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RequestMatcher = function() {};
 /** @type {!Array<string>} */
chrome.declarativeWebRequest.RequestMatcher.prototype.contentType;
 /** @type {!chrome.events.UrlFilter} */
chrome.declarativeWebRequest.RequestMatcher.prototype.url;
 /** @type {!Array<string>} */
chrome.declarativeWebRequest.RequestMatcher.prototype.excludeContentType;
 /** @type {!Array<!chrome.declarativeWebRequest.HeaderFilter>} */
chrome.declarativeWebRequest.RequestMatcher.prototype.excludeResponseHeader;
 /** @type {string} */
chrome.declarativeWebRequest.RequestMatcher.prototype.resourceType;
 /** @type {!Array<!chrome.declarativeWebRequest.HeaderFilter>} */
chrome.declarativeWebRequest.RequestMatcher.prototype.responseHeaders;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.IgnoreRules = function() {};
 /** @type {number} */
chrome.declarativeWebRequest.IgnoreRules.prototype.lowerPriorityThan;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RedirectToEmptyDocument = function() {};
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RedirectRequest = function() {};
 /** @type {string} */
chrome.declarativeWebRequest.RedirectRequest.prototype.redirectUrl;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.ResponseCookie = function() {};
 /** @type {string} */
chrome.declarativeWebRequest.ResponseCookie.prototype.domain;
 /** @type {string} */
chrome.declarativeWebRequest.ResponseCookie.prototype.name;
 /** @type {string} */
chrome.declarativeWebRequest.ResponseCookie.prototype.expires;
 /** @type {number} */
chrome.declarativeWebRequest.ResponseCookie.prototype.maxAge;
 /** @type {string} */
chrome.declarativeWebRequest.ResponseCookie.prototype.value;
 /** @type {string} */
chrome.declarativeWebRequest.ResponseCookie.prototype.path;
 /** @type {string} */
chrome.declarativeWebRequest.ResponseCookie.prototype.httpOnly;
 /** @type {string} */
chrome.declarativeWebRequest.ResponseCookie.prototype.secure;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.AddResponseCookie = function() {};
 /** @type {!chrome.declarativeWebRequest.ResponseCookie} */
chrome.declarativeWebRequest.AddResponseCookie.prototype.cookie;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.EditResponseCookie = function() {};
 /** @type {!chrome.declarativeWebRequest.ResponseCookie} */
chrome.declarativeWebRequest.EditResponseCookie.prototype.filter;
 /** @type {!chrome.declarativeWebRequest.ResponseCookie} */
chrome.declarativeWebRequest.EditResponseCookie.prototype.modification;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.CancelRequest = function() {};
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RemoveRequestHeader = function() {};
 /** @type {string} */
chrome.declarativeWebRequest.RemoveRequestHeader.prototype.name;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.EditRequestCookie = function() {};
 /** @type {!chrome.declarativeWebRequest.RequestCookie} */
chrome.declarativeWebRequest.EditRequestCookie.prototype.filter;
 /** @type {!chrome.declarativeWebRequest.RequestCookie} */
chrome.declarativeWebRequest.EditRequestCookie.prototype.modification;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.SetRequestHeader = function() {};
 /** @type {string} */
chrome.declarativeWebRequest.SetRequestHeader.prototype.name;
 /** @type {string} */
chrome.declarativeWebRequest.SetRequestHeader.prototype.value;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RequestCookie = function() {};
 /** @type {string} */
chrome.declarativeWebRequest.RequestCookie.prototype.name;
 /** @type {string} */
chrome.declarativeWebRequest.RequestCookie.prototype.value;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RedirectByRegEx = function() {};
 /** @type {string} */
chrome.declarativeWebRequest.RedirectByRegEx.prototype.to;
 /** @type {string} */
chrome.declarativeWebRequest.RedirectByRegEx.prototype.from;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RedirectToTransparentImage = function() {};
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.AddRequestCookie = function() {};
 /** @type {!chrome.declarativeWebRequest.RequestCookie} */
chrome.declarativeWebRequest.AddRequestCookie.prototype.cookie;
/**
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RemoveRequestCookie = function() {};
 /** @type {!chrome.declarativeWebRequest.RequestCookie} */
chrome.declarativeWebRequest.RemoveRequestCookie.prototype.filter;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.declarativeWebRequest.RequestedEvent = function() {};
 /** @type {!chrome.declarativeWebRequest.RequestedEvent} */
chrome.declarativeWebRequest.onRequest;
/** @const */
chrome.desktopCapture = {};

/**
 * Shows desktop media picker UI with the specified set of sources.
 * Shows desktop media picker UI with the specified set of sources.
 * @param {!Array<string>} sources Set of sources that should be shown to the user.
 * @param {function(string): void|!chrome.tabs.Tab} callback_or_targetTab The callback parameter should be a function that looks like this:
 * function(string streamId) {...};
 * Parameter streamId: An opaque string that can be passed to getUserMedia() API to generate media stream that corresponds to the source selected by the user. If user didn't select any source (i.e. canceled the prompt) then the callback is called with an empty streamId. The created streamId can be used only once and expires after a few seconds when it is not used. / Optional tab for which the stream is created. If not specified then the resulting stream can be used only by the calling extension. The stream can only be used by frames in the given tab whose security origin matches tab.url.
 * @param {function(string): void=} callback The callback parameter should be a function that looks like this:
 * function(string streamId) {...};
 * Parameter streamId: An opaque string that can be passed to getUserMedia() API to generate media stream that corresponds to the source selected by the user. If user didn't select any source (i.e. canceled the prompt) then the callback is called with an empty streamId. The created streamId can be used only once and expires after a few seconds when it is not used.
 * @return {number}
 */
chrome.desktopCapture.chooseDesktopMedia = function(sources, callback_or_targetTab, callback) {};

/**
 * Hides desktop media picker dialog shown by chooseDesktopMedia().
 * @param {number} desktopMediaRequestId Id returned by chooseDesktopMedia()
 * @return {void}
 */
chrome.desktopCapture.cancelChooseDesktopMedia = function(desktopMediaRequestId) {};
/** @const */
chrome.devtools = {};
/** @const */
chrome.devtools.inspectedWindow = {};
/**
 * @record
 * @struct
 */
chrome.devtools.inspectedWindow.Resource = function() {};
 /** @type {string} */
chrome.devtools.inspectedWindow.Resource.prototype.url;

/**
 * Gets the content of the resource.
 * @param {function(string, string): void} callback A function that receives resource content when the request completes.
 * The callback parameter should be a function that looks like this:
 * function(string content, string encoding) {...};
 * Parameter content: Content of the resource (potentially encoded).
 * Parameter encoding: Empty if content is not encoded, encoding name otherwise. Currently, only base64 is supported.
 * @return {void}
 */
chrome.devtools.inspectedWindow.Resource.prototype.getContent = function(callback) {};

/**
 * Sets the content of the resource.
 * @param {string} content New content of the resource. Only resources with the text type are currently supported.
 * @param {boolean} commit True if the user has finished editing the resource, and the new content of the resource should be persisted; false if this is a minor change sent in progress of the user editing the resource.
 * @param {function(!Object): void=} callback A function called upon request completion.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(object error) {...};
 * Optional parameter error: Set to undefined if the resource content was set successfully; describes error otherwise.
 * @return {void}
 */
chrome.devtools.inspectedWindow.Resource.prototype.setContent = function(content, commit, callback) {};
/**
 * @record
 * @struct
 */
chrome.devtools.inspectedWindow.ReloadOptions = function() {};
 /** @type {string} */
chrome.devtools.inspectedWindow.ReloadOptions.prototype.userAgent;
 /** @type {boolean} */
chrome.devtools.inspectedWindow.ReloadOptions.prototype.ignoreCache;
 /** @type {string} */
chrome.devtools.inspectedWindow.ReloadOptions.prototype.injectedScript;
 /** @type {string} */
chrome.devtools.inspectedWindow.ReloadOptions.prototype.preprocessorScript;
/**
 * @record
 * @struct
 */
chrome.devtools.inspectedWindow.EvaluationExceptionInfo = function() {};
 /** @type {boolean} */
chrome.devtools.inspectedWindow.EvaluationExceptionInfo.prototype.isError;
 /** @type {string} */
chrome.devtools.inspectedWindow.EvaluationExceptionInfo.prototype.code;
 /** @type {string} */
chrome.devtools.inspectedWindow.EvaluationExceptionInfo.prototype.description;
 /** @type {!Array<?>} */
chrome.devtools.inspectedWindow.EvaluationExceptionInfo.prototype.details;
 /** @type {boolean} */
chrome.devtools.inspectedWindow.EvaluationExceptionInfo.prototype.isException;
 /** @type {string} */
chrome.devtools.inspectedWindow.EvaluationExceptionInfo.prototype.value;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.inspectedWindow.ResourceAddedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.inspectedWindow.ResourceContentCommittedEvent = function() {};
 /** @type {number} */
chrome.devtools.inspectedWindow.tabId;

/**
 * Reloads the inspected page.
 * @param {!chrome.devtools.inspectedWindow.ReloadOptions} reloadOptions
 * @return {void}
 */
chrome.devtools.inspectedWindow.reload = function(reloadOptions) {};

/**
 * Evaluates a JavaScript expression in the context of the main frame of the inspected page. The expression must evaluate to a JSON-compliant object, otherwise an exception is thrown. The eval function can report either a DevTools-side error or a JavaScript exception that occurs during evaluation. In either case, the result parameter of the callback is undefined. In the case of a DevTools-side error, the isException parameter is non-null and has isError set to true and code set to an error code. In the case of a JavaScript error, isException is set to true and value is set to the string value of thrown object.
 * @param {string} expression An expression to evaluate.
 * @param {function(!Object, !chrome.devtools.inspectedWindow.EvaluationExceptionInfo): void=} callback A function called when evaluation completes.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(object result, object exceptionInfo) {...};
 * Parameter result: The result of evaluation.
 * Parameter exceptionInfo: An object providing details if an exception occurred while evaluating the expression.
 * @return {void}
 */
chrome.devtools.inspectedWindow.eval = function(expression, callback) {};

/**
 * Retrieves the list of resources from the inspected page.
 * @param {function(!Array<!chrome.devtools.inspectedWindow.Resource>): void} callback A function that receives the list of resources when the request completes.
 * The callback parameter should be a function that looks like this:
 * function(array of Resource resources) {...};
 * @return {void}
 */
chrome.devtools.inspectedWindow.getResources = function(callback) {};
 /** @type {!chrome.devtools.inspectedWindow.ResourceAddedEvent} */
chrome.devtools.inspectedWindow.onResourceAdded;
 /** @type {!chrome.devtools.inspectedWindow.ResourceContentCommittedEvent} */
chrome.devtools.inspectedWindow.onResourceContentCommitted;
/** @const */
chrome.devtools.network = {};
/**
 * @record
 * @struct
 */
chrome.devtools.network.Request = function() {};

/**
 * Returns content of the response body.
 * @param {function(string, string): void} callback A function that receives the response body when the request completes.
 * The callback parameter should be a function that looks like this:
 * function(string content, string encoding) {...};
 * Parameter content: Content of the response body (potentially encoded).
 * Parameter encoding: Empty if content is not encoded, encoding name otherwise. Currently, only base64 is supported.
 * @return {void}
 */
chrome.devtools.network.Request.prototype.getContent = function(callback) {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.network.RequestFinishedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.network.NavigatedEvent = function() {};

/**
 * Returns HAR log that contains all known network requests.
 * @param {function(!Object): void} callback A function that receives the HAR log when the request completes.
 * The callback parameter should be a function that looks like this:
 * function(object harLog) {...};
 * Parameter harLog: A HAR log. See HAR specification for details.
 * @return {void}
 */
chrome.devtools.network.getHAR = function(callback) {};
 /** @type {!chrome.devtools.network.RequestFinishedEvent} */
chrome.devtools.network.onRequestFinished;
 /** @type {!chrome.devtools.network.NavigatedEvent} */
chrome.devtools.network.onNavigated;
/** @const */
chrome.devtools.panels = {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.panels.PanelShownEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.panels.PanelHiddenEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.panels.PanelSearchEvent = function() {};
/**
 * @record
 * @struct
 */
chrome.devtools.panels.ExtensionPanel = function() {};
 /** @type {!chrome.devtools.panels.PanelShownEvent} */
chrome.devtools.panels.ExtensionPanel.prototype.onShown;
 /** @type {!chrome.devtools.panels.PanelHiddenEvent} */
chrome.devtools.panels.ExtensionPanel.prototype.onHidden;
 /** @type {!chrome.devtools.panels.PanelSearchEvent} */
chrome.devtools.panels.ExtensionPanel.prototype.onSearch;

/**
 * Appends a button to the status bar of the panel.
 * @param {string} iconPath Path to the icon of the button. The file should contain a 64x24-pixel image composed of two 32x24 icons. The left icon is used when the button is inactive; the right icon is displayed when the button is pressed.
 * @param {string} tooltipText Text shown as a tooltip when user hovers the mouse over the button.
 * @param {boolean} disabled Whether the button is disabled.
 * @return {!chrome.devtools.panels.Button}
 */
chrome.devtools.panels.ExtensionPanel.prototype.createStatusBarButton = function(iconPath, tooltipText, disabled) {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.panels.ButtonClickedEvent = function() {};
/**
 * @record
 * @struct
 */
chrome.devtools.panels.Button = function() {};
 /** @type {!chrome.devtools.panels.ButtonClickedEvent} */
chrome.devtools.panels.Button.prototype.onClicked;

/**
 * Updates the attributes of the button. If some of the arguments are omitted or null, the corresponding attributes are not updated.
 * @param {string=} iconPath Path to the new icon of the button.
 * @param {string=} tooltipText Text shown as a tooltip when user hovers the mouse over the button.
 * @param {boolean=} disabled Whether the button is disabled.
 * @return {void}
 */
chrome.devtools.panels.Button.prototype.update = function(iconPath, tooltipText, disabled) {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.panels.SelectionChangedEvent = function() {};
/**
 * @record
 * @struct
 */
chrome.devtools.panels.ElementsPanel = function() {};
 /** @type {!chrome.devtools.panels.SelectionChangedEvent} */
chrome.devtools.panels.ElementsPanel.prototype.onSelectionChanged;

/**
 * Creates a pane within panel's sidebar.
 * @param {string} title Text that is displayed in sidebar caption.
 * @param {function(!chrome.devtools.panels.ExtensionSidebarPane): void=} callback A callback invoked when the sidebar is created.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function( ExtensionSidebarPane result) {...};
 * Parameter result: An ExtensionSidebarPane object for created sidebar pane.
 * @return {void}
 */
chrome.devtools.panels.ElementsPanel.prototype.createSidebarPane = function(title, callback) {};
/**
 * @record
 * @struct
 */
chrome.devtools.panels.SourcesPanel = function() {};
 /** @type {!chrome.devtools.panels.SelectionChangedEvent} */
chrome.devtools.panels.SourcesPanel.prototype.onSelectionChanged;

/**
 * Creates a pane within panel's sidebar.
 * @param {string} title Text that is displayed in sidebar caption.
 * @param {function(!chrome.devtools.panels.ExtensionSidebarPane): void=} callback A callback invoked when the sidebar is created.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function( ExtensionSidebarPane result) {...};
 * Parameter result: An ExtensionSidebarPane object for created sidebar pane.
 * @return {void}
 */
chrome.devtools.panels.SourcesPanel.prototype.createSidebarPane = function(title, callback) {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.panels.ExtensionSidebarPaneShownEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.devtools.panels.ExtensionSidebarPaneHiddenEvent = function() {};
/**
 * @record
 * @struct
 */
chrome.devtools.panels.ExtensionSidebarPane = function() {};
 /** @type {!chrome.devtools.panels.ExtensionSidebarPaneShownEvent} */
chrome.devtools.panels.ExtensionSidebarPane.prototype.onShown;
 /** @type {!chrome.devtools.panels.ExtensionSidebarPaneHiddenEvent} */
chrome.devtools.panels.ExtensionSidebarPane.prototype.onHidden;

/**
 * Sets the height of the sidebar.
 * @param {string} height A CSS-like size specification, such as '100px' or '12ex'.
 * @return {void}
 */
chrome.devtools.panels.ExtensionSidebarPane.prototype.setHeight = function(height) {};

/**
 * Sets an expression that is evaluated within the inspected page. The result is displayed in the sidebar pane.
 * Sets an expression that is evaluated within the inspected page. The result is displayed in the sidebar pane.
 * @param {string} expression An expression to be evaluated in context of the inspected page. JavaScript objects and DOM nodes are displayed in an expandable tree similar to the console/watch.
 * @param {string|function(): void=} rootTitle_or_callback An optional title for the root of the expression tree. / A callback invoked after the sidebar pane is updated with the expression evaluation results.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @param {function(): void=} callback A callback invoked after the sidebar pane is updated with the expression evaluation results.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.devtools.panels.ExtensionSidebarPane.prototype.setExpression = function(expression, rootTitle_or_callback, callback) {};

/**
 * Sets a JSON-compliant object to be displayed in the sidebar pane.
 * Sets a JSON-compliant object to be displayed in the sidebar pane.
 * @param {!Object} jsonObject An object to be displayed in context of the inspected page. Evaluated in the context of the caller (API client).
 * @param {string|function(): void=} rootTitle_or_callback An optional title for the root of the expression tree. / A callback invoked after the sidebar is updated with the object.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @param {function(): void=} callback A callback invoked after the sidebar is updated with the object.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.devtools.panels.ExtensionSidebarPane.prototype.setObject = function(jsonObject, rootTitle_or_callback, callback) {};

/**
 * Sets an HTML page to be displayed in the sidebar pane.
 * @param {string} path Relative path of an extension page to display within the sidebar.
 * @return {void}
 */
chrome.devtools.panels.ExtensionSidebarPane.prototype.setPage = function(path) {};
 /** @type {!chrome.devtools.panels.ElementsPanel} */
chrome.devtools.panels.elements;
 /** @type {!chrome.devtools.panels.SourcesPanel} */
chrome.devtools.panels.sources;

/**
 * Creates an extension panel.
 * @param {string} title Title that is displayed next to the extension icon in the Developer Tools toolbar.
 * @param {string} iconPath Path of the panel's icon relative to the extension directory.
 * @param {string} pagePath Path of the panel's HTML page relative to the extension directory.
 * @param {function(!chrome.devtools.panels.ExtensionPanel): void=} callback A function that is called when the panel is created.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function( ExtensionPanel panel) {...};
 * Parameter panel: An ExtensionPanel object representing the created panel.
 * @return {void}
 */
chrome.devtools.panels.create = function(title, iconPath, pagePath, callback) {};

/**
 * Specifies the function to be called when the user clicks a resource link in the Developer Tools window. To unset the handler, either call the method with no parameters or pass null as the parameter.
 * @param {function(!chrome.devtools.inspectedWindow.Resource): void=} callback A function that is called when the user clicks on a valid resource link in Developer Tools window. Note that if the user clicks an invalid URL or an XHR, this function is not called.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function( devtools.inspectedWindow.Resource resource) {...};
 * Parameter resource: A devtools.inspectedWindow.Resource object for the resource that was clicked.
 * @return {void}
 */
chrome.devtools.panels.setOpenResourceHandler = function(callback) {};

/**
 * Since Chrome 38.
 * Requests DevTools to open a URL in a Developer Tools panel.
 * @param {string} url The URL of the resource to open.
 * @param {number} lineNumber Specifies the line number to scroll to when the resource is loaded.
 * @param {function(): void} callback A function that is called when the resource has been successfully loaded.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.devtools.panels.openResource = function(url, lineNumber, callback) {};
/** @const */
chrome.documentScan = {};
/**
 * @record
 * @struct
 */
chrome.documentScan.DocumentScanOptions = function() {};
 /** @type {!Array<string>} */
chrome.documentScan.DocumentScanOptions.prototype.mimeTypes;
 /** @type {number} */
chrome.documentScan.DocumentScanOptions.prototype.maxImages;
/**
 * @record
 * @struct
 */
chrome.documentScan.DocumentScanCallbackArg = function() {};
 /** @type {!Array<string>} */
chrome.documentScan.DocumentScanCallbackArg.prototype.dataUrls;
 /** @type {string} */
chrome.documentScan.DocumentScanCallbackArg.prototype.mimeType;

/**
 * Performs a document scan. On success, the PNG data will be sent to the callback.
 * @param {!chrome.documentScan.DocumentScanOptions} options Object containing scan parameters.
 * @param {function(!chrome.documentScan.DocumentScanCallbackArg): void} callback Called with the result and data from the scan.
 * The callback parameter should be a function that looks like this:
 * function(object result) {...};
 * @return {void}
 */
chrome.documentScan.scan = function(options, callback) {};
/** @const */
chrome.downloads = {};
/**
 * @record
 * @struct
 */
chrome.downloads.HeaderNameValuePair = function() {};
 /** @type {string} */
chrome.downloads.HeaderNameValuePair.prototype.name;
 /** @type {string} */
chrome.downloads.HeaderNameValuePair.prototype.value;
/**
 * @record
 * @struct
 */
chrome.downloads.DownloadOptions = function() {};
 /** @type {string} */
chrome.downloads.DownloadOptions.prototype.body;
 /** @type {boolean} */
chrome.downloads.DownloadOptions.prototype.saveAs;
 /** @type {string} */
chrome.downloads.DownloadOptions.prototype.url;
 /** @type {string} */
chrome.downloads.DownloadOptions.prototype.filename;
 /** @type {!Array<!chrome.downloads.HeaderNameValuePair>} */
chrome.downloads.DownloadOptions.prototype.headers;
 /** @type {string} */
chrome.downloads.DownloadOptions.prototype.method;
 /** @type {string} */
chrome.downloads.DownloadOptions.prototype.conflictAction;
/**
 * @record
 * @struct
 */
chrome.downloads.DownloadDelta = function() {};
 /** @type {!chrome.downloads.StringDelta} */
chrome.downloads.DownloadDelta.prototype.danger;
 /** @type {!chrome.downloads.StringDelta} */
chrome.downloads.DownloadDelta.prototype.url;
 /** @type {!chrome.downloads.DoubleDelta} */
chrome.downloads.DownloadDelta.prototype.totalBytes;
 /** @type {!chrome.downloads.StringDelta} */
chrome.downloads.DownloadDelta.prototype.filename;
 /** @type {!chrome.downloads.BooleanDelta} */
chrome.downloads.DownloadDelta.prototype.paused;
 /** @type {!chrome.downloads.StringDelta} */
chrome.downloads.DownloadDelta.prototype.state;
 /** @type {!chrome.downloads.StringDelta} */
chrome.downloads.DownloadDelta.prototype.mime;
 /** @type {!chrome.downloads.DoubleDelta} */
chrome.downloads.DownloadDelta.prototype.fileSize;
 /** @type {!chrome.downloads.DoubleDelta} */
chrome.downloads.DownloadDelta.prototype.startTime;
 /** @type {!chrome.downloads.StringDelta} */
chrome.downloads.DownloadDelta.prototype.error;
 /** @type {!chrome.downloads.DoubleDelta} */
chrome.downloads.DownloadDelta.prototype.endTime;
 /** @type {number} */
chrome.downloads.DownloadDelta.prototype.id;
 /** @type {!chrome.downloads.BooleanDelta} */
chrome.downloads.DownloadDelta.prototype.canResume;
 /** @type {!chrome.downloads.BooleanDelta} */
chrome.downloads.DownloadDelta.prototype.exists;
/**
 * @record
 * @struct
 */
chrome.downloads.BooleanDelta = function() {};
 /** @type {boolean} */
chrome.downloads.BooleanDelta.prototype.current;
 /** @type {boolean} */
chrome.downloads.BooleanDelta.prototype.previous;
/**
 * @record
 * @struct
 */
chrome.downloads.DoubleDelta = function() {};
 /** @type {number} */
chrome.downloads.DoubleDelta.prototype.current;
 /** @type {number} */
chrome.downloads.DoubleDelta.prototype.previous;
/**
 * @record
 * @struct
 */
chrome.downloads.StringDelta = function() {};
 /** @type {string} */
chrome.downloads.StringDelta.prototype.current;
 /** @type {string} */
chrome.downloads.StringDelta.prototype.previous;
/**
 * @record
 * @struct
 */
chrome.downloads.DownloadItem = function() {};
 /** @type {number} */
chrome.downloads.DownloadItem.prototype.bytesReceived;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.danger;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.url;
 /** @type {number} */
chrome.downloads.DownloadItem.prototype.totalBytes;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.filename;
 /** @type {boolean} */
chrome.downloads.DownloadItem.prototype.paused;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.state;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.mime;
 /** @type {number} */
chrome.downloads.DownloadItem.prototype.fileSize;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.startTime;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.error;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.endTime;
 /** @type {number} */
chrome.downloads.DownloadItem.prototype.id;
 /** @type {boolean} */
chrome.downloads.DownloadItem.prototype.incognito;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.referrer;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.estimatedEndTime;
 /** @type {boolean} */
chrome.downloads.DownloadItem.prototype.canResume;
 /** @type {boolean} */
chrome.downloads.DownloadItem.prototype.exists;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.byExtensionId;
 /** @type {string} */
chrome.downloads.DownloadItem.prototype.byExtensionName;
/**
 * @record
 * @struct
 */
chrome.downloads.GetFileIconOptions = function() {};
 /** @type {number} */
chrome.downloads.GetFileIconOptions.prototype.size;
/**
 * @record
 * @struct
 */
chrome.downloads.DownloadQuery = function() {};
 /** @type {!Array<string>} */
chrome.downloads.DownloadQuery.prototype.orderBy;
 /** @type {string} */
chrome.downloads.DownloadQuery.prototype.urlRegex;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.endedBefore;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.totalBytesGreater;
 /** @type {string} */
chrome.downloads.DownloadQuery.prototype.danger;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.totalBytes;
 /** @type {boolean} */
chrome.downloads.DownloadQuery.prototype.paused;
 /** @type {string} */
chrome.downloads.DownloadQuery.prototype.filenameRegex;
 /** @type {!Array<string>} */
chrome.downloads.DownloadQuery.prototype.query;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.totalBytesLess;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.id;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.bytesReceived;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.endedAfter;
 /** @type {string} */
chrome.downloads.DownloadQuery.prototype.filename;
 /** @type {string} */
chrome.downloads.DownloadQuery.prototype.state;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.startedAfter;
 /** @type {string} */
chrome.downloads.DownloadQuery.prototype.mime;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.fileSize;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.startTime;
 /** @type {string} */
chrome.downloads.DownloadQuery.prototype.url;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.startedBefore;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.limit;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.error;
 /** @type {number} */
chrome.downloads.DownloadQuery.prototype.endTime;
 /** @type {boolean} */
chrome.downloads.DownloadQuery.prototype.exists;
/**
 * @record
 * @struct
 */
chrome.downloads.DownloadFilenameSuggestion = function() {};
 /** @type {string} */
chrome.downloads.DownloadFilenameSuggestion.prototype.filename;
 /** @type {string} */
chrome.downloads.DownloadFilenameSuggestion.prototype.conflictAction;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.downloads.DownloadChangedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.downloads.DownloadCreatedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.downloads.DownloadErasedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.downloads.DownloadDeterminingFilenameEvent = function() {};

/**
 * Find DownloadItem. Set query to the empty object to get all DownloadItem. To get a specific DownloadItem, set only the id field. To page through a large number of items, set orderBy: ['-startTime'], set limit to the number of items per page, and set startedAfter to the startTime of the last item from the last page.
 * @param {!chrome.downloads.DownloadQuery} query
 * @param {function(!Array<!chrome.downloads.DownloadItem>): void} callback The callback parameter should be a function that looks like this:
 * function(array of DownloadItem results) {...};
 * @return {void}
 */
chrome.downloads.search = function(query, callback) {};

/**
 * Pause the download. If the request was successful the download is in a paused state. Otherwise runtime.lastError contains an error message. The request will fail if the download is not active.
 * @param {number} downloadId The id of the download to pause.
 * @param {function(): void=} callback Called when the pause request is completed.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.downloads.pause = function(downloadId, callback) {};

/**
 * Retrieve an icon for the specified download. For new downloads, file icons are available after the onCreated event has been received. The image returned by this function while a download is in progress may be different from the image returned after the download is complete. Icon retrieval is done by querying the underlying operating system or toolkit depending on the platform. The icon that is returned will therefore depend on a number of factors including state of the download, platform, registered file types and visual theme. If a file icon cannot be determined, runtime.lastError will contain an error message.
 * Retrieve an icon for the specified download. For new downloads, file icons are available after the onCreated event has been received. The image returned by this function while a download is in progress may be different from the image returned after the download is complete. Icon retrieval is done by querying the underlying operating system or toolkit depending on the platform. The icon that is returned will therefore depend on a number of factors including state of the download, platform, registered file types and visual theme. If a file icon cannot be determined, runtime.lastError will contain an error message.
 * @param {number} downloadId The identifier for the download.
 * @param {function(string): void|!chrome.downloads.GetFileIconOptions} callback_or_options A URL to an image that represents the download.
 * The callback parameter should be a function that looks like this:
 * function(string iconURL) {...};
 * @param {function(string): void=} callback A URL to an image that represents the download.
 * The callback parameter should be a function that looks like this:
 * function(string iconURL) {...};
 * @return {void}
 */
chrome.downloads.getFileIcon = function(downloadId, callback_or_options, callback) {};

/**
 * Resume a paused download. If the request was successful the download is in progress and unpaused. Otherwise runtime.lastError contains an error message. The request will fail if the download is not active.
 * @param {number} downloadId The id of the download to resume.
 * @param {function(): void=} callback  Called when the resume request is completed.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.downloads.resume = function(downloadId, callback) {};

/**
 * Cancel a download. When callback is run, the download is cancelled, completed, interrupted or doesn't exist anymore.
 * @param {number} downloadId The id of the download to cancel.
 * @param {function(): void=} callback Called when the cancel request is completed.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.downloads.cancel = function(downloadId, callback) {};

/**
 * Download a URL. If the URL uses the HTTP[S] protocol, then the request will include all cookies currently set for its hostname. If both filename and saveAs are specified, then the Save As dialog will be displayed, pre-populated with the specified filename. If the download started successfully, callback will be called with the new DownloadItem's downloadId. If there was an error starting the download, then callback will be called with downloadId=undefined and runtime.lastError will contain a descriptive string. The error strings are not guaranteed to remain backwards compatible between releases. Extensions must not parse it.
 * @param {!chrome.downloads.DownloadOptions} options What to download and how.
 * @param {function(number): void=} callback Called with the id of the new DownloadItem.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(integer downloadId) {...};
 * @return {void}
 */
chrome.downloads.download = function(options, callback) {};

/**
 * Open the downloaded file now if the DownloadItem is complete; otherwise returns an error through runtime.lastError. Requires the "downloads.open" permission in addition to the "downloads" permission. An onChanged event will fire when the item is opened for the first time.
 * @param {number} downloadId The identifier for the downloaded file.
 * @return {void}
 */
chrome.downloads.open = function(downloadId) {};

/**
 * Show the downloaded file in its folder in a file manager.
 * @param {number} downloadId The identifier for the downloaded file.
 * @return {void}
 */
chrome.downloads.show = function(downloadId) {};

/**
 * Show the default Downloads folder in a file manager.
 * @return {void}
 */
chrome.downloads.showDefaultFolder = function() {};

/**
 * Erase matching DownloadItem from history without deleting the downloaded file. An onErased event will fire for each DownloadItem that matches query, then callback will be called.
 * @param {!chrome.downloads.DownloadQuery} query
 * @param {function(!Array<number>): void} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(array of integer erasedIds) {...};
 * @return {void}
 */
chrome.downloads.erase = function(query, callback) {};

/**
 * Remove the downloaded file if it exists and the DownloadItem is complete; otherwise return an error through runtime.lastError.
 * @param {number} downloadId
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.downloads.removeFile = function(downloadId, callback) {};

/**
 * Prompt the user to accept a dangerous download. Can only be called from a visible context (tab, window, or page/browser action popup). Does not automatically accept dangerous downloads. If the download is accepted, then an onChanged event will fire, otherwise nothing will happen. When all the data is fetched into a temporary file and either the download is not dangerous or the danger has been accepted, then the temporary file is renamed to the target filename, the |state| changes to 'complete', and onChanged fires.
 * @param {number} downloadId The identifier for the DownloadItem.
 * @param {function(): void} callback Called when the danger prompt dialog closes.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.downloads.acceptDanger = function(downloadId, callback) {};

/**
 * Initiate dragging the downloaded file to another application. Call in a javascript ondragstart handler.
 * @param {number} downloadId
 * @return {void}
 */
chrome.downloads.drag = function(downloadId) {};

/**
 * Enable or disable the gray shelf at the bottom of every window associated with the current browser profile. The shelf will be disabled as long as at least one extension has disabled it. Enabling the shelf while at least one other extension has disabled it will return an error through runtime.lastError. Requires the "downloads.shelf" permission in addition to the "downloads" permission.
 * @param {boolean} enabled
 * @return {void}
 */
chrome.downloads.setShelfEnabled = function(enabled) {};
 /** @type {!chrome.downloads.DownloadChangedEvent} */
chrome.downloads.onChanged;
 /** @type {!chrome.downloads.DownloadCreatedEvent} */
chrome.downloads.onCreated;
 /** @type {!chrome.downloads.DownloadErasedEvent} */
chrome.downloads.onErased;
 /** @type {!chrome.downloads.DownloadDeterminingFilenameEvent} */
chrome.downloads.onDeterminingFilename;
/** @const */
chrome.enterprise = {};
/** @const */
chrome.enterprise.platformKeys = {};
/**
 * @record
 * @struct
 */
chrome.enterprise.platformKeys.Token = function() {};
 /** @type {string} */
chrome.enterprise.platformKeys.Token.prototype.id;
 /** @type {!SubtleCrypto} */
chrome.enterprise.platformKeys.Token.prototype.subtleCrypto;

/**
 * Returns the available Tokens. In a regular user's session the list will always contain the user's token with id "user". If a system-wide TPM token is available, the returned list will also contain the system-wide token with id "system". The system-wide token will be the same for all sessions on this device (device in the sense of e.g. a Chromebook).
 * @param {function(!Array<!chrome.enterprise.platformKeys.Token>): void} callback Invoked by getTokens with the list of available Tokens.
 * The callback parameter should be a function that looks like this:
 * function(array of Token tokens) {...};
 * Parameter tokens: The list of available tokens.
 * @return {void}
 */
chrome.enterprise.platformKeys.getToken = function(callback) {};

/**
 * Returns the list of all client certificates available from the given token. Can be used to check for the existence and expiration of client certificates that are usable for a certain authentication.
 * @param {string} tokenId The id of a Token returned by getTokens.
 * @param {function(!ArrayBuffer): void} callback Called back with the list of the available certificates.
 * The callback parameter should be a function that looks like this:
 * function(array of ArrayBuffer certificates) {...};
 * Parameter certificates: The list of certificates, each in DER encoding of a X.509 certificate.
 * @return {void}
 */
chrome.enterprise.platformKeys.getCertificates = function(tokenId, callback) {};

/**
 * Imports certificate to the given token if the certified key is already stored in this token. After a successful certification request, this function should be used to store the obtained certificate and to make it available to the operating system and browser for authentication.
 * @param {string} tokenId The id of a Token returned by getTokens.
 * @param {!ArrayBuffer} certificate The DER encoding of a X.509 certificate.
 * @param {function(): void=} callback Called back when this operation is finished.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.enterprise.platformKeys.importCertificate = function(tokenId, certificate, callback) {};

/**
 * Removes certificate from the given token if present. Should be used to remove obsolete certificates so that they are not considered during authentication and do not clutter the certificate choice. Should be used to free storage in the certificate store.
 * @param {string} tokenId The id of a Token returned by getTokens.
 * @param {!ArrayBuffer} certificate The DER encoding of a X.509 certificate.
 * @param {function(): void=} callback Called back when this operation is finished.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.enterprise.platformKeys.removeCertificate = function(tokenId, certificate, callback) {};
/** @const */
chrome.events = {};
/**
 * @record
 * @struct
 */
chrome.events.UrlFilter = function() {};
 /** @type {!Array<string>} */
chrome.events.UrlFilter.prototype.schemes;
 /** @type {string} */
chrome.events.UrlFilter.prototype.urlMatches;
 /** @type {string} */
chrome.events.UrlFilter.prototype.pathContains;
 /** @type {string} */
chrome.events.UrlFilter.prototype.hostSuffix;
 /** @type {string} */
chrome.events.UrlFilter.prototype.hostPrefix;
 /** @type {string} */
chrome.events.UrlFilter.prototype.hostContains;
 /** @type {string} */
chrome.events.UrlFilter.prototype.urlContains;
 /** @type {string} */
chrome.events.UrlFilter.prototype.querySuffix;
 /** @type {string} */
chrome.events.UrlFilter.prototype.urlPrefix;
 /** @type {string} */
chrome.events.UrlFilter.prototype.hostEquals;
 /** @type {string} */
chrome.events.UrlFilter.prototype.urlEquals;
 /** @type {string} */
chrome.events.UrlFilter.prototype.queryContains;
 /** @type {string} */
chrome.events.UrlFilter.prototype.pathPrefix;
 /** @type {string} */
chrome.events.UrlFilter.prototype.pathEquals;
 /** @type {string} */
chrome.events.UrlFilter.prototype.pathSuffix;
 /** @type {string} */
chrome.events.UrlFilter.prototype.queryEquals;
 /** @type {string} */
chrome.events.UrlFilter.prototype.queryPrefix;
 /** @type {string} */
chrome.events.UrlFilter.prototype.urlSuffix;
 /** @type {!Array<?>} */
chrome.events.UrlFilter.prototype.ports;
 /** @type {string} */
chrome.events.UrlFilter.prototype.originAndPathMatches;
/**
 * @record
 * @struct
 */
chrome.events.Event = function() {};

/**
 * Registers an event listener callback to an event.
 * @param {T} callback Called when an event occurs. The parameters of this function depend on the type of event.
 * The callback parameter should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.events.Event.prototype.addListener = function(callback) {};

/**
 * Returns currently registered rules.
 * Returns currently registered rules.
 * @param {function(!Array<!chrome.events.Rule>): void|!Array<string>} callback_or_ruleIdentifiers Called with registered rules.
 * The callback parameter should be a function that looks like this:
 * function(array of Rule rules) {...};
 * Parameter rules: Rules that were registered, the optional parameters are filled with values. / If an array is passed, only rules with identifiers contained in this array are returned.
 * @param {function(!Array<!chrome.events.Rule>): void=} callback Called with registered rules.
 * The callback parameter should be a function that looks like this:
 * function(array of Rule rules) {...};
 * Parameter rules: Rules that were registered, the optional parameters are filled with values.
 * @return {void}
 */
chrome.events.Event.prototype.getRules = function(callback_or_ruleIdentifiers, callback) {};

/**
 * @param {T} callback Listener whose registration status shall be tested.
 * @return {boolean}
 */
chrome.events.Event.prototype.hasListener = function(callback) {};

/**
 * Unregisters currently registered rules.
 * Unregisters currently registered rules.
 * @param {!Array<string>|function(): void=} ruleIdentifiers_or_callback If an array is passed, only rules with identifiers contained in this array are unregistered. / Called when rules were unregistered.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @param {function(): void=} callback Called when rules were unregistered.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.events.Event.prototype.removeRules = function(ruleIdentifiers_or_callback, callback) {};

/**
 * Registers rules to handle events.
 * @param {!Array<!chrome.events.Rule>} rules Rules to be registered. These do not replace previously registered rules.
 * @param {function(!Array<!chrome.events.Rule>): void=} callback Called with registered rules.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(array of Rule rules) {...};
 * Parameter rules: Rules that were registered, the optional parameters are filled with values.
 * @return {void}
 */
chrome.events.Event.prototype.addRules = function(rules, callback) {};

/**
 * Deregisters an event listener callback from an event.
 * @param {T} callback Listener that shall be unregistered.
 * The callback parameter should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.events.Event.prototype.removeListener = function(callback) {};

/**
 * @return {boolean}
 */
chrome.events.Event.prototype.hasListeners = function() {};
/**
 * @record
 * @struct
 */
chrome.events.Rule = function() {};
 /** @type {number} */
chrome.events.Rule.prototype.priority;
 /** @type {!Array<?>} */
chrome.events.Rule.prototype.conditions;
 /** @type {string} */
chrome.events.Rule.prototype.id;
 /** @type {!Array<?>} */
chrome.events.Rule.prototype.actions;
 /** @type {!Array<string>} */
chrome.events.Rule.prototype.tags;
/** @const */
chrome.extension = {};
/**
 * @record
 * @struct
 */
chrome.extension.FetchProperties = function() {};
 /** @type {number} */
chrome.extension.FetchProperties.prototype.windowId;
 /** @type {string} */
chrome.extension.FetchProperties.prototype.type;
/**
 * @record
 * @struct
 */
chrome.extension.LastError = function() {};
 /** @type {string} */
chrome.extension.LastError.prototype.message;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.extension.OnRequestEvent = function() {};
 /** @type {boolean} */
chrome.extension.inIncognitoContext;
 /** @type {!chrome.extension.LastError} */
chrome.extension.lastError;

/**
 * Returns the JavaScript 'window' object for the background page running inside the current extension. Returns null if the extension has no background page.
 * @return {!Window}
 */
chrome.extension.getBackgroundPage = function() {};

/**
 * Converts a relative path within an extension install directory to a fully-qualified URL.
 * @param {string} path A path to a resource within an extension expressed relative to its install directory.
 * @return {string}
 */
chrome.extension.getURL = function(path) {};

/**
 * Sets the value of the ap CGI parameter used in the extension's update URL. This value is ignored for extensions that are hosted in the Chrome Extension Gallery.
 * Since Chrome 9.
 * @param {string} data
 * @return {void}
 */
chrome.extension.setUpdateUrlData = function(data) {};

/**
 * Returns an array of the JavaScript 'window' objects for each of the pages running inside the current extension.
 * @param {!chrome.extension.FetchProperties=} fetchProperties
 * @return {!Array<!Window>}
 */
chrome.extension.getViews = function(fetchProperties) {};

/**
 * Retrieves the state of the extension's access to the 'file://' scheme (as determined by the user-controlled 'Allow access to File URLs' checkbox.
 * Since Chrome 12.
 * @param {function(boolean): void} callback The callback parameter should be a function that looks like this:
 * function(boolean isAllowedAccess) {...};
 * Parameter isAllowedAccess: True if the extension can access the 'file://' scheme, false otherwise.
 * @return {void}
 */
chrome.extension.isAllowedFileSchemeAccess = function(callback) {};

/**
 * Retrieves the state of the extension's access to Incognito-mode (as determined by the user-controlled 'Allowed in Incognito' checkbox.
 * Since Chrome 12.
 * @param {function(boolean): void} callback The callback parameter should be a function that looks like this:
 * function(boolean isAllowedAccess) {...};
 * Parameter isAllowedAccess: True if the extension has access to Incognito mode, false otherwise.
 * @return {void}
 */
chrome.extension.isAllowedIncognitoAccess = function(callback) {};

/**
 * Sends a single request to other listeners within the extension. Similar to runtime.connect, but only sends a single request with an optional response. The extension.onRequest event is fired in each page of the extension.
 * @deprecated Deprecated since Chrome 33. Please use runtime.sendMessage.
 * Sends a single request to other listeners within the extension. Similar to runtime.connect, but only sends a single request with an optional response. The extension.onRequest event is fired in each page of the extension.
 * @param {string|?} extensionId_or_request The extension ID of the extension you want to connect to. If omitted, default is your own extension.
 * @param {?|function(?): void=} request_or_responseCallback If you specify the responseCallback parameter, it should be a function that looks like this:
 * function(any response) {...};
 * Parameter response: The JSON response object sent by the handler of the request. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.
 * @param {function(?): void=} responseCallback If you specify the responseCallback parameter, it should be a function that looks like this:
 * function(any response) {...};
 * Parameter response: The JSON response object sent by the handler of the request. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.
 * @return {void}
 */
chrome.extension.sendRequest = function(extensionId_or_request, request_or_responseCallback, responseCallback) {};

/**
 * Returns an array of the JavaScript 'window' objects for each of the tabs running inside the current extension. If windowId is specified, returns only the 'window' objects of tabs attached to the specified window.
 * @deprecated Deprecated since Chrome 33. Please use extension.getViews {type: "tab"}.
 * @param {number=} windowId
 * @return {!Array<!Window>}
 */
chrome.extension.getExtensionTabs = function(windowId) {};
 /** @type {!chrome.extension.OnRequestEvent} */
chrome.extension.onRequest;
 /** @type {!chrome.extension.OnRequestEvent} */
chrome.extension.onRequestExternal;
/** @const */
chrome.fileBrowserHandler = {};
/**
 * @record
 * @struct
 */
chrome.fileBrowserHandler.SelectionParams = function() {};
 /** @type {!Array<string>} */
chrome.fileBrowserHandler.SelectionParams.prototype.allowedFileExtensions;
 /** @type {string} */
chrome.fileBrowserHandler.SelectionParams.prototype.suggestedName;
/**
 * @record
 * @struct
 */
chrome.fileBrowserHandler.SelectionResult = function() {};
 /** @type {!Object} */
chrome.fileBrowserHandler.SelectionResult.prototype.entry;
 /** @type {boolean} */
chrome.fileBrowserHandler.SelectionResult.prototype.success;
/**
 * @record
 * @struct
 */
chrome.fileBrowserHandler.FileHandlerExecuteEventDetails = function() {};
 /** @type {number} */
chrome.fileBrowserHandler.FileHandlerExecuteEventDetails.prototype.tab_id;
 /** @type {!Array<?>} */
chrome.fileBrowserHandler.FileHandlerExecuteEventDetails.prototype.entries;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileBrowserHandler.FileBrowserHandlerExecuteEvent = function() {};

/**
 * Prompts user to select file path under which file should be saved. When the file is selected, file access permission required to use the file (read, write and create) are granted to the caller. The file will not actually get created during the function call, so function caller must ensure its existence before using it. The function has to be invoked with a user gesture.
 * Since Chrome 21.
 * @param {!chrome.fileBrowserHandler.SelectionParams} selectionParams Parameters that will be used while selecting the file.
 * @param {function(!chrome.fileBrowserHandler.SelectionResult): void} callback Function called upon completion.
 * The callback parameter should be a function that looks like this:
 * function(object result) {...};
 * Parameter result: Result of the method.
 * @return {void}
 */
chrome.fileBrowserHandler.selectFile = function(selectionParams, callback) {};
 /** @type {!chrome.fileBrowserHandler.FileBrowserHandlerExecuteEvent} */
chrome.fileBrowserHandler.onExecute;
/** @const */
chrome.fileSystemProvider = {};
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.OpenedFileInfo = function() {};
 /** @type {number} */
chrome.fileSystemProvider.OpenedFileInfo.prototype.openRequestId;
 /** @type {string} */
chrome.fileSystemProvider.OpenedFileInfo.prototype.filePath;
 /** @type {string} */
chrome.fileSystemProvider.OpenedFileInfo.prototype.mode;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.FileWatchersInfo = function() {};
 /** @type {string} */
chrome.fileSystemProvider.FileWatchersInfo.prototype.entryPath;
 /** @type {boolean} */
chrome.fileSystemProvider.FileWatchersInfo.prototype.recursive;
 /** @type {string} */
chrome.fileSystemProvider.FileWatchersInfo.prototype.lastTag;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.EntryMetadata = function() {};
 /** @type {boolean} */
chrome.fileSystemProvider.EntryMetadata.prototype.isDirectory;
 /** @type {string} */
chrome.fileSystemProvider.EntryMetadata.prototype.name;
 /** @type {number} */
chrome.fileSystemProvider.EntryMetadata.prototype.size;
 /** @type {!Date} */
chrome.fileSystemProvider.EntryMetadata.prototype.modificationTime;
 /** @type {string} */
chrome.fileSystemProvider.EntryMetadata.prototype.mimeType;
 /** @type {string} */
chrome.fileSystemProvider.EntryMetadata.prototype.thumbnail;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.FileSystemInfo = function() {};
 /** @type {string} */
chrome.fileSystemProvider.FileSystemInfo.prototype.fileSystemId;
 /** @type {string} */
chrome.fileSystemProvider.FileSystemInfo.prototype.displayName;
 /** @type {boolean} */
chrome.fileSystemProvider.FileSystemInfo.prototype.writable;
 /** @type {number} */
chrome.fileSystemProvider.FileSystemInfo.prototype.openedFilesLimit;
 /** @type {!Array<!chrome.fileSystemProvider.OpenedFileInfo>} */
chrome.fileSystemProvider.FileSystemInfo.prototype.openedFiles;
 /** @type {boolean} */
chrome.fileSystemProvider.FileSystemInfo.prototype.supportsNotifyTag;
 /** @type {!Array<!chrome.fileSystemProvider.FileWatchersInfo>} */
chrome.fileSystemProvider.FileSystemInfo.prototype.watchers;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.GetActionsRequestedOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.GetActionsRequestedOptions.prototype.fileSystemId;
 /** @type {number} */
chrome.fileSystemProvider.GetActionsRequestedOptions.prototype.requestId;
 /** @type {string} */
chrome.fileSystemProvider.GetActionsRequestedOptions.prototype.entryPath;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.Action = function() {};
 /** @type {string} */
chrome.fileSystemProvider.Action.prototype.id;
 /** @type {string} */
chrome.fileSystemProvider.Action.prototype.title;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.ExecuteActionRequestedOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.ExecuteActionRequestedOptions.prototype.fileSystemId;
 /** @type {number} */
chrome.fileSystemProvider.ExecuteActionRequestedOptions.prototype.requestId;
 /** @type {string} */
chrome.fileSystemProvider.ExecuteActionRequestedOptions.prototype.entryPath;
 /** @type {string} */
chrome.fileSystemProvider.ExecuteActionRequestedOptions.prototype.actionId;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.MountOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.MountOptions.prototype.fileSystemId;
 /** @type {string} */
chrome.fileSystemProvider.MountOptions.prototype.displayName;
 /** @type {boolean} */
chrome.fileSystemProvider.MountOptions.prototype.writable;
 /** @type {number} */
chrome.fileSystemProvider.MountOptions.prototype.openedFilesLimit;
 /** @type {boolean} */
chrome.fileSystemProvider.MountOptions.prototype.supportsNotifyTag;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.UnmountOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.UnmountOptions.prototype.fileSystemId;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.NotificationChange = function() {};
 /** @type {string} */
chrome.fileSystemProvider.NotificationChange.prototype.entryPath;
 /** @type {string} */
chrome.fileSystemProvider.NotificationChange.prototype.changeType;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.NotificationOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.NotificationOptions.prototype.fileSystemId;
 /** @type {string} */
chrome.fileSystemProvider.NotificationOptions.prototype.observedPath;
 /** @type {boolean} */
chrome.fileSystemProvider.NotificationOptions.prototype.recursive;
 /** @type {string} */
chrome.fileSystemProvider.NotificationOptions.prototype.changeType;
 /** @type {!Array<!chrome.fileSystemProvider.NotificationChange>} */
chrome.fileSystemProvider.NotificationOptions.prototype.changes;
 /** @type {string} */
chrome.fileSystemProvider.NotificationOptions.prototype.tag;
/**
 * @record
 * @struct
 */
chrome.fileSystemProvider.RequestedEventOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.RequestedEventOptions.prototype.fileSystemId;
 /** @type {number} */
chrome.fileSystemProvider.RequestedEventOptions.prototype.requestId;
/**
 * @extends {chrome.fileSystemProvider.RequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.EntryPathRequestedEventOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.EntryPathRequestedEventOptions.prototype.entryPath;
/**
 * @extends {chrome.fileSystemProvider.EntryPathRequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.MetadataRequestedEventOptions = function() {};
 /** @type {boolean} */
chrome.fileSystemProvider.MetadataRequestedEventOptions.prototype.thumbnail;
/**
 * @extends {chrome.fileSystemProvider.RequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.DirectoryPathRequestedEventOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.DirectoryPathRequestedEventOptions.prototype.directoryPath;
/**
 * @extends {chrome.fileSystemProvider.RequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.FilePathRequestedEventOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.FilePathRequestedEventOptions.prototype.filePath;
/**
 * @extends {chrome.fileSystemProvider.FilePathRequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OpenFileRequestedEventOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.OpenFileRequestedEventOptions.prototype.mode;
/**
 * @extends {chrome.fileSystemProvider.RequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OpenedFileRequestedEventOptions = function() {};
 /** @type {number} */
chrome.fileSystemProvider.OpenedFileRequestedEventOptions.prototype.openRequestId;
/**
 * @extends {chrome.fileSystemProvider.OpenedFileRequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OpenedFileOffsetRequestedEventOptions = function() {};
 /** @type {number} */
chrome.fileSystemProvider.OpenedFileOffsetRequestedEventOptions.prototype.offset;
 /** @type {number} */
chrome.fileSystemProvider.OpenedFileOffsetRequestedEventOptions.prototype.length;
/**
 * @extends {chrome.fileSystemProvider.DirectoryPathRequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.DirectoryPathRecursiveRequestedEventOptions = function() {};
 /** @type {boolean} */
chrome.fileSystemProvider.DirectoryPathRecursiveRequestedEventOptions.prototype.recursive;
/**
 * @extends {chrome.fileSystemProvider.EntryPathRequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.EntryPathRecursiveRequestedEventOptions = function() {};
 /** @type {boolean} */
chrome.fileSystemProvider.EntryPathRecursiveRequestedEventOptions.prototype.recursive;
/**
 * @extends {chrome.fileSystemProvider.RequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.SourceTargetPathRequestedEventOptions = function() {};
 /** @type {string} */
chrome.fileSystemProvider.SourceTargetPathRequestedEventOptions.prototype.sourcePath;
 /** @type {string} */
chrome.fileSystemProvider.SourceTargetPathRequestedEventOptions.prototype.targetPath;
/**
 * @extends {chrome.fileSystemProvider.FilePathRequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.FilePathLengthRequestedEventOptions = function() {};
 /** @type {number} */
chrome.fileSystemProvider.FilePathLengthRequestedEventOptions.prototype.length;
/**
 * @extends {chrome.fileSystemProvider.OpenedFileRequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OpenedFileIoRequestedEventOptions = function() {};
 /** @type {number} */
chrome.fileSystemProvider.OpenedFileIoRequestedEventOptions.prototype.offset;
 /** @type {!ArrayBuffer} */
chrome.fileSystemProvider.OpenedFileIoRequestedEventOptions.prototype.data;
/**
 * @extends {chrome.fileSystemProvider.RequestedEventOptions}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OperationRequestedEventOptions = function() {};
 /** @type {number} */
chrome.fileSystemProvider.OperationRequestedEventOptions.prototype.operationRequestId;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.RequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.MetadataRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.DirectoryPathRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OpenFileRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OpenedFileRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OpenedFileOffsetRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.DirectoryPathRecursiveRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.EntryPathRecursiveRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.FilePathRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.SourceTargetPathRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.FilePathLengthRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OpenedFileIoRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OperationRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fileSystemProvider.OptionlessRequestedEvent = function() {};

/**
 * Mounts a file system with the given fileSystemId and displayName. displayName will be shown in the left panel of Files.app. displayName can contain any characters including '/', but cannot be an empty string. displayName must be descriptive but doesn't have to be unique. The fileSystemId must not be an empty string.
 * Depending on the type of the file system being mounted, the source option must be set appropriately.
 * In case of an error, runtime.lastError will be set with a corresponding error code.
 * @param {!chrome.fileSystemProvider.MountOptions} options
 * @param {function(): void=} callback A generic result callback to indicate success or failure.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fileSystemProvider.mount = function(options, callback) {};

/**
 * Unmounts a file system with the given fileSystemId. It must be called after onUnmountRequested is invoked. Also, the providing extension can decide to perform unmounting if not requested (eg. in case of lost connection, or a file error).
 * In case of an error, runtime.lastError will be set with a corresponding error code.
 * @param {!chrome.fileSystemProvider.UnmountOptions} options
 * @param {function(): void=} callback A generic result callback to indicate success or failure.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fileSystemProvider.unmount = function(options, callback) {};

/**
 * Returns all file systems mounted by the extension.
 * @param {function(!Array<!chrome.fileSystemProvider.FileSystemInfo>): void} callback Callback to receive the result of getAll function.
 * The callback parameter should be a function that looks like this:
 * function(array of FileSystemInfo fileSystems) {...};
 * @return {void}
 */
chrome.fileSystemProvider.getAll = function(callback) {};

/**
 * Returns information about a file system with the passed fileSystemId.
 * \@since Since Chrome 42.
 * @param {string} fileSystemId
 * @param {function(!chrome.fileSystemProvider.FileSystemInfo): void} callback Callback to receive the result of get function.
 * The callback parameter should be a function that looks like this:
 * function(FileSystemInfo fileSystem) {...};
 * @return {void}
 */
chrome.fileSystemProvider.get = function(fileSystemId, callback) {};

/**
 * Notifies about changes in the watched directory at observedPath in recursive mode. If the file system is mounted with supportsNofityTag, then tag must be provided, and all changes since the last notification always reported, even if the system was shutdown. The last tag can be obtained with getAll.
 * To use, the file_system_provider.notify manifest option must be set to true.
 * Value of tag can be any string which is unique per call, so it's possible to identify the last registered notification. Eg. if the providing extension starts after a reboot, and the last registered notification's tag is equal to "123", then it should call notify for all changes which happened since the change tagged as "123". It cannot be an empty string.
 * Not all providers are able to provide a tag, but if the file system has a changelog, then the tag can be eg. a change number, or a revision number.
 * Note that if a parent directory is removed, then all descendant entries are also removed, and if they are watched, then the API must be notified about the fact. Also, if a directory is renamed, then all descendant entries are in fact removed, as there is no entry under their original paths anymore.
 * In case of an error, runtime.lastError will be set will a corresponding error code.
 * @param {!chrome.fileSystemProvider.NotificationOptions} options
 * @param {function(): void} callback A generic result callback to indicate success or failure.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fileSystemProvider.notify = function(options, callback) {};
 /** @type {!chrome.fileSystemProvider.RequestedEvent} */
chrome.fileSystemProvider.onUnmountRequested;
 /** @type {!chrome.fileSystemProvider.MetadataRequestedEvent} */
chrome.fileSystemProvider.onGetMetadataRequested;
 /** @type {!chrome.fileSystemProvider.DirectoryPathRequestedEvent} */
chrome.fileSystemProvider.onReadDirectoryRequested;
 /** @type {!chrome.fileSystemProvider.OpenFileRequestedEvent} */
chrome.fileSystemProvider.onOpenFileRequested;
 /** @type {!chrome.fileSystemProvider.OpenedFileRequestedEvent} */
chrome.fileSystemProvider.onCloseFileRequested;
 /** @type {!chrome.fileSystemProvider.OpenedFileOffsetRequestedEvent} */
chrome.fileSystemProvider.onReadFileRequested;
 /** @type {!chrome.fileSystemProvider.DirectoryPathRecursiveRequestedEvent} */
chrome.fileSystemProvider.onCreateDirectoryRequested;
 /** @type {!chrome.fileSystemProvider.EntryPathRecursiveRequestedEvent} */
chrome.fileSystemProvider.onDeleteEntryRequested;
 /** @type {!chrome.fileSystemProvider.FilePathRequestedEvent} */
chrome.fileSystemProvider.onCreateFileRequested;
 /** @type {!chrome.fileSystemProvider.SourceTargetPathRequestedEvent} */
chrome.fileSystemProvider.onCopyEntryRequested;
 /** @type {!chrome.fileSystemProvider.SourceTargetPathRequestedEvent} */
chrome.fileSystemProvider.onMoveEntryRequested;
 /** @type {!chrome.fileSystemProvider.FilePathLengthRequestedEvent} */
chrome.fileSystemProvider.onTruncateRequested;
 /** @type {!chrome.fileSystemProvider.OpenedFileIoRequestedEvent} */
chrome.fileSystemProvider.onWriteFileRequested;
 /** @type {!chrome.fileSystemProvider.OperationRequestedEvent} */
chrome.fileSystemProvider.onAbortRequested;
 /** @type {!chrome.fileSystemProvider.RequestedEvent} */
chrome.fileSystemProvider.onConfigureRequested;
 /** @type {!chrome.fileSystemProvider.OptionlessRequestedEvent} */
chrome.fileSystemProvider.onMountRequested;
 /** @type {!chrome.fileSystemProvider.EntryPathRecursiveRequestedEvent} */
chrome.fileSystemProvider.onAddWatcherRequested;
 /** @type {!chrome.fileSystemProvider.EntryPathRecursiveRequestedEvent} */
chrome.fileSystemProvider.onRemoveWatcherRequested;
/** @const */
chrome.fontSettings = {};
/**
 * @record
 * @struct
 */
chrome.fontSettings.FontName = function() {};
 /** @type {string} */
chrome.fontSettings.FontName.prototype.displayName;
 /** @type {string} */
chrome.fontSettings.FontName.prototype.fontId;
/**
 * @record
 * @struct
 */
chrome.fontSettings.DefaultFontSizeDetails = function() {};
 /** @type {number} */
chrome.fontSettings.DefaultFontSizeDetails.prototype.pixelSize;
/**
 * @record
 * @struct
 */
chrome.fontSettings.FontDetails = function() {};
 /** @type {string} */
chrome.fontSettings.FontDetails.prototype.genericFamily;
 /** @type {string} */
chrome.fontSettings.FontDetails.prototype.script;
/**
 * @record
 * @struct
 */
chrome.fontSettings.FullFontDetails = function() {};
 /** @type {string} */
chrome.fontSettings.FullFontDetails.prototype.genericFamily;
 /** @type {string} */
chrome.fontSettings.FullFontDetails.prototype.levelOfControl;
 /** @type {string} */
chrome.fontSettings.FullFontDetails.prototype.script;
 /** @type {string} */
chrome.fontSettings.FullFontDetails.prototype.fontId;
/**
 * @record
 * @struct
 */
chrome.fontSettings.FontDetailsResult = function() {};
 /** @type {string} */
chrome.fontSettings.FontDetailsResult.prototype.levelOfControl;
 /** @type {string} */
chrome.fontSettings.FontDetailsResult.prototype.fontId;
/**
 * @record
 * @struct
 */
chrome.fontSettings.FontSizeDetails = function() {};
 /** @type {number} */
chrome.fontSettings.FontSizeDetails.prototype.pixelSize;
 /** @type {string} */
chrome.fontSettings.FontSizeDetails.prototype.levelOfControl;
/**
 * @record
 * @struct
 */
chrome.fontSettings.SetFontSizeDetails = function() {};
 /** @type {number} */
chrome.fontSettings.SetFontSizeDetails.prototype.pixelSize;
/**
 * @extends {chrome.fontSettings.FontDetails}
 * @record
 * @struct
 */
chrome.fontSettings.SetFontDetails = function() {};
 /** @type {string} */
chrome.fontSettings.SetFontDetails.prototype.fontId;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fontSettings.DefaultFixedFontSizeChangedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fontSettings.DefaultFontSizeChangedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fontSettings.MinimumFontSizeChangedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.fontSettings.FontChangedEvent = function() {};

/**
 * Sets the default font size.
 * @param {!chrome.fontSettings.DefaultFontSizeDetails} details
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fontSettings.setDefaultFontSize = function(details, callback) {};

/**
 * Gets the font for a given script and generic font family.
 * @param {!chrome.fontSettings.FontDetails} details
 * @param {function(!chrome.fontSettings.FontDetailsResult): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(object details) {...};
 * @return {void}
 */
chrome.fontSettings.getFont = function(details, callback) {};

/**
 * Gets the default font size.
 * @param {!Object=} details This parameter is currently unused.
 * @param {function(!chrome.fontSettings.FontSizeDetails): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(object details) {...};
 * @return {void}
 */
chrome.fontSettings.getDefaultFontSize = function(details, callback) {};

/**
 * Gets the minimum font size.
 * @param {!chrome.fontSettings.FontSizeDetails=} details This parameter is currently unused.
 * @param {function(!chrome.fontSettings.FontSizeDetails): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(object details) {...};
 * @return {void}
 */
chrome.fontSettings.getMinimumFontSize = function(details, callback) {};

/**
 * Sets the minimum font size.
 * @param {!chrome.fontSettings.SetFontSizeDetails} details
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fontSettings.setMinimumFontSize = function(details, callback) {};

/**
 * Gets the default size for fixed width fonts.
 * @param {!Object=} details This parameter is currently unused.
 * @param {function(!chrome.fontSettings.FontSizeDetails): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(object details) {...};
 * @return {void}
 */
chrome.fontSettings.getDefaultFixedFontSize = function(details, callback) {};

/**
 * Clears the default font size set by this extension, if any.
 * @param {!Object=} details This parameter is currently unused.
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fontSettings.clearDefaultFontSize = function(details, callback) {};

/**
 * Sets the default size for fixed width fonts.
 * @param {!chrome.fontSettings.SetFontSizeDetails} details
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fontSettings.setDefaultFixedFontSize = function(details, callback) {};

/**
 * Clears the font set by this extension, if any.
 * @param {!chrome.fontSettings.FontDetails} details
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fontSettings.clearFont = function(details, callback) {};

/**
 * Sets the font for a given script and generic font family.
 * @param {!chrome.fontSettings.SetFontDetails} details
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(object details) {...};
 * @return {void}
 */
chrome.fontSettings.setFont = function(details, callback) {};

/**
 * Clears the minimum font size set by this extension, if any.
 * @param {!Object=} details This parameter is currently unused.
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fontSettings.clearMinimumFontSize = function(details, callback) {};

/**
 * Gets a list of fonts on the system.
 * @param {function(!Array<!chrome.fontSettings.FontName>): void} callback The callback parameter should be a function that looks like this:
 * function(array of FontName results) {...};
 * @return {void}
 */
chrome.fontSettings.getFontList = function(callback) {};

/**
 * Clears the default fixed font size set by this extension, if any.
 * @param {!Object} details This parameter is currently unused.
 * @param {!Function=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.fontSettings.clearDefaultFixedFontSize = function(details, callback) {};
 /** @type {!chrome.fontSettings.DefaultFixedFontSizeChangedEvent} */
chrome.fontSettings.onDefaultFixedFontSizeChanged;
 /** @type {!chrome.fontSettings.DefaultFontSizeChangedEvent} */
chrome.fontSettings.onDefaultFontSizeChanged;
 /** @type {!chrome.fontSettings.MinimumFontSizeChangedEvent} */
chrome.fontSettings.onMinimumFontSizeChanged;
 /** @type {!chrome.fontSettings.FontChangedEvent} */
chrome.fontSettings.onFontChanged;
/** @const */
chrome.gcm = {};
/**
 * @record
 * @struct
 */
chrome.gcm.OutgoingMessage = function() {};
 /** @type {string} */
chrome.gcm.OutgoingMessage.prototype.destinationId;
 /** @type {string} */
chrome.gcm.OutgoingMessage.prototype.messageId;
 /** @type {number} */
chrome.gcm.OutgoingMessage.prototype.timeToLive;
 /** @type {!Object} */
chrome.gcm.OutgoingMessage.prototype.data;
/**
 * @record
 * @struct
 */
chrome.gcm.IncomingMessage = function() {};
 /** @type {!Object} */
chrome.gcm.IncomingMessage.prototype.data;
 /** @type {string} */
chrome.gcm.IncomingMessage.prototype.from;
 /** @type {string} */
chrome.gcm.IncomingMessage.prototype.collapseKey;
/**
 * @record
 * @struct
 */
chrome.gcm.GcmError = function() {};
 /** @type {string} */
chrome.gcm.GcmError.prototype.errorMessage;
 /** @type {string} */
chrome.gcm.GcmError.prototype.messageId;
 /** @type {!Object} */
chrome.gcm.GcmError.prototype.detail;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.gcm.MessageReceptionEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.gcm.MessageDeletionEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.gcm.GcmErrorEvent = function() {};
 /** @type {number} */
chrome.gcm.MAX_MESSAGE_SIZE;

/**
 * Registers the application with GCM. The registration ID will be returned by the callback. If register is called again with the same list of senderIds, the same registration ID will be returned.
 * @param {!Array<string>} senderIds A list of server IDs that are allowed to send messages to the application. It should contain at least one and no more than 100 sender IDs.
 * @param {function(string): void} callback Function called when registration completes. It should check runtime.lastError for error when registrationId is empty.
 * The callback parameter should be a function that looks like this:
 * function(string registrationId) {...};
 * Parameter registrationId: A registration ID assigned to the application by the GCM.
 * @return {void}
 */
chrome.gcm.register = function(senderIds, callback) {};

/**
 * Unregisters the application from GCM.
 * @param {function(): void} callback A function called after the unregistration completes. Unregistration was successful if runtime.lastError is not set.
 * The callback parameter should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.gcm.unregister = function(callback) {};

/**
 * Sends a message according to its contents.
 * @param {!chrome.gcm.OutgoingMessage} message A message to send to the other party via GCM.
 * @param {function(string): void} callback A function called after the message is successfully queued for sending. runtime.lastError should be checked, to ensure a message was sent without problems.
 * The callback parameter should be a function that looks like this:
 * function(string messageId) {...};
 * Parameter messageId: The ID of the message that the callback was issued for.
 * @return {void}
 */
chrome.gcm.send = function(message, callback) {};
 /** @type {!chrome.gcm.MessageReceptionEvent} */
chrome.gcm.onMessage;
 /** @type {!chrome.gcm.MessageDeletionEvent} */
chrome.gcm.onMessagesDeleted;
 /** @type {!chrome.gcm.GcmErrorEvent} */
chrome.gcm.onSendError;
/** @const */
chrome.history = {};
/**
 * @record
 * @struct
 */
chrome.history.VisitItem = function() {};
 /** @type {string} */
chrome.history.VisitItem.prototype.transition;
 /** @type {number} */
chrome.history.VisitItem.prototype.visitTime;
 /** @type {string} */
chrome.history.VisitItem.prototype.visitId;
 /** @type {string} */
chrome.history.VisitItem.prototype.referringVisitId;
 /** @type {string} */
chrome.history.VisitItem.prototype.id;
/**
 * @record
 * @struct
 */
chrome.history.HistoryItem = function() {};
 /** @type {number} */
chrome.history.HistoryItem.prototype.typedCount;
 /** @type {string} */
chrome.history.HistoryItem.prototype.title;
 /** @type {string} */
chrome.history.HistoryItem.prototype.url;
 /** @type {number} */
chrome.history.HistoryItem.prototype.lastVisitTime;
 /** @type {number} */
chrome.history.HistoryItem.prototype.visitCount;
 /** @type {string} */
chrome.history.HistoryItem.prototype.id;
/**
 * @record
 * @struct
 */
chrome.history.HistoryQuery = function() {};
 /** @type {string} */
chrome.history.HistoryQuery.prototype.text;
 /** @type {number} */
chrome.history.HistoryQuery.prototype.maxResults;
 /** @type {number} */
chrome.history.HistoryQuery.prototype.startTime;
 /** @type {number} */
chrome.history.HistoryQuery.prototype.endTime;
/**
 * @record
 * @struct
 */
chrome.history.Url = function() {};
 /** @type {string} */
chrome.history.Url.prototype.url;
/**
 * @record
 * @struct
 */
chrome.history.Range = function() {};
 /** @type {number} */
chrome.history.Range.prototype.endTime;
 /** @type {number} */
chrome.history.Range.prototype.startTime;
/**
 * @record
 * @struct
 */
chrome.history.RemovedResult = function() {};
 /** @type {boolean} */
chrome.history.RemovedResult.prototype.allHistory;
 /** @type {!Array<string>} */
chrome.history.RemovedResult.prototype.urls;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.history.HistoryVisitedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.history.HistoryVisitRemovedEvent = function() {};

/**
 * Searches the history for the last visit time of each page matching the query.
 * @param {!chrome.history.HistoryQuery} query
 * @param {function(!Array<!chrome.history.HistoryItem>): void} callback The callback parameter should be a function that looks like this:
 * function(array of HistoryItem results) {...};
 * @return {void}
 */
chrome.history.search = function(query, callback) {};

/**
 * Adds a URL to the history at the current time with a transition type of "link".
 * @param {!chrome.history.Url} details
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.history.addUrl = function(details, callback) {};

/**
 * Removes all items within the specified date range from the history. Pages will not be removed from the history unless all visits fall within the range.
 * @param {!chrome.history.Range} range
 * @param {function(): void} callback The callback parameter should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.history.deleteRange = function(range, callback) {};

/**
 * Deletes all items from the history.
 * @param {function(): void} callback The callback parameter should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.history.deleteAll = function(callback) {};

/**
 * Retrieves information about visits to a URL.
 * @param {!chrome.history.Url} details
 * @param {function(!Array<!chrome.history.VisitItem>): void} callback The callback parameter should be a function that looks like this:
 * function(array of VisitItem results) {...};
 * @return {void}
 */
chrome.history.getVisits = function(details, callback) {};

/**
 * Removes all occurrences of the given URL from the history.
 * @param {!chrome.history.Url} details
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.history.deleteUrl = function(details, callback) {};
 /** @type {!chrome.history.HistoryVisitedEvent} */
chrome.history.onVisited;
 /** @type {!chrome.history.HistoryVisitRemovedEvent} */
chrome.history.onVisitRemoved;
/** @const */
chrome.i18n = {};
/**
 * @record
 * @struct
 */
chrome.i18n.DetectedLanguage = function() {};
 /** @type {string} */
chrome.i18n.DetectedLanguage.prototype.language;
 /** @type {number} */
chrome.i18n.DetectedLanguage.prototype.percentage;
/**
 * @record
 * @struct
 */
chrome.i18n.LanguageDetectionResult = function() {};
 /** @type {boolean} */
chrome.i18n.LanguageDetectionResult.prototype.isReliable;
 /** @type {!Array<!chrome.i18n.DetectedLanguage>} */
chrome.i18n.LanguageDetectionResult.prototype.languages;

/**
 * Gets the accept-languages of the browser. This is different from the locale used by the browser; to get the locale, use i18n.getUILanguage.
 * @param {function(!Array<string>): void} callback The callback parameter should be a function that looks like this:
 * function(array of string languages) {...};
 * Parameter languages: Array of the accept languages of the browser, such as en-US,en,zh-CN
 * @return {void}
 */
chrome.i18n.getAcceptLanguages = function(callback) {};

/**
 * Gets the localized string for the specified message. If the message is missing, this method returns an empty string (''). If the format of the getMessage() call is wrong  for example, messageName is not a string or the substitutions array has more than 9 elements  this method returns undefined.
 * @param {string} messageName The name of the message, as specified in the messages.json file.
 * @param {?=} substitutions Optional. Up to 9 substitution strings, if the message requires any.
 * @return {string}
 */
chrome.i18n.getMessage = function(messageName, substitutions) {};

/**
 * Gets the browser UI language of the browser. This is different from i18n.getAcceptLanguages which returns the preferred user languages.
 * \@since Chrome 35.
 * @return {string}
 */
chrome.i18n.getUILanguage = function() {};

/**
 * Detects the language of the provided text using CLD.
 * @param {string} text User input string to be translated.
 * @param {function(!chrome.i18n.LanguageDetectionResult): void} callback The callback parameter should be a function that looks like this: function(object result) {...};
 * @return {void}
 */
chrome.i18n.detectLanguage = function(text, callback) {};
/** @const */
chrome.identity = {};
/**
 * @record
 * @struct
 */
chrome.identity.AccountInfo = function() {};
 /** @type {string} */
chrome.identity.AccountInfo.prototype.id;
/**
 * @record
 * @struct
 */
chrome.identity.TokenDetails = function() {};
 /** @type {boolean} */
chrome.identity.TokenDetails.prototype.interactive;
 /** @type {!chrome.identity.AccountInfo} */
chrome.identity.TokenDetails.prototype.account;
 /** @type {!Array<string>} */
chrome.identity.TokenDetails.prototype.scopes;
/**
 * @record
 * @struct
 */
chrome.identity.UserInfo = function() {};
 /** @type {string} */
chrome.identity.UserInfo.prototype.email;
 /** @type {string} */
chrome.identity.UserInfo.prototype.id;
/**
 * @record
 * @struct
 */
chrome.identity.TokenInformation = function() {};
 /** @type {string} */
chrome.identity.TokenInformation.prototype.token;
/**
 * @record
 * @struct
 */
chrome.identity.WebAuthFlowOptions = function() {};
 /** @type {string} */
chrome.identity.WebAuthFlowOptions.prototype.url;
 /** @type {boolean} */
chrome.identity.WebAuthFlowOptions.prototype.interactive;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.identity.SignInChangeEvent = function() {};

/**
 * Retrieves a list of AccountInfo objects describing the accounts present on the profile.
 * getAccounts is only supported on dev channel.
 * Dev channel only.
 * @param {function(!Array<!chrome.identity.AccountInfo>): void} callback
 * @return {void}
 */
chrome.identity.getAccounts = function(callback) {};

/**
 * Gets an OAuth2 access token using the client ID and scopes specified in the oauth2 section of manifest.json.
 * The Identity API caches access tokens in memory, so it's ok to call getAuthToken non-interactively any time a token is required. The token cache automatically handles expiration.
 * For a good user experience it is important interactive token requests are initiated by UI in your app explaining what the authorization is for. Failing to do this will cause your users to get authorization requests, or Chrome sign in screens if they are not signed in, with with no context. In particular, do not use getAuthToken interactively when your app is first launched.
 * @param {!chrome.identity.TokenDetails} details Token options.
 * @param {function(string): void=} callback Called with an OAuth2 access token as specified by the manifest, or undefined if there was an error.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(string token) {...};
 * @return {void}
 */
chrome.identity.getAuthToken = function(details, callback) {};

/**
 * Retrieves email address and obfuscated gaia id of the user signed into a profile.
 * This API is different from identity.getAccounts in two ways. The information returned is available offline, and it only applies to the primary account for the profile.
 * \@since Chrome 37.
 * @param {function(!chrome.identity.UserInfo): void} callback
 * @return {void}
 */
chrome.identity.getProfileUserInfo = function(callback) {};

/**
 * Removes an OAuth2 access token from the Identity API's token cache.
 * If an access token is discovered to be invalid, it should be passed to removeCachedAuthToken to remove it from the cache. The app may then retrieve a fresh token with getAuthToken.
 * @param {!chrome.identity.TokenInformation} details Token information.
 * @param {function(): void=} callback Called when the token has been removed from the cache.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.identity.removeCachedAuthToken = function(details, callback) {};

/**
 * Starts an auth flow at the specified URL.
 * This method enables auth flows with non-Google identity providers by launching a web view and navigating it to the first URL in the provider's auth flow. When the provider redirects to a URL matching the pattern https://<app-id>.chromiumapp.org/*, the window will close, and the final redirect URL will be passed to the callback function.
 * For a good user experience it is important interactive auth flows are initiated by UI in your app explaining what the authorization is for. Failing to do this will cause your users to get authorization requests with no context. In particular, do not launch an interactive auth flow when your app is first launched.
 * @param {!chrome.identity.WebAuthFlowOptions} details WebAuth flow options.
 * @param {function(string): void} callback Called with the URL redirected back to your application.
 * The callback parameter should be a function that looks like this:
 * function(string responseUrl) {...};
 * @return {void}
 */
chrome.identity.launchWebAuthFlow = function(details, callback) {};

/**
 * Generates a redirect URL to be used in launchWebAuthFlow.
 * The generated URLs match the pattern https://<app-id>.chromiumapp.org/*.
 * \@since Chrome 33.
 * @param {string=} path Optional. The path appended to the end of the generated URL.
 * @return {string}
 */
chrome.identity.getRedirectURL = function(path) {};
 /** @type {!chrome.identity.SignInChangeEvent} */
chrome.identity.onSignInChanged;
/** @const */
chrome.idle = {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.idle.IdleStateChangedEvent = function() {};

/**
 * Returns "locked" if the system is locked, "idle" if the user has not generated any input for a specified number of seconds, or "active" otherwise.
 * @param {number} detectionIntervalInSeconds The system is considered idle if detectionIntervalInSeconds seconds have elapsed since the last user input detected.
 * Since Chrome 25.
 * @param {function(string): void} callback The callback parameter should be a function that looks like this:
 * function( IdleState newState) {...};
 * @return {void}
 */
chrome.idle.queryState = function(detectionIntervalInSeconds, callback) {};

/**
 * Sets the interval, in seconds, used to determine when the system is in an idle state for onStateChanged events. The default interval is 60 seconds.
 * \@since Chrome 25.
 * @param {number} intervalInSeconds Threshold, in seconds, used to determine when the system is in an idle state.
 * @return {void}
 */
chrome.idle.setDetectionInterval = function(intervalInSeconds) {};
 /** @type {!chrome.idle.IdleStateChangedEvent} */
chrome.idle.onStateChanged;
/** @const */
chrome.input = {};
/** @const */
chrome.input.ime = {};
/**
 * @record
 * @struct
 */
chrome.input.ime.KeyboardEvent = function() {};
 /** @type {boolean} */
chrome.input.ime.KeyboardEvent.prototype.shiftKey;
 /** @type {boolean} */
chrome.input.ime.KeyboardEvent.prototype.altKey;
 /** @type {string} */
chrome.input.ime.KeyboardEvent.prototype.requestId;
 /** @type {string} */
chrome.input.ime.KeyboardEvent.prototype.key;
 /** @type {boolean} */
chrome.input.ime.KeyboardEvent.prototype.ctrlKey;
 /** @type {string} */
chrome.input.ime.KeyboardEvent.prototype.type;
 /** @type {string} */
chrome.input.ime.KeyboardEvent.prototype.extensionId;
 /** @type {string} */
chrome.input.ime.KeyboardEvent.prototype.code;
 /** @type {number} */
chrome.input.ime.KeyboardEvent.prototype.keyCode;
 /** @type {boolean} */
chrome.input.ime.KeyboardEvent.prototype.capsLock;
/**
 * @record
 * @struct
 */
chrome.input.ime.InputContext = function() {};
 /** @type {number} */
chrome.input.ime.InputContext.prototype.contextID;
 /** @type {string} */
chrome.input.ime.InputContext.prototype.type;
 /** @type {boolean} */
chrome.input.ime.InputContext.prototype.autoCorrect;
 /** @type {boolean} */
chrome.input.ime.InputContext.prototype.autoComplete;
 /** @type {boolean} */
chrome.input.ime.InputContext.prototype.spellCheck;
/**
 * @record
 * @struct
 */
chrome.input.ime.MenuItem = function() {};
 /** @type {string} */
chrome.input.ime.MenuItem.prototype.id;
 /** @type {string} */
chrome.input.ime.MenuItem.prototype.label;
 /** @type {string} */
chrome.input.ime.MenuItem.prototype.style;
 /** @type {boolean} */
chrome.input.ime.MenuItem.prototype.visible;
 /** @type {boolean} */
chrome.input.ime.MenuItem.prototype.checked;
 /** @type {boolean} */
chrome.input.ime.MenuItem.prototype.enabled;
/**
 * @record
 * @struct
 */
chrome.input.ime.ImeParameters = function() {};
 /** @type {!Array<!chrome.input.ime.MenuItem>} */
chrome.input.ime.ImeParameters.prototype.items;
 /** @type {string} */
chrome.input.ime.ImeParameters.prototype.engineID;
/**
 * @record
 * @struct
 */
chrome.input.ime.CommitTextParameters = function() {};
 /** @type {string} */
chrome.input.ime.CommitTextParameters.prototype.text;
 /** @type {number} */
chrome.input.ime.CommitTextParameters.prototype.contextID;
/**
 * @record
 * @struct
 */
chrome.input.ime.CandidateUsage = function() {};
 /** @type {string} */
chrome.input.ime.CandidateUsage.prototype.title;
 /** @type {string} */
chrome.input.ime.CandidateUsage.prototype.body;
/**
 * @record
 * @struct
 */
chrome.input.ime.CandidateTemplate = function() {};
 /** @type {string} */
chrome.input.ime.CandidateTemplate.prototype.candidate;
 /** @type {number} */
chrome.input.ime.CandidateTemplate.prototype.id;
 /** @type {number} */
chrome.input.ime.CandidateTemplate.prototype.parentId;
 /** @type {string} */
chrome.input.ime.CandidateTemplate.prototype.label;
 /** @type {string} */
chrome.input.ime.CandidateTemplate.prototype.annotation;
 /** @type {!chrome.input.ime.CandidateUsage} */
chrome.input.ime.CandidateTemplate.prototype.usage;
/**
 * @record
 * @struct
 */
chrome.input.ime.CandidatesParameters = function() {};
 /** @type {number} */
chrome.input.ime.CandidatesParameters.prototype.contextID;
 /** @type {!Array<!chrome.input.ime.CandidateTemplate>} */
chrome.input.ime.CandidatesParameters.prototype.candidates;
/**
 * @record
 * @struct
 */
chrome.input.ime.CompositionParameterSegment = function() {};
 /** @type {number} */
chrome.input.ime.CompositionParameterSegment.prototype.start;
 /** @type {number} */
chrome.input.ime.CompositionParameterSegment.prototype.end;
 /** @type {string} */
chrome.input.ime.CompositionParameterSegment.prototype.style;
/**
 * @record
 * @struct
 */
chrome.input.ime.CompositionParameters = function() {};
 /** @type {number} */
chrome.input.ime.CompositionParameters.prototype.contextID;
 /** @type {string} */
chrome.input.ime.CompositionParameters.prototype.text;
 /** @type {!Array<!chrome.input.ime.CompositionParameterSegment>} */
chrome.input.ime.CompositionParameters.prototype.segments;
 /** @type {number} */
chrome.input.ime.CompositionParameters.prototype.cursor;
 /** @type {number} */
chrome.input.ime.CompositionParameters.prototype.selectionStart;
 /** @type {number} */
chrome.input.ime.CompositionParameters.prototype.selectionEnd;
/**
 * @record
 * @struct
 */
chrome.input.ime.MenuItemParameters = function() {};
 /** @type {!Array<!Object>} */
chrome.input.ime.MenuItemParameters.prototype.items;
 /** @type {string} */
chrome.input.ime.MenuItemParameters.prototype.engineId;
/**
 * @record
 * @struct
 */
chrome.input.ime.CandidateWindowParameterProperties = function() {};
 /** @type {boolean} */
chrome.input.ime.CandidateWindowParameterProperties.prototype.cursorVisible;
 /** @type {boolean} */
chrome.input.ime.CandidateWindowParameterProperties.prototype.vertical;
 /** @type {number} */
chrome.input.ime.CandidateWindowParameterProperties.prototype.pageSize;
 /** @type {boolean} */
chrome.input.ime.CandidateWindowParameterProperties.prototype.auxiliaryTextVisible;
 /** @type {string} */
chrome.input.ime.CandidateWindowParameterProperties.prototype.auxiliaryText;
 /** @type {boolean} */
chrome.input.ime.CandidateWindowParameterProperties.prototype.visible;
 /** @type {string} */
chrome.input.ime.CandidateWindowParameterProperties.prototype.windowPosition;
/**
 * @record
 * @struct
 */
chrome.input.ime.CandidateWindowParameter = function() {};
 /** @type {string} */
chrome.input.ime.CandidateWindowParameter.prototype.engineID;
 /** @type {!chrome.input.ime.CandidateWindowParameterProperties} */
chrome.input.ime.CandidateWindowParameter.prototype.properties;
/**
 * @record
 * @struct
 */
chrome.input.ime.ClearCompositionParameters = function() {};
 /** @type {number} */
chrome.input.ime.ClearCompositionParameters.prototype.contextID;
/**
 * @record
 * @struct
 */
chrome.input.ime.CursorPositionParameters = function() {};
 /** @type {number} */
chrome.input.ime.CursorPositionParameters.prototype.candidateID;
 /** @type {number} */
chrome.input.ime.CursorPositionParameters.prototype.contextID;
/**
 * @record
 * @struct
 */
chrome.input.ime.SendKeyEventParameters = function() {};
 /** @type {number} */
chrome.input.ime.SendKeyEventParameters.prototype.contextID;
 /** @type {!Array<!chrome.input.ime.KeyboardEvent>} */
chrome.input.ime.SendKeyEventParameters.prototype.keyData;
/**
 * @record
 * @struct
 */
chrome.input.ime.DeleteSurroundingTextParameters = function() {};
 /** @type {string} */
chrome.input.ime.DeleteSurroundingTextParameters.prototype.engineID;
 /** @type {number} */
chrome.input.ime.DeleteSurroundingTextParameters.prototype.contextID;
 /** @type {number} */
chrome.input.ime.DeleteSurroundingTextParameters.prototype.offset;
 /** @type {number} */
chrome.input.ime.DeleteSurroundingTextParameters.prototype.length;
/**
 * @record
 * @struct
 */
chrome.input.ime.SurroundingTextInfo = function() {};
 /** @type {string} */
chrome.input.ime.SurroundingTextInfo.prototype.text;
 /** @type {number} */
chrome.input.ime.SurroundingTextInfo.prototype.focus;
 /** @type {number} */
chrome.input.ime.SurroundingTextInfo.prototype.anchor;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.BlurEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.CandidateClickedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.KeyEventEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.DeactivatedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.InputContextUpdateEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.ActivateEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.FocusEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.MenuItemActivatedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.SurroundingTextChangedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.input.ime.InputResetEvent = function() {};

/**
 * Adds the provided menu items to the language menu when this IME is active.
 * @param {!chrome.input.ime.ImeParameters} parameters
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.input.ime.setMenuItems = function(parameters, callback) {};

/**
 * Commits the provided text to the current input.
 * @param {!chrome.input.ime.CommitTextParameters} parameters
 * @param {function(boolean): void=} callback Called when the operation completes with a boolean indicating if the text was accepted or not. On failure, chrome.runtime.lastError is set.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean success) {...};
 * @return {void}
 */
chrome.input.ime.commitText = function(parameters, callback) {};

/**
 * Sets the current candidate list. This fails if this extension doesn't own the active IME
 * @param {!chrome.input.ime.CandidatesParameters} parameters
 * @param {function(boolean): void=} callback Called when the operation completes.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean success) {...};
 * @return {void}
 */
chrome.input.ime.setCandidates = function(parameters, callback) {};

/**
 * Set the current composition. If this extension does not own the active IME, this fails.
 * @param {!chrome.input.ime.CompositionParameters} parameters
 * @param {function(boolean): void=} callback Called when the operation completes with a boolean indicating if the text was accepted or not. On failure, chrome.runtime.lastError is set.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean success) {...};
 * @return {void}
 */
chrome.input.ime.setComposition = function(parameters, callback) {};

/**
 * Updates the state of the MenuItems specified
 * @param {!chrome.input.ime.MenuItemParameters} parameters
 * @param {function(): void=} callback Called when the operation completes
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.input.ime.updateMenuItems = function(parameters, callback) {};

/**
 * Sets the properties of the candidate window. This fails if the extension doesn't own the active IME
 * @param {!chrome.input.ime.CandidateWindowParameter} parameters
 * @param {function(boolean): void=} callback Called when the operation completes.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean success) {...};
 * @return {void}
 */
chrome.input.ime.setCandidateWindowProperties = function(parameters, callback) {};

/**
 * Clear the current composition. If this extension does not own the active IME, this fails.
 * @param {!chrome.input.ime.ClearCompositionParameters} parameters
 * @param {function(boolean): void=} callback Called when the operation completes with a boolean indicating if the text was accepted or not. On failure, chrome.runtime.lastError is set.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean success) {...};
 * @return {void}
 */
chrome.input.ime.clearComposition = function(parameters, callback) {};

/**
 * Set the position of the cursor in the candidate window. This is a no-op if this extension does not own the active IME.
 * @param {!chrome.input.ime.CursorPositionParameters} parameters
 * @param {function(boolean): void=} callback Called when the operation completes
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean success) {...};
 * @return {void}
 */
chrome.input.ime.setCursorPosition = function(parameters, callback) {};

/**
 * Sends the key events. This function is expected to be used by virtual keyboards. When key(s) on a virtual keyboard is pressed by a user, this function is used to propagate that event to the system.
 * \@since Chrome 33.
 * @param {!chrome.input.ime.SendKeyEventParameters} parameters
 * @param {function(): void=} callback Called when the operation completes.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.input.ime.sendKeyEvents = function(parameters, callback) {};

/**
 * Hides the input view window, which is popped up automatically by system. If the input view window is already hidden, this function will do nothing.
 * \@since Chrome 34.
 * @return {void}
 */
chrome.input.ime.hideInputView = function() {};

/**
 * Deletes the text around the caret.
 * \@since Chrome 27.
 * @param {!chrome.input.ime.DeleteSurroundingTextParameters} parameters
 * @param {function(): void=} callback
 * @return {void}
 */
chrome.input.ime.deleteSurroundingText = function(parameters, callback) {};

/**
 * Indicates that the key event received by onKeyEvent is handled. This should only be called if the onKeyEvent listener is asynchronous.
 * \@since Chrome 25.
 * @param {string} requestId Request id of the event that was handled. This should come from keyEvent.requestId
 * @param {boolean} response True if the keystroke was handled, false if not
 * @return {void}
 */
chrome.input.ime.keyEventHandled = function(requestId, response) {};
 /** @type {!chrome.input.ime.BlurEvent} */
chrome.input.ime.onBlur;
 /** @type {!chrome.input.ime.CandidateClickedEvent} */
chrome.input.ime.onCandidateClicked;
 /** @type {!chrome.input.ime.KeyEventEvent} */
chrome.input.ime.onKeyEvent;
 /** @type {!chrome.input.ime.DeactivatedEvent} */
chrome.input.ime.onDeactivated;
 /** @type {!chrome.input.ime.InputContextUpdateEvent} */
chrome.input.ime.onInputContextUpdate;
 /** @type {!chrome.input.ime.ActivateEvent} */
chrome.input.ime.onActivate;
 /** @type {!chrome.input.ime.FocusEvent} */
chrome.input.ime.onFocus;
 /** @type {!chrome.input.ime.MenuItemActivatedEvent} */
chrome.input.ime.onMenuItemActivated;
 /** @type {!chrome.input.ime.SurroundingTextChangedEvent} */
chrome.input.ime.onSurroundingTextChanged;
 /** @type {!chrome.input.ime.InputResetEvent} */
chrome.input.ime.onReset;
/** @const */
chrome.management = {};
/**
 * @record
 * @struct
 */
chrome.management.ExtensionInfo = function() {};
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.disabledReason;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.appLaunchUrl;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.description;
 /** @type {!Array<string>} */
chrome.management.ExtensionInfo.prototype.permissions;
 /** @type {!Array<!chrome.management.IconInfo>} */
chrome.management.ExtensionInfo.prototype.icons;
 /** @type {!Array<string>} */
chrome.management.ExtensionInfo.prototype.hostPermissions;
 /** @type {boolean} */
chrome.management.ExtensionInfo.prototype.enabled;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.homepageUrl;
 /** @type {boolean} */
chrome.management.ExtensionInfo.prototype.mayDisable;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.installType;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.version;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.id;
 /** @type {boolean} */
chrome.management.ExtensionInfo.prototype.offlineEnabled;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.updateUrl;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.type;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.optionsUrl;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.name;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.shortName;
 /** @type {boolean} */
chrome.management.ExtensionInfo.prototype.isApp;
 /** @type {string} */
chrome.management.ExtensionInfo.prototype.launchType;
 /** @type {!Array<string>} */
chrome.management.ExtensionInfo.prototype.availableLaunchTypes;
/**
 * @record
 * @struct
 */
chrome.management.IconInfo = function() {};
 /** @type {string} */
chrome.management.IconInfo.prototype.url;
 /** @type {number} */
chrome.management.IconInfo.prototype.size;
/**
 * @record
 * @struct
 */
chrome.management.UninstallOptions = function() {};
 /** @type {boolean} */
chrome.management.UninstallOptions.prototype.showConfirmDialog;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.management.ManagementDisabledEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.management.ManagementUninstalledEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.management.ManagementInstalledEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.management.ManagementEnabledEvent = function() {};

/**
 * Enables or disables an app or extension.
 * @param {string} id This should be the id from an item of management.ExtensionInfo.
 * @param {boolean} enabled Whether this item should be enabled or disabled.
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.management.setEnabled = function(id, enabled, callback) {};

/**
 * Returns a list of permission warnings for the given extension id.
 * \@since Chrome 15.
 * @param {string} id The ID of an already installed extension.
 * @param {function(!Array<string>): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(array of string permissionWarnings) {...};
 * @return {void}
 */
chrome.management.getPermissionWarningsById = function(id, callback) {};

/**
 * Returns information about the installed extension, app, or theme that has the given ID.
 * \@since Chrome 9.
 * @param {string} id The ID from an item of management.ExtensionInfo.
 * @param {function(!chrome.management.ExtensionInfo): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function( ExtensionInfo result) {...};
 * @return {void}
 */
chrome.management.get = function(id, callback) {};

/**
 * Returns a list of information about installed extensions and apps.
 * @param {function(!Array<!chrome.management.ExtensionInfo>): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(array of ExtensionInfo result) {...};
 * @return {void}
 */
chrome.management.getAll = function(callback) {};

/**
 * Returns a list of permission warnings for the given extension manifest string. Note: This function can be used without requesting the 'management' permission in the manifest.
 * \@since Chrome 15.
 * @param {string} manifestStr Extension manifest JSON string.
 * @param {function(!Array<string>): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(array of string permissionWarnings) {...};
 * @return {void}
 */
chrome.management.getPermissionWarningsByManifest = function(manifestStr, callback) {};

/**
 * Launches an application.
 * @param {string} id The extension id of the application.
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.management.launchApp = function(id, callback) {};

/**
 * Uninstalls a currently installed app or extension.
 * \@since Chrome 21.
 * Uninstalls a currently installed app or extension.
 * @deprecated since Chrome 21. The options parameter was added to this function.
 * @param {string} id This should be the id from an item of management.ExtensionInfo.
 * @param {!chrome.management.UninstallOptions|function(): void=} options_or_callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.management.uninstall = function(id, options_or_callback, callback) {};

/**
 * Returns information about the calling extension, app, or theme. Note: This function can be used without requesting the 'management' permission in the manifest.
 * \@since Chrome 39.
 * @param {function(!chrome.management.ExtensionInfo): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function( ExtensionInfo result) {...};
 * @return {void}
 */
chrome.management.getSelf = function(callback) {};

/**
 * Uninstalls the calling extension.
 * Note: This function can be used without requesting the 'management' permission in the manifest.
 * \@since Chrome 26.
 * Uninstalls the calling extension.
 * Note: This function can be used without requesting the 'management' permission in the manifest.
 * \@since Chrome 26.
 * @param {!chrome.management.UninstallOptions|function(): void=} options_or_callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.management.uninstallSelf = function(options_or_callback, callback) {};

/**
 * Display options to create shortcuts for an app. On Mac, only packaged app shortcuts can be created.
 * \@since Chrome 37.
 * @param {string} id
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.management.createAppShortcut = function(id, callback) {};

/**
 * Set the launch type of an app.
 * \@since Chrome 37.
 * @param {string} id This should be the id from an app item of management.ExtensionInfo.
 * @param {string} launchType The target launch type. Always check and make sure this launch type is in ExtensionInfo.availableLaunchTypes, because the available launch types vary on different platforms and configurations.
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.management.setLaunchType = function(id, launchType, callback) {};

/**
 * Generate an app for a URL. Returns the generated bookmark app.
 * \@since Chrome 37.
 * @param {string} url The URL of a web page. The scheme of the URL can only be "http" or "https".
 * @param {string} title The title of the generated app.
 * @param {function(!chrome.management.ExtensionInfo): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function( ExtensionInfo result) {...};
 * @return {void}
 */
chrome.management.generateAppForLink = function(url, title, callback) {};
 /** @type {!chrome.management.ManagementDisabledEvent} */
chrome.management.onDisabled;
 /** @type {!chrome.management.ManagementUninstalledEvent} */
chrome.management.onUninstalled;
 /** @type {!chrome.management.ManagementInstalledEvent} */
chrome.management.onInstalled;
 /** @type {!chrome.management.ManagementEnabledEvent} */
chrome.management.onEnabled;
/** @const */
chrome.networking = {};
/** @const */
chrome.networking.config = {};
/**
 * @record
 * @struct
 */
chrome.networking.config.NetworkInfo = function() {};
 /** @type {string} */
chrome.networking.config.NetworkInfo.prototype.Type;
 /** @type {string} */
chrome.networking.config.NetworkInfo.prototype.GUID;
 /** @type {string} */
chrome.networking.config.NetworkInfo.prototype.HexSSID;
 /** @type {string} */
chrome.networking.config.NetworkInfo.prototype.SSID;
 /** @type {string} */
chrome.networking.config.NetworkInfo.prototype.BSSID;
 /** @type {string} */
chrome.networking.config.NetworkInfo.prototype.Security;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.networking.config.CaptivePorttalDetectedEvent = function() {};

/**
 * Allows an extension to define network filters for the networks it can handle. A call to this function will remove all filters previously installed by the extension before setting the new list.
 * @param {!Array<!chrome.networking.config.NetworkInfo>} networks Network filters to set. Every NetworkInfo must either have the SSID or HexSSID set. Other fields will be ignored.
 * @param {function(): void} callback Called back when this operation is finished.
 * The callback parameter should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.networking.config.setNetworkFilter = function(networks, callback) {};

/**
 * Called by the extension to notify the network config API that it finished a captive portal authentication attempt and hand over the result of the attempt. This function must only be called with the GUID of the latest onCaptivePortalDetected event.
 * @param {string} GUID Unique network identifier obtained from onCaptivePortalDetected.
 * @param {string} result The result of the authentication attempt.
 * unhandled: The extension does not handle this network or captive portal (e.g. server end-point not found or not compatible).
 * succeeded: The extension handled this network and authenticated successfully.
 * rejected: The extension handled this network, tried to authenticate, however was rejected by the server.
 * failed: The extension handled this network, tried to authenticate, however failed due to an unspecified error.
 * @param {function(): void=} callback Called back when this operation is finished.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.networking.config.finishAuthentication = function(GUID, result, callback) {};
 /** @type {!chrome.networking.config.CaptivePorttalDetectedEvent} */
chrome.networking.config.onCaptivePortalDetected;
/** @const */
chrome.notifications = {};
/**
 * @record
 * @struct
 */
chrome.notifications.ButtonOptions = function() {};
 /** @type {string} */
chrome.notifications.ButtonOptions.prototype.title;
 /** @type {string} */
chrome.notifications.ButtonOptions.prototype.iconUrl;
/**
 * @record
 * @struct
 */
chrome.notifications.ItemOptions = function() {};
 /** @type {string} */
chrome.notifications.ItemOptions.prototype.title;
 /** @type {string} */
chrome.notifications.ItemOptions.prototype.message;
/**
 * @record
 * @struct
 */
chrome.notifications.NotificationOptions = function() {};
 /** @type {string} */
chrome.notifications.NotificationOptions.prototype.type;
 /** @type {string} */
chrome.notifications.NotificationOptions.prototype.iconUrl;
 /** @type {string} */
chrome.notifications.NotificationOptions.prototype.title;
 /** @type {string} */
chrome.notifications.NotificationOptions.prototype.message;
 /** @type {string} */
chrome.notifications.NotificationOptions.prototype.contextMessage;
 /** @type {number} */
chrome.notifications.NotificationOptions.prototype.priority;
 /** @type {number} */
chrome.notifications.NotificationOptions.prototype.eventTime;
 /** @type {!Array<!chrome.notifications.ButtonOptions>} */
chrome.notifications.NotificationOptions.prototype.buttons;
 /** @type {!Array<!chrome.notifications.ItemOptions>} */
chrome.notifications.NotificationOptions.prototype.items;
 /** @type {number} */
chrome.notifications.NotificationOptions.prototype.progress;
 /** @type {boolean} */
chrome.notifications.NotificationOptions.prototype.isClickable;
 /** @type {string} */
chrome.notifications.NotificationOptions.prototype.appIconMaskUrl;
 /** @type {string} */
chrome.notifications.NotificationOptions.prototype.imageUrl;
 /** @type {boolean} */
chrome.notifications.NotificationOptions.prototype.requireInteraction;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.notifications.NotificationClosedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.notifications.NotificationClickedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.notifications.NotificationButtonClickedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.notifications.NotificationPermissionLevelChangedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.notifications.NotificationShowSettingsEvent = function() {};
 /** @type {!chrome.notifications.NotificationClosedEvent} */
chrome.notifications.onClosed;
 /** @type {!chrome.notifications.NotificationClickedEvent} */
chrome.notifications.onClicked;
 /** @type {!chrome.notifications.NotificationButtonClickedEvent} */
chrome.notifications.onButtonClicked;
 /** @type {!chrome.notifications.NotificationPermissionLevelChangedEvent} */
chrome.notifications.onPermissionLevelChanged;
 /** @type {!chrome.notifications.NotificationShowSettingsEvent} */
chrome.notifications.onShowSettings;

/**
 * Creates and displays a notification.
 * Creates and displays a notification.
 * @param {string|!chrome.notifications.NotificationOptions} notificationId_or_options Identifier of the notification. If not set or empty, an ID will automatically be generated. If it matches an existing notification, this method first clears that notification before proceeding with the create operation.
 * The notificationId parameter is required before Chrome 42. / Contents of the notification.
 * @param {!chrome.notifications.NotificationOptions|function(string): void=} options_or_callback Contents of the notification. / Returns the notification id (either supplied or generated) that represents the created notification.
 * The callback is required before Chrome 42.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(string notificationId) {...};
 * @param {function(string): void=} callback Returns the notification id (either supplied or generated) that represents the created notification.
 * The callback is required before Chrome 42.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(string notificationId) {...};
 * @return {void}
 */
chrome.notifications.create = function(notificationId_or_options, options_or_callback, callback) {};

/**
 * Updates an existing notification.
 * @param {string} notificationId The id of the notification to be updated. This is returned by notifications.create method.
 * @param {!chrome.notifications.NotificationOptions} options Contents of the notification to update to.
 * @param {function(boolean): void=} callback Called to indicate whether a matching notification existed.
 * The callback is required before Chrome 42.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean wasUpdated) {...};
 * @return {void}
 */
chrome.notifications.update = function(notificationId, options, callback) {};

/**
 * Clears the specified notification.
 * @param {string} notificationId The id of the notification to be cleared. This is returned by notifications.create method.
 * @param {function(boolean): void=} callback Called to indicate whether a matching notification existed.
 * The callback is required before Chrome 42.
 * If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean wasCleared) {...};
 * @return {void}
 */
chrome.notifications.clear = function(notificationId, callback) {};

/**
 * Retrieves all the notifications.
 * \@since Chrome 29.
 * @param {function(!Object): void} callback Returns the set of notification_ids currently in the system.
 * The callback parameter should be a function that looks like this:
 * function(object notifications) {...};
 * @return {void}
 */
chrome.notifications.getAll = function(callback) {};

/**
 * Retrieves whether the user has enabled notifications from this app or extension.
 * \@since Chrome 32.
 * @param {function(string): void} callback Returns the current permission level.
 * The callback parameter should be a function that looks like this:
 * function( PermissionLevel level) {...};
 * @return {void}
 */
chrome.notifications.getPermissionLevel = function(callback) {};
/** @const */
chrome.omnibox = {};
/**
 * @record
 * @struct
 */
chrome.omnibox.SuggestResult = function() {};
 /** @type {string} */
chrome.omnibox.SuggestResult.prototype.content;
 /** @type {string} */
chrome.omnibox.SuggestResult.prototype.description;
/**
 * @record
 * @struct
 */
chrome.omnibox.Suggestion = function() {};
 /** @type {string} */
chrome.omnibox.Suggestion.prototype.description;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.omnibox.OmniboxInputEnteredEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.omnibox.OmniboxInputChangedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.omnibox.OmniboxInputStartedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.omnibox.OmniboxInputCancelledEvent = function() {};

/**
 * Sets the description and styling for the default suggestion. The default suggestion is the text that is displayed in the first suggestion row underneath the URL bar.
 * @param {!chrome.omnibox.Suggestion} suggestion A partial SuggestResult object, without the 'content' parameter.
 * @return {void}
 */
chrome.omnibox.setDefaultSuggestion = function(suggestion) {};
 /** @type {!chrome.omnibox.OmniboxInputEnteredEvent} */
chrome.omnibox.onInputEntered;
 /** @type {!chrome.omnibox.OmniboxInputChangedEvent} */
chrome.omnibox.onInputChanged;
 /** @type {!chrome.omnibox.OmniboxInputStartedEvent} */
chrome.omnibox.onInputStarted;
 /** @type {!chrome.omnibox.OmniboxInputCancelledEvent} */
chrome.omnibox.onInputCancelled;
/** @const */
chrome.pageAction = {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.pageAction.PageActionClickedEvent = function() {};
/**
 * @record
 * @struct
 */
chrome.pageAction.TitleDetails = function() {};
 /** @type {number} */
chrome.pageAction.TitleDetails.prototype.tabId;
 /** @type {string} */
chrome.pageAction.TitleDetails.prototype.title;
/**
 * @record
 * @struct
 */
chrome.pageAction.GetDetails = function() {};
 /** @type {number} */
chrome.pageAction.GetDetails.prototype.tabId;
/**
 * @record
 * @struct
 */
chrome.pageAction.PopupDetails = function() {};
 /** @type {number} */
chrome.pageAction.PopupDetails.prototype.tabId;
 /** @type {string} */
chrome.pageAction.PopupDetails.prototype.popup;
/**
 * @record
 * @struct
 */
chrome.pageAction.IconDetails = function() {};
 /** @type {number} */
chrome.pageAction.IconDetails.prototype.tabId;
 /** @type {number} */
chrome.pageAction.IconDetails.prototype.iconIndex;
 /** @type {!ImageData} */
chrome.pageAction.IconDetails.prototype.imageData;
 /** @type {?} */
chrome.pageAction.IconDetails.prototype.path;

/**
 * Shows the page action. The page action is shown whenever the tab is selected.
 * @param {number} tabId The id of the tab for which you want to modify the page action.
 * @return {void}
 */
chrome.pageAction.hide = function(tabId) {};

/**
 * Shows the page action. The page action is shown whenever the tab is selected.
 * @param {number} tabId The id of the tab for which you want to modify the page action.
 * @return {void}
 */
chrome.pageAction.show = function(tabId) {};

/**
 * Sets the title of the page action. This is displayed in a tooltip over the page action.
 * @param {!chrome.pageAction.TitleDetails} details
 * @return {void}
 */
chrome.pageAction.setTitle = function(details) {};

/**
 * Sets the html document to be opened as a popup when the user clicks on the page action's icon.
 * @param {!chrome.pageAction.PopupDetails} details
 * @return {void}
 */
chrome.pageAction.setPopup = function(details) {};

/**
 * Gets the title of the page action.
 * \@since Chrome 19.
 * @param {!chrome.pageAction.GetDetails} details
 * @param {function(string): void} callback The callback parameter should be a function that looks like this:
 * function(string result) {...};
 * @return {void}
 */
chrome.pageAction.getTitle = function(details, callback) {};

/**
 * Gets the html document set as the popup for this page action.
 * \@since Chrome 19.
 * @param {!chrome.pageAction.GetDetails} details
 * @param {function(string): void} callback The callback parameter should be a function that looks like this:
 * function(string result) {...};
 * @return {void}
 */
chrome.pageAction.getPopup = function(details, callback) {};

/**
 * Sets the icon for the page action. The icon can be specified either as the path to an image file or as the pixel data from a canvas element, or as dictionary of either one of those. Either the path or the imageData property must be specified.
 * @param {!chrome.pageAction.IconDetails} details
 * @param {function(): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function() {...};
 * @return {void}
 */
chrome.pageAction.setIcon = function(details, callback) {};
 /** @type {!chrome.pageAction.PageActionClickedEvent} */
chrome.pageAction.onClicked;
/** @const */
chrome.pageCapture = {};
/**
 * @record
 * @struct
 */
chrome.pageCapture.SaveDetails = function() {};
 /** @type {number} */
chrome.pageCapture.SaveDetails.prototype.tabId;

/**
 * Saves the content of the tab with given id as MHTML.
 * @param {!chrome.pageCapture.SaveDetails} details
 * @param {function(?): void} callback Called when the MHTML has been generated.
 * The callback parameter should be a function that looks like this:
 * function(binary mhtmlData) {...};
 * Parameter mhtmlData: The MHTML data as a Blob.
 * @return {void}
 */
chrome.pageCapture.saveAsMHTML = function(details, callback) {};
/** @const */
chrome.permissions = {};
/**
 * @record
 * @struct
 */
chrome.permissions.Permissions = function() {};
 /** @type {!Array<string>} */
chrome.permissions.Permissions.prototype.origins;
 /** @type {!Array<string>} */
chrome.permissions.Permissions.prototype.permissions;
/**
 * @record
 * @struct
 */
chrome.permissions.PermissionsRemovedEvent = function() {};

/**
 * @param {function(!chrome.permissions.Permissions): void} callback The callback parameter should be a function that looks like this:
 * function( Permissions permissions) {...};
 * Parameter permissions: The permissions that have been removed.
 * @return {void}
 */
chrome.permissions.PermissionsRemovedEvent.prototype.addListener = function(callback) {};
/**
 * @record
 * @struct
 */
chrome.permissions.PermissionsAddedEvent = function() {};

/**
 * @param {function(!chrome.permissions.Permissions): void} callback The callback parameter should be a function that looks like this:
 * function( Permissions permissions) {...};
 * Parameter permissions: The newly acquired permissions.
 * @return {void}
 */
chrome.permissions.PermissionsAddedEvent.prototype.addListener = function(callback) {};

/**
 * Checks if the extension has the specified permissions.
 * @param {!chrome.permissions.Permissions} permissions
 * @param {function(boolean): void} callback The callback parameter should be a function that looks like this:
 * function(boolean result) {...};
 * Parameter result: True if the extension has the specified permissions.
 * @return {void}
 */
chrome.permissions.contains = function(permissions, callback) {};

/**
 * Gets the extension's current set of permissions.
 * @param {function(!chrome.permissions.Permissions): void} callback The callback parameter should be a function that looks like this:
 * function( Permissions permissions) {...};
 * Parameter permissions: The extension's active permissions.
 * @return {void}
 */
chrome.permissions.getAll = function(callback) {};

/**
 * Requests access to the specified permissions. These permissions must be defined in the optional_permissions field of the manifest. If there are any problems requesting the permissions, runtime.lastError will be set.
 * @param {!chrome.permissions.Permissions} permissions
 * @param {function(boolean): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean granted) {...};
 * Parameter granted: True if the user granted the specified permissions.
 * @return {void}
 */
chrome.permissions.request = function(permissions, callback) {};

/**
 * Removes access to the specified permissions. If there are any problems removing the permissions, runtime.lastError will be set.
 * @param {!chrome.permissions.Permissions} permissions
 * @param {function(boolean): void=} callback If you specify the callback parameter, it should be a function that looks like this:
 * function(boolean removed) {...};
 * Parameter removed: True if the permissions were removed.
 * @return {void}
 */
chrome.permissions.remove = function(permissions, callback) {};
 /** @type {!chrome.permissions.PermissionsRemovedEvent} */
chrome.permissions.onRemoved;
 /** @type {!chrome.permissions.PermissionsAddedEvent} */
chrome.permissions.onAdded;
/** @const */
chrome.platformKeys = {};
/**
 * @record
 * @struct
 */
chrome.platformKeys.Match = function() {};
 /** @type {!ArrayBuffer} */
chrome.platformKeys.Match.prototype.certificate;
 /** @type {!KeyAlgorithm} */
chrome.platformKeys.Match.prototype.keyAlgorithm;
/**
 * @record
 * @struct
 */
chrome.platformKeys.ClientCertificateSelectRequestDetails = function() {};
 /** @type {!Array<string>} */
chrome.platformKeys.ClientCertificateSelectRequestDetails.prototype.certificateTypes;
 /** @type {!Array<!ArrayBuffer>} */
chrome.platformKeys.ClientCertificateSelectRequestDetails.prototype.certificateAuthorities;
/**
 * @record
 * @struct
 */
chrome.platformKeys.ClientCertificateSelectDetails = function() {};
 /** @type {!chrome.platformKeys.ClientCertificateSelectRequestDetails} */
chrome.platformKeys.ClientCertificateSelectDetails.prototype.request;
 /** @type {!Array<!ArrayBuffer>} */
chrome.platformKeys.ClientCertificateSelectDetails.prototype.clientCerts;
 /** @type {boolean} */
chrome.platformKeys.ClientCertificateSelectDetails.prototype.interactive;
/**
 * @record
 * @struct
 */
chrome.platformKeys.ServerCertificateVerificationDetails = function() {};
 /** @type {!Array<!ArrayBuffer>} */
chrome.platformKeys.ServerCertificateVerificationDetails.prototype.serverCertificateChain;
 /** @type {string} */
chrome.platformKeys.ServerCertificateVerificationDetails.prototype.hostname;
/**
 * @record
 * @struct
 */
chrome.platformKeys.ServerCertificateVerificationResult = function() {};
 /** @type {boolean} */
chrome.platformKeys.ServerCertificateVerificationResult.prototype.trusted;
 /** @type {!Array<string>} */
chrome.platformKeys.ServerCertificateVerificationResult.prototype.debug_errors;

/**
 * This function filters from a list of client certificates the ones that are known to the platform, match request and for which the extension has permission to access the certificate and its private key. If interactive is true, the user is presented a dialog where he can select from matching certificates and grant the extension access to the certificate. The selected/filtered client certificates will be passed to callback.
 * @param {!chrome.platformKeys.ClientCertificateSelectDetails} details
 * @param {function(!Array<!chrome.platformKeys.Match>): void} callback The callback parameter should be a function that looks like this:
 * function(array of Match matches) {...};
 * Parameter matches: The list of certificates that match the request, that the extension has permission for and, if interactive is true, that were selected by the user.
 * @return {void}
 */
chrome.platformKeys.selectClientCertificates = function(details, callback) {};

/**
 * Passes the key pair of certificate for usage with platformKeys.subtleCrypto to callback.
 * @param {!ArrayBuffer} certificate The certificate of a Match returned by selectClientCertificates.
 * @param {!Object} parameters Determines signature/hash algorithm parameters additionally to the parameters fixed by the key itself. The same parameters are   accepted as by WebCrypto's importKey function, e.g. RsaHashedImportParams for a RSASSA-PKCS1-v1_5 key. For RSASSA-PKCS1-v1_5 keys, additionally the parameters { 'hash': { 'name': 'none' } } are supported. The sign function will then apply PKCS#1 v1.5 padding and but not hash the given data.
 * @param {function(!CryptoKey, !CryptoKey): void} callback The public and private CryptoKey of a certificate which can only be used with platformKeys.subtleCrypto.
 * The callback parameter should be a function that looks like this:
 * function(object publicKey, object privateKey) {...};
 * Optional parameter privateKey: Might be null if this extension does not have access to it.
 * @return {void}
 */
chrome.platformKeys.getKeyPair = function(certificate, parameters, callback) {};

/**
 * An implementation of WebCrypto's  SubtleCrypto that allows crypto operations on keys of client certificates that are available to this extension.
 * @return {!SubtleCrypto}
 */
chrome.platformKeys.subtleCrypto = function() {};

/**
 * Checks whether details.serverCertificateChain can be trusted for details.hostname according to the trust settings of the platform. Note: The actual behavior of the trust verification is not fully specified and might change in the future. The API implementation verifies certificate expiration, validates the certification path and checks trust by a known CA. The implementation is supposed to respect the EKU serverAuth and to support subject alternative names.
 * @param {!chrome.platformKeys.ServerCertificateVerificationDetails} details
 * @param {function(!chrome.platformKeys.ServerCertificateVerificationResult): void} callback The callback parameter should be a function that looks like this:
 * function(object result) {...};
 * @return {void}
 */
chrome.platformKeys.verifyTLSServerCertificate = function(details, callback) {};
/** @const */
chrome.power = {};

/**
 * Requests that power management be temporarily disabled. |level| describes the degree to which power management should be disabled. If a request previously made by the same app is still active, it will be replaced by the new request.
 * @param {string} level
 * @return {void}
 */
chrome.power.requestKeepAwake = function(level) {};

/**
 * Releases a request previously made via requestKeepAwake().
 * @return {void}
 */
chrome.power.releaseKeepAwake = function() {};
/** @const */
chrome.printerProvider = {};
/**
 * @record
 * @struct
 */
chrome.printerProvider.PrinterInfo = function() {};
 /** @type {string} */
chrome.printerProvider.PrinterInfo.prototype.id;
 /** @type {string} */
chrome.printerProvider.PrinterInfo.prototype.name;
 /** @type {string} */
chrome.printerProvider.PrinterInfo.prototype.description;
/**
 * @record
 * @struct
 */
chrome.printerProvider.PrinterCapabilities = function() {};
 /** @type {?} */
chrome.printerProvider.PrinterCapabilities.prototype.capabilities;
/**
 * @record
 * @struct
 */
chrome.printerProvider.PrintJob = function() {};
 /** @type {string} */
chrome.printerProvider.PrintJob.prototype.printerId;
 /** @type {string} */
chrome.printerProvider.PrintJob.prototype.title;
 /** @type {!Object} */
chrome.printerProvider.PrintJob.prototype.ticket;
 /** @type {string} */
chrome.printerProvider.PrintJob.prototype.contentType;
 /** @type {!Blob} */
chrome.printerProvider.PrintJob.prototype.document;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.printerProvider.PrinterRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.printerProvider.PrinterInfoRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.printerProvider.CapabilityRequestedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.printerProvider.PrintRequestedEvent = function() {};
 /** @type {!chrome.printerProvider.PrinterRequestedEvent} */
chrome.printerProvider.onGetPrintersRequested;
 /** @type {!chrome.printerProvider.PrinterInfoRequestedEvent} */
chrome.printerProvider.onGetUsbPrinterInfoRequested;
 /** @type {!chrome.printerProvider.CapabilityRequestedEvent} */
chrome.printerProvider.onGetCapabilityRequested;
 /** @type {!chrome.printerProvider.PrintRequestedEvent} */
chrome.printerProvider.onPrintRequested;
/** @const */
chrome.privacy = {};
/**
 * @record
 * @struct
 */
chrome.privacy.Services = function() {};
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.spellingServiceEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.searchSuggestEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.instantEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.alternateErrorPagesEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.safeBrowsingEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.autofillEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.translationServiceEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.passwordSavingEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.hotwordSearchEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Services.prototype.safeBrowsingExtendedReportingEnabled;
/**
 * @record
 * @struct
 */
chrome.privacy.Network = function() {};
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Network.prototype.networkPredictionEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Network.prototype.webRTCMultipleRoutesEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Network.prototype.webRTCNonProxiedUdpEnabled;
/**
 * @record
 * @struct
 */
chrome.privacy.Websites = function() {};
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Websites.prototype.thirdPartyCookiesAllowed;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Websites.prototype.referrersEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Websites.prototype.hyperlinkAuditingEnabled;
 /** @type {!chrome.types.ChromeSetting} */
chrome.privacy.Websites.prototype.protectedContentEnabled;
 /** @type {!chrome.privacy.Services} */
chrome.privacy.services;
 /** @type {!chrome.privacy.Network} */
chrome.privacy.network;
 /** @type {!chrome.privacy.Websites} */
chrome.privacy.websites;
/** @const */
chrome.proxy = {};
/**
 * @record
 * @struct
 */
chrome.proxy.PacScript = function() {};
 /** @type {string} */
chrome.proxy.PacScript.prototype.url;
 /** @type {boolean} */
chrome.proxy.PacScript.prototype.mandatory;
 /** @type {string} */
chrome.proxy.PacScript.prototype.data;
/**
 * @record
 * @struct
 */
chrome.proxy.ProxyConfig = function() {};
 /** @type {!chrome.proxy.ProxyRules} */
chrome.proxy.ProxyConfig.prototype.rules;
 /** @type {!chrome.proxy.PacScript} */
chrome.proxy.ProxyConfig.prototype.pacScript;
 /** @type {string} */
chrome.proxy.ProxyConfig.prototype.mode;
/**
 * @record
 * @struct
 */
chrome.proxy.ProxyServer = function() {};
 /** @type {string} */
chrome.proxy.ProxyServer.prototype.host;
 /** @type {string} */
chrome.proxy.ProxyServer.prototype.scheme;
 /** @type {number} */
chrome.proxy.ProxyServer.prototype.port;
/**
 * @record
 * @struct
 */
chrome.proxy.ProxyRules = function() {};
 /** @type {!chrome.proxy.ProxyServer} */
chrome.proxy.ProxyRules.prototype.proxyForFtp;
 /** @type {!chrome.proxy.ProxyServer} */
chrome.proxy.ProxyRules.prototype.proxyForHttp;
 /** @type {!chrome.proxy.ProxyServer} */
chrome.proxy.ProxyRules.prototype.fallbackProxy;
 /** @type {!chrome.proxy.ProxyServer} */
chrome.proxy.ProxyRules.prototype.singleProxy;
 /** @type {!chrome.proxy.ProxyServer} */
chrome.proxy.ProxyRules.prototype.proxyForHttps;
 /** @type {!Array<string>} */
chrome.proxy.ProxyRules.prototype.bypassList;
/**
 * @record
 * @struct
 */
chrome.proxy.ErrorDetails = function() {};
 /** @type {string} */
chrome.proxy.ErrorDetails.prototype.details;
 /** @type {string} */
chrome.proxy.ErrorDetails.prototype.error;
 /** @type {boolean} */
chrome.proxy.ErrorDetails.prototype.fatal;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.proxy.ProxyErrorEvent = function() {};
 /** @type {!chrome.types.ChromeSetting} */
chrome.proxy.settings;
 /** @type {!chrome.proxy.ProxyErrorEvent} */
chrome.proxy.onProxyError;
/** @const */
chrome.runtime = {};
 /** @type {!chrome.runtime.LastError} */
chrome.runtime.lastError;
 /** @type {string} */
chrome.runtime.id;
/**
 * @record
 * @struct
 */
chrome.runtime.LastError = function() {};
 /** @type {string} */
chrome.runtime.LastError.prototype.message;
/**
 * @record
 * @struct
 */
chrome.runtime.ConnectInfo = function() {};
 /** @type {string} */
chrome.runtime.ConnectInfo.prototype.name;
/**
 * @record
 * @struct
 */
chrome.runtime.InstalledDetails = function() {};
 /** @type {string} */
chrome.runtime.InstalledDetails.prototype.reason;
 /** @type {string} */
chrome.runtime.InstalledDetails.prototype.previousVersion;
 /** @type {string} */
chrome.runtime.InstalledDetails.prototype.id;
/**
 * @record
 * @struct
 */
chrome.runtime.MessageOptions = function() {};
 /** @type {boolean} */
chrome.runtime.MessageOptions.prototype.includeTlsChannelId;
/**
 * @record
 * @struct
 */
chrome.runtime.MessageSender = function() {};
 /** @type {string} */
chrome.runtime.MessageSender.prototype.id;
 /** @type {!chrome.tabs.Tab} */
chrome.runtime.MessageSender.prototype.tab;
 /** @type {number} */
chrome.runtime.MessageSender.prototype.frameId;
 /** @type {string} */
chrome.runtime.MessageSender.prototype.url;
 /** @type {string} */
chrome.runtime.MessageSender.prototype.tlsChannelId;
/**
 * @record
 * @struct
 */
chrome.runtime.PlatformInfo = function() {};
 /** @type {string} */
chrome.runtime.PlatformInfo.prototype.os;
 /** @type {string} */
chrome.runtime.PlatformInfo.prototype.arch;
 /** @type {string} */
chrome.runtime.PlatformInfo.prototype.nacl_arch;
/**
 * @record
 * @struct
 */
chrome.runtime.Port = function() {};
 /** @type {function(!Object): void} */
chrome.runtime.Port.prototype.postMessage;
 /** @type {function(): void} */
chrome.runtime.Port.prototype.disconnect;
 /** @type {!chrome.runtime.MessageSender} */
chrome.runtime.Port.prototype.sender;
 /** @type {!chrome.runtime.PortDisconnectEvent} */
chrome.runtime.Port.prototype.onDisconnect;
 /** @type {!chrome.runtime.PortMessageEvent} */
chrome.runtime.Port.prototype.onMessage;
 /** @type {string} */
chrome.runtime.Port.prototype.name;
/**
 * @record
 * @struct
 */
chrome.runtime.UpdateAvailableDetails = function() {};
 /** @type {string} */
chrome.runtime.UpdateAvailableDetails.prototype.version;
/**
 * @record
 * @struct
 */
chrome.runtime.UpdateCheckDetails = function() {};
 /** @type {string} */
chrome.runtime.UpdateCheckDetails.prototype.version;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.runtime.PortDisconnectEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.runtime.PortMessageEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.runtime.ExtensionMessageEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.runtime.ExtensionConnectEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.runtime.RuntimeInstalledEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.runtime.RuntimeEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.runtime.RuntimeRestartRequiredEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.runtime.RuntimeUpdateAvailableEvent = function() {};
/**
 * @record
 * @struct
 */
chrome.runtime.ManifestIcons = function() {};

/* TODO: IndexSignature: chrome.runtime */
/**
 * @record
 * @struct
 */
chrome.runtime.ManifestAction = function() {};
 /** @type {!chrome.runtime.ManifestIcons} */
chrome.runtime.ManifestAction.prototype.default_icon;
 /** @type {string} */
chrome.runtime.ManifestAction.prototype.default_title;
 /** @type {string} */
chrome.runtime.ManifestAction.prototype.default_popup;
/**
 * @record
 * @struct
 */
chrome.runtime.SearchProvider = function() {};
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.name;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.keyword;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.favicon_url;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.search_url;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.encoding;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.suggest_url;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.instant_url;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.image_url;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.search_url_post_params;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.suggest_url_post_params;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.instant_url_post_params;
 /** @type {string} */
chrome.runtime.SearchProvider.prototype.image_url_post_params;
 /** @type {!Array<string>} */
chrome.runtime.SearchProvider.prototype.alternate_urls;
 /** @type {number} */
chrome.runtime.SearchProvider.prototype.prepopulated_id;
 /** @type {boolean} */
chrome.runtime.SearchProvider.prototype.is_default;
/**
 * @record
 * @struct
 */
chrome.runtime.Manifest = function() {};
 /** @type {number} */
chrome.runtime.Manifest.prototype.manifest_version;
 /** @type {string} */
chrome.runtime.Manifest.prototype.name;
 /** @type {string} */
chrome.runtime.Manifest.prototype.version;
 /** @type {string} */
chrome.runtime.Manifest.prototype.default_locale;
 /** @type {string} */
chrome.runtime.Manifest.prototype.description;
 /** @type {!chrome.runtime.ManifestIcons} */
chrome.runtime.Manifest.prototype.icons;
 /** @type {!chrome.runtime.ManifestAction} */
chrome.runtime.Manifest.prototype.browser_action;
 /** @type {!chrome.runtime.ManifestAction} */
chrome.runtime.Manifest.prototype.page_action;
 /** @type {?} */
chrome.runtime.Manifest.prototype.author;
 /** @type {?} */
chrome.runtime.Manifest.prototype.automation;
 /** @type {{scripts: !Array<string>, page: string, persistent: boolean}} */
chrome.runtime.Manifest.prototype.background;
 /** @type {string} */
chrome.runtime.Manifest.prototype.background_page;
 /** @type {{homepage: string, search_provider: !chrome.runtime.SearchProvider, startup_pages: !Array<string>}} */
chrome.runtime.Manifest.prototype.chrome_settings_overrides;
 /** @type {{bookmarks_ui: {remove_bookmark_shortcut: boolean, remove_button: boolean}}} */
chrome.runtime.Manifest.prototype.chrome_ui_overrides;
 /** @type {{bookmarks: string, history: string, newtab: string}} */
chrome.runtime.Manifest.prototype.chrome_url_overrides;
 /** @type {!Object<string,{suggested_key: {default: string, windows: string, mac: string, chromeos: string, linux: string}, description: string, global: boolean}>} */
chrome.runtime.Manifest.prototype.commands;
 /** @type {{matches: !Array<string>, permissions: !Array<string>}} */
chrome.runtime.Manifest.prototype.content_capabilities;
 /** @type {!Array<{matches: !Array<string>, exclude_matches: !Array<string>, css: !Array<string>, js: !Array<string>, run_at: string, all_frames: boolean, include_globs: !Array<string>, exclude_globs: !Array<string>}>} */
chrome.runtime.Manifest.prototype.content_scripts;
 /** @type {string} */
chrome.runtime.Manifest.prototype.content_security_policy;
 /** @type {boolean} */
chrome.runtime.Manifest.prototype.converted_from_user_script;
 /** @type {?} */
chrome.runtime.Manifest.prototype.copresence;
 /** @type {string} */
chrome.runtime.Manifest.prototype.current_locale;
 /** @type {string} */
chrome.runtime.Manifest.prototype.devtools_page;
 /** @type {!Array<{event: string, actions: !Array<{type: string}>, conditions: !Array<!chrome.declarativeContent.PageStateMatcher>}>} */
chrome.runtime.Manifest.prototype.event_rules;
 /** @type {{ids: !Array<string>, matches: !Array<string>, accepts_tls_channel_id: boolean}} */
chrome.runtime.Manifest.prototype.externally_connectable;
 /** @type {!Array<{id: string, default_title: string, file_filters: !Array<string>}>} */
chrome.runtime.Manifest.prototype.file_browser_handlers;
 /** @type {{configurable: boolean, watchable: boolean, multiple_mounts: boolean, source: string}} */
chrome.runtime.Manifest.prototype.file_system_provider_capabilities;
 /** @type {string} */
chrome.runtime.Manifest.prototype.homepage_url;
 /** @type {!Array<{id: string, minimum_version: string}>} */
chrome.runtime.Manifest.prototype.import;
 /** @type {{whitelist: !Array<string>}} */
chrome.runtime.Manifest.prototype.export;
 /** @type {string} */
chrome.runtime.Manifest.prototype.incognito;
 /** @type {!Array<{name: string, type: string, id: string, description: string, language: string, layouts: !Array<?>}>} */
chrome.runtime.Manifest.prototype.input_components;
 /** @type {string} */
chrome.runtime.Manifest.prototype.key;
 /** @type {string} */
chrome.runtime.Manifest.prototype.minimum_chrome_version;
 /** @type {!Array<{path: string, mime_type: string}>} */
chrome.runtime.Manifest.prototype.nacl_modules;
 /** @type {{client_id: string, scopes: !Array<string>}} */
chrome.runtime.Manifest.prototype.oauth2;
 /** @type {boolean} */
chrome.runtime.Manifest.prototype.offline_enabled;
 /** @type {{keyword: string}} */
chrome.runtime.Manifest.prototype.omnibox;
 /** @type {!Array<string>} */
chrome.runtime.Manifest.prototype.optional_permissions;
 /** @type {string} */
chrome.runtime.Manifest.prototype.options_page;
 /** @type {{page: string, chrome_style: boolean, open_in_tab: boolean}} */
chrome.runtime.Manifest.prototype.options_ui;
 /** @type {!Array<string>} */
chrome.runtime.Manifest.prototype.permissions;
 /** @type {!Array<{nacl_arch: string, sub_package_path: string}>} */
chrome.runtime.Manifest.prototype.platforms;
 /** @type {!Array<{path: string}>} */
chrome.runtime.Manifest.prototype.plugins;
 /** @type {{3D: {features: !Array<string>}, plugins: {npapi: boolean}}} */
chrome.runtime.Manifest.prototype.requirements;
 /** @type {{pages: !Array<string>, content_security_policy: string}} */
chrome.runtime.Manifest.prototype.sandbox;
 /** @type {string} */
chrome.runtime.Manifest.prototype.short_name;
 /** @type {?} */
chrome.runtime.Manifest.prototype.signature;
 /** @type {{dictionary_language: string, dictionary_locale: string, dictionary_format: string, dictionary_path: string}} */
chrome.runtime.Manifest.prototype.spellcheck;
 /** @type {{managed_schema: string}} */
chrome.runtime.Manifest.prototype.storage;
 /** @type {?} */
chrome.runtime.Manifest.prototype.system_indicator;
 /** @type {{voices: !Array<{voice_name: string, lang: string, gender: string, event_types: !Array<string>}>}} */
chrome.runtime.Manifest.prototype.tts_engine;
 /** @type {string} */
chrome.runtime.Manifest.prototype.update_url;
 /** @type {string} */
chrome.runtime.Manifest.prototype.version_name;
 /** @type {!Array<string>} */
chrome.runtime.Manifest.prototype.web_accessible_resources;

/* TODO: IndexSignature: chrome.runtime */

/**
 * Attempts to connect to connect listeners within an extension/app (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via tabs.connect.
 * \@since Chrome 26.
 * Attempts to connect to connect listeners within an extension/app (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via tabs.connect.
 * \@since Chrome 26.
 * @param {!chrome.runtime.ConnectInfo|string=} connectInfo_or_extensionId Optional.
 * The ID of the extension or app to connect to. If omitted, a connection will be attempted with your own extension. Required if sending messages from a web page for web messaging.
 * @param {!chrome.runtime.ConnectInfo=} connectInfo
 * @return {!chrome.runtime.Port}
 */
chrome.runtime.connect = function(connectInfo_or_extensionId, connectInfo) {};

/**
 * Connects to a native application in the host machine.
 * \@since Chrome 28.
 * @param {string} application The name of the registered application to connect to.
 * @return {!chrome.runtime.Port}
 */
chrome.runtime.connectNative = function(application) {};

/**
 * Retrieves the JavaScript 'window' object for the background page running inside the current extension/app. If the background page is an event page, the system will ensure it is loaded before calling the callback. If there is no background page, an error is set.
 * @param {function(!Window): void} callback
 * @return {void}
 */
chrome.runtime.getBackgroundPage = function(callback) {};

/**
 * Returns details about the app or extension from the manifest. The object returned is a serialization of the full manifest file.
 * @return {!chrome.runtime.Manifest} The manifest details.
 */
chrome.runtime.getManifest = function() {};

/**
 * Returns a DirectoryEntry for the package directory.
 * \@since Chrome 29.
 * @param {function(!DirectoryEntry): void} callback
 * @return {void}
 */
chrome.runtime.getPackageDirectoryEntry = function(callback) {};

/**
 * Returns information about the current platform.
 * \@since Chrome 29.
 * @param {function(!chrome.runtime.PlatformInfo): void} callback Called with results
 * @return {void}
 */
chrome.runtime.getPlatformInfo = function(callback) {};

/**
 * Converts a relative path within an app/extension install directory to a fully-qualified URL.
 * @param {string} path A path to a resource within an app/extension expressed relative to its install directory.
 * @return {string}
 */
chrome.runtime.getURL = function(path) {};

/**
 * Reloads the app or extension.
 * \@since Chrome 25.
 * @return {void}
 */
chrome.runtime.reload = function() {};

/**
 * Requests an update check for this app/extension.
 * \@since Chrome 25.
 * @param {function(string, !chrome.runtime.UpdateCheckDetails): void} callback 
 * Parameter status: Result of the update check. One of: "throttled", "no_update", or "update_available"
 * Optional parameter details: If an update is available, this contains more information about the available update.
 * @return {void}
 */
chrome.runtime.requestUpdateCheck = function(callback) {};

/**
 * Restart the ChromeOS device when the app runs in kiosk mode. Otherwise, it's no-op.
 * \@since Chrome 32.
 * @return {void}
 */
chrome.runtime.restart = function() {};

/**
 * Sends a single message to event listeners within your extension/app or a different extension/app. Similar to runtime.connect but only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage event will be fired in each page, or runtime.onMessageExternal, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage.
 * \@since Chrome 26.
 * Sends a single message to event listeners within your extension/app or a different extension/app. Similar to runtime.connect but only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage event will be fired in each page, or runtime.onMessageExternal, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage.
 * \@since Chrome 32.
 * Sends a single message to event listeners within your extension/app or a different extension/app. Similar to runtime.connect but only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage event will be fired in each page, or runtime.onMessageExternal, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage.
 * \@since Chrome 26.
 * Sends a single message to event listeners within your extension/app or a different extension/app. Similar to runtime.connect but only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage event will be fired in each page, or runtime.onMessageExternal, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage.
 * \@since Chrome 32.
 * @param {?|string} message_or_extensionId The ID of the extension/app to send the message to. If omitted, the message will be sent to your own extension/app. Required if sending messages from a web page for web messaging.
 * @param {function(?): void|!chrome.runtime.MessageOptions|?=} responseCallback_or_options_or_message Optional
 * Parameter response: The JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.
 * @param {function(?): void|!chrome.runtime.MessageOptions=} responseCallback_or_options Optional
 * Parameter response: The JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.
 * @param {function(?): void=} responseCallback Optional
 * Parameter response: The JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.
 * @return {void}
 */
chrome.runtime.sendMessage = function(message_or_extensionId, responseCallback_or_options_or_message, responseCallback_or_options, responseCallback) {};

/**
 * Send a single message to a native application.
 * \@since Chrome 28.
 * @param {string} application The of the native messaging host.
 * @param {!Object} message The message that will be passed to the native messaging host.
 * @param {function(?): void=} responseCallback Optional.
 * Parameter response: The response message sent by the native messaging host. If an error occurs while connecting to the native messaging host, the callback will be called with no arguments and runtime.lastError will be set to the error message.
 * @return {void}
 */
chrome.runtime.sendNativeMessage = function(application, message, responseCallback) {};

/**
 * Sets the URL to be visited upon uninstallation. This may be used to clean up server-side data, do analytics, and implement surveys. Maximum 255 characters.
 * \@since Chrome 41.
 * @param {string} url Since Chrome 34.
 * URL to be opened after the extension is uninstalled. This URL must have an http: or https: scheme. Set an empty string to not open a new tab upon uninstallation.
 * @param {function(): void=} callback Called when the uninstall URL is set. If the given URL is invalid, runtime.lastError will be set.
 * @return {void}
 */
chrome.runtime.setUninstallURL = function(url, callback) {};

/**
 * Open your Extension's options page, if possible.
 * The precise behavior may depend on your manifest's options_ui or options_page key, or what Chrome happens to support at the time. For example, the page may be opened in a new tab, within chrome://extensions, within an App, or it may just focus an open options page. It will never cause the caller page to reload.
 * If your Extension does not declare an options page, or Chrome failed to create one for some other reason, the callback will set lastError.
 * \@since Chrome 42.
 * @param {function(): void=} callback
 * @return {void}
 */
chrome.runtime.openOptionsPage = function(callback) {};
 /** @type {!chrome.runtime.ExtensionConnectEvent} */
chrome.runtime.onConnect;
 /** @type {!chrome.runtime.ExtensionConnectEvent} */
chrome.runtime.onConnectExternal;
 /** @type {!chrome.runtime.RuntimeEvent} */
chrome.runtime.onSuspend;
 /** @type {!chrome.runtime.RuntimeEvent} */
chrome.runtime.onStartup;
 /** @type {!chrome.runtime.RuntimeInstalledEvent} */
chrome.runtime.onInstalled;
 /** @type {!chrome.runtime.RuntimeEvent} */
chrome.runtime.onSuspendCanceled;
 /** @type {!chrome.runtime.ExtensionMessageEvent} */
chrome.runtime.onMessage;
 /** @type {!chrome.runtime.ExtensionMessageEvent} */
chrome.runtime.onMessageExternal;
 /** @type {!chrome.runtime.RuntimeRestartRequiredEvent} */
chrome.runtime.onRestartRequired;
 /** @type {!chrome.runtime.RuntimeUpdateAvailableEvent} */
chrome.runtime.onUpdateAvailable;
 /** @type {!chrome.runtime.RuntimeEvent} */
chrome.runtime.onBrowserUpdateAvailable;
/** @const */
chrome.scriptBadge = {};
/**
 * @record
 * @struct
 */
chrome.scriptBadge.GetPopupDetails = function() {};
 /** @type {number} */
chrome.scriptBadge.GetPopupDetails.prototype.tabId;
/**
 * @record
 * @struct
 */
chrome.scriptBadge.AttentionDetails = function() {};
 /** @type {number} */
chrome.scriptBadge.AttentionDetails.prototype.tabId;
/**
 * @record
 * @struct
 */
chrome.scriptBadge.SetPopupDetails = function() {};
 /** @type {number} */
chrome.scriptBadge.SetPopupDetails.prototype.tabId;
 /** @type {string} */
chrome.scriptBadge.SetPopupDetails.prototype.popup;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.scriptBadge.ScriptBadgeClickedEvent = function() {};

/**
 * @param {!chrome.scriptBadge.GetPopupDetails} details
 * @param {!Function} callback
 * @return {void}
 */
chrome.scriptBadge.getPopup = function(details, callback) {};

/**
 * @param {!chrome.scriptBadge.AttentionDetails} details
 * @return {void}
 */
chrome.scriptBadge.getAttention = function(details) {};

/**
 * @param {!chrome.scriptBadge.SetPopupDetails} details
 * @return {void}
 */
chrome.scriptBadge.setPopup = function(details) {};
 /** @type {!chrome.scriptBadge.ScriptBadgeClickedEvent} */
chrome.scriptBadge.onClicked;
/** @const */
chrome.sessions = {};
/**
 * @record
 * @struct
 */
chrome.sessions.Filter = function() {};
 /** @type {number} */
chrome.sessions.Filter.prototype.maxResults;
/**
 * @record
 * @struct
 */
chrome.sessions.Session = function() {};
 /** @type {number} */
chrome.sessions.Session.prototype.lastModified;
 /** @type {!chrome.tabs.Tab} */
chrome.sessions.Session.prototype.tab;
 /** @type {!chrome.windows.Window} */
chrome.sessions.Session.prototype.window;
/**
 * @record
 * @struct
 */
chrome.sessions.Device = function() {};
 /** @type {string} */
chrome.sessions.Device.prototype.deviceName;
 /** @type {!Array<!chrome.sessions.Session>} */
chrome.sessions.Device.prototype.sessions;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.sessions.SessionChangedEvent = function() {};
 /** @type {number} */
chrome.sessions.MAX_SESSION_RESULTS;

/**
 * Gets the list of recently closed tabs and/or windows.
 * Gets the list of recently closed tabs and/or windows.
 * @param {!chrome.sessions.Filter|function(!Array<!chrome.sessions.Session>): void} filter_or_callback 
 * Parameter sessions: The list of closed entries in reverse order that they were closed (the most recently closed tab or window will be at index 0). The entries may contain either tabs or windows.
 * @param {function(!Array<!chrome.sessions.Session>): void=} callback 
 * Parameter sessions: The list of closed entries in reverse order that they were closed (the most recently closed tab or window will be at index 0). The entries may contain either tabs or windows.
 * @return {void}
 */
chrome.sessions.getRecentlyClosed = function(filter_or_callback, callback) {};

/**
 * Retrieves all devices with synced sessions.
 * Retrieves all devices with synced sessions.
 * @param {!chrome.sessions.Filter|function(!Array<!chrome.sessions.Device>): void} filter_or_callback 
 * Parameter devices: The list of sessions.Device objects for each synced session, sorted in order from device with most recently modified session to device with least recently modified session. tabs.Tab objects are sorted by recency in the windows.Window of the sessions.Session objects.
 * @param {function(!Array<!chrome.sessions.Device>): void=} callback 
 * Parameter devices: The list of sessions.Device objects for each synced session, sorted in order from device with most recently modified session to device with least recently modified session. tabs.Tab objects are sorted by recency in the windows.Window of the sessions.Session objects.
 * @return {void}
 */
chrome.sessions.getDevices = function(filter_or_callback, callback) {};

/**
 * Reopens a windows.Window or tabs.Tab, with an optional callback to run when the entry has been restored.
 * @param {string=} sessionId Optional.
 * The windows.Window.sessionId, or tabs.Tab.sessionId to restore. If this parameter is not specified, the most recently closed session is restored.
 * @param {function(!chrome.sessions.Session): void=} callback Optional.
 * Parameter restoredSession: A sessions.Session containing the restored windows.Window or tabs.Tab object.
 * @return {void}
 */
chrome.sessions.restore = function(sessionId, callback) {};
 /** @type {!chrome.sessions.SessionChangedEvent} */
chrome.sessions.onChanged;
/** @const */
chrome.storage = {};
/**
 * @record
 * @struct
 */
chrome.storage.StorageArea = function() {};

/**
 * Gets the amount of space (in bytes) being used by one or more items.
 * Gets the amount of space (in bytes) being used by one or more items.
 * @param {function(number): void|(string|!Array<string>)} callback_or_keys Callback with the amount of space being used by storage, or on failure (in which case runtime.lastError will be set).
 * Parameter bytesInUse: Amount of space being used in storage, in bytes. / A single key or list of keys to get the total usage for. An empty list will return 0. Pass in null to get the total usage of all of storage.
 * @param {function(number): void=} callback Callback with the amount of space being used by storage, or on failure (in which case runtime.lastError will be set).
 * Parameter bytesInUse: Amount of space being used in storage, in bytes.
 * @return {void}
 */
chrome.storage.StorageArea.prototype.getBytesInUse = function(callback_or_keys, callback) {};

/**
 * Removes all items from storage.
 * @param {function(): void=} callback Optional.
 * Callback on success, or on failure (in which case runtime.lastError will be set).
 * @return {void}
 */
chrome.storage.StorageArea.prototype.clear = function(callback) {};

/**
 * Sets multiple items.
 * @param {!Object} items An object which gives each key/value pair to update storage with. Any other key/value pairs in storage will not be affected.
 * Primitive values such as numbers will serialize as expected. Values with a typeof "object" and "function" will typically serialize to {}, with the exception of Array (serializes as expected), Date, and Regex (serialize using their String representation).
 * @param {function(): void=} callback Optional.
 * Callback on success, or on failure (in which case runtime.lastError will be set).
 * @return {void}
 */
chrome.storage.StorageArea.prototype.set = function(items, callback) {};

/**
 * Removes one item from storage.
 * Removes items from storage.
 * @param {string|!Array<string>} key_or_keys A single key for items to remove. / A list of keys for items to remove.
 * @param {function(): void=} callback Optional.
 * Callback on success, or on failure (in which case runtime.lastError will be set).
 * @return {void}
 */
chrome.storage.StorageArea.prototype.remove = function(key_or_keys, callback) {};

/**
 * Gets one or more items from storage.
 * Gets one or more items from storage.
 * @param {function(!Object<string,?>): void|(string|!Object|!Array<string>)} callback_or_keys Callback with storage items, or on failure (in which case runtime.lastError will be set).
 * Parameter items: Object with items in their key-value mappings. / A single key to get, list of keys to get, or a dictionary specifying default values.
 * An empty list or object will return an empty result object. Pass in null to get the entire contents of storage.
 * @param {function(!Object<string,?>): void=} callback Callback with storage items, or on failure (in which case runtime.lastError will be set).
 * Parameter items: Object with items in their key-value mappings.
 * @return {void}
 */
chrome.storage.StorageArea.prototype.get = function(callback_or_keys, callback) {};
/**
 * @record
 * @struct
 */
chrome.storage.StorageChange = function() {};
 /** @type {?} */
chrome.storage.StorageChange.prototype.newValue;
 /** @type {?} */
chrome.storage.StorageChange.prototype.oldValue;
/**
 * @extends {chrome.storage.StorageArea}
 * @record
 * @struct
 */
chrome.storage.LocalStorageArea = function() {};
 /** @type {number} */
chrome.storage.LocalStorageArea.prototype.QUOTA_BYTES;
/**
 * @extends {chrome.storage.StorageArea}
 * @record
 * @struct
 */
chrome.storage.SyncStorageArea = function() {};
 /** @type {number} */
chrome.storage.SyncStorageArea.prototype.MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE;
 /** @type {number} */
chrome.storage.SyncStorageArea.prototype.QUOTA_BYTES;
 /** @type {number} */
chrome.storage.SyncStorageArea.prototype.QUOTA_BYTES_PER_ITEM;
 /** @type {number} */
chrome.storage.SyncStorageArea.prototype.MAX_ITEMS;
 /** @type {number} */
chrome.storage.SyncStorageArea.prototype.MAX_WRITE_OPERATIONS_PER_HOUR;
 /** @type {number} */
chrome.storage.SyncStorageArea.prototype.MAX_WRITE_OPERATIONS_PER_MINUTE;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.storage.StorageChangedEvent = function() {};
 /** @type {!chrome.storage.LocalStorageArea} */
chrome.storage.local;
 /** @type {!chrome.storage.SyncStorageArea} */
chrome.storage.sync;
 /** @type {!chrome.storage.StorageArea} */
chrome.storage.managed;
 /** @type {!chrome.storage.StorageChangedEvent} */
chrome.storage.onChanged;
/** @const */
chrome.socket = {};
/**
 * @record
 * @struct
 */
chrome.socket.CreateInfo = function() {};
 /** @type {number} */
chrome.socket.CreateInfo.prototype.socketId;
/**
 * @record
 * @struct
 */
chrome.socket.AcceptInfo = function() {};
 /** @type {number} */
chrome.socket.AcceptInfo.prototype.resultCode;
 /** @type {number} */
chrome.socket.AcceptInfo.prototype.socketId;
/**
 * @record
 * @struct
 */
chrome.socket.ReadInfo = function() {};
 /** @type {number} */
chrome.socket.ReadInfo.prototype.resultCode;
 /** @type {!ArrayBuffer} */
chrome.socket.ReadInfo.prototype.data;
/**
 * @record
 * @struct
 */
chrome.socket.WriteInfo = function() {};
 /** @type {number} */
chrome.socket.WriteInfo.prototype.bytesWritten;
/**
 * @record
 * @struct
 */
chrome.socket.RecvFromInfo = function() {};
 /** @type {number} */
chrome.socket.RecvFromInfo.prototype.resultCode;
 /** @type {!ArrayBuffer} */
chrome.socket.RecvFromInfo.prototype.data;
 /** @type {number} */
chrome.socket.RecvFromInfo.prototype.port;
 /** @type {string} */
chrome.socket.RecvFromInfo.prototype.address;
/**
 * @record
 * @struct
 */
chrome.socket.SocketInfo = function() {};
 /** @type {string} */
chrome.socket.SocketInfo.prototype.socketType;
 /** @type {number} */
chrome.socket.SocketInfo.prototype.localPort;
 /** @type {string} */
chrome.socket.SocketInfo.prototype.peerAddress;
 /** @type {number} */
chrome.socket.SocketInfo.prototype.peerPort;
 /** @type {string} */
chrome.socket.SocketInfo.prototype.localAddress;
 /** @type {boolean} */
chrome.socket.SocketInfo.prototype.connected;
/**
 * @record
 * @struct
 */
chrome.socket.NetworkInterface = function() {};
 /** @type {string} */
chrome.socket.NetworkInterface.prototype.name;
 /** @type {string} */
chrome.socket.NetworkInterface.prototype.address;

/**
 * @param {string} type
 * @param {!Object=} options
 * @param {function(!chrome.socket.CreateInfo): void=} callback
 * @return {void}
 */
chrome.socket.create = function(type, options, callback) {};

/**
 * @param {number} socketId
 * @return {void}
 */
chrome.socket.destroy = function(socketId) {};

/**
 * @param {number} socketId
 * @param {string} hostname
 * @param {number} port
 * @param {function(number): void} callback
 * @return {void}
 */
chrome.socket.connect = function(socketId, hostname, port, callback) {};

/**
 * @param {number} socketId
 * @param {string} address
 * @param {number} port
 * @param {function(number): void} callback
 * @return {void}
 */
chrome.socket.bind = function(socketId, address, port, callback) {};

/**
 * @param {number} socketId
 * @return {void}
 */
chrome.socket.disconnect = function(socketId) {};

/**
 * @param {number} socketId
 * @param {number=} bufferSize
 * @param {function(!chrome.socket.ReadInfo): void=} callback
 * @return {void}
 */
chrome.socket.read = function(socketId, bufferSize, callback) {};

/**
 * @param {number} socketId
 * @param {!ArrayBuffer} data
 * @param {function(!chrome.socket.WriteInfo): void=} callback
 * @return {void}
 */
chrome.socket.write = function(socketId, data, callback) {};

/**
 * @param {number} socketId
 * @param {number=} bufferSize
 * @param {function(!chrome.socket.RecvFromInfo): void=} callback
 * @return {void}
 */
chrome.socket.recvFrom = function(socketId, bufferSize, callback) {};

/**
 * @param {number} socketId
 * @param {!ArrayBuffer} data
 * @param {string} address
 * @param {number} port
 * @param {function(!chrome.socket.WriteInfo): void=} callback
 * @return {void}
 */
chrome.socket.sendTo = function(socketId, data, address, port, callback) {};

/**
 * @param {number} socketId
 * @param {string} address
 * @param {number} port
 * @param {number=} backlog
 * @param {function(number): void=} callback
 * @return {void}
 */
chrome.socket.listen = function(socketId, address, port, backlog, callback) {};

/**
 * @param {number} socketId
 * @param {function(!chrome.socket.AcceptInfo): void=} callback
 * @return {void}
 */
chrome.socket.accept = function(socketId, callback) {};

/**
 * @param {number} socketId
 * @param {boolean} enable
 * @param {number=} delay
 * @param {function(boolean): void=} callback
 * @return {void}
 */
chrome.socket.setKeepAlive = function(socketId, enable, delay, callback) {};

/**
 * @param {number} socketId
 * @param {boolean} noDelay
 * @param {function(boolean): void=} callback
 * @return {void}
 */
chrome.socket.setNoDelay = function(socketId, noDelay, callback) {};

/**
 * @param {number} socketId
 * @param {function(!chrome.socket.SocketInfo): void} callback
 * @return {void}
 */
chrome.socket.getInfo = function(socketId, callback) {};

/**
 * @param {function(!Array<!chrome.socket.NetworkInterface>): void} callback
 * @return {void}
 */
chrome.socket.getNetworkList = function(callback) {};
/** @const */
chrome.system = {};
/** @const */
chrome.system.cpu = {};
/**
 * @record
 * @struct
 */
chrome.system.cpu.ProcessorUsage = function() {};
 /** @type {number} */
chrome.system.cpu.ProcessorUsage.prototype.user;
 /** @type {number} */
chrome.system.cpu.ProcessorUsage.prototype.kernel;
 /** @type {number} */
chrome.system.cpu.ProcessorUsage.prototype.idle;
 /** @type {number} */
chrome.system.cpu.ProcessorUsage.prototype.total;
/**
 * @record
 * @struct
 */
chrome.system.cpu.ProcessorInfo = function() {};
 /** @type {!chrome.system.cpu.ProcessorUsage} */
chrome.system.cpu.ProcessorInfo.prototype.usage;
/**
 * @record
 * @struct
 */
chrome.system.cpu.CpuInfo = function() {};
 /** @type {number} */
chrome.system.cpu.CpuInfo.prototype.numOfProcessors;
 /** @type {string} */
chrome.system.cpu.CpuInfo.prototype.archName;
 /** @type {string} */
chrome.system.cpu.CpuInfo.prototype.modelName;
 /** @type {!Array<string>} */
chrome.system.cpu.CpuInfo.prototype.features;
 /** @type {!Array<!chrome.system.cpu.ProcessorInfo>} */
chrome.system.cpu.CpuInfo.prototype.processors;

/**
 * Queries basic CPU information of the system.
 * @param {function(!chrome.system.cpu.CpuInfo): void} callback
 * @return {void}
 */
chrome.system.cpu.getInfo = function(callback) {};
/** @const */
chrome.system.memory = {};
/**
 * @record
 * @struct
 */
chrome.system.memory.MemoryInfo = function() {};
 /** @type {number} */
chrome.system.memory.MemoryInfo.prototype.capacity;
 /** @type {number} */
chrome.system.memory.MemoryInfo.prototype.availableCapacity;

/**
 * Get physical memory information.
 * @param {function(!chrome.system.memory.MemoryInfo): void} callback
 * @return {void}
 */
chrome.system.memory.getInfo = function(callback) {};
/** @const */
chrome.system.storage = {};
/**
 * @record
 * @struct
 */
chrome.system.storage.StorageUnitInfo = function() {};
 /** @type {string} */
chrome.system.storage.StorageUnitInfo.prototype.id;
 /** @type {string} */
chrome.system.storage.StorageUnitInfo.prototype.name;
 /** @type {string} */
chrome.system.storage.StorageUnitInfo.prototype.type;
 /** @type {number} */
chrome.system.storage.StorageUnitInfo.prototype.capacity;
/**
 * @record
 * @struct
 */
chrome.system.storage.StorageCapacityInfo = function() {};
 /** @type {string} */
chrome.system.storage.StorageCapacityInfo.prototype.id;
 /** @type {number} */
chrome.system.storage.StorageCapacityInfo.prototype.availableCapacity;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.system.storage.SystemStorageAttachedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.system.storage.SystemStorageDetachedEvent = function() {};

/**
 * Get the storage information from the system. The argument passed to the callback is an array of StorageUnitInfo objects.
 * @param {function(!Array<!chrome.system.storage.StorageUnitInfo>): void} callback
 * @return {void}
 */
chrome.system.storage.getInfo = function(callback) {};

/**
 * Ejects a removable storage device.
 * @param {string} id
 * @param {function(string): void} callback 
 * Parameter result: success: The ejection command is successful -- the application can prompt the user to remove the device; in_use: The device is in use by another application. The ejection did not succeed; the user should not remove the device until the other application is done with the device; no_such_device: There is no such device known. failure: The ejection command failed.
 * @return {void}
 */
chrome.system.storage.ejectDevice = function(id, callback) {};

/**
 * Get the available capacity of a specified |id| storage device. The |id| is the transient device ID from StorageUnitInfo.
 * \@since Dev channel only.
 * @param {string} id
 * @param {function(!chrome.system.storage.StorageCapacityInfo): void} callback
 * @return {void}
 */
chrome.system.storage.getAvailableCapacity = function(id, callback) {};
 /** @type {!chrome.system.storage.SystemStorageAttachedEvent} */
chrome.system.storage.onAttached;
 /** @type {!chrome.system.storage.SystemStorageDetachedEvent} */
chrome.system.storage.onDetached;
/** @const */
chrome.tabCapture = {};
/**
 * @record
 * @struct
 */
chrome.tabCapture.CaptureInfo = function() {};
 /** @type {number} */
chrome.tabCapture.CaptureInfo.prototype.tabId;
 /** @type {string} */
chrome.tabCapture.CaptureInfo.prototype.status;
 /** @type {boolean} */
chrome.tabCapture.CaptureInfo.prototype.fullscreen;
/**
 * @record
 * @struct
 */
chrome.tabCapture.CaptureOptions = function() {};
 /** @type {boolean} */
chrome.tabCapture.CaptureOptions.prototype.audio;
 /** @type {boolean} */
chrome.tabCapture.CaptureOptions.prototype.video;
 /** @type {!MediaStreamConstraints} */
chrome.tabCapture.CaptureOptions.prototype.audioConstraints;
 /** @type {!MediaStreamConstraints} */
chrome.tabCapture.CaptureOptions.prototype.videoConstraints;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabCapture.CaptureStatusChangedEvent = function() {};

/**
 * Captures the visible area of the currently active tab. Capture can only be started on the currently active tab after the extension has been invoked. Capture is maintained across page navigations within the tab, and stops when the tab is closed, or the media stream is closed by the extension.
 * @param {!chrome.tabCapture.CaptureOptions} options Configures the returned media stream.
 * @param {function(!MediaStream): void} callback Callback with either the tab capture stream or null.
 * @return {void}
 */
chrome.tabCapture.capture = function(options, callback) {};

/**
 * Returns a list of tabs that have requested capture or are being captured, i.e. status != stopped and status != error. This allows extensions to inform the user that there is an existing tab capture that would prevent a new tab capture from succeeding (or to prevent redundant requests for the same tab).
 * @param {function(!Array<!chrome.tabCapture.CaptureInfo>): void} callback Callback invoked with CaptureInfo[] for captured tabs.
 * @return {void}
 */
chrome.tabCapture.getCapturedTabs = function(callback) {};
 /** @type {!chrome.tabCapture.CaptureStatusChangedEvent} */
chrome.tabCapture.onStatusChanged;
/** @const */
chrome.tabs = {};
/**
 * @record
 * @struct
 */
chrome.tabs.MutedInfo = function() {};
 /** @type {boolean} */
chrome.tabs.MutedInfo.prototype.muted;
 /** @type {string} */
chrome.tabs.MutedInfo.prototype.reason;
 /** @type {string} */
chrome.tabs.MutedInfo.prototype.extensionId;
/**
 * @record
 * @struct
 */
chrome.tabs.Tab = function() {};
 /** @type {string} */
chrome.tabs.Tab.prototype.status;
 /** @type {number} */
chrome.tabs.Tab.prototype.index;
 /** @type {number} */
chrome.tabs.Tab.prototype.openerTabId;
 /** @type {string} */
chrome.tabs.Tab.prototype.title;
 /** @type {string} */
chrome.tabs.Tab.prototype.url;
 /** @type {boolean} */
chrome.tabs.Tab.prototype.pinned;
 /** @type {boolean} */
chrome.tabs.Tab.prototype.highlighted;
 /** @type {number} */
chrome.tabs.Tab.prototype.windowId;
 /** @type {boolean} */
chrome.tabs.Tab.prototype.active;
 /** @type {string} */
chrome.tabs.Tab.prototype.favIconUrl;
 /** @type {number} */
chrome.tabs.Tab.prototype.id;
 /** @type {boolean} */
chrome.tabs.Tab.prototype.incognito;
 /** @type {boolean} */
chrome.tabs.Tab.prototype.selected;
 /** @type {boolean} */
chrome.tabs.Tab.prototype.audible;
 /** @type {!chrome.tabs.MutedInfo} */
chrome.tabs.Tab.prototype.mutedInfo;
 /** @type {number} */
chrome.tabs.Tab.prototype.width;
 /** @type {number} */
chrome.tabs.Tab.prototype.height;
 /** @type {string} */
chrome.tabs.Tab.prototype.sessionId;
/**
 * @record
 * @struct
 */
chrome.tabs.ZoomSettings = function() {};
 /** @type {string} */
chrome.tabs.ZoomSettings.prototype.mode;
 /** @type {string} */
chrome.tabs.ZoomSettings.prototype.scope;
 /** @type {number} */
chrome.tabs.ZoomSettings.prototype.defaultZoomFactor;
/**
 * @record
 * @struct
 */
chrome.tabs.InjectDetails = function() {};
 /** @type {boolean} */
chrome.tabs.InjectDetails.prototype.allFrames;
 /** @type {string} */
chrome.tabs.InjectDetails.prototype.code;
 /** @type {string} */
chrome.tabs.InjectDetails.prototype.runAt;
 /** @type {string} */
chrome.tabs.InjectDetails.prototype.file;
 /** @type {number} */
chrome.tabs.InjectDetails.prototype.frameId;
 /** @type {boolean} */
chrome.tabs.InjectDetails.prototype.matchAboutBlank;
/**
 * @record
 * @struct
 */
chrome.tabs.CreateProperties = function() {};
 /** @type {number} */
chrome.tabs.CreateProperties.prototype.index;
 /** @type {number} */
chrome.tabs.CreateProperties.prototype.openerTabId;
 /** @type {string} */
chrome.tabs.CreateProperties.prototype.url;
 /** @type {boolean} */
chrome.tabs.CreateProperties.prototype.pinned;
 /** @type {number} */
chrome.tabs.CreateProperties.prototype.windowId;
 /** @type {boolean} */
chrome.tabs.CreateProperties.prototype.active;
 /** @type {boolean} */
chrome.tabs.CreateProperties.prototype.selected;
/**
 * @record
 * @struct
 */
chrome.tabs.MoveProperties = function() {};
 /** @type {number} */
chrome.tabs.MoveProperties.prototype.index;
 /** @type {number} */
chrome.tabs.MoveProperties.prototype.windowId;
/**
 * @record
 * @struct
 */
chrome.tabs.UpdateProperties = function() {};
 /** @type {boolean} */
chrome.tabs.UpdateProperties.prototype.pinned;
 /** @type {number} */
chrome.tabs.UpdateProperties.prototype.openerTabId;
 /** @type {string} */
chrome.tabs.UpdateProperties.prototype.url;
 /** @type {boolean} */
chrome.tabs.UpdateProperties.prototype.highlighted;
 /** @type {boolean} */
chrome.tabs.UpdateProperties.prototype.active;
 /** @type {boolean} */
chrome.tabs.UpdateProperties.prototype.selected;
 /** @type {boolean} */
chrome.tabs.UpdateProperties.prototype.muted;
/**
 * @record
 * @struct
 */
chrome.tabs.CaptureVisibleTabOptions = function() {};
 /** @type {number} */
chrome.tabs.CaptureVisibleTabOptions.prototype.quality;
 /** @type {string} */
chrome.tabs.CaptureVisibleTabOptions.prototype.format;
/**
 * @record
 * @struct
 */
chrome.tabs.ReloadProperties = function() {};
 /** @type {boolean} */
chrome.tabs.ReloadProperties.prototype.bypassCache;
/**
 * @record
 * @struct
 */
chrome.tabs.ConnectInfo = function() {};
 /** @type {string} */
chrome.tabs.ConnectInfo.prototype.name;
 /** @type {number} */
chrome.tabs.ConnectInfo.prototype.frameId;
/**
 * @record
 * @struct
 */
chrome.tabs.MessageSendOptions = function() {};
 /** @type {number} */
chrome.tabs.MessageSendOptions.prototype.frameId;
/**
 * @record
 * @struct
 */
chrome.tabs.HighlightInfo = function() {};
 /** @type {(number|!Array<number>)} */
chrome.tabs.HighlightInfo.prototype.tabs;
 /** @type {number} */
chrome.tabs.HighlightInfo.prototype.windowId;
/**
 * @record
 * @struct
 */
chrome.tabs.QueryInfo = function() {};
 /** @type {string} */
chrome.tabs.QueryInfo.prototype.status;
 /** @type {boolean} */
chrome.tabs.QueryInfo.prototype.lastFocusedWindow;
 /** @type {number} */
chrome.tabs.QueryInfo.prototype.windowId;
 /** @type {string} */
chrome.tabs.QueryInfo.prototype.windowType;
 /** @type {boolean} */
chrome.tabs.QueryInfo.prototype.active;
 /** @type {number} */
chrome.tabs.QueryInfo.prototype.index;
 /** @type {string} */
chrome.tabs.QueryInfo.prototype.title;
 /** @type {(string|!Array<string>)} */
chrome.tabs.QueryInfo.prototype.url;
 /** @type {boolean} */
chrome.tabs.QueryInfo.prototype.currentWindow;
 /** @type {boolean} */
chrome.tabs.QueryInfo.prototype.highlighted;
 /** @type {boolean} */
chrome.tabs.QueryInfo.prototype.pinned;
 /** @type {boolean} */
chrome.tabs.QueryInfo.prototype.audible;
 /** @type {boolean} */
chrome.tabs.QueryInfo.prototype.muted;
/**
 * @record
 * @struct
 */
chrome.tabs.TabHighlightInfo = function() {};
 /** @type {number} */
chrome.tabs.TabHighlightInfo.prototype.windowId;
 /** @type {!Array<number>} */
chrome.tabs.TabHighlightInfo.prototype.tabIds;
/**
 * @record
 * @struct
 */
chrome.tabs.TabRemoveInfo = function() {};
 /** @type {number} */
chrome.tabs.TabRemoveInfo.prototype.windowId;
 /** @type {boolean} */
chrome.tabs.TabRemoveInfo.prototype.isWindowClosing;
/**
 * @record
 * @struct
 */
chrome.tabs.TabAttachInfo = function() {};
 /** @type {number} */
chrome.tabs.TabAttachInfo.prototype.newPosition;
 /** @type {number} */
chrome.tabs.TabAttachInfo.prototype.newWindowId;
/**
 * @record
 * @struct
 */
chrome.tabs.TabChangeInfo = function() {};
 /** @type {string} */
chrome.tabs.TabChangeInfo.prototype.status;
 /** @type {boolean} */
chrome.tabs.TabChangeInfo.prototype.pinned;
 /** @type {string} */
chrome.tabs.TabChangeInfo.prototype.url;
 /** @type {boolean} */
chrome.tabs.TabChangeInfo.prototype.audible;
 /** @type {!chrome.tabs.MutedInfo} */
chrome.tabs.TabChangeInfo.prototype.mutedInfo;
 /** @type {string} */
chrome.tabs.TabChangeInfo.prototype.favIconUrl;
 /** @type {string} */
chrome.tabs.TabChangeInfo.prototype.title;
/**
 * @record
 * @struct
 */
chrome.tabs.TabMoveInfo = function() {};
 /** @type {number} */
chrome.tabs.TabMoveInfo.prototype.toIndex;
 /** @type {number} */
chrome.tabs.TabMoveInfo.prototype.windowId;
 /** @type {number} */
chrome.tabs.TabMoveInfo.prototype.fromIndex;
/**
 * @record
 * @struct
 */
chrome.tabs.TabDetachInfo = function() {};
 /** @type {number} */
chrome.tabs.TabDetachInfo.prototype.oldWindowId;
 /** @type {number} */
chrome.tabs.TabDetachInfo.prototype.oldPosition;
/**
 * @record
 * @struct
 */
chrome.tabs.TabActiveInfo = function() {};
 /** @type {number} */
chrome.tabs.TabActiveInfo.prototype.tabId;
 /** @type {number} */
chrome.tabs.TabActiveInfo.prototype.windowId;
/**
 * @record
 * @struct
 */
chrome.tabs.TabWindowInfo = function() {};
 /** @type {number} */
chrome.tabs.TabWindowInfo.prototype.windowId;
/**
 * @record
 * @struct
 */
chrome.tabs.ZoomChangeInfo = function() {};
 /** @type {number} */
chrome.tabs.ZoomChangeInfo.prototype.tabId;
 /** @type {number} */
chrome.tabs.ZoomChangeInfo.prototype.oldZoomFactor;
 /** @type {number} */
chrome.tabs.ZoomChangeInfo.prototype.newZoomFactor;
 /** @type {!chrome.tabs.ZoomSettings} */
chrome.tabs.ZoomChangeInfo.prototype.zoomSettings;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabHighlightedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabRemovedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabUpdatedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabAttachedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabMovedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabDetachedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabCreatedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabActivatedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabReplacedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabSelectedEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.tabs.TabZoomChangeEvent = function() {};

/**
 * Injects JavaScript code into a page. For details, see the programmatic injection section of the content scripts doc.
 * Injects JavaScript code into a page. For details, see the programmatic injection section of the content scripts doc.
 * @param {!chrome.tabs.InjectDetails|number} details_or_tabId Details of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time. / Optional. The ID of the tab in which to run the script; defaults to the active tab of the current window.
 * @param {function(!Array<?>): void|!chrome.tabs.InjectDetails=} callback_or_details Optional. Called after all the JavaScript has been executed.
 * Parameter result: The result of the script in every injected frame. / Details of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.
 * @param {function(!Array<?>): void=} callback Optional. Called after all the JavaScript has been executed.
 * Parameter result: The result of the script in every injected frame.
 * @return {void}
 */
chrome.tabs.executeScript = function(details_or_tabId, callback_or_details, callback) {};

/**
 * Retrieves details about the specified tab.
 * @param {number} tabId
 * @param {function(!chrome.tabs.Tab): void} callback
 * @return {void}
 */
chrome.tabs.get = function(tabId, callback) {};

/**
 * Gets details about all tabs in the specified window.
 * @deprecated since Chrome 33. Please use tabs.query {windowId: windowId}.
 * Gets details about all tabs in the specified window.
 * @param {function(!chrome.tabs.Tab): void|number} callback_or_windowId Optional. Defaults to the current window.
 * @param {function(!chrome.tabs.Tab): void=} callback
 * @return {void}
 */
chrome.tabs.getAllInWindow = function(callback_or_windowId, callback) {};

/**
 * Gets the tab that this script call is being made from. May be undefined if called from a non-tab context (for example: a background page or popup view).
 * @param {function(!chrome.tabs.Tab): void} callback
 * @return {void}
 */
chrome.tabs.getCurrent = function(callback) {};

/**
 * Gets the tab that is selected in the specified window.
 * @deprecated since Chrome 33. Please use tabs.query {active: true}.
 * Gets the tab that is selected in the specified window.
 * @param {function(!chrome.tabs.Tab): void|number} callback_or_windowId Optional. Defaults to the current window.
 * @param {function(!chrome.tabs.Tab): void=} callback
 * @return {void}
 */
chrome.tabs.getSelected = function(callback_or_windowId, callback) {};

/**
 * Creates a new tab.
 * @param {!chrome.tabs.CreateProperties} createProperties
 * @param {function(!chrome.tabs.Tab): void=} callback Optional.
 * Parameter tab: Details about the created tab. Will contain the ID of the new tab.
 * @return {void}
 */
chrome.tabs.create = function(createProperties, callback) {};

/**
 * Moves one or more tabs to a new position within its window, or to a new window. Note that tabs can only be moved to and from normal (window.type === "normal") windows.
 * Moves one or more tabs to a new position within its window, or to a new window. Note that tabs can only be moved to and from normal (window.type === "normal") windows.
 * @param {number|!Array<number>} tabId_or_tabIds The tab to move. / The tabs to move.
 * @param {!chrome.tabs.MoveProperties} moveProperties
 * @param {function(!chrome.tabs.Tab): void|function(!Array<!chrome.tabs.Tab>): void=} callback Optional.
 * Parameter tab: Details about the moved tab. / Optional.
 * Parameter tabs: Details about the moved tabs.
 * @return {void}
 */
chrome.tabs.move = function(tabId_or_tabIds, moveProperties, callback) {};

/**
 * Modifies the properties of a tab. Properties that are not specified in updateProperties are not modified.
 * Modifies the properties of a tab. Properties that are not specified in updateProperties are not modified.
 * @param {!chrome.tabs.UpdateProperties|number} updateProperties_or_tabId Defaults to the selected tab of the current window.
 * @param {function(!chrome.tabs.Tab): void|!chrome.tabs.UpdateProperties=} callback_or_updateProperties Optional.
 * Optional parameter tab: Details about the updated tab. The tabs.Tab object doesn't contain url, title and favIconUrl if the "tabs" permission has not been requested.
 * @param {function(!chrome.tabs.Tab): void=} callback Optional.
 * Optional parameter tab: Details about the updated tab. The tabs.Tab object doesn't contain url, title and favIconUrl if the "tabs" permission has not been requested.
 * @return {void}
 */
chrome.tabs.update = function(updateProperties_or_tabId, callback_or_updateProperties, callback) {};

/**
 * Closes a tab.
 * Closes several tabs.
 * @param {number|!Array<number>} tabId_or_tabIds The tab to close. / The list of tabs to close.
 * @param {!Function=} callback
 * @return {void}
 */
chrome.tabs.remove = function(tabId_or_tabIds, callback) {};

/**
 * Captures the visible area of the currently active tab in the specified window. You must have <all_urls> permission to use this method.
 * Captures the visible area of the currently active tab in the specified window. You must have <all_urls> permission to use this method.
 * Captures the visible area of the currently active tab in the specified window. You must have <all_urls> permission to use this method.
 * Captures the visible area of the currently active tab in the specified window. You must have <all_urls> permission to use this method.
 * @param {function(string): void|number|!chrome.tabs.CaptureVisibleTabOptions} callback_or_windowId_or_options 
 * Parameter dataUrl: A data URL which encodes an image of the visible area of the captured tab. May be assigned to the 'src' property of an HTML Image element for display. / Optional. The target window. Defaults to the current window. / Optional. Details about the format and quality of an image.
 * @param {function(string): void|!chrome.tabs.CaptureVisibleTabOptions=} callback_or_options 
 * Parameter dataUrl: A data URL which encodes an image of the visible area of the captured tab. May be assigned to the 'src' property of an HTML Image element for display. / Optional. Details about the format and quality of an image.
 * @param {function(string): void=} callback 
 * Parameter dataUrl: A data URL which encodes an image of the visible area of the captured tab. May be assigned to the 'src' property of an HTML Image element for display.
 * @return {void}
 */
chrome.tabs.captureVisibleTab = function(callback_or_windowId_or_options, callback_or_options, callback) {};

/**
 * Reload a tab.
 * \@since Chrome 16.
 * Reload the selected tab of the current window.
 * \@since Chrome 16.
 * Reload the selected tab of the current window.
 * \@since Chrome 16.
 * @param {number|!chrome.tabs.ReloadProperties|function(): void=} tabId_or_reloadProperties_or_callback The ID of the tab to reload; defaults to the selected tab of the current window.
 * @param {!chrome.tabs.ReloadProperties|function(): void=} reloadProperties_or_callback
 * @param {function(): void=} callback
 * @return {void}
 */
chrome.tabs.reload = function(tabId_or_reloadProperties_or_callback, reloadProperties_or_callback, callback) {};

/**
 * Duplicates a tab.
 * \@since Chrome 23.
 * @param {number} tabId The ID of the tab which is to be duplicated.
 * @param {function(!chrome.tabs.Tab): void=} callback Optional.
 * Optional parameter tab: Details about the duplicated tab. The tabs.Tab object doesn't contain url, title and favIconUrl if the "tabs" permission has not been requested.
 * @return {void}
 */
chrome.tabs.duplicate = function(tabId, callback) {};

/**
 * Sends a single message to the content script(s) in the specified tab, with an optional callback to run when a response is sent back. The runtime.onMessage event is fired in each content script running in the specified tab for the current extension.
 * \@since Chrome 20.
 * Sends a single message to the content script(s) in the specified tab, with an optional callback to run when a response is sent back. The runtime.onMessage event is fired in each content script running in the specified tab for the current extension.
 * \@since Chrome 41.
 * @param {number} tabId
 * @param {?} message
 * @param {function(?): void|!chrome.tabs.MessageSendOptions=} responseCallback_or_options
 * @param {function(?): void=} responseCallback Optional.
 * Parameter response: The JSON response object sent by the handler of the message. If an error occurs while connecting to the specified tab, the callback will be called with no arguments and runtime.lastError will be set to the error message.
 * @return {void}
 */
chrome.tabs.sendMessage = function(tabId, message, responseCallback_or_options, responseCallback) {};

/**
 * Sends a single request to the content script(s) in the specified tab, with an optional callback to run when a response is sent back. The extension.onRequest event is fired in each content script running in the specified tab for the current extension.
 * @deprecated since Chrome 33. Please use runtime.sendMessage.
 * @param {number} tabId
 * @param {?} request
 * @param {function(?): void=} responseCallback Optional.
 * Parameter response: The JSON response object sent by the handler of the request. If an error occurs while connecting to the specified tab, the callback will be called with no arguments and runtime.lastError will be set to the error message.
 * @return {void}
 */
chrome.tabs.sendRequest = function(tabId, request, responseCallback) {};

/**
 * Connects to the content script(s) in the specified tab. The runtime.onConnect event is fired in each content script running in the specified tab for the current extension.
 * @param {number} tabId
 * @param {!chrome.tabs.ConnectInfo=} connectInfo
 * @return {!chrome.runtime.Port}
 */
chrome.tabs.connect = function(tabId, connectInfo) {};

/**
 * Injects CSS into a page. For details, see the programmatic injection section of the content scripts doc.
 * Injects CSS into a page. For details, see the programmatic injection section of the content scripts doc.
 * @param {!chrome.tabs.InjectDetails|number} details_or_tabId Details of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time. / Optional. The ID of the tab in which to insert the CSS; defaults to the active tab of the current window.
 * @param {!Function|!chrome.tabs.InjectDetails=} callback_or_details Optional. Called when all the CSS has been inserted. / Details of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.
 * @param {!Function=} callback Optional. Called when all the CSS has been inserted.
 * @return {void}
 */
chrome.tabs.insertCSS = function(details_or_tabId, callback_or_details, callback) {};

/**
 * Highlights the given tabs.
 * \@since Chrome 16.
 * @param {!chrome.tabs.HighlightInfo} highlightInfo
 * @param {function(!chrome.windows.Window): void} callback Optional.
 * Parameter window: Contains details about the window whose tabs were highlighted.
 * @return {void}
 */
chrome.tabs.highlight = function(highlightInfo, callback) {};

/**
 * Gets all tabs that have the specified properties, or all tabs if no properties are specified.
 * \@since Chrome 16.
 * @param {!chrome.tabs.QueryInfo} queryInfo
 * @param {function(!Array<!chrome.tabs.Tab>): void} callback
 * @return {void}
 */
chrome.tabs.query = function(queryInfo, callback) {};

/**
 * Detects the primary language of the content in a tab.
 * Detects the primary language of the content in a tab.
 * @param {function(string): void|number} callback_or_tabId 
 * Parameter language: An ISO language code such as en or fr. For a complete list of languages supported by this method, see kLanguageInfoTable. The 2nd to 4th columns will be checked and the first non-NULL value will be returned except for Simplified Chinese for which zh-CN will be returned. For an unknown language, und will be returned. / Optional. Defaults to the active tab of the current window.
 * @param {function(string): void=} callback 
 * Parameter language: An ISO language code such as en or fr. For a complete list of languages supported by this method, see kLanguageInfoTable. The 2nd to 4th columns will be checked and the first non-NULL value will be returned except for Simplified Chinese for which zh-CN will be returned. For an unknown language, und will be returned.
 * @return {void}
 */
chrome.tabs.detectLanguage = function(callback_or_tabId, callback) {};

/**
 * Zooms a specified tab.
 * \@since Chrome 42.
 * Zooms a specified tab.
 * \@since Chrome 42.
 * @param {number} zoomFactor_or_tabId The new zoom factor. Use a value of 0 here to set the tab to its current default zoom factor. Values greater than zero specify a (possibly non-default) zoom factor for the tab. / Optional. The ID of the tab to zoom; defaults to the active tab of the current window.
 * @param {function(): void|number=} callback_or_zoomFactor Optional. Called after the zoom factor has been changed. / The new zoom factor. Use a value of 0 here to set the tab to its current default zoom factor. Values greater than zero specify a (possibly non-default) zoom factor for the tab.
 * @param {function(): void=} callback Optional. Called after the zoom factor has been changed.
 * @return {void}
 */
chrome.tabs.setZoom = function(zoomFactor_or_tabId, callback_or_zoomFactor, callback) {};

/**
 * Gets the current zoom factor of a specified tab.
 * \@since Chrome 42.
 * Gets the current zoom factor of a specified tab.
 * \@since Chrome 42.
 * @param {function(number): void|number} callback_or_tabId Called with the tab's current zoom factor after it has been fetched.
 * Parameter zoomFactor: The tab's current zoom factor. / Optional. The ID of the tab to get the current zoom factor from; defaults to the active tab of the current window.
 * @param {function(number): void=} callback Called with the tab's current zoom factor after it has been fetched.
 * Parameter zoomFactor: The tab's current zoom factor.
 * @return {void}
 */
chrome.tabs.getZoom = function(callback_or_tabId, callback) {};

/**
 * Sets the zoom settings for a specified tab, which define how zoom changes are handled. These settings are reset to defaults upon navigating the tab.
 * \@since Chrome 42.
 * Sets the zoom settings for a specified tab, which define how zoom changes are handled. These settings are reset to defaults upon navigating the tab.
 * \@since Chrome 42.
 * @param {!chrome.tabs.ZoomSettings|number} zoomSettings_or_tabId Defines how zoom changes are handled and at what scope. / Optional. The ID of the tab to change the zoom settings for; defaults to the active tab of the current window.
 * @param {function(): void|!chrome.tabs.ZoomSettings=} callback_or_zoomSettings Optional. Called after the zoom settings have been changed. / Defines how zoom changes are handled and at what scope.
 * @param {function(): void=} callback Optional. Called after the zoom settings have been changed.
 * @return {void}
 */
chrome.tabs.setZoomSettings = function(zoomSettings_or_tabId, callback_or_zoomSettings, callback) {};

/**
 * Gets the current zoom settings of a specified tab.
 * \@since Chrome 42.
 * Gets the current zoom settings of a specified tab.
 * \@since Chrome 42.
 * @param {function(!chrome.tabs.ZoomSettings): void|number} callback_or_tabId Called with the tab's current zoom settings.
 * Paramater zoomSettings: The tab's current zoom settings. / Optional. The ID of the tab to get the current zoom settings from; defaults to the active tab of the current window.
 * @param {function(!chrome.tabs.ZoomSettings): void=} callback Called with the tab's current zoom settings.
 * Paramater zoomSettings: The tab's current zoom settings.
 * @return {void}
 */
chrome.tabs.getZoomSettings = function(callback_or_tabId, callback) {};
 /** @type {!chrome.tabs.TabHighlightedEvent} */
chrome.tabs.onHighlighted;
 /** @type {!chrome.tabs.TabRemovedEvent} */
chrome.tabs.onRemoved;
 /** @type {!chrome.tabs.TabUpdatedEvent} */
chrome.tabs.onUpdated;
 /** @type {!chrome.tabs.TabAttachedEvent} */
chrome.tabs.onAttached;
 /** @type {!chrome.tabs.TabMovedEvent} */
chrome.tabs.onMoved;
 /** @type {!chrome.tabs.TabDetachedEvent} */
chrome.tabs.onDetached;
 /** @type {!chrome.tabs.TabCreatedEvent} */
chrome.tabs.onCreated;
 /** @type {!chrome.tabs.TabActivatedEvent} */
chrome.tabs.onActivated;
 /** @type {!chrome.tabs.TabReplacedEvent} */
chrome.tabs.onReplaced;
 /** @type {!chrome.tabs.TabSelectedEvent} */
chrome.tabs.onSelectionChanged;
 /** @type {!chrome.tabs.TabSelectedEvent} */
chrome.tabs.onActiveChanged;
 /** @type {!chrome.tabs.TabHighlightedEvent} */
chrome.tabs.onHighlightChanged;
 /** @type {!chrome.tabs.TabZoomChangeEvent} */
chrome.tabs.onZoomChange;
 /** @type {number} */
chrome.tabs.TAB_ID_NONE;
/** @const */
chrome.topSites = {};
/**
 * @record
 * @struct
 */
chrome.topSites.MostVisitedURL = function() {};
 /** @type {string} */
chrome.topSites.MostVisitedURL.prototype.url;
 /** @type {string} */
chrome.topSites.MostVisitedURL.prototype.title;

/**
 * Gets a list of top sites.
 * @param {function(!Array<!chrome.topSites.MostVisitedURL>): void} callback
 * @return {void}
 */
chrome.topSites.get = function(callback) {};
/** @const */
chrome.tts = {};
/**
 * @record
 * @struct
 */
chrome.tts.TtsEvent = function() {};
 /** @type {number} */
chrome.tts.TtsEvent.prototype.charIndex;
 /** @type {string} */
chrome.tts.TtsEvent.prototype.errorMessage;
 /** @type {string} */
chrome.tts.TtsEvent.prototype.type;
/**
 * @record
 * @struct
 */
chrome.tts.TtsVoice = function() {};
 /** @type {string} */
chrome.tts.TtsVoice.prototype.lang;
 /** @type {string} */
chrome.tts.TtsVoice.prototype.gender;
 /** @type {string} */
chrome.tts.TtsVoice.prototype.voiceName;
 /** @type {string} */
chrome.tts.TtsVoice.prototype.extensionsId;
 /** @type {!Array<string>} */
chrome.tts.TtsVoice.prototype.eventTypes;
 /** @type {boolean} */
chrome.tts.TtsVoice.prototype.remote;
/**
 * @record
 * @struct
 */
chrome.tts.SpeakOptions = function() {};
 /** @type {number} */
chrome.tts.SpeakOptions.prototype.volume;
 /** @type {boolean} */
chrome.tts.SpeakOptions.prototype.enqueue;
 /** @type {number} */
chrome.tts.SpeakOptions.prototype.rate;
 /** @type {function(!chrome.tts.TtsEvent): void} */
chrome.tts.SpeakOptions.prototype.onEvent;
 /** @type {number} */
chrome.tts.SpeakOptions.prototype.pitch;
 /** @type {string} */
chrome.tts.SpeakOptions.prototype.lang;
 /** @type {string} */
chrome.tts.SpeakOptions.prototype.voiceName;
 /** @type {string} */
chrome.tts.SpeakOptions.prototype.extensionId;
 /** @type {string} */
chrome.tts.SpeakOptions.prototype.gender;
 /** @type {!Array<string>} */
chrome.tts.SpeakOptions.prototype.requiredEventTypes;
 /** @type {!Array<string>} */
chrome.tts.SpeakOptions.prototype.desiredEventTypes;

/**
 * Checks whether the engine is currently speaking. On Mac OS X, the result is true whenever the system speech engine is speaking, even if the speech wasn't initiated by Chrome.
 * @param {function(boolean): void=} callback
 * @return {void}
 */
chrome.tts.isSpeaking = function(callback) {};

/**
 * Stops any current speech and flushes the queue of any pending utterances. In addition, if speech was paused, it will now be un-paused for the next call to speak.
 * @return {void}
 */
chrome.tts.stop = function() {};

/**
 * Gets an array of all available voices.
 * @param {function(!Array<!chrome.tts.TtsVoice>): void=} callback
 * @return {void}
 */
chrome.tts.getVoices = function(callback) {};

/**
 * Speaks text using a text-to-speech engine.
 * Speaks text using a text-to-speech engine.
 * @param {string} utterance The text to speak, either plain text or a complete, well-formed SSML document. Speech engines that do not support SSML will strip away the tags and speak the text. The maximum length of the text is 32,768 characters.
 * @param {!Function|!chrome.tts.SpeakOptions=} callback_or_options Optional. Called right away, before speech finishes. Check chrome.runtime.lastError to make sure there were no errors. Use options.onEvent to get more detailed feedback. / Optional. The speech options.
 * @param {!Function=} callback Optional. Called right away, before speech finishes. Check chrome.runtime.lastError to make sure there were no errors. Use options.onEvent to get more detailed feedback.
 * @return {void}
 */
chrome.tts.speak = function(utterance, callback_or_options, callback) {};

/**
 * Pauses speech synthesis, potentially in the middle of an utterance. A call to resume or stop will un-pause speech.
 * \@since Chrome 29.
 * @return {void}
 */
chrome.tts.pause = function() {};

/**
 * If speech was paused, resumes speaking where it left off.
 * \@since Chrome 29.
 * @return {void}
 */
chrome.tts.resume = function() {};
/** @const */
chrome.ttsEngine = {};
/**
 * @record
 * @struct
 */
chrome.ttsEngine.SpeakOptions = function() {};
 /** @type {string} */
chrome.ttsEngine.SpeakOptions.prototype.lang;
 /** @type {string} */
chrome.ttsEngine.SpeakOptions.prototype.voiceName;
 /** @type {string} */
chrome.ttsEngine.SpeakOptions.prototype.gender;
 /** @type {number} */
chrome.ttsEngine.SpeakOptions.prototype.volume;
 /** @type {number} */
chrome.ttsEngine.SpeakOptions.prototype.rate;
 /** @type {number} */
chrome.ttsEngine.SpeakOptions.prototype.pitch;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.ttsEngine.TtsEngineSpeakEvent = function() {};
 /** @type {!chrome.ttsEngine.TtsEngineSpeakEvent} */
chrome.ttsEngine.onSpeak;
 /** @type {!chrome.events.Event<function(): void>} */
chrome.ttsEngine.onStop;
 /** @type {!chrome.events.Event<function(): void>} */
chrome.ttsEngine.onPause;
 /** @type {!chrome.events.Event<function(): void>} */
chrome.ttsEngine.onResume;
/** @const */
chrome.types = {};
/**
 * @record
 * @struct
 */
chrome.types.ChromeSettingClearDetails = function() {};
 /** @type {string} */
chrome.types.ChromeSettingClearDetails.prototype.scope;
/**
 * @extends {chrome.types.ChromeSettingClearDetails}
 * @record
 * @struct
 */
chrome.types.ChromeSettingSetDetails = function() {};
 /** @type {?} */
chrome.types.ChromeSettingSetDetails.prototype.value;
 /** @type {string} */
chrome.types.ChromeSettingSetDetails.prototype.scope;
/**
 * @record
 * @struct
 */
chrome.types.ChromeSettingGetDetails = function() {};
 /** @type {boolean} */
chrome.types.ChromeSettingGetDetails.prototype.incognito;

/** @typedef {function(!chrome.types.ChromeSettingGetResultDetails): void} */
chrome.types.DetailsCallback;
/**
 * @record
 * @struct
 */
chrome.types.ChromeSettingGetResultDetails = function() {};
 /** @type {string} */
chrome.types.ChromeSettingGetResultDetails.prototype.levelOfControl;
 /** @type {?} */
chrome.types.ChromeSettingGetResultDetails.prototype.value;
 /** @type {boolean} */
chrome.types.ChromeSettingGetResultDetails.prototype.incognitoSpecific;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.types.ChromeSettingChangedEvent = function() {};
/**
 * @record
 * @struct
 */
chrome.types.ChromeSetting = function() {};
 /** @type {!chrome.types.ChromeSettingChangedEvent} */
chrome.types.ChromeSetting.prototype.onChange;

/**
 * Sets the value of a setting.
 * @param {!chrome.types.ChromeSettingSetDetails} details Which setting to change.
 * @param {!Function=} callback Optional. Called at the completion of the set operation.
 * @return {void}
 */
chrome.types.ChromeSetting.prototype.set = function(details, callback) {};

/**
 * Gets the value of a setting.
 * @param {!chrome.types.ChromeSettingGetDetails} details Which setting to consider.
 * @param {function(!chrome.types.ChromeSettingGetResultDetails): void=} callback
 * @return {void}
 */
chrome.types.ChromeSetting.prototype.get = function(details, callback) {};

/**
 * Clears the setting, restoring any default value.
 * @param {!chrome.types.ChromeSettingClearDetails} details Which setting to clear.
 * @param {!Function=} callback Optional. Called at the completion of the clear operation.
 * @return {void}
 */
chrome.types.ChromeSetting.prototype.clear = function(details, callback) {};
/** @const */
chrome.vpnProvider = {};
/**
 * @record
 * @struct
 */
chrome.vpnProvider.VpnSessionParameters = function() {};
 /** @type {string} */
chrome.vpnProvider.VpnSessionParameters.prototype.address;
 /** @type {string} */
chrome.vpnProvider.VpnSessionParameters.prototype.broadcastAddress;
 /** @type {string} */
chrome.vpnProvider.VpnSessionParameters.prototype.mtu;
 /** @type {!Array<string>} */
chrome.vpnProvider.VpnSessionParameters.prototype.exclusionList;
 /** @type {!Array<string>} */
chrome.vpnProvider.VpnSessionParameters.prototype.inclusionList;
 /** @type {!Array<string>} */
chrome.vpnProvider.VpnSessionParameters.prototype.domainSearch;
 /** @type {!Array<string>} */
chrome.vpnProvider.VpnSessionParameters.prototype.dnsServer;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.vpnProvider.VpnPlatformMessageEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.vpnProvider.VpnPacketReceptionEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.vpnProvider.VpnConfigRemovalEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.vpnProvider.VpnConfigCreationEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.vpnProvider.VpnUiEvent = function() {};

/**
 * Creates a new VPN configuration that persists across multiple login sessions of the user.
 * @param {string} name The name of the VPN configuration.
 * @param {function(string): void} callback Called when the configuration is created or if there is an error.
 * Parameter id: A unique ID for the created configuration, empty string on failure.
 * @return {void}
 */
chrome.vpnProvider.createConfig = function(name, callback) {};

/**
 * Destroys a VPN configuration created by the extension.
 * @param {string} id ID of the VPN configuration to destroy.
 * @param {!Function=} callback Optional. Called when the configuration is destroyed or if there is an error.
 * @return {void}
 */
chrome.vpnProvider.destroyConfig = function(id, callback) {};

/**
 * Sets the parameters for the VPN session. This should be called immediately after "connected" is received from the platform. This will succeed only when the VPN session is owned by the extension.
 * @param {!chrome.vpnProvider.VpnSessionParameters} parameters The parameters for the VPN session.
 * @param {!Function} callback Called when the parameters are set or if there is an error.
 * @return {void}
 */
chrome.vpnProvider.setParameters = function(parameters, callback) {};

/**
 * Sends an IP packet through the tunnel created for the VPN session. This will succeed only when the VPN session is owned by the extension.
 * @param {!ArrayBuffer} data The IP packet to be sent to the platform.
 * @param {!Function=} callback Optional. Called when the packet is sent or if there is an error.
 * @return {void}
 */
chrome.vpnProvider.sendPacket = function(data, callback) {};

/**
 * Notifies the VPN session state to the platform. This will succeed only when the VPN session is owned by the extension.
 * @param {string} state The VPN session state of the VPN client.
 * connected: VPN connection was successful.
 * failure: VPN connection failed.
 * @param {!Function=} callback Optional. Called when the notification is complete or if there is an error.
 * @return {void}
 */
chrome.vpnProvider.notifyConnectionStateChanged = function(state, callback) {};
 /** @type {!chrome.vpnProvider.VpnPlatformMessageEvent} */
chrome.vpnProvider.onPlatformMessage;
 /** @type {!chrome.vpnProvider.VpnPacketReceptionEvent} */
chrome.vpnProvider.onPacketReceived;
 /** @type {!chrome.vpnProvider.VpnConfigRemovalEvent} */
chrome.vpnProvider.onConfigRemoved;
 /** @type {!chrome.vpnProvider.VpnConfigCreationEvent} */
chrome.vpnProvider.onConfigCreated;
 /** @type {!chrome.vpnProvider.VpnUiEvent} */
chrome.vpnProvider.onUIEvent;
/** @const */
chrome.wallpaper = {};
/**
 * @record
 * @struct
 */
chrome.wallpaper.WallpaperDetails = function() {};
 /** @type {?} */
chrome.wallpaper.WallpaperDetails.prototype.data;
 /** @type {string} */
chrome.wallpaper.WallpaperDetails.prototype.url;
 /** @type {string} */
chrome.wallpaper.WallpaperDetails.prototype.layout;
 /** @type {string} */
chrome.wallpaper.WallpaperDetails.prototype.filename;
 /** @type {boolean} */
chrome.wallpaper.WallpaperDetails.prototype.thumbnail;

/**
 * Sets wallpaper to the image at url or wallpaperData with the specified layout
 * @param {!chrome.wallpaper.WallpaperDetails} details
 * @param {function(?): void} callback 
 * Optional parameter thumbnail: The jpeg encoded wallpaper thumbnail. It is generated by resizing the wallpaper to 128x60.
 * @return {void}
 */
chrome.wallpaper.setWallpaper = function(details, callback) {};
/** @const */
chrome.webNavigation = {};
/**
 * @record
 * @struct
 */
chrome.webNavigation.GetFrameDetails = function() {};
 /** @type {number} */
chrome.webNavigation.GetFrameDetails.prototype.processId;
 /** @type {number} */
chrome.webNavigation.GetFrameDetails.prototype.tabId;
 /** @type {number} */
chrome.webNavigation.GetFrameDetails.prototype.frameId;
/**
 * @record
 * @struct
 */
chrome.webNavigation.GetFrameResultDetails = function() {};
 /** @type {string} */
chrome.webNavigation.GetFrameResultDetails.prototype.url;
 /** @type {boolean} */
chrome.webNavigation.GetFrameResultDetails.prototype.errorOccurred;
 /** @type {number} */
chrome.webNavigation.GetFrameResultDetails.prototype.parentFrameId;
/**
 * @record
 * @struct
 */
chrome.webNavigation.GetAllFrameDetails = function() {};
 /** @type {number} */
chrome.webNavigation.GetAllFrameDetails.prototype.tabId;
/**
 * @extends {chrome.webNavigation.GetFrameResultDetails}
 * @record
 * @struct
 */
chrome.webNavigation.GetAllFrameResultDetails = function() {};
 /** @type {number} */
chrome.webNavigation.GetAllFrameResultDetails.prototype.processId;
 /** @type {number} */
chrome.webNavigation.GetAllFrameResultDetails.prototype.frameId;
/**
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationCallbackDetails = function() {};
 /** @type {number} */
chrome.webNavigation.WebNavigationCallbackDetails.prototype.tabId;
 /** @type {number} */
chrome.webNavigation.WebNavigationCallbackDetails.prototype.timeStamp;
/**
 * @extends {chrome.webNavigation.WebNavigationCallbackDetails}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationUrlCallbackDetails = function() {};
 /** @type {string} */
chrome.webNavigation.WebNavigationUrlCallbackDetails.prototype.url;
/**
 * @extends {chrome.webNavigation.WebNavigationCallbackDetails}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationReplacementCallbackDetails = function() {};
 /** @type {number} */
chrome.webNavigation.WebNavigationReplacementCallbackDetails.prototype.replacedTabId;
/**
 * @extends {chrome.webNavigation.WebNavigationUrlCallbackDetails}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationFramedCallbackDetails = function() {};
 /** @type {number} */
chrome.webNavigation.WebNavigationFramedCallbackDetails.prototype.frameId;
 /** @type {number} */
chrome.webNavigation.WebNavigationFramedCallbackDetails.prototype.processId;
/**
 * @extends {chrome.webNavigation.WebNavigationFramedCallbackDetails}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationFramedErrorCallbackDetails = function() {};
 /** @type {string} */
chrome.webNavigation.WebNavigationFramedErrorCallbackDetails.prototype.error;
/**
 * @extends {chrome.webNavigation.WebNavigationUrlCallbackDetails}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationSourceCallbackDetails = function() {};
 /** @type {number} */
chrome.webNavigation.WebNavigationSourceCallbackDetails.prototype.sourceTabId;
 /** @type {number} */
chrome.webNavigation.WebNavigationSourceCallbackDetails.prototype.sourceProcessId;
 /** @type {number} */
chrome.webNavigation.WebNavigationSourceCallbackDetails.prototype.sourceFrameId;
/**
 * @extends {chrome.webNavigation.WebNavigationFramedCallbackDetails}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationParentedCallbackDetails = function() {};
 /** @type {number} */
chrome.webNavigation.WebNavigationParentedCallbackDetails.prototype.parentFrameId;
/**
 * @extends {chrome.webNavigation.WebNavigationFramedCallbackDetails}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationTransitionCallbackDetails = function() {};
 /** @type {string} */
chrome.webNavigation.WebNavigationTransitionCallbackDetails.prototype.transitionType;
 /** @type {!Array<string>} */
chrome.webNavigation.WebNavigationTransitionCallbackDetails.prototype.transitionQualifiers;
/**
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationEventFilter = function() {};
 /** @type {!Array<!chrome.events.UrlFilter>} */
chrome.webNavigation.WebNavigationEventFilter.prototype.url;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationEvent = function() {};

/**
 * @param {function(T): void} callback
 * @param {!chrome.webNavigation.WebNavigationEventFilter=} filters
 * @return {void}
 */
chrome.webNavigation.WebNavigationEvent.prototype.addListener = function(callback, filters) {};
/**
 * @extends {chrome.webNavigation.WebNavigationEvent}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationFramedEvent = function() {};
/**
 * @extends {chrome.webNavigation.WebNavigationEvent}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationFramedErrorEvent = function() {};
/**
 * @extends {chrome.webNavigation.WebNavigationEvent}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationSourceEvent = function() {};
/**
 * @extends {chrome.webNavigation.WebNavigationEvent}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationParentedEvent = function() {};
/**
 * @extends {chrome.webNavigation.WebNavigationEvent}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationTransitionalEvent = function() {};
/**
 * @extends {chrome.webNavigation.WebNavigationEvent}
 * @record
 * @struct
 */
chrome.webNavigation.WebNavigationReplacementEvent = function() {};

/**
 * Retrieves information about the given frame. A frame refers to an <iframe> or a <frame> of a web page and is identified by a tab ID and a frame ID.
 * @param {!chrome.webNavigation.GetFrameDetails} details Information about the frame to retrieve information about.
 * @param {function(!chrome.webNavigation.GetFrameResultDetails): void} callback 
 * Optional parameter details: Information about the requested frame, null if the specified frame ID and/or tab ID are invalid.
 * @return {void}
 */
chrome.webNavigation.getFrame = function(details, callback) {};

/**
 * Retrieves information about all frames of a given tab.
 * @param {!chrome.webNavigation.GetAllFrameDetails} details Information about the tab to retrieve all frames from.
 * @param {function(!Array<!chrome.webNavigation.GetAllFrameResultDetails>): void} callback 
 * Optional parameter details: A list of frames in the given tab, null if the specified tab ID is invalid.
 * @return {void}
 */
chrome.webNavigation.getAllFrames = function(details, callback) {};
 /** @type {!chrome.webNavigation.WebNavigationTransitionalEvent} */
chrome.webNavigation.onReferenceFragmentUpdated;
 /** @type {!chrome.webNavigation.WebNavigationFramedEvent} */
chrome.webNavigation.onCompleted;
 /** @type {!chrome.webNavigation.WebNavigationTransitionalEvent} */
chrome.webNavigation.onHistoryStateUpdated;
 /** @type {!chrome.webNavigation.WebNavigationSourceEvent} */
chrome.webNavigation.onCreatedNavigationTarget;
 /** @type {!chrome.webNavigation.WebNavigationReplacementEvent} */
chrome.webNavigation.onTabReplaced;
 /** @type {!chrome.webNavigation.WebNavigationParentedEvent} */
chrome.webNavigation.onBeforeNavigate;
 /** @type {!chrome.webNavigation.WebNavigationTransitionalEvent} */
chrome.webNavigation.onCommitted;
 /** @type {!chrome.webNavigation.WebNavigationFramedEvent} */
chrome.webNavigation.onDOMContentLoaded;
 /** @type {!chrome.webNavigation.WebNavigationFramedErrorEvent} */
chrome.webNavigation.onErrorOccurred;
/** @const */
chrome.webRequest = {};
/**
 * @record
 * @struct
 */
chrome.webRequest.AuthCredentials = function() {};
 /** @type {string} */
chrome.webRequest.AuthCredentials.prototype.username;
 /** @type {string} */
chrome.webRequest.AuthCredentials.prototype.password;
/**
 * @record
 * @struct
 */
chrome.webRequest.HttpHeader = function() {};
 /** @type {string} */
chrome.webRequest.HttpHeader.prototype.name;
 /** @type {string} */
chrome.webRequest.HttpHeader.prototype.value;
 /** @type {!ArrayBuffer} */
chrome.webRequest.HttpHeader.prototype.binaryValue;
/**
 * @record
 * @struct
 */
chrome.webRequest.BlockingResponse = function() {};
 /** @type {boolean} */
chrome.webRequest.BlockingResponse.prototype.cancel;
 /** @type {string} */
chrome.webRequest.BlockingResponse.prototype.redirectUrl;
 /** @type {!Array<!chrome.webRequest.HttpHeader>} */
chrome.webRequest.BlockingResponse.prototype.responseHeaders;
 /** @type {!chrome.webRequest.AuthCredentials} */
chrome.webRequest.BlockingResponse.prototype.authCredentials;
 /** @type {!Array<!chrome.webRequest.HttpHeader>} */
chrome.webRequest.BlockingResponse.prototype.requestHeaders;
/**
 * @record
 * @struct
 */
chrome.webRequest.RequestFilter = function() {};
 /** @type {number} */
chrome.webRequest.RequestFilter.prototype.tabId;
 /** @type {!Array<string>} */
chrome.webRequest.RequestFilter.prototype.types;
 /** @type {!Array<string>} */
chrome.webRequest.RequestFilter.prototype.urls;
 /** @type {number} */
chrome.webRequest.RequestFilter.prototype.windowId;
/**
 * @record
 * @struct
 */
chrome.webRequest.UploadData = function() {};
 /** @type {!ArrayBuffer} */
chrome.webRequest.UploadData.prototype.bytes;
 /** @type {string} */
chrome.webRequest.UploadData.prototype.file;
/**
 * @record
 * @struct
 */
chrome.webRequest.WebRequestBody = function() {};
 /** @type {string} */
chrome.webRequest.WebRequestBody.prototype.error;
 /** @type {!Object<string,!Array<string>>} */
chrome.webRequest.WebRequestBody.prototype.formData;
 /** @type {!Array<!chrome.webRequest.UploadData>} */
chrome.webRequest.WebRequestBody.prototype.raw;
/**
 * @record
 * @struct
 */
chrome.webRequest.WebAuthChallenger = function() {};
 /** @type {string} */
chrome.webRequest.WebAuthChallenger.prototype.host;
 /** @type {number} */
chrome.webRequest.WebAuthChallenger.prototype.port;
/**
 * @record
 * @struct
 */
chrome.webRequest.ResourceRequest = function() {};
 /** @type {string} */
chrome.webRequest.ResourceRequest.prototype.url;
 /** @type {string} */
chrome.webRequest.ResourceRequest.prototype.requestId;
 /** @type {number} */
chrome.webRequest.ResourceRequest.prototype.frameId;
 /** @type {number} */
chrome.webRequest.ResourceRequest.prototype.parentFrameId;
 /** @type {number} */
chrome.webRequest.ResourceRequest.prototype.tabId;
 /** @type {string} */
chrome.webRequest.ResourceRequest.prototype.type;
 /** @type {number} */
chrome.webRequest.ResourceRequest.prototype.timeStamp;
/**
 * @extends {chrome.webRequest.ResourceRequest}
 * @record
 * @struct
 */
chrome.webRequest.WebRequestDetails = function() {};
 /** @type {string} */
chrome.webRequest.WebRequestDetails.prototype.method;
/**
 * @extends {chrome.webRequest.WebRequestDetails}
 * @record
 * @struct
 */
chrome.webRequest.WebRequestHeadersDetails = function() {};
 /** @type {!Array<!chrome.webRequest.HttpHeader>} */
chrome.webRequest.WebRequestHeadersDetails.prototype.requestHeaders;
/**
 * @extends {chrome.webRequest.WebRequestDetails}
 * @record
 * @struct
 */
chrome.webRequest.WebRequestBodyDetails = function() {};
 /** @type {!chrome.webRequest.WebRequestBody} */
chrome.webRequest.WebRequestBodyDetails.prototype.requestBody;
/**
 * @extends {chrome.webRequest.WebRequestHeadersDetails}
 * @extends {chrome.webRequest.WebRequestBodyDetails}
 * @record
 * @struct
 */
chrome.webRequest.WebRequestFullDetails = function() {};
/**
 * @extends {chrome.webRequest.ResourceRequest}
 * @record
 * @struct
 */
chrome.webRequest.WebResponseDetails = function() {};
 /** @type {string} */
chrome.webRequest.WebResponseDetails.prototype.statusLine;
 /** @type {number} */
chrome.webRequest.WebResponseDetails.prototype.statusCode;
/**
 * @extends {chrome.webRequest.WebResponseDetails}
 * @record
 * @struct
 */
chrome.webRequest.WebResponseHeadersDetails = function() {};
 /** @type {!Array<!chrome.webRequest.HttpHeader>} */
chrome.webRequest.WebResponseHeadersDetails.prototype.responseHeaders;
 /** @type {string} */
chrome.webRequest.WebResponseHeadersDetails.prototype.method;
/**
 * @extends {chrome.webRequest.WebResponseHeadersDetails}
 * @record
 * @struct
 */
chrome.webRequest.WebResponseCacheDetails = function() {};
 /** @type {string} */
chrome.webRequest.WebResponseCacheDetails.prototype.ip;
 /** @type {boolean} */
chrome.webRequest.WebResponseCacheDetails.prototype.fromCache;
/**
 * @extends {chrome.webRequest.WebResponseCacheDetails}
 * @record
 * @struct
 */
chrome.webRequest.WebRedirectionResponseDetails = function() {};
 /** @type {string} */
chrome.webRequest.WebRedirectionResponseDetails.prototype.redirectUrl;
/**
 * @extends {chrome.webRequest.WebResponseHeadersDetails}
 * @record
 * @struct
 */
chrome.webRequest.WebAuthenticationChallengeDetails = function() {};
 /** @type {string} */
chrome.webRequest.WebAuthenticationChallengeDetails.prototype.scheme;
 /** @type {string} */
chrome.webRequest.WebAuthenticationChallengeDetails.prototype.realm;
 /** @type {!chrome.webRequest.WebAuthChallenger} */
chrome.webRequest.WebAuthenticationChallengeDetails.prototype.challenger;
 /** @type {boolean} */
chrome.webRequest.WebAuthenticationChallengeDetails.prototype.isProxy;
/**
 * @extends {chrome.webRequest.WebResponseCacheDetails}
 * @record
 * @struct
 */
chrome.webRequest.WebResponseErrorDetails = function() {};
 /** @type {string} */
chrome.webRequest.WebResponseErrorDetails.prototype.error;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.webRequest.WebRequestBodyEvent = function() {};

/**
 * @param {function(!chrome.webRequest.WebRequestBodyDetails): void} callback
 * @param {!chrome.webRequest.RequestFilter=} filter
 * @param {!Array<string>=} opt_extraInfoSpec
 * @return {void}
 */
chrome.webRequest.WebRequestBodyEvent.prototype.addListener = function(callback, filter, opt_extraInfoSpec) {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.webRequest.WebRequestHeadersEvent = function() {};

/**
 * @param {function(!chrome.webRequest.WebRequestHeadersDetails): void} callback
 * @param {!chrome.webRequest.RequestFilter=} filter
 * @param {!Array<string>=} opt_extraInfoSpec
 * @return {void}
 */
chrome.webRequest.WebRequestHeadersEvent.prototype.addListener = function(callback, filter, opt_extraInfoSpec) {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.webRequest._WebResponseHeadersEvent = function() {};

/**
 * @param {function(T): void} callback
 * @param {!chrome.webRequest.RequestFilter=} filter
 * @param {!Array<string>=} opt_extraInfoSpec
 * @return {void}
 */
chrome.webRequest._WebResponseHeadersEvent.prototype.addListener = function(callback, filter, opt_extraInfoSpec) {};
/**
 * @extends {chrome.webRequest._WebResponseHeadersEvent}
 * @record
 * @struct
 */
chrome.webRequest.WebResponseHeadersEvent = function() {};
/**
 * @extends {chrome.webRequest._WebResponseHeadersEvent}
 * @record
 * @struct
 */
chrome.webRequest.WebResponseCacheEvent = function() {};
/**
 * @extends {chrome.webRequest._WebResponseHeadersEvent}
 * @record
 * @struct
 */
chrome.webRequest.WebRedirectionResponseEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.webRequest.WebAuthenticationChallengeEvent = function() {};

/**
 * @param {function(!chrome.webRequest.WebAuthenticationChallengeDetails, function(!chrome.webRequest.BlockingResponse): void): void} callback
 * @param {!chrome.webRequest.RequestFilter=} filter
 * @param {!Array<string>=} opt_extraInfoSpec
 * @return {void}
 */
chrome.webRequest.WebAuthenticationChallengeEvent.prototype.addListener = function(callback, filter, opt_extraInfoSpec) {};
/**
 * @extends {chrome.webRequest._WebResponseHeadersEvent}
 * @record
 * @struct
 */
chrome.webRequest.WebResponseErrorEvent = function() {};
 /** @type {number} */
chrome.webRequest.MAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES;

/**
 * Needs to be called when the behavior of the webRequest handlers has changed to prevent incorrect handling due to caching. This function call is expensive. Don't call it often.
 * @param {!Function=} callback
 * @return {void}
 */
chrome.webRequest.handlerBehaviorChanged = function(callback) {};
 /** @type {!chrome.webRequest.WebRequestBodyEvent} */
chrome.webRequest.onBeforeRequest;
 /** @type {!chrome.webRequest.WebRequestHeadersEvent} */
chrome.webRequest.onBeforeSendHeaders;
 /** @type {!chrome.webRequest.WebRequestHeadersEvent} */
chrome.webRequest.onSendHeaders;
 /** @type {!chrome.webRequest.WebResponseHeadersEvent} */
chrome.webRequest.onHeadersReceived;
 /** @type {!chrome.webRequest.WebAuthenticationChallengeEvent} */
chrome.webRequest.onAuthRequired;
 /** @type {!chrome.webRequest.WebResponseCacheEvent} */
chrome.webRequest.onResponseStarted;
 /** @type {!chrome.webRequest.WebRedirectionResponseEvent} */
chrome.webRequest.onBeforeRedirect;
 /** @type {!chrome.webRequest.WebResponseCacheEvent} */
chrome.webRequest.onCompleted;
 /** @type {!chrome.webRequest.WebResponseErrorEvent} */
chrome.webRequest.onErrorOccurred;
/** @const */
chrome.webstore = {};

/**
 * @param {string|!Function|function(string, string): void=} url_or_successCallback_or_failureCallback Optional. If you have more than one <link> tag on your page with the chrome-webstore-item relation, you can choose which item you'd like to install by passing in its URL here. If it is omitted, then the first (or only) link will be used. An exception will be thrown if the passed in URL does not exist on the page. / Optional. This function is invoked when inline installation successfully completes (after the dialog is shown and the user agrees to add the item to Chrome). You may wish to use this to hide the user interface element that prompted the user to install the app or extension. / Optional. This function is invoked when inline installation does not successfully complete. Possible reasons for this include the user canceling the dialog, the linked item not being found in the store, or the install being initiated from a non-verified site.
 * Parameter error: The failure detail. You may wish to inspect or log this for debugging purposes, but you should not rely on specific strings being passed back.
 * Optional parameter errorCode: The error code from the stable set of possible errors.
 * * Enum of the possible install results, including error codes sent back in the event that an inline installation has failed.
 * * * "otherError": An uncommon, unrecognized, or unexpected error. In some cases, the readable error string can provide more information.
 * * * "aborted": The operation was aborted as the requestor is no longer alive.
 * * * "installInProgress": An installation of the same extension is in progress.
 * * * "notPermitted": The installation is not permitted.
 * * * "invalidId": Invalid Chrome Web Store item ID.
 * * * "webstoreRequestError": Failed to retrieve extension metadata from the Web Store.
 * * * "invalidWebstoreResponse": The extension metadata retrieved from the Web Store was invalid.
 * * * "invalidManifest": An error occurred while parsing the extension manifest retrieved from the Web Store.
 * * * "iconError": Failed to retrieve the extension's icon from the Web Store, or the icon was invalid.
 * * * "userCanceled": The user canceled the operation.
 * * * "blacklisted": The extension is blacklisted.
 * * * "missingDependencies": Unsatisfied dependencies, such as shared modules.
 * * * "requirementViolations": Unsatisfied requirements, such as webgl.
 * * * "blockedByPolicy": The extension is blocked by management policies.
 * * * "launchFeatureDisabled": The launch feature is not available.
 * * * "launchUnsupportedExtensionType": The launch feature is not supported for the extension type.
 * * * "launchInProgress": A launch of the same extension is in progress.
 * @param {!Function|function(string, string): void=} successCallback_or_failureCallback Optional. This function is invoked when inline installation successfully completes (after the dialog is shown and the user agrees to add the item to Chrome). You may wish to use this to hide the user interface element that prompted the user to install the app or extension. / Optional. This function is invoked when inline installation does not successfully complete. Possible reasons for this include the user canceling the dialog, the linked item not being found in the store, or the install being initiated from a non-verified site.
 * Parameter error: The failure detail. You may wish to inspect or log this for debugging purposes, but you should not rely on specific strings being passed back.
 * Optional parameter errorCode: The error code from the stable set of possible errors.
 * * Enum of the possible install results, including error codes sent back in the event that an inline installation has failed.
 * * * "otherError": An uncommon, unrecognized, or unexpected error. In some cases, the readable error string can provide more information.
 * * * "aborted": The operation was aborted as the requestor is no longer alive.
 * * * "installInProgress": An installation of the same extension is in progress.
 * * * "notPermitted": The installation is not permitted.
 * * * "invalidId": Invalid Chrome Web Store item ID.
 * * * "webstoreRequestError": Failed to retrieve extension metadata from the Web Store.
 * * * "invalidWebstoreResponse": The extension metadata retrieved from the Web Store was invalid.
 * * * "invalidManifest": An error occurred while parsing the extension manifest retrieved from the Web Store.
 * * * "iconError": Failed to retrieve the extension's icon from the Web Store, or the icon was invalid.
 * * * "userCanceled": The user canceled the operation.
 * * * "blacklisted": The extension is blacklisted.
 * * * "missingDependencies": Unsatisfied dependencies, such as shared modules.
 * * * "requirementViolations": Unsatisfied requirements, such as webgl.
 * * * "blockedByPolicy": The extension is blocked by management policies.
 * * * "launchFeatureDisabled": The launch feature is not available.
 * * * "launchUnsupportedExtensionType": The launch feature is not supported for the extension type.
 * * * "launchInProgress": A launch of the same extension is in progress.
 * @param {function(string, string): void=} failureCallback Optional. This function is invoked when inline installation does not successfully complete. Possible reasons for this include the user canceling the dialog, the linked item not being found in the store, or the install being initiated from a non-verified site.
 * Parameter error: The failure detail. You may wish to inspect or log this for debugging purposes, but you should not rely on specific strings being passed back.
 * Optional parameter errorCode: The error code from the stable set of possible errors.
 * * Enum of the possible install results, including error codes sent back in the event that an inline installation has failed.
 * * * "otherError": An uncommon, unrecognized, or unexpected error. In some cases, the readable error string can provide more information.
 * * * "aborted": The operation was aborted as the requestor is no longer alive.
 * * * "installInProgress": An installation of the same extension is in progress.
 * * * "notPermitted": The installation is not permitted.
 * * * "invalidId": Invalid Chrome Web Store item ID.
 * * * "webstoreRequestError": Failed to retrieve extension metadata from the Web Store.
 * * * "invalidWebstoreResponse": The extension metadata retrieved from the Web Store was invalid.
 * * * "invalidManifest": An error occurred while parsing the extension manifest retrieved from the Web Store.
 * * * "iconError": Failed to retrieve the extension's icon from the Web Store, or the icon was invalid.
 * * * "userCanceled": The user canceled the operation.
 * * * "blacklisted": The extension is blacklisted.
 * * * "missingDependencies": Unsatisfied dependencies, such as shared modules.
 * * * "requirementViolations": Unsatisfied requirements, such as webgl.
 * * * "blockedByPolicy": The extension is blocked by management policies.
 * * * "launchFeatureDisabled": The launch feature is not available.
 * * * "launchUnsupportedExtensionType": The launch feature is not supported for the extension type.
 * * * "launchInProgress": A launch of the same extension is in progress.
 * @return {void}
 */
chrome.webstore.install = function(url_or_successCallback_or_failureCallback, successCallback_or_failureCallback, failureCallback) {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.webstore.InstallationStageEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.webstore.DownloadProgressEvent = function() {};
 /** @type {!chrome.webstore.InstallationStageEvent} */
chrome.webstore.onInstallStageChanged;
 /** @type {!chrome.webstore.DownloadProgressEvent} */
chrome.webstore.onDownloadProgress;
/** @const */
chrome.windows = {};
/**
 * @record
 * @struct
 */
chrome.windows.Window = function() {};
 /** @type {!Array<!chrome.tabs.Tab>} */
chrome.windows.Window.prototype.tabs;
 /** @type {number} */
chrome.windows.Window.prototype.top;
 /** @type {number} */
chrome.windows.Window.prototype.height;
 /** @type {number} */
chrome.windows.Window.prototype.width;
 /** @type {string} */
chrome.windows.Window.prototype.state;
 /** @type {boolean} */
chrome.windows.Window.prototype.focused;
 /** @type {boolean} */
chrome.windows.Window.prototype.alwaysOnTop;
 /** @type {boolean} */
chrome.windows.Window.prototype.incognito;
 /** @type {string} */
chrome.windows.Window.prototype.type;
 /** @type {number} */
chrome.windows.Window.prototype.id;
 /** @type {number} */
chrome.windows.Window.prototype.left;
 /** @type {string} */
chrome.windows.Window.prototype.sessionId;
/**
 * @record
 * @struct
 */
chrome.windows.GetInfo = function() {};
 /** @type {boolean} */
chrome.windows.GetInfo.prototype.populate;
 /** @type {!Array<string>} */
chrome.windows.GetInfo.prototype.windowTypes;
/**
 * @record
 * @struct
 */
chrome.windows.CreateData = function() {};
 /** @type {number} */
chrome.windows.CreateData.prototype.tabId;
 /** @type {(string|!Array<string>)} */
chrome.windows.CreateData.prototype.url;
 /** @type {number} */
chrome.windows.CreateData.prototype.top;
 /** @type {number} */
chrome.windows.CreateData.prototype.height;
 /** @type {number} */
chrome.windows.CreateData.prototype.width;
 /** @type {boolean} */
chrome.windows.CreateData.prototype.focused;
 /** @type {boolean} */
chrome.windows.CreateData.prototype.incognito;
 /** @type {string} */
chrome.windows.CreateData.prototype.type;
 /** @type {number} */
chrome.windows.CreateData.prototype.left;
 /** @type {string} */
chrome.windows.CreateData.prototype.state;
/**
 * @record
 * @struct
 */
chrome.windows.UpdateInfo = function() {};
 /** @type {number} */
chrome.windows.UpdateInfo.prototype.top;
 /** @type {boolean} */
chrome.windows.UpdateInfo.prototype.drawAttention;
 /** @type {number} */
chrome.windows.UpdateInfo.prototype.height;
 /** @type {number} */
chrome.windows.UpdateInfo.prototype.width;
 /** @type {string} */
chrome.windows.UpdateInfo.prototype.state;
 /** @type {boolean} */
chrome.windows.UpdateInfo.prototype.focused;
 /** @type {number} */
chrome.windows.UpdateInfo.prototype.left;
/**
 * @record
 * @struct
 */
chrome.windows.WindowEventFilter = function() {};
 /** @type {!Array<string>} */
chrome.windows.WindowEventFilter.prototype.windowTypes;
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.windows.WindowIdEvent = function() {};
/**
 * @extends {chrome.events.Event}
 * @record
 * @struct
 */
chrome.windows.WindowReferenceEvent = function() {};
 /** @type {number} */
chrome.windows.WINDOW_ID_CURRENT;
 /** @type {number} */
chrome.windows.WINDOW_ID_NONE;

/**
 * Gets details about a window.
 * Gets details about a window.
 * \@since Chrome 18.
 * @param {number} windowId
 * @param {function(!chrome.windows.Window): void|!chrome.windows.GetInfo} callback_or_getInfo
 * @param {function(!chrome.windows.Window): void=} callback
 * @return {void}
 */
chrome.windows.get = function(windowId, callback_or_getInfo, callback) {};

/**
 * Gets the current window.
 * Gets the current window.
 * \@since Chrome 18.
 * @param {function(!chrome.windows.Window): void|!chrome.windows.GetInfo} callback_or_getInfo
 * @param {function(!chrome.windows.Window): void=} callback
 * @return {void}
 */
chrome.windows.getCurrent = function(callback_or_getInfo, callback) {};

/**
 * Creates (opens) a new browser with any optional sizing, position or default URL provided.
 * Creates (opens) a new browser with any optional sizing, position or default URL provided.
 * @param {function(!chrome.windows.Window): void|!chrome.windows.CreateData=} callback_or_createData 
 * Optional parameter window: Contains details about the created window.
 * @param {function(!chrome.windows.Window): void=} callback 
 * Optional parameter window: Contains details about the created window.
 * @return {void}
 */
chrome.windows.create = function(callback_or_createData, callback) {};

/**
 * Gets all windows.
 * Gets all windows.
 * \@since Chrome 18.
 * @param {function(!Array<!chrome.windows.Window>): void|!chrome.windows.GetInfo} callback_or_getInfo
 * @param {function(!Array<!chrome.windows.Window>): void=} callback
 * @return {void}
 */
chrome.windows.getAll = function(callback_or_getInfo, callback) {};

/**
 * Updates the properties of a window. Specify only the properties that you want to change; unspecified properties will be left unchanged.
 * @param {number} windowId
 * @param {!chrome.windows.UpdateInfo} updateInfo
 * @param {function(!chrome.windows.Window): void=} callback
 * @return {void}
 */
chrome.windows.update = function(windowId, updateInfo, callback) {};

/**
 * Removes (closes) a window, and all the tabs inside it.
 * @param {number} windowId
 * @param {!Function=} callback
 * @return {void}
 */
chrome.windows.remove = function(windowId, callback) {};

/**
 * Gets the window that was most recently focused  typically the window 'on top'.
 * Gets the window that was most recently focused  typically the window 'on top'.
 * \@since Chrome 18.
 * @param {function(!chrome.windows.Window): void|!chrome.windows.GetInfo} callback_or_getInfo
 * @param {function(!chrome.windows.Window): void=} callback
 * @return {void}
 */
chrome.windows.getLastFocused = function(callback_or_getInfo, callback) {};
 /** @type {!chrome.windows.WindowIdEvent} */
chrome.windows.onRemoved;
 /** @type {!chrome.windows.WindowReferenceEvent} */
chrome.windows.onCreated;
 /** @type {!chrome.windows.WindowIdEvent} */
chrome.windows.onFocusChanged;
