/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/signals/index.d.ts:
 /** @type {!signals.SignalWrapper} */
var signals;

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
/**
 * @record
 * @struct
 */
signals.SignalWrapper = function() {};
 /** @type {!signals.Signal} */
signals.SignalWrapper.prototype.Signal;
/**
 * @record
 * @struct
 */
signals.SignalBinding = function() {};
 /** @type {boolean} */
signals.SignalBinding.prototype.active;
 /** @type {?} */
signals.SignalBinding.prototype.context;
 /** @type {?} */
signals.SignalBinding.prototype.params;

/**
 * @return {!Function}
 */
signals.SignalBinding.prototype.detach = function() {};

/**
 * @param {!Array<?>=} paramsArr
 * @return {?}
 */
signals.SignalBinding.prototype.execute = function(paramsArr) {};

/**
 * @return {!Function}
 */
signals.SignalBinding.prototype.getListener = function() {};

/**
 * @return {!signals.Signal}
 */
signals.SignalBinding.prototype.getSignal = function() {};

/**
 * @return {boolean}
 */
signals.SignalBinding.prototype.isBound = function() {};

/**
 * @return {boolean}
 */
signals.SignalBinding.prototype.isOnce = function() {};
/**
 * @record
 * @struct
 */
signals.Signal = function() {};

/* TODO: ConstructSignature: signals */
 /** @type {boolean} */
signals.Signal.prototype.active;
 /** @type {boolean} */
signals.Signal.prototype.memorize;
 /** @type {string} */
signals.Signal.prototype.VERSION;

/**
 * Add a listener to the signal.
 * 
 * @param {!Function} listener Signal handler function.
 * @param {?=} listenerContext
 * @param {!Number=} priority The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
 * @return {!signals.SignalBinding}
 */
signals.Signal.prototype.add = function(listener, listenerContext, priority) {};

/**
 * Add listener to the signal that should be removed after first execution (will be executed only once).
 * 
 * @param {!Function} listener Signal handler function.
 * @param {?=} listenerContext
 * @param {!Number=} priority The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
 * @return {!signals.SignalBinding}
 */
signals.Signal.prototype.addOnce = function(listener, listenerContext, priority) {};

/**
 * Dispatch/Broadcast Signal to all listeners added to the queue.
 * 
 * @param {...?} params Parameters that should be passed to each handler.
 * @return {void}
 */
signals.Signal.prototype.dispatch = function(params) {};

/**
 * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
 * @return {void}
 */
signals.Signal.prototype.dispose = function() {};

/**
 * Forget memorized arguments.
 * @return {void}
 */
signals.Signal.prototype.forget = function() {};

/**
 * Returns a number of listeners attached to the Signal.
 * @return {number}
 */
signals.Signal.prototype.getNumListeners = function() {};

/**
 * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
 * @return {void}
 */
signals.Signal.prototype.halt = function() {};

/**
 * Check if listener was attached to Signal.
 * @param {!Function} listener
 * @param {?=} context
 * @return {boolean}
 */
signals.Signal.prototype.has = function(listener, context) {};

/**
 * Remove a single listener from the dispatch queue.
 * @param {!Function} listener
 * @param {?=} context
 * @return {!Function}
 */
signals.Signal.prototype.remove = function(listener, context) {};

/**
 * @return {void}
 */
signals.Signal.prototype.removeAll = function() {};
