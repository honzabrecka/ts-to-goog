/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/forge-di/index.d.ts:
/**
 * @constructor
 * @struct
 */
function Forge() {}
 /** @type {!Forge.IBindingMap} */
Forge.prototype.bindings;

/**
 * Creates a new instance
 * @return {!Forge}
 */
Forge.prototype.new = function() {};

/**
 * Creates a new binding.
 * @param {string} name
 * @return {!Forge.IBinding}
 */
Forge.prototype.bind = function(name) {};

/**
 * Unbinds then recreates a binding for this name.
 * @param {string} name
 * @return {!Forge.IBinding}
 */
Forge.prototype.rebind = function(name) {};

/**
 * Unbinds all bindings for this name. Returns the number of bindings removed.
 * @param {string} name
 * @return {number}
 */
Forge.prototype.unbind = function(name) {};

/**
 * Get instance or instances of type registered under the provided name and optional hint.
 * @template T
 * @param {string} name
 * @param {string=} hint
 * @param {...?} args
 * @return {T}
 */
Forge.prototype.get = function(name, hint, args) {};

/**
 * Get a single instance of type registered under the provided name and optional hint.
 * @template T
 * @param {string} name
 * @param {string=} hint
 * @param {...?} args
 * @return {T}
 */
Forge.prototype.getOne = function(name, hint, args) {};

/**
 * Gets all instances of the type registered under the provided name.
 * @template T
 * @param {string} name
 * @param {...?} args
 * @return {(T|!Array<T>)}
 */
Forge.prototype.getAll = function(name, args) {};

/**
 * Creates an instance of the target type attempting to resolve any dependencies.
 * @template T
 * @param {T} target
 * @param {...?} args
 * @return {T}
 */
Forge.prototype.create = function(target, args) {};

/**
 * Get all bindings registered under a binding name and optional hint.
 * @param {string} name
 * @param {string=} hint
 * @return {!Array<!Forge.IBinding>}
 */
Forge.prototype.getMatchingBindings = function(name, hint) {};

/**
 * Returns a string that represents all bindings within this forge instance.
 * @return {string}
 */
Forge.prototype.inspect = function() {};

/**
 * @template T
 * @param {string} name
 * @param {!Forge.IContext=} context
 * @param {string=} hint
 * @param {boolean=} all
 * @param {...?} args
 * @return {(T|!Array<T>)}
 */
Forge.prototype.resolve = function(name, context, hint, all, args) {};

/**
 * @param {!Forge.IContext} context
 * @param {!Array<!Forge.IBinding>} bindings
 * @param {string} hint
 * @param {!Array<?>} args
 * @param {boolean} unwrap
 * @return {!Array<!Forge.IBinding>}
 */
Forge.prototype.resolveBindings = function(context, bindings, hint, args, unwrap) {};
/**
 * @record
 * @struct
 */
Forge.IContext = function() {};

/* TODO: ConstructSignature: Forge */
 /** @type {!Array<!Forge.IBinding>} */
Forge.IContext.prototype.bindings;

/**
 * @param {!Forge.IBinding} binding
 * @return {boolean}
 */
Forge.IContext.prototype.has = function(binding) {};

/**
 * @param {!Forge.IBinding} binding
 * @return {void}
 */
Forge.IContext.prototype.push = function(binding) {};

/**
 * @return {!Forge.IBinding}
 */
Forge.IContext.prototype.pop = function() {};

/**
 * @param {number} indent
 * @return {string}
 */
Forge.IContext.prototype.toString = function(indent) {};
/**
 * @record
 * @struct
 */
Forge.IType = function() {};

/* TODO: ConstructSignature: Forge */
/**
 * @record
 * @struct
 */
Forge.IBindingArguments = function() {};

/* TODO: IndexSignature: Forge */
/**
 * @record
 * @struct
 */
Forge.IBinding = function() {};
 /** @type {!Forge} */
Forge.IBinding.prototype.forge;
 /** @type {string} */
Forge.IBinding.prototype.name;
 /** @type {!Forge.IBinding} */
Forge.IBinding.prototype.to;
 /** @type {!Forge.IBinding} */
Forge.IBinding.prototype.as;
 /** @type {boolean} */
Forge.IBinding.prototype.isResolving;
 /** @type {!Forge.IResolver} */
Forge.IBinding.prototype.resolver;
 /** @type {!Forge.ILifecycle} */
Forge.IBinding.prototype.lifecycle;
 /** @type {!Forge.IPredicate} */
Forge.IBinding.prototype.predicate;
 /** @type {!Forge.IBindingArguments} */
Forge.IBinding.prototype.arguments;

/**
 * Checks whether or not this binding matches the hint by executing the predicate.
 * @param {string} hint
 * @return {boolean}
 */
Forge.IBinding.prototype.matches = function(hint) {};

/**
 * Registers a type to a binding. This type must have a constructor.
 * @template T
 * @param {T} target
 * @return {!Forge.IBinding}
 */
Forge.IBinding.prototype.type = function(target) {};

/**
 * Registers a type to a binding. This must be a callable function.
 * @template T
 * @param {T} target
 * @return {!Forge.IBinding}
 */
Forge.IBinding.prototype.function = function(target) {};

/**
 * Registeres an instance to a binding. This instance will always be returned.
 * @template T
 * @param {T} target
 * @return {!Forge.IBinding}
 */
Forge.IBinding.prototype.instance = function(target) {};

/**
 * Configures this binding lifecycle as a singleton. This is the default lifecycle.
 * @return {!Forge.IBinding}
 */
Forge.IBinding.prototype.singleton = function() {};

/**
 * Configures this binding lifecycle as transient.
 * New instances will be created, if this is a type based binding, on each get.
 * @return {!Forge.IBinding}
 */
Forge.IBinding.prototype.transient = function() {};

/**
 * Registers a predicate for this binding.
 * Registers a hint for this binding.
 * @param {!Forge.IPredicate|string} predicate_or_hint
 * @return {!Forge.IBinding}
 */
Forge.IBinding.prototype.when = function(predicate_or_hint) {};

/**
 * Registers additional binding arguments to help with resolving.
 * @param {!Forge.IBindingArguments} args
 * @return {!Forge.IBinding}
 */
Forge.IBinding.prototype.with = function(args) {};

/**
 * Returns a string representing this binding.
 * @return {string}
 */
Forge.IBinding.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
Forge.IBindingMap = function() {};

/* TODO: IndexSignature: Forge */
/**
 * @record
 * @struct
 */
Forge.IPredicate = function() {};

/* TODO: CallSignature: Forge */
/**
 * @record
 * @struct
 */
Forge.IResolver = function() {};

/**
 * Resolves a specific type.
 * @template T
 * @return {T}
 */
Forge.IResolver.prototype.resolve = function() {};
/**
 * @record
 * @struct
 */
Forge.ILifecycle = function() {};

/**
 * Returns the instance from a resolver based on the configured lifecycle.
 * @template T
 * @param {!Forge.IResolver} resolver
 * @return {T}
 */
Forge.ILifecycle.prototype.getInstance = function(resolver) {};

/* TODO: ExportAssignment in  */
