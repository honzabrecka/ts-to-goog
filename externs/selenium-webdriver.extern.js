/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/selenium-webdriver/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */
/** @const */
var error = {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.IError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.WebDriverError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.ElementNotSelectableError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.ElementNotVisibleError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.InvalidArgumentError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.InvalidCookieDomainError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.InvalidElementCoordinatesError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.InvalidElementStateError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.InvalidSelectorError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.NoSuchSessionError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.JavascriptError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.MoveTargetOutOfBoundsError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.NoSuchAlertError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.NoSuchElementError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.NoSuchFrameError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.NoSuchWindowError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.ScriptTimeoutError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.SessionNotCreatedError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.StaleElementReferenceError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.TimeoutError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.UnableToSetCookieError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.UnableToCaptureScreenError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 * @param {string=} opt_text
 */
error.UnexpectedAlertOpenError = function(opt_error, opt_text) {};

/**
 *     if available.
 * @return {string}
 */
error.UnexpectedAlertOpenError.prototype.getAlertText = function() {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.UnknownCommandError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.UnknownMethodError = function(opt_error) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_error
 */
error.UnsupportedOperationError = function(opt_error) {};
/** @const */
var logging = {};
/**
 * @constructor
 * @struct
 */
logging.Preferences = function() {};

/**
 * @param {string} type
 * @param {(string|number|?)} level
 * @return {void}
 */
logging.Preferences.prototype.setLevel = function(type, level) {};

/**
 * @return {?}
 */
logging.Preferences.prototype.toJSON = function() {};
/**
 * @record
 * @struct
 */
logging.IType = function() {};
 /** @type {string} */
logging.IType.prototype.BROWSER;
 /** @type {string} */
logging.IType.prototype.CLIENT;
 /** @type {string} */
logging.IType.prototype.DRIVER;
 /** @type {string} */
logging.IType.prototype.PERFORMANCE;
 /** @type {string} */
logging.IType.prototype.SERVER;
 /** @type {?} */
logging.Type;

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {number} level
 */
logging.Level = function(name, level) {};
 /** @type {string} */
logging.Level.prototype.name_;
 /** @type {number} */
logging.Level.prototype.value_;
 /** @type {string} */
logging.Level.prototype.name;
 /** @type {number} */
logging.Level.prototype.value;
 /** @type {?} */
logging.Level.OFF;
 /** @type {?} */
logging.Level.SEVERE;
 /** @type {?} */
logging.Level.WARNING;
 /** @type {?} */
logging.Level.INFO;
 /** @type {?} */
logging.Level.DEBUG;
 /** @type {?} */
logging.Level.FINE;
 /** @type {?} */
logging.Level.FINER;
 /** @type {?} */
logging.Level.FINEST;
 /** @type {?} */
logging.Level.ALL;

/**
 * @override
 * @return {string}
 */
logging.Level.prototype.toString = function() {};

/**
 * Converts a level name or value to a {\@link logging.Level} value.
 * If the name/value is not recognized, {\@link logging.Level.ALL}
 * will be returned.
 *     convert .
 * @param {(string|number)} nameOrValue
 * @return {?}
 */
logging.getLevel = function(nameOrValue) {};
/**
 * @record
 * @struct
 */
logging.IEntryJSON = function() {};
 /** @type {string} */
logging.IEntryJSON.prototype.level;
 /** @type {string} */
logging.IEntryJSON.prototype.message;
 /** @type {number} */
logging.IEntryJSON.prototype.timestamp;
 /** @type {string} */
logging.IEntryJSON.prototype.type;

/**
 * @constructor
 * @struct
 *     milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the
 *     current time will be used.
 * @param {(string|number|?)} level
 * @param {string} message
 * @param {number=} opt_timestamp
 * @param {(string|?)=} opt_type
 */
logging.Entry = function(level, message, opt_timestamp, opt_type) {};
 /** @type {?} */
logging.Entry.prototype.level;
 /** @type {string} */
logging.Entry.prototype.message;
 /** @type {number} */
logging.Entry.prototype.timestamp;
 /** @type {string} */
logging.Entry.prototype.type;

/**
 *           type: string}} The JSON representation of this entry.
 * @return {?}
 */
logging.Entry.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {?=} opt_level
 */
logging.Logger = function(name, opt_level) {};
 /** @type {string} */
logging.Logger.prototype.name_;
 /** @type {?} */
logging.Logger.prototype.level_;
 /** @type {?} */
logging.Logger.prototype.parent_;
 /** @type {?} */
logging.Logger.prototype.handlers_;

/**
 * @return {string}
 */
logging.Logger.prototype.getName = function() {};

/**
 *     should inherit its level from its parent logger.
 * @param {?} level
 * @return {void}
 */
logging.Logger.prototype.setLevel = function(level) {};

/**
 * @return {?}
 */
logging.Logger.prototype.getLevel = function() {};

/**
 * @return {?}
 */
logging.Logger.prototype.getEffectiveLevel = function() {};

/**
 *     by this instance.
 * @param {?} level
 * @return {boolean}
 */
logging.Logger.prototype.isLoggable = function(level) {};

/**
 * Adds a handler to this logger. The handler will be invoked for each message
 * logged with this instance, or any of its descendants.
 * 
 * @param {?} handler
 * @return {void}
 */
logging.Logger.prototype.addHandler = function(handler) {};

/**
 * Removes a handler from this logger.
 * 
 * @param {?} handler
 * @return {void}
 */
logging.Logger.prototype.removeHandler = function(handler) {};

/**
 * Logs a message at the given level. The message may be defined as a string
 * or as a function that will return the message. If a function is provided,
 * it will only be invoked if this logger's
 * {\@linkplain #getEffectiveLevel() effective log level} includes the given
 * `level`.
 * 
 *     function that will return the message.
 * @param {?} level
 * @param {(string|!Function)} loggable
 * @return {void}
 */
logging.Logger.prototype.log = function(level, loggable) {};

/**
 * Logs a message at the {\@link Level.SEVERE} log level.
 *     function that will return the message.
 * @param {(string|!Function)} loggable
 * @return {void}
 */
logging.Logger.prototype.severe = function(loggable) {};

/**
 * Logs a message at the {\@link Level.WARNING} log level.
 *     function that will return the message.
 * @param {(string|!Function)} loggable
 * @return {void}
 */
logging.Logger.prototype.warning = function(loggable) {};

/**
 * Logs a message at the {\@link Level.INFO} log level.
 *     function that will return the message.
 * @param {(string|!Function)} loggable
 * @return {void}
 */
logging.Logger.prototype.info = function(loggable) {};

/**
 * Logs a message at the {\@link Level.DEBUG} log level.
 *     function that will return the message.
 * @param {(string|!Function)} loggable
 * @return {void}
 */
logging.Logger.prototype.debug = function(loggable) {};

/**
 * Logs a message at the {\@link Level.FINE} log level.
 *     function that will return the message.
 * @param {(string|!Function)} loggable
 * @return {void}
 */
logging.Logger.prototype.fine = function(loggable) {};

/**
 * Logs a message at the {\@link Level.FINER} log level.
 *     function that will return the message.
 * @param {(string|!Function)} loggable
 * @return {void}
 */
logging.Logger.prototype.finer = function(loggable) {};

/**
 * Logs a message at the {\@link Level.FINEST} log level.
 *     function that will return the message.
 * @param {(string|!Function)} loggable
 * @return {void}
 */
logging.Logger.prototype.finest = function(loggable) {};
/**
 * @constructor
 * @struct
 */
logging.LogManager = function() {};

/**
 * Retrieves a named logger, creating it in the process. This function will
 * implicitly create the requested logger, and any of its parents, if they
 * do not yet exist.
 * 
 * @param {string} name
 * @return {?}
 */
logging.LogManager.prototype.getLogger = function(name) {};

/**
 * Creates a new logger.
 * 
 * @param {string} name
 * @param {?} parent
 * @return {?}
 */
logging.LogManager.prototype.createLogger_ = function(name, parent) {};
/** @const */
var promise = {};
 /** @type {boolean} */
promise.USE_PROMISE_MANAGER;

/**
 * Given an array of promises, will return a promise that will be fulfilled
 * with the fulfillment values of the input array's values. If any of the
 * input array's promises are rejected, the returned promise will be rejected
 * with the same reason.
 * 
 *     promises to wait on.
 *     fulfilled with an array containing the fulfilled values of the
 *     input array, or rejected with the same reason as the first
 *     rejected value.
 * @template T
 * @param {!Array<?>} arr
 * @return {?}
 */
promise.all = function(arr) {};

/**
 * Invokes the appropriate callback function as soon as a promised
 * {\@code value} is resolved. This function is similar to
 * {\@link promise.when}, except it does not return a new promise.
 *     resolved successfully.
 *     rejected.
 * @param {?} value
 * @param {!Function} callback
 * @param {!Function=} opt_errback
 * @return {void}
 */
promise.asap = function(value, callback, opt_errback) {};

/**
 * @return {?}
 */
promise.controlFlow = function() {};

/**
 * Creates a new control flow. The provided callback will be invoked as the
 * first task within the new flow, with the flow as its sole argument. Returns
 * a promise that resolves to the callback result.
 *     to the newly created flow.
 *     result.
 * @template R
 * @param {?} callback
 * @return {?}
 */
promise.createFlow = function(callback) {};

/**
 * Determines whether a {\@code value} should be treated as a promise.
 * Any object whose 'then' property is a function will be considered a promise.
 * 
 * @param {?} value
 * @return {boolean}
 */
promise.isPromise = function(value) {};

/**
 * Tests is a function is a generator.
 * @param {!Function} fn
 * @return {boolean}
 */
promise.isGenerator = function(fn) {};

/**
 * Creates a promise that will be resolved at a set time in the future.
 *     resolving the promise.
 * @param {number} ms
 * @return {?}
 */
promise.delayed = function(ms) {};

/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 * 
 * If the return value of the filter function is a promise, this function
 * will wait for it to be fulfilled before determining whether to insert the
 * element into the new array.
 * 
 * If the filter function throws or returns a rejected promise, the promise
 * returned by this function will be rejected with the same reason. Only the
 * first failure will be reported; all subsequent errors will be silently
 * ignored.
 * 
 *     array to iterator over, or a promise that will resolve to said array.
 *             boolean|ManagedPromise<boolean>)} fn The function
 *     to call for each element in the array.
 *     {\@code fn}.
 * @template T
 * @param {(!Array<?>|?)} arr
 * @param {?} fn
 * @param {?=} opt_self
 * @return {?}
 */
promise.filter = function(arr, fn, opt_self) {};

/**
 * Creates a new deferred object.
 * @template T
 * @return {?}
 */
promise.defer = function() {};

/**
 * Creates a promise that has been resolved with the given value.
 * @deprecated Use {\@link Promise#resolve Promise.resolve(value)}.
 * @template T
 * @param {?=} opt_value
 * @return {?}
 */
promise.fulfilled = function(opt_value) {};

/**
 * Calls a function for each element in an array and inserts the result into a
 * new array, which is used as the fulfillment value of the promise returned
 * by this function.
 * 
 * If the return value of the mapping function is a promise, this function
 * will wait for it to be fulfilled before inserting it into the new array.
 * 
 * If the mapping function throws or returns a rejected promise, the
 * promise returned by this function will be rejected with the same reason.
 * Only the first failure will be reported; all subsequent errors will be
 * silently ignored.
 * 
 *     array to iterator over, or a promise that will resolve to said array.
 *     function to call for each element in the array. This function should
 *     expect three arguments (the element, the index, and the array itself.
 *     {\@code fn}.
 * @template T
 * @param {(!Array<?>|?)} arr
 * @param {?} fn
 * @param {?=} opt_self
 * @return {?}
 */
promise.map = function(arr, fn, opt_self) {};

/**
 * Creates a promise that has been rejected with the given reason.
 *     usually an Error or a string.
 * @deprecated Use {\@link Promise#reject Promise.Promise(reason)}.
 * @template T
 * @param {?=} opt_reason
 * @return {?}
 */
promise.rejected = function(opt_reason) {};

/**
 * Wraps a function that expects a node-style callback as its final
 * argument. This callback expects two arguments: an error value (which will be
 * null if the call succeeded), and the success value as the second argument.
 * The callback will the resolve or reject the returned promise, based on its
 * arguments.
 *     final callback.
 *     result of the provided function's callback.
 * @template T
 * @param {!Function} fn
 * @param {...?} var_args
 * @return {?}
 */
promise.checkedNodeCall = function(fn, var_args) {};

/**
 * Consumes a {\@code GeneratorFunction}. Each time the generator yields a
 * promise, this function will wait for it to be fulfilled before feeding the
 * fulfilled value back into {\@code next}. Likewise, if a yielded promise is
 * rejected, the rejection error will be passed to {\@code throw}.
 * 
 * __Example 1:__ the Fibonacci Sequence.
 * 
 *     promise.consume(function* fibonacci() {
 *       var n1 = 1, n2 = 1;
 *       for (var i = 0; i < 4; ++i) {
 *         var tmp = yield n1 + n2;
 *         n1 = n2;
 *         n2 = tmp;
 *       }
 *       return n1 + n2;
 *     }).then(function(result) {
 *       console.log(result);  // 13
 *     });
 * 
 * __Example 2:__ a generator that throws.
 * 
 *     promise.consume(function* () {
 *       yield promise.delayed(250).then(function() {
 *         throw Error('boom');
 *       });
 *     }).catch(function(e) {
 *       console.log(e.toString());  // Error: boom
 *     });
 * 
 *     initial generator.
 *     generator's final result.
 * @throws {TypeError} If the given function is not a generator.
 * @template T
 * @param {!Function} generatorFn
 * @param {?=} opt_self
 * @param {...?} var_args
 * @return {?}
 */
promise.consume = function(generatorFn, opt_self, var_args) {};

/**
 * Registers an observer on a promised {\@code value}, returning a new promise
 * that will be resolved when the value is. If {\@code value} is not a promise,
 * then the return promise will be immediately resolved.
 *     resolved successfully.
 *     rejected.
 * @template T
 * @param {?} value
 * @param {?=} opt_callback
 * @param {?=} opt_errback
 * @return {?}
 */
promise.when = function(value, opt_callback, opt_errback) {};

/**
 * Returns a promise that will be resolved with the input value in a
 * fully-resolved state. If the value is an array, each element will be fully
 * resolved. Likewise, if the value is an object, all keys will be fully
 * resolved. In both cases, all nested arrays and objects will also be
 * fully resolved.  All fields are resolved in place; the returned promise will
 * resolve on {\@code value} and not a copy.
 * 
 * Warning: This function makes no checks against objects that contain
 * cyclical references:
 * 
 *     var value = {};
 *     value['self'] = value;
 *     promise.fullyResolved(value);  // Stack overflow.
 * 
 *     of the input value.
 * @template T
 * @param {?} value
 * @return {?}
 */
promise.fullyResolved = function(value) {};

/**
 * Changes the default flow to use when no others are active.
 * @throws {Error} If the default flow is not currently active.
 * @param {?} flow
 * @return {void}
 */
promise.setDefaultFlow = function(flow) {};

/**
 * @constructor
 * @struct
 * @param {string=} opt_msg
 */
promise.CancellationError = function(opt_msg) {};
/**
 * @record
 * @struct
 */
promise.IThenable = function() {};

/**
 * Registers listeners for when this instance is resolved.
 * 
 *     function to call if this promise is successfully resolved. The function
 *     should expect a single argument: the promise's resolved value.
 *     The function to call if this promise is rejected. The function should
 *     expect a single argument: the rejection reason.
 *     resolved with the result of the invoked callback.
 * @template R
 * @param {?=} opt_callback
 * @param {?=} opt_errback
 * @return {?}
 */
promise.IThenable.prototype.then = function(opt_callback, opt_errback) {};

/**
 * Registers a listener for when this promise is rejected. This is synonymous
 * with the {\@code catch} clause in a synchronous API:
 * 
 *     // Synchronous API:
 *     try {
 *       doSynchronousWork();
 *     } catch (ex) {
 *       console.error(ex);
 *     }
 * 
 *     // Asynchronous promise API:
 *     doAsynchronousWork().catch(function(ex) {
 *       console.error(ex);
 *     });
 * 
 *     function to call if this promise is rejected. The function should
 *     expect a single argument: the rejection reason.
 *     resolved with the result of the invoked callback.
 * @template R
 * @param {!Function} errback
 * @return {?}
 */
promise.IThenable.prototype.catch = function(errback) {};
/**
 * @implements {promise.IThenable}
 * @constructor
 * @struct
 */
promise.Thenable = function() {};

/**
 * Registers listeners for when this instance is resolved.
 * 
 *     function to call if this promise is successfully resolved. The function
 *     should expect a single argument: the promise's resolved value.
 *     The function to call if this promise is rejected. The function should
 *     expect a single argument: the rejection reason.
 *     resolved with the result of the invoked callback.
 * @template R
 * @param {?=} opt_callback
 * @param {?=} opt_errback
 * @return {?}
 */
promise.Thenable.prototype.then = function(opt_callback, opt_errback) {};

/**
 * Registers a listener for when this promise is rejected. This is synonymous
 * with the {\@code catch} clause in a synchronous API:
 * 
 *     // Synchronous API:
 *     try {
 *       doSynchronousWork();
 *     } catch (ex) {
 *       console.error(ex);
 *     }
 * 
 *     // Asynchronous promise API:
 *     doAsynchronousWork().catch(function(ex) {
 *       console.error(ex);
 *     });
 * 
 *     function to call if this promise is rejected. The function should
 *     expect a single argument: the rejection reason.
 *     resolved with the result of the invoked callback.
 * @template R
 * @param {!Function} errback
 * @return {?}
 */
promise.Thenable.prototype.catch = function(errback) {};

/**
 * Registers a listener to invoke when this promise is resolved, regardless
 * of whether the promise's value was successfully computed. This function
 * is synonymous with the {\@code finally} clause in a synchronous API:
 * 
 *     // Synchronous API:
 *     try {
 *       doSynchronousWork();
 *     } finally {
 *       cleanUp();
 *     }
 * 
 *     // Asynchronous promise API:
 *     doAsynchronousWork().finally(cleanUp);
 * 
 * __Note:__ similar to the {\@code finally} clause, if the registered
 * callback returns a rejected promise or throws an error, it will silently
 * replace the rejection error (if any) from this promise:
 * 
 *     try {
 *       throw Error('one');
 *     } finally {
 *       throw Error('two');  // Hides Error: one
 *     }
 * 
 *     promise.rejected(Error('one'))
 *         .finally(function() {
 *           throw Error('two');  // Hides Error: one
 *         });
 * 
 *     this promise is resolved.
 *     with the callback result.
 * @template R
 * @param {!Function} callback
 * @return {?}
 */
promise.Thenable.prototype.finally = function(callback) {};

/**
 * Adds a property to a class prototype to allow runtime checks of whether
 * instances of that class implement the Thenable interface. This function
 * will also ensure the prototype's {\@code then} function is exported from
 * compiled code.
 *     constructor whose prototype to modify.
 * @param {!Function} ctor
 * @return {void}
 */
promise.Thenable.addImplementation = function(ctor) {};

/**
 * Checks if an object has been tagged for implementing the Thenable
 * interface as defined by {\@link Thenable.addImplementation}.
 *     interface.
 * @param {?} object
 * @return {boolean}
 */
promise.Thenable.isImplementation = function(object) {};
/**
 * @record
 * @struct
 */
promise.IFulfilledCallback = function() {};

/* TODO: CallSignature: promise */
/**
 * @record
 * @struct
 */
promise.IRejectedCallback = function() {};

/* TODO: CallSignature: promise */

/**
 * @constructor
 * @struct
 *           function((T|IThenable<T>|Thenable)=),
 *           function(*=))} resolver
 *     Function that is invoked immediately to begin computation of this
 *     promise's value. The function should accept a pair of callback
 *     functions, one for fulfilling the promise and another for rejecting it.
 *     this instance was created under. Defaults to the currently active flow.
 * @param {?} resolver
 * @param {?=} opt_flow
 */
promise.Promise = function(resolver, opt_flow) {};

/**
 * Creates a promise that is immediately resolved with the given value.
 * 
 * @template T
 * @param {?=} opt_value
 * @return {?}
 */
promise.Promise.resolve = function(opt_value) {};

/**
 * Creates a promise that is immediately rejected with the given reason.
 * 
 * @param {?=} opt_reason
 * @return {?}
 */
promise.Promise.reject = function(opt_reason) {};

/**
 * Registers listeners for when this instance is resolved.
 * 
 *     function to call if this promise is successfully resolved. The function
 *     should expect a single argument: the promise's resolved value.
 *     The function to call if this promise is rejected. The function should
 *     expect a single argument: the rejection reason.
 *     of the invoked callback.
 * @template R
 * @param {?=} opt_callback
 * @param {?=} opt_errback
 * @return {?}
 */
promise.Promise.prototype.then = function(opt_callback, opt_errback) {};

/**
 * Registers a listener for when this promise is rejected. This is synonymous
 * with the {\@code catch} clause in a synchronous API:
 * 
 *     // Synchronous API:
 *     try {
 *       doSynchronousWork();
 *     } catch (ex) {
 *       console.error(ex);
 *     }
 * 
 *     // Asynchronous promise API:
 *     doAsynchronousWork().catch(function(ex) {
 *       console.error(ex);
 *     });
 * 
 *     function to call if this promise is rejected. The function should
 *     expect a single argument: the rejection reason.
 *     resolved with the result of the invoked callback.
 * @template R
 * @param {?} errback
 * @return {?}
 */
promise.Promise.prototype.catch = function(errback) {};

/**
 * @constructor
 * @struct
 * 
 *     this instance was created under. This should only be provided during
 *     unit tests.
 * @param {?=} opt_flow
 */
promise.Deferred = function(opt_flow) {};
 /** @type {?} */
promise.Deferred.State_;
 /** @type {?} */
promise.Deferred.prototype.promise;

/**
 * Rejects this promise. If the error is itself a promise, this instance will
 * be chained to it and be rejected with the error's resolved value.
 *     {\@code Error} or a {\@code string}.
 * @param {?=} opt_error
 * @return {void}
 */
promise.Deferred.prototype.reject = function(opt_error) {};

/**
 * @param {?=} opt_error
 * @return {void}
 */
promise.Deferred.prototype.errback = function(opt_error) {};

/**
 * Resolves this promise with the given value. If the value is itself a
 * promise and not a reference to this deferred, this instance will wait for
 * it before resolving.
 * @param {?=} opt_value
 * @return {void}
 */
promise.Deferred.prototype.fulfill = function(opt_value) {};

/**
 * Removes all of the listeners previously registered on this deferred.
 * @throws {Error} If this deferred has already been resolved.
 * @return {void}
 */
promise.Deferred.prototype.removeAll = function() {};
/**
 * @record
 * @struct
 */
promise.IControlFlowTimer = function() {};

/**
 * @param {number} ms
 * @return {void}
 */
promise.IControlFlowTimer.prototype.clearInterval = function(ms) {};

/**
 * @param {number} ms
 * @return {void}
 */
promise.IControlFlowTimer.prototype.clearTimeout = function(ms) {};

/**
 * @param {!Function} fn
 * @param {number} ms
 * @return {number}
 */
promise.IControlFlowTimer.prototype.setInterval = function(fn, ms) {};

/**
 * @param {!Function} fn
 * @param {number} ms
 * @return {number}
 */
promise.IControlFlowTimer.prototype.setTimeout = function(fn, ms) {};
/**
 * @record
 * @struct
 */
promise.IEventType = function() {};
 /** @type {string} */
promise.IEventType.prototype.IDLE;
 /** @type {string} */
promise.IEventType.prototype.RESET;
 /** @type {string} */
promise.IEventType.prototype.SCHEDULE_TASK;
 /** @type {string} */
promise.IEventType.prototype.UNCAUGHT_EXCEPTION;

/**
 * @constructor
 * @struct
 */
promise.ControlFlow = function() {};
 /** @type {?} */
promise.ControlFlow.EventType;

/**
 * Returns a string representation of this control flow, which is its current
 * {\@link #getSchedule() schedule}, sans task stack traces.
 * @override
 * @return {string}
 */
promise.ControlFlow.prototype.toString = function() {};

/**
 * Resets this instance, clearing its queue and removing all event listeners.
 * @return {void}
 */
promise.ControlFlow.prototype.reset = function() {};

/**
 * Generates an annotated string describing the internal state of this control
 * flow, including the currently executing as well as pending tasks. If
 * {\@code opt_includeStackTraces === true}, the string will include the
 * stack trace from when each task was scheduled.
 *     from when each task was scheduled. Defaults to false.
 * @param {boolean=} opt_includeStackTraces
 * @return {string}
 */
promise.ControlFlow.prototype.getSchedule = function(opt_includeStackTraces) {};

/**
 * Schedules a task for execution. If there is nothing currently in the
 * queue, the task will be executed in the next turn of the event loop. If
 * the task function is a generator, the task will be executed using
 * {\@link promise.consume}.
 * 
 *     call to start the task. If the function returns a
 *     {\@link promise.Promise}, this instance will wait for it to be
 *     resolved before starting the next task.
 *     with the result of the action.
 * @template T
 * @param {?} fn
 * @param {string=} opt_description
 * @return {?}
 */
promise.ControlFlow.prototype.execute = function(fn, opt_description) {};

/**
 * Inserts a {\@code setTimeout} into the command queue. This is equivalent to
 * a thread sleep in a synchronous programming language.
 * 
 *     the result of the action.
 * @param {number} ms
 * @param {string=} opt_description
 * @return {?}
 */
promise.ControlFlow.prototype.timeout = function(ms, opt_description) {};

/**
 * Schedules a task that shall wait for a condition to hold. Each condition
 * function may return any value, but it will always be evaluated as a boolean.
 * 
 * Condition functions may schedule sub-tasks with this instance, however,
 * their execution time will be factored into whether a wait has timed out.
 * 
 * In the event a condition returns a Promise, the polling loop will wait for
 * it to be resolved before evaluating whether the condition has been satisfied.
 * The resolution time for a promise is factored into whether a wait has timed
 * out.
 * 
 * If the condition function throws, or returns a rejected promise, the
 * wait task will fail.
 * 
 * If the condition is defined as a promise, the flow will wait for it to
 * settle. If the timeout expires before the promise settles, the promise
 * returned by this function will be rejected.
 * 
 * If this function is invoked with `timeout === 0`, or the timeout is omitted,
 * the flow will wait indefinitely for the condition to be satisfied.
 * 
 *     or a promise to wait on.
 *     condition to hold before timing out. If omitted, the flow will wait
 *     indefinitely.
 *     wait times out; defaults to the empty string.
 *     when the condition has been satisified. The promise shall be rejected if
 *     the wait times out waiting for the condition.
 * @throws {TypeError} If condition is not a function or promise or if timeout
 *     is not a number >= 0.
 * @template T
 * @param {(!Function|?)} condition
 * @param {number=} opt_timeout
 * @param {string=} opt_message
 * @return {?}
 */
promise.ControlFlow.prototype.wait = function(condition, opt_timeout, opt_message) {};

/**
 * @constructor
 * @struct
 *     sentence 'Waiting [...]'
 *     evaluate on each iteration of the wait loop.
 * @param {string} message
 * @param {?} fn
 */
function Condition(message, fn) {}

/**
 * @return {string}
 */
Condition.prototype.description = function() {};

/**
 * @param {?} webdriver
 * @return {?}
 */
Condition.prototype.fn = function(webdriver) {};
/**
 * @constructor
 * @struct
 */
function WebElementCondition() {}
 /** @type {undefined} */
WebElementCondition.prototype._nominal;
/** @const */
var until = {};

/**
 * Creates a condition that will wait until the input driver is able to switch
 * to the designated frame. The target frame may be specified as
 * 
 * 1. a numeric index into
 *     [window.frames](https://developer.mozilla.org/en-US/docs/Web/API/Window.frames)
 *     for the currently selected frame.
 * 2. a {\@link ./WebElement}, which must reference a FRAME or IFRAME
 *     element on the current page.
 * 3. a locator which may be used to first locate a FRAME or IFRAME on the
 *     current page before attempting to switch to it.
 * 
 * Upon successful resolution of this condition, the driver will be left
 * focused on the new frame.
 * 
 *           function(!./WebDriver): !./WebElement)} frame
 *     The frame identifier.
 * @param {(number|?)} frame
 * @return {?}
 */
until.ableToSwitchToFrame = function(frame) {};

/**
 * Creates a condition that waits for an alert to be opened. Upon success, the
 * returned promise will be fulfilled with the handle for the opened alert.
 * 
 * @return {?}
 */
until.alertIsPresent = function() {};

/**
 * Creates a condition that will wait for the given element to be disabled.
 * 
 * @see WebDriver#isEnabled
 * @param {?} element
 * @return {?}
 */
until.elementIsDisabled = function(element) {};

/**
 * Creates a condition that will wait for the given element to be enabled.
 * 
 * @see WebDriver#isEnabled
 * @param {?} element
 * @return {?}
 */
until.elementIsEnabled = function(element) {};

/**
 * Creates a condition that will wait for the given element to be deselected.
 * 
 * @see WebDriver#isSelected
 * @param {?} element
 * @return {?}
 */
until.elementIsNotSelected = function(element) {};

/**
 * Creates a condition that will wait for the given element to be in the DOM,
 * yet not visible to the user.
 * 
 * @see WebDriver#isDisplayed
 * @param {?} element
 * @return {?}
 */
until.elementIsNotVisible = function(element) {};

/**
 * Creates a condition that will wait for the given element to be selected.
 * @see WebDriver#isSelected
 * @param {?} element
 * @return {?}
 */
until.elementIsSelected = function(element) {};

/**
 * Creates a condition that will wait for the given element to become visible.
 * 
 * @see WebDriver#isDisplayed
 * @param {?} element
 * @return {?}
 */
until.elementIsVisible = function(element) {};

/**
 * Creates a condition that will loop until an element is
 * {\@link ./WebDriver#findElement found} with the given locator.
 * 
 * @param {(!Function|?)} locator
 * @return {?}
 */
until.elementLocated = function(locator) {};

/**
 * Creates a condition that will wait for the given element's
 * {\@link WebDriver#getText visible text} to contain the given
 * substring.
 * 
 * @see WebDriver#getText
 * @param {?} element
 * @param {string} substr
 * @return {?}
 */
until.elementTextContains = function(element, substr) {};

/**
 * Creates a condition that will wait for the given element's
 * {\@link WebDriver#getText visible text} to match the given
 * {\@code text} exactly.
 * 
 * @see WebDriver#getText
 * @param {?} element
 * @param {string} text
 * @return {?}
 */
until.elementTextIs = function(element, text) {};

/**
 * Creates a condition that will wait for the given element's
 * {\@link WebDriver#getText visible text} to match a regular
 * expression.
 * 
 * @see WebDriver#getText
 * @param {?} element
 * @param {!RegExp} regex
 * @return {?}
 */
until.elementTextMatches = function(element, regex) {};

/**
 * Creates a condition that will loop until at least one element is
 * {\@link WebDriver#findElement found} with the given locator.
 * 
 *     to use.
 *     condition.
 * @param {(!Function|?)} locator
 * @return {?}
 */
until.elementsLocated = function(locator) {};

/**
 * Creates a condition that will wait for the given element to become stale. An
 * element is considered stale once it is removed from the DOM, or a new page
 * has loaded.
 * 
 * @param {?} element
 * @return {?}
 */
until.stalenessOf = function(element) {};

/**
 * Creates a condition that will wait for the current page's title to contain
 * the given substring.
 * 
 *     title.
 * @param {string} substr
 * @return {?}
 */
until.titleContains = function(substr) {};

/**
 * Creates a condition that will wait for the current page's title to match the
 * given value.
 * 
 * @param {string} title
 * @return {?}
 */
until.titleIs = function(title) {};

/**
 * Creates a condition that will wait for the current page's title to match the
 * given regular expression.
 * 
 * @param {!RegExp} regex
 * @return {?}
 */
until.titleMatches = function(regex) {};

/**
 * Creates a condition that will wait for the current page's url to contain
 * the given substring.
 * 
 *     URL.
 * @param {string} substrUrl
 * @return {?}
 */
until.urlContains = function(substrUrl) {};

/**
 * Creates a condition that will wait for the current page's url to match the
 * given value.
 * 
 * @param {string} url
 * @return {?}
 */
until.urlIs = function(url) {};

/**
 * Creates a condition that will wait for the current page's url to match the
 * given regular expression.
 * 
 * @param {!RegExp} regex
 * @return {?}
 */
until.urlMatches = function(regex) {};
/**
 * @record
 * @struct
 */
function ILocation() {}
 /** @type {number} */
ILocation.prototype.x;
 /** @type {number} */
ILocation.prototype.y;
/**
 * @record
 * @struct
 */
function ISize() {}
 /** @type {number} */
ISize.prototype.width;
 /** @type {number} */
ISize.prototype.height;
/**
 * @record
 * @struct
 */
function IButton() {}
 /** @type {string} */
IButton.prototype.LEFT;
 /** @type {string} */
IButton.prototype.MIDDLE;
 /** @type {string} */
IButton.prototype.RIGHT;
 /** @type {?} */
var Button;
/**
 * @record
 * @struct
 */
function IKey() {}
 /** @type {string} */
IKey.prototype.NULL;
 /** @type {string} */
IKey.prototype.CANCEL;
 /** @type {string} */
IKey.prototype.HELP;
 /** @type {string} */
IKey.prototype.BACK_SPACE;
 /** @type {string} */
IKey.prototype.TAB;
 /** @type {string} */
IKey.prototype.CLEAR;
 /** @type {string} */
IKey.prototype.RETURN;
 /** @type {string} */
IKey.prototype.ENTER;
 /** @type {string} */
IKey.prototype.SHIFT;
 /** @type {string} */
IKey.prototype.CONTROL;
 /** @type {string} */
IKey.prototype.ALT;
 /** @type {string} */
IKey.prototype.PAUSE;
 /** @type {string} */
IKey.prototype.ESCAPE;
 /** @type {string} */
IKey.prototype.SPACE;
 /** @type {string} */
IKey.prototype.PAGE_UP;
 /** @type {string} */
IKey.prototype.PAGE_DOWN;
 /** @type {string} */
IKey.prototype.END;
 /** @type {string} */
IKey.prototype.HOME;
 /** @type {string} */
IKey.prototype.ARROW_LEFT;
 /** @type {string} */
IKey.prototype.LEFT;
 /** @type {string} */
IKey.prototype.ARROW_UP;
 /** @type {string} */
IKey.prototype.UP;
 /** @type {string} */
IKey.prototype.ARROW_RIGHT;
 /** @type {string} */
IKey.prototype.RIGHT;
 /** @type {string} */
IKey.prototype.ARROW_DOWN;
 /** @type {string} */
IKey.prototype.DOWN;
 /** @type {string} */
IKey.prototype.INSERT;
 /** @type {string} */
IKey.prototype.DELETE;
 /** @type {string} */
IKey.prototype.SEMICOLON;
 /** @type {string} */
IKey.prototype.EQUALS;
 /** @type {string} */
IKey.prototype.NUMPAD0;
 /** @type {string} */
IKey.prototype.NUMPAD1;
 /** @type {string} */
IKey.prototype.NUMPAD2;
 /** @type {string} */
IKey.prototype.NUMPAD3;
 /** @type {string} */
IKey.prototype.NUMPAD4;
 /** @type {string} */
IKey.prototype.NUMPAD5;
 /** @type {string} */
IKey.prototype.NUMPAD6;
 /** @type {string} */
IKey.prototype.NUMPAD7;
 /** @type {string} */
IKey.prototype.NUMPAD8;
 /** @type {string} */
IKey.prototype.NUMPAD9;
 /** @type {string} */
IKey.prototype.MULTIPLY;
 /** @type {string} */
IKey.prototype.ADD;
 /** @type {string} */
IKey.prototype.SEPARATOR;
 /** @type {string} */
IKey.prototype.SUBTRACT;
 /** @type {string} */
IKey.prototype.DECIMAL;
 /** @type {string} */
IKey.prototype.DIVIDE;
 /** @type {string} */
IKey.prototype.F1;
 /** @type {string} */
IKey.prototype.F2;
 /** @type {string} */
IKey.prototype.F3;
 /** @type {string} */
IKey.prototype.F4;
 /** @type {string} */
IKey.prototype.F5;
 /** @type {string} */
IKey.prototype.F6;
 /** @type {string} */
IKey.prototype.F7;
 /** @type {string} */
IKey.prototype.F8;
 /** @type {string} */
IKey.prototype.F9;
 /** @type {string} */
IKey.prototype.F10;
 /** @type {string} */
IKey.prototype.F11;
 /** @type {string} */
IKey.prototype.F12;
 /** @type {string} */
IKey.prototype.COMMAND;
 /** @type {string} */
IKey.prototype.META;

/**
 * Simulate pressing many keys at once in a 'chord'. Takes a sequence of
 * keys or strings, appends each of the values to a string,
 * and adds the chord termination key ({\@link Key.NULL}) and returns
 * the resulting string.
 * 
 * Note: when the low-level webdriver key handlers see Keys.NULL, active
 * modifier keys (CTRL/ALT/SHIFT/etc) release via a keyup event.
 * 
 * @param {...(string|?)} var_args
 * @return {string}
 */
IKey.prototype.chord = function(var_args) {};
 /** @type {?} */
var Key;

/**
 * @constructor
 * @struct
 * @param {?} driver
 */
function ActionSequence(driver) {}

/**
 * Executes this action sequence.
 *     this sequence has completed.
 * @return {?}
 */
ActionSequence.prototype.perform = function() {};

/**
 * Moves the mouse.  The location to move to may be specified in terms of the
 * mouse's current location, an offset relative to the top-left corner of an
 * element, or an element (in which case the middle of the element is used).
 * 
 *     location to drag to, as either another WebElement or an offset in
 *     pixels.
 *     is defined as a {\@link ./WebElement}, this parameter defines
 *     an offset within that element. The offset should be specified in pixels
 *     relative to the top-left corner of the element's bounding box. If
 *     omitted, the element's center will be used as the target offset.
 * @param {?} location
 * @param {?=} opt_offset
 * @return {?}
 */
ActionSequence.prototype.mouseMove = function(location, opt_offset) {};

/**
 * Presses a mouse button. The mouse button will not be released until
 * {\@link #mouseUp} is called, regardless of whether that call is made in this
 * sequence or another. The behavior for out-of-order events (e.g. mouseDown,
 * click) is undefined.
 * 
 * If an element is provided, the mouse will first be moved to the center
 * of that element. This is equivalent to:
 * 
 *     sequence.mouseMove(element).mouseDown()
 * 
 * Warning: this method currently only supports the left mouse button. See
 * [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).
 * 
 *     the element to interact with or the button to click with.
 *     Defaults to {\@link input.Button.LEFT} if neither an element nor
 *     button is specified.
 *     {\@link input.Button.LEFT}. Ignored if a button is provided as the
 *     first argument.
 * @param {(string|?)=} opt_elementOrButton
 * @param {string=} opt_button
 * @return {?}
 */
ActionSequence.prototype.mouseDown = function(opt_elementOrButton, opt_button) {};

/**
 * Releases a mouse button. Behavior is undefined for calling this function
 * without a previous call to {\@link #mouseDown}.
 * 
 * If an element is provided, the mouse will first be moved to the center
 * of that element. This is equivalent to:
 * 
 *     sequence.mouseMove(element).mouseUp()
 * 
 * Warning: this method currently only supports the left mouse button. See
 * [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).
 * 
 *     the element to interact with or the button to click with.
 *     Defaults to {\@link input.Button.LEFT} if neither an element nor
 *     button is specified.
 *     {\@link input.Button.LEFT}. Ignored if a button is provided as the
 *     first argument.
 * @param {(string|?)=} opt_elementOrButton
 * @param {string=} opt_button
 * @return {?}
 */
ActionSequence.prototype.mouseUp = function(opt_elementOrButton, opt_button) {};

/**
 * Convenience function for performing a 'drag and drop' manuever. The target
 * element may be moved to the location of another element, or by an offset (in
 * pixels).
 * 
 *     location to drag to, either as another WebElement or an offset in
 *     pixels.
 * @param {?} element
 * @param {?} location
 * @return {?}
 */
ActionSequence.prototype.dragAndDrop = function(element, location) {};

/**
 * Clicks a mouse button.
 * 
 * If an element is provided, the mouse will first be moved to the center
 * of that element. This is equivalent to:
 * 
 *     sequence.mouseMove(element).click()
 * 
 *     the element to interact with or the button to click with.
 *     Defaults to {\@link input.Button.LEFT} if neither an element nor
 *     button is specified.
 *     {\@link input.Button.LEFT}. Ignored if a button is provided as the
 *     first argument.
 * @param {(string|?)=} opt_elementOrButton
 * @param {string=} opt_button
 * @return {?}
 */
ActionSequence.prototype.click = function(opt_elementOrButton, opt_button) {};

/**
 * Double-clicks a mouse button.
 * 
 * If an element is provided, the mouse will first be moved to the center of
 * that element. This is equivalent to:
 * 
 *     sequence.mouseMove(element).doubleClick()
 * 
 * Warning: this method currently only supports the left mouse button. See
 * [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).
 * 
 *     the element to interact with or the button to click with.
 *     Defaults to {\@link input.Button.LEFT} if neither an element nor
 *     button is specified.
 *     {\@link input.Button.LEFT}. Ignored if a button is provided as the
 *     first argument.
 * @param {(string|?)=} opt_elementOrButton
 * @param {string=} opt_button
 * @return {?}
 */
ActionSequence.prototype.doubleClick = function(opt_elementOrButton, opt_button) {};

/**
 * Performs a modifier key press. The modifier key is <em>not released</em>
 * until {\@link #keyUp} or {\@link #sendKeys} is called. The key press will be
 * targetted at the currently focused element.
 *     {ALT, CONTROL, SHIFT, COMMAND, META}.
 * @throws {Error} If the key is not a valid modifier key.
 * @param {string} key
 * @return {?}
 */
ActionSequence.prototype.keyDown = function(key) {};

/**
 * Performs a modifier key release. The release is targetted at the currently
 * focused element.
 *     {ALT, CONTROL, SHIFT, COMMAND, META}.
 * @throws {Error} If the key is not a valid modifier key.
 * @param {string} key
 * @return {?}
 */
ActionSequence.prototype.keyUp = function(key) {};

/**
 * Simulates typing multiple keys. Each modifier key encountered in the
 * sequence will not be released until it is encountered again. All key events
 * will be targeted at the currently focused element.
 * 
 *     The keys to type.
 * @throws {Error} If the key is not a valid modifier key.
 * @param {...(string|?)} var_args
 * @return {?}
 */
ActionSequence.prototype.sendKeys = function(var_args) {};

/**
 * @constructor
 * @struct
 * @param {?} driver
 */
function TouchSequence(driver) {}

/**
 * Executes this action sequence.
 *     this sequence has completed.
 * @return {?}
 */
TouchSequence.prototype.perform = function() {};

/**
 * Taps an element.
 * 
 * @param {?} elem
 * @return {?}
 */
TouchSequence.prototype.tap = function(elem) {};

/**
 * Double taps an element.
 * 
 * @param {?} elem
 * @return {?}
 */
TouchSequence.prototype.doubleTap = function(elem) {};

/**
 * Long press on an element.
 * 
 * @param {?} elem
 * @return {?}
 */
TouchSequence.prototype.longPress = function(elem) {};

/**
 * Touch down at the given location.
 * 
 * @param {?} location
 * @return {?}
 */
TouchSequence.prototype.tapAndHold = function(location) {};

/**
 * Move a held {\@linkplain #tapAndHold touch} to the specified location.
 * 
 * @param {?} location
 * @return {?}
 */
TouchSequence.prototype.move = function(location) {};

/**
 * Release a held {\@linkplain #tapAndHold touch} at the specified location.
 * 
 * @param {?} location
 * @return {?}
 */
TouchSequence.prototype.release = function(location) {};

/**
 * Scrolls the touch screen by the given offset.
 * 
 * @param {?} offset
 * @return {?}
 */
TouchSequence.prototype.scroll = function(offset) {};

/**
 * Scrolls the touch screen, starting on `elem` and moving by the specified
 * offset.
 * 
 * @param {?} elem
 * @param {?} offset
 * @return {?}
 */
TouchSequence.prototype.scrollFromElement = function(elem, offset) {};

/**
 * Flick, starting anywhere on the screen, at speed xspeed and yspeed.
 * 
 * direction, in pixels per second.
 * @param {?} speed
 * @return {?}
 */
TouchSequence.prototype.flick = function(speed) {};

/**
 * Flick starting at elem and moving by x and y at specified speed.
 * 
 * @param {?} elem
 * @param {?} offset
 * @param {number} speed
 * @return {?}
 */
TouchSequence.prototype.flickElement = function(elem, offset, speed) {};
/**
 * @record
 * @struct
 */
function IOffset() {}
 /** @type {number} */
IOffset.prototype.x;
 /** @type {number} */
IOffset.prototype.y;
/**
 * @record
 * @struct
 */
function ISpeed() {}
 /** @type {number} */
ISpeed.prototype.xspeed;
 /** @type {number} */
ISpeed.prototype.yspeed;

/**
 * @constructor
 * @struct
 *     is attached to.
 * @param {?} driver
 * @param {string} text
 */
function Alert(driver, text) {}

/**
 * Retrieves the message text displayed with this alert. For instance, if the
 * alert were opened with alert('hello'), then this would return 'hello'.
 *     text displayed with this alert.
 * @return {?}
 */
Alert.prototype.getText = function() {};

/**
 * Sets the username and password in an alert prompting for credentials (such
 * as a Basic HTTP Auth prompt). This method will implicitly
 * {\@linkplain #accept() submit} the dialog.
 * 
 *     command has completed.
 * @param {string} username
 * @param {string} password
 * @return {?}
 */
Alert.prototype.authenticateAs = function(username, password) {};

/**
 * Accepts this alert.
 *     this command has completed.
 * @return {?}
 */
Alert.prototype.accept = function() {};

/**
 * Dismisses this alert.
 *     this command has completed.
 * @return {?}
 */
Alert.prototype.dismiss = function() {};

/**
 * Sets the response text on this alert. This command will return an error if
 * the underlying alert does not support response text (e.g. window.alert and
 * window.confirm).
 *     this command has completed.
 * @param {string} text
 * @return {?}
 */
Alert.prototype.sendKeys = function(text) {};

/**
 * @constructor
 * @struct
 *     alert is attached to.
 *     that will be fulfilled with the promised alert.
 * @param {?} driver
 * @param {?} alert
 */
function AlertPromise(driver, alert) {}

/**
 * Registers listeners for when this instance is resolved. This function most
 * overridden by subtypes.
 * 
 * @param {!Function=} opt_callback The function to call if this promise is
 *     successfully resolved. The function should expect a single argument: the
 *     promise's resolved value.
 * @param {!Function=} opt_errback The function to call if this promise is
 *     rejected. The function should expect a single argument: the rejection
 *     reason.
 * @return {?} A new promise which will be resolved
 *     with the result of the invoked callback.
 */
AlertPromise.prototype.then = function(opt_callback, opt_errback) {};

/**
 * Registers a listener for when this promise is rejected. This is synonymous
 * with the {\@code catch} clause in a synchronous API:
 * 
 *     // Synchronous API:
 *     try {
 *       doSynchronousWork();
 *     } catch (ex) {
 *       console.error(ex);
 *     }
 * 
 *     // Asynchronous promise API:
 *     doAsynchronousWork().catch(function(ex) {
 *       console.error(ex);
 *     });
 * 
 *     function to call if this promise is rejected. The function should
 *     expect a single argument: the rejection reason.
 *     resolved with the result of the invoked callback.
 * @template R
 * @param {!Function} errback
 * @return {?}
 */
AlertPromise.prototype.catch = function(errback) {};
/**
 * @record
 * @struct
 */
function IBrowser() {}
 /** @type {string} */
IBrowser.prototype.ANDROID;
 /** @type {string} */
IBrowser.prototype.CHROME;
 /** @type {string} */
IBrowser.prototype.EDGE;
 /** @type {string} */
IBrowser.prototype.FIREFOX;
 /** @type {string} */
IBrowser.prototype.IE;
 /** @type {string} */
IBrowser.prototype.INTERNET_EXPLORER;
 /** @type {string} */
IBrowser.prototype.IPAD;
 /** @type {string} */
IBrowser.prototype.IPHONE;
 /** @type {string} */
IBrowser.prototype.OPERA;
 /** @type {string} */
IBrowser.prototype.PHANTOM_JS;
 /** @type {string} */
IBrowser.prototype.SAFARI;
 /** @type {string} */
IBrowser.prototype.HTMLUNIT;
 /** @type {?} */
var Browser;
/**
 * @record
 * @struct
 */
function ProxyConfig() {}
 /** @type {string} */
ProxyConfig.prototype.proxyType;
 /** @type {string} */
ProxyConfig.prototype.proxyAutoconfigUrl;
 /** @type {string} */
ProxyConfig.prototype.ftpProxy;
 /** @type {string} */
ProxyConfig.prototype.httpProxy;
 /** @type {string} */
ProxyConfig.prototype.sslProxy;
 /** @type {string} */
ProxyConfig.prototype.noProxy;
 /** @type {string} */
ProxyConfig.prototype.socksProxy;
 /** @type {string} */
ProxyConfig.prototype.socksUsername;
 /** @type {string} */
ProxyConfig.prototype.socksPassword;

/**
 * @constructor
 * @struct
 */
function Builder() {}

/**
 * Configures this builder to ignore any environment variable overrides and to
 * only use the configuration specified through this instance's API.
 * 
 * @return {?}
 */
Builder.prototype.disableEnvironmentOverrides = function() {};

/**
 * Creates a new WebDriver client based on this builder's current
 * configuration.
 * 
 * This method will return a {\@linkplain ThenableWebDriver} instance, allowing
 * users to issue commands directly without calling `then()`. The returned
 * thenable wraps a promise that will resolve to a concrete
 * {\@linkplain webdriver.WebDriver WebDriver} instance. The promise will be
 * rejected if the remote end fails to create a new session.
 * 
 * @throws {Error} If the current configuration is invalid.
 * @return {?}
 */
Builder.prototype.build = function() {};

/**
 * Configures the target browser for clients created by this instance.
 * Any calls to {\@link #withCapabilities} after this function will
 * overwrite these settings.
 * 
 * <p>You may also define the target browser using the {\@code SELENIUM_BROWSER}
 * environment variable. If set, this environment variable should be of the
 * form {\@code browser[:[version][:platform]]}.
 * 
 *     common defaults are available on the {\@link Browser} enum.
 *     version should be used.
 *     version may be used.
 * @param {string} name
 * @param {string=} opt_version
 * @param {string=} opt_platform
 * @return {?}
 */
Builder.prototype.forBrowser = function(name, opt_version, opt_platform) {};

/**
 * Returns the base set of capabilities this instance is currently configured
 * to use.
 * @return {?}
 */
Builder.prototype.getCapabilities = function() {};

/**
 *     to use.
 * @return {string}
 */
Builder.prototype.getServerUrl = function() {};

/**
 *    HTTP connections, or `null` if not set.
 * @return {string}
 */
Builder.prototype.getWebDriverProxy = function() {};

/**
 * Sets the default action to take with an unexpected alert before returning
 * an error.
 *     or 'ignore'. Defaults to 'dismiss'.
 * @param {string} behavior
 * @return {?}
 */
Builder.prototype.setAlertBehavior = function(behavior) {};

/**
 * Sets Chrome-specific options for drivers created by this builder. Any
 * logging or proxy settings defined on the given options will take precedence
 * over those set through {\@link #setLoggingPrefs} and {\@link #setProxy},
 * respectively.
 * 
 * @param {?} options
 * @return {?}
 */
Builder.prototype.setChromeOptions = function(options) {};

/**
 * Sets the control flow that created drivers should execute actions in. If
 * the flow is never set, or is set to {\@code null}, it will use the active
 * flow at the time {\@link #build()} is called.
 *     {\@code null} to
 * @param {?} flow
 * @return {?}
 */
Builder.prototype.setControlFlow = function(flow) {};

/**
 * Set {\@linkplain edge.Options options} specific to Microsoft's Edge browser
 * for drivers created by this builder. Any proxy settings defined on the
 * given options will take precedence over those set through
 * {\@link #setProxy}.
 * 
 * @param {?} options
 * @return {?}
 */
Builder.prototype.setEdgeOptions = function(options) {};

/**
 * Sets whether native events should be used.
 * @param {boolean} enabled
 * @return {?}
 */
Builder.prototype.setEnableNativeEvents = function(enabled) {};

/**
 * Sets Firefox-specific options for drivers created by this builder. Any
 * logging or proxy settings defined on the given options will take precedence
 * over those set through {\@link #setLoggingPrefs} and {\@link #setProxy},
 * respectively.
 * 
 * @param {?} options
 * @return {?}
 */
Builder.prototype.setFirefoxOptions = function(options) {};

/**
 * Set Internet Explorer specific {\@linkplain ie.Options options} for drivers
 * created by this builder. Any proxy settings defined on the given options
 * will take precedence over those set through {\@link #setProxy}.
 * 
 * @param {?} options
 * @return {?}
 */
Builder.prototype.setIeOptions = function(options) {};

/**
 * Sets the logging preferences for the created session. Preferences may be
 * changed by repeated calls, or by calling {\@link #withCapabilities}.
 *     desired logging preferences.
 * @param {(!Object|?)} prefs
 * @return {?}
 */
Builder.prototype.setLoggingPrefs = function(prefs) {};

/**
 * Sets Opera specific {\@linkplain opera.Options options} for drivers created
 * by this builder. Any logging or proxy settings defined on the given options
 * will take precedence over those set through {\@link #setLoggingPrefs} and
 * {\@link #setProxy}, respectively.
 * 
 * @param {?} options
 * @return {?}
 */
Builder.prototype.setOperaOptions = function(options) {};

/**
 * Sets the proxy configuration to use for WebDriver clients created by this
 * builder. Any calls to {\@link #withCapabilities} after this function will
 * overwrite these settings.
 * @param {?} config
 * @return {?}
 */
Builder.prototype.setProxy = function(config) {};

/**
 * Sets Safari specific {\@linkplain safari.Options options} for drivers
 * created by this builder. Any logging settings defined on the given options
 * will take precedence over those set through {\@link #setLoggingPrefs}.
 * 
 * @param {?} options
 * @return {?}
 */
Builder.prototype.setSafari = function(options) {};

/**
 * Sets how elements should be scrolled into view for interaction.
 *     the top of the viewport or 1 to align with the bottom.
 * @param {number} behavior
 * @return {?}
 */
Builder.prototype.setScrollBehavior = function(behavior) {};

/**
 * Sets the http agent to use for each request.
 * If this method is not called, the Builder will use http.globalAgent by default.
 * 
 * @param {?} agent
 * @return {?}
 */
Builder.prototype.usingHttpAgent = function(agent) {};

/**
 * Sets the URL of a remote WebDriver server to use. Once a remote URL has been
 * specified, the builder direct all new clients to that server. If this method
 * is never called, the Builder will attempt to create all clients locally.
 * 
 * <p>As an alternative to this method, you may also set the
 * {\@code SELENIUM_REMOTE_URL} environment variable.
 * 
 * @param {string} url
 * @return {?}
 */
Builder.prototype.usingServer = function(url) {};

/**
 * Sets the URL of the proxy to use for the WebDriver's HTTP connections.
 * If this method is never called, the Builder will create a connection
 * without a proxy.
 * 
 * @param {string} proxy
 * @return {?}
 */
Builder.prototype.usingWebDriverProxy = function(proxy) {};

/**
 * Sets the desired capabilities when requesting a new session. This will
 * overwrite any previously set capabilities.
 *     capabilities for a new session.
 * @param {(!Object|?)} capabilities
 * @return {?}
 */
Builder.prototype.withCapabilities = function(capabilities) {};

/**
 * @constructor
 * @struct
 * @param {string} using
 * @param {string} value
 */
function By(using, value) {}

/**
 * Locates elements that have a specific class name.
 * 
 * @see http://www.w3.org/TR/2011/WD-html5-20110525/elements.html#classes
 * @see http://www.w3.org/TR/CSS2/selector.html#class-html
 * @param {string} name
 * @return {?}
 */
By.className = function(name) {};

/**
 * Locates elements using a CSS selector.
 * 
 * @see http://www.w3.org/TR/CSS2/selector.html
 * @param {string} selector
 * @return {?}
 */
By.css = function(selector) {};

/**
 * Locates eleemnts by the ID attribute. This locator uses the CSS selector
 * `*[id='$ID']`, _not_ `document.getElementById`.
 * 
 * @param {string} id
 * @return {?}
 */
By.id = function(id) {};

/**
 * Locates link elements whose
 * {\@linkplain WebElement#getText visible text} matches the given
 * string.
 * 
 * @param {string} text
 * @return {?}
 */
By.linkText = function(text) {};

/**
 * Locates an elements by evaluating a
 * {\@linkplain WebDriver#executeScript JavaScript expression}.
 * The result of this expression must be an element or list of elements.
 * 
 *     A new JavaScript-based locator function.
 * @param {(string|!Function)} script
 * @param {...?} var_args
 * @return {?}
 */
By.js = function(script, var_args) {};

/**
 * Locates elements whose `name` attribute has the given value.
 * 
 * @param {string} name
 * @return {?}
 */
By.name = function(name) {};

/**
 * Locates link elements whose
 * {\@linkplain WebElement#getText visible text} contains the given
 * substring.
 * 
 * @param {string} text
 * @return {?}
 */
By.partialLinkText = function(text) {};

/**
 * Locates elements with a given tag name.
 * 
 * @deprecated Use {\@link By.css() By.css(tagName)} instead.
 * @param {string} name
 * @return {?}
 */
By.tagName = function(name) {};

/**
 * Locates elements matching a XPath selector. Care should be taken when
 * using an XPath selector with a {\@link WebElement} as WebDriver
 * will respect the context in the specified in the selector. For example,
 * given the selector `//div`, WebDriver will search from the document root
 * regardless of whether the locator was used with a WebElement.
 * 
 * @see http://www.w3.org/TR/xpath/
 * @param {string} xpath
 * @return {?}
 */
By.xpath = function(xpath) {};

/**
 * @override
 * @return {string}
 */
By.prototype.toString = function() {};

/** @typedef {?} */
var ByHash;

/** @typedef {(!Function|?)} */
var Locator;
/**
 * @record
 * @struct
 */
function ICapability() {}
 /** @type {string} */
ICapability.prototype.ACCEPT_SSL_CERTS;
 /** @type {string} */
ICapability.prototype.BROWSER_NAME;
 /** @type {string} */
ICapability.prototype.ELEMENT_SCROLL_BEHAVIOR;
 /** @type {string} */
ICapability.prototype.HANDLES_ALERTS;
 /** @type {string} */
ICapability.prototype.LOGGING_PREFS;
 /** @type {string} */
ICapability.prototype.NATIVE_EVENTS;
 /** @type {string} */
ICapability.prototype.PLATFORM;
 /** @type {string} */
ICapability.prototype.PROXY;
 /** @type {string} */
ICapability.prototype.ROTATABLE;
 /** @type {string} */
ICapability.prototype.SECURE_SSL;
 /** @type {string} */
ICapability.prototype.SUPPORTS_APPLICATION_CACHE;
 /** @type {string} */
ICapability.prototype.SUPPORTS_CSS_SELECTORS;
 /** @type {string} */
ICapability.prototype.SUPPORTS_JAVASCRIPT;
 /** @type {string} */
ICapability.prototype.SUPPORTS_LOCATION_CONTEXT;
 /** @type {string} */
ICapability.prototype.TAKES_SCREENSHOT;
 /** @type {string} */
ICapability.prototype.UNEXPECTED_ALERT_BEHAVIOR;
 /** @type {string} */
ICapability.prototype.VERSION;
 /** @type {?} */
var Capability;

/**
 * @constructor
 * @struct
 *     capabilities to merge into this instance.
 * @param {(!Object|?)=} opt_other
 */
function Capabilities(opt_other) {}

/**
 * @return {?}
 */
Capabilities.prototype.toJSON = function() {};

/**
 * Merges another set of capabilities into this instance. Any duplicates in
 * the provided set will override those already set on this instance.
 *     merge into this instance.
 * @param {(!Object|?)} other
 * @return {?}
 */
Capabilities.prototype.merge = function(other) {};

/**
 *     serializable. Pass {\@code null} to unset the capability.
 * @param {string} key
 * @param {?} value
 * @return {?}
 */
Capabilities.prototype.set = function(key, value) {};

/**
 * Sets the logging preferences. Preferences may be specified as a
 * {\@link logging.Preferences} instance, or a as a map of log-type to
 * log-level.
 *     logging preferences.
 * @param {(!Object|?)} prefs
 * @return {?}
 */
Capabilities.prototype.setLoggingPrefs = function(prefs) {};

/**
 * Sets the proxy configuration for this instance.
 * @param {?} proxy
 * @return {?}
 */
Capabilities.prototype.setProxy = function(proxy) {};

/**
 * Sets whether native events should be used.
 * @param {boolean} enabled
 * @return {?}
 */
Capabilities.prototype.setEnableNativeEvents = function(enabled) {};

/**
 * Sets how elements should be scrolled into view for interaction.
 *     the top of the viewport or 1 to align with the bottom.
 * @param {number} behavior
 * @return {?}
 */
Capabilities.prototype.setScrollBehavior = function(behavior) {};

/**
 * Sets the default action to take with an unexpected alert before returning
 * an error.
 *     or 'ignore'. Defaults to 'dismiss'.
 * @param {string} behavior
 * @return {?}
 */
Capabilities.prototype.setAlertBehavior = function(behavior) {};

/**
 *     not been set.
 * @param {string} key
 * @return {?}
 */
Capabilities.prototype.get = function(key) {};

/**
 * @param {string} key
 * @return {boolean}
 */
Capabilities.prototype.has = function(key) {};

/**
 * @return {?}
 */
Capabilities.android = function() {};

/**
 * @return {?}
 */
Capabilities.chrome = function() {};

/**
 * @return {?}
 */
Capabilities.edge = function() {};

/**
 * @return {?}
 */
Capabilities.firefox = function() {};

/**
 *     Internet Explorer.
 * @return {?}
 */
Capabilities.ie = function() {};

/**
 * @return {?}
 */
Capabilities.ipad = function() {};

/**
 * @return {?}
 */
Capabilities.iphone = function() {};

/**
 * @return {?}
 */
Capabilities.opera = function() {};

/**
 *     PhantomJS.
 * @return {?}
 */
Capabilities.phantomjs = function() {};

/**
 * @return {?}
 */
Capabilities.safari = function() {};

/**
 * @return {?}
 */
Capabilities.htmlunit = function() {};

/**
 *                                   with enabled Javascript.
 * @return {?}
 */
Capabilities.htmlunitwithjs = function() {};
/**
 * @record
 * @struct
 */
function ICommandName() {}
 /** @type {string} */
ICommandName.prototype.GET_SERVER_STATUS;
 /** @type {string} */
ICommandName.prototype.NEW_SESSION;
 /** @type {string} */
ICommandName.prototype.GET_SESSIONS;
 /** @type {string} */
ICommandName.prototype.DESCRIBE_SESSION;
 /** @type {string} */
ICommandName.prototype.CLOSE;
 /** @type {string} */
ICommandName.prototype.QUIT;
 /** @type {string} */
ICommandName.prototype.GET_CURRENT_URL;
 /** @type {string} */
ICommandName.prototype.GET;
 /** @type {string} */
ICommandName.prototype.GO_BACK;
 /** @type {string} */
ICommandName.prototype.GO_FORWARD;
 /** @type {string} */
ICommandName.prototype.REFRESH;
 /** @type {string} */
ICommandName.prototype.ADD_COOKIE;
 /** @type {string} */
ICommandName.prototype.GET_COOKIE;
 /** @type {string} */
ICommandName.prototype.GET_ALL_COOKIES;
 /** @type {string} */
ICommandName.prototype.DELETE_COOKIE;
 /** @type {string} */
ICommandName.prototype.DELETE_ALL_COOKIES;
 /** @type {string} */
ICommandName.prototype.GET_ACTIVE_ELEMENT;
 /** @type {string} */
ICommandName.prototype.FIND_ELEMENT;
 /** @type {string} */
ICommandName.prototype.FIND_ELEMENTS;
 /** @type {string} */
ICommandName.prototype.FIND_CHILD_ELEMENT;
 /** @type {string} */
ICommandName.prototype.FIND_CHILD_ELEMENTS;
 /** @type {string} */
ICommandName.prototype.CLEAR_ELEMENT;
 /** @type {string} */
ICommandName.prototype.CLICK_ELEMENT;
 /** @type {string} */
ICommandName.prototype.SEND_KEYS_TO_ELEMENT;
 /** @type {string} */
ICommandName.prototype.SUBMIT_ELEMENT;
 /** @type {string} */
ICommandName.prototype.GET_CURRENT_WINDOW_HANDLE;
 /** @type {string} */
ICommandName.prototype.GET_WINDOW_HANDLES;
 /** @type {string} */
ICommandName.prototype.GET_WINDOW_POSITION;
 /** @type {string} */
ICommandName.prototype.SET_WINDOW_POSITION;
 /** @type {string} */
ICommandName.prototype.GET_WINDOW_SIZE;
 /** @type {string} */
ICommandName.prototype.SET_WINDOW_SIZE;
 /** @type {string} */
ICommandName.prototype.MAXIMIZE_WINDOW;
 /** @type {string} */
ICommandName.prototype.SWITCH_TO_WINDOW;
 /** @type {string} */
ICommandName.prototype.SWITCH_TO_FRAME;
 /** @type {string} */
ICommandName.prototype.GET_PAGE_SOURCE;
 /** @type {string} */
ICommandName.prototype.GET_TITLE;
 /** @type {string} */
ICommandName.prototype.EXECUTE_SCRIPT;
 /** @type {string} */
ICommandName.prototype.EXECUTE_ASYNC_SCRIPT;
 /** @type {string} */
ICommandName.prototype.GET_ELEMENT_TEXT;
 /** @type {string} */
ICommandName.prototype.GET_ELEMENT_TAG_NAME;
 /** @type {string} */
ICommandName.prototype.IS_ELEMENT_SELECTED;
 /** @type {string} */
ICommandName.prototype.IS_ELEMENT_ENABLED;
 /** @type {string} */
ICommandName.prototype.IS_ELEMENT_DISPLAYED;
 /** @type {string} */
ICommandName.prototype.GET_ELEMENT_LOCATION;
 /** @type {string} */
ICommandName.prototype.GET_ELEMENT_LOCATION_IN_VIEW;
 /** @type {string} */
ICommandName.prototype.GET_ELEMENT_SIZE;
 /** @type {string} */
ICommandName.prototype.GET_ELEMENT_ATTRIBUTE;
 /** @type {string} */
ICommandName.prototype.GET_ELEMENT_VALUE_OF_CSS_PROPERTY;
 /** @type {string} */
ICommandName.prototype.ELEMENT_EQUALS;
 /** @type {string} */
ICommandName.prototype.SCREENSHOT;
 /** @type {string} */
ICommandName.prototype.IMPLICITLY_WAIT;
 /** @type {string} */
ICommandName.prototype.SET_SCRIPT_TIMEOUT;
 /** @type {string} */
ICommandName.prototype.SET_TIMEOUT;
 /** @type {string} */
ICommandName.prototype.ACCEPT_ALERT;
 /** @type {string} */
ICommandName.prototype.DISMISS_ALERT;
 /** @type {string} */
ICommandName.prototype.GET_ALERT_TEXT;
 /** @type {string} */
ICommandName.prototype.SET_ALERT_TEXT;
 /** @type {string} */
ICommandName.prototype.EXECUTE_SQL;
 /** @type {string} */
ICommandName.prototype.GET_LOCATION;
 /** @type {string} */
ICommandName.prototype.SET_LOCATION;
 /** @type {string} */
ICommandName.prototype.GET_APP_CACHE;
 /** @type {string} */
ICommandName.prototype.GET_APP_CACHE_STATUS;
 /** @type {string} */
ICommandName.prototype.CLEAR_APP_CACHE;
 /** @type {string} */
ICommandName.prototype.IS_BROWSER_ONLINE;
 /** @type {string} */
ICommandName.prototype.SET_BROWSER_ONLINE;
 /** @type {string} */
ICommandName.prototype.GET_LOCAL_STORAGE_ITEM;
 /** @type {string} */
ICommandName.prototype.GET_LOCAL_STORAGE_KEYS;
 /** @type {string} */
ICommandName.prototype.SET_LOCAL_STORAGE_ITEM;
 /** @type {string} */
ICommandName.prototype.REMOVE_LOCAL_STORAGE_ITEM;
 /** @type {string} */
ICommandName.prototype.CLEAR_LOCAL_STORAGE;
 /** @type {string} */
ICommandName.prototype.GET_LOCAL_STORAGE_SIZE;
 /** @type {string} */
ICommandName.prototype.GET_SESSION_STORAGE_ITEM;
 /** @type {string} */
ICommandName.prototype.GET_SESSION_STORAGE_KEYS;
 /** @type {string} */
ICommandName.prototype.SET_SESSION_STORAGE_ITEM;
 /** @type {string} */
ICommandName.prototype.REMOVE_SESSION_STORAGE_ITEM;
 /** @type {string} */
ICommandName.prototype.CLEAR_SESSION_STORAGE;
 /** @type {string} */
ICommandName.prototype.GET_SESSION_STORAGE_SIZE;
 /** @type {string} */
ICommandName.prototype.SET_SCREEN_ORIENTATION;
 /** @type {string} */
ICommandName.prototype.GET_SCREEN_ORIENTATION;
 /** @type {string} */
ICommandName.prototype.CLICK;
 /** @type {string} */
ICommandName.prototype.DOUBLE_CLICK;
 /** @type {string} */
ICommandName.prototype.MOUSE_DOWN;
 /** @type {string} */
ICommandName.prototype.MOUSE_UP;
 /** @type {string} */
ICommandName.prototype.MOVE_TO;
 /** @type {string} */
ICommandName.prototype.SEND_KEYS_TO_ACTIVE_ELEMENT;
 /** @type {string} */
ICommandName.prototype.TOUCH_SINGLE_TAP;
 /** @type {string} */
ICommandName.prototype.TOUCH_DOWN;
 /** @type {string} */
ICommandName.prototype.TOUCH_UP;
 /** @type {string} */
ICommandName.prototype.TOUCH_MOVE;
 /** @type {string} */
ICommandName.prototype.TOUCH_SCROLL;
 /** @type {string} */
ICommandName.prototype.TOUCH_DOUBLE_TAP;
 /** @type {string} */
ICommandName.prototype.TOUCH_LONG_PRESS;
 /** @type {string} */
ICommandName.prototype.TOUCH_FLICK;
 /** @type {string} */
ICommandName.prototype.GET_AVAILABLE_LOG_TYPES;
 /** @type {string} */
ICommandName.prototype.GET_LOG;
 /** @type {string} */
ICommandName.prototype.GET_SESSION_LOGS;
 /** @type {string} */
ICommandName.prototype.UPLOAD_FILE;
 /** @type {?} */
var CommandName;

/**
 * @constructor
 * @struct
 * @param {string} name
 */
function Command(name) {}

/**
 * @return {string}
 */
Command.prototype.getName = function() {};

/**
 * Sets a parameter to send with this command.
 * @param {string} name
 * @param {?} value
 * @return {?}
 */
Command.prototype.setParameter = function(name, value) {};

/**
 * Sets the parameters for this command.
 * @param {?} parameters
 * @return {?}
 */
Command.prototype.setParameters = function(parameters) {};

/**
 * Returns a named command parameter.
 * @param {string} key
 * @return {?}
 */
Command.prototype.getParameter = function(key) {};

/**
 * @return {?}
 */
Command.prototype.getParameters = function() {};
/**
 * @constructor
 * @struct
 */
function Executor() {}

/**
 * Executes the given {\@code command}. If there is an error executing the
 * command, the provided callback will be invoked with the offending error.
 * Otherwise, the callback will be invoked with a null Error and non-null
 * response object.
 * 
 *     the command result.
 * @param {?} command
 * @return {?}
 */
Executor.prototype.execute = function(command) {};

/**
 * @constructor
 * @struct
 *     listener.
 * @param {!Function} fn
 * @param {!Object} scope
 * @param {boolean} oneshot
 */
function Listener(fn, scope, oneshot) {}

/**
 * @constructor
 * @struct
 */
function EventEmitter() {}

/**
 * Fires an event and calls all listeners.
 * @param {string} type
 * @param {...?} var_args
 * @return {void}
 */
EventEmitter.prototype.emit = function(type, var_args) {};

/**
 * Returns a mutable list of listeners for a specific type of event.
 *     type.
 * @param {string} type
 * @return {?}
 */
EventEmitter.prototype.listeners = function(type) {};

/**
 * Registers a listener.
 *    the first event is fired.
 * @param {string} type
 * @param {!Function} fn
 * @param {?=} opt_scope
 * @param {boolean=} opt_oneshot
 * @return {?}
 */
EventEmitter.prototype.addListener = function(type, fn, opt_scope, opt_oneshot) {};

/**
 * Registers a one-time listener which will be called only the first time an
 * event is emitted, after which it will be removed.
 * @param {string} type
 * @param {?} fn
 * @param {?=} opt_scope
 * @return {?}
 */
EventEmitter.prototype.once = function(type, fn, opt_scope) {};

/**
 * An alias for {\@code #addListener()}.
 * @param {string} type
 * @param {!Function} fn
 * @param {?=} opt_scope
 * @return {?}
 */
EventEmitter.prototype.on = function(type, fn, opt_scope) {};

/**
 * Removes a previously registered event listener.
 * @param {string} type
 * @param {!Function} listenerFn
 * @return {?}
 */
EventEmitter.prototype.removeListener = function(type, listenerFn) {};

/**
 * Removes all listeners for a specific type of event. If no event is
 * specified, all listeners across all types will be removed.
 * @param {string=} opt_type
 * @return {?}
 */
EventEmitter.prototype.removeAllListeners = function(opt_type) {};

/**
 * @constructor
 * @struct
 * Interface for navigating back and forth in the browser history.
 * 
 * This class should never be instantiated directly. Insead, obtain an instance
 * with
 * 
 *    navigate()
 * 
 * @see WebDriver#navigate()
 * @param {?} driver
 */
function Navigation(driver) {}

/**
 * Schedules a command to navigate to a new URL.
 *     when the URL has been loaded.
 * @param {string} url
 * @return {?}
 */
Navigation.prototype.to = function(url) {};

/**
 * Schedules a command to move backwards in the browser history.
 *     when the navigation event has completed.
 * @return {?}
 */
Navigation.prototype.back = function() {};

/**
 * Schedules a command to move forwards in the browser history.
 *     when the navigation event has completed.
 * @return {?}
 */
Navigation.prototype.forward = function() {};

/**
 * Schedules a command to refresh the current page.
 *     when the navigation event has completed.
 * @return {?}
 */
Navigation.prototype.refresh = function() {};
/**
 * @record
 * @struct
 */
function IWebDriverOptionsCookie() {}
 /** @type {string} */
IWebDriverOptionsCookie.prototype.name;
 /** @type {string} */
IWebDriverOptionsCookie.prototype.value;
 /** @type {string} */
IWebDriverOptionsCookie.prototype.path;
 /** @type {string} */
IWebDriverOptionsCookie.prototype.domain;
 /** @type {boolean} */
IWebDriverOptionsCookie.prototype.secure;
 /** @type {boolean} */
IWebDriverOptionsCookie.prototype.httpOnly;
 /** @type {(number|!Date)} */
IWebDriverOptionsCookie.prototype.expiry;
/**
 * @extends {IWebDriverOptionsCookie}
 * @record
 * @struct
 */
function IWebDriverCookie() {}
 /** @type {number} */
IWebDriverCookie.prototype.expiry;

/**
 * @constructor
 * @struct
 * @param {?} driver
 */
function Options(driver) {}

/**
 * Schedules a command to add a cookie.
 *     when the cookie has been added to the page.
 * @throws {error.InvalidArgumentError} if any of the cookie parameters are
 *     invalid.
 * @throws {TypeError} if `spec` is not a cookie object.
 * @param {?} spec
 * @return {?}
 */
Options.prototype.addCookie = function(spec) {};

/**
 * Schedules a command to delete all cookies visible to the current page.
 *     cookies have been deleted.
 * @return {?}
 */
Options.prototype.deleteAllCookies = function() {};

/**
 * Schedules a command to delete the cookie with the given name. This command is
 * a no-op if there is no cookie with the given name visible to the current
 * page.
 *     cookie has been deleted.
 * @param {string} name
 * @return {?}
 */
Options.prototype.deleteCookie = function(name) {};

/**
 * Schedules a command to retrieve all cookies visible to the current page.
 * Each cookie will be returned as a JSON object as described by the WebDriver
 * wire protocol.
 *     cookies visible to the current page.
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object
 * @return {?}
 */
Options.prototype.getCookies = function() {};

/**
 * Schedules a command to retrieve the cookie with the given name. Returns null
 * if there is no such cookie. The cookie will be returned as a JSON object as
 * described by the WebDriver wire protocol.
 *     named cookie, or {\@code null} if there is no such cookie.
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object
 * @param {string} name
 * @return {?}
 */
Options.prototype.getCookie = function(name) {};

/**
 *     logs.
 * @return {?}
 */
Options.prototype.logs = function() {};

/**
 *     timeouts.
 * @return {?}
 */
Options.prototype.timeouts = function() {};

/**
 *     current window.
 * @return {?}
 */
Options.prototype.window = function() {};

/**
 * @constructor
 * @struct
 * @param {?} driver
 */
function Timeouts(driver) {}

/**
 * Specifies the amount of time the driver should wait when searching for an
 * element if it is not immediately present.
 * <p/>
 * When searching for a single element, the driver should poll the page
 * until the element has been found, or this timeout expires before failing
 * with a {\@code bot.ErrorCode.NO_SUCH_ELEMENT} error. When searching
 * for multiple elements, the driver should poll the page until at least one
 * element has been found or this timeout has expired.
 * <p/>
 * Setting the wait timeout to 0 (its default value), disables implicit
 * waiting.
 * <p/>
 * Increasing the implicit wait timeout should be used judiciously as it
 * will have an adverse effect on test run time, especially when used with
 * slower location strategies like XPath.
 * 
 *     implicit wait timeout has been set.
 * @param {number} ms
 * @return {?}
 */
Timeouts.prototype.implicitlyWait = function(ms) {};

/**
 * Sets the amount of time to wait, in milliseconds, for an asynchronous script
 * to finish execution before returning an error. If the timeout is less than or
 * equal to 0, the script will be allowed to run indefinitely.
 * 
 *     script timeout has been set.
 * @param {number} ms
 * @return {?}
 */
Timeouts.prototype.setScriptTimeout = function(ms) {};

/**
 * Sets the amount of time to wait for a page load to complete before returning
 * an error.  If the timeout is negative, page loads may be indefinite.
 *     the timeout has been set.
 * @param {number} ms
 * @return {?}
 */
Timeouts.prototype.pageLoadTimeout = function(ms) {};

/**
 * @constructor
 * @struct
 * @param {?} driver
 */
function Window(driver) {}

/**
 * Retrieves the window's current position, relative to the top left corner of
 * the screen.
 *     window's position in the form of a {x:number, y:number} object literal.
 * @return {?}
 */
Window.prototype.getPosition = function() {};

/**
 * Repositions the current window.
 *     of the screen.
 *     of the screen.
 *     command has completed.
 * @param {number} x
 * @param {number} y
 * @return {?}
 */
Window.prototype.setPosition = function(x, y) {};

/**
 * Retrieves the window's current size.
 *     window's size in the form of a {width:number, height:number} object
 *     literal.
 * @return {?}
 */
Window.prototype.getSize = function() {};

/**
 * Resizes the current window.
 *     command has completed.
 * @param {number} width
 * @param {number} height
 * @return {?}
 */
Window.prototype.setSize = function(width, height) {};

/**
 * Maximizes the current window.
 *     command has completed.
 * @return {?}
 */
Window.prototype.maximize = function() {};

/**
 * @constructor
 * @struct
 * @param {?} driver
 */
function Logs(driver) {}

/**
 * Fetches available log entries for the given type.
 * 
 * <p/>Note that log buffers are reset after each call, meaning that
 * available log entries correspond to those entries not yet returned for a
 * given log type. In practice, this means that this call will return the
 * available log entries since the last call, or from the start of the
 * session.
 * 
 *   promise that will resolve to a list of log entries for the specified
 *   type.
 * @param {string} type
 * @return {?}
 */
Logs.prototype.get = function(type) {};

/**
 * Retrieves the log types available to this driver.
 *     promise that will resolve to a list of available log types.
 * @return {?}
 */
Logs.prototype.getAvailableLogTypes = function() {};

/**
 * @constructor
 * @struct
 * @param {?} driver
 */
function TargetLocator(driver) {}

/**
 * Schedules a command retrieve the {\@code document.activeElement} element on
 * the current document, or {\@code document.body} if activeElement is not
 * available.
 * @return {?}
 */
TargetLocator.prototype.activeElement = function() {};

/**
 * Schedules a command to switch focus of all future commands to the first frame
 * on the page.
 *     driver has changed focus to the default content.
 * @return {?}
 */
TargetLocator.prototype.defaultContent = function() {};

/**
 * Schedules a command to switch the focus of all future commands to another
 * frame on the page. The target frame may be specified as one of the
 * following:
 * 
 * - A number that specifies a (zero-based) index into [window.frames](
 *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).
 * - A {\@link WebElement} reference, which correspond to a `frame` or `iframe`
 *   DOM element.
 * - The `null` value, to select the topmost frame on the page. Passing `null`
 *   is the same as calling {\@link #defaultContent defaultContent()}.
 * 
 * If the specified frame can not be found, the returned promise will be
 * rejected with a {\@linkplain error.NoSuchFrameError}.
 * 
 *     when the driver has changed focus to the specified frame.
 * @param {(number|?)} nameOrIndex
 * @return {?}
 */
TargetLocator.prototype.frame = function(nameOrIndex) {};

/**
 * Schedules a command to switch the focus of all future commands to another
 * window. Windows may be specified by their {\@code window.name} attribute or
 * by its handle (as returned by {\@link WebDriver#getWindowHandles}).
 * 
 * If the specified window cannot be found, the returned promise will be
 * rejected with a {\@linkplain error.NoSuchWindowError}.
 * 
 *     switch focus to.
 *     when the driver has changed focus to the specified window.
 * @param {string} nameOrHandle
 * @return {?}
 */
TargetLocator.prototype.window = function(nameOrHandle) {};

/**
 * Schedules a command to change focus to the active modal dialog, such as
 * those opened by `window.alert()`, `window.confirm()`, and
 * `window.prompt()`. The returned promise will be rejected with a
 * {\@linkplain error.NoSuchAlertError} if there are no open alerts.
 * 
 * @return {?}
 */
TargetLocator.prototype.alert = function() {};

/**
 * @constructor
 * @struct
 */
function FileDetector() {}

/**
 * Handles the file specified by the given path, preparing it for use with
 * the current browser. If the path does not refer to a valid file, it will
 * be returned unchanged, otherwisee a path suitable for use with the current
 * browser will be returned.
 * 
 * This default implementation is a no-op. Subtypes may override this
 * function for custom tailored file handling.
 * 
 *     file path.
 * @package
 * @param {?} driver
 * @param {string} path
 * @return {?}
 */
FileDetector.prototype.handleFile = function(driver, path) {};

/** @typedef {?} */
var CreateSessionCapabilities;

/**
 * @constructor
 * @struct
 *     known session or a promise that will be resolved to a session.
 *     commands to the browser.
 *     schedule commands through. Defaults to the active flow object.
 * @param {?} session
 * @param {?} executor
 * @param {?=} opt_flow
 */
function WebDriver(session, executor, opt_flow) {}

/**
 * Creates a new WebDriver client for an existing session.
 *     for session details.
 *     driver commands should execute under. Defaults to the
 *     {\@link promise.controlFlow() currently active}  control flow.
 * @param {?} executor
 * @param {string} sessionId
 * @param {?=} opt_flow
 * @return {?}
 */
WebDriver.attachToSession = function(executor, sessionId, opt_flow) {};

/**
 * @param {...?} var_args
 * @return {?}
 */
WebDriver.createSession = function(var_args) {};

/**
 *     instance.
 * @return {?}
 */
WebDriver.prototype.controlFlow = function() {};

/**
 * Schedules a {\@link command.Command} to be executed by this driver's
 * {\@link command.Executor}.
 * 
 *     with the command result.
 * @template T
 * @param {?} command
 * @param {string} description
 * @return {?}
 */
WebDriver.prototype.schedule = function(command, description) {};

/**
 * Sets the {\@linkplain input.FileDetector file detector} that should be
 * used with this instance.
 * @param {?} detector
 * @return {void}
 */
WebDriver.prototype.setFileDetector = function(detector) {};

/**
 *     client's session.
 * @return {?}
 */
WebDriver.prototype.getSession = function() {};

/**
 *     that will resolve with the this instance's capabilities.
 * @return {?}
 */
WebDriver.prototype.getCapabilities = function() {};

/**
 * Schedules a command to quit the current session. After calling quit, this
 * instance will be invalidated and may no longer be used to issue commands
 * against the browser.
 *     when the command has completed.
 * @return {?}
 */
WebDriver.prototype.quit = function() {};

/**
 * Creates a new action sequence using this driver. The sequence will not be
 * scheduled for execution until {\@link actions.ActionSequence#perform} is
 * called. Example:
 * 
 *     driver.actions().
 *         mouseDown(element1).
 *         mouseMove(element2).
 *         mouseUp().
 *         perform();
 * 
 * @return {?}
 */
WebDriver.prototype.actions = function() {};

/**
 * Creates a new touch sequence using this driver. The sequence will not be
 * scheduled for execution until {\@link actions.TouchSequence#perform} is
 * called. Example:
 * 
 *     driver.touchActions().
 *         tap(element1).
 *         doubleTap(element2).
 *         perform();
 * 
 * @return {?}
 */
WebDriver.prototype.touchActions = function() {};

/**
 * Schedules a command to execute JavaScript in the context of the currently
 * selected frame or window. The script fragment will be executed as the body
 * of an anonymous function. If the script is provided as a function object,
 * that function will be converted to a string for injection into the target
 * window.
 * 
 * Any arguments provided in addition to the script will be included as script
 * arguments and may be referenced using the {\@code arguments} object.
 * Arguments may be a boolean, number, string, or {\@code WebElement}.
 * Arrays and objects may also be used as script arguments as long as each item
 * adheres to the types previously mentioned.
 * 
 * The script may refer to any variables accessible from the current window.
 * Furthermore, the script will execute in the window's context, thus
 * {\@code document} may be used to refer to the current document. Any local
 * variables will not be available once the script has finished executing,
 * though global variables will persist.
 * 
 * If the script has a return value (i.e. if the script contains a return
 * statement), then the following steps will be taken for resolving this
 * functions return value:
 * 
 * - For a HTML element, the value will resolve to a
 *     {\@link WebElement}
 * - Null and undefined return values will resolve to null</li>
 * - Booleans, numbers, and strings will resolve as is</li>
 * - Functions will resolve to their string representation</li>
 * - For arrays and objects, each member item will be converted according to
 *     the rules above
 * 
 *    scripts return value.
 * @template T
 * @param {(string|!Function)} script
 * @param {...?} var_args
 * @return {?}
 */
WebDriver.prototype.executeScript = function(script, var_args) {};

/**
 * Schedules a command to execute asynchronous JavaScript in the context of the
 * currently selected frame or window. The script fragment will be executed as
 * the body of an anonymous function. If the script is provided as a function
 * object, that function will be converted to a string for injection into the
 * target window.
 * 
 * Any arguments provided in addition to the script will be included as script
 * arguments and may be referenced using the {\@code arguments} object.
 * Arguments may be a boolean, number, string, or {\@code WebElement}.
 * Arrays and objects may also be used as script arguments as long as each item
 * adheres to the types previously mentioned.
 * 
 * Unlike executing synchronous JavaScript with {\@link #executeScript},
 * scripts executed with this function must explicitly signal they are finished
 * by invoking the provided callback. This callback will always be injected
 * into the executed function as the last argument, and thus may be referenced
 * with {\@code arguments[arguments.length - 1]}. The following steps will be
 * taken for resolving this functions return value against the first argument
 * to the script's callback function:
 * 
 * - For a HTML element, the value will resolve to a
 *     {\@link WebElement}
 * - Null and undefined return values will resolve to null
 * - Booleans, numbers, and strings will resolve as is
 * - Functions will resolve to their string representation
 * - For arrays and objects, each member item will be converted according to
 *     the rules above
 * 
 * __Example #1:__ Performing a sleep that is synchronized with the currently
 * selected window:
 * 
 *     var start = new Date().getTime();
 *     driver.executeAsyncScript(
 *         'window.setTimeout(arguments[arguments.length - 1], 500);').
 *         then(function() {
 *           console.log(
 *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');
 *         });
 * 
 * __Example #2:__ Synchronizing a test with an AJAX application:
 * 
 *     var button = driver.findElement(By.id('compose-button'));
 *     button.click();
 *     driver.executeAsyncScript(
 *         'var callback = arguments[arguments.length - 1];' +
 *         'mailClient.getComposeWindowWidget().onload(callback);');
 *     driver.switchTo().frame('composeWidget');
 *     driver.findElement(By.id('to')).sendKeys('dog\@example.com');
 * 
 * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In
 * this example, the inject script is specified with a function literal. When
 * using this format, the function is converted to a string for injection, so it
 * should not reference any symbols not defined in the scope of the page under
 * test.
 * 
 *     driver.executeAsyncScript(function() {
 *       var callback = arguments[arguments.length - 1];
 *       var xhr = new XMLHttpRequest();
 *       xhr.open('GET', '/resource/data.json', true);
 *       xhr.onreadystatechange = function() {
 *         if (xhr.readyState == 4) {
 *           callback(xhr.responseText);
 *         }
 *       }
 *       xhr.send('');
 *     }).then(function(str) {
 *       console.log(JSON.parse(str)['food']);
 *     });
 * 
 *    scripts return value.
 * @template T
 * @param {(string|!Function)} script
 * @param {...?} var_args
 * @return {?}
 */
WebDriver.prototype.executeAsyncScript = function(script, var_args) {};

/**
 * Schedules a command to execute a custom function.
 *     execute.
 *     with the function's result.
 * @template T
 * @param {?} fn
 * @param {?=} opt_scope
 * @param {...?} var_args
 * @return {?}
 */
WebDriver.prototype.call = function(fn, opt_scope, var_args) {};

/**
 * Schedules a command to wait for a condition to hold. The condition may be
 * specified by a {\@link Condition}, as a custom function, or
 * as a {\@link promise.Promise}.
 * 
 * For a {\@link Condition} or function, the wait will repeatedly
 * evaluate the condition until it returns a truthy value. If any errors occur
 * while evaluating the condition, they will be allowed to propagate. In the
 * event a condition returns a {\@link promise.Promise promise}, the
 * polling loop will wait for it to be resolved and use the resolved value for
 * whether the condition has been satisified. Note the resolution time for
 * a promise is factored into whether a wait has timed out.
 * 
 * Note, if the provided condition is a {\@link WebElementCondition}, then
 * the wait will return a {\@link WebElementPromise} that will resolve to the
 * element that satisified the condition.
 * 
 * *Example:* waiting up to 10 seconds for an element to be present and visible
 * on the page.
 * 
 *     var button = driver.wait(until.elementLocated(By.id('foo'), 10000);
 *     button.click();
 * 
 * This function may also be used to block the command flow on the resolution
 * of a {\@link promise.Promise promise}. When given a promise, the
 * command will simply wait for its resolution before completing. A timeout may
 * be provided to fail the command if the promise does not resolve before the
 * timeout expires.
 * 
 * *Example:* Suppose you have a function, `startTestServer`, that returns a
 * promise for when a server is ready for requests. You can block a `WebDriver`
 * client on this promise with:
 * 
 *     var started = startTestServer();
 *     driver.wait(started, 5 * 1000, 'Server should start within 5 seconds');
 *     driver.get(getServerUrl());
 * 
 *     wait on, defined as a promise, condition object, or  a function to
 *     evaluate as a condition.
 *     out.
 *     with the first truthy value returned by the condition function, or
 *     rejected if the condition times out.
 * Schedules a command to wait for a condition to hold. The condition may be
 * specified by a {\@link webdriver.Condition}, as a custom function, or
 * as a {\@link webdriver.promise.Promise}.
 * 
 * For a {\@link webdriver.Condition} or function, the wait will repeatedly
 * evaluate the condition until it returns a truthy value. If any errors occur
 * while evaluating the condition, they will be allowed to propagate. In the
 * event a condition returns a {\@link webdriver.promise.Promise promise}, the
 * polling loop will wait for it to be resolved and use the resolved value for
 * whether the condition has been satisified. Note the resolution time for
 * a promise is factored into whether a wait has timed out.
 * 
 * Note, if the provided condition is a {\@link WebElementCondition}, then
 * the wait will return a {\@link WebElementPromise} that will resolve to the
 * element that satisified the condition.
 * 
 * *Example:* waiting up to 10 seconds for an element to be present and visible
 * on the page.
 * 
 *     var button = driver.wait(until.elementLocated(By.id('foo'), 10000);
 *     button.click();
 * 
 * This function may also be used to block the command flow on the resolution
 * of a {\@link webdriver.promise.Promise promise}. When given a promise, the
 * command will simply wait for its resolution before completing. A timeout may
 * be provided to fail the command if the promise does not resolve before the
 * timeout expires.
 * 
 * *Example:* Suppose you have a function, `startTestServer`, that returns a
 * promise for when a server is ready for requests. You can block a `WebDriver`
 * client on this promise with:
 * 
 *     var started = startTestServer();
 *     driver.wait(started, 5 * 1000, 'Server should start within 5 seconds');
 *     driver.get(getServerUrl());
 * 
 *           Condition<T>|
 *           function(!WebDriver): T)} condition The condition to
 *     wait on, defined as a promise, condition object, or  a function to
 *     evaluate as a condition.
 *     out.
 *     with the first truthy value returned by the condition function, or
 *     rejected if the condition times out.
 * @template T
 * @param {?|(!Function|!PromiseLike<?>|?)} condition
 * @param {number=} opt_timeout
 * @param {string=} opt_message
 * @return {?}
 */
WebDriver.prototype.wait = function(condition, opt_timeout, opt_message) {};

/**
 * Schedules a command to make the driver sleep for the given amount of time.
 *     when the sleep has finished.
 * @param {number} ms
 * @return {?}
 */
WebDriver.prototype.sleep = function(ms) {};

/**
 * Schedules a command to retrieve they current window handle.
 *     resolved with the current window handle.
 * @return {?}
 */
WebDriver.prototype.getWindowHandle = function() {};

/**
 * Schedules a command to retrieve the current list of available window handles.
 *     be resolved with an array of window handles.
 * @return {?}
 */
WebDriver.prototype.getAllWindowHandles = function() {};

/**
 * Schedules a command to retrieve the current page's source. The page source
 * returned is a representation of the underlying DOM: do not expect it to be
 * formatted or escaped in the same way as the response sent from the web
 * server.
 *     resolved with the current page source.
 * @return {?}
 */
WebDriver.prototype.getPageSource = function() {};

/**
 * Schedules a command to close the current window.
 *     when this command has completed.
 * @return {?}
 */
WebDriver.prototype.close = function() {};

/**
 * Schedules a command to navigate to the given URL.
 *     when the document has finished loading.
 * @param {string} url
 * @return {?}
 */
WebDriver.prototype.get = function(url) {};

/**
 * Schedules a command to retrieve the URL of the current page.
 *     resolved with the current URL.
 * @return {?}
 */
WebDriver.prototype.getCurrentUrl = function() {};

/**
 * Schedules a command to retrieve the current page's title.
 *     resolved with the current page's title.
 * @return {?}
 */
WebDriver.prototype.getTitle = function() {};

/**
 * Schedule a command to find an element on the page. If the element cannot be
 * found, a {\@link bot.ErrorCode.NO_SUCH_ELEMENT} result will be returned
 * by the driver. Unlike other commands, this error cannot be suppressed. In
 * other words, scheduling a command to find an element doubles as an assert
 * that the element is present on the page. To test whether an element is
 * present on the page, use {\@link #findElements}.
 * 
 * The search criteria for an element may be defined using one of the
 * factories in the {\@link By} namespace, or as a short-hand
 * {\@link By.Hash} object. For example, the following two statements
 * are equivalent:
 * 
 *     var e1 = driver.findElement(By.id('foo'));
 *     var e2 = driver.findElement({id:'foo'});
 * 
 * You may also provide a custom locator function, which takes as input this
 * instance and returns a {\@link WebElement}, or a promise that will resolve
 * to a WebElement. If the returned promise resolves to an array of
 * WebElements, WebDriver will use the first element. For example, to find the
 * first visible link on a page, you could write:
 * 
 *     var link = driver.findElement(firstVisibleLink);
 * 
 *     function firstVisibleLink(driver) {
 *       var links = driver.findElements(By.tagName('a'));
 *       return promise.filter(links, function(link) {
 *         return link.isDisplayed();
 *       });
 *     }
 * 
 *     commands against the located element. If the element is not found, the
 *     element will be invalidated and all scheduled commands aborted.
 * @param {(!Function|?)} locator
 * @return {?}
 */
WebDriver.prototype.findElement = function(locator) {};

/**
 * Schedule a command to search for multiple elements on the page.
 * 
 *     promise that will resolve to an array of WebElements.
 * @param {(!Function|?)} locator
 * @return {?}
 */
WebDriver.prototype.findElements = function(locator) {};

/**
 * Schedule a command to take a screenshot. The driver makes a best effort to
 * return a screenshot of the following, in order of preference:
 * 
 * 1. Entire page
 * 2. Current window
 * 3. Visible portion of the current frame
 * 4. The entire display containing the browser
 * 
 *     resolved to the screenshot as a base-64 encoded PNG.
 * @return {?}
 */
WebDriver.prototype.takeScreenshot = function() {};

/**
 *     instance.
 * @return {?}
 */
WebDriver.prototype.manage = function() {};

/**
 *     instance.
 * @return {?}
 */
WebDriver.prototype.navigate = function() {};

/**
 *     this instance.
 * @return {?}
 */
WebDriver.prototype.switchTo = function() {};
/**
 * @extends {promise.IThenable}
 * @record
 * @struct
 */
function ThenableWebDriver() {}
/**
 * @record
 * @struct
 */
function IWebElementId() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function IWebElement() {}

/**
 * Schedules a command to click on this element.
 *     the click command has completed.
 * @return {?}
 */
IWebElement.prototype.click = function() {};

/**
 * Schedules a command to type a sequence on the DOM element represented by
 * this instance.
 * 
 * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
 * processed in the key sequence, that key state is toggled until one of the
 * following occurs:
 * 
 * - The modifier key is encountered again in the sequence. At this point the
 *   state of the key is toggled (along with the appropriate keyup/down
 *   events).
 * - The {\@link input.Key.NULL} key is encountered in the sequence. When
 *   this key is encountered, all modifier keys current in the down state are
 *   released (with accompanying keyup events). The NULL key can be used to
 *   simulate common keyboard shortcuts:
 * 
 *         element.sendKeys('text was',
 *                          Key.CONTROL, 'a', Key.NULL,
 *                          'now text is');
 *         // Alternatively:
 *         element.sendKeys('text was',
 *                          Key.chord(Key.CONTROL, 'a'),
 *                          'now text is');
 * 
 * - The end of the key sequence is encountered. When there are no more keys
 *   to type, all depressed modifier keys are released (with accompanying
 *   keyup events).
 * 
 * If this element is a file input ({\@code <input type='file'>}), the
 * specified key sequence should specify the path to the file to attach to
 * the element. This is analogous to the user clicking 'Browse...' and entering
 * the path into the file select dialog.
 * 
 *     var form = driver.findElement(By.css('form'));
 *     var element = form.findElement(By.css('input[type=file]'));
 *     element.sendKeys('/path/to/file.txt');
 *     form.submit();
 * 
 * For uploads to function correctly, the entered path must reference a file
 * on the _browser's_ machine, not the local machine running this script. When
 * running against a remote Selenium server, a {\@link input.FileDetector}
 * may be used to transparently copy files to the remote machine before
 * attempting to upload them in the browser.
 * 
 * __Note:__ On browsers where native keyboard events are not supported
 * (e.g. Firefox on OS X), key events will be synthesized. Special
 * punctuation keys will be synthesized according to a standard QWERTY en-us
 * keyboard layout.
 * 
 *     sequence of keys to type. Number keys may be referenced numerically or
 *     by string (1 or '1'). All arguments will be joined into a single
 *     sequence.
 *     keys have been typed.
 * @param {...(string|number|?)} var_args
 * @return {?}
 */
IWebElement.prototype.sendKeys = function(var_args) {};

/**
 * Schedules a command to query for the tag/node name of this element.
 *     element's tag name.
 * @return {?}
 */
IWebElement.prototype.getTagName = function() {};

/**
 * Schedules a command to query for the computed style of the element
 * represented by this instance. If the element inherits the named style from
 * its parent, the parent will be queried for its value.  Where possible, color
 * values will be converted to their hex representation (e.g. #00ff00 instead of
 * rgb(0, 255, 0)).
 * <p/>
 * <em>Warning:</em> the value returned will be as the browser interprets it, so
 * it may be tricky to form a proper assertion.
 * 
 *     up.
 *     requested CSS value.
 * @param {string} cssStyleProperty
 * @return {?}
 */
IWebElement.prototype.getCssValue = function(cssStyleProperty) {};

/**
 * Schedules a command to query for the value of the given attribute of the
 * element. Will return the current value even if it has been modified after the
 * page has been loaded. More exactly, this method will return the value of the
 * given attribute, unless that attribute is not present, in which case the
 * value of the property with the same name is returned. If neither value is
 * set, null is returned. The 'style' attribute is converted as best can be to a
 * text representation with a trailing semi-colon. The following are deemed to
 * be 'boolean' attributes and will be returned as thus:
 * 
 * <p>async, autofocus, autoplay, checked, compact, complete, controls, declare,
 * defaultchecked, defaultselected, defer, disabled, draggable, ended,
 * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
 * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
 * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
 * selected, spellcheck, truespeed, willvalidate
 * 
 * <p>Finally, the following commonly mis-capitalized attribute/property names
 * are evaluated as expected:
 * <ul>
 *   <li>'class'
 *   <li>'readonly'
 * </ul>
 *     attribute's value.
 * @param {string} attributeName
 * @return {?}
 */
IWebElement.prototype.getAttribute = function(attributeName) {};

/**
 * Get the visible (i.e. not hidden by CSS) innerText of this element, including
 * sub-elements, without any leading or trailing whitespace.
 *     element's visible text.
 * @return {?}
 */
IWebElement.prototype.getText = function() {};

/**
 * Schedules a command to compute the size of this element's bounding box, in
 * pixels.
 *     element's size as a {\@code {width:number, height:number}} object.
 * @return {?}
 */
IWebElement.prototype.getSize = function() {};

/**
 * Schedules a command to compute the location of this element in page space.
 *     element's location as a {\@code {x:number, y:number}} object.
 * @return {?}
 */
IWebElement.prototype.getLocation = function() {};

/**
 * Schedules a command to query whether the DOM element represented by this
 * instance is enabled, as dicted by the {\@code disabled} attribute.
 *     whether this element is currently enabled.
 * @return {?}
 */
IWebElement.prototype.isEnabled = function() {};

/**
 * Schedules a command to query whether this element is selected.
 *     whether this element is currently selected.
 * @return {?}
 */
IWebElement.prototype.isSelected = function() {};

/**
 * Schedules a command to submit the form containing this element (or this
 * element if it is a FORM element). This command is a no-op if the element is
 * not contained in a form.
 *     the form has been submitted.
 * @return {?}
 */
IWebElement.prototype.submit = function() {};

/**
 * Schedules a command to clear the {\@code value} of this element. This command
 * has no effect if the underlying DOM element is neither a text INPUT element
 * nor a TEXTAREA element.
 *     the element has been cleared.
 * @return {?}
 */
IWebElement.prototype.clear = function() {};

/**
 * Schedules a command to test whether this element is currently displayed.
 *     whether this element is currently visible on the page.
 * @return {?}
 */
IWebElement.prototype.isDisplayed = function() {};

/**
 *     that resolves to this element's JSON representation as defined by the
 *     WebDriver wire protocol.
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol
 * @return {?}
 */
IWebElement.prototype.getId = function() {};
/**
 * @record
 * @struct
 */
function IWebElementFinders() {}

/**
 * Schedule a command to find a descendant of this element. If the element
 * cannot be found, a {\@code bot.ErrorCode.NO_SUCH_ELEMENT} result will
 * be returned by the driver. Unlike other commands, this error cannot be
 * suppressed. In other words, scheduling a command to find an element doubles
 * as an assert that the element is present on the page. To test whether an
 * element is present on the page, use {\@code #findElements}.
 * 
 * <p>The search criteria for an element may be defined using one of the
 * factories in the {\@link By} namespace, or as a short-hand
 * {\@link By.Hash} object. For example, the following two statements
 * are equivalent:
 * <code><pre>
 * var e1 = element.findElement(By.id('foo'));
 * var e2 = element.findElement({id:'foo'});
 * </pre></code>
 * 
 * <p>You may also provide a custom locator function, which takes as input
 * this WebDriver instance and returns a {\@link WebElement}, or a
 * promise that will resolve to a WebElement. For example, to find the first
 * visible link on a page, you could write:
 * <code><pre>
 * var link = element.findElement(firstVisibleLink);
 * 
 * function firstVisibleLink(element) {
 *   var links = element.findElements(By.tagName('a'));
 *   return promise.filter(links, function(link) {
 *     return links.isDisplayed();
 *   }).then(function(visibleLinks) {
 *     return visibleLinks[0];
 *   });
 * }
 * </pre></code>
 * 
 *     locator strategy to use when searching for the element.
 *     commands against the located element. If the element is not found, the
 *     element will be invalidated and all scheduled commands aborted.
 * @param {(!Function|?)} locator
 * @return {?}
 */
IWebElementFinders.prototype.findElement = function(locator) {};

/**
 * Schedules a command to find all of the descendants of this element that
 * match the given search criteria.
 * 
 *     locator strategy to use when searching for the elements.
 *     promise that will resolve to an array of WebElements.
 * @param {(!Function|?)} locator
 * @return {?}
 */
IWebElementFinders.prototype.findElements = function(locator) {};
/**
 * @record
 * @struct
 */
function Serializable() {}

/**
 * Returns either this instance's serialized represention, if immediately
 * available, or a promise for its serialized representation. This function is
 * conceptually equivalent to objects that have a {\@code toJSON()} property,
 * except the serialize() result may be a promise or an object containing a
 * promise (which are not directly JSON friendly).
 * 
 * @return {?}
 */
Serializable.prototype.serialize = function() {};

/**
 * @constructor
 * @struct
 *     the underlying DOM element.
 * @param {?} driver
 * @param {(string|?)} id
 */
function WebElement(driver, id) {}

/**
 * @param {string} id
 * @param {boolean=} opt_noLegacy
 * @return {!Object}
 */
WebElement.buildId = function(id, opt_noLegacy) {};

/**
 * Extracts the encoded WebElement ID from the object.
 * 
 * @throws {TypeError} if the object is not a valid encoded ID.
 * @param {?} obj
 * @return {string}
 */
WebElement.extractId = function(obj) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
WebElement.isId = function(obj) {};

/**
 * Compares two WebElements for equality.
 * 
 *     resolved to whether the two WebElements are equal.
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
WebElement.equals = function(a, b) {};

/**
 * @return {?}
 */
WebElement.prototype.getDriver = function() {};

/**
 *     the server-assigned opaque ID assigned to this element.
 * @return {?}
 */
WebElement.prototype.getId = function() {};

/**
 * Schedule a command to find a descendant of this element. If the element
 * cannot be found, a {\@link bot.ErrorCode.NO_SUCH_ELEMENT} result will
 * be returned by the driver. Unlike other commands, this error cannot be
 * suppressed. In other words, scheduling a command to find an element doubles
 * as an assert that the element is present on the page. To test whether an
 * element is present on the page, use {\@link #findElements}.
 * 
 * The search criteria for an element may be defined using one of the
 * factories in the {\@link By} namespace, or as a short-hand
 * {\@link By.Hash} object. For example, the following two statements
 * are equivalent:
 * 
 *     var e1 = element.findElement(By.id('foo'));
 *     var e2 = element.findElement({id:'foo'});
 * 
 * You may also provide a custom locator function, which takes as input
 * this WebDriver instance and returns a {\@link WebElement}, or a
 * promise that will resolve to a WebElement. For example, to find the first
 * visible link on a page, you could write:
 * 
 *     var link = element.findElement(firstVisibleLink);
 * 
 *     function firstVisibleLink(element) {
 *       var links = element.findElements(By.tagName('a'));
 *       return promise.filter(links, function(link) {
 *         return links.isDisplayed();
 *       }).then(function(visibleLinks) {
 *         return visibleLinks[0];
 *       });
 *     }
 * 
 *     searching for the element.
 *     commands against the located element. If the element is not found, the
 *     element will be invalidated and all scheduled commands aborted.
 * @param {(!Function|?)} locator
 * @return {?}
 */
WebElement.prototype.findElement = function(locator) {};

/**
 * Schedules a command to find all of the descendants of this element that
 * match the given search criteria.
 * 
 *     searching for the element.
 *     promise that will resolve to an array of WebElements.
 * @param {(!Function|?)} locator
 * @return {?}
 */
WebElement.prototype.findElements = function(locator) {};

/**
 * Schedules a command to click on this element.
 *     when the click command has completed.
 * @return {?}
 */
WebElement.prototype.click = function() {};

/**
 * Schedules a command to type a sequence on the DOM element represented by this
 * promsieinstance.
 * 
 * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
 * processed in the keysequence, that key state is toggled until one of the
 * following occurs:
 * 
 * - The modifier key is encountered again in the sequence. At this point the
 *   state of the key is toggled (along with the appropriate keyup/down events).
 * - The {\@link Key.NULL} key is encountered in the sequence. When
 *   this key is encountered, all modifier keys current in the down state are
 *   released (with accompanying keyup events). The NULL key can be used to
 *   simulate common keyboard shortcuts:
 * 
 *         element.sendKeys('text was',
 *                          Key.CONTROL, 'a', Key.NULL,
 *                          'now text is');
 *         // Alternatively:
 *         element.sendKeys('text was',
 *                          Key.chord(Key.CONTROL, 'a'),
 *                          'now text is');
 * 
 * - The end of the keysequence is encountered. When there are no more keys
 *   to type, all depressed modifier keys are released (with accompanying keyup
 *   events).
 * 
 * If this element is a file input ({\@code <input type='file'>}), the
 * specified key sequence should specify the path to the file to attach to
 * the element. This is analgous to the user clicking 'Browse...' and entering
 * the path into the file select dialog.
 * 
 *     var form = driver.findElement(By.css('form'));
 *     var element = form.findElement(By.css('input[type=file]'));
 *     element.sendKeys('/path/to/file.txt');
 *     form.submit();
 * 
 * For uploads to function correctly, the entered path must reference a file
 * on the _browser's_ machine, not the local machine running this script. When
 * running against a remote Selenium server, a {\@link FileDetector}
 * may be used to transparently copy files to the remote machine before
 * attempting to upload them in the browser.
 * 
 * __Note:__ On browsers where native keyboard events are not supported
 * (e.g. Firefox on OS X), key events will be synthesized. Special
 * punctionation keys will be synthesized according to a standard QWERTY en-us
 * keyboard layout.
 * 
 *     of keys to type. All arguments will be joined into a single sequence.
 *     when all keys have been typed.
 * @param {...(string|number|?)} var_args
 * @return {?}
 */
WebElement.prototype.sendKeys = function(var_args) {};

/**
 * Schedules a command to query for the tag/node name of this element.
 *     resolved with the element's tag name.
 * @return {?}
 */
WebElement.prototype.getTagName = function() {};

/**
 * Schedules a command to query for the computed style of the element
 * represented by this instance. If the element inherits the named style from
 * its parent, the parent will be queried for its value.  Where possible, color
 * values will be converted to their hex representation (e.g. #00ff00 instead of
 * rgb(0, 255, 0)).
 * 
 * _Warning:_ the value returned will be as the browser interprets it, so
 * it may be tricky to form a proper assertion.
 * 
 *     up.
 *     resolved with the requested CSS value.
 * @param {string} cssStyleProperty
 * @return {?}
 */
WebElement.prototype.getCssValue = function(cssStyleProperty) {};

/**
 * Schedules a command to query for the value of the given attribute of the
 * element. Will return the current value, even if it has been modified after
 * the page has been loaded. More exactly, this method will return the value of
 * the given attribute, unless that attribute is not present, in which case the
 * value of the property with the same name is returned. If neither value is
 * set, null is returned (for example, the 'value' property of a textarea
 * element). The 'style' attribute is converted as best can be to a
 * text representation with a trailing semi-colon. The following are deemed to
 * be 'boolean' attributes and will return either 'true' or null:
 * 
 * async, autofocus, autoplay, checked, compact, complete, controls, declare,
 * defaultchecked, defaultselected, defer, disabled, draggable, ended,
 * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
 * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
 * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
 * selected, spellcheck, truespeed, willvalidate
 * 
 * Finally, the following commonly mis-capitalized attribute/property names
 * are evaluated as expected:
 * 
 * - 'class'
 * - 'readonly'
 * 
 *     resolved with the attribute's value. The returned value will always be
 *     either a string or null.
 * @param {string} attributeName
 * @return {?}
 */
WebElement.prototype.getAttribute = function(attributeName) {};

/**
 * Get the visible (i.e. not hidden by CSS) innerText of this element, including
 * sub-elements, without any leading or trailing whitespace.
 *     resolved with the element's visible text.
 * @return {?}
 */
WebElement.prototype.getText = function() {};

/**
 * Schedules a command to compute the size of this element's bounding box, in
 * pixels.
 *     promise that will be resolved with the element's size as a
 *     {\@code {width:number, height:number}} object.
 * @return {?}
 */
WebElement.prototype.getSize = function() {};

/**
 * Schedules a command to compute the location of this element in page space.
 *     will be resolved to the element's location as a
 *     {\@code {x:number, y:number}} object.
 * @return {?}
 */
WebElement.prototype.getLocation = function() {};

/**
 * Schedules a command to query whether the DOM element represented by this
 * instance is enabled, as dicted by the {\@code disabled} attribute.
 *     resolved with whether this element is currently enabled.
 * @return {?}
 */
WebElement.prototype.isEnabled = function() {};

/**
 * Schedules a command to query whether this element is selected.
 *     resolved with whether this element is currently selected.
 * @return {?}
 */
WebElement.prototype.isSelected = function() {};

/**
 * Schedules a command to submit the form containing this element (or this
 * element if it is a FORM element). This command is a no-op if the element is
 * not contained in a form.
 *     when the form has been submitted.
 * @return {?}
 */
WebElement.prototype.submit = function() {};

/**
 * Schedules a command to clear the `value` of this element. This command has
 * no effect if the underlying DOM element is neither a text INPUT element
 * nor a TEXTAREA element.
 *     when the element has been cleared.
 * @return {?}
 */
WebElement.prototype.clear = function() {};

/**
 * Schedules a command to test whether this element is currently displayed.
 *     resolved with whether this element is currently visible on the page.
 * @return {?}
 */
WebElement.prototype.isDisplayed = function() {};

/**
 * Take a screenshot of the visible region encompassed by this element's
 * bounding rectangle.
 * 
 *     element should be scrolled into view before taking a screenshot.
 *     Defaults to false.
 *     resolved to the screenshot as a base-64 encoded PNG.
 * @param {boolean=} opt_scroll
 * @return {?}
 */
WebElement.prototype.takeScreenshot = function(opt_scroll) {};

/**
 * @override
 * @return {?}
 */
WebElement.prototype.serialize = function() {};

/**
 * @constructor
 * @struct
 *     element.
 *     that will resolve to the promised element.
 * @param {?} driver
 * @param {?} el
 */
function WebElementPromise(driver, el) {}

/**
 * Registers listeners for when this instance is resolved.
 * 
 * Registers listeners for when this instance is resolved.
 * 
 * @template R
 * @param {?=} opt_callback The
 *     function to call if this promise is successfully resolved. The function
 *     should expect a single argument: the promise's resolved value.
 * @param {?=} opt_errback The
 *     function to call if this promise is rejected. The function should expect
 *     a single argument: the rejection reason.
 * @return {?} A new promise which will be
 *     resolved with the result of the invoked callback.
 */
WebElementPromise.prototype.then = function(opt_callback, opt_errback) {};

/**
 * Registers a listener for when this promise is rejected. This is synonymous
 * with the {\@code catch} clause in a synchronous API:
 * 
 *     // Synchronous API:
 *     try {
 *       doSynchronousWork();
 *     } catch (ex) {
 *       console.error(ex);
 *     }
 * 
 *     // Asynchronous promise API:
 *     doAsynchronousWork().catch(function(ex) {
 *       console.error(ex);
 *     });
 * 
 *     function to call if this promise is rejected. The function should
 *     expect a single argument: the rejection reason.
 *     resolved with the result of the invoked callback.
 * @template R
 * @param {!Function} errback
 * @return {?}
 */
WebElementPromise.prototype.catch = function(errback) {};

/**
 * @constructor
 * @struct
 *     capabilities.
 * @param {string} id
 * @param {(!Object|?)} capabilities
 */
function Session(id, capabilities) {}

/**
 * @return {string}
 */
Session.prototype.getId = function() {};

/**
 * @return {?}
 */
Session.prototype.getCapabilities = function() {};

/**
 * Retrieves the value of a specific capability.
 * @param {string} key
 * @return {?}
 */
Session.prototype.getCapability = function(key) {};

/**
 * Returns the JSON representation of this object, which is just the string
 * session ID.
 * @return {string}
 */
Session.prototype.toJSON = function() {};
