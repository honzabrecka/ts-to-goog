/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/openjscad/index.d.ts:
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "three"
/** @const */
tsickle_declare_module.three = {};
 /** @type {{fromCSG: function(!CSG, ?): {colorMesh: ?, wireframe: ?, boundLen: number}, getGeometryVertex: function(?, ?): number}} */
tsickle_declare_module.three.CSG;
/**
 * @record
 * @struct
 */
tsickle_declare_module.three.ICanvasRendererOptions = function() {};
 /** @type {!HTMLCanvasElement} */
tsickle_declare_module.three.ICanvasRendererOptions.prototype.canvas;
 /** @type {boolean} */
tsickle_declare_module.three.ICanvasRendererOptions.prototype.alpha;
/** @const */
var OpenJsCad = {};
/**
 * @record
 * @struct
 */
OpenJsCad.ILog = function() {};

/* TODO: CallSignature: OpenJsCad */
 /** @type {number} */
OpenJsCad.ILog.prototype.prevLogTime;
 /** @type {!OpenJsCad.ILog} */
OpenJsCad.log;
/**
 * @record
 * @struct
 */
OpenJsCad.IViewerOptions = function() {};
 /** @type {boolean} */
OpenJsCad.IViewerOptions.prototype.drawLines;
 /** @type {boolean} */
OpenJsCad.IViewerOptions.prototype.drawFaces;
 /** @type {!Array<number>} */
OpenJsCad.IViewerOptions.prototype.color;
 /** @type {number} */
OpenJsCad.IViewerOptions.prototype.bgColor;
 /** @type {boolean} */
OpenJsCad.IViewerOptions.prototype.noWebGL;
/**
 * @extends {OpenJsCad.IViewerOptions}
 * @record
 * @struct
 */
OpenJsCad.ProcessorOptions = function() {};
 /** @type {boolean} */
OpenJsCad.ProcessorOptions.prototype.verbose;
 /** @type {number} */
OpenJsCad.ProcessorOptions.prototype.viewerwidth;
 /** @type {number} */
OpenJsCad.ProcessorOptions.prototype.viewerheight;
 /** @type {number} */
OpenJsCad.ProcessorOptions.prototype.viewerheightratio;

/**
 * @constructor
 * @struct
 * @param {?} containerElm
 * @param {?} size
 * @param {!OpenJsCad.IViewerOptions} options
 */
OpenJsCad.Viewer = function(containerElm, size, options) {};
 /** @type {?} */
OpenJsCad.Viewer.prototype.perspective;
 /** @type {?} */
OpenJsCad.Viewer.prototype.drawOptions;
 /** @type {?} */
OpenJsCad.Viewer.prototype.size;
 /** @type {?} */
OpenJsCad.Viewer.prototype.defaultColor_;
 /** @type {?} */
OpenJsCad.Viewer.prototype.bgColor_;
 /** @type {?} */
OpenJsCad.Viewer.prototype.containerElm_;
 /** @type {?} */
OpenJsCad.Viewer.prototype.scene_;
 /** @type {?} */
OpenJsCad.Viewer.prototype.camera_;
 /** @type {?} */
OpenJsCad.Viewer.prototype.controls_;
 /** @type {?} */
OpenJsCad.Viewer.prototype.renderer_;
 /** @type {?} */
OpenJsCad.Viewer.prototype.canvas;
 /** @type {?} */
OpenJsCad.Viewer.prototype.pauseRender_;
 /** @type {?} */
OpenJsCad.Viewer.prototype.requestID_;

/**
 * @param {?} drawAxes
 * @param {?} axLen
 * @return {void}
 */
OpenJsCad.Viewer.prototype.createScene = function(drawAxes, axLen) {};

/**
 * @return {void}
 */
OpenJsCad.Viewer.prototype.createCamera = function() {};

/**
 * @param {?} canvas
 * @return {void}
 */
OpenJsCad.Viewer.prototype.createControls = function(canvas) {};

/**
 * @return {boolean}
 */
OpenJsCad.Viewer.prototype.webGLAvailable = function() {};

/**
 * @param {?} bool_noWebGL
 * @return {void}
 */
OpenJsCad.Viewer.prototype.createRenderer = function(bool_noWebGL) {};

/**
 * @return {void}
 */
OpenJsCad.Viewer.prototype.render = function() {};

/**
 * @return {void}
 */
OpenJsCad.Viewer.prototype.animate = function() {};

/**
 * @return {void}
 */
OpenJsCad.Viewer.prototype.cancelAnimate = function() {};

/**
 * @param {?} bool_noWebGL
 * @return {void}
 */
OpenJsCad.Viewer.prototype.refreshRenderer = function(bool_noWebGL) {};

/**
 * @param {?} axLen
 * @return {void}
 */
OpenJsCad.Viewer.prototype.drawAxes = function(axLen) {};

/**
 * @param {?} csg
 * @param {?} resetZoom
 * @return {void}
 */
OpenJsCad.Viewer.prototype.setCsg = function(csg, resetZoom) {};

/**
 * @return {void}
 */
OpenJsCad.Viewer.prototype.applyDrawOptions = function() {};

/**
 * @return {void}
 */
OpenJsCad.Viewer.prototype.clear = function() {};

/**
 * @param {?=} str
 * @return {!Array<?>}
 */
OpenJsCad.Viewer.prototype.getUserMeshes = function(str) {};

/**
 * @param {?} r
 * @return {void}
 */
OpenJsCad.Viewer.prototype.resetZoom = function(r) {};

/**
 * @return {void}
 */
OpenJsCad.Viewer.prototype.parseSizeParams = function() {};

/**
 * @return {void}
 */
OpenJsCad.Viewer.prototype.handleResize = function() {};

/**
 * @param {?} url
 * @param {?} baseurl
 * @return {?}
 */
OpenJsCad.makeAbsoluteUrl = function(url, baseurl) {};

/**
 * @return {boolean}
 */
OpenJsCad.isChrome = function() {};

/**
 * @param {?} mainParameters
 * @return {void}
 */
OpenJsCad.runMainInWorker = function(mainParameters) {};

/**
 * @param {?} result
 * @return {?}
 */
OpenJsCad.expandResultObjectArray = function(result) {};

/**
 * @param {?} result
 * @return {void}
 */
OpenJsCad.checkResult = function(result) {};

/**
 * @param {?} resultin
 * @return {?}
 */
OpenJsCad.resultToCompactBinary = function(resultin) {};

/**
 * @param {?} resultin
 * @return {?}
 */
OpenJsCad.resultFromCompactBinary = function(resultin) {};

/**
 * @param {?} script
 * @param {?} mainParameters
 * @param {?} debugging
 * @return {?}
 */
OpenJsCad.parseJsCadScriptSync = function(script, mainParameters, debugging) {};

/**
 * @param {?} script
 * @param {?} mainParameters
 * @param {?} options
 * @param {?} callback
 * @return {!Worker}
 */
OpenJsCad.parseJsCadScriptASync = function(script, mainParameters, options, callback) {};

/**
 * @return {!URL}
 */
OpenJsCad.getWindowURL = function() {};

/**
 * @param {?} txt
 * @return {string}
 */
OpenJsCad.textToBlobUrl = function(txt) {};

/**
 * @param {?} url
 * @return {void}
 */
OpenJsCad.revokeBlobUrl = function(url) {};

/**
 * @param {?} fileError
 * @param {?} operation
 * @return {void}
 */
OpenJsCad.FileSystemApiErrorHandler = function(fileError, operation) {};

/**
 * @return {void}
 */
OpenJsCad.AlertUserOfUncaughtExceptions = function() {};

/**
 * @param {?} script
 * @return {!Array<?>}
 */
OpenJsCad.getParamDefinitions = function(script) {};
/**
 * @record
 * @struct
 */
OpenJsCad.EventHandler = function() {};

/* TODO: CallSignature: OpenJsCad */
/**
 * @record
 * @struct
 */
OpenJsCad.ViewerSize = function() {};
 /** @type {string} */
OpenJsCad.ViewerSize.prototype.widthDefault;
 /** @type {string} */
OpenJsCad.ViewerSize.prototype.heightDefault;
 /** @type {number} */
OpenJsCad.ViewerSize.prototype.width;
 /** @type {number} */
OpenJsCad.ViewerSize.prototype.height;
 /** @type {number} */
OpenJsCad.ViewerSize.prototype.heightratio;

/**
 * @constructor
 * @struct
 * @param {!HTMLDivElement} containerdiv
 * @param {!OpenJsCad.ProcessorOptions=} options
 * @param {!OpenJsCad.EventHandler=} onchange
 */
OpenJsCad.Processor = function(containerdiv, options, onchange) {};
 /** @type {?} */
OpenJsCad.Processor.prototype.containerdiv;
 /** @type {?} */
OpenJsCad.Processor.prototype.options;
 /** @type {?} */
OpenJsCad.Processor.prototype.onchange;
 /** @type {?} */
OpenJsCad.Processor.widthDefault;
 /** @type {?} */
OpenJsCad.Processor.heightDefault;
 /** @type {?} */
OpenJsCad.Processor.prototype.viewerdiv;
 /** @type {?} */
OpenJsCad.Processor.prototype.viewer;
 /** @type {?} */
OpenJsCad.Processor.prototype.viewerSize;
 /** @type {?} */
OpenJsCad.Processor.prototype.processing;
 /** @type {?} */
OpenJsCad.Processor.prototype.currentObject;
 /** @type {?} */
OpenJsCad.Processor.prototype.hasValidCurrentObject;
 /** @type {?} */
OpenJsCad.Processor.prototype.hasOutputFile;
 /** @type {?} */
OpenJsCad.Processor.prototype.worker;
 /** @type {?} */
OpenJsCad.Processor.prototype.paramDefinitions;
 /** @type {?} */
OpenJsCad.Processor.prototype.paramControls;
 /** @type {?} */
OpenJsCad.Processor.prototype.script;
 /** @type {?} */
OpenJsCad.Processor.prototype.hasError;
 /** @type {?} */
OpenJsCad.Processor.prototype.debugging;
 /** @type {?} */
OpenJsCad.Processor.prototype.errordiv;
 /** @type {?} */
OpenJsCad.Processor.prototype.errorpre;
 /** @type {?} */
OpenJsCad.Processor.prototype.statusdiv;
 /** @type {?} */
OpenJsCad.Processor.prototype.controldiv;
 /** @type {?} */
OpenJsCad.Processor.prototype.statusspan;
 /** @type {?} */
OpenJsCad.Processor.prototype.statusbuttons;
 /** @type {?} */
OpenJsCad.Processor.prototype.abortbutton;
 /** @type {?} */
OpenJsCad.Processor.prototype.renderedElementDropdown;
 /** @type {?} */
OpenJsCad.Processor.prototype.formatDropdown;
 /** @type {?} */
OpenJsCad.Processor.prototype.generateOutputFileButton;
 /** @type {?} */
OpenJsCad.Processor.prototype.downloadOutputFileLink;
 /** @type {?} */
OpenJsCad.Processor.prototype.parametersdiv;
 /** @type {?} */
OpenJsCad.Processor.prototype.parameterstable;
 /** @type {?} */
OpenJsCad.Processor.prototype.currentFormat;
 /** @type {?} */
OpenJsCad.Processor.prototype.filename;
 /** @type {?} */
OpenJsCad.Processor.prototype.currentObjects;
 /** @type {?} */
OpenJsCad.Processor.prototype.currentObjectIndex;
 /** @type {?} */
OpenJsCad.Processor.prototype.isFirstRender_;
 /** @type {?} */
OpenJsCad.Processor.prototype.outputFileDirEntry;
 /** @type {?} */
OpenJsCad.Processor.prototype.outputFileBlobUrl;

/**
 * @param {?} obj
 * @return {?}
 */
OpenJsCad.Processor.convertToSolid = function(obj) {};

/**
 * @param {?} option
 * @param {?} deflt
 * @return {?}
 */
OpenJsCad.Processor.prototype.cleanOption = function(option, deflt) {};

/**
 * @param {?} str
 * @return {boolean}
 */
OpenJsCad.Processor.prototype.toggleDrawOption = function(str) {};

/**
 * @param {?} str
 * @param {?} bool
 * @return {void}
 */
OpenJsCad.Processor.prototype.setDrawOption = function(str, bool) {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.handleResize = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.createElements = function() {};

/**
 * @return {string}
 */
OpenJsCad.Processor.prototype.getFilenameForRenderedObject = function() {};

/**
 * @param {?} obj
 * @return {void}
 */
OpenJsCad.Processor.prototype.setRenderedObjects = function(obj) {};

/**
 * @param {number} index
 * @return {void}
 */
OpenJsCad.Processor.prototype.setSelectedObjectIndex = function(index) {};

/**
 * @return {?}
 */
OpenJsCad.Processor.prototype.selectedFormat = function() {};

/**
 * @return {?}
 */
OpenJsCad.Processor.prototype.selectedFormatInfo = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.updateDownloadLink = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.clearViewer = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.abort = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.enableItems = function() {};

/**
 * @param {string} path
 * @return {void}
 */
OpenJsCad.Processor.prototype.setOpenJsCadPath = function(path) {};

/**
 * @param {?} lib
 * @return {void}
 */
OpenJsCad.Processor.prototype.addLibrary = function(lib) {};

/**
 * @param {string} txt
 * @return {void}
 */
OpenJsCad.Processor.prototype.setError = function(txt) {};

/**
 * @param {boolean} debugging
 * @return {void}
 */
OpenJsCad.Processor.prototype.setDebugging = function(debugging) {};

/**
 * @param {string} script
 * @param {string=} filename
 * @return {void}
 */
OpenJsCad.Processor.prototype.setJsCad = function(script, filename) {};

/**
 * @return {!Object}
 */
OpenJsCad.Processor.prototype.getParamValues = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.rebuildSolid = function() {};

/**
 * @return {boolean}
 */
OpenJsCad.Processor.prototype.hasSolid = function() {};

/**
 * @return {boolean}
 */
OpenJsCad.Processor.prototype.isProcessing = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.clearOutputFile = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.generateOutputFile = function() {};

/**
 * @return {?}
 */
OpenJsCad.Processor.prototype.currentObjectToBlob = function() {};

/**
 * @return {!Array<string>}
 */
OpenJsCad.Processor.prototype.supportedFormatsForCurrentObject = function() {};

/**
 * @param {?} format
 * @return {?}
 */
OpenJsCad.Processor.prototype.formatInfo = function(format) {};

/**
 * @return {string}
 */
OpenJsCad.Processor.prototype.downloadLinkTextForCurrentObject = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.generateOutputFileBlobUrl = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.generateOutputFileFileSystem = function() {};

/**
 * @return {void}
 */
OpenJsCad.Processor.prototype.createParamControls = function() {};
 /** @type {!Worker} */
Window.prototype.Worker;
 /** @type {!URL} */
Window.prototype.webkitURL;
 /** @type {?} */
Window.prototype.requestFileSystem;
 /** @type {?} */
Window.prototype.webkitRequestFileSystem;
/**
 * @record
 * @struct
 */
function IAMFStringOptions() {}
 /** @type {string} */
IAMFStringOptions.prototype.unit;
/**
 * @constructor
 * @struct
 */
function CxG() {}

/**
 * @return {string}
 */
CxG.prototype.toStlString = function() {};

/**
 * @return {void}
 */
CxG.prototype.toStlBinary = function() {};

/**
 * @param {!IAMFStringOptions=} AMFStringOptions
 * @return {void}
 */
CxG.prototype.toAMFString = function(AMFStringOptions) {};

/**
 * @return {!Array<!CxG>}
 */
CxG.prototype.getBounds = function() {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CxG}
 */
CxG.prototype.transform = function(matrix4x4) {};

/**
 * @param {!CSG.Plane} plane
 * @return {!CxG}
 */
CxG.prototype.mirrored = function(plane) {};

/**
 * @return {!CxG}
 */
CxG.prototype.mirroredX = function() {};

/**
 * @return {!CxG}
 */
CxG.prototype.mirroredY = function() {};

/**
 * @return {!CxG}
 */
CxG.prototype.mirroredZ = function() {};

/**
 * @param {!Array<number>|!CSG.Vector3D} v
 * @return {!CxG}
 */
CxG.prototype.translate = function(v) {};

/**
 * @param {!CSG.Vector3D} f
 * @return {!CxG}
 */
CxG.prototype.scale = function(f) {};

/**
 * @param {number} deg
 * @return {!CxG}
 */
CxG.prototype.rotateX = function(deg) {};

/**
 * @param {number} deg
 * @return {!CxG}
 */
CxG.prototype.rotateY = function(deg) {};

/**
 * @param {number} deg
 * @return {!CxG}
 */
CxG.prototype.rotateZ = function(deg) {};

/**
 * @param {!CSG.Vector3D} rotationCenter
 * @param {!CSG.Vector3D} rotationAxis
 * @param {number} degrees
 * @return {!CxG}
 */
CxG.prototype.rotate = function(rotationCenter, rotationAxis, degrees) {};

/**
 * @param {number} alpha
 * @param {number} beta
 * @param {number} gamma
 * @param {!Array<number>} position
 * @return {!CxG}
 */
CxG.prototype.rotateEulerAngles = function(alpha, beta, gamma, position) {};
/**
 * @record
 * @struct
 */
function ICenter() {}

/**
 * @param {!Array<string>} cAxes
 * @return {!CxG}
 */
ICenter.prototype.center = function(cAxes) {};
/**
 * @extends {CxG}
 * @implements {ICenter}
 * @constructor
 * @struct
 */
function CSG() {}
 /** @type {!Array<!CSG.Polygon>} */
CSG.prototype.polygons;
 /** @type {!CSG.Properties} */
CSG.prototype.properties;
 /** @type {boolean} */
CSG.prototype.isCanonicalized;
 /** @type {boolean} */
CSG.prototype.isRetesselated;
 /** @type {!Array<!CSG.Vector3D>} */
CSG.prototype.cachedBoundingBox;
 /** @type {number} */
CSG.defaultResolution2D;
 /** @type {number} */
CSG.defaultResolution3D;

/**
 * @param {!Array<!CSG.Polygon>} polygons
 * @return {!CSG}
 */
CSG.fromPolygons = function(polygons) {};

/**
 * @param {?} options
 * @return {!CSG}
 */
CSG.fromSlices = function(options) {};

/**
 * @param {?} obj
 * @return {!CSG}
 */
CSG.fromObject = function(obj) {};

/**
 * @param {?} bin
 * @return {!CSG}
 */
CSG.fromCompactBinary = function(bin) {};

/**
 * @return {!Array<!CSG.Polygon>}
 */
CSG.prototype.toPolygons = function() {};

/**
 * @param {!Array<!CSG>|!CSG} csg
 * @return {!CSG}
 */
CSG.prototype.union = function(csg) {};

/**
 * @param {!CSG} csg
 * @param {boolean=} retesselate
 * @param {boolean=} canonicalize
 * @return {!CSG}
 */
CSG.prototype.unionSub = function(csg, retesselate, canonicalize) {};

/**
 * @param {!CSG} csg
 * @return {!CSG}
 */
CSG.prototype.unionForNonIntersecting = function(csg) {};

/**
 * @param {!Array<!CSG>|!CSG} csg
 * @return {!CSG}
 */
CSG.prototype.subtract = function(csg) {};

/**
 * @param {!CSG} csg
 * @param {boolean} retesselate
 * @param {boolean} canonicalize
 * @return {!CSG}
 */
CSG.prototype.subtractSub = function(csg, retesselate, canonicalize) {};

/**
 * @param {!Array<!CSG>|!CSG} csg
 * @return {!CSG}
 */
CSG.prototype.intersect = function(csg) {};

/**
 * @param {!CSG} csg
 * @param {boolean=} retesselate
 * @param {boolean=} canonicalize
 * @return {!CSG}
 */
CSG.prototype.intersectSub = function(csg, retesselate, canonicalize) {};

/**
 * @return {!CSG}
 */
CSG.prototype.invert = function() {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG}
 */
CSG.prototype.transform1 = function(matrix4x4) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG}
 */
CSG.prototype.transform = function(matrix4x4) {};

/**
 * @return {string}
 */
CSG.prototype.toString = function() {};

/**
 * @param {number} radius
 * @param {number} resolution
 * @return {!CSG}
 */
CSG.prototype.expand = function(radius, resolution) {};

/**
 * @param {number} radius
 * @param {number} resolution
 * @return {!CSG}
 */
CSG.prototype.contract = function(radius, resolution) {};

/**
 * @param {!Array<number>} normal
 * @param {!Array<number>} point
 * @param {number} length
 * @return {!CSG}
 */
CSG.prototype.stretchAtPlane = function(normal, point, length) {};

/**
 * @param {number} radius
 * @param {number} resolution
 * @param {boolean} unionWithThis
 * @return {!CSG}
 */
CSG.prototype.expandedShell = function(radius, resolution, unionWithThis) {};

/**
 * @return {!CSG}
 */
CSG.prototype.canonicalized = function() {};

/**
 * @return {!CSG}
 */
CSG.prototype.reTesselated = function() {};

/**
 * @return {!Array<!CSG.Vector3D>}
 */
CSG.prototype.getBounds = function() {};

/**
 * @param {!CSG} csg
 * @return {boolean}
 */
CSG.prototype.mayOverlap = function(csg) {};

/**
 * @param {!CSG.Plane} plane
 * @return {!CSG}
 */
CSG.prototype.cutByPlane = function(plane) {};

/**
 * @param {!CSG.Connector} myConnector
 * @param {!CSG.Connector} otherConnector
 * @param {boolean} mirror
 * @param {number} normalrotation
 * @return {!CSG}
 */
CSG.prototype.connectTo = function(myConnector, otherConnector, mirror, normalrotation) {};

/**
 * @param {!CSG.Polygon.Shared} shared
 * @return {!CSG}
 */
CSG.prototype.setShared = function(shared) {};

/**
 * @param {?} args
 * @return {!CSG}
 */
CSG.prototype.setColor = function(args) {};

/**
 * @return {{class: string, numPolygons: number, numVerticesPerPolygon: !Uint32Array, polygonPlaneIndexes: !Uint32Array, polygonSharedIndexes: !Uint32Array, polygonVertices: !Uint32Array, vertexData: !Float64Array, planeData: !Float64Array, shared: !Array<!CSG.Polygon.Shared>}}
 */
CSG.prototype.toCompactBinary = function() {};

/**
 * @param {?} cuberadius
 * @return {!CSG}
 */
CSG.prototype.toPointCloud = function(cuberadius) {};

/**
 * @return {?}
 */
CSG.prototype.getTransformationAndInverseTransformationToFlatLying = function() {};

/**
 * @return {?}
 */
CSG.prototype.getTransformationToFlatLying = function() {};

/**
 * @return {!CSG}
 */
CSG.prototype.lieFlat = function() {};

/**
 * @param {!CSG.OrthoNormalBasis} orthobasis
 * @return {!CAG}
 */
CSG.prototype.projectToOrthoNormalBasis = function(orthobasis) {};

/**
 * @param {!CSG.OrthoNormalBasis} orthobasis
 * @return {!CAG}
 */
CSG.prototype.sectionCut = function(orthobasis) {};

/**
 * @return {!CSG}
 */
CSG.prototype.fixTJunctions = function() {};

/**
 * @return {!Array<?>}
 */
CSG.prototype.toTriangles = function() {};

/**
 * @param {?} features
 * @return {?}
 */
CSG.prototype.getFeatures = function(features) {};

/**
 * @param {!Array<string>} cAxes
 * @return {!CxG}
 */
CSG.prototype.center = function(cAxes) {};

/**
 * @return {!Blob}
 */
CSG.prototype.toX3D = function() {};

/**
 * @return {!Blob}
 */
CSG.prototype.toStlBinary = function() {};

/**
 * @return {string}
 */
CSG.prototype.toStlString = function() {};

/**
 * @param {!IAMFStringOptions} m
 * @return {!Blob}
 */
CSG.prototype.toAMFString = function(m) {};

/**
 * @param {?} a
 * @param {?} b
 * @return {number}
 */
CSG.fnNumberSort = function(a, b) {};

/**
 * @param {?} options
 * @param {?} optionname
 * @param {?} defaultvalue
 * @return {?}
 */
CSG.parseOption = function(options, optionname, defaultvalue) {};

/**
 * @param {?} options
 * @param {?} optionname
 * @param {?} defaultvalue
 * @return {!CSG.Vector3D}
 */
CSG.parseOptionAs3DVector = function(options, optionname, defaultvalue) {};

/**
 * @param {?} options
 * @param {?} optionname
 * @param {?} defaultvalue
 * @return {?}
 */
CSG.parseOptionAs3DVectorList = function(options, optionname, defaultvalue) {};

/**
 * @param {?} options
 * @param {?} optionname
 * @param {?} defaultvalue
 * @return {?}
 */
CSG.parseOptionAs2DVector = function(options, optionname, defaultvalue) {};

/**
 * @param {?} options
 * @param {?} optionname
 * @param {?} defaultvalue
 * @return {?}
 */
CSG.parseOptionAsFloat = function(options, optionname, defaultvalue) {};

/**
 * @param {?} options
 * @param {?} optionname
 * @param {?} defaultvalue
 * @return {?}
 */
CSG.parseOptionAsInt = function(options, optionname, defaultvalue) {};

/**
 * @param {?} options
 * @param {?} optionname
 * @param {?} defaultvalue
 * @return {?}
 */
CSG.parseOptionAsBool = function(options, optionname, defaultvalue) {};

/**
 * @param {?} options
 * @return {!CSG}
 */
CSG.cube = function(options) {};

/**
 * @param {?} options
 * @return {!CSG}
 */
CSG.sphere = function(options) {};

/**
 * @param {?} options
 * @return {!CSG}
 */
CSG.cylinder = function(options) {};

/**
 * @param {?} options
 * @return {!CSG}
 */
CSG.roundedCylinder = function(options) {};

/**
 * @param {?} options
 * @return {!CSG}
 */
CSG.roundedCube = function(options) {};

/**
 * polyhedron accepts openscad style arguments. I.e. define face vertices clockwise looking from outside
 * @param {?} options
 * @return {!CSG}
 */
CSG.polyhedron = function(options) {};

/**
 * @param {?} n
 * @return {boolean}
 */
CSG.IsFloat = function(n) {};

/**
 * @param {?} a
 * @param {?} b
 * @param {?} c
 * @param {?} d
 * @param {?} u
 * @param {?} v
 * @return {!Array<number>}
 */
CSG.solve2Linear = function(a, b, c, d, u, v) {};

/**
 * @constructor
 * @struct
 * @param {!CSG.Vector3D|!CSG.Vector2D|!Array<number>|number} v3_or_v2_or_x
 * @param {number=} y
 * @param {number=} z
 */
CSG.Vector3D = function(v3_or_v2_or_x, y, z) {};
 /** @type {number} */
CSG.Vector3D.prototype.x;
 /** @type {number} */
CSG.Vector3D.prototype.y;
 /** @type {number} */
CSG.Vector3D.prototype.z;

/**
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.Create = function(x, y, z) {};

/**
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.clone = function() {};

/**
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.negated = function() {};

/**
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.abs = function() {};

/**
 * @param {!CSG.Vector3D} a
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.plus = function(a) {};

/**
 * @param {!CSG.Vector3D} a
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.minus = function(a) {};

/**
 * @param {number} a
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.times = function(a) {};

/**
 * @param {number} a
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.dividedBy = function(a) {};

/**
 * @param {!CSG.Vector3D} a
 * @return {number}
 */
CSG.Vector3D.prototype.dot = function(a) {};

/**
 * @param {!CSG.Vector3D} a
 * @param {number} t
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.lerp = function(a, t) {};

/**
 * @return {number}
 */
CSG.Vector3D.prototype.lengthSquared = function() {};

/**
 * @return {number}
 */
CSG.Vector3D.prototype.length = function() {};

/**
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.unit = function() {};

/**
 * @param {!CSG.Vector3D} a
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.cross = function(a) {};

/**
 * @param {!CSG.Vector3D} a
 * @return {number}
 */
CSG.Vector3D.prototype.distanceTo = function(a) {};

/**
 * @param {!CSG.Vector3D} a
 * @return {number}
 */
CSG.Vector3D.prototype.distanceToSquared = function(a) {};

/**
 * @param {!CSG.Vector3D} a
 * @return {boolean}
 */
CSG.Vector3D.prototype.equals = function(a) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.multiply4x4 = function(matrix4x4) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.transform = function(matrix4x4) {};

/**
 * @return {string}
 */
CSG.Vector3D.prototype.toString = function() {};

/**
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.randomNonParallelVector = function() {};

/**
 * @param {!CSG.Vector3D} p
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.min = function(p) {};

/**
 * @param {!CSG.Vector3D} p
 * @return {!CSG.Vector3D}
 */
CSG.Vector3D.prototype.max = function(p) {};

/**
 * @return {string}
 */
CSG.Vector3D.prototype.toStlString = function() {};

/**
 * @return {string}
 */
CSG.Vector3D.prototype.toAMFString = function() {};

/**
 * @constructor
 * @struct
 * @param {!CSG.Vector3D} pos
 */
CSG.Vertex = function(pos) {};
 /** @type {!CSG.Vector3D} */
CSG.Vertex.prototype.pos;
 /** @type {number} */
CSG.Vertex.prototype.tag;

/**
 * @param {?} obj
 * @return {!CSG.Vertex}
 */
CSG.Vertex.fromObject = function(obj) {};

/**
 * @return {!CSG.Vertex}
 */
CSG.Vertex.prototype.flipped = function() {};

/**
 * @return {number}
 */
CSG.Vertex.prototype.getTag = function() {};

/**
 * @param {!CSG.Vertex} other
 * @param {number} t
 * @return {!CSG.Vertex}
 */
CSG.Vertex.prototype.interpolate = function(other, t) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Vertex}
 */
CSG.Vertex.prototype.transform = function(matrix4x4) {};

/**
 * @return {string}
 */
CSG.Vertex.prototype.toString = function() {};

/**
 * @return {string}
 */
CSG.Vertex.prototype.toStlString = function() {};

/**
 * @return {string}
 */
CSG.Vertex.prototype.toAMFString = function() {};

/**
 * @constructor
 * @struct
 * @param {!CSG.Vector3D} normal
 * @param {number} w
 */
CSG.Plane = function(normal, w) {};
 /** @type {!CSG.Vector3D} */
CSG.Plane.prototype.normal;
 /** @type {number} */
CSG.Plane.prototype.w;
 /** @type {number} */
CSG.Plane.prototype.tag;
 /** @type {number} */
CSG.Plane.EPSILON;

/**
 * @param {?} obj
 * @return {!CSG.Plane}
 */
CSG.Plane.fromObject = function(obj) {};

/**
 * @param {!CSG.Vector3D} a
 * @param {!CSG.Vector3D} b
 * @param {!CSG.Vector3D} c
 * @return {!CSG.Plane}
 */
CSG.Plane.fromVector3Ds = function(a, b, c) {};

/**
 * @param {!CSG.Vector3D} a
 * @param {!CSG.Vector3D} b
 * @param {!CSG.Vector3D} c
 * @return {!CSG.Plane}
 */
CSG.Plane.anyPlaneFromVector3Ds = function(a, b, c) {};

/**
 * @param {!CSG.Vector3D} a
 * @param {!CSG.Vector3D} b
 * @param {!CSG.Vector3D} c
 * @return {!CSG.Plane}
 */
CSG.Plane.fromPoints = function(a, b, c) {};

/**
 * @param {!CSG.Vector3D|!Array<number>} normal
 * @param {!CSG.Vector3D|!Array<number>} point
 * @return {!CSG.Plane}
 */
CSG.Plane.fromNormalAndPoint = function(normal, point) {};

/**
 * @return {!CSG.Plane}
 */
CSG.Plane.prototype.flipped = function() {};

/**
 * @return {number}
 */
CSG.Plane.prototype.getTag = function() {};

/**
 * @param {!CSG.Plane} n
 * @return {boolean}
 */
CSG.Plane.prototype.equals = function(n) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Plane}
 */
CSG.Plane.prototype.transform = function(matrix4x4) {};

/**
 * @param {!CSG.Polygon} polygon
 * @return {{type: ?, front: ?, back: ?}}
 */
CSG.Plane.prototype.splitPolygon = function(polygon) {};

/**
 * @param {!CSG.Vector3D} p1
 * @param {!CSG.Vector3D} p2
 * @return {!CSG.Vector3D}
 */
CSG.Plane.prototype.splitLineBetweenPoints = function(p1, p2) {};

/**
 * @param {!CSG.Line3D} line3d
 * @return {!CSG.Vector3D}
 */
CSG.Plane.prototype.intersectWithLine = function(line3d) {};

/**
 * @param {!CSG.Plane} plane
 * @return {!CSG.Line3D}
 */
CSG.Plane.prototype.intersectWithPlane = function(plane) {};

/**
 * @param {!CSG.Vector3D} point
 * @return {number}
 */
CSG.Plane.prototype.signedDistanceToPoint = function(point) {};

/**
 * @return {string}
 */
CSG.Plane.prototype.toString = function() {};

/**
 * @param {!CSG.Vector3D} point3d
 * @return {!CSG.Vector3D}
 */
CSG.Plane.prototype.mirrorPoint = function(point3d) {};

/**
 * @constructor
 * @struct
 * @param {!CSG.Vector3D|!Array<!CSG.Vertex>} vertices
 * @param {!CSG.Polygon.Shared=} shared
 * @param {!CSG.Plane=} plane
 */
CSG.Polygon = function(vertices, shared, plane) {};
 /** @type {!Array<!CSG.Vertex>} */
CSG.Polygon.prototype.vertices;
 /** @type {!CSG.Polygon.Shared} */
CSG.Polygon.prototype.shared;
 /** @type {!CSG.Plane} */
CSG.Polygon.prototype.plane;
 /** @type {?} */
CSG.Polygon.prototype.cachedBoundingSphere;
 /** @type {!Array<!CSG.Vector3D>} */
CSG.Polygon.prototype.cachedBoundingBox;
 /** @type {!CSG.Polygon.Shared} */
CSG.Polygon.defaultShared;

/**
 * @param {?} obj
 * @return {!CSG.Polygon}
 */
CSG.Polygon.fromObject = function(obj) {};

/**
 * @return {void}
 */
CSG.Polygon.prototype.checkIfConvex = function() {};

/**
 * @param {?} args
 * @return {!CSG.Polygon}
 */
CSG.Polygon.prototype.setColor = function(args) {};

/**
 * @return {number}
 */
CSG.Polygon.prototype.getSignedVolume = function() {};

/**
 * @return {number}
 */
CSG.Polygon.prototype.getArea = function() {};

/**
 * @param {?} features
 * @return {!Array<?>}
 */
CSG.Polygon.prototype.getTetraFeatures = function(features) {};

/**
 * @param {?} offsetvector
 * @return {!CSG}
 */
CSG.Polygon.prototype.extrude = function(offsetvector) {};

/**
 * @return {?}
 */
CSG.Polygon.prototype.boundingSphere = function() {};

/**
 * @return {!Array<!CSG.Vector3D>}
 */
CSG.Polygon.prototype.boundingBox = function() {};

/**
 * @return {!CSG.Polygon}
 */
CSG.Polygon.prototype.flipped = function() {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Polygon}
 */
CSG.Polygon.prototype.transform = function(matrix4x4) {};

/**
 * @return {string}
 */
CSG.Polygon.prototype.toString = function() {};

/**
 * @param {!CSG.OrthoNormalBasis} orthobasis
 * @return {!CAG}
 */
CSG.Polygon.prototype.projectToOrthoNormalBasis = function(orthobasis) {};

/**
 * Creates solid from slices (CSG.Polygon) by generating walls
 *  - numslices {Number} Number of slices to be generated
 *  - callback(t, slice) {Function} Callback function generating slices.
 *          arguments: t = [0..1], slice = [0..numslices - 1]
 *          return: CSG.Polygon or null to skip
 *  - loop {Boolean} no flats, only walls, it's used to generate solids like a tor
 * @param {?} options
 * @return {!CSG}
 */
CSG.Polygon.prototype.solidFromSlices = function(options) {};

/**
 *
 * @param {?} walls Array of wall polygons
 * @param {?} bottom Bottom polygon
 * @param {?} top Top polygon
 * @param {?} bFlipped
 * @return {?}
 */
CSG.Polygon.prototype._addWalls = function(walls, bottom, top, bFlipped) {};

/**
 * @param {!Array<!CSG.Vertex>} vertices
 * @param {?} planenormal
 * @return {boolean}
 */
CSG.Polygon.verticesConvex = function(vertices, planenormal) {};

/**
 * @param {!Array<!Array<number>>} points
 * @param {!CSG.Polygon.Shared=} shared
 * @param {!CSG.Plane=} plane
 * @return {!CSG.Polygon}
 */
CSG.Polygon.createFromPoints = function(points, shared, plane) {};

/**
 * @param {?} prevpoint
 * @param {?} point
 * @param {?} nextpoint
 * @param {?} normal
 * @return {boolean}
 */
CSG.Polygon.isConvexPoint = function(prevpoint, point, nextpoint, normal) {};

/**
 * @param {?} prevpoint
 * @param {?} point
 * @param {?} nextpoint
 * @param {?} normal
 * @return {boolean}
 */
CSG.Polygon.isStrictlyConvexPoint = function(prevpoint, point, nextpoint, normal) {};

/**
 * @return {string}
 */
CSG.Polygon.prototype.toStlString = function() {};

/**
 * @constructor
 * @struct
 * @param {?} color
 */
CSG.Polygon.Shared = function(color) {};
 /** @type {?} */
CSG.Polygon.Shared.prototype.color;
 /** @type {?} */
CSG.Polygon.Shared.prototype.tag;

/**
 * @param {?} obj
 * @return {!CSG.Polygon.Shared}
 */
CSG.Polygon.Shared.fromObject = function(obj) {};

/**
 * @param {?} args
 * @return {!CSG.Polygon.Shared}
 */
CSG.Polygon.Shared.fromColor = function(args) {};

/**
 * @return {?}
 */
CSG.Polygon.Shared.prototype.getTag = function() {};

/**
 * @return {?}
 */
CSG.Polygon.Shared.prototype.getHash = function() {};

/**
 * @constructor
 * @struct
 */
CSG.PolygonTreeNode = function() {};
 /** @type {?} */
CSG.PolygonTreeNode.prototype.parent;
 /** @type {?} */
CSG.PolygonTreeNode.prototype.children;
 /** @type {!CSG.Polygon} */
CSG.PolygonTreeNode.prototype.polygon;
 /** @type {boolean} */
CSG.PolygonTreeNode.prototype.removed;

/**
 * @param {?} polygons
 * @return {void}
 */
CSG.PolygonTreeNode.prototype.addPolygons = function(polygons) {};

/**
 * @return {void}
 */
CSG.PolygonTreeNode.prototype.remove = function() {};

/**
 * @return {boolean}
 */
CSG.PolygonTreeNode.prototype.isRemoved = function() {};

/**
 * @return {boolean}
 */
CSG.PolygonTreeNode.prototype.isRootNode = function() {};

/**
 * @return {void}
 */
CSG.PolygonTreeNode.prototype.invert = function() {};

/**
 * @return {!CSG.Polygon}
 */
CSG.PolygonTreeNode.prototype.getPolygon = function() {};

/**
 * @param {!Array<!CSG.Polygon>} result
 * @return {void}
 */
CSG.PolygonTreeNode.prototype.getPolygons = function(result) {};

/**
 * @param {?} plane
 * @param {?} coplanarfrontnodes
 * @param {?} coplanarbacknodes
 * @param {?} frontnodes
 * @param {?} backnodes
 * @return {void}
 */
CSG.PolygonTreeNode.prototype.splitByPlane = function(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes) {};

/**
 * @param {?} plane
 * @param {?} coplanarfrontnodes
 * @param {?} coplanarbacknodes
 * @param {?} frontnodes
 * @param {?} backnodes
 * @return {void}
 */
CSG.PolygonTreeNode.prototype._splitByPlane = function(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes) {};

/**
 * @param {!CSG.Polygon} polygon
 * @return {!CSG.PolygonTreeNode}
 */
CSG.PolygonTreeNode.prototype.addChild = function(polygon) {};

/**
 * @return {void}
 */
CSG.PolygonTreeNode.prototype.invertSub = function() {};

/**
 * @return {void}
 */
CSG.PolygonTreeNode.prototype.recursivelyInvalidatePolygon = function() {};

/**
 * @constructor
 * @struct
 * @param {!Array<!CSG.Polygon>} polygons
 */
CSG.Tree = function(polygons) {};
 /** @type {!CSG.PolygonTreeNode} */
CSG.Tree.prototype.polygonTree;
 /** @type {!CSG.Node} */
CSG.Tree.prototype.rootnode;

/**
 * @return {void}
 */
CSG.Tree.prototype.invert = function() {};

/**
 * @param {!CSG.Tree} tree
 * @param {boolean=} alsoRemovecoplanarFront
 * @return {void}
 */
CSG.Tree.prototype.clipTo = function(tree, alsoRemovecoplanarFront) {};

/**
 * @return {!Array<!CSG.Polygon>}
 */
CSG.Tree.prototype.allPolygons = function() {};

/**
 * @param {!Array<!CSG.Polygon>} polygons
 * @return {void}
 */
CSG.Tree.prototype.addPolygons = function(polygons) {};

/**
 * @constructor
 * @struct
 * @param {!CSG.Node} parent
 */
CSG.Node = function(parent) {};
 /** @type {!CSG.Node} */
CSG.Node.prototype.parent;
 /** @type {!CSG.Plane} */
CSG.Node.prototype.plane;
 /** @type {?} */
CSG.Node.prototype.front;
 /** @type {?} */
CSG.Node.prototype.back;
 /** @type {!Array<!CSG.PolygonTreeNode>} */
CSG.Node.prototype.polygontreenodes;

/**
 * @return {void}
 */
CSG.Node.prototype.invert = function() {};

/**
 * @param {!Array<!CSG.PolygonTreeNode>} polygontreenodes
 * @param {boolean} alsoRemovecoplanarFront
 * @return {void}
 */
CSG.Node.prototype.clipPolygons = function(polygontreenodes, alsoRemovecoplanarFront) {};

/**
 * @param {!CSG.Tree} tree
 * @param {boolean} alsoRemovecoplanarFront
 * @return {void}
 */
CSG.Node.prototype.clipTo = function(tree, alsoRemovecoplanarFront) {};

/**
 * @param {!Array<!CSG.PolygonTreeNode>} polygontreenodes
 * @return {void}
 */
CSG.Node.prototype.addPolygonTreeNodes = function(polygontreenodes) {};

/**
 * @param {!Array<!CSG.Vector3D>} normals
 * @param {number} maxdepth
 * @return {void}
 */
CSG.Node.prototype.getParentPlaneNormals = function(normals, maxdepth) {};

/**
 * @constructor
 * @struct
 * @param {!Array<number>=} elements
 */
CSG.Matrix4x4 = function(elements) {};
 /** @type {!Array<number>} */
CSG.Matrix4x4.prototype.elements;

/**
 * @param {!CSG.Matrix4x4} m
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.prototype.plus = function(m) {};

/**
 * @param {!CSG.Matrix4x4} m
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.prototype.minus = function(m) {};

/**
 * @param {!CSG.Matrix4x4} m
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.prototype.multiply = function(m) {};

/**
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.prototype.clone = function() {};

/**
 * @param {!CSG.Vector3D} v
 * @return {!CSG.Vector3D}
 */
CSG.Matrix4x4.prototype.rightMultiply1x3Vector = function(v) {};

/**
 * @param {!CSG.Vector3D} v
 * @return {!CSG.Vector3D}
 */
CSG.Matrix4x4.prototype.leftMultiply1x3Vector = function(v) {};

/**
 * @param {!CSG.Vector2D} v
 * @return {!CSG.Vector2D}
 */
CSG.Matrix4x4.prototype.rightMultiply1x2Vector = function(v) {};

/**
 * @param {!CSG.Vector2D} v
 * @return {!CSG.Vector2D}
 */
CSG.Matrix4x4.prototype.leftMultiply1x2Vector = function(v) {};

/**
 * @return {boolean}
 */
CSG.Matrix4x4.prototype.isMirroring = function() {};

/**
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.unity = function() {};

/**
 * @param {number} degrees
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.rotationX = function(degrees) {};

/**
 * @param {number} degrees
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.rotationY = function(degrees) {};

/**
 * @param {number} degrees
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.rotationZ = function(degrees) {};

/**
 * @param {!CSG.Vector3D} rotationCenter
 * @param {!CSG.Vector3D} rotationAxis
 * @param {number} degrees
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.rotation = function(rotationCenter, rotationAxis, degrees) {};

/**
 * @param {!Array<number>|!CSG.Vector3D} v
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.translation = function(v) {};

/**
 * @param {!CSG.Plane} plane
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.mirroring = function(plane) {};

/**
 * @param {!Array<number>|!CSG.Vector3D} v
 * @return {!CSG.Matrix4x4}
 */
CSG.Matrix4x4.scaling = function(v) {};

/**
 * @constructor
 * @struct
 * @param {number|!Array<number>|!CSG.Vector2D} x
 * @param {number=} y
 */
CSG.Vector2D = function(x, y) {};
 /** @type {number} */
CSG.Vector2D.prototype.x;
 /** @type {number} */
CSG.Vector2D.prototype.y;

/**
 * @param {number} radians
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.fromAngle = function(radians) {};

/**
 * @param {number} degrees
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.fromAngleDegrees = function(degrees) {};

/**
 * @param {number} radians
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.fromAngleRadians = function(radians) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.Create = function(x, y) {};

/**
 * @param {number} z
 * @return {!CSG.Vector3D}
 */
CSG.Vector2D.prototype.toVector3D = function(z) {};

/**
 * @param {!CSG.Vector2D} a
 * @return {boolean}
 */
CSG.Vector2D.prototype.equals = function(a) {};

/**
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.clone = function() {};

/**
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.negated = function() {};

/**
 * @param {!CSG.Vector2D} a
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.plus = function(a) {};

/**
 * @param {!CSG.Vector2D} a
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.minus = function(a) {};

/**
 * @param {number} a
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.times = function(a) {};

/**
 * @param {number} a
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.dividedBy = function(a) {};

/**
 * @param {!CSG.Vector2D} a
 * @return {number}
 */
CSG.Vector2D.prototype.dot = function(a) {};

/**
 * @param {!CSG.Vector2D} a
 * @param {number} t
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.lerp = function(a, t) {};

/**
 * @return {number}
 */
CSG.Vector2D.prototype.length = function() {};

/**
 * @param {!CSG.Vector2D} a
 * @return {number}
 */
CSG.Vector2D.prototype.distanceTo = function(a) {};

/**
 * @param {!CSG.Vector2D} a
 * @return {number}
 */
CSG.Vector2D.prototype.distanceToSquared = function(a) {};

/**
 * @return {number}
 */
CSG.Vector2D.prototype.lengthSquared = function() {};

/**
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.unit = function() {};

/**
 * @param {!CSG.Vector2D} a
 * @return {number}
 */
CSG.Vector2D.prototype.cross = function(a) {};

/**
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.normal = function() {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.multiply4x4 = function(matrix4x4) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.transform = function(matrix4x4) {};

/**
 * @return {number}
 */
CSG.Vector2D.prototype.angle = function() {};

/**
 * @return {number}
 */
CSG.Vector2D.prototype.angleDegrees = function() {};

/**
 * @return {number}
 */
CSG.Vector2D.prototype.angleRadians = function() {};

/**
 * @param {!CSG.Vector2D} p
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.min = function(p) {};

/**
 * @param {!CSG.Vector2D} p
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.max = function(p) {};

/**
 * @return {string}
 */
CSG.Vector2D.prototype.toString = function() {};

/**
 * @return {!CSG.Vector2D}
 */
CSG.Vector2D.prototype.abs = function() {};

/**
 * @constructor
 * @struct
 * @param {!CSG.Vector2D} normal
 * @param {number} w
 */
CSG.Line2D = function(normal, w) {};
 /** @type {!CSG.Vector2D} */
CSG.Line2D.prototype.normal;
 /** @type {number} */
CSG.Line2D.prototype.w;

/**
 * @param {!CSG.Vector2D} p1
 * @param {!CSG.Vector2D} p2
 * @return {!CSG.Line2D}
 */
CSG.Line2D.fromPoints = function(p1, p2) {};

/**
 * @return {!CSG.Line2D}
 */
CSG.Line2D.prototype.reverse = function() {};

/**
 * @param {!CSG.Line2D} l
 * @return {boolean}
 */
CSG.Line2D.prototype.equals = function(l) {};

/**
 * @return {!CSG.Vector2D}
 */
CSG.Line2D.prototype.origin = function() {};

/**
 * @return {!CSG.Vector2D}
 */
CSG.Line2D.prototype.direction = function() {};

/**
 * @param {number} y
 * @return {number}
 */
CSG.Line2D.prototype.xAtY = function(y) {};

/**
 * @param {!CSG.Vector2D} point
 * @return {number}
 */
CSG.Line2D.prototype.absDistanceToPoint = function(point) {};

/**
 * @param {!CSG.Line2D} line2d
 * @return {!CSG.Vector2D}
 */
CSG.Line2D.prototype.intersectWithLine = function(line2d) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Line2D}
 */
CSG.Line2D.prototype.transform = function(matrix4x4) {};

/**
 * @constructor
 * @struct
 * @param {!CSG.Vector3D} point
 * @param {!CSG.Vector3D} direction
 */
CSG.Line3D = function(point, direction) {};
 /** @type {!CSG.Vector3D} */
CSG.Line3D.prototype.point;
 /** @type {!CSG.Vector3D} */
CSG.Line3D.prototype.direction;

/**
 * @param {!CSG.Vector3D} p1
 * @param {!CSG.Vector3D} p2
 * @return {!CSG.Line3D}
 */
CSG.Line3D.fromPoints = function(p1, p2) {};

/**
 * @param {!CSG.Plane} p1
 * @param {!CSG.Plane} p2
 * @return {!CSG.Line3D}
 */
CSG.Line3D.fromPlanes = function(p1, p2) {};

/**
 * @param {!CSG.Plane} plane
 * @return {!CSG.Vector3D}
 */
CSG.Line3D.prototype.intersectWithPlane = function(plane) {};

/**
 * @return {!CSG.Line3D}
 */
CSG.Line3D.prototype.clone = function() {};

/**
 * @return {!CSG.Line3D}
 */
CSG.Line3D.prototype.reverse = function() {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Line3D}
 */
CSG.Line3D.prototype.transform = function(matrix4x4) {};

/**
 * @param {!CSG.Vector3D} point
 * @return {!CSG.Vector3D}
 */
CSG.Line3D.prototype.closestPointOnLine = function(point) {};

/**
 * @param {!CSG.Vector3D} point
 * @return {number}
 */
CSG.Line3D.prototype.distanceToPoint = function(point) {};

/**
 * @param {!CSG.Line3D} line3d
 * @return {boolean}
 */
CSG.Line3D.prototype.equals = function(line3d) {};

/**
 * @constructor
 * @struct
 * @param {!CSG.Plane} plane
 * @param {!CSG.Vector3D=} rightvector
 */
CSG.OrthoNormalBasis = function(plane, rightvector) {};
 /** @type {!CSG.Vector3D} */
CSG.OrthoNormalBasis.prototype.v;
 /** @type {!CSG.Vector3D} */
CSG.OrthoNormalBasis.prototype.u;
 /** @type {!CSG.Plane} */
CSG.OrthoNormalBasis.prototype.plane;
 /** @type {!CSG.Vector3D} */
CSG.OrthoNormalBasis.prototype.planeorigin;

/**
 * @param {string} xaxisid
 * @param {string} yaxisid
 * @return {!CSG.OrthoNormalBasis}
 */
CSG.OrthoNormalBasis.GetCartesian = function(xaxisid, yaxisid) {};

/**
 * @return {!CSG.OrthoNormalBasis}
 */
CSG.OrthoNormalBasis.Z0Plane = function() {};

/**
 * @return {!CSG.Matrix4x4}
 */
CSG.OrthoNormalBasis.prototype.getProjectionMatrix = function() {};

/**
 * @return {!CSG.Matrix4x4}
 */
CSG.OrthoNormalBasis.prototype.getInverseProjectionMatrix = function() {};

/**
 * @param {!CSG.Vector3D} vec3
 * @return {!CSG.Vector2D}
 */
CSG.OrthoNormalBasis.prototype.to2D = function(vec3) {};

/**
 * @param {!CSG.Vector2D} vec2
 * @return {!CSG.Vector3D}
 */
CSG.OrthoNormalBasis.prototype.to3D = function(vec2) {};

/**
 * @param {!CSG.Line3D} line3d
 * @return {!CSG.Line2D}
 */
CSG.OrthoNormalBasis.prototype.line3Dto2D = function(line3d) {};

/**
 * @param {!CSG.Line2D} line2d
 * @return {!CSG.Line3D}
 */
CSG.OrthoNormalBasis.prototype.line2Dto3D = function(line2d) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.OrthoNormalBasis}
 */
CSG.OrthoNormalBasis.prototype.transform = function(matrix4x4) {};

/**
 * @param {!CSG.Vector2D} point1
 * @param {!CSG.Vector2D} point2
 * @param {number} y
 * @return {number}
 */
CSG.interpolateBetween2DPointsForY = function(point1, point2, y) {};

/**
 * @param {!Array<!CSG.Polygon>} sourcepolygons
 * @param {!Array<!CSG.Polygon>} destpolygons
 * @return {void}
 */
CSG.reTesselateCoplanarPolygons = function(sourcepolygons, destpolygons) {};

/**
 * @constructor
 * @struct
 * @param {number} numdimensions
 * @param {number} tolerance
 */
CSG.fuzzyFactory = function(numdimensions, tolerance) {};
 /** @type {number} */
CSG.fuzzyFactory.prototype.multiplier;
 /** @type {?} */
CSG.fuzzyFactory.prototype.lookuptable;

/**
 * @param {?} els
 * @param {?} creatorCallback
 * @return {?}
 */
CSG.fuzzyFactory.prototype.lookupOrCreate = function(els, creatorCallback) {};

/**
 * @constructor
 * @struct
 */
CSG.fuzzyCSGFactory = function() {};
 /** @type {!CSG.fuzzyFactory} */
CSG.fuzzyCSGFactory.prototype.vertexfactory;
 /** @type {!CSG.fuzzyFactory} */
CSG.fuzzyCSGFactory.prototype.planefactory;
 /** @type {?} */
CSG.fuzzyCSGFactory.prototype.polygonsharedfactory;

/**
 * @param {!CSG.Polygon.Shared} sourceshared
 * @return {!CSG.Polygon.Shared}
 */
CSG.fuzzyCSGFactory.prototype.getPolygonShared = function(sourceshared) {};

/**
 * @param {!CSG.Vertex} sourcevertex
 * @return {!CSG.Vertex}
 */
CSG.fuzzyCSGFactory.prototype.getVertex = function(sourcevertex) {};

/**
 * @param {!CSG.Plane} sourceplane
 * @return {!CSG.Plane}
 */
CSG.fuzzyCSGFactory.prototype.getPlane = function(sourceplane) {};

/**
 * @param {!CSG.Polygon} sourcepolygon
 * @return {!CSG.Polygon}
 */
CSG.fuzzyCSGFactory.prototype.getPolygon = function(sourcepolygon) {};

/**
 * @param {!CSG} sourcecsg
 * @return {!CSG}
 */
CSG.fuzzyCSGFactory.prototype.getCSG = function(sourcecsg) {};
 /** @type {number} */
CSG.staticTag;

/**
 * @return {number}
 */
CSG.getTag = function() {};
/**
 * @constructor
 * @struct
 */
CSG.Properties = function() {};
 /** @type {!CSG.Properties} */
CSG.Properties.prototype.cube;
 /** @type {?} */
CSG.Properties.prototype.center;
 /** @type {!Array<?>} */
CSG.Properties.prototype.facecenters;
 /** @type {!CSG.Properties} */
CSG.Properties.prototype.roundedCube;
 /** @type {!CSG.Properties} */
CSG.Properties.prototype.cylinder;
 /** @type {?} */
CSG.Properties.prototype.start;
 /** @type {?} */
CSG.Properties.prototype.end;
 /** @type {?} */
CSG.Properties.prototype.facepointH;
 /** @type {?} */
CSG.Properties.prototype.facepointH90;
 /** @type {!CSG.Properties} */
CSG.Properties.prototype.sphere;
 /** @type {?} */
CSG.Properties.prototype.facepoint;
 /** @type {?} */
CSG.Properties.prototype.roundedCylinder;

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Properties}
 */
CSG.Properties.prototype._transform = function(matrix4x4) {};

/**
 * @param {!CSG.Properties} otherproperties
 * @return {!CSG.Properties}
 */
CSG.Properties.prototype._merge = function(otherproperties) {};

/**
 * @param {?} source
 * @param {?} result
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {void}
 */
CSG.Properties.transformObj = function(source, result, matrix4x4) {};

/**
 * @param {?} source
 * @param {?} result
 * @return {void}
 */
CSG.Properties.cloneObj = function(source, result) {};

/**
 * @param {?} result
 * @param {!CSG.Properties} otherproperties
 * @return {void}
 */
CSG.Properties.addFrom = function(result, otherproperties) {};

/**
 * @constructor
 * @struct
 * @param {!Array<number>|!CSG.Vector3D} point
 * @param {!CSG.Vector3D|!Array<number>} axisvector
 * @param {!Array<number>|!CSG.Vector3D} normalvector
 */
CSG.Connector = function(point, axisvector, normalvector) {};
 /** @type {!CSG.Vector3D} */
CSG.Connector.prototype.point;
 /** @type {!CSG.Vector3D} */
CSG.Connector.prototype.axisvector;
 /** @type {!CSG.Vector3D} */
CSG.Connector.prototype.normalvector;

/**
 * @return {!CSG.Connector}
 */
CSG.Connector.prototype.normalized = function() {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Connector}
 */
CSG.Connector.prototype.transform = function(matrix4x4) {};

/**
 * @param {!CSG.Connector} other
 * @param {boolean} mirror
 * @param {number} normalrotation
 * @return {!CSG.Matrix4x4}
 */
CSG.Connector.prototype.getTransformationTo = function(other, mirror, normalrotation) {};

/**
 * @return {!CSG.Line3D}
 */
CSG.Connector.prototype.axisLine = function() {};

/**
 * @param {number} distance
 * @return {!CSG.Connector}
 */
CSG.Connector.prototype.extend = function(distance) {};

/**
 * @constructor
 * @struct
 * @param {!Array<!CSG.Connector>} connectors
 */
CSG.ConnectorList = function(connectors) {};
 /** @type {!Array<!CSG.Connector>} */
CSG.ConnectorList.prototype.connectors_;
 /** @type {boolean} */
CSG.ConnectorList.prototype.closed;
 /** @type {!Array<number>} */
CSG.ConnectorList.defaultNormal;

/**
 * @param {!CSG.Path2D} path2D
 * @param {?} arg1
 * @param {?} arg2
 * @return {!CSG.ConnectorList}
 */
CSG.ConnectorList.fromPath2D = function(path2D, arg1, arg2) {};

/**
 * @param {?} path2D
 * @param {?} start
 * @param {?} end
 * @return {!CSG.ConnectorList}
 */
CSG.ConnectorList._fromPath2DTangents = function(path2D, start, end) {};

/**
 * @param {?} path2D
 * @param {?} angleIsh
 * @return {!CSG.ConnectorList}
 */
CSG.ConnectorList._fromPath2DExplicit = function(path2D, angleIsh) {};

/**
 * @param {boolean} bool
 * @return {void}
 */
CSG.ConnectorList.prototype.setClosed = function(bool) {};

/**
 * @param {!CSG.Connector} conn
 * @return {void}
 */
CSG.ConnectorList.prototype.appendConnector = function(conn) {};

/**
 * @param {?} cagish
 * @return {!CSG}
 */
CSG.ConnectorList.prototype.followWith = function(cagish) {};

/**
 * @return {void}
 */
CSG.ConnectorList.prototype.verify = function() {};
/**
 * @record
 * @struct
 */
CSG.IRadiusOptions = function() {};
 /** @type {number} */
CSG.IRadiusOptions.prototype.radius;
 /** @type {number} */
CSG.IRadiusOptions.prototype.resolution;
/**
 * @extends {CSG.IRadiusOptions}
 * @record
 * @struct
 */
CSG.ICircleOptions = function() {};
 /** @type {(!Array<number>|!CSG.Vector2D)} */
CSG.ICircleOptions.prototype.center;
/**
 * @extends {CSG.ICircleOptions}
 * @record
 * @struct
 */
CSG.IArcOptions = function() {};
 /** @type {number} */
CSG.IArcOptions.prototype.startangle;
 /** @type {number} */
CSG.IArcOptions.prototype.endangle;
 /** @type {boolean} */
CSG.IArcOptions.prototype.maketangent;
/**
 * @extends {CSG.IRadiusOptions}
 * @record
 * @struct
 */
CSG.IEllpiticalArcOptions = function() {};
 /** @type {boolean} */
CSG.IEllpiticalArcOptions.prototype.clockwise;
 /** @type {boolean} */
CSG.IEllpiticalArcOptions.prototype.large;
 /** @type {number} */
CSG.IEllpiticalArcOptions.prototype.xaxisrotation;
 /** @type {number} */
CSG.IEllpiticalArcOptions.prototype.xradius;
 /** @type {number} */
CSG.IEllpiticalArcOptions.prototype.yradius;
/**
 * @record
 * @struct
 */
CSG.IRectangleOptions = function() {};
 /** @type {!CSG.Vector2D} */
CSG.IRectangleOptions.prototype.center;
 /** @type {!CSG.Vector2D} */
CSG.IRectangleOptions.prototype.corner1;
 /** @type {!CSG.Vector2D} */
CSG.IRectangleOptions.prototype.corner2;
 /** @type {!CSG.Vector2D} */
CSG.IRectangleOptions.prototype.radius;
/**
 * @record
 * @struct
 */
CSG.IRoundRectangleOptions = function() {};
 /** @type {number} */
CSG.IRoundRectangleOptions.prototype.roundradius;
 /** @type {number} */
CSG.IRoundRectangleOptions.prototype.resolution;

/**
 * @constructor
 * @struct
 * @param {!Array<number>|!Array<!CSG.Vector2D>} points
 * @param {boolean=} closed
 */
CSG.Path2D = function(points, closed) {};
 /** @type {boolean} */
CSG.Path2D.prototype.closed;
 /** @type {!Array<!CSG.Vector2D>} */
CSG.Path2D.prototype.points;
 /** @type {!CSG.Vector2D} */
CSG.Path2D.prototype.lastBezierControlPoint;

/**
 * @param {!CSG.IArcOptions} options
 * @return {!CSG.Path2D}
 */
CSG.Path2D.arc = function(options) {};

/**
 * @param {!CSG.Path2D} otherpath
 * @return {!CSG.Path2D}
 */
CSG.Path2D.prototype.concat = function(otherpath) {};

/**
 * @param {!CSG.Vector2D} point
 * @return {!CSG.Path2D}
 */
CSG.Path2D.prototype.appendPoint = function(point) {};

/**
 * @param {!Array<!CSG.Vector2D>} points
 * @return {!CSG.Path2D}
 */
CSG.Path2D.prototype.appendPoints = function(points) {};

/**
 * @return {!CSG.Path2D}
 */
CSG.Path2D.prototype.close = function() {};

/**
 * @param {number} width
 * @param {number} height
 * @param {number} resolution
 * @return {!CSG}
 */
CSG.Path2D.prototype.rectangularExtrude = function(width, height, resolution) {};

/**
 * @param {number} pathradius
 * @param {number} resolution
 * @return {!CAG}
 */
CSG.Path2D.prototype.expandToCAG = function(pathradius, resolution) {};

/**
 * @return {!CAG}
 */
CSG.Path2D.prototype.innerToCAG = function() {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CSG.Path2D}
 */
CSG.Path2D.prototype.transform = function(matrix4x4) {};

/**
 * @param {?} controlpoints
 * @param {?} options
 * @return {!CSG.Path2D}
 */
CSG.Path2D.prototype.appendBezier = function(controlpoints, options) {};

/**
 * @param {!CSG.Vector2D} endpoint
 * @param {!CSG.IEllpiticalArcOptions} options
 * @return {!CSG.Path2D}
 */
CSG.Path2D.prototype.appendArc = function(endpoint, options) {};

/**
 * @constructor
 * @struct
 */
function CAG() {}
 /** @type {!Array<!CAG.Side>} */
CAG.prototype.sides;
 /** @type {boolean} */
CAG.prototype.isCanonicalized;

/**
 * @param {!Array<!CAG.Side>} sides
 * @return {!CAG}
 */
CAG.fromSides = function(sides) {};

/**
 * @param {!Array<!CSG.Vector2D>} points
 * @return {!CAG}
 */
CAG.fromPoints = function(points) {};

/**
 * @param {!Array<!CSG.Vector2D>} points
 * @return {!CAG}
 */
CAG.fromPointsNoCheck = function(points) {};

/**
 * @param {!CSG} csg
 * @return {!CAG}
 */
CAG.fromFakeCSG = function(csg) {};

/**
 * @param {!CSG.Vector2D} p0start
 * @param {!CSG.Vector2D} p0end
 * @param {!CSG.Vector2D} p1start
 * @param {!CSG.Vector2D} p1end
 * @return {boolean}
 */
CAG.linesIntersect = function(p0start, p0end, p1start, p1end) {};

/**
 * @param {!CSG.ICircleOptions} options
 * @return {!CAG}
 */
CAG.circle = function(options) {};

/**
 * @param {!CSG.IRectangleOptions} options
 * @return {!CAG}
 */
CAG.rectangle = function(options) {};

/**
 * @param {?} options
 * @return {!CAG}
 */
CAG.roundedRectangle = function(options) {};

/**
 * @param {?} bin
 * @return {!CAG}
 */
CAG.fromCompactBinary = function(bin) {};

/**
 * @return {string}
 */
CAG.prototype.toString = function() {};

/**
 * @param {?} z0
 * @param {?} z1
 * @return {!CSG}
 */
CAG.prototype._toCSGWall = function(z0, z1) {};

/**
 * @param {!CSG.Matrix4x4} m
 * @return {!Array<!Array<!CSG.Vector3D>>}
 */
CAG.prototype._toVector3DPairs = function(m) {};

/**
 * @param {?} options
 * @return {!Array<!CSG.Polygon>}
 */
CAG.prototype._toPlanePolygons = function(options) {};

/**
 * @param {?} options
 * @return {!Array<?>}
 */
CAG.prototype._toWallPolygons = function(options) {};

/**
 * @param {!Array<!CAG>|!CAG} cag
 * @return {!CAG}
 */
CAG.prototype.union = function(cag) {};

/**
 * @param {!Array<!CAG>|!CAG} cag
 * @return {!CAG}
 */
CAG.prototype.subtract = function(cag) {};

/**
 * @param {!Array<!CAG>|!CAG} cag
 * @return {!CAG}
 */
CAG.prototype.intersect = function(cag) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CAG}
 */
CAG.prototype.transform = function(matrix4x4) {};

/**
 * @return {number}
 */
CAG.prototype.area = function() {};

/**
 * @return {!CAG}
 */
CAG.prototype.flipped = function() {};

/**
 * @return {!Array<!CSG.Vector2D>}
 */
CAG.prototype.getBounds = function() {};

/**
 * @return {boolean}
 */
CAG.prototype.isSelfIntersecting = function() {};

/**
 * @param {number} radius
 * @param {number} resolution
 * @return {!CAG}
 */
CAG.prototype.expandedShell = function(radius, resolution) {};

/**
 * @param {number} radius
 * @param {number} resolution
 * @return {!CAG}
 */
CAG.prototype.expand = function(radius, resolution) {};

/**
 * @param {number} radius
 * @param {number} resolution
 * @return {!CAG}
 */
CAG.prototype.contract = function(radius, resolution) {};

/**
 * @param {!CSG.OrthoNormalBasis} orthonormalbasis
 * @param {number} depth
 * @param {?=} options
 * @return {!CSG}
 */
CAG.prototype.extrudeInOrthonormalBasis = function(orthonormalbasis, depth, options) {};

/**
 * @param {?} axis1
 * @param {?} axis2
 * @param {?} depth
 * @param {?} options
 * @return {!CSG}
 */
CAG.prototype.extrudeInPlane = function(axis1, axis2, depth, options) {};

/**
 * @param {!CAG_extrude_options} options
 * @return {!CSG}
 */
CAG.prototype.extrude = function(options) {};

/**
 * @param {?} options
 * @return {!CSG}
 */
CAG.prototype.rotateExtrude = function(options) {};

/**
 * @return {void}
 */
CAG.prototype.check = function() {};

/**
 * @return {!CAG}
 */
CAG.prototype.canonicalized = function() {};

/**
 * @return {{class: string, sideVertexIndices: !Uint32Array, vertexData: !Float64Array}}
 */
CAG.prototype.toCompactBinary = function() {};

/**
 * @return {!Array<!CSG.Path2D>}
 */
CAG.prototype.getOutlinePaths = function() {};

/**
 * @param {?} cutterradius
 * @return {!CAG}
 */
CAG.prototype.overCutInsideCorners = function(cutterradius) {};

/**
 * @param {!Array<string>} cAxes
 * @return {!CxG}
 */
CAG.prototype.center = function(cAxes) {};

/**
 * @return {!Blob}
 */
CAG.prototype.toDxf = function() {};

/**
 * @param {!Array<!CSG.Path2D>} paths
 * @return {!Blob}
 */
CAG.PathsToDxf = function(paths) {};

/**
 * @constructor
 * @struct
 * @param {!CSG.Vector2D} pos
 */
CAG.Vertex = function(pos) {};
 /** @type {!CSG.Vector2D} */
CAG.Vertex.prototype.pos;
 /** @type {number} */
CAG.Vertex.prototype.tag;

/**
 * @return {string}
 */
CAG.Vertex.prototype.toString = function() {};

/**
 * @return {number}
 */
CAG.Vertex.prototype.getTag = function() {};

/**
 * @constructor
 * @struct
 * @param {!CAG.Vertex} vertex0
 * @param {!CAG.Vertex} vertex1
 */
CAG.Side = function(vertex0, vertex1) {};
 /** @type {!CAG.Vertex} */
CAG.Side.prototype.vertex0;
 /** @type {!CAG.Vertex} */
CAG.Side.prototype.vertex1;
 /** @type {number} */
CAG.Side.prototype.tag;

/**
 * @param {!CSG.Polygon} polygon
 * @return {!CAG.Side}
 */
CAG.Side._fromFakePolygon = function(polygon) {};

/**
 * @return {string}
 */
CAG.Side.prototype.toString = function() {};

/**
 * @param {?} z0
 * @param {?} z1
 * @return {!CSG.Polygon}
 */
CAG.Side.prototype.toPolygon3D = function(z0, z1) {};

/**
 * @param {!CSG.Matrix4x4} matrix4x4
 * @return {!CAG.Side}
 */
CAG.Side.prototype.transform = function(matrix4x4) {};

/**
 * @return {!CAG.Side}
 */
CAG.Side.prototype.flipped = function() {};

/**
 * @return {!CSG.Vector2D}
 */
CAG.Side.prototype.direction = function() {};

/**
 * @return {number}
 */
CAG.Side.prototype.getTag = function() {};

/**
 * @return {number}
 */
CAG.Side.prototype.lengthSquared = function() {};

/**
 * @return {number}
 */
CAG.Side.prototype.length = function() {};

/**
 * @constructor
 * @struct
 */
CAG.fuzzyCAGFactory = function() {};
 /** @type {!CSG.fuzzyFactory} */
CAG.fuzzyCAGFactory.prototype.vertexfactory;

/**
 * @param {!CAG.Vertex} sourcevertex
 * @return {!CAG.Vertex}
 */
CAG.fuzzyCAGFactory.prototype.getVertex = function(sourcevertex) {};

/**
 * @param {!CAG.Side} sourceside
 * @return {!CAG.Side}
 */
CAG.fuzzyCAGFactory.prototype.getSide = function(sourceside) {};

/**
 * @param {!CAG} sourcecag
 * @return {!CAG}
 */
CAG.fuzzyCAGFactory.prototype.getCAG = function(sourcecag) {};
/**
 * @record
 * @struct
 */
function CAG_extrude_options() {}
 /** @type {!Array<number>} */
CAG_extrude_options.prototype.offset;
 /** @type {number} */
CAG_extrude_options.prototype.twistangle;
 /** @type {number} */
CAG_extrude_options.prototype.twiststeps;

/**
 * @constructor
 * @struct
 * @param {!Array<!CSG.Vector2D>} points
 */
CSG.Polygon2D = function(points) {};
