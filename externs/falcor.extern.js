/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/falcor/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: NamespaceExportDeclaration in  */

/* TODO: ExportDeclaration in  */

/* TODO: ExportDeclaration in  */
/**
 * @constructor
 * @struct
 */
function DataSource() {}

/**
 * The get method retrieves values from the DataSource's associated JSONGraph object.
 * @param {!Array<!Array<(string|number|boolean|!FalcorJsonGraph.Range|!Array<(string|number|boolean|!FalcorJsonGraph.Range)>)>>} pathSets
 * @return {?}
 */
DataSource.prototype.get = function(pathSets) {};

/**
 * The set method accepts values to set in the DataSource's associated JSONGraph object.
 * @param {!FalcorJsonGraph.JSONGraphEnvelope} jsonGraphEnvelope
 * @return {?}
 */
DataSource.prototype.set = function(jsonGraphEnvelope) {};

/**
 * Invokes a function in the DataSource's JSONGraph object.
 * @param {!Array<(string|number|boolean)>} functionPath
 * @param {!Array<?>=} args
 * @param {!Array<!Array<(string|number|boolean|!FalcorJsonGraph.Range|!Array<(string|number|boolean|!FalcorJsonGraph.Range)>)>>=} refSuffixes
 * @param {!Array<!Array<(string|number|boolean|!FalcorJsonGraph.Range|!Array<(string|number|boolean|!FalcorJsonGraph.Range)>)>>=} thisPaths
 * @return {?}
 */
DataSource.prototype.call = function(functionPath, args, refSuffixes, thisPaths) {};
/**
 * @record
 * @struct
 */
function ModelOptions() {}
 /** @type {?} */
ModelOptions.prototype.source;
 /** @type {?} */
ModelOptions.prototype.cache;
 /** @type {number} */
ModelOptions.prototype.maxSize;
 /** @type {number} */
ModelOptions.prototype.collectRatio;
 /** @type {?} */
ModelOptions.prototype.errorSelector;
 /** @type {?} */
ModelOptions.prototype.onChange;
 /** @type {?} */
ModelOptions.prototype.comparator;

/** @typedef {?} */
var ModelOnChange;

/** @typedef {?} */
var ModelErrorSelector;

/** @typedef {?} */
var ModelComparator;

/**
 * @constructor
 * @struct
 * @param {?=} options
 */
function Model(options) {}

/**
 * The get method retrieves several {\@link Path}s or {\@link PathSet}s from a {\@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.
 * @template T
 * @param {...(string|!Array<(string|number|boolean|!FalcorJsonGraph.Range|!Array<(string|number|boolean|!FalcorJsonGraph.Range)>)>)} path
 * @return {?}
 */
Model.prototype.get = function(path) {};

/**
 * Sets the value at one or more places in the JSONGraph model.
 * The set method accepts one or more {\@link PathValue}s, each of which is a combination of a location in the document and the value to place there.
 * In addition to accepting  {\@link PathValue}s, the set method also returns the values after the set operation is complete.
 * @template T
 * @param {...!FalcorJsonGraph.PathValue|?} args_or_jsonGraph
 * @return {?}
 */
Model.prototype.set = function(args_or_jsonGraph) {};

/**
 * The preload method retrieves several {\@link Path}s or {\@link PathSet}s from a {\@link Model} and loads them into the Model cache.
 * @param {...!Array<(string|number|boolean|!FalcorJsonGraph.Range|!Array<(string|number|boolean|!FalcorJsonGraph.Range)>)>} path
 * @return {void}
 */
Model.prototype.preload = function(path) {};

/**
 * @template T
 * @param {(string|!Array<(string|number|boolean)>)} functionPath
 * @param {!Array<?>=} args
 * @param {!Array<(string|number|boolean|!FalcorJsonGraph.Range|!Array<(string|number|boolean|!FalcorJsonGraph.Range)>)>=} refPaths
 * @param {!Array<!Array<(string|number|boolean|!FalcorJsonGraph.Range|!Array<(string|number|boolean|!FalcorJsonGraph.Range)>)>>=} thisPaths
 * @return {?}
 */
Model.prototype.call = function(functionPath, args, refPaths, thisPaths) {};

/**
 * The invalidate method synchronously removes several {\@link Path}s or {\@link PathSet}s from a {\@link Model} cache.
 * @param {...!Array<(string|number|boolean|!FalcorJsonGraph.Range|!Array<(string|number|boolean|!FalcorJsonGraph.Range)>)>} path
 * @return {void}
 */
Model.prototype.invalidate = function(path) {};

/**
 * Returns a new {\@link Model} bound to a location within the {\@link JSONGraph}.
 * The bound location is never a {\@link Reference}: any {\@link Reference}s encountered while resolving the bound {\@link Path} are always replaced with the {\@link Reference}s target value.
 * For subsequent operations on the {\@link Model}, all paths will be evaluated relative to the bound path. Deref allows you to:
 * - Expose only a fragment of the {\@link JSONGraph} to components, rather than the entire graph
 * - Hide the location of a {\@link JSONGraph} fragment from components
 * - Optimize for executing multiple operations and path looksup at/below the same location in the {\@link JSONGraph}
 * @param {?} responseObject
 * @return {?}
 */
Model.prototype.deref = function(responseObject) {};

/**
 * Get data for a single {\@link Path}.
 * @template T
 * @param {(string|!Array<(string|number|boolean)>)} path
 * @return {?}
 */
Model.prototype.getValue = function(path) {};

/**
 * Set value for a single {\@link Path}.
 * @template T
 * @param {(string|!Array<(string|number|boolean)>)} path
 * @param {?} value
 * @return {?}
 */
Model.prototype.setValue = function(path, value) {};

/**
 * Set the local cache to a {\@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.
 * @param {?} jsonGraph
 * @return {void}
 */
Model.prototype.setCache = function(jsonGraph) {};

/**
 * Get the local {\@link JSONGraph} cache. This method can be a useful to store the state of the cache.
 * @param {...!Array<(string|number|boolean|!FalcorJsonGraph.Range|!Array<(string|number|boolean|!FalcorJsonGraph.Range)>)>} path
 * @return {?}
 */
Model.prototype.getCache = function(path) {};

/**
 * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.
 * @param {!Array<(string|number|boolean)>=} path
 * @return {number}
 */
Model.prototype.getVersion = function(path) {};

/**
 * Returns a clone of the {\@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {\@link DataSource} in a batch.
 * Batching can be more efficient if the {\@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.
 * @param {(number|?)=} schedulerOrDelay
 * @return {?}
 */
Model.prototype.batch = function(schedulerOrDelay) {};

/**
 * Returns a clone of the {\@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {\@link DataSource} separately.
 * @return {?}
 */
Model.prototype.unbatch = function() {};

/**
 * Returns a clone of the {\@link Model} that treats errors as values. Errors will be reported in the same callback used to report data.
 * Errors will appear as objects in responses, rather than being sent to the {\@link Observable~onErrorCallback} callback of the {\@link ModelResponse}.
 * @return {?}
 */
Model.prototype.treatErrorsAsValues = function() {};

/**
 * Adapts a Model to the {\@link DataSource} interface.
 * @return {?}
 */
Model.prototype.asDataSource = function() {};

/**
 * Returns a clone of the {\@link Model} that boxes values returning the wrapper ({\@link Atom}, {\@link Reference}, or {\@link Error}), rather than the value inside it.
 * This allows any metadata attached to the wrapper to be inspected.
 * @return {?}
 */
Model.prototype.boxValues = function() {};

/**
 * Returns a clone of the {\@link Model} that unboxes values, returning the value inside of the wrapper ({\@link Atom}, {\@link Reference}, or {\@link Error}), rather than the wrapper itself.
 * This is the default mode.
 * @return {?}
 */
Model.prototype.unboxValues = function() {};

/**
 * Returns a clone of the {\@link Model} that only uses the local {\@link JSONGraph} and never uses a {\@link DataSource} to retrieve missing paths.
 * @return {?}
 */
Model.prototype.withoutDataSource = function() {};

/**
 * Returns the {\@link Path} to the object within the JSON Graph that this Model references.
 * @return {!Array<(string|number|boolean)>}
 */
Model.prototype.getPath = function() {};

/**
 * @constructor
 * @struct
 * @param {?} observable
 */
function ModelResponse(observable) {}

/**
 * @return {?}
 */
ModelResponse.prototype.progressively = function() {};

/**
 * @param {?} onNext
 * @param {?=} onError
 * @param {?=} onCompleted
 * @return {?}
 */
ModelResponse.prototype.forEach = function(onNext, onError, onCompleted) {};

/**
 * @template U
 * @param {?=} onFulfilled
 * @param {?=} onRejected
 * @return {?}
 */
ModelResponse.prototype.then = function(onFulfilled, onRejected) {};
/**
 * @record
 * @struct
 */
function Thenable() {}

/**
 * @template U
 * @param {?=} onFulfilled
 * @param {?=} onRejected
 * @return {?}
 */
Thenable.prototype.then = function(onFulfilled, onRejected) {};
/**
 * @constructor
 * @struct
 */
function Observable() {}

/**
 * The forEach method is a synonym for {\@link Observable.prototype.subscribe} and triggers the execution of the Observable, causing the values within to be pushed to a callback.
 * An Observable is like a pipe of water that is closed.
 * When forEach is called, we open the valve and the values within are pushed at us.
 * These values can be received using either callbacks or an {\@link Observer} object.
 * @param {?=} onNext
 * @param {?=} onError
 * @param {?=} onCompleted
 * @return {?}
 */
Observable.prototype.forEach = function(onNext, onError, onCompleted) {};

/**
 * The subscribe method is a synonym for {\@link Observable.prototype.forEach} and triggers the execution of the Observable, causing the values within to be pushed to a callback.
 * An Observable is like a pipe of water that is closed.
 * When forEach is called, we open the valve and the values within are pushed at us.  These values can be received using either callbacks or an {\@link Observer} object.
 * @param {?=} onNext
 * @param {?=} onError
 * @param {?=} onCompleted
 * @return {?}
 */
Observable.prototype.subscribe = function(onNext, onError, onCompleted) {};

/** @typedef {?} */
var ObservableOnNextCallback;

/** @typedef {?} */
var ObservableOnErrorCallback;

/** @typedef {?} */
var ObservableOnCompletedCallback;
/**
 * @constructor
 * @struct
 */
function Subscription() {}

/**
 * When this method is called on the Subscription, the Observable that created the Subscription will stop sending values to the callbacks passed when the Subscription was created.
 * @return {void}
 */
Subscription.prototype.dispose = function() {};
/**
 * @record
 * @struct
 */
function Scheduler() {}

/**
 * @param {?} handler
 * @return {?}
 */
Scheduler.prototype.catch = function(handler) {};

/**
 * @param {?} handler
 * @return {?}
 */
Scheduler.prototype.catchException = function(handler) {};
