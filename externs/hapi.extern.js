/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/hapi/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/** @typedef {(?|!Array<?>)} */
var JoiValidationObject;

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportDeclaration in  */
/**
 * @record
 * @struct
 */
function Dictionary() {}

/* TODO: IndexSignature:  */

/**
 * @constructor
 * @struct
 * Creates a new Server object
 * @param {?=} options
 */
function Server(options) {}
 /** @type {?} */
Server.prototype.app;
 /** @type {!Array<?>} */
Server.prototype.connections;
 /** @type {?} */
Server.prototype.info;
 /** @type {?} */
Server.prototype.load;
 /** @type {!Server} */
Server.prototype.listener;
 /** @type {?} */
Server.prototype.methods;
 /** @type {?} */
Server.prototype.mime;
 /** @type {?} */
Server.prototype.plugins;
 /** @type {?} */
Server.prototype.realm;
 /** @type {?} */
Server.prototype.registrations;
 /** @type {?} */
Server.prototype.root;
 /** @type {?} */
Server.prototype.settings;
 /** @type {string} */
Server.prototype.version;
 /** @type {?} */
Server.prototype.auth;
 /** @type {?} */
Server.prototype.cache;

/**
 * Sets a global context used as the default bind object when adding a route or an extension
 * When setting context inside a plugin, the context is applied only to methods set up by the plugin. Note that the context applies only to routes and extensions added after it has been set. Ignored if the method being bound is an arrow function.
 * @param {?} context  the object used to bind this in handler and extension methods.
 * [See docs](https://hapijs.com/api/16.1.1#serverbindcontext)
 * @return {void}
 */
Server.prototype.bind = function(context) {};

/**
 * Adds an incoming server connection
 * Returns a server object with the new connections selected.
 * Must be called before any other server method that modifies connections is called for it to apply to the new connection (e.g. server.state())
 * Note that the options object is deeply cloned (with the exception of listener which is shallowly copied) and cannot contain any values that are unsafe to perform deep copy on.
 * 
 * [See docs](https://hapijs.com/api/16.1.1#serverconnectionoptions) for various advantage topics covering usage and caveats around use of the function in plugin register(), connectionless plugins calling connection(), etc.
 * @param {!Array<?>|?=} options
 * @return {?}
 */
Server.prototype.connection = function(options) {};

/**
 * Registers a custom content decoding compressor to extend the built-in support for 'gzip' and 'deflate'
 * [See docs](https://hapijs.com/api/16.1.1#serverdecoderencoding-decoder)
 * @param {string} encoding  the decoder name string.
 * @param {?} decoder  a function using the signature function(options) where options are the encoding specific options configured in the route payload.compression configuration option, and the return value is an object compatible with the output of node's zlib.createGunzip().
 * @return {void}
 */
Server.prototype.decoder = function(encoding, decoder) {};

/**
 * Extends various framework interfaces with custom methods
 * Note that decorations apply to the entire server and all its connections regardless of current selection.
 * [See docs](https://hapijs.com/api/16.1.1#serverdecoratetype-property-method-options)
 * 
 * NOTE: it's not possible to type the result of this action.
 * It's advised that in a custom definition file, you extend the ReplyNoContinue
 * and ReplyWithContinue functions.  See Inert `.file` for an example.
 * Or if it is not part of a library / plugin then you use a namespace within
 * your code to type the request, server and or reply.  See
 * [tests/server/decorate.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/hapi/tests/server/decorate.ts)
 * for examples.
 * @param {string} type  the interface being decorated. Supported types:
 *      * 'request' - adds methods to the Request object.
 *      * 'reply' - adds methods to the reply interface.
 *      * 'server' - adds methods to the Server object.
 * @param {string} property  the object decoration key name.
 * @param {!Function|?} method  the extension function or other value.
 * @param {?=} options
 * @return {void}
 */
Server.prototype.decorate = function(type, property, method, options) {};

/**
 * Used within a plugin to declare a required dependency on other plugins
 * The after method is identical to setting a server extension point on 'onPreStart'. Connectionless plugins (those with attributes.connections set to false) can only depend on other connectionless plugins (server initialization will fail even of the dependency is loaded but is not connectionless).
 * Dependencies can also be set via the register attributes property (does not support setting after).
 * [See docs](https://hapijs.com/api/16.1.1#serverdependencydependencies-after)
 * @param {(string|!Array<string>)} dependencies  a single string or array of plugin name strings which must be registered in order for this plugin to operate. Plugins listed must be registered before the server is initialized or started. Does not provide version dependency which should be implemented using npm peer dependencies.
 * @param {?=} after  an optional function called after all the specified dependencies have been registered and before the server starts. The function is only called if the server is initialized or started. If a circular dependency is detected, an exception is thrown (e.g. two plugins each has an after function to be called after the other). The function signature is function(server, next)
 * @return {void}
 */
Server.prototype.dependency = function(dependencies, after) {};

/**
 * Emits a custom application event update to all the subscribed listeners
 * Note that events must be registered before they can be emitted or subscribed to by calling server.event(events). This is done to detect event name misspelling and invalid event activities.
 * [See docs](https://hapijs.com/api/16.1.1#serveremitcriteria-data-callback)
 * @param {(string|?)} criteria  the event update criteria which if an object can have the following optional keys (unless noted otherwise):
 *      * name - the event name string (required).
 *      * channel - the channel name string.
 *      * tags - a tag string or array of tag strings.
 * @param {?} data  the value emitted to the subscribers. If data is a function, the function signature is function() and it called once to generate (return value) the actual data emitted to the listeners. If no listeners match the event, the data function is not invoked.
 * @param {?=} callback  an optional callback method invoked when all subscribers have been notified using the signature function(). The callback is called only after all the listeners have been notified, including any event updates emitted earlier (the order of event updates are guaranteed to be in the order they were emitted).
 * @return {void}
 */
Server.prototype.emit = function(criteria, data, callback) {};

/**
 * Registers a custom content encoding compressor to extend the built-in support for 'gzip' and 'deflate'
 * [See docs](https://hapijs.com/api/16.1.1#serverencoderencoding-encoder)
 * @param {string} encoding  the encoder name string.
 * @param {?} encoder  a function using the signature function(options) where options are the encoding specific options configured in the route compression configuration option, and the return value is an object compatible with the output of node's zlib.createGzip().
 * @return {void}
 */
Server.prototype.encoder = function(encoding, encoder) {};

/**
 * Register custom application events
 * [See docs](https://hapijs.com/api/16.1.1#servereventevents)
 * @param {!Array<(string|?)>|(string|?)} events  see ApplicationEvent
 * @return {void}
 */
Server.prototype.event = function(events) {};

/**
 * Used within a plugin to expose a property via server.plugins[name]
 * [See docs](https://hapijs.com/api/16.1.1#serverexposekey-value)
 * Merges an object into to the existing content of server.plugins[name]
 * Note that all properties of obj are deeply cloned into server.plugins[name], so you should avoid using this method for exposing large objects that may be expensive to clone or singleton objects such as database client objects. Instead favor the server.expose(key, value) form, which only copies a reference to value.
 * [See docs](https://hapijs.com/api/16.1.1#serverexposeobj)
 * @param {string|!Object} key_or_obj  the key assigned (server.plugins[name][key]). /  the object merged into the exposed properties container.
 * @param {?=} value  the value assigned.
 * @return {void}
 */
Server.prototype.expose = function(key_or_obj, value) {};

/**
 * Registers an extension function in one of the available extension points
 * [See docs](https://hapijs.com/api/16.1.1#serverextevents)
 * Registers a single extension event using the same properties as used in server.ext(events), but passed as arguments.
 * [See docs](https://hapijs.com/api/16.1.1#serverextevent-method-options)
 * @param {?|!Array<?>|string} events_or_event  see \@ServerExtConfigurationObject /  the extension point event name.
 * @param {!Array<?>|?=} method  a function or an array of functions to be executed at a specified point during request processing.
 * @param {?=} options
 * @return {void}
 */
Server.prototype.ext = function(events_or_event, method, options) {};

/**
 * Registers a new handler type to be used in routes
 * The method function can have a defaults object or function property. If the property is set to an object, that object is used as the default route config for routes using this handler. If the property is set to a function, the function uses the signature function(method) and returns the route default configuration.
 * [See docs](https://hapijs.com/api/16.1.1#serverhandlername-method)
 * @param {string} name  string name for the handler being registered. Cannot override any previously registered type.
 * @param {?} method  the function used to generate the route handler using the signature function(route, options) where:
 *      * route - the route public interface object.
 *      * options - the configuration object provided in the handler config.
 * @return {void}
 */
Server.prototype.handler = function(name, method) {};

/**
 * Initializes the server (starts the caches, finalizes plugin registration) but does not start listening on the connection ports
 * Note that if the method fails and the callback includes an error, the server is considered to be in an undefined state and should be shut down. In most cases it would be impossible to fully recover as the various plugins, caches, and other event listeners will get confused by repeated attempts to start the server or make assumptions about the healthy state of the environment. It is recommended to assert that no error has been returned after calling initialize() to abort the process when the server fails to start properly. If you must try to resume after an error, call server.stop() first to reset the server state.
 * [See docs](https://hapijs.com/api/16.1.1#serverinitializecallback)
 * @param {?=} callback  the callback method when server initialization is completed or failed with the signature function(err)
 * @return {void|!Promise<!Error>}
 */
Server.prototype.initialize = function(callback) {};

/**
 * When the server contains exactly one connection, injects a request into the sole connection simulating an incoming HTTP request without making an actual socket connection. Injection is useful for testing purposes as well as for invoking routing logic internally without the overhead or limitations of the network stack. Utilizes the shot module for performing injections, with some additional options and response properties
 * If no callback is provided, a Promise object is returned.
 * When the server contains more than one connection, each server.connections array member provides its own connection.inject().
 * [See docs](https://hapijs.com/api/16.1.1#serverinjectoptions-callback)
 * @param {(string|?)} options  can be assigned a string with the requested URI, or an object
 * @param {?=} callback  the callback function with signature function(res)
 * @return {void|!Promise<?>}
 */
Server.prototype.inject = function(options, callback) {};

/**
 * Logs server events that cannot be associated with a specific request. When called the server emits a 'log' event which can be used by other listeners or plugins to record the information or output to the console.
 * [See docs](https://hapijs.com/api/16.1.1#serverlogtags-data-timestamp)
 * @param {(string|!Array<string>)} tags  a string or an array of strings (e.g. ['error', 'database', 'read']) used to identify the event. Tags are used instead of log levels and provide a much more expressive mechanism for describing and filtering events. Any logs generated by the server internally include the 'hapi' tag along with event-specific information.
 * @param {(string|!Object|!Function)=} data  an optional message string or object with the application data being logged. If data is a function, the function signature is function() and it called once to generate (return value) the actual data emitted to the listeners. If no listeners match the event, the data function is not invoked.
 * @param {number=} timestamp  an optional timestamp expressed in milliseconds. Defaults to Date.now() (now).
 * @return {void}
 */
Server.prototype.log = function(tags, data, timestamp) {};

/**
 * When the server contains exactly one connection, looks up a route configuration.
 * When the server contains more than one connection, each server.connections array member provides its own connection.lookup() method.
 * [See docs](https://hapijs.com/api/16.1.1#serverlookupid)
 * @param {string} id  the route identifier as set in the route options.
 * @return {?} the route public interface object if found, otherwise null.
 */
Server.prototype.lookup = function(id) {};

/**
 * When the server contains exactly one connection, looks up a route configuration
 * When the server contains more than one connection, each server.connections array member provides its own connection.match() method.
 * [See docs](https://hapijs.com/api/16.1.1#servermatchmethod-path-host)
 * @param {string} method  the HTTP method (e.g. 'GET', 'POST').  TODO check if it allows HEAD
 * @param {string} path  the requested path (must begin with '/').
 * @param {string=} host  optional hostname (to match against routes with vhost).
 * @return {?} the route public interface object if found, otherwise null.
 */
Server.prototype.match = function(method, path, host) {};

/**
 * Registers a server method. Server methods are functions registered with the server and used throughout the application as a common utility. Their advantage is in the ability to configure them to use the built-in cache and share across multiple request handlers without having to create a common module.
 * [See docs](https://hapijs.com/api/16.1.1#servermethodname-method-options)
 * Registers a server method function as described in server.method() using a configuration object
 * [See docs](https://hapijs.com/api/16.1.1#servermethodmethods)
 * @param {string|!Array<?>|?} name_or_methods  a unique method name used to invoke the method via server.methods[name]. Supports using nested names such as utils.users.get which will automatically create the missing path under server.methods and can be accessed for the previous example via server.methods.utils.users.get. When configured with caching enabled, server.methods[name].cache will be an object see ServerMethodNameCacheObject
 * @param {?=} method  the method function
 * @param {?=} options  optional configuration
 * @return {void}
 */
Server.prototype.method = function(name_or_methods, method, options) {};

/**
 * Subscribe a handler to an event
 * [See docs](https://hapijs.com/api/16.1.1#serveroncriteria-listener)
 * The 'log' event includes the event object and a tags object (where each tag is a key with the value true)
 * [See docs](https://hapijs.com/api/16.1.1#server-events)
 * The 'request' and 'request-internal' events include the request object, the event object, and a tags object (where each tag is a key with the value true)
 * [See docs](https://hapijs.com/api/16.1.1#server-events)
 * TODO submit issue to TypeScript.  Using 'request' | 'request-internal' removes the type
 * interference when using code like: `server.on('request', (request, event, tags) => {...}`
 * Same for 'response' | 'tail'.
 * The 'request-error' event includes the request object and the causing error err object
 * [See docs](https://hapijs.com/api/16.1.1#server-events)
 * The 'response' and 'tail' events include the request object
 * [See docs](https://hapijs.com/api/16.1.1#server-events)
 * See 'request' and 'request-internal'
 * The 'route' event includes the route public interface, the connection, and the server object used to add the route (e.g. the result of a plugin select operation)
 * [See docs](https://hapijs.com/api/16.1.1#server-events)
 * @param {(string|?)|string} criteria  the subscription criteria which can be an event name string which can be any of the built-in server events or a custom application event registered with server.event(events).
 * Or an see ServerEventCriteria.
 * If 'start' - emitted when the server is started using server.start().
 * If 'stop' - emitted when the server is stopped using server.stop().
 * @param {!Function|?} listener
 * @return {void}
 */
Server.prototype.on = function(criteria, listener) {};

/**
 * Same as calling server.on() with the count option set to 1.
 * TODO type this to copy the server.on specific types for 'route', 'tail', etc.
 * [See docs](https://hapijs.com/api/16.1.1#serveroncecriteria-listener)
 * @param {(string|?)} criteria
 * @param {!Function} listener
 * @return {void}
 */
Server.prototype.once = function(criteria, listener) {};

/**
 * Sets the path prefix used to locate static resources (files and view templates) when relative paths are used
 * Note that setting a path within a plugin only applies to resources accessed by plugin methods. If no path is set, the connection files.relativeTo configuration is used. The path only applies to routes added after it has been set.
 * [See docs](https://hapijs.com/api/16.1.1#serverpathrelativeto)
 * @param {string} relativeTo  the path prefix added to any relative file path starting with '.'.
 * @return {void}
 */
Server.prototype.path = function(relativeTo) {};

/**
 * Registers a plugin
 * If no callback is provided, a Promise object is returned.
 * Note that plugin registration are recorded on each of the available connections. When plugins express a dependency on other plugins, both have to be loaded into the same connections for the dependency requirement to be fulfilled. It is recommended that plugin registration happen after all the server connections are created via server.connection().
 * [See docs](https://hapijs.com/api/16.1.1#serverregisterplugins-options-callback)
 * @template OptionsPassedToPlugin
 * @param {!Array<?>|?} plugins
 * @param {?=} callback_or_options  with signature function(err) where err an error returned from the registration function. Note that exceptions thrown by the registration function are not handled by the framework.
 * A note on typings.  Common use case is:
 *     register(Plugin, (err) => {// do more stuff})
 * so these typings save passing empty `options` object or having to
 * explicity type the Error in the Callback e.g.:
 *     register(Plugin, {}, (err) => {// do more stuff})  or
 *     register(Plugin, (err: Error) => {// do more stuff})
 * @param {?=} callback
 * @return {void|!Promise<!Error>}
 */
Server.prototype.register = function(plugins, callback_or_options, callback) {};

/**
 * Adds a connection route
 * [See docs](https://hapijs.com/api/16.1.1#serverrouteoptions)
 * @param {!Array<?>|?} options  a route configuration object [See docs](https://hapijs.com/api/16.1.1#route-configuration) or an array of configuration objects.
 * @return {void}
 */
Server.prototype.route = function(options) {};

/**
 * Selects a subset of the server's connections
 * Returns a server object with connections set to the requested subset. Selecting again on a selection operates as a logic AND statement between the individual selections.
 * [See docs](https://hapijs.com/api/16.1.1#serverselectlabels)
 * @param {(string|!Array<string>)} labels  a single string or array of strings of labels used as a logical OR statement to select all the connections with matching labels in their configuration.
 * @return {?}
 */
Server.prototype.select = function(labels) {};

/**
 * Starts the server connections by listening for incoming requests on the configured port of each listener (unless the connection was configured with autoListen set to false)
 * If no callback is provided, a Promise object is returned.
 * Note that if the method fails and the callback includes an error, the server is considered to be in an undefined state and should be shut down. In most cases it would be impossible to fully recover as the various plugins, caches, and other event listeners will get confused by repeated attempts to start the server or make assumptions about the healthy state of the environment. It is recommended to assert that no error has been returned after calling start() to abort the process when the server fails to start properly. If you must try to resume after a start error, call server.stop() first to reset the server state.
 * If a started server is started again, the second call to start() will only start new connections added after the initial start() was called. No events will be emitted and no extension points invoked.
 * [See docs](https://hapijs.com/api/16.1.1#serverstartcallback)
 * @param {?=} callback  the callback method when server startup is completed or failed with the signature function(err) where:
 *      * err - any startup error condition.
 * @return {void|!Promise<!Error>}
 */
Server.prototype.start = function(callback) {};

/**
 * HTTP state management [See docs](https://tools.ietf.org/html/rfc6265) uses client cookies to persist a state across multiple requests. Registers a cookie definitions
 * [See docs](https://hapijs.com/api/16.1.1#serverstatename-options)
 * @param {string} name  the cookie name string.
 * @param {?=} options  optional cookie settings
 * @return {void}
 */
Server.prototype.state = function(name, options) {};

/**
 * Stops the server's connections by refusing to accept any new connections or requests (existing connections will continue until closed or timeout)
 * If no callback is provided, a Promise object is returned.
 * [See docs](https://hapijs.com/api/16.1.1#serverstopoptions-callback)
 * @param {?=} options  options object with:
 *      * timeout - overrides the timeout in millisecond before forcefully terminating a connection. Defaults to 5000 (5 seconds).
 * @param {?=} callback  optional callback method which is called once all the connections have ended and it is safe to exit the process with signature function(err) where:
 *      * err - any termination error condition.
 * @return {void|!Promise<!Error>}
 */
Server.prototype.stop = function(options, callback) {};

/**
 * Returns a copy of the routing table
 * Note that if the server has not been started and multiple connections use port 0, the table items will override each other and will produce an incomplete result.
 * When calling connection.table() directly on each connection, the return value is the same as the array table item value of an individual connection
 * [See docs](https://hapijs.com/api/16.1.1#servertablehost)
 * @param {string=} host  optional host to filter routes matching a specific virtual host. Defaults to all virtual hosts.
 * @return {!Array<?>}
 */
Server.prototype.table = function(host) {};
/**
 * @record
 * @struct
 */
function PluginSpecificConfiguration() {}
/**
 * @record
 * @struct
 */
function ServerOptions() {}
 /** @type {?} */
ServerOptions.prototype.app;
 /** @type {(?|!Array<?>)} */
ServerOptions.prototype.cache;
 /** @type {?} */
ServerOptions.prototype.connections;
 /** @type {(boolean|?)} */
ServerOptions.prototype.debug;
 /** @type {?} */
ServerOptions.prototype.load;
 /** @type {?} */
ServerOptions.prototype.mime;
 /** @type {?} */
ServerOptions.prototype.plugins;
 /** @type {boolean} */
ServerOptions.prototype.useDomains;
/**
 * @record
 * @struct
 */
function ServerEventObject() {}
 /** @type {number} */
ServerEventObject.prototype.timestamp;
 /** @type {string} */
ServerEventObject.prototype.request;
 /** @type {string} */
ServerEventObject.prototype.server;
 /** @type {!Array<string>} */
ServerEventObject.prototype.tags;
 /** @type {?} */
ServerEventObject.prototype.data;
 /** @type {boolean} */
ServerEventObject.prototype.internal;
/**
 * @record
 * @struct
 */
function ServerEventCriteria() {}
 /** @type {string} */
ServerEventCriteria.prototype.name;
 /** @type {boolean} */
ServerEventCriteria.prototype.block;
 /** @type {(string|!Array<string>)} */
ServerEventCriteria.prototype.channels;
 /** @type {boolean} */
ServerEventCriteria.prototype.clone;
 /** @type {number} */
ServerEventCriteria.prototype.count;
 /** @type {(string|!Array<string>|?)} */
ServerEventCriteria.prototype.filter;
 /** @type {boolean} */
ServerEventCriteria.prototype.spread;
 /** @type {boolean} */
ServerEventCriteria.prototype.tags;
/**
 * @record
 * @struct
 */
function ServerMethod() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
 /** @type {?} */
ServerMethod.prototype.cache;
/**
 * @record
 * @struct
 */
function ServerMethodNext() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ServerMethodNameCacheObject() {}
 /** @type {?} */
ServerMethodNameCacheObject.prototype.stats;

/**
 * function that can be used to clear the cache for a given key.
 * @param {...?} args
 * @return {void}
 */
ServerMethodNameCacheObject.prototype.drop = function(args) {};
/**
 * @record
 * @struct
 */
function ServerMethodOptions() {}
 /** @type {?} */
ServerMethodOptions.prototype.bind;
 /** @type {?} */
ServerMethodOptions.prototype.cache;
 /** @type {boolean} */
ServerMethodOptions.prototype.callback;

/**
 * a function used to generate a unique key (for caching) from the arguments passed to the method function (the callback argument is not passed as input). The server will automatically generate a unique key if the function's arguments are all of types 'string', 'number', or 'boolean'. However if the method uses other types of arguments, a key generation function must be provided which takes the same arguments as the function and returns a unique string (or null if no key can be generated).
 * @param {!Array<?>} args
 * @return {string}
 */
ServerMethodOptions.prototype.generateKey = function(args) {};
/**
 * @record
 * @struct
 */
function ServerMethodConfigurationObject() {}
 /** @type {string} */
ServerMethodConfigurationObject.prototype.name;
 /** @type {?} */
ServerMethodConfigurationObject.prototype.method;
 /** @type {?} */
ServerMethodConfigurationObject.prototype.options;

/** @typedef {?} */
var CatboxServerOptionsCacheConfiguration;
/**
 * @extends {PolicyOptions}
 * @record
 * @struct
 */
function CatboxServerCacheConfiguration() {}
 /** @type {string} */
CatboxServerCacheConfiguration.prototype.cache;
 /** @type {string} */
CatboxServerCacheConfiguration.prototype.segment;
 /** @type {boolean} */
CatboxServerCacheConfiguration.prototype.shared;
 /** @type {?} */
CatboxServerCacheConfiguration.prototype.engine;
 /** @type {string} */
CatboxServerCacheConfiguration.prototype.name;

/* TODO: IndexSignature:  */
/**
 * @extends {Shot.RequestOptions}
 * @record
 * @struct
 */
function InjectedRequestOptions() {}
 /** @type {?} */
InjectedRequestOptions.prototype.credentials;
 /** @type {?} */
InjectedRequestOptions.prototype.artifacts;
 /** @type {?} */
InjectedRequestOptions.prototype.app;
 /** @type {?} */
InjectedRequestOptions.prototype.plugins;
 /** @type {boolean} */
InjectedRequestOptions.prototype.allowInternals;
/**
 * @extends {Shot.ResponseObject}
 * @record
 * @struct
 */
function InjectedResponseObject() {}
 /** @type {(string|!Object)} */
InjectedResponseObject.prototype.result;
 /** @type {?} */
InjectedResponseObject.prototype.request;
/**
 * @record
 * @struct
 */
function ConnectionConfigurationServerDefaults() {}
 /** @type {?} */
ConnectionConfigurationServerDefaults.prototype.app;
 /** @type {boolean} */
ConnectionConfigurationServerDefaults.prototype.compression;
 /** @type {?} */
ConnectionConfigurationServerDefaults.prototype.load;
 /** @type {?} */
ConnectionConfigurationServerDefaults.prototype.plugins;
 /** @type {?} */
ConnectionConfigurationServerDefaults.prototype.router;
 /** @type {?} */
ConnectionConfigurationServerDefaults.prototype.routes;
 /** @type {?} */
ConnectionConfigurationServerDefaults.prototype.state;
/**
 * @extends {ConnectionConfigurationServerDefaults}
 * @record
 * @struct
 */
function ServerConnectionOptions() {}
 /** @type {string} */
ServerConnectionOptions.prototype.host;
 /** @type {string} */
ServerConnectionOptions.prototype.address;
 /** @type {(string|number)} */
ServerConnectionOptions.prototype.port;
 /** @type {string} */
ServerConnectionOptions.prototype.uri;
 /** @type {!Server} */
ServerConnectionOptions.prototype.listener;
 /** @type {boolean} */
ServerConnectionOptions.prototype.autoListen;
 /** @type {(string|!Array<string>)} */
ServerConnectionOptions.prototype.labels;
 /** @type {(boolean|!RequestOptions)} */
ServerConnectionOptions.prototype.tls;

/** @typedef {?} */
var CompressionEncoderSettings;

/** @typedef {?} */
var CompressionDecoderSettings;
/**
 * @record
 * @struct
 */
function AfterDependencyLoadCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function AuthOptions() {}
 /** @type {string} */
AuthOptions.prototype.mode;
 /** @type {!Array<string>} */
AuthOptions.prototype.strategies;
 /** @type {string} */
AuthOptions.prototype.strategy;
 /** @type {(boolean|string)} */
AuthOptions.prototype.payload;
 /** @type {(?|!Array<?>)} */
AuthOptions.prototype.access;
 /** @type {(string|boolean|!Array<string>)} */
AuthOptions.prototype.scope;
 /** @type {string} */
AuthOptions.prototype.entity;
/**
 * @record
 * @struct
 */
function RouteAuthAccessConfiguationObject() {}
 /** @type {(string|boolean|!Array<string>)} */
RouteAuthAccessConfiguationObject.prototype.scope;
 /** @type {string} */
RouteAuthAccessConfiguationObject.prototype.entity;

/** @typedef {?} */
var RouteCacheOptions;
/**
 * @record
 * @struct
 */
function CorsConfigurationObject() {}
 /** @type {(!Array<string>|string)} */
CorsConfigurationObject.prototype.origin;
 /** @type {number} */
CorsConfigurationObject.prototype.maxAge;
 /** @type {!Array<string>} */
CorsConfigurationObject.prototype.headers;
 /** @type {!Array<string>} */
CorsConfigurationObject.prototype.additionalHeaders;
 /** @type {!Array<string>} */
CorsConfigurationObject.prototype.exposedHeaders;
 /** @type {!Array<string>} */
CorsConfigurationObject.prototype.additionalExposedHeaders;
 /** @type {boolean} */
CorsConfigurationObject.prototype.credentials;
/**
 * @record
 * @struct
 */
function ServerStartExtConfigurationObject() {}
 /** @type {string} */
ServerStartExtConfigurationObject.prototype.type;
 /** @type {(?|!Array<?>)} */
ServerStartExtConfigurationObject.prototype.method;
 /** @type {?} */
ServerStartExtConfigurationObject.prototype.options;
/**
 * @record
 * @struct
 */
function ServerRequestExtConfigurationObject() {}
 /** @type {string} */
ServerRequestExtConfigurationObject.prototype.type;
 /** @type {(?|!Array<?>)} */
ServerRequestExtConfigurationObject.prototype.method;
 /** @type {?} */
ServerRequestExtConfigurationObject.prototype.options;
/**
 * @record
 * @struct
 */
function ServerRequestExtConfigurationObjectWithRequest() {}
 /** @type {string} */
ServerRequestExtConfigurationObjectWithRequest.prototype.type;
 /** @type {(?|!Array<?>)} */
ServerRequestExtConfigurationObjectWithRequest.prototype.method;
 /** @type {?} */
ServerRequestExtConfigurationObjectWithRequest.prototype.options;

/** @typedef {?} */
var RouteExtConfigurationObject;

/** @typedef {?} */
var ServerExtMethod;
/**
 * @record
 * @struct
 */
function ServerExtOptions() {}
 /** @type {(string|!Array<string>)} */
ServerExtOptions.prototype.before;
 /** @type {(string|!Array<string>)} */
ServerExtOptions.prototype.after;
 /** @type {?} */
ServerExtOptions.prototype.bind;
 /** @type {string} */
ServerExtOptions.prototype.sandbox;

/** @typedef {string} */
var ServerStartExtPoints;

/** @typedef {string} */
var ServerRequestExtPointsBase;

/** @typedef {string} */
var ServerRequestExtPoints;
/**
 * @record
 * @struct
 */
function ServerExtFunction() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function RoutePayloadConfigurationObject() {}
 /** @type {string} */
RoutePayloadConfigurationObject.prototype.output;
 /** @type {(boolean|string)} */
RoutePayloadConfigurationObject.prototype.parse;
 /** @type {(boolean|?)} */
RoutePayloadConfigurationObject.prototype.multipart;
 /** @type {(string|!Array<string>)} */
RoutePayloadConfigurationObject.prototype.allow;
 /** @type {string} */
RoutePayloadConfigurationObject.prototype.override;
 /** @type {number} */
RoutePayloadConfigurationObject.prototype.maxBytes;
 /** @type {number} */
RoutePayloadConfigurationObject.prototype.timeout;
 /** @type {string} */
RoutePayloadConfigurationObject.prototype.uploads;
 /** @type {string} */
RoutePayloadConfigurationObject.prototype.failAction;
 /** @type {string} */
RoutePayloadConfigurationObject.prototype.defaultContentType;
 /** @type {?} */
RoutePayloadConfigurationObject.prototype.compression;

/** @typedef {string} */
var PayLoadOutputOption;

/** @typedef {(string|?)} */
var ApplicationEvent;
/**
 * @record
 * @struct
 */
function ApplicationEventOptionsObject() {}
 /** @type {string} */
ApplicationEventOptionsObject.prototype.name;
 /** @type {(string|!Array<string>)} */
ApplicationEventOptionsObject.prototype.channels;
 /** @type {boolean} */
ApplicationEventOptionsObject.prototype.clone;
 /** @type {boolean} */
ApplicationEventOptionsObject.prototype.spread;
 /** @type {boolean} */
ApplicationEventOptionsObject.prototype.tags;
 /** @type {boolean} */
ApplicationEventOptionsObject.prototype.shared;
/**
 * @record
 * @struct
 */
function RouteConfiguration() {}
 /** @type {string} */
RouteConfiguration.prototype.path;
 /** @type {(string|!Array<string>)} */
RouteConfiguration.prototype.method;
 /** @type {string} */
RouteConfiguration.prototype.vhost;
 /** @type {(string|?)} */
RouteConfiguration.prototype.handler;
 /** @type {?} */
RouteConfiguration.prototype.config;
/**
 * @record
 * @struct
 */
function RouteAdditionalConfigurationOptions() {}
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.app;
 /** @type {(string|boolean|?)} */
RouteAdditionalConfigurationOptions.prototype.auth;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.bind;
 /** @type {(boolean|?)} */
RouteAdditionalConfigurationOptions.prototype.cache;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.compression;
 /** @type {(boolean|?)} */
RouteAdditionalConfigurationOptions.prototype.cors;
 /** @type {(?|!Array<?>)} */
RouteAdditionalConfigurationOptions.prototype.ext;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.files;
 /** @type {(string|?)} */
RouteAdditionalConfigurationOptions.prototype.handler;
 /** @type {string} */
RouteAdditionalConfigurationOptions.prototype.id;
 /** @type {boolean} */
RouteAdditionalConfigurationOptions.prototype.isInternal;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.json;
 /** @type {string} */
RouteAdditionalConfigurationOptions.prototype.jsonp;
 /** @type {boolean} */
RouteAdditionalConfigurationOptions.prototype.log;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.payload;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.plugins;
 /** @type {(!Array<(string|?)>|!Array<(string|?|!Array<(string|?)>)>)} */
RouteAdditionalConfigurationOptions.prototype.pre;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.response;
 /** @type {(boolean|?)} */
RouteAdditionalConfigurationOptions.prototype.security;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.state;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.validate;
 /** @type {?} */
RouteAdditionalConfigurationOptions.prototype.timeout;
 /** @type {string} */
RouteAdditionalConfigurationOptions.prototype.description;
 /** @type {(string|!Array<string>)} */
RouteAdditionalConfigurationOptions.prototype.notes;
 /** @type {!Array<string>} */
RouteAdditionalConfigurationOptions.prototype.tags;
/**
 * @record
 * @struct
 */
function RoutePublicInterface() {}
 /** @type {string} */
RoutePublicInterface.prototype.method;
 /** @type {string} */
RoutePublicInterface.prototype.path;
 /** @type {(string|!Array<string>)} */
RoutePublicInterface.prototype.vhost;
 /** @type {?} */
RoutePublicInterface.prototype.realm;
 /** @type {?} */
RoutePublicInterface.prototype.settings;
 /** @type {string} */
RoutePublicInterface.prototype.fingerprint;
 /** @type {?} */
RoutePublicInterface.prototype.auth;

/** @typedef {?} */
var RouteHandlerConfig;
/**
 * @record
 * @struct
 */
function MakeRouteHandler() {}

/* TODO: CallSignature:  */
 /** @type {?} */
MakeRouteHandler.prototype.defaults;
/**
 * @record
 * @struct
 */
function RoutingTableEntry() {}
 /** @type {?} */
RoutingTableEntry.prototype.info;
 /** @type {!Array<string>} */
RoutingTableEntry.prototype.labels;
 /** @type {!Array<?>} */
RoutingTableEntry.prototype.table;
/**
 * @record
 * @struct
 */
function Route() {}
 /** @type {?} */
Route.prototype.settings;
 /** @type {string} */
Route.prototype.method;
 /** @type {string} */
Route.prototype.path;
 /** @type {!Array<string>} */
Route.prototype.params;
 /** @type {?} */
Route.prototype.connection;
 /** @type {string} */
Route.prototype.fingerprint;
 /** @type {?} */
Route.prototype.plugin;
 /** @type {?} */
Route.prototype.public;
 /** @type {?} */
Route.prototype.server;

/** @typedef {(!Array<(string|?)>|!Array<(string|?|!Array<(string|?)>)>)} */
var RoutePrerequisitesArray;

/** @typedef {(string|?)} */
var RoutePrerequisitesPart;
/**
 * @record
 * @struct
 */
function RoutePrerequisiteObjects() {}
 /** @type {(string|?)} */
RoutePrerequisiteObjects.prototype.method;
 /** @type {string} */
RoutePrerequisiteObjects.prototype.assign;
 /** @type {string} */
RoutePrerequisiteObjects.prototype.failAction;
/**
 * @record
 * @struct
 */
function RouteResponseConfigurationObject() {}
 /** @type {number} */
RouteResponseConfigurationObject.prototype.emptyStatusCode;
 /** @type {(string|?)} */
RouteResponseConfigurationObject.prototype.failAction;
 /** @type {boolean} */
RouteResponseConfigurationObject.prototype.modify;
 /** @type {?} */
RouteResponseConfigurationObject.prototype.options;
 /** @type {boolean} */
RouteResponseConfigurationObject.prototype.ranges;
 /** @type {number} */
RouteResponseConfigurationObject.prototype.sample;
 /** @type {(boolean|?|!Array<?>)} */
RouteResponseConfigurationObject.prototype.schema;
 /** @type {?} */
RouteResponseConfigurationObject.prototype.status;

/** @typedef {(boolean|?|!Array<?>)} */
var RouteResponseConfigurationScheme;
/**
 * @record
 * @struct
 */
function ValidationFunctionForRouteResponse() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function RouteResponseValidationContext() {}
 /** @type {?} */
RouteResponseValidationContext.prototype.context;
/**
 * @record
 * @struct
 */
function RouteSecurityConfigurationObject() {}
 /** @type {(number|boolean|?)} */
RouteSecurityConfigurationObject.prototype.hsts;
 /** @type {(boolean|string|?)} */
RouteSecurityConfigurationObject.prototype.xframe;
 /** @type {boolean} */
RouteSecurityConfigurationObject.prototype.xss;
 /** @type {boolean} */
RouteSecurityConfigurationObject.prototype.noOpen;
 /** @type {boolean} */
RouteSecurityConfigurationObject.prototype.noSniff;
/**
 * @record
 * @struct
 */
function RouteValidationConfigurationObject() {}
 /** @type {(boolean|?|!Array<?>)} */
RouteValidationConfigurationObject.prototype.headers;
 /** @type {(boolean|?|!Array<?>)} */
RouteValidationConfigurationObject.prototype.params;
 /** @type {(boolean|?|!Array<?>)} */
RouteValidationConfigurationObject.prototype.query;
 /** @type {(boolean|?|!Array<?>)} */
RouteValidationConfigurationObject.prototype.payload;
 /** @type {?} */
RouteValidationConfigurationObject.prototype.errorFields;
 /** @type {(string|?)} */
RouteValidationConfigurationObject.prototype.failAction;
 /** @type {?} */
RouteValidationConfigurationObject.prototype.options;
/**
 * @record
 * @struct
 */
function ValidationFunctionForRouteInput() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function RouteInputValidationContext() {}
 /** @type {?} */
RouteInputValidationContext.prototype.context;
/**
 * @record
 * @struct
 */
function RouteFailFunction() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ServerStateCookieConfiguationObject() {}
 /** @type {number} */
ServerStateCookieConfiguationObject.prototype.ttl;
 /** @type {boolean} */
ServerStateCookieConfiguationObject.prototype.isSecure;
 /** @type {boolean} */
ServerStateCookieConfiguationObject.prototype.isHttpOnly;
 /** @type {(boolean|string)} */
ServerStateCookieConfiguationObject.prototype.isSameSite;
 /** @type {string} */
ServerStateCookieConfiguationObject.prototype.path;
 /** @type {string} */
ServerStateCookieConfiguationObject.prototype.domain;
 /** @type {string} */
ServerStateCookieConfiguationObject.prototype.encoding;
 /** @type {?} */
ServerStateCookieConfiguationObject.prototype.sign;
 /** @type {string} */
ServerStateCookieConfiguationObject.prototype.password;
 /** @type {?} */
ServerStateCookieConfiguationObject.prototype.iron;
 /** @type {boolean} */
ServerStateCookieConfiguationObject.prototype.ignoreErrors;
 /** @type {boolean} */
ServerStateCookieConfiguationObject.prototype.clearInvalid;
 /** @type {boolean} */
ServerStateCookieConfiguationObject.prototype.strictHeader;
 /** @type {?} */
ServerStateCookieConfiguationObject.prototype.passThrough;

/**
 * if present and the cookie was not received from the client or explicitly set by the route handler, the cookie is automatically added to the response with the provided value. The value can be a function with signature function(request, next) where:
 *  * request - the request object.
 *  * next - the continuation function using the function(err, value) signature.
 * @param {?} request
 * @param {?} next
 * @return {void}
 */
ServerStateCookieConfiguationObject.prototype.autoValue = function(request, next) {};
/**
 * @record
 * @struct
 */
function ServerConnection() {}
 /** @type {?} */
ServerConnection.prototype.settings;
 /** @type {?} */
ServerConnection.prototype.server;
 /** @type {string} */
ServerConnection.prototype.type;
 /** @type {?} */
ServerConnection.prototype.registrations;
 /** @type {?} */
ServerConnection.prototype.states;
 /** @type {?} */
ServerConnection.prototype.auth;
 /** @type {?} */
ServerConnection.prototype.plugins;
 /** @type {?} */
ServerConnection.prototype.app;
 /** @type {!Server} */
ServerConnection.prototype.listener;
 /** @type {?} */
ServerConnection.prototype.info;

/**
 * Described in server.inject [See docs](https://hapijs.com/api/16.1.1#serverinjectoptions-callback)
 * @param {(string|?)} options
 * @param {?=} callback
 * @return {void|!Promise<?>}
 */
ServerConnection.prototype.inject = function(options, callback) {};

/**
 * Mentioned but not documented under server.connections [See docs](https://hapijs.com/api/16.1.1#serverconnections)
 * @param {string=} host
 * @return {!Array<?>}
 */
ServerConnection.prototype.table = function(host) {};

/**
 * Described in server.table [See docs](https://hapijs.com/api/16.1.1#serverlookupid)
 * @param {string} id
 * @return {?}
 */
ServerConnection.prototype.lookup = function(id) {};

/**
 * Described in server.table [See docs](https://hapijs.com/api/16.1.1#servermatchmethod-path-host)
 * @param {string} method
 * @param {string} path
 * @param {string=} host
 * @return {?}
 */
ServerConnection.prototype.match = function(method, path, host) {};
/**
 * @record
 * @struct
 */
function ServerConnectionInfo() {}
 /** @type {string} */
ServerConnectionInfo.prototype.id;
 /** @type {number} */
ServerConnectionInfo.prototype.created;
 /** @type {number} */
ServerConnectionInfo.prototype.started;
 /** @type {(string|number)} */
ServerConnectionInfo.prototype.port;
 /** @type {string} */
ServerConnectionInfo.prototype.host;
 /** @type {string} */
ServerConnectionInfo.prototype.address;
 /** @type {string} */
ServerConnectionInfo.prototype.protocol;
 /** @type {string} */
ServerConnectionInfo.prototype.uri;

/** @typedef {!Server} */
var ServerListener;
/**
 * @record
 * @struct
 */
function ServerRealm() {}
 /** @type {?} */
ServerRealm.prototype.modifiers;
 /** @type {string} */
ServerRealm.prototype.plugin;
 /** @type {?} */
ServerRealm.prototype.pluginOptions;
 /** @type {?} */
ServerRealm.prototype.plugins;
 /** @type {?} */
ServerRealm.prototype.settings;
/**
 * @record
 * @struct
 */
function ServerRegisteredPlugins() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function ServerRegisteredPlugin() {}
 /** @type {string} */
ServerRegisteredPlugin.prototype.version;
 /** @type {string} */
ServerRegisteredPlugin.prototype.name;
 /** @type {?} */
ServerRegisteredPlugin.prototype.options;
 /** @type {?} */
ServerRegisteredPlugin.prototype.attributes;
/**
 * @record
 * @struct
 */
function ServerAuth() {}
 /** @type {?} */
ServerAuth.prototype.api;

/**
 * server.auth.default
 * Sets a default strategy which is applied to every route
 * The default does not apply when the route config specifies auth as false, or has an authentication strategy configured (contains the strategy or strategies authentication settings). Otherwise, the route authentication config is applied to the defaults.
 * Note that if the route has authentication config, the default only applies at the time of adding the route, not at runtime. This means that calling default() after adding a route with some authentication config will have no impact on the routes added prior. However, the default will apply to routes added before default() is called if those routes lack any authentication config.
 * The default auth strategy configuration can be accessed via connection.auth.settings.default. To obtain the active authentication configuration of a route, use connection.auth.lookup(request.route).
 * [See docs](https://hapijs.com/api/16.1.1#serverauthdefaultoptions)
 * @param {(string|?)} options
 * @return {void}
 */
ServerAuth.prototype.default = function(options) {};

/**
 * server.auth.scheme
 * Registers an authentication scheme
 * [See docs](https://hapijs.com/api/16.1.1#serverauthschemename-scheme)
 * @param {string} name the scheme name.
 * @param {?} scheme the method implementing the scheme with signature function(server, options) see ServerAuthScheme
 * @return {void}
 */
ServerAuth.prototype.scheme = function(name, scheme) {};

/**
 * Registers an authentication strategy
 * [See docs](https://hapijs.com/api/16.1.1#serverauthstrategyname-scheme-mode-options)
 * @param {string} name  the strategy name.
 * @param {string} scheme  the scheme name (must be previously registered using server.auth.scheme()).
 * @param {?|(boolean|string)=} options_or_mode  scheme options based on the scheme requirements.
 * @param {?=} options
 * @return {void}
 */
ServerAuth.prototype.strategy = function(name, scheme, options_or_mode, options) {};

/**
 * Tests a request against an authentication strategy
 * Note that the test() method does not take into account the route authentication configuration. It also does not perform payload authentication. It is limited to the basic strategy authentication execution. It does not include verifying scope, entity, or other route properties.
 * [See docs](https://hapijs.com/api/16.1.1#serverauthteststrategy-request-next)
 * @param {string} strategy - the strategy name registered with server.auth.strategy().
 * @param {?} request - the request object.
 * @param {?} next - the callback function with signature function(err, credentials) where:
 *      * err - the error if authentication failed.
 *      * credentials - the authentication credentials object if authentication was successful.
 * @return {void}
 */
ServerAuth.prototype.test = function(strategy, request, next) {};

/** @typedef {?} */
var Strategy;

/** @typedef {?} */
var SchemeSettings;
/**
 * @record
 * @struct
 */
function ServerAuthScheme() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function SchemeMethodResult() {}
 /** @type {?} */
SchemeMethodResult.prototype.api;
 /** @type {?} */
SchemeMethodResult.prototype.options;

/**
 * required function called on each incoming request configured with the authentication scheme
 * When the scheme authenticate() method implementation calls reply() with an error condition, the specifics of the error affect whether additional authentication strategies will be attempted (if configured for the route). If the err passed to the reply() method includes a message, no additional strategies will be attempted. If the err does not include a message but does include the scheme name (e.g. Boom.unauthorized(null, 'Custom')), additional strategies will be attempted in the order of preference (defined in the route configuration). If authentication fails the scheme names will be present in the 'WWW-Authenticate' header.
 * @param {?} request  the request object.
 * @param {?} reply  the reply interface the authentication method must call when done authenticating the request
 * @return {void}
 */
SchemeMethodResult.prototype.authenticate = function(request, reply) {};

/**
 * optional function called to authenticate the request payload
 * When the scheme payload() method returns an error with a message, it means payload validation failed due to bad payload. If the error has no message but includes a scheme name (e.g. Boom.unauthorized(null, 'Custom')), authentication may still be successful if the route auth.payload configuration is set to 'optional'.
 * @param {?} request  the request object.
 * @param {?} reply  is called if authentication failed
 * @return {void}
 */
SchemeMethodResult.prototype.payload = function(request, reply) {};

/**
 * optional function called to decorate the response with authentication headers before the response headers or payload is written where:
 * @param {?} request  the request object.
 * @param {?} reply  is called if an error occured
 * @return {void}
 */
SchemeMethodResult.prototype.response = function(request, reply) {};
/**
 * @record
 * @struct
 */
function ServerCacheMethod() {}

/* TODO: CallSignature:  */

/**
 * Provisions a server cache as described in server.cache
 * If no callback is provided, a Promise object is returned.
 * Note that if the server has been initialized or started, the cache will be automatically started to match the state of any other provisioned server cache.
 * [See docs](https://hapijs.com/api/16.1.1#servercacheprovisionoptions-callback)
 * @param {?} options  same as the server cache configuration options.
 * @param {?=} callback
 * @return {!Promise<?>|void}
 */
ServerCacheMethod.prototype.provision = function(options, callback) {};
/**
 * @constructor
 * @struct
 */
function Request() {}
 /** @type {?} */
Request.prototype.app;
 /** @type {?} */
Request.prototype.auth;
 /** @type {?} */
Request.prototype.connection;
 /** @type {!Domain} */
Request.prototype.domain;
 /** @type {?} */
Request.prototype.headers;
 /** @type {string} */
Request.prototype.id;
 /** @type {?} */
Request.prototype.info;
 /** @type {string} */
Request.prototype.method;
 /** @type {string} */
Request.prototype.mime;
 /** @type {?} */
Request.prototype.orig;
 /** @type {?} */
Request.prototype.params;
 /** @type {!Array<string>} */
Request.prototype.paramsArray;
 /** @type {string} */
Request.prototype.path;
 /** @type {?} */
Request.prototype.payload;
 /** @type {?} */
Request.prototype.plugins;
 /** @type {!Object} */
Request.prototype.pre;
 /** @type {?} */
Request.prototype.response;
 /** @type {!Object} */
Request.prototype.preResponses;
 /** @type {?} */
Request.prototype.query;
 /** @type {?} */
Request.prototype.raw;
 /** @type {?} */
Request.prototype.route;
 /** @type {?} */
Request.prototype.server;
 /** @type {?} */
Request.prototype.state;
 /** @type {!Url} */
Request.prototype.url;

/**
 * request.setUrl(url, [stripTrailingSlash])
 * Available only in 'onRequest' extension methods.
 * Changes the request URI before the router begins processing the request
 * [See docs](https://hapijs.com/api/16.1.1#requestseturlurl-striptrailingslash)
 * @param {(string|!Url)} url  the new request URI. If url is a string, it is parsed with node's URL parse() method. url can also be set to an object compatible with node's URL parse() method output.
 * @param {boolean=} stripTrailingSlash  if true, strip the trailing slash from the path. Defaults to false.
 * @return {void}
 */
Request.prototype.setUrl = function(url, stripTrailingSlash) {};

/**
 * request.setMethod(method)
 * Available only in 'onRequest' extension methods.
 * Changes the request method before the router begins processing the request
 * [See docs](https://hapijs.com/api/16.1.1#requestsetmethodmethod)
 * @param {string} method  is the request HTTP method (e.g. 'GET').
 * @return {void}
 */
Request.prototype.setMethod = function(method) {};

/**
 * request.generateResponse(source, [options])
 * Always available.
 * Returns a response which you can pass into the reply interface where:
 * [See docs](https://hapijs.com/api/16.1.1#requestgenerateresponsesource-options)
 * @param {(string|number|boolean|!Object|!Error|?|!internal.Stream|!Promise<(string|number|boolean|!Object|!Error|?|!internal.Stream)>)=} source  the object to set as the source of the reply interface.  TODO, submit a PR to clarify this doc, from the source code it's clear that "the object to set" refers to something of type `ReplyValue` i.e. that can be null, string, number, object, Stream, Promise, or Buffer.
 * @param {?=} options  options for the method, optional.  Not documented yet, perhaps not very important.
 * @return {?}
 */
Request.prototype.generateResponse = function(source, options) {};

/**
 * request.log(tags, [data, [timestamp]])
 * Always available.
 * Logs request-specific events. When called, the server emits a 'request' event which can be used by other listeners or plugins.
 * Any logs generated by the server internally will be emitted only on the 'request-internal' channel and will include the event.internal flag set to true.
 * [See docs](https://hapijs.com/api/16.1.1#requestlogtags-data-timestamp)
 * @param {(string|!Array<string>)} tags  a string or an array of strings (e.g. ['error', 'database', 'read']) used to identify the event. Tags are used instead of log levels and provide a much more expressive mechanism for describing and filtering events.
 * @param {(string|!Object|?)=} data  an optional message string or object with the application data being logged. If data is a function, the function signature is function() and it called once to generate (return value) the actual data emitted to the listeners.
 * @param {number=} timestamp  an optional timestamp expressed in milliseconds. Defaults to Date.now() (now).
 * @return {void}
 */
Request.prototype.log = function(tags, data, timestamp) {};

/**
 * request.getLog([tags], [internal])
 * Always available.
 * Returns an array containing the events matching any of the tags specified (logical OR)
 * Note that this methods requires the route log configuration set to true.
 * [See docs](https://hapijs.com/api/16.1.1#requestgetlogtags-internal)
 * @param {(string|!Array<string>)|boolean=} tags_or_internal  is a single tag string or array of tag strings. If no tags specified, returns all events.
 * @param {boolean=} internal  filters the events to only those with a matching event.internal value. If true, only internal logs are included. If false, only user event are included. Defaults to all events (undefined).
 * @return {!Array<string>}
 */
Request.prototype.getLog = function(tags_or_internal, internal) {};

/**
 * request.tail([name])
 * Available until immediately after the 'response' event is emitted.
 * Adds a request tail which has to complete before the request lifecycle is complete.
 * Returns a tail function which must be called when the tail activity is completed.
 * Tails are actions performed throughout the request lifecycle, but which may end after a response is sent back to the client. For example, a request may trigger a database update which should not delay sending back a response. However, it is still desirable to associate the activity with the request when logging it (or an error associated with it).
 * When all tails completed, the server emits a 'tail' event.
 * [See docs](https://hapijs.com/api/16.1.1#requesttailname)
 * @param {string=} name  an optional tail name used for logging purposes.
 * @return {?}
 */
Request.prototype.tail = function(name) {};
/**
 * @record
 * @struct
 */
function RequestAuthenticationInformation() {}
 /** @type {boolean} */
RequestAuthenticationInformation.prototype.isAuthenticated;
 /** @type {?} */
RequestAuthenticationInformation.prototype.credentials;
 /** @type {?} */
RequestAuthenticationInformation.prototype.artifacts;
 /** @type {string} */
RequestAuthenticationInformation.prototype.mode;
 /** @type {!Error} */
RequestAuthenticationInformation.prototype.error;

/** @typedef {string} */
var HTTP_METHODS_PARTIAL_lowercase;

/** @typedef {string} */
var HTTP_METHODS_PARTIAL;

/** @typedef {string} */
var HTTP_METHODS;

/** @typedef {string} */
var RequestEventTypes;
/**
 * @record
 * @struct
 */
function RouteHandlerPlugins() {}
/**
 * @record
 * @struct
 */
function RouteHandler() {}

/* TODO: CallSignature:  */

/** @typedef {?} */
var RoutePrerequisiteRequestHandler;
/**
 * @record
 * @struct
 */
function ServerExtRequestHandler() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function RequestHandler() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ContinuationFunction() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ContinuationValueFunction() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/** @typedef {(string|number|boolean|!Object|!Error|?|!internal.Stream|!Promise<(string|number|boolean|!Object|!Error|?|!internal.Stream)>)} */
var ReplyValue;

/** @typedef {(string|number|boolean|!Object|!Error|?|!internal.Stream)} */
var _ReplyValue;
/**
 * @record
 * @struct
 */
function Base_Reply() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
 /** @type {?} */
Base_Reply.prototype.realm;
 /** @type {?} */
Base_Reply.prototype.request;

/**
 * reply.entity(options)
 * Sets the response 'ETag' and 'Last-Modified' headers and checks for any conditional request headers to decide if the response is going to qualify for an HTTP 304 (Not Modified). If the entity values match the request conditions, reply.entity() returns control back to the framework with a 304 response. Otherwise, it sets the provided entity headers and returns null.
 * Returns a response object if the reply is unmodified or null if the response has changed. If null is returned, the developer must call reply() to continue execution. If the response is not null, the developer must not call reply().
 * [See docs](https://hapijs.com/api/16.1.1#replyentityoptions)
 * @param {?} options  a required configuration object with:
 *      * etag - the ETag string. Required if modified is not present. Defaults to no header.
 *      * modified - the Last-Modified header value. Required if etag is not present. Defaults to no header.
 *      * vary - same as the response.etag() option. Defaults to true.
 * @return {?}
 */
Base_Reply.prototype.entity = function(options) {};

/**
 * reply.close([options])
 * Concludes the handler activity by returning control over to the router and informing the router that a response has already been sent back directly via request.raw.res and that no further response action is needed. Supports the following optional options:
 * The response flow control rules do not apply.
 * [See docs](https://hapijs.com/api/16.1.1#replycloseoptions)
 * @param {?=} options  options object:
 *      * end - if false, the router will not call request.raw.res.end()) to ensure the response was ended. Defaults to true.
 * @return {void}
 */
Base_Reply.prototype.close = function(options) {};

/**
 * reply.redirect(uri)
 * Redirects the client to the specified uri. Same as calling reply().redirect(uri).
 * The response flow control rules apply.
 * Sets an HTTP redirection response (302) and decorates the response with additional methods for
 * changing to a permanent or non-rewritable redirect is also available see response object redirect for more information.
 * [See docs](https://hapijs.com/api/16.1.1#replyredirecturi)
 * @param {string} uri  an absolute or relative URI used to redirect the client to another resource.
 * @return {?}
 */
Base_Reply.prototype.redirect = function(uri) {};

/**
 * reply.response(result)
 * Shorthand for calling `reply(null, result)`, replies with the response set to `result`.
 * [See docs](https://hapijs.com/api/16.1.1#replyresponseresult)
 * TODO likely to change.  Await approval of pull request to Hapi docs.
 * @param {(string|number|boolean|!Object|!Error|?|!internal.Stream|!Promise<(string|number|boolean|!Object|!Error|?|!internal.Stream)>)} result
 * @return {?}
 */
Base_Reply.prototype.response = function(result) {};

/**
 * Sets a cookie on the response
 * [See docs](https://hapijs.com/api/16.1.1#reply)
 * TODO likely to change.  Await approval of pull request to Hapi docs.
 * @param {string} name
 * @param {?} value
 * @param {?=} options
 * @return {void}
 */
Base_Reply.prototype.state = function(name, value, options) {};

/**
 * Clears a cookie on the response
 * [See docs](https://hapijs.com/api/16.1.1#reply)
 * TODO likely to change.  Await approval of pull request to Hapi docs.
 * @param {string} name
 * @param {?=} options
 * @return {void}
 */
Base_Reply.prototype.unstate = function(name, options) {};
/**
 * @record
 * @struct
 */
function Continue_Reply() {}

/**
 * @param {(string|number|boolean|!Object|!Error|?|!internal.Stream|!Promise<(string|number|boolean|!Object|!Error|?|!internal.Stream)>)=} result
 * @return {?}
 */
Continue_Reply.prototype.continue = function(result) {};
/**
 * @extends {Base_Reply}
 * @record
 * @struct
 */
function ReplySchemeAuth() {}

/* TODO: CallSignature:  */

/**
 * is called if authentication succeeded
 * @param {?} result  same object as result above.
 * @return {void}
 */
ReplySchemeAuth.prototype.continue = function(result) {};

/** @typedef {?} */
var AnyAuthenticationResponseAction;
/**
 * @record
 * @struct
 */
function AuthenticationResult() {}
 /** @type {?} */
AuthenticationResult.prototype.credentials;
 /** @type {?} */
AuthenticationResult.prototype.artifacts;
/**
 * @record
 * @struct
 */
function AuthenticatedCredentials() {}
/**
 * @extends {Base_Reply}
 * @record
 * @struct
 */
function ReplySchemeAuthOfPayload() {}

/* TODO: CallSignature:  */

/**
 * is called if payload authentication succeeded
 * @return {void}
 */
ReplySchemeAuthOfPayload.prototype.continue = function() {};
/**
 * @extends {Base_Reply}
 * @record
 * @struct
 */
function ReplySchemeAuthDecorateResponse() {}

/* TODO: CallSignature:  */

/**
 * is called if the operation succeeded.
 * @return {void}
 */
ReplySchemeAuthDecorateResponse.prototype.continue = function() {};
/**
 * @extends {Continue_Reply}
 * @extends {Base_Reply}
 * @record
 * @struct
 */
function ReplyWithContinue() {}
/**
 * @extends {Base_Reply}
 * @record
 * @struct
 */
function ReplyNoContinue() {}
/**
 * @record
 * @struct
 */
function Response() {}
 /** @type {number} */
Response.prototype.statusCode;
 /** @type {?} */
Response.prototype.headers;
 /** @type {(string|number|boolean|!Object|!Error|?|!internal.Stream|!Promise<(string|number|boolean|!Object|!Error|?|!internal.Stream)>)} */
Response.prototype.source;
 /** @type {string} */
Response.prototype.variety;
 /** @type {?} */
Response.prototype.app;
 /** @type {?} */
Response.prototype.plugins;
 /** @type {?} */
Response.prototype.settings;
 /** @type {boolean} */
Response.prototype.isBoom;
 /** @type {boolean} */
Response.prototype.isMissing;
 /** @type {!Boom.Output} */
Response.prototype.output;

/**
 * sets the HTTP 'Content-Length' header (to avoid chunked transfer encoding)
 * @param {number} length  the header value. Must match the actual payload size.
 * @return {?}
 */
Response.prototype.bytes = function(length) {};

/**
 * sets the 'Content-Type' HTTP header 'charset' property
 * @param {string} charset  the charset property value.
 * @return {?}
 */
Response.prototype.charset = function(charset) {};

/**
 * sets the HTTP status code
 * @param {number} statusCode  the HTTP status code (e.g. 200).
 * @return {?}
 */
Response.prototype.code = function(statusCode) {};

/**
 * sets the HTTP status message
 * @param {string} httpMessage  the HTTP status message (e.g. 'Ok' for status code 200).
 * @return {?}
 */
Response.prototype.message = function(httpMessage) {};

/**
 * sets the HTTP status code to Created (201) and the HTTP 'Location' header
 * @param {string} uri  an absolute or relative URI used as the 'Location' header value.
 * @return {?}
 */
Response.prototype.created = function(uri) {};

/**
 * sets the string encoding scheme used to serial data into the HTTP payload
 * @param {string} encoding  the encoding property value (see node Buffer encoding [See docs](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings)).
 *  * 'ascii' - for 7-bit ASCII data only. This encoding is fast and will strip the high bit if set.
 *  * 'utf8' - Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
 *  * 'utf16le' - 2 or 4 bytes, little-endian encoded Unicode characters. Surrogate pairs (U+10000 to U+10FFFF) are supported.
 *  * 'ucs2' - Alias of 'utf16le'.
 *  * 'base64' - Base64 encoding. When creating a Buffer from a string, this encoding will also correctly accept "URL and Filename Safe Alphabet" as specified in RFC4648, Section 5.
 *  * 'latin1' - A way of encoding the Buffer into a one-byte encoded string (as defined by the IANA in RFC1345, page 63, to be the Latin-1 supplement block and C0/C1 control codes).
 *  * 'binary' - Alias for 'latin1'.
 *  * 'hex' - Encode each byte as two hexadecimal characters.
 * @return {?}
 */
Response.prototype.encoding = function(encoding) {};

/**
 * sets the representation entity tag
 * @param {string} tag  the entity tag string without the double-quote.
 * @param {?=} options  options object
 *      * weak - if true, the tag will be prefixed with the 'W/' weak signifier. Weak tags will fail to match identical tags for the purpose of determining 304 response status. Defaults to false.
 *      * vary - if true and content encoding is set or applied to the response (e.g 'gzip' or 'deflate'), the encoding name will be automatically added to the tag at transmission time (separated by a '-' character). Ignored when weak is true. Defaults to true.
 * @return {?}
 */
Response.prototype.etag = function(tag, options) {};

/**
 * sets an HTTP header
 * @param {string} name  the header name.
 * @param {string} value  the header value.
 * @param {?=} options
 * @return {?}
 */
Response.prototype.header = function(name, value, options) {};

/**
 * sets the HTTP 'Location' header
 * @param {string} uri  an absolute or relative URI used as the 'Location' header value.
 * @return {?}
 */
Response.prototype.location = function(uri) {};

/**
 * sets an HTTP redirection response (302) and decorates the response with additional methods listed below,
 * @param {string} uri  an absolute or relative URI used to redirect the client to another resource.
 * @return {?}
 */
Response.prototype.redirect = function(uri) {};

/**
 * sets the JSON.stringify() replacer argument
 * @param {(?|!Array<(string|number)>)} method  the replacer function or array. Defaults to none.
 * @return {?}
 */
Response.prototype.replacer = function(method) {};

/**
 * sets the JSON.stringify() space argument
 * @param {(string|number)} count  the number of spaces to indent nested object keys. Defaults to no indentation.
 * @return {?}
 */
Response.prototype.spaces = function(count) {};

/**
 * sets an HTTP cookie
 * @param {string} name  the cookie name.
 * @param {(string|!Object|!Array<?>)} value  the cookie value. If no encoding is defined, must be a string.
 * @param {?=} options  optional configuration. If the state was previously registered with the server using server.state(), the specified keys in options override those same keys in the server definition (but not others).
 * @return {?}
 */
Response.prototype.state = function(name, value, options) {};

/**
 * sets a string suffix when the response is process via JSON.stringify().
 * @param {string} suffix
 * @return {?}
 */
Response.prototype.suffix = function(suffix) {};

/**
 * overrides the default route cache expiration rule for this response instance
 * @param {number} msec  the time-to-live value in milliseconds.
 * @return {?}
 */
Response.prototype.ttl = function(msec) {};

/**
 * sets the HTTP 'Content-Type' header
 * @param {string} mimeType  is the mime type. Should only be used to override the built-in default for each response type.
 * @return {?}
 */
Response.prototype.type = function(mimeType) {};

/**
 * clears the HTTP cookie by setting an expired value
 * @param {string} name  the cookie name.
 * @param {?=} options  optional configuration for expiring cookie. If the state was previously registered with the server using server.state(), the specified keys in options override those same keys in the server definition (but not others).
 * @return {?}
 */
Response.prototype.unstate = function(name, options) {};

/**
 * adds the provided header to the list of inputs affected the response generation via the HTTP 'Vary' header
 * @param {string} header  the HTTP request header name.
 * @return {?}
 */
Response.prototype.vary = function(header) {};

/**
 * Flow control - hold()
 * When calling reply(), the framework waits until process.nextTick() to continue processing the request and transmit the response. This enables making changes to the returned response object before the response is sent. This means the framework will resume as soon as the handler method exits. To suspend this behavior, the returned response object supports the following methods:
 * puts the response on hold until response.send() is called. Available only after reply() is called and until response.hold() is invoked once.
 * [See docs](https://hapijs.com/api/16.1.1#flow-control)
 * @return {?}
 */
Response.prototype.hold = function() {};

/**
 * Flow control - send()
 * When calling reply(), the framework waits until process.nextTick() to continue processing the request and transmit the response. This enables making changes to the returned response object before the response is sent. This means the framework will resume as soon as the handler method exits. To suspend this behavior, the returned response object supports the following methods:
 * immediately resume the response. Available only after response.hold() is called and until response.send() is invoked once.
 * [See docs](https://hapijs.com/api/16.1.1#flow-control)
 * @return {?}
 */
Response.prototype.send = function() {};

/**
 * Mentioned here: "Note that prerequisites do not follow the same rules of the normal reply interface. In all other cases, calling reply() with or without a value will use the result as the response sent back to the client. In a prerequisite method, calling reply() will assign the returned value to the provided assign key. If the returned value is an error, the failAction setting determines the behavior. To force the return value as the response and skip any other prerequisites and the handler, use the reply().takeover() method."
 * TODO prepare documentation PR and submit to hapi.
 * [See docs](https://hapijs.com/api/16.1.1#route-prerequisites)
 * @return {?}
 */
Response.prototype.takeover = function() {};
/**
 * @extends {Response}
 * @record
 * @struct
 */
function ResponseRedirect() {}

/**
 * temporary
 * sets the status code to 302 or 307 (based on the rewritable() setting) where:
 * [See docs](https://hapijs.com/api/16.1.1#response-object-redirect-methods)
 * @param {boolean} isTemporary  if false, sets status to permanent. Defaults to true.
 * @return {?}
 */
ResponseRedirect.prototype.temporary = function(isTemporary) {};

/**
 * permanent
 * sets the status code to 301 or 308 (based on the rewritable() setting) where:
 * [See docs](https://hapijs.com/api/16.1.1#response-object-redirect-methods)
 * @param {boolean} isPermanent  if false, sets status to temporary. Defaults to true.
 * @return {?}
 */
ResponseRedirect.prototype.permanent = function(isPermanent) {};

/**
 * rewritable
 * sets the status code to 301/302 for rewritable (allows changing the request method from 'POST' to 'GET') or 307/308 for non-rewritable (does not allow changing the request method from 'POST' to 'GET'). Exact code based on the temporary() or permanent() setting. Arguments:
 * [See docs](https://hapijs.com/api/16.1.1#response-object-redirect-methods)
 * @param {boolean} isRewritable  if false, sets to non-rewritable. Defaults to true.
 * @return {?}
 */
ResponseRedirect.prototype.rewritable = function(isRewritable) {};
/**
 * @record
 * @struct
 */
function ResponseHeaderOptionsObject() {}
 /** @type {boolean} */
ResponseHeaderOptionsObject.prototype.append;
 /** @type {string} */
ResponseHeaderOptionsObject.prototype.separator;
 /** @type {boolean} */
ResponseHeaderOptionsObject.prototype.override;
 /** @type {boolean} */
ResponseHeaderOptionsObject.prototype.duplicate;
/**
 * @record
 * @struct
 */
function PluginFunction() {}

/* TODO: CallSignature:  */
 /** @type {?} */
PluginFunction.prototype.attributes;
/**
 * @record
 * @struct
 */
function PluginAttributes() {}
 /** @type {string} */
PluginAttributes.prototype.name;
 /** @type {string} */
PluginAttributes.prototype.version;
 /** @type {?} */
PluginAttributes.prototype.pkg;
 /** @type {boolean} */
PluginAttributes.prototype.multiple;
 /** @type {(string|!Array<string>)} */
PluginAttributes.prototype.dependencies;
 /** @type {(boolean|string)} */
PluginAttributes.prototype.connections;
 /** @type {boolean} */
PluginAttributes.prototype.once;
/**
 * @record
 * @struct
 */
function PluginsStates() {}

/* TODO: IndexSignature:  */
/**
 * @extends {PluginRegistrationOptions}
 * @record
 * @struct
 */
function PluginRegistrationObject() {}
 /** @type {?} */
PluginRegistrationObject.prototype.register;
 /** @type {?} */
PluginRegistrationObject.prototype.options;
/**
 * @record
 * @struct
 */
function PluginRegistrationOptions() {}
 /** @type {boolean} */
PluginRegistrationOptions.prototype.once;
 /** @type {?} */
PluginRegistrationOptions.prototype.routes;
 /** @type {(string|!Array<string>)} */
PluginRegistrationOptions.prototype.select;
/** @const */
var Json = {};

/** @typedef {(?|!Array<(string|number)>)} */
Json.StringifyReplacer;

/** @typedef {(string|number)} */
Json.StringifySpace;
/**
 * @record
 * @struct
 */
Json.StringifyArguments = function() {};
 /** @type {(?|!Array<(string|number)>)} */
Json.StringifyArguments.prototype.replacer;
 /** @type {(string|number)} */
Json.StringifyArguments.prototype.space;
