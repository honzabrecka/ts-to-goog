/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/lodash v3/index.d.ts:
 /** @type {!_.LoDashStatic} */
var _;
/**
 * @record
 * @struct
 */
_.LoDashStatic = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {string} */
_.LoDashStatic.prototype.VERSION;
 /** @type {!_.Support} */
_.LoDashStatic.prototype.support;
 /** @type {!_.TemplateSettings} */
_.LoDashStatic.prototype.templateSettings;
/**
 * @record
 * @struct
 */
_.TemplateSettings = function() {};
 /** @type {!RegExp} */
_.TemplateSettings.prototype.escape;
 /** @type {!RegExp} */
_.TemplateSettings.prototype.evaluate;
 /** @type {!_.Dictionary<?>} */
_.TemplateSettings.prototype.imports;
 /** @type {!RegExp} */
_.TemplateSettings.prototype.interpolate;
 /** @type {string} */
_.TemplateSettings.prototype.variable;
/**
 * @record
 * @struct
 */
_.MapCache = function() {};

/**
 * Removes `key` and its value from the cache.
 * @param {string} key The key of the value to remove.
 * @return {boolean} Returns `true` if the entry was removed successfully, else `false`.
 */
_.MapCache.prototype.delete = function(key) {};

/**
 * Gets the cached value for `key`.
 * @param {string} key The key of the value to get.
 * @return {?} Returns the cached value.
 */
_.MapCache.prototype.get = function(key) {};

/**
 * Checks if a cached value for `key` exists.
 * @param {string} key The key of the entry to check.
 * @return {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
_.MapCache.prototype.has = function(key) {};

/**
 * Sets `value` to `key` of the cache.
 * @param {string} key The key of the value to cache.
 * @param {?} value The value to cache.
 * @return {!_.Dictionary<?>} Returns the cache object.
 */
_.MapCache.prototype.set = function(key, value) {};
/**
 * @record
 * @struct
 */
_.Support = function() {};
 /** @type {boolean} */
_.Support.prototype.argsClass;
 /** @type {boolean} */
_.Support.prototype.argsObject;
 /** @type {boolean} */
_.Support.prototype.enumErrorProps;
 /** @type {boolean} */
_.Support.prototype.enumPrototypes;
 /** @type {boolean} */
_.Support.prototype.fastBind;
 /** @type {boolean} */
_.Support.prototype.funcDecomp;
 /** @type {boolean} */
_.Support.prototype.funcNames;
 /** @type {boolean} */
_.Support.prototype.nonEnumArgs;
 /** @type {boolean} */
_.Support.prototype.nonEnumShadows;
 /** @type {boolean} */
_.Support.prototype.ownLast;
 /** @type {boolean} */
_.Support.prototype.spliceObjects;
 /** @type {boolean} */
_.Support.prototype.unindexedChars;
/**
 * @record
 * @struct
 */
_.LoDashWrapperBase = function() {};
/**
 * @extends {_.LoDashWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitWrapperBase = function() {};
/**
 * @extends {_.LoDashWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitWrapperBase = function() {};
/**
 * @extends {_.LoDashImplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitWrapper = function() {};
/**
 * @extends {_.LoDashImplicitWrapper}
 * @record
 * @struct
 */
_.LoDashImplicitStringWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapper}
 * @record
 * @struct
 */
_.LoDashExplicitStringWrapper = function() {};
/**
 * @extends {_.LoDashImplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitObjectWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitObjectWrapper = function() {};
/**
 * @extends {_.LoDashImplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitArrayWrapper = function() {};

/**
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.pop = function() {};

/**
 * @param {...T} items
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.push = function(items) {};

/**
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.shift = function() {};

/**
 * @param {function(T, T): number=} compareFn
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.sort = function(compareFn) {};

/**
 * @param {number} start
 * @param {number=} deleteCount
 * @param {...?} items
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.splice = function(start, deleteCount, items) {};

/**
 * @param {...T} items
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.unshift = function(items) {};
/**
 * @extends {_.LoDashExplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitArrayWrapper = function() {};
/**
 * @extends {_.LoDashImplicitArrayWrapper}
 * @record
 * @struct
 */
_.LoDashImplicitNumberArrayWrapper = function() {};
/**
 * @extends {_.LoDashExplicitArrayWrapper}
 * @record
 * @struct
 */
_.LoDashExplicitNumberArrayWrapper = function() {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {string}
 */
_.LoDashImplicitArrayWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {string}
 */
_.LoDashImplicitObjectWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitArrayWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.join = function(separator) {};

/**
 * Creates an array of elements split into groups the length of size. If collection can’t be split evenly, the
 * final chunk will be the remaining elements.
 * 
 * @template T
 * @param {!_.List<T>} array The array to process.
 * @param {number=} size The length of each chunk.
 * @return {!Array<!Array<T>>} Returns the new array containing chunks.
 */
_.LoDashStatic.prototype.chunk = function(array, size) {};

/**
 * @see _.chunk
 * @param {number=} size
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.chunk = function(size) {};

/**
 * @see _.chunk
 * @template TResult
 * @param {number=} size
 * @return {!_.LoDashImplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashImplicitObjectWrapper.prototype.chunk = function(size) {};

/**
 * @see _.chunk
 * @param {number=} size
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.chunk = function(size) {};

/**
 * @see _.chunk
 * @template TResult
 * @param {number=} size
 * @return {!_.LoDashExplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashExplicitObjectWrapper.prototype.chunk = function(size) {};

/**
 * Creates an array with all falsey values removed. The values false, null, 0, "", undefined, and NaN are
 * falsey.
 * 
 * @template T
 * @param {!_.List<T>=} array The array to compact.
 * @return {!Array<T>} (Array) Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.compact = function(array) {};

/**
 * @see _.compact
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.compact = function() {};

/**
 * @see _.compact
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.compact = function() {};

/**
 * @see _.compact
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.compact = function() {};

/**
 * @see _.compact
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.compact = function() {};

/**
 * Creates an array of unique array values not included in the other provided arrays using SameValueZero for
 * equality comparisons.
 * 
 * @template T
 * @param {(!Array<T>|!_.List<T>)} array The array to inspect.
 * @param {...(!Array<T>|!_.List<T>)} values The arrays of values to exclude.
 * @return {!Array<T>} Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.difference = function(array, values) {};

/**
 * @see _.difference
 * @param {...(!Array<T>|!_.List<T>)} values
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.difference = function(values) {};

/**
 * @see _.difference
 * @template TValue
 * @param {...(!Array<TValue>|!_.List<TValue>)} values
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.difference = function(values) {};

/**
 * @see _.difference
 * @param {...(!Array<T>|!_.List<T>)} values
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.difference = function(values) {};

/**
 * @see _.difference
 * @template TValue
 * @param {...(!Array<TValue>|!_.List<TValue>)} values
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.difference = function(values) {};

/**
 * Creates a slice of array with n elements dropped from the beginning.
 * 
 * @template T
 * @param {(!Array<T>|!_.List<T>)} array The array to query.
 * @param {number=} n The number of elements to drop.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.drop = function(array, n) {};

/**
 * @see _.drop
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.drop = function(n) {};

/**
 * @see _.drop
 * @template T
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.drop = function(n) {};

/**
 * @see _.drop
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.drop = function(n) {};

/**
 * @see _.drop
 * @template T
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.drop = function(n) {};

/**
 * Creates a slice of array with n elements dropped from the end.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @param {number=} n The number of elements to drop.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.dropRight = function(array, n) {};

/**
 * @see _.dropRight
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.dropRight = function(n) {};

/**
 * @see _.dropRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.dropRight = function(n) {};

/**
 * @see _.dropRight
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.dropRight = function(n) {};

/**
 * @see _.dropRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.dropRight = function(n) {};

/**
 * Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate
 * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * match the properties of the given object, else false.
 * 
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TValue, TWhere
 * @param {!_.List<TValue>} array The array to query.
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.dropRightWhile = function(array, predicate, thisArg) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.dropRightWhile = function(predicate, thisArg) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.dropRightWhile = function(predicate, thisArg) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.dropRightWhile = function(predicate, thisArg) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.dropRightWhile = function(predicate, thisArg) {};

/**
 * Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate
 * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TValue, TWhere
 * @param {!_.List<TValue>} array The array to query.
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.dropWhile = function(array, predicate, thisArg) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.dropWhile = function(predicate, thisArg) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.dropWhile = function(predicate, thisArg) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.dropWhile = function(predicate, thisArg) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.dropWhile = function(predicate, thisArg) {};

/**
 * Fills elements of array with value from start up to, but not including, end.
 * 
 * Note: This method mutates array.
 * 
 * @see _.fill
 * @template T
 * @param {!Array<?>|!_.List<?>} array The array to fill.
 * @param {T} value The value to fill array with.
 * @param {number=} start The start position.
 * @param {number=} end The end position.
 * @return {!Array<T>|!_.List<T>} Returns array.
 */
_.LoDashStatic.prototype.fill = function(array, value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.fill = function(value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashImplicitObjectWrapper<!_.List<T>>}
 */
_.LoDashImplicitObjectWrapper.prototype.fill = function(value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapper.prototype.fill = function(value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashExplicitObjectWrapper<!_.List<T>>}
 */
_.LoDashExplicitObjectWrapper.prototype.fill = function(value, start, end) {};

/**
 * This method is like _.find except that it returns the index of the first element predicate returns truthy
 * for instead of the element itself.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findIndex
 * @see _.findIndex
 * @template T, W
 * @param {!_.List<T>} array The array to search.
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {number} Returns the index of the found element, else -1.
 */
_.LoDashStatic.prototype.findIndex = function(array, predicate, thisArg) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.findIndex = function(predicate, thisArg) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.findIndex = function(predicate, thisArg) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.findIndex = function(predicate, thisArg) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.findIndex = function(predicate, thisArg) {};

/**
 * This method is like _.findIndex except that it iterates over elements of collection from right to left.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template T, W
 * @param {!_.List<T>} array The array to search.
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The function invoked per iteration.
 * @return {number} Returns the index of the found element, else -1.
 */
_.LoDashStatic.prototype.findLastIndex = function(array, predicate, thisArg) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.findLastIndex = function(predicate, thisArg) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.findLastIndex = function(predicate, thisArg) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.findLastIndex = function(predicate, thisArg) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.findLastIndex = function(predicate, thisArg) {};

/**
 * Gets the first element of array.
 * 
 * \@alias _.head
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @return {T} Returns the first element of array.
 */
_.LoDashStatic.prototype.first = function(array) {};

/**
 * @see _.first
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashExplicitArrayWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashExplicitObjectWrapper.prototype.first = function() {};
/**
 * @record
 * @struct
 */
_.RecursiveArray = function() {};
/**
 * @extends {_.List}
 * @record
 * @struct
 */
_.ListOfRecursiveArraysOrValues = function() {};

/**
 * Flattens a nested array. If isDeep is true the array is recursively flattened, otherwise it’s only
 * flattened a single level.
 * 
 * @see _.flatten
 * @see _.flatten
 * @template T
 * @param {!_.ListOfRecursiveArraysOrValues<T>|!_.List<(T|!Array<T>)>} array The array to flatten.
 * @param {boolean=} isDeep Specify a deep flatten.
 * @return {!Array<T>|!_.RecursiveArray<T>} Returns the new flattened array.
 */
_.LoDashStatic.prototype.flatten = function(array, isDeep) {};

/**
 * @see _.flatten
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.flatten = function() {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.flatten = function(isDeep) {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.flatten = function(isDeep) {};

/**
 * @see _.flatten
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.flatten = function() {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.flatten = function(isDeep) {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.flatten = function(isDeep) {};

/**
 * Recursively flattens a nested array.
 * 
 * @template T
 * @param {!_.ListOfRecursiveArraysOrValues<T>} array The array to recursively flatten.
 * @return {!Array<T>} Returns the new flattened array.
 */
_.LoDashStatic.prototype.flattenDeep = function(array) {};

/**
 * @see _.flattenDeep
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.first
 * @template T
 * @param {!_.List<T>} array
 * @return {T}
 */
_.LoDashStatic.prototype.head = function(array) {};

/**
 * @see _.first
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashExplicitArrayWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashExplicitObjectWrapper.prototype.head = function() {};

/**
 * Gets the index at which the first occurrence of value is found in array using SameValueZero for equality
 * comparisons. If fromIndex is negative, it’s used as the offset from the end of array. If array is sorted
 * providing true for fromIndex performs a faster binary search.
 * 
 * @template T
 * @param {!_.List<T>} array The array to search.
 * @param {T} value The value to search for.
 * @param {(number|boolean)=} fromIndex The index to search from or true to perform a binary search on a sorted array.
 * @return {number} The index to search from or true to perform a binary search on a sorted array.
 */
_.LoDashStatic.prototype.indexOf = function(array, value, fromIndex) {};

/**
 * @see _.indexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.indexOf = function(value, fromIndex) {};

/**
 * @see _.indexOf
 * @template TValue
 * @param {TValue} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.indexOf = function(value, fromIndex) {};

/**
 * @see _.indexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.indexOf = function(value, fromIndex) {};

/**
 * @see _.indexOf
 * @template TValue
 * @param {TValue} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.indexOf = function(value, fromIndex) {};

/**
 * Gets all but the last element of array.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.initial = function(array) {};

/**
 * @see _.initial
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.initial = function() {};

/**
 * @see _.initial
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.initial = function() {};

/**
 * @see _.initial
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.initial = function() {};

/**
 * @see _.initial
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.initial = function() {};

/**
 * Creates an array of unique values that are included in all of the provided arrays using SameValueZero for
 * equality comparisons.
 * 
 * @template T
 * @param {...(!Array<T>|!_.List<T>)} arrays The arrays to inspect.
 * @return {!Array<T>} Returns the new array of shared values.
 */
_.LoDashStatic.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...(!Array<TResult>|!_.List<TResult>)} arrays
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...(!Array<TResult>|!_.List<TResult>)} arrays
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...(!Array<TResult>|!_.List<TResult>)} arrays
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...(!Array<TResult>|!_.List<TResult>)} arrays
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.intersection = function(arrays) {};

/**
 * Gets the last element of array.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @return {T} Returns the last element of array.
 */
_.LoDashStatic.prototype.last = function(array) {};

/**
 * @see _.last
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @template T
 * @return {T}
 */
_.LoDashExplicitArrayWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @template T
 * @return {T}
 */
_.LoDashExplicitObjectWrapper.prototype.last = function() {};

/**
 * This method is like _.indexOf except that it iterates over elements of array from right to left.
 * 
 * @template T
 * @param {!_.List<T>} array The array to search.
 * @param {T} value The value to search for.
 * @param {(number|boolean)=} fromIndex The index to search from or true to perform a binary search on a sorted array.
 * @return {number} Returns the index of the matched value, else -1.
 */
_.LoDashStatic.prototype.lastIndexOf = function(array, value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @template TResult
 * @param {TResult} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @template TResult
 * @param {TResult} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {(!_.List<!_.StringRepresentable>|!_.List<!_.List<?>>)} props
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {TResult|!_.Dictionary<?>}
 */
_.LoDashStatic.prototype.object = function(props, values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitArrayWrapper.prototype.object = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitObjectWrapper.prototype.object = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitArrayWrapper.prototype.object = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitObjectWrapper.prototype.object = function(values) {};

/**
 * Removes all provided values from array using SameValueZero for equality comparisons.
 * 
 * Note: Unlike _.without, this method mutates array.
 * 
 * @see _.pull
 * @template T
 * @param {!Array<T>|!_.List<T>} array The array to modify.
 * @param {...T} values The values to remove.
 * @return {!Array<T>|!_.List<T>} Returns array.
 */
_.LoDashStatic.prototype.pull = function(array, values) {};

/**
 * @see _.pull
 * @param {...T} values
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.pull = function(values) {};

/**
 * @see _.pull
 * @template TValue
 * @param {...TValue} values
 * @return {!_.LoDashImplicitObjectWrapper<!_.List<TValue>>}
 */
_.LoDashImplicitObjectWrapper.prototype.pull = function(values) {};

/**
 * @see _.pull
 * @param {...T} values
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.pull = function(values) {};

/**
 * @see _.pull
 * @template TValue
 * @param {...TValue} values
 * @return {!_.LoDashExplicitObjectWrapper<!_.List<TValue>>}
 */
_.LoDashExplicitObjectWrapper.prototype.pull = function(values) {};

/**
 * Removes elements from array corresponding to the given indexes and returns an array of the removed elements.
 * Indexes may be specified as an array of indexes or as individual arguments.
 * 
 * Note: Unlike _.at, this method mutates array.
 * 
 * @template T
 * @param {!_.List<T>} array The array to modify.
 * @param {...(number|!Array<number>)} indexes The indexes of elements to remove, specified as individual indexes or arrays of indexes.
 * @return {!Array<T>} Returns the new array of removed elements.
 */
_.LoDashStatic.prototype.pullAt = function(array, indexes) {};

/**
 * @see _.pullAt
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.pullAt = function(indexes) {};

/**
 * @see _.pullAt
 * @template T
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.pullAt = function(indexes) {};

/**
 * @see _.pullAt
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.pullAt = function(indexes) {};

/**
 * @see _.pullAt
 * @template T
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.pullAt = function(indexes) {};

/**
 * Removes all elements from array that predicate returns truthy for and returns an array of the removed
 * elements. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * Note: Unlike _.filter, this method mutates array.
 * 
 * @see _.remove
 * @see _.remove
 * @template T, W
 * @param {!_.List<T>} array The array to modify.
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<T>} Returns the new array of removed elements.
 */
_.LoDashStatic.prototype.remove = function(array, predicate, thisArg) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.remove = function(predicate, thisArg) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.remove = function(predicate, thisArg) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.remove = function(predicate, thisArg) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.remove = function(predicate, thisArg) {};

/**
 * Gets all but the first element of array.
 * 
 * \@alias _.tail
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.rest = function(array) {};

/**
 * @see _.rest
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.rest = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.rest = function() {};

/**
 * @see _.rest
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.rest = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.rest = function() {};

/**
 * Creates a slice of array from start up to, but not including, end.
 * 
 * @template T
 * @param {!Array<T>} array The array to slice.
 * @param {number=} start The start position.
 * @param {number=} end The end position.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.slice = function(array, start, end) {};

/**
 * @see _.slice
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.slice = function(start, end) {};

/**
 * @see _.slice
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.slice = function(start, end) {};

/**
 * Uses a binary search to determine the lowest index at which value should be inserted into array in order to maintain its sort order. If an iteratee function is provided it’s invoked for value and each element of array to compute their sort ranking. The iteratee is bound to thisArg and invoked with one argument; (value).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that have the properties of the given object, else false.
 * 
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template T, TSort, W
 * @param {!_.List<T>} array The sorted array to inspect.
 * @param {T} value The value to evaluate.
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee The function invoked per iteration.
 * @param {?=} thisArg
 * @return {number} The this binding of iteratee.
 */
_.LoDashStatic.prototype.sortedIndex = function(array, value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * This method is like _.sortedIndex except that it returns the highest index at which value should be
 * inserted into array in order to maintain its sort order.
 * 
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template T, TSort, W
 * @param {!_.List<T>} array The sorted array to inspect.
 * @param {T} value The value to evaluate.
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {number} Returns the index at which value should be inserted into array.
 */
_.LoDashStatic.prototype.sortedLastIndex = function(array, value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.rest
 * @template T
 * @param {!_.List<T>} array
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.tail = function(array) {};

/**
 * @see _.rest
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.tail = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.tail = function() {};

/**
 * @see _.rest
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.tail = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.tail = function() {};

/**
 * Creates a slice of array with n elements taken from the beginning.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @param {number=} n The number of elements to take.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.take = function(array, n) {};

/**
 * @see _.take
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.take = function(n) {};

/**
 * @see _.take
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.take = function(n) {};

/**
 * @see _.take
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.take = function(n) {};

/**
 * @see _.take
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.take = function(n) {};

/**
 * Creates a slice of array with n elements taken from the end.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @param {number=} n The number of elements to take.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.takeRight = function(array, n) {};

/**
 * @see _.takeRight
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.takeRight = function(n) {};

/**
 * @see _.takeRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.takeRight = function(n) {};

/**
 * @see _.takeRight
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.takeRight = function(n) {};

/**
 * @see _.takeRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.takeRight = function(n) {};

/**
 * Creates a slice of array with elements taken from the end. Elements are taken until predicate returns
 * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TValue, TWhere
 * @param {!_.List<TValue>} array The array to query.
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.takeRightWhile = function(array, predicate, thisArg) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.takeRightWhile = function(predicate, thisArg) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.takeRightWhile = function(predicate, thisArg) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.takeRightWhile = function(predicate, thisArg) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.takeRightWhile = function(predicate, thisArg) {};

/**
 * Creates a slice of array with elements taken from the beginning. Elements are taken until predicate returns
 * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TValue, TWhere
 * @param {!_.List<TValue>} array The array to query.
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.takeWhile = function(array, predicate, thisArg) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * Creates an array of unique values, in order, from all of the provided arrays using SameValueZero for
 * equality comparisons.
 * 
 * @template T
 * @param {...!_.List<T>} arrays The arrays to inspect.
 * @return {!Array<T>} Returns the new array of combined values.
 */
_.LoDashStatic.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @see _.union
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper|!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @see _.union
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper|!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapper.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.union = function(arrays) {};

/**
 * Creates a duplicate-free version of an array, using SameValueZero for equality comparisons, in which only
 * the first occurrence of each element is kept. Providing true for isSorted performs a faster search
 * algorithm for sorted arrays. If an iteratee function is provided it’s invoked for each element in the
 * array to generate the criterion by which uniqueness is computed. The iteratee is bound to thisArg and
 * invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.unique
 * 
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {!_.List<T>} array The array to inspect.
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee Specify the array is sorted.
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg The function invoked per iteration.
 * @param {?=} thisArg iteratee
 * @return {!Array<T>} Returns the new duplicate-value-free array.
 */
_.LoDashStatic.prototype.uniq = function(array, isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @param {boolean|!_.ListIterator<T, TSort>=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template TSort, TWhere
 * @param {boolean|!_.ListIterator<T, TSort>|string|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?|string|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @param {boolean|!_.ListIterator<T, TSort>=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template TSort, TWhere
 * @param {boolean|!_.ListIterator<T, TSort>|string|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?|string|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {!_.List<T>} array
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.unique = function(array, isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @param {boolean|!_.ListIterator<T, TSort>=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template TSort, TWhere
 * @param {boolean|!_.ListIterator<T, TSort>|string|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?|string|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @param {boolean|!_.ListIterator<T, TSort>=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template TSort, TWhere
 * @param {boolean|!_.ListIterator<T, TSort>|string|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?|string|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * This method is like _.zip except that it accepts an array of grouped elements and creates an array
 * regrouping the elements to their pre-zip configuration.
 * 
 * @template T
 * @param {!_.List<!_.List<T>>} array The array of grouped elements to process.
 * @return {!Array<!Array<T>>} Returns the new array of regrouped elements.
 */
_.LoDashStatic.prototype.unzip = function(array) {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.unzip = function() {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitObjectWrapper.prototype.unzip = function() {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.unzip = function() {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitObjectWrapper.prototype.unzip = function() {};

/**
 * This method is like _.unzip except that it accepts an iteratee to specify how regrouped values should be
 * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,
 * group).
 * 
 * @template TArray, TResult
 * @param {!_.List<!_.List<TArray>>} array The array of grouped elements to process.
 * @param {!_.MemoIterator<TArray, TResult>=} iteratee The function to combine regrouped values.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<TResult>} Returns the new array of regrouped elements.
 */
_.LoDashStatic.prototype.unzipWith = function(array, iteratee, thisArg) {};

/**
 * @see _.unzipWith
 * @template TArr, TResult
 * @param {!_.MemoIterator<TArr, TResult>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.unzipWith = function(iteratee, thisArg) {};

/**
 * @see _.unzipWith
 * @template TArr, TResult
 * @param {!_.MemoIterator<TArr, TResult>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.unzipWith = function(iteratee, thisArg) {};

/**
 * Creates an array excluding all provided values using SameValueZero for equality comparisons.
 * 
 * @template T
 * @param {!_.List<T>} array The array to filter.
 * @param {...T} values The values to exclude.
 * @return {!Array<T>} Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.without = function(array, values) {};

/**
 * @see _.without
 * @param {...T} values
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.without = function(values) {};

/**
 * @see _.without
 * @template T
 * @param {...T} values
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.without = function(values) {};

/**
 * @see _.without
 * @param {...T} values
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.without = function(values) {};

/**
 * @see _.without
 * @template T
 * @param {...T} values
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.without = function(values) {};

/**
 * Creates an array of unique values that is the symmetric difference of the provided arrays.
 * 
 * @template T
 * @param {...!_.List<T>} arrays The arrays to inspect.
 * @return {!Array<T>} Returns the new array of values.
 */
_.LoDashStatic.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.xor = function(arrays) {};

/**
 * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,
 * the second of which contains the second elements of the given arrays, and so on.
 * 
 * @template T
 * @param {...!_.List<T>} arrays The arrays to process.
 * @return {!Array<!Array<T>>} Returns the new array of grouped elements.
 */
_.LoDashStatic.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitObjectWrapper.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitObjectWrapper.prototype.zip = function(arrays) {};

/**
 * The inverse of _.pairs; this method returns an object composed from arrays of property names and values.
 * Provide either a single two dimensional array, e.g. [[key1, value1], [key2, value2]] or two arrays, one of
 * property names and one of corresponding values.
 * 
 * \@alias _.object
 * 
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {(!_.List<!_.StringRepresentable>|!_.List<!_.List<?>>)} props The property names.
 * @param {!_.List<TValues>|!_.List<?>=} values The property values.
 * @return {TResult|!_.Dictionary<?>} Returns the new object.
 */
_.LoDashStatic.prototype.zipObject = function(props, values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitArrayWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitObjectWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitArrayWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitObjectWrapper.prototype.zipObject = function(values) {};

/**
 * This method is like _.zip except that it accepts an iteratee to specify how grouped values should be
 * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,
 * group).
 * @template TResult
 * @param {...?} args
 * @return {!Array<TResult>} Returns the new array of grouped elements.
 */
_.LoDashStatic.prototype.zipWith = function(args) {};

/**
 * @see _.zipWith
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.zipWith = function(args) {};

/**
 * Creates a lodash object that wraps value with explicit method chaining enabled.
 * 
 * @template T
 * @param {number|string|boolean|!Array<T>|T|?} value The value to wrap.
 * @return {!_.LoDashExplicitWrapper<number>|!_.LoDashExplicitWrapper<string>|!_.LoDashExplicitWrapper<boolean>|!_.LoDashExplicitArrayWrapper<T>|!_.LoDashExplicitObjectWrapper<T>|!_.LoDashExplicitWrapper<?>} Returns the new lodash wrapper instance.
 */
_.LoDashStatic.prototype.chain = function(value) {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitObjectWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {TWrapper}
 */
_.LoDashExplicitWrapperBase.prototype.chain = function() {};

/**
 * This method invokes interceptor and returns value. The interceptor is bound to thisArg and invoked with one
 * argument; (value). The purpose of this method is to "tap into" a method chain in order to perform operations
 * on intermediate results within the chain.
 * 
 * \@parem thisArg The this binding of interceptor.
 * @template T
 * @param {T} value The value to provide to interceptor.
 * @param {function(T): void} interceptor The function to invoke.
 * @param {?=} thisArg
 * @return {T} Returns value.
 * 
 */
_.LoDashStatic.prototype.tap = function(value, interceptor, thisArg) {};

/**
 * @see _.tap
 * @param {function(T): void} interceptor
 * @param {?=} thisArg
 * @return {TWrapper}
 */
_.LoDashImplicitWrapperBase.prototype.tap = function(interceptor, thisArg) {};

/**
 * @see _.tap
 * @param {function(T): void} interceptor
 * @param {?=} thisArg
 * @return {TWrapper}
 */
_.LoDashExplicitWrapperBase.prototype.tap = function(interceptor, thisArg) {};

/**
 * This method is like _.tap except that it returns the result of interceptor.
 * 
 * @template T, TResult
 * @param {T} value The value to provide to interceptor.
 * @param {function(T): TResult} interceptor The function to invoke.
 * @param {?=} thisArg The this binding of interceptor.
 * @return {TResult} Returns the result of interceptor.
 */
_.LoDashStatic.prototype.thru = function(value, interceptor, thisArg) {};

/**
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @template TResult
 * @param {function(T): TResult|function(T): !Array<TResult>} interceptor
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<TResult>|!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.thru = function(interceptor, thisArg) {};

/**
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @template TResult
 * @param {function(T): TResult|function(T): !Array<TResult>} interceptor
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitWrapperBase.prototype.thru = function(interceptor, thisArg) {};

/**
 * Executes the chained sequence and returns the wrapped result.
 * 
 * @return {TWrapper} Returns the new lodash wrapper instance.
 */
_.LoDashImplicitWrapperBase.prototype.commit = function() {};

/**
 * @see _.commit
 * @return {TWrapper}
 */
_.LoDashExplicitWrapperBase.prototype.commit = function() {};

/**
 * Creates a new array joining a wrapped array with any additional arrays and/or values.
 * 
 * @see _.concat
 * @template TItem
 * @param {...(TItem|!Array<TItem>)|(T|!Array<T>)} items
 * @return {!_.LoDashImplicitArrayWrapper<TItem>|!_.LoDashImplicitArrayWrapper<T>} Returns the new concatenated array.
 */
_.LoDashImplicitWrapperBase.prototype.concat = function(items) {};

/**
 * @see _.concat
 * @see _.concat
 * @template TItem
 * @param {...(TItem|!Array<TItem>)|(T|!Array<T>)} items
 * @return {!_.LoDashExplicitArrayWrapper<TItem>|!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapperBase.prototype.concat = function(items) {};

/**
 * Creates a clone of the chained sequence planting value as the wrapped value.
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @template T
 * @param {number|string|boolean|!Array<number>|!Array<T>|T|?} value The value to plant as the wrapped value.
 * @return {!_.LoDashImplicitWrapper<number>|!_.LoDashImplicitStringWrapper|!_.LoDashImplicitWrapper<boolean>|!_.LoDashImplicitNumberArrayWrapper|!_.LoDashImplicitArrayWrapper<T>|!_.LoDashImplicitObjectWrapper<T>|!_.LoDashImplicitWrapper<?>} Returns the new lodash wrapper instance.
 */
_.LoDashImplicitWrapperBase.prototype.plant = function(value) {};

/**
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @template T
 * @param {number|string|boolean|!Array<number>|!Array<T>|T|?} value
 * @return {!_.LoDashExplicitWrapper<number>|!_.LoDashExplicitStringWrapper|!_.LoDashExplicitWrapper<boolean>|!_.LoDashExplicitNumberArrayWrapper|!_.LoDashExplicitArrayWrapper<T>|!_.LoDashExplicitObjectWrapper<T>|!_.LoDashExplicitWrapper<?>}
 */
_.LoDashExplicitWrapperBase.prototype.plant = function(value) {};

/**
 * Reverses the wrapped array so the first element becomes the last, the second element becomes the second to
 * last, and so on.
 * 
 * Note: This method mutates the wrapped array.
 * 
 * @return {!_.LoDashImplicitArrayWrapper} Returns the new reversed lodash wrapper instance.
 */
_.LoDashImplicitArrayWrapper.prototype.reverse = function() {};

/**
 * @see _.reverse
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.reverse = function() {};

/**
 * @see _.value
 * @return {T}
 */
_.LoDashWrapperBase.prototype.run = function() {};

/**
 * @see _.value
 * @return {T}
 */
_.LoDashWrapperBase.prototype.toJSON = function() {};

/**
 * Produces the result of coercing the unwrapped value to a string.
 * 
 * @return {string} Returns the coerced string value.
 */
_.LoDashWrapperBase.prototype.toString = function() {};

/**
 * Executes the chained sequence to extract the unwrapped value.
 * 
 * \@alias _.run, _.toJSON, _.valueOf
 * 
 * @return {T} Returns the resolved unwrapped value.
 */
_.LoDashWrapperBase.prototype.value = function() {};

/**
 * @see _.value
 * @return {T}
 */
_.LoDashWrapperBase.prototype.valueOf = function() {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @see _.every
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashStatic.prototype.all = function(collection, predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.all = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.all = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.all = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.all = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|!Object|(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>|!_.ObjectIterator<?, boolean>|string|TObject|!Object=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashStatic.prototype.any = function(collection, predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TObject
 * @param {(!_.ListIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.any = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult, TObject
 * @param {(!_.ObjectIterator<?, boolean>|!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.any = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TObject
 * @param {(!_.ListIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.any = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult, TObject
 * @param {(!_.ObjectIterator<?, boolean>|!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.any = function(predicate, thisArg) {};

/**
 * Creates an array of elements corresponding to the given keys, or indexes, of collection. Keys may be
 * specified as individual arguments or as arrays of keys.
 * 
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {...(string|number|!Array<(string|number)>)} props The property names or indexes of elements to pick, specified individually or in arrays.
 * @return {!Array<T>} Returns the new array of picked elements.
 */
_.LoDashStatic.prototype.at = function(collection, props) {};

/**
 * @see _.at
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.at = function(props) {};

/**
 * @see _.at
 * @template T
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.at = function(props) {};

/**
 * @see _.at
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.at = function(props) {};

/**
 * @see _.at
 * @template T
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.at = function(props) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @template T, TResult, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection
 * @param {!_.ListIterator<T, TResult>|!_.DictionaryIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!Array<TResult>|!Array<boolean>}
 */
_.LoDashStatic.prototype.collect = function(collection, iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, TObject
 * @param {!_.ListIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitArrayWrapper.prototype.collect = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, TObject
 * @param {(!_.ListIterator<TValue, TResult>|!_.DictionaryIterator<TValue, TResult>)|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapper.prototype.collect = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, TObject
 * @param {!_.ListIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.collect = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, TObject
 * @param {(!_.ListIterator<TValue, TResult>|!_.DictionaryIterator<TValue, TResult>)|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.collect = function(iteratee, thisArg) {};

/**
 * @see _.includes
 * @see _.includes
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection
 * @param {T|string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashStatic.prototype.contains = function(collection, target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is the number of times the key was returned by iteratee. The
 * iteratee is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>|string|W|!Object=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<number>} Returns the composed aggregate object.
 */
_.LoDashStatic.prototype.countBy = function(collection, iteratee, thisArg) {};

/**
 * @see _.countBy
 * @param {!_.ListIterator<T, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashImplicitWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template W
 * @param {!_.ListIterator<T, ?>|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashImplicitArrayWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template T, W
 * @param {(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>)|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashImplicitObjectWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @param {!_.ListIterator<T, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashExplicitWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template W
 * @param {!_.ListIterator<T, ?>|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashExplicitArrayWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template T, W
 * @param {(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>)|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashExplicitObjectWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashStatic.prototype.detect = function(collection, predicate, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.detect = function(predicate, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.detect = function(predicate, thisArg) {};

/**
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @template T, TValue
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>|T} collection
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>|!_.ObjectIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg_or_thisArgs
 * @return {!Array<T>|!_.List<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.each = function(collection, iteratee, thisArg_or_thisArgs) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @template T, TValue
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>|T} collection
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>|!_.ObjectIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg_or_thisArgs
 * @return {!Array<T>|!_.List<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.eachRight = function(collection, iteratee, thisArg_or_thisArgs) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * Checks if predicate returns truthy for all elements of collection. The predicate is bound to thisArg and
 * invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.all
 * 
 * @see _.every
 * @see _.every
 * @see _.every
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|string|TObject=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {boolean} Returns true if all elements pass the predicate check, else false.
 */
_.LoDashStatic.prototype.every = function(collection, predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.every = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.every = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.every = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.every = function(predicate, thisArg) {};

/**
 * Iterates over elements of collection, returning an array of all elements predicate returns truthy for. The
 * predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.select
 * 
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>|string|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.StringIterator<boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<T>|!Array<string>} Returns the new filtered array.
 */
_.LoDashStatic.prototype.filter = function(collection, predicate, thisArg) {};

/**
 * @see _.filter
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * Iterates over elements of collection, returning the first element predicate returns truthy for.
 * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.detect
 * 
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to search.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|string|TObject=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {T} Returns the matched element, else undefined.
 */
_.LoDashStatic.prototype.find = function(collection, predicate, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.find = function(predicate, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.find = function(predicate, thisArg) {};

/**
 * @see _.find
 * 
 * @see _.find
 * 
 * @see _.find
 * 
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T, W
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|W|string} callback_or_whereValue_or_pluckValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashStatic.prototype.findWhere = function(collection, callback_or_whereValue_or_pluckValue, thisArg) {};

/**
 * This method is like _.find except that it iterates over elements of a collection from
 * right to left.
 * @see _.find
 * 
 * @see _.find
 * 
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T, W
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection Searches for a value in this list.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|W|string} callback_or_whereValue_or_pluckValue The function called per iteration.
 * @param {?=} thisArg The this binding of callback.
 * @return {T} The found element, else undefined.
 * 
 */
_.LoDashStatic.prototype.findLast = function(collection, callback_or_whereValue_or_pluckValue, thisArg) {};

/**
 * @see _.findLast
 * @see _.findLast
 * @see _.findLast
 * @template W
 * @param {!_.ListIterator<T, boolean>|W|string} callback_or_whereValue_or_pluckValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.findLast = function(callback_or_whereValue_or_pluckValue, thisArg) {};

/**
 * Iterates over elements of collection invoking iteratee for each element. The iteratee is bound to thisArg
 * and invoked with three arguments:
 * (value, index|key, collection). Iteratee functions may exit iteration early by explicitly returning false.
 * 
 * Note: As with other "Collections" methods, objects with a "length" property are iterated like arrays. To
 * avoid this behavior _.forIn or _.forOwn may be used for object iteration.
 * 
 * \@alias _.each
 * 
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @template T, TValue
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>|T} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>|!_.ObjectIterator<TValue, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg_or_thisArgs The this binding of iteratee.
 * @return {!Array<T>|!_.List<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.forEach = function(collection, iteratee, thisArg_or_thisArgs) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * This method is like _.forEach except that it iterates over elements of collection from right to left.
 * 
 * \@alias _.eachRight
 * 
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @template T, TValue
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>|T} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>|!_.ObjectIterator<TValue, ?>=} iteratee The function called per iteration.
 * @param {?=} thisArg_or_thisArgs The this binding of callback.
 * @return {!Array<T>|!_.List<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.forEachRight = function(collection, iteratee, thisArg_or_thisArgs) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is an array of the elements responsible for generating the
 * key. The iteratee is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template T, TKey, TValue, TWhere
 * @param {!_.List<T>|!_.List<?>|!_.Dictionary<T>|!_.Dictionary<?>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, TKey>|!_.ListIterator<T, ?>|!_.DictionaryIterator<T, TKey>|!_.DictionaryIterator<T, ?>|string|TWhere|!Object=} iteratee The function invoked per iteration.
 * @param {?|TValue=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<!Array<T>>} Returns the composed aggregate object.
 */
_.LoDashStatic.prototype.groupBy = function(collection, iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @template TKey
 * @param {!_.ListIterator<T, TKey>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashImplicitWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template TKey, TValue, TWhere
 * @param {!_.ListIterator<T, TKey>|string|TWhere=} iteratee
 * @param {?|TValue=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashImplicitArrayWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template T, TKey, TValue, TWhere
 * @param {(!_.ListIterator<T, TKey>|!_.DictionaryIterator<T, TKey>)|(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|TWhere|!Object=} iteratee
 * @param {?|TValue=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashImplicitObjectWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @template TKey
 * @param {!_.ListIterator<T, TKey>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashExplicitWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template TKey, TValue, TWhere
 * @param {!_.ListIterator<T, TKey>|string|TWhere=} iteratee
 * @param {?|TValue=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashExplicitArrayWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template T, TKey, TValue, TWhere
 * @param {(!_.ListIterator<T, TKey>|!_.DictionaryIterator<T, TKey>)|(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|TWhere|!Object=} iteratee
 * @param {?|TValue=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashExplicitObjectWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.includes
 * @see _.includes
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection
 * @param {T|string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashStatic.prototype.include = function(collection, target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.include = function(target, fromIndex) {};

/**
 * Checks if target is in collection using SameValueZero for equality comparisons. If fromIndex is negative,
 * it’s used as the offset from the end of collection.
 * 
 * \@alias _.contains, _.include
 * 
 * @see _.includes
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection The collection to search.
 * @param {T|string} target The value to search for.
 * @param {number=} fromIndex The index to search from.
 * @return {boolean} True if the target element is found, else false.
 */
_.LoDashStatic.prototype.includes = function(collection, target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is the last element responsible for generating the key. The
 * iteratee function is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template T, W
 * @param {!_.List<T>|!_.NumericDictionary<T>|!_.Dictionary<T>|(!_.Dictionary<T>|!_.List<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>|!_.DictionaryIterator<T, ?>|string|W|!Object=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>} Returns the composed aggregate object.
 */
_.LoDashStatic.prototype.indexBy = function(collection, iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @param {!_.ListIterator<T, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template W
 * @param {!_.ListIterator<T, ?>|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template T, W
 * @param {(!_.ListIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitObjectWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @param {!_.ListIterator<T, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template W
 * @param {!_.ListIterator<T, ?>|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template T, W
 * @param {(!_.ListIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitObjectWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * Invokes the method named by methodName on each element in the collection returning
 * an array of the results of each invoked method. Additional arguments will be provided
 * to each invoked method. If methodName is a function it will be invoked for, and this
 * bound to, each element in the collection.
 * @see _.invoke
 * 
 * @see _.invoke
 * 
 * @see _.invoke
 * 
 * @see _.invoke
 * 
 * @see _.invoke
 * 
 * @template T
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {string|!Function} methodName_or_method The name of the method to invoke.
 * @param {...?} args Arguments to invoke the method with.
 * 
 * @return {?}
 */
_.LoDashStatic.prototype.invoke = function(collection, methodName_or_method, args) {};

/**
 * Creates an array of values by running each element in collection through iteratee. The iteratee is bound to
 * thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property value
 * of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * Many lodash methods are guarded to work as iteratees for methods like _.every, _.filter, _.map, _.mapValues,
 * _.reject, and _.some.
 * 
 * The guarded methods are:
 * ary, callback, chunk, clone, create, curry, curryRight, drop, dropRight, every, fill, flatten, invert, max,
 * min, parseInt, slice, sortBy, take, takeRight, template, trim, trimLeft, trimRight, trunc, random, range,
 * sample, some, sum, uniq, and words
 * 
 * \@alias _.collect
 * 
 * @see _.map
 * @see _.map
 * @see _.map
 * @template T, TResult, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, TResult>|!_.DictionaryIterator<T, TResult>|string|TObject=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<TResult>|!Array<boolean>} Returns the new mapped array.
 */
_.LoDashStatic.prototype.map = function(collection, iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, TObject
 * @param {!_.ListIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitArrayWrapper.prototype.map = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, TObject
 * @param {(!_.ListIterator<TValue, TResult>|!_.DictionaryIterator<TValue, TResult>)|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapper.prototype.map = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, TObject
 * @param {!_.ListIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.map = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, TObject
 * @param {(!_.ListIterator<TValue, TResult>|!_.DictionaryIterator<TValue, TResult>)|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.map = function(iteratee, thisArg) {};

/**
 * Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for,
 * while the second of which contains elements predicate returns falsey for.
 * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback
 * returns the property value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback
 * returns true for elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns
 * true for elements that have the properties of the given object, else false.
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|W|string} callback_or_whereValue_or_path_or_pluckValue The function called per iteration.
 * @param {?=} thisArg_or_srcValue The this binding of predicate.
 * @return {!Array<!Array<T>>} Returns the array of grouped elements.
 * 
 */
_.LoDashStatic.prototype.partition = function(collection, callback_or_whereValue_or_path_or_pluckValue, thisArg_or_srcValue) {};

/**
 * @see _.partition
 * @param {!_.ListIterator<string, boolean>} callback
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<!Array<string>>}
 */
_.LoDashImplicitStringWrapper.prototype.partition = function(callback, thisArg) {};

/**
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @template W
 * @param {!_.ListIterator<T, boolean>|W|string} callback_or_whereValue_or_path_or_pluckValue
 * @param {?=} thisArg_or_srcValue
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.partition = function(callback_or_whereValue_or_path_or_pluckValue, thisArg_or_srcValue) {};

/**
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>|W|string} callback_or_whereValue_or_path_or_pluckValue
 * @param {?=} thisArg_or_srcValue
 * @return {!_.LoDashImplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashImplicitObjectWrapper.prototype.partition = function(callback_or_whereValue_or_path_or_pluckValue, thisArg_or_srcValue) {};

/**
 * Gets the property value of path from all elements in collection.
 * 
 * @see _.pluck
 * @template T, TResult
 * @param {(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to pluck.
 * @return {!Array<?>|!Array<TResult>} A new array of property values.
 */
_.LoDashStatic.prototype.pluck = function(collection, path) {};

/**
 * @see _.pluck
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.pluck = function(path) {};

/**
 * @see _.pluck
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.pluck = function(path) {};

/**
 * @see _.pluck
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.pluck = function(path) {};

/**
 * @see _.pluck
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.pluck = function(path) {};

/**
 * Reduces a collection to a value which is the accumulated result of running each
 * element in the collection through the callback, where each successive callback execution
 * consumes the return value of the previous execution. If accumulator is not provided the
 * first element of the collection will be used as the initial accumulator value. The callback
 * is bound to thisArg and invoked with four arguments; (accumulator, value, index|key, collection).
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {!_.MemoIterator<T, TResult>} callback The function called per iteration.
 * @param {TResult|?=} accumulator_or_thisArg Initial value of the accumulator.
 * @param {?=} thisArg The this binding of callback.
 * @return {TResult} Returns the accumulated value.
 * 
 */
_.LoDashStatic.prototype.reduce = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashStatic.prototype.inject = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashStatic.prototype.foldl = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TResult
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.reduce = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TResult
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.inject = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TResult
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.foldl = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.reduce = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.inject = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.foldl = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.reduce = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.inject = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.foldl = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * This method is like _.reduce except that it iterates over elements of a collection from
 * right to left.
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {!_.MemoIterator<T, TResult>} callback The function called per iteration.
 * @param {TResult|?=} accumulator_or_thisArg Initial value of the accumulator.
 * @param {?=} thisArg The this binding of callback.
 * @return {TResult} The accumulated value.
 * 
 */
_.LoDashStatic.prototype.reduceRight = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashStatic.prototype.foldr = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * The opposite of _.filter; this method returns the elements of collection that predicate does not return
 * truthy for.
 * 
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>|string|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.StringIterator<boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<T>|!Array<string>} Returns the new filtered array.
 */
_.LoDashStatic.prototype.reject = function(collection, predicate, thisArg) {};

/**
 * @see _.reject
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>|string|(!_.List<T>|!_.Dictionary<T>)} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.StringIterator<boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!Array<T>|!Array<string>}
 */
_.LoDashStatic.prototype.select = function(collection, predicate, thisArg) {};

/**
 * @see _.filter
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * Gets a random element or n random elements from a collection.
 * 
 * @see _.sample
 * @see _.sample
 * @see _.sample
 * @see _.sample
 * @see _.sample
 * @template T, O
 * @param {(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)|O|!Object} collection The collection to sample.
 * @param {number=} n
 * @return {!Array<T>|T} Returns the random sample(s) of collection.
 */
_.LoDashStatic.prototype.sample = function(collection, n) {};

/**
 * @see _.sample
 * @see _.sample
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<string>|string}
 */
_.LoDashImplicitWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper|T}
 */
_.LoDashImplicitArrayWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @template T
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>|T}
 */
_.LoDashImplicitObjectWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<string>|!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @template TWrapper
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper|TWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @template T, TWrapper
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>|TWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.sample = function(n) {};

/**
 * Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.
 * 
 * @see _.shuffle
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection The collection to shuffle.
 * @return {!Array<T>|!Array<string>} Returns the new shuffled array.
 */
_.LoDashStatic.prototype.shuffle = function(collection) {};

/**
 * @see _.shuffle
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.shuffle = function() {};

/**
 * Gets the size of collection by returning its length for array-like values or the number of own enumerable
 * properties for objects.
 * 
 * @see _.size
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection The collection to inspect.
 * @return {number} Returns the size of collection.
 */
_.LoDashStatic.prototype.size = function(collection) {};

/**
 * @see _.size
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.size = function() {};

/**
 * Checks if predicate returns truthy for any element of collection. The function returns as soon as it finds
 * a passing value and does not iterate over the entire collection. The predicate is bound to thisArg and
 * invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.any
 * 
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|!Object|(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>|!_.ObjectIterator<?, boolean>|string|TObject|!Object=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {boolean} Returns true if any element passes the predicate check, else false.
 */
_.LoDashStatic.prototype.some = function(collection, predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TObject
 * @param {(!_.ListIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.some = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult, TObject
 * @param {(!_.ObjectIterator<?, boolean>|!_.NumericDictionaryIterator<T, boolean>|!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.some = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TObject
 * @param {(!_.ListIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.some = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult, TObject
 * @param {(!_.ObjectIterator<?, boolean>|!_.NumericDictionaryIterator<T, boolean>|!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.some = function(predicate, thisArg) {};

/**
 * Creates an array of elements, sorted in ascending order by the results of running each element in a
 * collection through iteratee. This method performs a stable sort, that is, it preserves the original sort
 * order of equal elements. The iteratee is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * valueof the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template T, TSort, W
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, TSort>|!_.DictionaryIterator<T, TSort>|string|W=} iteratee_or_whereValue The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<T>} Returns the new sorted array.
 */
_.LoDashStatic.prototype.sortBy = function(collection, iteratee_or_whereValue, thisArg) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template TSort, W
 * @param {!_.ListIterator<T, TSort>|string|W=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.sortBy = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template T, TSort, W
 * @param {(!_.ListIterator<T, TSort>|!_.DictionaryIterator<T, TSort>)|string|W=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.sortBy = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template TSort, W
 * @param {!_.ListIterator<T, TSort>|string|W=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.sortBy = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template T, TSort, W
 * @param {(!_.ListIterator<T, TSort>|!_.DictionaryIterator<T, TSort>)|string|W=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.sortBy = function(iteratee_or_whereValue, thisArg) {};

/**
 * This method is like "_.sortBy" except that it can sort by multiple iteratees or
 * property names.
 * 
 * If a property name is provided for an iteratee the created "_.property" style callback
 * returns the property value of the given element.
 * 
 * If a value is also provided for thisArg the created "_.matchesProperty" style callback
 * returns true for elements that have a matching property value, else false.
 * 
 * If an object is provided for an iteratee the created "_.matches" style callback returns
 * true for elements that have the properties of the given object, else false.
 * 
 * @see _.sortByAll
 * 
 * @see _.sortByAll
 * 
 * @see _.sortByAll
 * 
 * Sorts by all the given arguments, using either ListIterator, pluckValue, or whereValue foramts
 * @template T
 * @param {!Array<T>|!_.List<T>|(!Array<T>|!_.List<T>)} collection The collection to iterate over.
 * @param {...!Array<(string|!Object|!_.ListIterator<T, ?>)>|(string|!Object|!_.ListIterator<T, ?>)|(string|!Object|!_.ListIterator<T, boolean>)} iteratees_or_args The rules by which to sort
 * @return {!Array<T>} A new array of sorted elements.
 * 
 */
_.LoDashStatic.prototype.sortByAll = function(collection, iteratees_or_args) {};

/**
 * Sorts by all the given arguments, using either ListIterator, pluckValue, or whereValue foramts
 * @see _.sortByAll
 * 
 * @see _.sortByAll
 * 
 * @param {...(string|!Object|!_.ListIterator<T, boolean>)|!Array<(string|!Object|!_.ListIterator<T, ?>)>|(string|!Object|!_.ListIterator<T, ?>)} args_or_iteratees The rules by which to sort
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.sortByAll = function(args_or_iteratees) {};

/**
 * This method is like _.sortByAll except that it allows specifying the sort orders of the iteratees to sort
 * by. If orders is unspecified, all values are sorted in ascending order. Otherwise, a value is sorted in
 * ascending order if its corresponding order is "asc", and descending if "desc".
 * 
 * If a property name is provided for an iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If an object is provided for an iteratee the created _.matches style callback returns true for elements
 * that have the properties of the given object, else false.
 * 
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @template W, T
 * @param {!_.List<T>|!_.NumericDictionary<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {(string|W|!_.ListIterator<T, ?>|!Array<(string|W|!_.ListIterator<T, ?>)>)|(string|!Object|!_.ListIterator<T, ?>|!Array<(string|!Object|!_.ListIterator<T, ?>)>)|(string|W|!_.NumericDictionaryIterator<T, ?>|!Array<(string|W|!_.NumericDictionaryIterator<T, ?>)>)|(string|!Object|!_.NumericDictionaryIterator<T, ?>|!Array<(string|!Object|!_.NumericDictionaryIterator<T, ?>)>)|(string|W|!_.DictionaryIterator<T, ?>|!Array<(string|W|!_.DictionaryIterator<T, ?>)>)|(string|!Object|!_.DictionaryIterator<T, ?>|!Array<(string|!Object|!_.DictionaryIterator<T, ?>)>)} iteratees The iteratees to sort by.
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders The sort orders of iteratees.
 * @return {!Array<T>} Returns the new sorted array.
 */
_.LoDashStatic.prototype.sortByOrder = function(collection, iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @param {(string|!_.ListIterator<T, ?>|!Array<(string|!_.ListIterator<T, ?>)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @template W
 * @param {(string|!_.ListIterator<T, ?>|W|!Array<(string|!_.ListIterator<T, ?>|W)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @template W, T
 * @param {(string|W|!_.ListIterator<T, ?>|!Array<(string|W|!_.ListIterator<T, ?>)>)|(string|!Object|!_.ListIterator<T, ?>|!Array<(string|!Object|!_.ListIterator<T, ?>)>)|(string|W|!_.NumericDictionaryIterator<T, ?>|!Array<(string|W|!_.NumericDictionaryIterator<T, ?>)>)|(string|!Object|!_.NumericDictionaryIterator<T, ?>|!Array<(string|!Object|!_.NumericDictionaryIterator<T, ?>)>)|(string|W|!_.DictionaryIterator<T, ?>|!Array<(string|W|!_.DictionaryIterator<T, ?>)>)|(string|!Object|!_.DictionaryIterator<T, ?>|!Array<(string|!Object|!_.DictionaryIterator<T, ?>)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @param {(string|!_.ListIterator<T, ?>|!Array<(string|!_.ListIterator<T, ?>)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @template W
 * @param {(string|!_.ListIterator<T, ?>|W|!Array<(string|!_.ListIterator<T, ?>|W)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @template W, T
 * @param {(string|W|!_.ListIterator<T, ?>|!Array<(string|W|!_.ListIterator<T, ?>)>)|(string|!Object|!_.ListIterator<T, ?>|!Array<(string|!Object|!_.ListIterator<T, ?>)>)|(string|W|!_.NumericDictionaryIterator<T, ?>|!Array<(string|W|!_.NumericDictionaryIterator<T, ?>)>)|(string|!Object|!_.NumericDictionaryIterator<T, ?>|!Array<(string|!Object|!_.NumericDictionaryIterator<T, ?>)>)|(string|W|!_.DictionaryIterator<T, ?>|!Array<(string|W|!_.DictionaryIterator<T, ?>)>)|(string|!Object|!_.DictionaryIterator<T, ?>|!Array<(string|!Object|!_.DictionaryIterator<T, ?>)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * Performs a deep comparison of each element in a collection to the given properties
 * object, returning an array of all elements that have equivalent property values.
 * @see _.where
 * 
 * @see _.where
 * 
 * @template T, U
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} list
 * @param {U} properties The object of property values to filter by.
 * @return {!Array<T>} A new array of elements that have the given properties.
 * 
 */
_.LoDashStatic.prototype.where = function(list, properties) {};

/**
 * @see _.where
 * 
 * @template U
 * @param {U} properties
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.where = function(properties) {};

/**
 * Gets the number of milliseconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).
 * 
 * @return {number} The number of milliseconds.
 */
_.LoDashStatic.prototype.now = function() {};

/**
 * @see _.now
 * @return {number}
 */
_.LoDashImplicitWrapperBase.prototype.now = function() {};

/**
 * @see _.now
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapperBase.prototype.now = function() {};

/**
 * The opposite of _.before; this method creates a function that invokes func once it’s called n or more times.
 * 
 * @template TFunc
 * @param {number} n The number of calls before func is invoked.
 * @param {TFunc} func The function to restrict.
 * @return {TFunc} Returns the new restricted function.
 */
_.LoDashStatic.prototype.after = function(n, func) {};

/**
 * @see _.after
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashImplicitObjectWrapper<TFunc>}
 */
_.LoDashImplicitWrapper.prototype.after = function(func) {};

/**
 * @see _.after
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashExplicitObjectWrapper<TFunc>}
 */
_.LoDashExplicitWrapper.prototype.after = function(func) {};

/**
 * Creates a function that accepts up to n arguments ignoring any additional arguments.
 * 
 * @template TResult, T
 * @param {!Function|T} func The function to cap arguments for.
 * @param {number=} n The arity cap.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.ary = function(func, n) {};

/**
 * @see _.ary
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.ary = function(n) {};

/**
 * @see _.ary
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.ary = function(n) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {TResult}
 */
_.LoDashStatic.prototype.backflow = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.backflow = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.backflow = function(funcs) {};

/**
 * Creates a function that invokes func, with the this binding and arguments of the created function, while
 * it’s called less than n times. Subsequent calls to the created function return the result of the last func
 * invocation.
 * 
 * @template TFunc
 * @param {number} n The number of calls at which func is no longer invoked.
 * @param {TFunc} func The function to restrict.
 * @return {TFunc} Returns the new restricted function.
 */
_.LoDashStatic.prototype.before = function(n, func) {};

/**
 * @see _.before
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashImplicitObjectWrapper<TFunc>}
 */
_.LoDashImplicitWrapper.prototype.before = function(func) {};

/**
 * @see _.before
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashExplicitObjectWrapper<TFunc>}
 */
_.LoDashExplicitWrapper.prototype.before = function(func) {};
/**
 * @record
 * @struct
 */
_.FunctionBind = function() {};
 /** @type {?} */
_.FunctionBind.prototype.placeholder;

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {!_.FunctionBind} */
_.LoDashStatic.prototype.bind;

/**
 * @see _.bind
 * @template TResult
 * @param {?} thisArg
 * @param {...?} partials
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.bind = function(thisArg, partials) {};

/**
 * @see _.bind
 * @template TResult
 * @param {?} thisArg
 * @param {...?} partials
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.bind = function(thisArg, partials) {};

/**
 * Binds methods of an object to the object itself, overwriting the existing method. Method names may be
 * specified as individual arguments or as arrays of method names. If no method names are provided all
 * enumerable function properties, own and inherited, of object are bound.
 * 
 * Note: This method does not set the "length" property of bound functions.
 * 
 * @template T
 * @param {T} object The object to bind and assign the bound methods to.
 * @param {...(string|!Array<string>)} methodNames The object method names to bind, specified as individual method names or arrays of
 * method names.
 * @return {T} Returns object.
 */
_.LoDashStatic.prototype.bindAll = function(object, methodNames) {};

/**
 * @see _.bindAll
 * @param {...(string|!Array<string>)} methodNames
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.bindAll = function(methodNames) {};

/**
 * @see _.bindAll
 * @param {...(string|!Array<string>)} methodNames
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.bindAll = function(methodNames) {};
/**
 * @record
 * @struct
 */
_.FunctionBindKey = function() {};
 /** @type {?} */
_.FunctionBindKey.prototype.placeholder;

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {!_.FunctionBindKey} */
_.LoDashStatic.prototype.bindKey;

/**
 * @see _.bindKey
 * @template TResult
 * @param {?} key
 * @param {...?} partials
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.bindKey = function(key, partials) {};

/**
 * @see _.bindKey
 * @template TResult
 * @param {?} key
 * @param {...?} partials
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.bindKey = function(key, partials) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {TResult}
 */
_.LoDashStatic.prototype.compose = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.compose = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.compose = function(funcs) {};

/**
 * Produces a callback bound to an optional thisArg. If func is a property name the created
 * callback will return the property value for a given element. If func is an object the created
 * callback will return true for elements that contain the equivalent object properties,
 * otherwise it will return false.
 * @see _.createCallback
 * 
 * @param {string|!_.Dictionary<?>} func The value to convert to a callback.
 * @param {?=} thisArg The this binding of the created callback.
 * @param {number=} argCount The number of arguments the callback accepts.
 * @return {function(): ?|function(): boolean} A callback function.
 * 
 */
_.LoDashStatic.prototype.createCallback = function(func, thisArg, argCount) {};

/**
 * @see _.createCallback
 * 
 * @param {?=} thisArg
 * @param {number=} argCount
 * @return {!_.LoDashImplicitObjectWrapper<function(): ?>}
 */
_.LoDashImplicitWrapper.prototype.createCallback = function(thisArg, argCount) {};

/**
 * @see _.createCallback
 * 
 * @param {?=} thisArg
 * @param {number=} argCount
 * @return {!_.LoDashImplicitObjectWrapper<function(): ?>}
 */
_.LoDashImplicitObjectWrapper.prototype.createCallback = function(thisArg, argCount) {};

/**
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * @template T1, R, T2, T3, T4, T5, TResult
 * @param {function(T1): R|function(T1, T2): R|function(T1, T2, T3): R|function(T1, T2, T3, T4): R|function(T1, T2, T3, T4, T5): R|!Function} func The function to curry.
 * @param {number=} arity The arity of func.
 * @return {!_.CurriedFunction1<T1, R>|!_.CurriedFunction2<T1, T2, R>|!_.CurriedFunction3<T1, T2, T3, R>|!_.CurriedFunction4<T1, T2, T3, T4, R>|!_.CurriedFunction5<T1, T2, T3, T4, T5, R>|TResult} Returns the new curried function.
 */
_.LoDashStatic.prototype.curry = function(func, arity) {};
/**
 * @record
 * @struct
 */
_.CurriedFunction1 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction2 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction3 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction4 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction5 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/**
 * @see _.curry
 * 
 * @template TResult
 * @param {number=} arity
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.curry = function(arity) {};

/**
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * @template T1, R, T2, T3, T4, T5, TResult
 * @param {function(T1): R|function(T1, T2): R|function(T1, T2, T3): R|function(T1, T2, T3, T4): R|function(T1, T2, T3, T4, T5): R|!Function} func The function to curry.
 * @param {number=} arity The arity of func.
 * @return {!_.CurriedFunction1<T1, R>|!_.CurriedFunction2<T2, T1, R>|!_.CurriedFunction3<T3, T2, T1, R>|!_.CurriedFunction4<T4, T3, T2, T1, R>|!_.CurriedFunction5<T5, T4, T3, T2, T1, R>|TResult} Returns the new curried function.
 */
_.LoDashStatic.prototype.curryRight = function(func, arity) {};

/**
 * @see _.curryRight
 * 
 * @template TResult
 * @param {number=} arity
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.curryRight = function(arity) {};
/**
 * @record
 * @struct
 */
_.DebounceSettings = function() {};
 /** @type {boolean} */
_.DebounceSettings.prototype.leading;
 /** @type {number} */
_.DebounceSettings.prototype.maxWait;
 /** @type {boolean} */
_.DebounceSettings.prototype.trailing;

/**
 * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since
 * the last time the debounced function was invoked. The debounced function comes with a cancel method to
 * cancel delayed invocations. Provide an options object to indicate that func should be invoked on the
 * leading and/or trailing edge of the wait timeout. Subsequent calls to the debounced function return the
 * result of the last func invocation.
 * 
 * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only
 * if the the debounced function is invoked more than once during the wait timeout.
 * 
 * See David Corbacho’s article for details over the differences between _.debounce and _.throttle.
 * 
 * @template T
 * @param {T} func The function to debounce.
 * @param {number=} wait The number of milliseconds to delay.
 * @param {!_.DebounceSettings=} options The options object.
 * @return {?} Returns the new debounced function.
 */
_.LoDashStatic.prototype.debounce = function(func, wait, options) {};

/**
 * @see _.debounce
 * @param {number=} wait
 * @param {!_.DebounceSettings=} options
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.debounce = function(wait, options) {};

/**
 * @see _.debounce
 * @param {number=} wait
 * @param {!_.DebounceSettings=} options
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.debounce = function(wait, options) {};

/**
 * Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to
 * func when it’s invoked.
 * 
 * @template T
 * @param {T} func The function to defer.
 * @param {...?} args The arguments to invoke the function with.
 * @return {number} Returns the timer id.
 */
_.LoDashStatic.prototype.defer = function(func, args) {};

/**
 * @see _.defer
 * @param {...?} args
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitObjectWrapper.prototype.defer = function(args) {};

/**
 * @see _.defer
 * @param {...?} args
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.defer = function(args) {};

/**
 * Invokes func after wait milliseconds. Any additional arguments are provided to func when it’s invoked.
 * 
 * @template T
 * @param {T} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...?} args The arguments to invoke the function with.
 * @return {number} Returns the timer id.
 */
_.LoDashStatic.prototype.delay = function(func, wait, args) {};

/**
 * @see _.delay
 * @param {number} wait
 * @param {...?} args
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitObjectWrapper.prototype.delay = function(wait, args) {};

/**
 * @see _.delay
 * @param {number} wait
 * @param {...?} args
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.delay = function(wait, args) {};

/**
 * Creates a function that returns the result of invoking the provided functions with the this binding of the
 * created function, where each successive invocation is supplied the return value of the previous.
 * 
 * @template TResult
 * @param {...!Function} funcs Functions to invoke.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.flow = function(funcs) {};

/**
 * @see _.flow
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.flow = function(funcs) {};

/**
 * @see _.flow
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.flow = function(funcs) {};

/**
 * This method is like _.flow except that it creates a function that invokes the provided functions from right
 * to left.
 * 
 * \@alias _.backflow, _.compose
 * 
 * @template TResult
 * @param {...!Function} funcs Functions to invoke.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.flowRight = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.flowRight = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.flowRight = function(funcs) {};
/**
 * @record
 * @struct
 */
_.MemoizedFunction = function() {};
 /** @type {!_.MapCache} */
_.MemoizedFunction.prototype.cache;
 /** @type {?} */
_.LoDashStatic.prototype.memoize;

/**
 * @see _.memoize
 * @param {!Function=} resolver
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.memoize = function(resolver) {};

/**
 * @see _.memoize
 * @param {!Function=} resolver
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.memoize = function(resolver) {};

/**
 * Creates a function that runs each argument through a corresponding transform function.
 * 
 * @see _.modArgs
 * @template T, TResult
 * @param {T} func The function to wrap.
 * @param {...!Function|!Array<!Function>} transforms The functions to transform arguments, specified as individual functions or arrays
 * of functions.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.modArgs = function(func, transforms) {};

/**
 * @see _.modArgs
 * @see _.modArgs
 * @template TResult
 * @param {...!Function|!Array<!Function>} transforms
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.modArgs = function(transforms) {};

/**
 * @see _.modArgs
 * @see _.modArgs
 * @template TResult
 * @param {...!Function|!Array<!Function>} transforms
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.modArgs = function(transforms) {};

/**
 * Creates a function that negates the result of the predicate func. The func predicate is invoked with
 * the this binding and arguments of the created function.
 * 
 * @see _.negate
 * @template T, TResult
 * @param {T} predicate The predicate to negate.
 * @return {function(!Array<?>): boolean|TResult} Returns the new function.
 */
_.LoDashStatic.prototype.negate = function(predicate) {};

/**
 * @see _.negate
 * @see _.negate
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(!Array<?>): boolean>|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.negate = function() {};

/**
 * @see _.negate
 * @see _.negate
 * @template TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(!Array<?>): boolean>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.negate = function() {};

/**
 * Creates a function that is restricted to invoking func once. Repeat calls to the function return the value
 * of the first call. The func is invoked with the this binding and arguments of the created function.
 * 
 * @template T
 * @param {T} func The function to restrict.
 * @return {T} Returns the new restricted function.
 */
_.LoDashStatic.prototype.once = function(func) {};

/**
 * @see _.once
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.once = function() {};

/**
 * @see _.once
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.once = function() {};
 /** @type {!_.Partial} */
_.LoDashStatic.prototype.partial;

/** @typedef {!_.LoDashStatic} */
_.PH;
/**
 * @record
 * @struct
 */
_.Function0 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Function1 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Function2 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Function3 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Function4 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Partial = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {!_.PartialRight} */
_.LoDashStatic.prototype.partialRight;
/**
 * @record
 * @struct
 */
_.PartialRight = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/**
 * Creates a function that invokes func with arguments arranged according to the specified indexes where the
 * argument value at the first index is provided as the first argument, the argument value at the second index
 * is provided as the second argument, and so on.
 * @see _.rearg
 * @template TResult
 * @param {!Function} func The function to rearrange arguments for.
 * @param {...!Array<number>|number} indexes The arranged argument indexes, specified as individual indexes or arrays of indexes.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.rearg = function(func, indexes) {};

/**
 * @see _.rearg
 * @see _.rearg
 * @template TResult
 * @param {...!Array<number>|number} indexes
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.rearg = function(indexes) {};

/**
 * Creates a function that invokes func with the this binding of the created function and arguments from start
 * and beyond provided as an array.
 * 
 * Note: This method is based on the rest parameter.
 * 
 * @see _.restParam
 * @template TResult, TFunc
 * @param {!Function|TFunc} func The function to apply a rest parameter to.
 * @param {number=} start The start position of the rest parameter.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.restParam = function(func, start) {};

/**
 * @see _.restParam
 * @template TResult
 * @param {number=} start
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.restParam = function(start) {};

/**
 * @see _.restParam
 * @template TResult
 * @param {number=} start
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.restParam = function(start) {};

/**
 * Creates a function that invokes func with the this binding of the created function and an array of arguments
 * much like Function#apply.
 * 
 * Note: This method is based on the spread operator.
 * 
 * @see _.spread
 * @template F, T
 * @param {F|!Function} func The function to spread arguments over.
 * @return {T} Returns the new function.
 */
_.LoDashStatic.prototype.spread = function(func) {};

/**
 * @see _.spread
 * @template T
 * @return {!_.LoDashImplicitObjectWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.spread = function() {};

/**
 * @see _.spread
 * @template T
 * @return {!_.LoDashExplicitObjectWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.spread = function() {};
/**
 * @record
 * @struct
 */
_.ThrottleSettings = function() {};
 /** @type {boolean} */
_.ThrottleSettings.prototype.leading;
 /** @type {boolean} */
_.ThrottleSettings.prototype.trailing;

/**
 * Creates a throttled function that only invokes func at most once per every wait milliseconds. The throttled
 * function comes with a cancel method to cancel delayed invocations. Provide an options object to indicate
 * that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls to
 * the throttled function return the result of the last func call.
 * 
 * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if
 * the the throttled function is invoked more than once during the wait timeout.
 * 
 * @template T
 * @param {T} func The function to throttle.
 * @param {number=} wait The number of milliseconds to throttle invocations to.
 * @param {!_.ThrottleSettings=} options The options object.
 * @return {?} Returns the new throttled function.
 */
_.LoDashStatic.prototype.throttle = function(func, wait, options) {};

/**
 * @see _.throttle
 * @param {number=} wait
 * @param {!_.ThrottleSettings=} options
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.throttle = function(wait, options) {};

/**
 * @see _.throttle
 * @param {number=} wait
 * @param {!_.ThrottleSettings=} options
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.throttle = function(wait, options) {};

/**
 * Creates a function that provides value to the wrapper function as its first argument. Any additional
 * arguments provided to the function are appended to those provided to the wrapper function. The wrapper is
 * invoked with the this binding of the created function.
 * 
 * @see _.wrap
 * @see _.wrap
 * @template V, W, R
 * @param {V|?} value The value to wrap.
 * @param {W|!Function} wrapper The wrapper function.
 * @return {R} Returns the new function.
 */
_.LoDashStatic.prototype.wrap = function(value, wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashImplicitObjectWrapper<R>}
 */
_.LoDashImplicitWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashImplicitObjectWrapper<R>}
 */
_.LoDashImplicitArrayWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashImplicitObjectWrapper<R>}
 */
_.LoDashImplicitObjectWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashExplicitObjectWrapper<R>}
 */
_.LoDashExplicitWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashExplicitObjectWrapper<R>}
 */
_.LoDashExplicitArrayWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashExplicitObjectWrapper<R>}
 */
_.LoDashExplicitObjectWrapper.prototype.wrap = function(wrapper) {};
/**
 * @record
 * @struct
 */
_.CloneCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Creates a clone of value. If isDeep is true nested objects are cloned, otherwise they are assigned by
 * reference. If customizer is provided it's invoked to produce the cloned values. If customizer returns
 * undefined cloning is handled by the method instead. The customizer is bound to thisArg and invoked with
 * up to three argument; (value [, index|key, object]).
 * 
 * Note: This method is loosely based on the structured clone algorithm. The enumerable properties of
 * arguments objects and objects created by constructors other than Object are cloned to plain Object
 * objects. An empty object is returned for uncloneable values such as functions, DOM nodes, Maps, Sets,
 * and WeakMaps.
 * 
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult, T
 * @param {?|T} value The value to clone.
 * @param {boolean|!_.CloneCustomizer<?, TResult>|!_.CloneCustomizer<T, TResult>=} isDeep_or_customizer Specify a deep clone.
 * @param {!_.CloneCustomizer<?, TResult>|!_.CloneCustomizer<T, TResult>|?=} customizer_or_thisArg The function to customize cloning values.
 * @param {?=} thisArg The this binding of customizer.
 * @return {TResult|T} Returns the cloned value.
 */
_.LoDashStatic.prototype.clone = function(value, isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<T, TResult>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<T, TResult>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {TResult|T}
 */
_.LoDashImplicitWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<!Array<T>, TResult>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<!Array<T>, TResult>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {TResult|!Array<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<T, TResult>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<T, TResult>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {TResult|T}
 */
_.LoDashImplicitObjectWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<T, TResult>|!_.CloneCustomizer<T, !Array<TResult>>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<T, TResult>|!_.CloneCustomizer<T, !Array<TResult>>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitWrapper}
 */
_.LoDashExplicitWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<!Array<T>, TResult>|!_.CloneCustomizer<!Array<T>, !Array<TResult>>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<!Array<T>, TResult>|!_.CloneCustomizer<!Array<T>, !Array<TResult>>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<T, TResult>|!_.CloneCustomizer<T, !Array<TResult>>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<T, TResult>|!_.CloneCustomizer<T, !Array<TResult>>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};
/**
 * @record
 * @struct
 */
_.CloneDeepCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Creates a deep clone of value. If customizer is provided it's invoked to produce the cloned values.
 * If customizer returns undefined cloning is handled by the method instead. The customizer is bound to
 * thisArg and invoked with up to three argument; (value [, index|key, object]).
 * 
 * Note: This method is loosely based on the structured clone algorithm. The enumerable properties of
 * arguments objects and objects created by constructors other than Object are cloned to plain Object objects.
 * An empty object is returned for uncloneable values such as functions, DOM nodes, Maps, Sets, and WeakMaps.
 * 
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult, T
 * @param {?|T} value The value to deep clone.
 * @param {!_.CloneDeepCustomizer<?, TResult>|!_.CloneDeepCustomizer<T, TResult>=} customizer The function to customize cloning values.
 * @param {?=} thisArg The this binding of customizer.
 * @return {TResult|T} Returns the deep cloned value.
 */
_.LoDashStatic.prototype.cloneDeep = function(value, customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<T, TResult>=} customizer
 * @param {?=} thisArg
 * @return {TResult|T}
 */
_.LoDashImplicitWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<!Array<T>, TResult>=} customizer
 * @param {?=} thisArg
 * @return {TResult|!Array<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<T, TResult>=} customizer
 * @param {?=} thisArg
 * @return {TResult|T}
 */
_.LoDashImplicitObjectWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<T, TResult>|!_.CloneDeepCustomizer<T, !Array<TResult>>=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitWrapper}
 */
_.LoDashExplicitWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<!Array<T>, TResult>|!_.CloneDeepCustomizer<!Array<T>, !Array<TResult>>=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<T, TResult>|!_.CloneDeepCustomizer<T, !Array<TResult>>=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} value
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashStatic.prototype.eq = function(value, other, customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.eq = function(other, customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.eq = function(other, customizer, thisArg) {};

/**
 * Checks if value is greater than other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is greater than other, else false.
 */
_.LoDashStatic.prototype.gt = function(value, other) {};

/**
 * @see _.gt
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.gt = function(other) {};

/**
 * @see _.gt
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.gt = function(other) {};

/**
 * Checks if value is greater than or equal to other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is greater than or equal to other, else false.
 */
_.LoDashStatic.prototype.gte = function(value, other) {};

/**
 * @see _.gte
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.gte = function(other) {};

/**
 * @see _.gte
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.gte = function(other) {};

/**
 * Checks if value is classified as an arguments object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isArguments = function(value) {};

/**
 * @see _.isArguments
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isArguments = function() {};

/**
 * @see _.isArguments
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isArguments = function() {};

/**
 * Checks if value is classified as an Array object.
 * @template T
 * @param {?=} value The value to check.
 * 
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isArray = function(value) {};

/**
 * @see _.isArray
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isArray = function() {};

/**
 * @see _.isArray
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isArray = function() {};

/**
 * Checks if value is classified as a boolean primitive or object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isBoolean = function(value) {};

/**
 * @see _.isBoolean
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isBoolean = function() {};

/**
 * @see _.isBoolean
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isBoolean = function() {};

/**
 * Checks if value is classified as a Date object.
 * @param {?=} value The value to check.
 * 
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isDate = function(value) {};

/**
 * @see _.isDate
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isDate = function() {};

/**
 * @see _.isDate
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isDate = function() {};

/**
 * Checks if value is a DOM element.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a DOM element, else false.
 */
_.LoDashStatic.prototype.isElement = function(value) {};

/**
 * @see _.isElement
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isElement = function() {};

/**
 * @see _.isElement
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isElement = function() {};

/**
 * Checks if value is empty. A value is considered empty unless it’s an arguments object, array, string, or
 * jQuery-like collection with a length greater than 0 or an object with own enumerable properties.
 * 
 * @param {?=} value The value to inspect.
 * @return {boolean} Returns true if value is empty, else false.
 */
_.LoDashStatic.prototype.isEmpty = function(value) {};

/**
 * @see _.isEmpty
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isEmpty = function() {};

/**
 * @see _.isEmpty
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isEmpty = function() {};
/**
 * @record
 * @struct
 */
_.IsEqualCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Performs a deep comparison between two values to determine if they are equivalent. If customizer is
 * provided it’s invoked to compare values. If customizer returns undefined comparisons are handled by the
 * method instead. The customizer is bound to thisArg and invoked with up to three arguments: (value, other
 * [, index|key]).
 * 
 * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes,
 * and strings. Objects are compared by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are not supported. Provide a customizer function to extend support for comparing other values.
 * 
 * \@alias _.eq
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @param {!_.IsEqualCustomizer=} customizer The function to customize value comparisons.
 * @param {?=} thisArg The this binding of customizer.
 * @return {boolean} Returns true if the values are equivalent, else false.
 */
_.LoDashStatic.prototype.isEqual = function(value, other, customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isEqual = function(other, customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isEqual = function(other, customizer, thisArg) {};

/**
 * Checks if value is an Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, or URIError
 * object.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is an error object, else false.
 */
_.LoDashStatic.prototype.isError = function(value) {};

/**
 * @see _.isError
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isError = function() {};

/**
 * @see _.isError
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isError = function() {};

/**
 * Checks if value is a finite primitive number.
 * 
 * Note: This method is based on Number.isFinite.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a finite number, else false.
 */
_.LoDashStatic.prototype.isFinite = function(value) {};

/**
 * @see _.isFinite
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isFinite = function() {};

/**
 * @see _.isFinite
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isFinite = function() {};

/**
 * Checks if value is classified as a Function object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isFunction = function(value) {};

/**
 * @see _.isFunction
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isFunction = function() {};

/**
 * @see _.isFunction
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isFunction = function() {};
/**
 * @record
 * @struct
 */
_.isMatchCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Performs a deep comparison between object and source to determine if object contains equivalent property
 * values. If customizer is provided it’s invoked to compare values. If customizer returns undefined
 * comparisons are handled by the method instead. The customizer is bound to thisArg and invoked with three
 * arguments: (value, other, index|key).
 * @param {!Object} object The object to inspect.
 * @param {!Object} source The object of property values to match.
 * @param {!_.isMatchCustomizer=} customizer The function to customize value comparisons.
 * @param {?=} thisArg The this binding of customizer.
 * @return {boolean} Returns true if object is a match, else false.
 */
_.LoDashStatic.prototype.isMatch = function(object, source, customizer, thisArg) {};

/**
 * @see _.isMatch
 * @param {!Object} source
 * @param {!_.isMatchCustomizer=} customizer
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.isMatch = function(source, customizer, thisArg) {};

/**
 * Checks if value is NaN.
 * 
 * Note: This method is not the same as isNaN which returns true for undefined and other non-numeric values.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is NaN, else false.
 */
_.LoDashStatic.prototype.isNaN = function(value) {};

/**
 * @see _.isNaN
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNaN = function() {};

/**
 * @see _.isNaN
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNaN = function() {};

/**
 * Checks if value is a native function.
 * \@retrun Returns true if value is a native function, else false.
 * @param {?} value The value to check.
 * 
 * @return {boolean}
 */
_.LoDashStatic.prototype.isNative = function(value) {};

/**
 * see _.isNative
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNative = function() {};

/**
 * see _.isNative
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNative = function() {};

/**
 * Checks if value is null.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is null, else false.
 */
_.LoDashStatic.prototype.isNull = function(value) {};

/**
 * see _.isNull
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNull = function() {};

/**
 * see _.isNull
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNull = function() {};

/**
 * Checks if value is classified as a Number primitive or object.
 * 
 * Note: To exclude Infinity, -Infinity, and NaN, which are classified as numbers, use the _.isFinite method.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isNumber = function(value) {};

/**
 * see _.isNumber
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNumber = function() {};

/**
 * see _.isNumber
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNumber = function() {};

/**
 * Checks if value is the language type of Object. (e.g. arrays, functions, objects, regexes, new Number(0),
 * and new String(''))
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is an object, else false.
 */
_.LoDashStatic.prototype.isObject = function(value) {};

/**
 * see _.isObject
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isObject = function() {};

/**
 * see _.isObject
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isObject = function() {};

/**
 * Checks if value is a plain object, that is, an object created by the Object constructor or one with a
 * [[Prototype]] of null.
 * 
 * Note: This method assumes objects created by the Object constructor have no inherited enumerable properties.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a plain object, else false.
 */
_.LoDashStatic.prototype.isPlainObject = function(value) {};

/**
 * see _.isPlainObject
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isPlainObject = function() {};

/**
 * see _.isPlainObject
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isPlainObject = function() {};

/**
 * Checks if value is classified as a RegExp object.
 * @param {?=} value The value to check.
 * 
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isRegExp = function(value) {};

/**
 * see _.isRegExp
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isRegExp = function() {};

/**
 * see _.isRegExp
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isRegExp = function() {};

/**
 * Checks if value is classified as a String primitive or object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isString = function(value) {};

/**
 * see _.isString
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isString = function() {};

/**
 * see _.isString
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isString = function() {};

/**
 * Checks if value is classified as a typed array.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isTypedArray = function(value) {};

/**
 * see _.isTypedArray
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isTypedArray = function() {};

/**
 * see _.isTypedArray
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isTypedArray = function() {};

/**
 * Checks if value is undefined.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is undefined, else false.
 */
_.LoDashStatic.prototype.isUndefined = function(value) {};

/**
 * see _.isUndefined
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isUndefined = function() {};

/**
 * see _.isUndefined
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isUndefined = function() {};

/**
 * Checks if value is less than other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is less than other, else false.
 */
_.LoDashStatic.prototype.lt = function(value, other) {};

/**
 * @see _.lt
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.lt = function(other) {};

/**
 * @see _.lt
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.lt = function(other) {};

/**
 * Checks if value is less than or equal to other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is less than or equal to other, else false.
 */
_.LoDashStatic.prototype.lte = function(value, other) {};

/**
 * @see _.lte
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.lte = function(other) {};

/**
 * @see _.lte
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.lte = function(other) {};

/**
 * Converts value to an array.
 * 
 * @see _.toArray
 * @see _.toArray
 * @template T, TValue, TResult
 * @param {(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)|TValue|?=} value The value to convert.
 * @return {!Array<T>|!Array<TResult>} Returns the converted array.
 */
_.LoDashStatic.prototype.toArray = function(value) {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.toArray = function() {};

/**
 * Converts value to a plain object flattening inherited enumerable properties of value to own properties
 * of the plain object.
 * 
 * @template TResult
 * @param {?=} value The value to convert.
 * @return {TResult} Returns the converted plain object.
 */
_.LoDashStatic.prototype.toPlainObject = function(value) {};

/**
 * @see _.toPlainObject
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.toPlainObject = function() {};

/**
 * Adds two numbers.
 * 
 * @param {number} augend The first number to add.
 * @param {number} addend The second number to add.
 * @return {number} Returns the sum.
 */
_.LoDashStatic.prototype.add = function(augend, addend) {};

/**
 * @see _.add
 * @param {number} addend
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.add = function(addend) {};

/**
 * @see _.add
 * @param {number} addend
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.add = function(addend) {};

/**
 * Calculates n rounded up to precision.
 * 
 * @param {number} n The number to round up.
 * @param {number=} precision The precision to round up to.
 * @return {number} Returns the rounded up number.
 */
_.LoDashStatic.prototype.ceil = function(n, precision) {};

/**
 * @see _.ceil
 * @param {number=} precision
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.ceil = function(precision) {};

/**
 * @see _.ceil
 * @param {number=} precision
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.ceil = function(precision) {};

/**
 * Calculates n rounded down to precision.
 * 
 * @param {number} n The number to round down.
 * @param {number=} precision The precision to round down to.
 * @return {number} Returns the rounded down number.
 */
_.LoDashStatic.prototype.floor = function(n, precision) {};

/**
 * @see _.floor
 * @param {number=} precision
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.floor = function(precision) {};

/**
 * @see _.floor
 * @param {number=} precision
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.floor = function(precision) {};

/**
 * Gets the maximum value of collection. If collection is empty or falsey -Infinity is returned. If an iteratee
 * function is provided it’s invoked for each value in collection to generate the criterion by which the value
 * is ranked. The iteratee is bound to thisArg and invoked with three arguments: (value, index, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property value
 * of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.max
 * @see _.max
 * @see _.max
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|string|TObject=} iteratee_or_whereValue The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {T} Returns the maximum value.
 */
_.LoDashStatic.prototype.max = function(collection, iteratee_or_whereValue, thisArg) {};

/**
 * @see _.max
 * @see _.max
 * @see _.max
 * @template TObject
 * @param {!_.ListIterator<T, ?>|string|TObject=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.max = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.max
 * @see _.max
 * @see _.max
 * @template T, TObject
 * @param {(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|TObject=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.max = function(iteratee_or_whereValue, thisArg) {};

/**
 * Gets the minimum value of collection. If collection is empty or falsey Infinity is returned. If an iteratee
 * function is provided it’s invoked for each value in collection to generate the criterion by which the value
 * is ranked. The iteratee is bound to thisArg and invoked with three arguments: (value, index, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property value
 * of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.min
 * @see _.min
 * @see _.min
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|string|TObject=} iteratee_or_whereValue The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {T} Returns the minimum value.
 */
_.LoDashStatic.prototype.min = function(collection, iteratee_or_whereValue, thisArg) {};

/**
 * @see _.min
 * @see _.min
 * @see _.min
 * @template TObject
 * @param {!_.ListIterator<T, ?>|string|TObject=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.min = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.min
 * @see _.min
 * @see _.min
 * @template T, TObject
 * @param {(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|TObject=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.min = function(iteratee_or_whereValue, thisArg) {};

/**
 * Calculates n rounded to precision.
 * 
 * @param {number} n The number to round.
 * @param {number=} precision The precision to round to.
 * @return {number} Returns the rounded number.
 */
_.LoDashStatic.prototype.round = function(n, precision) {};

/**
 * @see _.round
 * @param {number=} precision
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.round = function(precision) {};

/**
 * @see _.round
 * @param {number=} precision
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.round = function(precision) {};

/**
 * Gets the sum of the values in collection.
 * 
 * @see _.sum
 * 
 * @see _.sum
 * @see _.sum
 * @see _.sum
 * @template T
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<!Object>|!_.Dictionary<?>)|(!_.List<T>|!_.Dictionary<T>)|(!_.Dictionary<number>|!_.List<number>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, number>|!_.DictionaryIterator<T, number>|string=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {number} Returns the sum.
 */
_.LoDashStatic.prototype.sum = function(collection, iteratee, thisArg) {};

/**
 * @see _.sum
 * @see _.sum
 * @see _.sum
 * @param {!_.ListIterator<T, number>|string=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.sum = function(iteratee, thisArg) {};

/**
 * @see _.sum
 * 
 * @see _.sum
 * @see _.sum
 * @template TValue
 * @param {(!_.ListIterator<TValue, number>|!_.DictionaryIterator<TValue, number>)|string=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.sum = function(iteratee, thisArg) {};

/**
 * @see _.sum
 * @see _.sum
 * @see _.sum
 * @param {!_.ListIterator<T, number>|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.sum = function(iteratee, thisArg) {};

/**
 * @see _.sum
 * @see _.sum
 * @see _.sum
 * @template TValue
 * @param {(!_.ListIterator<TValue, number>|!_.DictionaryIterator<TValue, number>)|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.sum = function(iteratee, thisArg) {};

/**
 * Checks if n is between start and up to but not including, end. If end is not specified it’s set to start
 * with start then set to 0.
 * 
 * @see _.inRange
 * @param {number} n The number to check.
 * @param {number} start_or_end The start of the range.
 * @param {number=} end The end of the range.
 * @return {boolean} Returns true if n is in the range, else false.
 */
_.LoDashStatic.prototype.inRange = function(n, start_or_end, end) {};

/**
 * @see _.inRange
 * @see _.inRange
 * @param {number} start_or_end
 * @param {number=} end
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.inRange = function(start_or_end, end) {};

/**
 * @see _.inRange
 * @see _.inRange
 * @param {number} start_or_end
 * @param {number=} end
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.inRange = function(start_or_end, end) {};

/**
 * Produces a random number between min and max (inclusive). If only one argument is provided a number between
 * 0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point
 * number is returned instead of an integer.
 * 
 * @see _.random
 * @see _.random
 * @param {number|boolean=} min_or_floating The minimum possible value.
 * @param {number|boolean=} max_or_floating The maximum possible value.
 * @param {boolean=} floating Specify returning a floating-point number.
 * @return {number} Returns the random number.
 */
_.LoDashStatic.prototype.random = function(min_or_floating, max_or_floating, floating) {};

/**
 * @see _.random
 * @see _.random
 * @param {number|boolean=} max_or_floating
 * @param {boolean=} floating
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.random = function(max_or_floating, floating) {};

/**
 * @see _.random
 * @see _.random
 * @param {number|boolean=} max_or_floating
 * @param {boolean=} floating
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.random = function(max_or_floating, floating) {};
/**
 * @record
 * @struct
 */
_.AssignCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Assigns own enumerable properties of source object(s) to the destination object. Subsequent sources
 * overwrite property assignments of previous sources. If customizer is provided it’s invoked to produce the
 * assigned values. The customizer is bound to thisArg and invoked with five arguments:
 * (objectValue, sourceValue, key, object, source).
 * 
 * Note: This method mutates object and is based on Object.assign.
 * 
 * \@alias _.extend
 * 
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TObject, TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {TObject} object The destination object.
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs The source objects.
 * @return {TResult|TObject} The destination object.
 */
_.LoDashStatic.prototype.assign = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.assign = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.assign = function(source_or_source1_or_otherArgs) {};

/**
 * Creates an object that inherits from the given prototype object. If a properties object is provided its own
 * enumerable properties are assigned to the created object.
 * 
 * @template T, U
 * @param {T} prototype The object to inherit from.
 * @param {U=} properties The properties to assign to the object.
 * @return {?} Returns the new object.
 */
_.LoDashStatic.prototype.create = function(prototype, properties) {};

/**
 * @see _.create
 * @template U
 * @param {U=} properties
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.create = function(properties) {};

/**
 * @see _.create
 * @template U
 * @param {U=} properties
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.create = function(properties) {};

/**
 * Assigns own enumerable properties of source object(s) to the destination object for all destination
 * properties that resolve to undefined. Once a property is set, additional values of the same property are
 * ignored.
 * 
 * Note: This method mutates object.
 * 
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @template Obj, TResult, S1, S2, S3, S4
 * @param {Obj|!Object} object The destination object.
 * @param {...!Object|S1} sources_or_source1 The source objects.
 * @return {TResult} The destination object.
 */
_.LoDashStatic.prototype.defaults = function(object, sources_or_source1) {};

/**
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @template S1, TResult, S2, S3, S4
 * @param {...S1|!Object} source1_or_sources
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.defaults = function(source1_or_sources) {};

/**
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @template S1, TResult, S2, S3, S4
 * @param {...S1|!Object} source1_or_sources
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.defaults = function(source1_or_sources) {};

/**
 * This method is like _.defaults except that it recursively assigns default properties.
 * @template T, TResult
 * @param {T} object The destination object.
 * @param {...?} sources The source objects.
 * @return {TResult} Returns object.
 * 
 */
_.LoDashStatic.prototype.defaultsDeep = function(object, sources) {};

/**
 * @see _.defaultsDeep
 * 
 * @template TResult
 * @param {...?} sources
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.defaultsDeep = function(sources) {};

/**
 * @see assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TObject, TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {TObject} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {TResult|TObject}
 */
_.LoDashStatic.prototype.extend = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.extend = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.extend = function(source_or_source1_or_otherArgs) {};

/**
 * This method is like _.find except that it returns the key of the first element predicate returns truthy for
 * instead of the element itself.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @template TValues, TObject, TWhere
 * @param {TObject} object The object to search.
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {string} Returns the key of the matched element, else undefined.
 */
_.LoDashStatic.prototype.findKey = function(object, predicate, thisArg) {};

/**
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @template TValues, TWhere
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {string}
 */
_.LoDashImplicitObjectWrapper.prototype.findKey = function(predicate, thisArg) {};

/**
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @template TValues, TWhere
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.findKey = function(predicate, thisArg) {};

/**
 * This method is like _.findKey except that it iterates over elements of a collection in the opposite order.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @template TValues, TObject, TWhere
 * @param {TObject} object The object to search.
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {string} Returns the key of the matched element, else undefined.
 */
_.LoDashStatic.prototype.findLastKey = function(object, predicate, thisArg) {};

/**
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @template TValues, TWhere
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {string}
 */
_.LoDashImplicitObjectWrapper.prototype.findLastKey = function(predicate, thisArg) {};

/**
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @template TValues, TWhere
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.findLastKey = function(predicate, thisArg) {};

/**
 * Iterates over own and inherited enumerable properties of an object invoking iteratee for each property. The
 * iteratee is bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may
 * exit iteration early by explicitly returning false.
 * 
 * @see _.forIn
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forIn = function(object, iteratee, thisArg) {};

/**
 * @see _.forIn
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forIn = function(iteratee, thisArg) {};

/**
 * @see _.forIn
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forIn = function(iteratee, thisArg) {};

/**
 * This method is like _.forIn except that it iterates over properties of object in the opposite order.
 * 
 * @see _.forInRight
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forInRight = function(object, iteratee, thisArg) {};

/**
 * @see _.forInRight
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forInRight = function(iteratee, thisArg) {};

/**
 * @see _.forInRight
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forInRight = function(iteratee, thisArg) {};

/**
 * Iterates over own enumerable properties of an object invoking iteratee for each property. The iteratee is
 * bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning false.
 * 
 * @see _.forOwn
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forOwn = function(object, iteratee, thisArg) {};

/**
 * @see _.forOwn
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forOwn = function(iteratee, thisArg) {};

/**
 * @see _.forOwn
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forOwn = function(iteratee, thisArg) {};

/**
 * This method is like _.forOwn except that it iterates over properties of object in the opposite order.
 * 
 * @see _.forOwnRight
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forOwnRight = function(object, iteratee, thisArg) {};

/**
 * @see _.forOwnRight
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forOwnRight = function(iteratee, thisArg) {};

/**
 * @see _.forOwnRight
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forOwnRight = function(iteratee, thisArg) {};

/**
 * Creates an array of function property names from all enumerable properties, own and inherited, of object.
 * 
 * \@alias _.methods
 * 
 * @template T
 * @param {?} object The object to inspect.
 * @return {!Array<string>} Returns the new array of property names.
 */
_.LoDashStatic.prototype.functions = function(object) {};

/**
 * @see _.functions
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.functions = function() {};

/**
 * @see _.functions
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.functions = function() {};

/**
 * Gets the property value at path of object. If the resolved value is undefined the defaultValue is used
 * in its place.
 * 
 * @see _.get
 * @template TObject, TResult
 * @param {TObject|?} object The object to query.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to get.
 * @param {TResult=} defaultValue The value returned if the resolved value is undefined.
 * @return {TResult} Returns the resolved value.
 */
_.LoDashStatic.prototype.get = function(object, path, defaultValue) {};

/**
 * @see _.get
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {TResult=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {TResult=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {TResult=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.get = function(path, defaultValue) {};

/**
 * Checks if path is a direct property.
 * 
 * @template T
 * @param {T} object The object to query.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path to check.
 * @return {boolean} Returns true if path is a direct property, else false.
 */
_.LoDashStatic.prototype.has = function(object, path) {};

/**
 * @see _.has
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.has = function(path) {};

/**
 * @see _.has
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.has = function(path) {};

/**
 * Creates an object composed of the inverted keys and values of object. If object contains duplicate values,
 * subsequent values overwrite property assignments of previous values unless multiValue is true.
 * 
 * @see _.invert
 * @template T, TResult
 * @param {T|!Object} object The object to invert.
 * @param {boolean=} multiValue Allow multiple values per key.
 * @return {TResult} Returns the new inverted object.
 */
_.LoDashStatic.prototype.invert = function(object, multiValue) {};

/**
 * @see _.invert
 * @template TResult
 * @param {boolean=} multiValue
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.invert = function(multiValue) {};

/**
 * @see _.invert
 * @template TResult
 * @param {boolean=} multiValue
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.invert = function(multiValue) {};

/**
 * Creates an array of the own enumerable property names of object.
 * 
 * Note: Non-object values are coerced to objects. See the ES spec for more details.
 * 
 * @param {?=} object The object to query.
 * @return {!Array<string>} Returns the array of property names.
 */
_.LoDashStatic.prototype.keys = function(object) {};

/**
 * @see _.keys
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.keys = function() {};

/**
 * @see _.keys
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.keys = function() {};

/**
 * Creates an array of the own and inherited enumerable property names of object.
 * 
 * Note: Non-object values are coerced to objects.
 * 
 * @param {?=} object The object to query.
 * @return {!Array<string>} An array of property names.
 */
_.LoDashStatic.prototype.keysIn = function(object) {};

/**
 * @see _.keysIn
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.keysIn = function() {};

/**
 * @see _.keysIn
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.keysIn = function() {};

/**
 * The opposite of _.mapValues; this method creates an object with the same values as object and keys generated
 * by running each own enumerable property of object through iteratee.
 * 
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template T, TKey, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.Dictionary<T>|!_.List<T>)} object The object to iterate over.
 * @param {!_.ListIterator<T, TKey>|!_.DictionaryIterator<T, TKey>|TObject|string=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>} Returns the new mapped object.
 */
_.LoDashStatic.prototype.mapKeys = function(object, iteratee, thisArg) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TKey, TObject
 * @param {!_.ListIterator<T, TKey>|TObject|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.mapKeys = function(iteratee, thisArg) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TResult, TKey, TObject
 * @param {(!_.ListIterator<TResult, TKey>|!_.DictionaryIterator<TResult, TKey>)|TObject|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>}
 */
_.LoDashImplicitObjectWrapper.prototype.mapKeys = function(iteratee, thisArg) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TKey, TObject
 * @param {!_.ListIterator<T, TKey>|TObject|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.mapKeys = function(iteratee, thisArg) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TResult, TKey, TObject
 * @param {(!_.ListIterator<TResult, TKey>|!_.DictionaryIterator<TResult, TKey>)|TObject|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<TResult>>}
 */
_.LoDashExplicitObjectWrapper.prototype.mapKeys = function(iteratee, thisArg) {};

/**
 * Creates an object with the same keys as object and values generated by running each own
 * enumerable property of object through iteratee. The iteratee function is bound to thisArg
 * and invoked with three arguments: (value, key, object).
 * 
 * If a property name is provided iteratee the created "_.property" style callback returns
 * the property value of the given element.
 * 
 * If a value is also provided for thisArg the creted "_.matchesProperty" style callback returns
 * true for elements that have a matching property value, else false;.
 * 
 * If an object is provided for iteratee the created "_.matches" style callback returns true
 * for elements that have the properties of the given object, else false.
 * 
 * @template T, TResult, TMapped
 * @param {!_.Dictionary<T>|T} obj
 * @param {!_.ObjectIterator<T, TResult>|!_.Dictionary<T>|string|!_.ObjectIterator<?, ?>} callback_or_where_or_pluck
 * @param {?=} thisArg
 * @return {!_.Dictionary<TResult>|!_.Dictionary<boolean>|TMapped|T}
 */
_.LoDashStatic.prototype.mapValues = function(obj, callback_or_where_or_pluck, thisArg) {};

/**
 * @see _.mapValues
 * TValue is the type of the property values of T.
 * TResult is the type output by the ObjectIterator function
 * @see _.mapValues
 * TResult is the type of the property specified by pluck.
 * T should be a Dictionary<Dictionary<TResult>>
 * @see _.mapValues
 * TResult is the type of the properties on the object specified by pluck.
 * T should be a Dictionary<Dictionary<Dictionary<TResult>>>
 * @see _.mapValues
 * TResult is the type of the properties of each object in the values of T
 * T should be a Dictionary<Dictionary<TResult>>
 * @template TValue, TResult
 * @param {!_.ObjectIterator<TValue, TResult>|string|!_.Dictionary<TResult>} callback_or_pluck_or_where
 * @param {?|!_.Dictionary<TResult>=} thisArg_or_where
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>|!_.LoDashImplicitArrayWrapper<!_.Dictionary<boolean>>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapper.prototype.mapValues = function(callback_or_pluck_or_where, thisArg_or_where) {};
/**
 * @record
 * @struct
 */
_.MergeCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Recursively merges own enumerable properties of the source object(s), that don’t resolve to undefined into
 * the destination object. Subsequent sources overwrite property assignments of previous sources. If customizer
 * is provided it’s invoked to produce the merged values of the destination and source properties. If
 * customizer returns undefined merging is handled by the method instead. The customizer is bound to thisArg
 * and invoked with five arguments: (objectValue, sourceValue, key, object, source).
 * 
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object The destination object.
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs The source objects.
 * @return {?|TResult} Returns object.
 */
_.LoDashStatic.prototype.merge = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.merge = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.functions
 * @template T
 * @param {?} object
 * @return {!Array<string>}
 */
_.LoDashStatic.prototype.methods = function(object) {};

/**
 * @see _.functions
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.methods = function() {};

/**
 * @see _.functions
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.methods = function() {};

/**
 * The opposite of _.pick; this method creates an object composed of the own and inherited enumerable
 * properties of object that are not omitted.
 * 
 * @see _.omit
 * @template TResult, T
 * @param {T} object The source object.
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate The function invoked per iteration or property names to omit, specified as individual
 * property names or arrays of property names.
 * @return {TResult} Returns the new object.
 */
_.LoDashStatic.prototype.omit = function(object, predicate) {};

/**
 * @see _.omit
 * @see _.omit
 * @template TResult
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.omit = function(predicate) {};

/**
 * @see _.omit
 * @see _.omit
 * @template TResult
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.omit = function(predicate) {};

/**
 * Creates a two dimensional array of the key-value pairs for object, e.g. [[key1, value1], [key2, value2]].
 * 
 * @template T, TResult
 * @param {T=} object The object to query.
 * @return {!Array<!Array<?>>|!Array<!Array<TResult>>} Returns the new array of key-value pairs.
 */
_.LoDashStatic.prototype.pairs = function(object) {};

/**
 * @see _.pairs
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashImplicitObjectWrapper.prototype.pairs = function() {};

/**
 * @see _.pairs
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashExplicitObjectWrapper.prototype.pairs = function() {};

/**
 * Creates an object composed of the picked object properties. Property names may be specified as individual
 * arguments or as arrays of property names. If predicate is provided it’s invoked for each property of object
 * picking the properties predicate returns truthy for. The predicate is bound to thisArg and invoked with
 * three arguments: (value, key, object).
 * 
 * @see _.pick
 * @template TResult, T
 * @param {T} object The source object.
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate The function invoked per iteration or property names to pick, specified as individual
 * property names or arrays of property names.
 * @return {TResult} Returns the new object.
 */
_.LoDashStatic.prototype.pick = function(object, predicate) {};

/**
 * @see _.pick
 * @see _.pick
 * @template TResult
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.pick = function(predicate) {};

/**
 * @see _.pick
 * @see _.pick
 * @template TResult
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.pick = function(predicate) {};

/**
 * This method is like _.get except that if the resolved value is a function it’s invoked with the this binding
 * of its parent object and its result is returned.
 * 
 * @see _.result
 * @template TObject, TResult
 * @param {TObject|?} object The object to query.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to resolve.
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue The value returned if the resolved value is undefined.
 * @return {TResult} Returns the resolved value.
 */
_.LoDashStatic.prototype.result = function(object, path, defaultValue) {};

/**
 * @see _.result
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.result = function(path, defaultValue) {};

/**
 * Sets the property value of path on object. If a portion of path does not exist it’s created.
 * 
 * @see _.set
 * @see _.set
 * @template TResult, V, O
 * @param {!Object|O} object The object to augment.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to set.
 * @param {?|V} value The value to set.
 * @return {TResult} Returns object.
 */
_.LoDashStatic.prototype.set = function(object, path, value) {};

/**
 * @see _.set
 * @see _.set
 * @template TResult, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|V} value
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.set = function(path, value) {};

/**
 * @see _.set
 * @see _.set
 * @template TResult, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|V} value
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.set = function(path, value) {};

/**
 * An alternative to _.reduce; this method transforms object to a new accumulator object which is the result of
 * running each of its own enumerable properties through iteratee, with each invocation potentially mutating
 * the accumulator object. The iteratee is bound to thisArg and invoked with four arguments: (accumulator,
 * value, key, object). Iteratee functions may exit iteration early by explicitly returning false.
 * 
 * @see _.transform
 * @see _.transform
 * @see _.transform
 * @template T, TResult
 * @param {!Array<T>|!_.Dictionary<T>} object The object to iterate over.
 * @param {!_.MemoVoidArrayIterator<T, !Array<TResult>>|!_.MemoVoidArrayIterator<T, !_.Dictionary<TResult>>|!_.MemoVoidDictionaryIterator<T, !_.Dictionary<TResult>>|!_.MemoVoidDictionaryIterator<T, !Array<TResult>>=} iteratee The function invoked per iteration.
 * @param {!Array<TResult>|!_.Dictionary<TResult>=} accumulator The custom accumulator value.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<TResult>|!_.Dictionary<TResult>} Returns the accumulated value.
 */
_.LoDashStatic.prototype.transform = function(object, iteratee, accumulator, thisArg) {};

/**
 * @see _.transform
 * @see _.transform
 * @template TResult
 * @param {!_.MemoVoidArrayIterator<T, !Array<TResult>>|!_.MemoVoidArrayIterator<T, !_.Dictionary<TResult>>=} iteratee
 * @param {!Array<TResult>|!_.Dictionary<TResult>=} accumulator
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>}
 */
_.LoDashImplicitArrayWrapper.prototype.transform = function(iteratee, accumulator, thisArg) {};

/**
 * @see _.transform
 * @see _.transform
 * @template T, TResult
 * @param {!_.MemoVoidDictionaryIterator<T, !_.Dictionary<TResult>>|!_.MemoVoidDictionaryIterator<T, !Array<TResult>>=} iteratee
 * @param {!_.Dictionary<TResult>|!Array<TResult>=} accumulator
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>|!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.transform = function(iteratee, accumulator, thisArg) {};

/**
 * Creates an array of the own enumerable property values of object.
 * 
 * @template T
 * @param {?=} object The object to query.
 * @return {!Array<T>} Returns an array of property values.
 */
_.LoDashStatic.prototype.values = function(object) {};

/**
 * @see _.values
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.values = function() {};

/**
 * @see _.values
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.values = function() {};

/**
 * Creates an array of the own and inherited enumerable property values of object.
 * 
 * @template T
 * @param {?=} object The object to query.
 * @return {!Array<T>} Returns the array of property values.
 */
_.LoDashStatic.prototype.valuesIn = function(object) {};

/**
 * @see _.valuesIn
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.valuesIn = function() {};

/**
 * @see _.valuesIn
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.valuesIn = function() {};

/**
 * Converts string to camel case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the camel cased string.
 */
_.LoDashStatic.prototype.camelCase = function(string) {};

/**
 * @see _.camelCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.camelCase = function() {};

/**
 * @see _.camelCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.camelCase = function() {};

/**
 * @param {string=} string
 * @return {string}
 */
_.LoDashStatic.prototype.capitalize = function(string) {};

/**
 * @see _.capitalize
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.capitalize = function() {};

/**
 * @see _.capitalize
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.capitalize = function() {};

/**
 * Deburrs string by converting latin-1 supplementary letters to basic latin letters and removing combining
 * diacritical marks.
 * 
 * @param {string=} string The string to deburr.
 * @return {string} Returns the deburred string.
 */
_.LoDashStatic.prototype.deburr = function(string) {};

/**
 * @see _.deburr
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.deburr = function() {};

/**
 * @see _.deburr
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.deburr = function() {};

/**
 * Checks if string ends with the given target string.
 * 
 * @param {string=} string The string to search.
 * @param {string=} target The string to search for.
 * @param {number=} position The position to search from.
 * @return {boolean} Returns true if string ends with target, else false.
 */
_.LoDashStatic.prototype.endsWith = function(string, target, position) {};

/**
 * @see _.endsWith
 * @param {string=} target
 * @param {number=} position
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.endsWith = function(target, position) {};

/**
 * @see _.endsWith
 * @param {string=} target
 * @param {number=} position
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.endsWith = function(target, position) {};

/**
 * Converts the characters "&", "<", ">", '"', "'", and "`", in string to their corresponding HTML entities.
 * 
 * Note: No other characters are escaped. To escape additional characters use a third-party library like he.
 * 
 * Though the ">" character is escaped for symmetry, characters like ">" and "/" don’t need escaping in HTML
 * and have no special meaning unless they're part of a tag or unquoted attribute value. See Mathias Bynens’s
 * article (under "semi-related fun fact") for more details.
 * 
 * Backticks are escaped because in Internet Explorer < 9, they can break out of attribute values or HTML
 * comments. See #59, #102, #108, and #133 of the HTML5 Security Cheatsheet for more details.
 * 
 * When working with HTML you should always quote attribute values to reduce XSS vectors.
 * 
 * @param {string=} string The string to escape.
 * @return {string} Returns the escaped string.
 */
_.LoDashStatic.prototype.escape = function(string) {};

/**
 * @see _.escape
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.escape = function() {};

/**
 * @see _.escape
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.escape = function() {};

/**
 * Escapes the RegExp special characters "\", "/", "^", "$", ".", "|", "?", "*", "+", "(", ")", "[", "]",
 * "{" and "}" in string.
 * 
 * @param {string=} string The string to escape.
 * @return {string} Returns the escaped string.
 */
_.LoDashStatic.prototype.escapeRegExp = function(string) {};

/**
 * @see _.escapeRegExp
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.escapeRegExp = function() {};

/**
 * @see _.escapeRegExp
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.escapeRegExp = function() {};

/**
 * Converts string to kebab case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the kebab cased string.
 */
_.LoDashStatic.prototype.kebabCase = function(string) {};

/**
 * @see _.kebabCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.kebabCase = function() {};

/**
 * @see _.kebabCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.kebabCase = function() {};

/**
 * Pads string on the left and right sides if it’s shorter than length. Padding characters are truncated if
 * they can’t be evenly divided by length.
 * 
 * @param {string=} string The string to pad.
 * @param {number=} length The padding length.
 * @param {string=} chars The string used as padding.
 * @return {string} Returns the padded string.
 */
_.LoDashStatic.prototype.pad = function(string, length, chars) {};

/**
 * @see _.pad
 * @param {number=} length
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.pad = function(length, chars) {};

/**
 * @see _.pad
 * @param {number=} length
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.pad = function(length, chars) {};

/**
 * Pads string on the left side if it’s shorter than length. Padding characters are truncated if they exceed
 * length.
 * 
 * @param {string=} string The string to pad.
 * @param {number=} length The padding length.
 * @param {string=} chars The string used as padding.
 * @return {string} Returns the padded string.
 */
_.LoDashStatic.prototype.padLeft = function(string, length, chars) {};

/**
 * @see _.padLeft
 * @param {number=} length
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.padLeft = function(length, chars) {};

/**
 * @see _.padLeft
 * @param {number=} length
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.padLeft = function(length, chars) {};

/**
 * Pads string on the right side if it’s shorter than length. Padding characters are truncated if they exceed
 * length.
 * 
 * @param {string=} string The string to pad.
 * @param {number=} length The padding length.
 * @param {string=} chars The string used as padding.
 * @return {string} Returns the padded string.
 */
_.LoDashStatic.prototype.padRight = function(string, length, chars) {};

/**
 * @see _.padRight
 * @param {number=} length
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.padRight = function(length, chars) {};

/**
 * @see _.padRight
 * @param {number=} length
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.padRight = function(length, chars) {};

/**
 * Converts string to an integer of the specified radix. If radix is undefined or 0, a radix of 10 is used
 * unless value is a hexadecimal, in which case a radix of 16 is used.
 * 
 * Note: This method aligns with the ES5 implementation of parseInt.
 * 
 * @param {string} string The string to convert.
 * @param {number=} radix The radix to interpret value by.
 * @return {number} Returns the converted integer.
 */
_.LoDashStatic.prototype.parseInt = function(string, radix) {};

/**
 * @see _.parseInt
 * @param {number=} radix
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.parseInt = function(radix) {};

/**
 * @see _.parseInt
 * @param {number=} radix
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.parseInt = function(radix) {};

/**
 * Repeats the given string n times.
 * 
 * @param {string=} string The string to repeat.
 * @param {number=} n The number of times to repeat the string.
 * @return {string} Returns the repeated string.
 */
_.LoDashStatic.prototype.repeat = function(string, n) {};

/**
 * @see _.repeat
 * @param {number=} n
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.repeat = function(n) {};

/**
 * @see _.repeat
 * @param {number=} n
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.repeat = function(n) {};

/**
 * Converts string to snake case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the snake cased string.
 */
_.LoDashStatic.prototype.snakeCase = function(string) {};

/**
 * @see _.snakeCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.snakeCase = function() {};

/**
 * @see _.snakeCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.snakeCase = function() {};

/**
 * Splits string by separator.
 * 
 * Note: This method is based on String#split.
 * 
 * @param {(string|!RegExp)=} separator The separator pattern to split by.
 * @param {number=} limit The length to truncate results to.
 * @return {!_.LoDashImplicitArrayWrapper<string>} Returns the new array with the terms splitted.
 */
_.LoDashImplicitWrapper.prototype.split = function(separator, limit) {};

/**
 * @see _.split
 * @param {(string|!RegExp)=} separator
 * @param {number=} limit
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.split = function(separator, limit) {};

/**
 * Converts string to start case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the start cased string.
 */
_.LoDashStatic.prototype.startCase = function(string) {};

/**
 * @see _.startCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.startCase = function() {};

/**
 * @see _.startCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.startCase = function() {};

/**
 * Checks if string starts with the given target string.
 * 
 * @param {string=} string The string to search.
 * @param {string=} target The string to search for.
 * @param {number=} position The position to search from.
 * @return {boolean} Returns true if string starts with target, else false.
 */
_.LoDashStatic.prototype.startsWith = function(string, target, position) {};

/**
 * @see _.startsWith
 * @param {string=} target
 * @param {number=} position
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.startsWith = function(target, position) {};

/**
 * @see _.startsWith
 * @param {string=} target
 * @param {number=} position
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.startsWith = function(target, position) {};
/**
 * @extends {_.TemplateSettings}
 * @record
 * @struct
 */
_.TemplateOptions = function() {};
 /** @type {string} */
_.TemplateOptions.prototype.sourceURL;
/**
 * @record
 * @struct
 */
_.TemplateExecutor = function() {};

/* TODO: CallSignature: _ */
 /** @type {string} */
_.TemplateExecutor.prototype.source;

/**
 * Creates a compiled template function that can interpolate data properties in "interpolate" delimiters,
 * HTML-escape interpolated data properties in "escape" delimiters, and execute JavaScript in "evaluate"
 * delimiters. Data properties may be accessed as free variables in the template. If a setting object is
 * provided it takes precedence over _.templateSettings values.
 * 
 * Note: In the development build _.template utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) for easier
 * debugging.
 * 
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 * 
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 * 
 * @param {string} string The template string.
 * @param {!_.TemplateOptions=} options The options object.
 * @return {!_.TemplateExecutor} Returns the compiled template function.
 */
_.LoDashStatic.prototype.template = function(string, options) {};

/**
 * @see _.template
 * @param {!_.TemplateOptions=} options
 * @return {!_.TemplateExecutor}
 */
_.LoDashImplicitWrapper.prototype.template = function(options) {};

/**
 * @see _.template
 * @param {!_.TemplateOptions=} options
 * @return {!_.LoDashExplicitObjectWrapper<!_.TemplateExecutor>}
 */
_.LoDashExplicitWrapper.prototype.template = function(options) {};

/**
 * Removes leading and trailing whitespace or specified characters from string.
 * 
 * @param {string=} string The string to trim.
 * @param {string=} chars The characters to trim.
 * @return {string} Returns the trimmed string.
 */
_.LoDashStatic.prototype.trim = function(string, chars) {};

/**
 * @see _.trim
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trim = function(chars) {};

/**
 * @see _.trim
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trim = function(chars) {};

/**
 * Removes leading whitespace or specified characters from string.
 * 
 * @param {string=} string The string to trim.
 * @param {string=} chars The characters to trim.
 * @return {string} Returns the trimmed string.
 */
_.LoDashStatic.prototype.trimLeft = function(string, chars) {};

/**
 * @see _.trimLeft
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trimLeft = function(chars) {};

/**
 * @see _.trimLeft
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trimLeft = function(chars) {};

/**
 * Removes trailing whitespace or specified characters from string.
 * 
 * @param {string=} string The string to trim.
 * @param {string=} chars The characters to trim.
 * @return {string} Returns the trimmed string.
 */
_.LoDashStatic.prototype.trimRight = function(string, chars) {};

/**
 * @see _.trimRight
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trimRight = function(chars) {};

/**
 * @see _.trimRight
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trimRight = function(chars) {};
/**
 * @record
 * @struct
 */
_.TruncOptions = function() {};
 /** @type {number} */
_.TruncOptions.prototype.length;
 /** @type {string} */
_.TruncOptions.prototype.omission;
 /** @type {(string|!RegExp)} */
_.TruncOptions.prototype.separator;

/**
 * Truncates string if it’s longer than the given maximum string length. The last characters of the truncated
 * string are replaced with the omission string which defaults to "…".
 * 
 * @param {string=} string The string to truncate.
 * @param {(number|!_.TruncOptions)=} options The options object or maximum string length.
 * @return {string} Returns the truncated string.
 */
_.LoDashStatic.prototype.trunc = function(string, options) {};

/**
 * @see _.trunc
 * @param {(number|!_.TruncOptions)=} options
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trunc = function(options) {};

/**
 * @see _.trunc
 * @param {(number|!_.TruncOptions)=} options
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trunc = function(options) {};

/**
 * The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;, and &#96;
 * in string to their corresponding characters.
 * 
 * @param {string=} string The string to unescape.
 * @return {string} Returns the unescaped string.
 */
_.LoDashStatic.prototype.unescape = function(string) {};

/**
 * @see _.unescape
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.unescape = function() {};

/**
 * @see _.unescape
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.unescape = function() {};

/**
 * Splits string into an array of its words.
 * 
 * @param {string=} string The string to inspect.
 * @param {(string|!RegExp)=} pattern The pattern to match words.
 * @return {!Array<string>} Returns the words of string.
 */
_.LoDashStatic.prototype.words = function(string, pattern) {};

/**
 * @see _.words
 * @param {(string|!RegExp)=} pattern
 * @return {!Array<string>}
 */
_.LoDashImplicitWrapper.prototype.words = function(pattern) {};

/**
 * @see _.words
 * @param {(string|!RegExp)=} pattern
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.words = function(pattern) {};

/**
 * Attempts to invoke func, returning either the result or the caught error object. Any additional arguments
 * are provided to func when it’s invoked.
 * 
 * @template TResult
 * @param {function(!Array<?>): TResult} func The function to attempt.
 * @param {...?} args
 * @return {(!Error|TResult)} Returns the func result or error object.
 */
_.LoDashStatic.prototype.attempt = function(func, args) {};

/**
 * @see _.attempt
 * @template TResult
 * @param {...?} args
 * @return {(!Error|TResult)}
 */
_.LoDashImplicitObjectWrapper.prototype.attempt = function(args) {};

/**
 * @see _.attempt
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<(!Error|TResult)>}
 */
_.LoDashExplicitObjectWrapper.prototype.attempt = function(args) {};

/**
 * Creates a function that invokes func with the this binding of thisArg and arguments of the created function.
 * If func is a property name the created callback returns the property value for a given element. If func is
 * an object the created callback returns true for elements that contain the equivalent object properties,
 * otherwise it returns false.
 * 
 * \@result Returns the callback.
 * @see _.callback
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {!Function|string|!Object=} func The value to convert to a callback.
 * @param {?=} thisArg The this binding of func.
 * @return {function(!Array<?>): TResult|function(?): TResult|function(?): boolean|function(TResult): TResult}
 */
_.LoDashStatic.prototype.callback = function(func, thisArg) {};

/**
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitWrapper.prototype.callback = function(thisArg) {};

/**
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<function(?): boolean>|!_.LoDashImplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.callback = function(thisArg) {};

/**
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitWrapper.prototype.callback = function(thisArg) {};

/**
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<function(?): boolean>|!_.LoDashExplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.callback = function(thisArg) {};

/**
 * Creates a function that returns value.
 * 
 * @template T
 * @param {T} value The value to return from the new function.
 * @return {function(): T} Returns the new function.
 */
_.LoDashStatic.prototype.constant = function(value) {};

/**
 * @see _.constant
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(): TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.constant = function() {};

/**
 * @see _.constant
 * @template TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(): TResult>}
 */
_.LoDashExplicitWrapperBase.prototype.constant = function() {};

/**
 * This method returns the first argument provided to it.
 * 
 * @template T
 * @param {T=} value Any value.
 * @return {T} Returns value.
 */
_.LoDashStatic.prototype.identity = function(value) {};

/**
 * @see _.identity
 * @return {T}
 */
_.LoDashImplicitWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {!Array<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {!_.LoDashExplicitWrapper}
 */
_.LoDashExplicitWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.identity = function() {};

/**
 * @see _.callback
 * @see _.callback
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {!Function|string|!Object=} func
 * @param {?=} thisArg
 * @return {function(!Array<?>): TResult|function(?): TResult|function(?): boolean|function(TResult): TResult}
 */
_.LoDashStatic.prototype.iteratee = function(func, thisArg) {};

/**
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitWrapper.prototype.iteratee = function(thisArg) {};

/**
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<function(?): boolean>|!_.LoDashImplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.iteratee = function(thisArg) {};

/**
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitWrapper.prototype.iteratee = function(thisArg) {};

/**
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<function(?): boolean>|!_.LoDashExplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.iteratee = function(thisArg) {};

/**
 * Creates a function that performs a deep comparison between a given object and source, returning true if the
 * given object has equivalent property values, else false.
 * 
 * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and
 * strings. Objects are compared by their own, not inherited, enumerable properties. For comparing a single own
 * or inherited property value see _.matchesProperty.
 * 
 * @see _.matches
 * @template T, V
 * @param {T} source The object of property values to match.
 * @return {function(?): boolean|function(V): boolean} Returns the new function.
 */
_.LoDashStatic.prototype.matches = function(source) {};

/**
 * @see _.matches
 * @template V
 * @return {!_.LoDashImplicitObjectWrapper<function(V): boolean>}
 */
_.LoDashImplicitWrapperBase.prototype.matches = function() {};

/**
 * @see _.matches
 * @template V
 * @return {!_.LoDashExplicitObjectWrapper<function(V): boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.matches = function() {};

/**
 * Creates a function that compares the property value of path on a given object to value.
 * 
 * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and
 * strings. Objects are compared by their own, not inherited, enumerable properties.
 * 
 * @see _.matchesProperty
 * @template T, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to get.
 * @param {T} srcValue The value to match.
 * @return {function(?): boolean|function(V): boolean} Returns the new function.
 */
_.LoDashStatic.prototype.matchesProperty = function(path, srcValue) {};

/**
 * @see _.matchesProperty
 * @see _.matchesProperty
 * @template SrcValue, Value
 * @param {SrcValue} srcValue
 * @return {!_.LoDashImplicitObjectWrapper<function(?): boolean>|!_.LoDashImplicitObjectWrapper<function(Value): boolean>}
 */
_.LoDashImplicitWrapperBase.prototype.matchesProperty = function(srcValue) {};

/**
 * @see _.matchesProperty
 * @see _.matchesProperty
 * @template SrcValue, Value
 * @param {SrcValue} srcValue
 * @return {!_.LoDashExplicitObjectWrapper<function(?): boolean>|!_.LoDashExplicitObjectWrapper<function(Value): boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.matchesProperty = function(srcValue) {};

/**
 * Creates a function that invokes the method at path on a given object. Any additional arguments are provided
 * to the invoked method.
 * 
 * @see _.method
 * @template TObject, TResult
 * @param {(string|!Array<!_.StringRepresentable>)} path The path of the method to invoke.
 * @param {...?} args The arguments to invoke the method with.
 * @return {function(TObject): TResult|function(?): TResult} Returns the new function.
 */
_.LoDashStatic.prototype.method = function(path, args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitObjectWrapper<function(TObject): TResult>|!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitWrapper.prototype.method = function(args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitObjectWrapper<function(TObject): TResult>|!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.method = function(args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<function(TObject): TResult>|!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitWrapper.prototype.method = function(args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<function(TObject): TResult>|!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.method = function(args) {};

/**
 * The opposite of _.method; this method creates a function that invokes the method at a given path on object.
 * Any additional arguments are provided to the invoked method.
 * 
 * @see _.methodOf
 * @template TObject, TResult
 * @param {TObject|!Object} object The object to query.
 * @param {...?} args The arguments to invoke the method with.
 * @return {function((!_.StringRepresentable|!Array<!_.StringRepresentable>)): TResult} Returns the new function.
 */
_.LoDashStatic.prototype.methodOf = function(object, args) {};

/**
 * @see _.methodOf
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitObjectWrapper<function((!_.StringRepresentable|!Array<!_.StringRepresentable>)): TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.methodOf = function(args) {};

/**
 * @see _.methodOf
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<function((!_.StringRepresentable|!Array<!_.StringRepresentable>)): TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.methodOf = function(args) {};
/**
 * @record
 * @struct
 */
_.MixinOptions = function() {};
 /** @type {boolean} */
_.MixinOptions.prototype.chain;

/**
 * Adds all own enumerable function properties of a source object to the destination object. If object is a
 * function then methods are added to its prototype as well.
 * 
 * Note: Use _.runInContext to create a pristine lodash function to avoid conflicts caused by modifying
 * the original.
 * 
 * @see _.mixin
 * @template TResult, TObject
 * @param {TObject|!_.Dictionary<!Function>} object_or_source The destination object.
 * @param {!_.Dictionary<!Function>|!_.MixinOptions=} source_or_options The object of functions to add.
 * @param {!_.MixinOptions=} options The options object.
 * @return {TResult} Returns object.
 */
_.LoDashStatic.prototype.mixin = function(object_or_source, source_or_options, options) {};

/**
 * @see _.mixin
 * @see _.mixin
 * @template TResult
 * @param {!_.Dictionary<!Function>|!_.MixinOptions=} source_or_options
 * @param {!_.MixinOptions=} options
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.mixin = function(source_or_options, options) {};

/**
 * @see _.mixin
 * @see _.mixin
 * @template TResult
 * @param {!_.Dictionary<!Function>|!_.MixinOptions=} source_or_options
 * @param {!_.MixinOptions=} options
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.mixin = function(source_or_options, options) {};

/**
 * Reverts the _ variable to its previous value and returns a reference to the lodash function.
 * 
 * @return {!_.LoDashStatic} Returns the lodash function.
 */
_.LoDashStatic.prototype.noConflict = function() {};

/**
 * @see _.noConflict
 * @return {!_.LoDashStatic}
 */
_.LoDashImplicitWrapperBase.prototype.noConflict = function() {};

/**
 * @see _.noConflict
 * @return {!_.LoDashExplicitObjectWrapper<!_.LoDashStatic>}
 */
_.LoDashExplicitWrapperBase.prototype.noConflict = function() {};

/**
 * A no-operation function that returns undefined regardless of the arguments it receives.
 * 
 * @param {...?} args
 * @return {void} undefined
 */
_.LoDashStatic.prototype.noop = function(args) {};

/**
 * @see _.noop
 * @param {...?} args
 * @return {void}
 */
_.LoDashImplicitWrapperBase.prototype.noop = function(args) {};

/**
 * @see _.noop
 * @param {...?} args
 * @return {!_.LoDashExplicitWrapper<void>}
 */
_.LoDashExplicitWrapperBase.prototype.noop = function(args) {};

/**
 * Creates a function that returns the property value at path on a given object.
 * 
 * @template TObj, TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to get.
 * @return {function(TObj): TResult} Returns the new function.
 */
_.LoDashStatic.prototype.property = function(path) {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashImplicitWrapper.prototype.property = function() {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.property = function() {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashExplicitWrapper.prototype.property = function() {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.property = function() {};

/**
 * The opposite of _.property; this method creates a function that returns the property value at a given path
 * on object.
 * 
 * @template T
 * @param {T} object The object to query.
 * @return {function((string|!Array<string>)): ?} Returns the new function.
 */
_.LoDashStatic.prototype.propertyOf = function(object) {};

/**
 * @see _.propertyOf
 * @return {!_.LoDashImplicitObjectWrapper<function((string|!Array<string>)): ?>}
 */
_.LoDashImplicitObjectWrapper.prototype.propertyOf = function() {};

/**
 * @see _.propertyOf
 * @return {!_.LoDashExplicitObjectWrapper<function((string|!Array<string>)): ?>}
 */
_.LoDashExplicitObjectWrapper.prototype.propertyOf = function() {};

/**
 * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.
 * If end is not specified it’s set to start with start then set to 0. If end is less than start a zero-length
 * range is created unless a negative step is specified.
 * 
 * @see _.range
 * @param {number} start_or_end The start of the range.
 * @param {number=} end_or_step The end of the range.
 * @param {number=} step The value to increment or decrement by.
 * @return {!Array<number>} Returns a new range array.
 */
_.LoDashStatic.prototype.range = function(start_or_end, end_or_step, step) {};

/**
 * @see _.range
 * @param {number=} end
 * @param {number=} step
 * @return {!_.LoDashImplicitArrayWrapper<number>}
 */
_.LoDashImplicitWrapper.prototype.range = function(end, step) {};

/**
 * @see _.range
 * @param {number=} end
 * @param {number=} step
 * @return {!_.LoDashExplicitArrayWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.range = function(end, step) {};

/**
 * Create a new pristine lodash function using the given context object.
 * 
 * @param {!Object=} context The context object.
 * @return {!_.LoDashStatic} Returns a new lodash function.
 */
_.LoDashStatic.prototype.runInContext = function(context) {};

/**
 * @see _.runInContext
 * @return {!_.LoDashStatic}
 */
_.LoDashImplicitObjectWrapper.prototype.runInContext = function() {};

/**
 * Invokes the iteratee function n times, returning an array of the results of each invocation. The iteratee is
 * bound to thisArg and invoked with one argument; (index).
 * 
 * @see _.times
 * @template TResult
 * @param {number} n The number of times to invoke iteratee.
 * @param {function(number): TResult=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<TResult>|!Array<number>} Returns the array of results.
 */
_.LoDashStatic.prototype.times = function(n, iteratee, thisArg) {};

/**
 * @see _.times
 * @see _.times
 * @template TResult
 * @param {function(number): TResult=} iteratee
 * @param {?=} thisArgs
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<number>}
 */
_.LoDashImplicitWrapper.prototype.times = function(iteratee, thisArgs) {};

/**
 * @see _.times
 * @see _.times
 * @template TResult
 * @param {function(number): TResult=} iteratee
 * @param {?=} thisArgs
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.times = function(iteratee, thisArgs) {};

/**
 * Generates a unique ID. If prefix is provided the ID is appended to it.
 * 
 * @param {string=} prefix The value to prefix the ID with.
 * @return {string} Returns the unique ID.
 */
_.LoDashStatic.prototype.uniqueId = function(prefix) {};

/**
 * @see _.uniqueId
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.uniqueId = function() {};

/**
 * @see _.uniqueId
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.uniqueId = function() {};
/**
 * @record
 * @struct
 */
_.ListIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.DictionaryIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.NumericDictionaryIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.ObjectIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.StringIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.MemoVoidIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.MemoIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.MemoVoidArrayIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.MemoVoidDictionaryIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.List = function() {};

/* TODO: IndexSignature: _ */
 /** @type {number} */
_.List.prototype.length;
/**
 * @record
 * @struct
 */
_.Dictionary = function() {};

/* TODO: IndexSignature: _ */
/**
 * @record
 * @struct
 */
_.NumericDictionary = function() {};

/* TODO: IndexSignature: _ */
/**
 * @record
 * @struct
 */
_.StringRepresentable = function() {};

/**
 * @return {string}
 */
_.StringRepresentable.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
_.Cancelable = function() {};

/**
 * @return {void}
 */
_.Cancelable.prototype.cancel = function() {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "lodash"
/** @const */
tsickle_declare_module.lodash = {};

/* TODO: ExportAssignment in tsickle_declare_module.lodash */
