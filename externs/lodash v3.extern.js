/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/lodash v3/index.d.ts:
 /** @type {!_.LoDashStatic} */
var _;
/**
 * @record
 * @struct
 */
_.LoDashStatic = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {string} */
_.LoDashStatic.prototype.VERSION;
 /** @type {!_.Support} */
_.LoDashStatic.prototype.support;
 /** @type {!_.TemplateSettings} */
_.LoDashStatic.prototype.templateSettings;
/**
 * @record
 * @struct
 */
_.TemplateSettings = function() {};
 /** @type {!RegExp} */
_.TemplateSettings.prototype.escape;
 /** @type {!RegExp} */
_.TemplateSettings.prototype.evaluate;
 /** @type {!_.Dictionary<?>} */
_.TemplateSettings.prototype.imports;
 /** @type {!RegExp} */
_.TemplateSettings.prototype.interpolate;
 /** @type {string} */
_.TemplateSettings.prototype.variable;
/**
 * @record
 * @struct
 */
_.MapCache = function() {};

/**
 * Removes `key` and its value from the cache.
 * @param {string} key The key of the value to remove.
 * @return {boolean} Returns `true` if the entry was removed successfully, else `false`.
 */
_.MapCache.prototype.delete = function(key) {};

/**
 * Gets the cached value for `key`.
 * @param {string} key The key of the value to get.
 * @return {?} Returns the cached value.
 */
_.MapCache.prototype.get = function(key) {};

/**
 * Checks if a cached value for `key` exists.
 * @param {string} key The key of the entry to check.
 * @return {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
_.MapCache.prototype.has = function(key) {};

/**
 * Sets `value` to `key` of the cache.
 * @param {string} key The key of the value to cache.
 * @param {?} value The value to cache.
 * @return {!_.Dictionary<?>} Returns the cache object.
 */
_.MapCache.prototype.set = function(key, value) {};
/**
 * @record
 * @struct
 */
_.Support = function() {};
 /** @type {boolean} */
_.Support.prototype.argsClass;
 /** @type {boolean} */
_.Support.prototype.argsObject;
 /** @type {boolean} */
_.Support.prototype.enumErrorProps;
 /** @type {boolean} */
_.Support.prototype.enumPrototypes;
 /** @type {boolean} */
_.Support.prototype.fastBind;
 /** @type {boolean} */
_.Support.prototype.funcDecomp;
 /** @type {boolean} */
_.Support.prototype.funcNames;
 /** @type {boolean} */
_.Support.prototype.nonEnumArgs;
 /** @type {boolean} */
_.Support.prototype.nonEnumShadows;
 /** @type {boolean} */
_.Support.prototype.ownLast;
 /** @type {boolean} */
_.Support.prototype.spliceObjects;
 /** @type {boolean} */
_.Support.prototype.unindexedChars;
/**
 * @record
 * @struct
 */
_.LoDashWrapperBase = function() {};
/**
 * @extends {_.LoDashWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitWrapperBase = function() {};
/**
 * @extends {_.LoDashWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitWrapperBase = function() {};
/**
 * @extends {_.LoDashImplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitWrapper = function() {};
/**
 * @extends {_.LoDashImplicitWrapper}
 * @record
 * @struct
 */
_.LoDashImplicitStringWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapper}
 * @record
 * @struct
 */
_.LoDashExplicitStringWrapper = function() {};
/**
 * @extends {_.LoDashImplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitObjectWrapper = function() {};
/**
 * @extends {_.LoDashExplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitObjectWrapper = function() {};
/**
 * @extends {_.LoDashImplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashImplicitArrayWrapper = function() {};

/**
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.pop = function() {};

/**
 * @param {...T} items
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.push = function(items) {};

/**
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.shift = function() {};

/**
 * @param {function(T, T): number=} compareFn
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.sort = function(compareFn) {};

/**
 * @param {number} start
 * @param {number=} deleteCount
 * @param {...?} items
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.splice = function(start, deleteCount, items) {};

/**
 * @param {...T} items
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.unshift = function(items) {};
/**
 * @extends {_.LoDashExplicitWrapperBase}
 * @record
 * @struct
 */
_.LoDashExplicitArrayWrapper = function() {};
/**
 * @extends {_.LoDashImplicitArrayWrapper}
 * @record
 * @struct
 */
_.LoDashImplicitNumberArrayWrapper = function() {};
/**
 * @extends {_.LoDashExplicitArrayWrapper}
 * @record
 * @struct
 */
_.LoDashExplicitNumberArrayWrapper = function() {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {string}
 */
_.LoDashImplicitArrayWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {string}
 */
_.LoDashImplicitObjectWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitArrayWrapper.prototype.join = function(separator) {};

/**
 * @see _.join
 * @param {string=} separator
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.join = function(separator) {};

/**
 * Creates an array of elements split into groups the length of size. If collection canâ€™t be split evenly, the
 * final chunk will be the remaining elements.
 * 
 * @template T
 * @param {!_.List<T>} array The array to process.
 * @param {number=} size The length of each chunk.
 * @return {!Array<!Array<T>>} Returns the new array containing chunks.
 */
_.LoDashStatic.prototype.chunk = function(array, size) {};

/**
 * @see _.chunk
 * @param {number=} size
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.chunk = function(size) {};

/**
 * @see _.chunk
 * @template TResult
 * @param {number=} size
 * @return {!_.LoDashImplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashImplicitObjectWrapper.prototype.chunk = function(size) {};

/**
 * @see _.chunk
 * @param {number=} size
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.chunk = function(size) {};

/**
 * @see _.chunk
 * @template TResult
 * @param {number=} size
 * @return {!_.LoDashExplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashExplicitObjectWrapper.prototype.chunk = function(size) {};

/**
 * Creates an array with all falsey values removed. The values false, null, 0, "", undefined, and NaN are
 * falsey.
 * 
 * @template T
 * @param {!_.List<T>=} array The array to compact.
 * @return {!Array<T>} (Array) Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.compact = function(array) {};

/**
 * @see _.compact
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.compact = function() {};

/**
 * @see _.compact
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.compact = function() {};

/**
 * @see _.compact
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.compact = function() {};

/**
 * @see _.compact
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.compact = function() {};

/**
 * Creates an array of unique array values not included in the other provided arrays using SameValueZero for
 * equality comparisons.
 * 
 * @template T
 * @param {(!Array<T>|!_.List<T>)} array The array to inspect.
 * @param {...(!Array<T>|!_.List<T>)} values The arrays of values to exclude.
 * @return {!Array<T>} Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.difference = function(array, values) {};

/**
 * @see _.difference
 * @param {...(!Array<T>|!_.List<T>)} values
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.difference = function(values) {};

/**
 * @see _.difference
 * @template TValue
 * @param {...(!Array<TValue>|!_.List<TValue>)} values
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.difference = function(values) {};

/**
 * @see _.difference
 * @param {...(!Array<T>|!_.List<T>)} values
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.difference = function(values) {};

/**
 * @see _.difference
 * @template TValue
 * @param {...(!Array<TValue>|!_.List<TValue>)} values
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.difference = function(values) {};

/**
 * Creates a slice of array with n elements dropped from the beginning.
 * 
 * @template T
 * @param {(!Array<T>|!_.List<T>)} array The array to query.
 * @param {number=} n The number of elements to drop.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.drop = function(array, n) {};

/**
 * @see _.drop
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.drop = function(n) {};

/**
 * @see _.drop
 * @template T
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.drop = function(n) {};

/**
 * @see _.drop
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.drop = function(n) {};

/**
 * @see _.drop
 * @template T
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.drop = function(n) {};

/**
 * Creates a slice of array with n elements dropped from the end.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @param {number=} n The number of elements to drop.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.dropRight = function(array, n) {};

/**
 * @see _.dropRight
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.dropRight = function(n) {};

/**
 * @see _.dropRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.dropRight = function(n) {};

/**
 * @see _.dropRight
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.dropRight = function(n) {};

/**
 * @see _.dropRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.dropRight = function(n) {};

/**
 * Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate
 * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * match the properties of the given object, else false.
 * 
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TValue, TWhere
 * @param {!_.List<TValue>} array The array to query.
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.dropRightWhile = function(array, predicate, thisArg) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.dropRightWhile = function(predicate, thisArg) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.dropRightWhile = function(predicate, thisArg) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.dropRightWhile = function(predicate, thisArg) {};

/**
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @see _.dropRightWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.dropRightWhile = function(predicate, thisArg) {};

/**
 * Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate
 * returns falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TValue, TWhere
 * @param {!_.List<TValue>} array The array to query.
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.dropWhile = function(array, predicate, thisArg) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.dropWhile = function(predicate, thisArg) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.dropWhile = function(predicate, thisArg) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.dropWhile = function(predicate, thisArg) {};

/**
 * @see _.dropWhile
 * @see _.dropWhile
 * @see _.dropWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.dropWhile = function(predicate, thisArg) {};

/**
 * Fills elements of array with value from start up to, but not including, end.
 * 
 * Note: This method mutates array.
 * 
 * @see _.fill
 * @template T
 * @param {!Array<?>|!_.List<?>} array The array to fill.
 * @param {T} value The value to fill array with.
 * @param {number=} start The start position.
 * @param {number=} end The end position.
 * @return {!Array<T>|!_.List<T>} Returns array.
 */
_.LoDashStatic.prototype.fill = function(array, value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.fill = function(value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashImplicitObjectWrapper<!_.List<T>>}
 */
_.LoDashImplicitObjectWrapper.prototype.fill = function(value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapper.prototype.fill = function(value, start, end) {};

/**
 * @see _.fill
 * @template T
 * @param {T} value
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashExplicitObjectWrapper<!_.List<T>>}
 */
_.LoDashExplicitObjectWrapper.prototype.fill = function(value, start, end) {};

/**
 * This method is like _.find except that it returns the index of the first element predicate returns truthy
 * for instead of the element itself.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findIndex
 * @see _.findIndex
 * @template T, W
 * @param {!_.List<T>} array The array to search.
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {number} Returns the index of the found element, else -1.
 */
_.LoDashStatic.prototype.findIndex = function(array, predicate, thisArg) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.findIndex = function(predicate, thisArg) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.findIndex = function(predicate, thisArg) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.findIndex = function(predicate, thisArg) {};

/**
 * @see _.findIndex
 * @see _.findIndex
 * @see _.findIndex
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.findIndex = function(predicate, thisArg) {};

/**
 * This method is like _.findIndex except that it iterates over elements of collection from right to left.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template T, W
 * @param {!_.List<T>} array The array to search.
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The function invoked per iteration.
 * @return {number} Returns the index of the found element, else -1.
 */
_.LoDashStatic.prototype.findLastIndex = function(array, predicate, thisArg) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.findLastIndex = function(predicate, thisArg) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.findLastIndex = function(predicate, thisArg) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.findLastIndex = function(predicate, thisArg) {};

/**
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @see _.findLastIndex
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.findLastIndex = function(predicate, thisArg) {};

/**
 * Gets the first element of array.
 * 
 * \@alias _.head
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @return {T} Returns the first element of array.
 */
_.LoDashStatic.prototype.first = function(array) {};

/**
 * @see _.first
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashExplicitArrayWrapper.prototype.first = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashExplicitObjectWrapper.prototype.first = function() {};
/**
 * @record
 * @struct
 */
_.RecursiveArray = function() {};
/**
 * @extends {_.List}
 * @record
 * @struct
 */
_.ListOfRecursiveArraysOrValues = function() {};

/**
 * Flattens a nested array. If isDeep is true the array is recursively flattened, otherwise itâ€™s only
 * flattened a single level.
 * 
 * @see _.flatten
 * @see _.flatten
 * @template T
 * @param {!_.ListOfRecursiveArraysOrValues<T>|!_.List<(T|!Array<T>)>} array The array to flatten.
 * @param {boolean=} isDeep Specify a deep flatten.
 * @return {!Array<T>|!_.RecursiveArray<T>} Returns the new flattened array.
 */
_.LoDashStatic.prototype.flatten = function(array, isDeep) {};

/**
 * @see _.flatten
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.flatten = function() {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.flatten = function(isDeep) {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.flatten = function(isDeep) {};

/**
 * @see _.flatten
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.flatten = function() {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.flatten = function(isDeep) {};

/**
 * @see _.flatten
 * @template TResult
 * @param {boolean=} isDeep
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.flatten = function(isDeep) {};

/**
 * Recursively flattens a nested array.
 * 
 * @template T
 * @param {!_.ListOfRecursiveArraysOrValues<T>} array The array to recursively flatten.
 * @return {!Array<T>} Returns the new flattened array.
 */
_.LoDashStatic.prototype.flattenDeep = function(array) {};

/**
 * @see _.flattenDeep
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.flattenDeep
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.flattenDeep = function() {};

/**
 * @see _.first
 * @template T
 * @param {!_.List<T>} array
 * @return {T}
 */
_.LoDashStatic.prototype.head = function(array) {};

/**
 * @see _.first
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashExplicitArrayWrapper.prototype.head = function() {};

/**
 * @see _.first
 * @template T
 * @return {T}
 */
_.LoDashExplicitObjectWrapper.prototype.head = function() {};

/**
 * Gets the index at which the first occurrence of value is found in array using SameValueZero for equality
 * comparisons. If fromIndex is negative, itâ€™s used as the offset from the end of array. If array is sorted
 * providing true for fromIndex performs a faster binary search.
 * 
 * @template T
 * @param {!_.List<T>} array The array to search.
 * @param {T} value The value to search for.
 * @param {(number|boolean)=} fromIndex The index to search from or true to perform a binary search on a sorted array.
 * @return {number} The index to search from or true to perform a binary search on a sorted array.
 */
_.LoDashStatic.prototype.indexOf = function(array, value, fromIndex) {};

/**
 * @see _.indexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.indexOf = function(value, fromIndex) {};

/**
 * @see _.indexOf
 * @template TValue
 * @param {TValue} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.indexOf = function(value, fromIndex) {};

/**
 * @see _.indexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.indexOf = function(value, fromIndex) {};

/**
 * @see _.indexOf
 * @template TValue
 * @param {TValue} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.indexOf = function(value, fromIndex) {};

/**
 * Gets all but the last element of array.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.initial = function(array) {};

/**
 * @see _.initial
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.initial = function() {};

/**
 * @see _.initial
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.initial = function() {};

/**
 * @see _.initial
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.initial = function() {};

/**
 * @see _.initial
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.initial = function() {};

/**
 * Creates an array of unique values that are included in all of the provided arrays using SameValueZero for
 * equality comparisons.
 * 
 * @template T
 * @param {...(!Array<T>|!_.List<T>)} arrays The arrays to inspect.
 * @return {!Array<T>} Returns the new array of shared values.
 */
_.LoDashStatic.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...(!Array<TResult>|!_.List<TResult>)} arrays
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...(!Array<TResult>|!_.List<TResult>)} arrays
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...(!Array<TResult>|!_.List<TResult>)} arrays
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.intersection = function(arrays) {};

/**
 * @see _.intersection
 * @template TResult
 * @param {...(!Array<TResult>|!_.List<TResult>)} arrays
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.intersection = function(arrays) {};

/**
 * Gets the last element of array.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @return {T} Returns the last element of array.
 */
_.LoDashStatic.prototype.last = function(array) {};

/**
 * @see _.last
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @template T
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @template T
 * @return {T}
 */
_.LoDashExplicitArrayWrapper.prototype.last = function() {};

/**
 * @see _.last
 * @template T
 * @return {T}
 */
_.LoDashExplicitObjectWrapper.prototype.last = function() {};

/**
 * This method is like _.indexOf except that it iterates over elements of array from right to left.
 * 
 * @template T
 * @param {!_.List<T>} array The array to search.
 * @param {T} value The value to search for.
 * @param {(number|boolean)=} fromIndex The index to search from or true to perform a binary search on a sorted array.
 * @return {number} Returns the index of the matched value, else -1.
 */
_.LoDashStatic.prototype.lastIndexOf = function(array, value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @template TResult
 * @param {TResult} value
 * @param {(number|boolean)=} fromIndex
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @param {T} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.lastIndexOf
 * @template TResult
 * @param {TResult} value
 * @param {(number|boolean)=} fromIndex
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.lastIndexOf = function(value, fromIndex) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {(!_.List<!_.StringRepresentable>|!_.List<!_.List<?>>)} props
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {TResult|!_.Dictionary<?>}
 */
_.LoDashStatic.prototype.object = function(props, values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitArrayWrapper.prototype.object = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitObjectWrapper.prototype.object = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitArrayWrapper.prototype.object = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitObjectWrapper.prototype.object = function(values) {};

/**
 * Removes all provided values from array using SameValueZero for equality comparisons.
 * 
 * Note: Unlike _.without, this method mutates array.
 * 
 * @see _.pull
 * @template T
 * @param {!Array<T>|!_.List<T>} array The array to modify.
 * @param {...T} values The values to remove.
 * @return {!Array<T>|!_.List<T>} Returns array.
 */
_.LoDashStatic.prototype.pull = function(array, values) {};

/**
 * @see _.pull
 * @param {...T} values
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.pull = function(values) {};

/**
 * @see _.pull
 * @template TValue
 * @param {...TValue} values
 * @return {!_.LoDashImplicitObjectWrapper<!_.List<TValue>>}
 */
_.LoDashImplicitObjectWrapper.prototype.pull = function(values) {};

/**
 * @see _.pull
 * @param {...T} values
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.pull = function(values) {};

/**
 * @see _.pull
 * @template TValue
 * @param {...TValue} values
 * @return {!_.LoDashExplicitObjectWrapper<!_.List<TValue>>}
 */
_.LoDashExplicitObjectWrapper.prototype.pull = function(values) {};

/**
 * Removes elements from array corresponding to the given indexes and returns an array of the removed elements.
 * Indexes may be specified as an array of indexes or as individual arguments.
 * 
 * Note: Unlike _.at, this method mutates array.
 * 
 * @template T
 * @param {!_.List<T>} array The array to modify.
 * @param {...(number|!Array<number>)} indexes The indexes of elements to remove, specified as individual indexes or arrays of indexes.
 * @return {!Array<T>} Returns the new array of removed elements.
 */
_.LoDashStatic.prototype.pullAt = function(array, indexes) {};

/**
 * @see _.pullAt
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.pullAt = function(indexes) {};

/**
 * @see _.pullAt
 * @template T
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.pullAt = function(indexes) {};

/**
 * @see _.pullAt
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.pullAt = function(indexes) {};

/**
 * @see _.pullAt
 * @template T
 * @param {...(number|!Array<number>)} indexes
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.pullAt = function(indexes) {};

/**
 * Removes all elements from array that predicate returns truthy for and returns an array of the removed
 * elements. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * Note: Unlike _.filter, this method mutates array.
 * 
 * @see _.remove
 * @see _.remove
 * @template T, W
 * @param {!_.List<T>} array The array to modify.
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<T>} Returns the new array of removed elements.
 */
_.LoDashStatic.prototype.remove = function(array, predicate, thisArg) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.remove = function(predicate, thisArg) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.remove = function(predicate, thisArg) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.remove = function(predicate, thisArg) {};

/**
 * @see _.remove
 * @see _.remove
 * @see _.remove
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.remove = function(predicate, thisArg) {};

/**
 * Gets all but the first element of array.
 * 
 * \@alias _.tail
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.rest = function(array) {};

/**
 * @see _.rest
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.rest = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.rest = function() {};

/**
 * @see _.rest
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.rest = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.rest = function() {};

/**
 * Creates a slice of array from start up to, but not including, end.
 * 
 * @template T
 * @param {!Array<T>} array The array to slice.
 * @param {number=} start The start position.
 * @param {number=} end The end position.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.slice = function(array, start, end) {};

/**
 * @see _.slice
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.slice = function(start, end) {};

/**
 * @see _.slice
 * @param {number=} start
 * @param {number=} end
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.slice = function(start, end) {};

/**
 * Uses a binary search to determine the lowest index at which value should be inserted into array in order to maintain its sort order. If an iteratee function is provided itâ€™s invoked for value and each element of array to compute their sort ranking. The iteratee is bound to thisArg and invoked with one argument; (value).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that have the properties of the given object, else false.
 * 
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template T, TSort, W
 * @param {!_.List<T>} array The sorted array to inspect.
 * @param {T} value The value to evaluate.
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee The function invoked per iteration.
 * @param {?=} thisArg
 * @return {number} The this binding of iteratee.
 */
_.LoDashStatic.prototype.sortedIndex = function(array, value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @see _.sortedIndex
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.sortedIndex = function(value, iteratee, thisArg) {};

/**
 * This method is like _.sortedIndex except that it returns the highest index at which value should be
 * inserted into array in order to maintain its sort order.
 * 
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template T, TSort, W
 * @param {!_.List<T>} array The sorted array to inspect.
 * @param {T} value The value to evaluate.
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {number} Returns the index at which value should be inserted into array.
 */
_.LoDashStatic.prototype.sortedLastIndex = function(array, value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @template TSort
 * @param {string} value
 * @param {function(string): TSort=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template TSort, W
 * @param {T} value
 * @param {function(T): TSort|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @see _.sortedLastIndex
 * @template T, TSort, W
 * @param {T} value
 * @param {function(T): TSort|function(T): ?|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.sortedLastIndex = function(value, iteratee, thisArg) {};

/**
 * @see _.rest
 * @template T
 * @param {!_.List<T>} array
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.tail = function(array) {};

/**
 * @see _.rest
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.tail = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.tail = function() {};

/**
 * @see _.rest
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.tail = function() {};

/**
 * @see _.rest
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.tail = function() {};

/**
 * Creates a slice of array with n elements taken from the beginning.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @param {number=} n The number of elements to take.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.take = function(array, n) {};

/**
 * @see _.take
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.take = function(n) {};

/**
 * @see _.take
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.take = function(n) {};

/**
 * @see _.take
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.take = function(n) {};

/**
 * @see _.take
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.take = function(n) {};

/**
 * Creates a slice of array with n elements taken from the end.
 * 
 * @template T
 * @param {!_.List<T>} array The array to query.
 * @param {number=} n The number of elements to take.
 * @return {!Array<T>} Returns the slice of array.
 */
_.LoDashStatic.prototype.takeRight = function(array, n) {};

/**
 * @see _.takeRight
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.takeRight = function(n) {};

/**
 * @see _.takeRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.takeRight = function(n) {};

/**
 * @see _.takeRight
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.takeRight = function(n) {};

/**
 * @see _.takeRight
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.takeRight = function(n) {};

/**
 * Creates a slice of array with elements taken from the end. Elements are taken until predicate returns
 * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TValue, TWhere
 * @param {!_.List<TValue>} array The array to query.
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.takeRightWhile = function(array, predicate, thisArg) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.takeRightWhile = function(predicate, thisArg) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.takeRightWhile = function(predicate, thisArg) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.takeRightWhile = function(predicate, thisArg) {};

/**
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @see _.takeRightWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.takeRightWhile = function(predicate, thisArg) {};

/**
 * Creates a slice of array with elements taken from the beginning. Elements are taken until predicate returns
 * falsey. The predicate is bound to thisArg and invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TValue, TWhere
 * @param {!_.List<TValue>} array The array to query.
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<TValue>} Returns the slice of array.
 */
_.LoDashStatic.prototype.takeWhile = function(array, predicate, thisArg) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TValue>}
 */
_.LoDashImplicitObjectWrapper.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TWhere
 * @param {!_.ListIterator<T, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * @see _.takeWhile
 * @see _.takeWhile
 * @see _.takeWhile
 * @template TValue, TWhere
 * @param {!_.ListIterator<TValue, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TValue>}
 */
_.LoDashExplicitObjectWrapper.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * Creates an array of unique values, in order, from all of the provided arrays using SameValueZero for
 * equality comparisons.
 * 
 * @template T
 * @param {...!_.List<T>} arrays The arrays to inspect.
 * @return {!Array<T>} Returns the new array of combined values.
 */
_.LoDashStatic.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @see _.union
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper|!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @see _.union
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper|!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitArrayWrapper.prototype.union = function(arrays) {};

/**
 * @see _.union
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.union = function(arrays) {};

/**
 * Creates a duplicate-free version of an array, using SameValueZero for equality comparisons, in which only
 * the first occurrence of each element is kept. Providing true for isSorted performs a faster search
 * algorithm for sorted arrays. If an iteratee function is provided itâ€™s invoked for each element in the
 * array to generate the criterion by which uniqueness is computed. The iteratee is bound to thisArg and
 * invoked with three arguments: (value, index, array).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.unique
 * 
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {!_.List<T>} array The array to inspect.
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee Specify the array is sorted.
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg The function invoked per iteration.
 * @param {?=} thisArg iteratee
 * @return {!Array<T>} Returns the new duplicate-value-free array.
 */
_.LoDashStatic.prototype.uniq = function(array, isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @param {boolean|!_.ListIterator<T, TSort>=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template TSort, TWhere
 * @param {boolean|!_.ListIterator<T, TSort>|string|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?|string|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @param {boolean|!_.ListIterator<T, TSort>=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template TSort, TWhere
 * @param {boolean|!_.ListIterator<T, TSort>|string|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?|string|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.uniq = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {!_.List<T>} array
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!Array<T>}
 */
_.LoDashStatic.prototype.unique = function(array, isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @param {boolean|!_.ListIterator<T, TSort>=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template TSort, TWhere
 * @param {boolean|!_.ListIterator<T, TSort>|string|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?|string|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @template TSort
 * @param {boolean|!_.ListIterator<T, TSort>=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template TSort, TWhere
 * @param {boolean|!_.ListIterator<T, TSort>|string|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, TSort>|?|string|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @see _.uniq
 * @template T, TSort, TWhere
 * @param {boolean|!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|string|!Object|TWhere=} isSorted_or_iteratee
 * @param {!_.ListIterator<T, ?>|!_.ListIterator<T, TSort>|?|string|!Object|TWhere=} iteratee_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.unique = function(isSorted_or_iteratee, iteratee_or_thisArg, thisArg) {};

/**
 * This method is like _.zip except that it accepts an array of grouped elements and creates an array
 * regrouping the elements to their pre-zip configuration.
 * 
 * @template T
 * @param {!_.List<!_.List<T>>} array The array of grouped elements to process.
 * @return {!Array<!Array<T>>} Returns the new array of regrouped elements.
 */
_.LoDashStatic.prototype.unzip = function(array) {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.unzip = function() {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitObjectWrapper.prototype.unzip = function() {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.unzip = function() {};

/**
 * @see _.unzip
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitObjectWrapper.prototype.unzip = function() {};

/**
 * This method is like _.unzip except that it accepts an iteratee to specify how regrouped values should be
 * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,
 * group).
 * 
 * @template TArray, TResult
 * @param {!_.List<!_.List<TArray>>} array The array of grouped elements to process.
 * @param {!_.MemoIterator<TArray, TResult>=} iteratee The function to combine regrouped values.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<TResult>} Returns the new array of regrouped elements.
 */
_.LoDashStatic.prototype.unzipWith = function(array, iteratee, thisArg) {};

/**
 * @see _.unzipWith
 * @template TArr, TResult
 * @param {!_.MemoIterator<TArr, TResult>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.unzipWith = function(iteratee, thisArg) {};

/**
 * @see _.unzipWith
 * @template TArr, TResult
 * @param {!_.MemoIterator<TArr, TResult>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.unzipWith = function(iteratee, thisArg) {};

/**
 * Creates an array excluding all provided values using SameValueZero for equality comparisons.
 * 
 * @template T
 * @param {!_.List<T>} array The array to filter.
 * @param {...T} values The values to exclude.
 * @return {!Array<T>} Returns the new array of filtered values.
 */
_.LoDashStatic.prototype.without = function(array, values) {};

/**
 * @see _.without
 * @param {...T} values
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.without = function(values) {};

/**
 * @see _.without
 * @template T
 * @param {...T} values
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.without = function(values) {};

/**
 * @see _.without
 * @param {...T} values
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.without = function(values) {};

/**
 * @see _.without
 * @template T
 * @param {...T} values
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.without = function(values) {};

/**
 * Creates an array of unique values that is the symmetric difference of the provided arrays.
 * 
 * @template T
 * @param {...!_.List<T>} arrays The arrays to inspect.
 * @return {!Array<T>} Returns the new array of values.
 */
_.LoDashStatic.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.xor = function(arrays) {};

/**
 * @see _.xor
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.xor = function(arrays) {};

/**
 * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,
 * the second of which contains the second elements of the given arrays, and so on.
 * 
 * @template T
 * @param {...!_.List<T>} arrays The arrays to process.
 * @return {!Array<!Array<T>>} Returns the new array of grouped elements.
 */
_.LoDashStatic.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitObjectWrapper.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.zip = function(arrays) {};

/**
 * @see _.zip
 * @template T
 * @param {...!_.List<T>} arrays
 * @return {!_.LoDashExplicitArrayWrapper<!Array<T>>}
 */
_.LoDashExplicitObjectWrapper.prototype.zip = function(arrays) {};

/**
 * The inverse of _.pairs; this method returns an object composed from arrays of property names and values.
 * Provide either a single two dimensional array, e.g. [[key1, value1], [key2, value2]] or two arrays, one of
 * property names and one of corresponding values.
 * 
 * \@alias _.object
 * 
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {(!_.List<!_.StringRepresentable>|!_.List<!_.List<?>>)} props The property names.
 * @param {!_.List<TValues>|!_.List<?>=} values The property values.
 * @return {TResult|!_.Dictionary<?>} Returns the new object.
 */
_.LoDashStatic.prototype.zipObject = function(props, values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitArrayWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashImplicitObjectWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitArrayWrapper.prototype.zipObject = function(values) {};

/**
 * @see _.zipObject
 * @see _.zipObject
 * @see _.zipObject
 * @template TValues, TResult
 * @param {!_.List<TValues>|!_.List<?>=} values
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper<!_.Dictionary<?>>}
 */
_.LoDashExplicitObjectWrapper.prototype.zipObject = function(values) {};

/**
 * This method is like _.zip except that it accepts an iteratee to specify how grouped values should be
 * combined. The iteratee is bound to thisArg and invoked with four arguments: (accumulator, value, index,
 * group).
 * @template TResult
 * @param {...?} args
 * @return {!Array<TResult>} Returns the new array of grouped elements.
 */
_.LoDashStatic.prototype.zipWith = function(args) {};

/**
 * @see _.zipWith
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.zipWith = function(args) {};

/**
 * Creates a lodash object that wraps value with explicit method chaining enabled.
 * 
 * @template T
 * @param {number|string|boolean|!Array<T>|T|?} value The value to wrap.
 * @return {!_.LoDashExplicitWrapper<number>|!_.LoDashExplicitWrapper<string>|!_.LoDashExplicitWrapper<boolean>|!_.LoDashExplicitArrayWrapper<T>|!_.LoDashExplicitObjectWrapper<T>|!_.LoDashExplicitWrapper<?>} Returns the new lodash wrapper instance.
 */
_.LoDashStatic.prototype.chain = function(value) {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {!_.LoDashExplicitObjectWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.chain = function() {};

/**
 * @see _.chain
 * @return {TWrapper}
 */
_.LoDashExplicitWrapperBase.prototype.chain = function() {};

/**
 * This method invokes interceptor and returns value. The interceptor is bound to thisArg and invoked with one
 * argument; (value). The purpose of this method is to "tap into" a method chain in order to perform operations
 * on intermediate results within the chain.
 * 
 * \@parem thisArg The this binding of interceptor.
 * @template T
 * @param {T} value The value to provide to interceptor.
 * @param {function(T): void} interceptor The function to invoke.
 * @param {?=} thisArg
 * @return {T} Returns value.
 * 
 */
_.LoDashStatic.prototype.tap = function(value, interceptor, thisArg) {};

/**
 * @see _.tap
 * @param {function(T): void} interceptor
 * @param {?=} thisArg
 * @return {TWrapper}
 */
_.LoDashImplicitWrapperBase.prototype.tap = function(interceptor, thisArg) {};

/**
 * @see _.tap
 * @param {function(T): void} interceptor
 * @param {?=} thisArg
 * @return {TWrapper}
 */
_.LoDashExplicitWrapperBase.prototype.tap = function(interceptor, thisArg) {};

/**
 * This method is like _.tap except that it returns the result of interceptor.
 * 
 * @template T, TResult
 * @param {T} value The value to provide to interceptor.
 * @param {function(T): TResult} interceptor The function to invoke.
 * @param {?=} thisArg The this binding of interceptor.
 * @return {TResult} Returns the result of interceptor.
 */
_.LoDashStatic.prototype.thru = function(value, interceptor, thisArg) {};

/**
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @template TResult
 * @param {function(T): TResult|function(T): !Array<TResult>} interceptor
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<TResult>|!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.thru = function(interceptor, thisArg) {};

/**
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @see _.thru
 * @template TResult
 * @param {function(T): TResult|function(T): !Array<TResult>} interceptor
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitWrapperBase.prototype.thru = function(interceptor, thisArg) {};

/**
 * Executes the chained sequence and returns the wrapped result.
 * 
 * @return {TWrapper} Returns the new lodash wrapper instance.
 */
_.LoDashImplicitWrapperBase.prototype.commit = function() {};

/**
 * @see _.commit
 * @return {TWrapper}
 */
_.LoDashExplicitWrapperBase.prototype.commit = function() {};

/**
 * Creates a new array joining a wrapped array with any additional arrays and/or values.
 * 
 * @see _.concat
 * @template TItem
 * @param {...(TItem|!Array<TItem>)|(T|!Array<T>)} items
 * @return {!_.LoDashImplicitArrayWrapper<TItem>|!_.LoDashImplicitArrayWrapper<T>} Returns the new concatenated array.
 */
_.LoDashImplicitWrapperBase.prototype.concat = function(items) {};

/**
 * @see _.concat
 * @see _.concat
 * @template TItem
 * @param {...(TItem|!Array<TItem>)|(T|!Array<T>)} items
 * @return {!_.LoDashExplicitArrayWrapper<TItem>|!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapperBase.prototype.concat = function(items) {};

/**
 * Creates a clone of the chained sequence planting value as the wrapped value.
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @template T
 * @param {number|string|boolean|!Array<number>|!Array<T>|T|?} value The value to plant as the wrapped value.
 * @return {!_.LoDashImplicitWrapper<number>|!_.LoDashImplicitStringWrapper|!_.LoDashImplicitWrapper<boolean>|!_.LoDashImplicitNumberArrayWrapper|!_.LoDashImplicitArrayWrapper<T>|!_.LoDashImplicitObjectWrapper<T>|!_.LoDashImplicitWrapper<?>} Returns the new lodash wrapper instance.
 */
_.LoDashImplicitWrapperBase.prototype.plant = function(value) {};

/**
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @see _.plant
 * @template T
 * @param {number|string|boolean|!Array<number>|!Array<T>|T|?} value
 * @return {!_.LoDashExplicitWrapper<number>|!_.LoDashExplicitStringWrapper|!_.LoDashExplicitWrapper<boolean>|!_.LoDashExplicitNumberArrayWrapper|!_.LoDashExplicitArrayWrapper<T>|!_.LoDashExplicitObjectWrapper<T>|!_.LoDashExplicitWrapper<?>}
 */
_.LoDashExplicitWrapperBase.prototype.plant = function(value) {};

/**
 * Reverses the wrapped array so the first element becomes the last, the second element becomes the second to
 * last, and so on.
 * 
 * Note: This method mutates the wrapped array.
 * 
 * @return {!_.LoDashImplicitArrayWrapper} Returns the new reversed lodash wrapper instance.
 */
_.LoDashImplicitArrayWrapper.prototype.reverse = function() {};

/**
 * @see _.reverse
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.reverse = function() {};

/**
 * @see _.value
 * @return {T}
 */
_.LoDashWrapperBase.prototype.run = function() {};

/**
 * @see _.value
 * @return {T}
 */
_.LoDashWrapperBase.prototype.toJSON = function() {};

/**
 * Produces the result of coercing the unwrapped value to a string.
 * 
 * @return {string} Returns the coerced string value.
 */
_.LoDashWrapperBase.prototype.toString = function() {};

/**
 * Executes the chained sequence to extract the unwrapped value.
 * 
 * \@alias _.run, _.toJSON, _.valueOf
 * 
 * @return {T} Returns the resolved unwrapped value.
 */
_.LoDashWrapperBase.prototype.value = function() {};

/**
 * @see _.value
 * @return {T}
 */
_.LoDashWrapperBase.prototype.valueOf = function() {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @see _.every
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashStatic.prototype.all = function(collection, predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.all = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.all = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.all = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.all = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|!Object|(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>|!_.ObjectIterator<?, boolean>|string|TObject|!Object=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashStatic.prototype.any = function(collection, predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TObject
 * @param {(!_.ListIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.any = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult, TObject
 * @param {(!_.ObjectIterator<?, boolean>|!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.any = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TObject
 * @param {(!_.ListIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.any = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult, TObject
 * @param {(!_.ObjectIterator<?, boolean>|!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.any = function(predicate, thisArg) {};

/**
 * Creates an array of elements corresponding to the given keys, or indexes, of collection. Keys may be
 * specified as individual arguments or as arrays of keys.
 * 
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {...(string|number|!Array<(string|number)>)} props The property names or indexes of elements to pick, specified individually or in arrays.
 * @return {!Array<T>} Returns the new array of picked elements.
 */
_.LoDashStatic.prototype.at = function(collection, props) {};

/**
 * @see _.at
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.at = function(props) {};

/**
 * @see _.at
 * @template T
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.at = function(props) {};

/**
 * @see _.at
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.at = function(props) {};

/**
 * @see _.at
 * @template T
 * @param {...(string|number|!Array<(string|number)>)} props
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.at = function(props) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @see _.map
 * @template T, TResult, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection
 * @param {!_.ListIterator<T, TResult>|!_.DictionaryIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!Array<TResult>|!Array<boolean>}
 */
_.LoDashStatic.prototype.collect = function(collection, iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, TObject
 * @param {!_.ListIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitArrayWrapper.prototype.collect = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, TObject
 * @param {(!_.ListIterator<TValue, TResult>|!_.DictionaryIterator<TValue, TResult>)|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapper.prototype.collect = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, TObject
 * @param {!_.ListIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.collect = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, TObject
 * @param {(!_.ListIterator<TValue, TResult>|!_.DictionaryIterator<TValue, TResult>)|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.collect = function(iteratee, thisArg) {};

/**
 * @see _.includes
 * @see _.includes
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection
 * @param {T|string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashStatic.prototype.contains = function(collection, target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.contains = function(target, fromIndex) {};

/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is the number of times the key was returned by iteratee. The
 * iteratee is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>|string|W|!Object=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<number>} Returns the composed aggregate object.
 */
_.LoDashStatic.prototype.countBy = function(collection, iteratee, thisArg) {};

/**
 * @see _.countBy
 * @param {!_.ListIterator<T, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashImplicitWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template W
 * @param {!_.ListIterator<T, ?>|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashImplicitArrayWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template T, W
 * @param {(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>)|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashImplicitObjectWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @param {!_.ListIterator<T, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashExplicitWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template W
 * @param {!_.ListIterator<T, ?>|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashExplicitArrayWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.countBy
 * @see _.countBy
 * @see _.countBy
 * @template T, W
 * @param {(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>)|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<number>>}
 */
_.LoDashExplicitObjectWrapper.prototype.countBy = function(iteratee, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashStatic.prototype.detect = function(collection, predicate, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.detect = function(predicate, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.detect = function(predicate, thisArg) {};

/**
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @template T, TValue
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>|T} collection
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>|!_.ObjectIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg_or_thisArgs
 * @return {!Array<T>|!_.List<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.each = function(collection, iteratee, thisArg_or_thisArgs) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.each = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @template T, TValue
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>|T} collection
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>|!_.ObjectIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg_or_thisArgs
 * @return {!Array<T>|!_.List<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.eachRight = function(collection, iteratee, thisArg_or_thisArgs) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.eachRight = function(iteratee, thisArg) {};

/**
 * Checks if predicate returns truthy for all elements of collection. The predicate is bound to thisArg and
 * invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.all
 * 
 * @see _.every
 * @see _.every
 * @see _.every
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|string|TObject=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {boolean} Returns true if all elements pass the predicate check, else false.
 */
_.LoDashStatic.prototype.every = function(collection, predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.every = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.every = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.every = function(predicate, thisArg) {};

/**
 * @see _.every
 * @see _.every
 * @see _.every
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.every = function(predicate, thisArg) {};

/**
 * Iterates over elements of collection, returning an array of all elements predicate returns truthy for. The
 * predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.select
 * 
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>|string|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.StringIterator<boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<T>|!Array<string>} Returns the new filtered array.
 */
_.LoDashStatic.prototype.filter = function(collection, predicate, thisArg) {};

/**
 * @see _.filter
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.filter = function(predicate, thisArg) {};

/**
 * Iterates over elements of collection, returning the first element predicate returns truthy for.
 * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.detect
 * 
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to search.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|string|TObject=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {T} Returns the matched element, else undefined.
 */
_.LoDashStatic.prototype.find = function(collection, predicate, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @template TObject
 * @param {!_.ListIterator<T, boolean>|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.find = function(predicate, thisArg) {};

/**
 * @see _.find
 * @see _.find
 * @see _.find
 * @template TResult, TObject
 * @param {(!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.find = function(predicate, thisArg) {};

/**
 * @see _.find
 * 
 * @see _.find
 * 
 * @see _.find
 * 
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T, W
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|W|string} callback_or_whereValue_or_pluckValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashStatic.prototype.findWhere = function(collection, callback_or_whereValue_or_pluckValue, thisArg) {};

/**
 * This method is like _.find except that it iterates over elements of a collection from
 * right to left.
 * @see _.find
 * 
 * @see _.find
 * 
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @see _.find
 * @template T, W
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection Searches for a value in this list.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|W|string} callback_or_whereValue_or_pluckValue The function called per iteration.
 * @param {?=} thisArg The this binding of callback.
 * @return {T} The found element, else undefined.
 * 
 */
_.LoDashStatic.prototype.findLast = function(collection, callback_or_whereValue_or_pluckValue, thisArg) {};

/**
 * @see _.findLast
 * @see _.findLast
 * @see _.findLast
 * @template W
 * @param {!_.ListIterator<T, boolean>|W|string} callback_or_whereValue_or_pluckValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.findLast = function(callback_or_whereValue_or_pluckValue, thisArg) {};

/**
 * Iterates over elements of collection invoking iteratee for each element. The iteratee is bound to thisArg
 * and invoked with three arguments:
 * (value, index|key, collection). Iteratee functions may exit iteration early by explicitly returning false.
 * 
 * Note: As with other "Collections" methods, objects with a "length" property are iterated like arrays. To
 * avoid this behavior _.forIn or _.forOwn may be used for object iteration.
 * 
 * \@alias _.each
 * 
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @see _.forEach
 * @template T, TValue
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>|T} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>|!_.ObjectIterator<TValue, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg_or_thisArgs The this binding of iteratee.
 * @return {!Array<T>|!_.List<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.forEach = function(collection, iteratee, thisArg_or_thisArgs) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * @see _.forEach
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forEach = function(iteratee, thisArg) {};

/**
 * This method is like _.forEach except that it iterates over elements of collection from right to left.
 * 
 * \@alias _.eachRight
 * 
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @see _.forEachRight
 * @template T, TValue
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>|T} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>|!_.ObjectIterator<TValue, ?>=} iteratee The function called per iteration.
 * @param {?=} thisArg_or_thisArgs The this binding of callback.
 * @return {!Array<T>|!_.List<T>|!_.Dictionary<T>|T}
 */
_.LoDashStatic.prototype.forEachRight = function(collection, iteratee, thisArg_or_thisArgs) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<string, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @param {!_.ListIterator<T, ?>} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * @see _.forEachRight
 * @template TValue
 * @param {(!_.ListIterator<TValue, ?>|!_.DictionaryIterator<TValue, ?>)=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forEachRight = function(iteratee, thisArg) {};

/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is an array of the elements responsible for generating the
 * key. The iteratee is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template T, TKey, TValue, TWhere
 * @param {!_.List<T>|!_.List<?>|!_.Dictionary<T>|!_.Dictionary<?>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, TKey>|!_.ListIterator<T, ?>|!_.DictionaryIterator<T, TKey>|!_.DictionaryIterator<T, ?>|string|TWhere|!Object=} iteratee The function invoked per iteration.
 * @param {?|TValue=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<!Array<T>>} Returns the composed aggregate object.
 */
_.LoDashStatic.prototype.groupBy = function(collection, iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @template TKey
 * @param {!_.ListIterator<T, TKey>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashImplicitWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template TKey, TValue, TWhere
 * @param {!_.ListIterator<T, TKey>|string|TWhere=} iteratee
 * @param {?|TValue=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashImplicitArrayWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template T, TKey, TValue, TWhere
 * @param {(!_.ListIterator<T, TKey>|!_.DictionaryIterator<T, TKey>)|(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|TWhere|!Object=} iteratee
 * @param {?|TValue=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashImplicitObjectWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @template TKey
 * @param {!_.ListIterator<T, TKey>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashExplicitWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template TKey, TValue, TWhere
 * @param {!_.ListIterator<T, TKey>|string|TWhere=} iteratee
 * @param {?|TValue=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashExplicitArrayWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @see _.groupBy
 * @template T, TKey, TValue, TWhere
 * @param {(!_.ListIterator<T, TKey>|!_.DictionaryIterator<T, TKey>)|(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|TWhere|!Object=} iteratee
 * @param {?|TValue=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<!Array<T>>>}
 */
_.LoDashExplicitObjectWrapper.prototype.groupBy = function(iteratee, thisArg) {};

/**
 * @see _.includes
 * @see _.includes
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection
 * @param {T|string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashStatic.prototype.include = function(collection, target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.include = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.include = function(target, fromIndex) {};

/**
 * Checks if target is in collection using SameValueZero for equality comparisons. If fromIndex is negative,
 * itâ€™s used as the offset from the end of collection.
 * 
 * \@alias _.contains, _.include
 * 
 * @see _.includes
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection The collection to search.
 * @param {T|string} target The value to search for.
 * @param {number=} fromIndex The index to search from.
 * @return {boolean} True if the target element is found, else false.
 */
_.LoDashStatic.prototype.includes = function(collection, target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {T} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @template TValue
 * @param {TValue} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * @see _.includes
 * @param {string} target
 * @param {number=} fromIndex
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.includes = function(target, fromIndex) {};

/**
 * Creates an object composed of keys generated from the results of running each element of collection through
 * iteratee. The corresponding value of each key is the last element responsible for generating the key. The
 * iteratee function is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template T, W
 * @param {!_.List<T>|!_.NumericDictionary<T>|!_.Dictionary<T>|(!_.Dictionary<T>|!_.List<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>|!_.DictionaryIterator<T, ?>|string|W|!Object=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>} Returns the composed aggregate object.
 */
_.LoDashStatic.prototype.indexBy = function(collection, iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @param {!_.ListIterator<T, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template W
 * @param {!_.ListIterator<T, ?>|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template T, W
 * @param {(!_.ListIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitObjectWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @param {!_.ListIterator<T, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template W
 * @param {!_.ListIterator<T, ?>|string|W=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @see _.indexBy
 * @template T, W
 * @param {(!_.ListIterator<T, ?>|!_.NumericDictionaryIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|W|!Object=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitObjectWrapper.prototype.indexBy = function(iteratee, thisArg) {};

/**
 * Invokes the method named by methodName on each element in the collection returning
 * an array of the results of each invoked method. Additional arguments will be provided
 * to each invoked method. If methodName is a function it will be invoked for, and this
 * bound to, each element in the collection.
 * @see _.invoke
 * 
 * @see _.invoke
 * 
 * @see _.invoke
 * 
 * @see _.invoke
 * 
 * @see _.invoke
 * 
 * @template T
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {string|!Function} methodName_or_method The name of the method to invoke.
 * @param {...?} args Arguments to invoke the method with.
 * 
 * @return {?}
 */
_.LoDashStatic.prototype.invoke = function(collection, methodName_or_method, args) {};

/**
 * Creates an array of values by running each element in collection through iteratee. The iteratee is bound to
 * thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property value
 * of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * Many lodash methods are guarded to work as iteratees for methods like _.every, _.filter, _.map, _.mapValues,
 * _.reject, and _.some.
 * 
 * The guarded methods are:
 * ary, callback, chunk, clone, create, curry, curryRight, drop, dropRight, every, fill, flatten, invert, max,
 * min, parseInt, slice, sortBy, take, takeRight, template, trim, trimLeft, trimRight, trunc, random, range,
 * sample, some, sum, uniq, and words
 * 
 * \@alias _.collect
 * 
 * @see _.map
 * @see _.map
 * @see _.map
 * @template T, TResult, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, TResult>|!_.DictionaryIterator<T, TResult>|string|TObject=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<TResult>|!Array<boolean>} Returns the new mapped array.
 */
_.LoDashStatic.prototype.map = function(collection, iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, TObject
 * @param {!_.ListIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitArrayWrapper.prototype.map = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, TObject
 * @param {(!_.ListIterator<TValue, TResult>|!_.DictionaryIterator<TValue, TResult>)|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapper.prototype.map = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TResult, TObject
 * @param {!_.ListIterator<T, TResult>|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.map = function(iteratee, thisArg) {};

/**
 * @see _.map
 * @see _.map
 * @see _.map
 * @template TValue, TResult, TObject
 * @param {(!_.ListIterator<TValue, TResult>|!_.DictionaryIterator<TValue, TResult>)|string|TObject=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.map = function(iteratee, thisArg) {};

/**
 * Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for,
 * while the second of which contains elements predicate returns falsey for.
 * The predicate is bound to thisArg and invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback
 * returns the property value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback
 * returns true for elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns
 * true for elements that have the properties of the given object, else false.
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @see _.partition
 * 
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|W|string} callback_or_whereValue_or_path_or_pluckValue The function called per iteration.
 * @param {?=} thisArg_or_srcValue The this binding of predicate.
 * @return {!Array<!Array<T>>} Returns the array of grouped elements.
 * 
 */
_.LoDashStatic.prototype.partition = function(collection, callback_or_whereValue_or_path_or_pluckValue, thisArg_or_srcValue) {};

/**
 * @see _.partition
 * @param {!_.ListIterator<string, boolean>} callback
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<!Array<string>>}
 */
_.LoDashImplicitStringWrapper.prototype.partition = function(callback, thisArg) {};

/**
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @template W
 * @param {!_.ListIterator<T, boolean>|W|string} callback_or_whereValue_or_path_or_pluckValue
 * @param {?=} thisArg_or_srcValue
 * @return {!_.LoDashImplicitArrayWrapper<!Array<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.partition = function(callback_or_whereValue_or_path_or_pluckValue, thisArg_or_srcValue) {};

/**
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @see _.partition
 * @template TResult, W
 * @param {!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>|W|string} callback_or_whereValue_or_path_or_pluckValue
 * @param {?=} thisArg_or_srcValue
 * @return {!_.LoDashImplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashImplicitObjectWrapper.prototype.partition = function(callback_or_whereValue_or_path_or_pluckValue, thisArg_or_srcValue) {};

/**
 * Gets the property value of path from all elements in collection.
 * 
 * @see _.pluck
 * @template T, TResult
 * @param {(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to pluck.
 * @return {!Array<?>|!Array<TResult>} A new array of property values.
 */
_.LoDashStatic.prototype.pluck = function(collection, path) {};

/**
 * @see _.pluck
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.pluck = function(path) {};

/**
 * @see _.pluck
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.pluck = function(path) {};

/**
 * @see _.pluck
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.pluck = function(path) {};

/**
 * @see _.pluck
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.pluck = function(path) {};

/**
 * Reduces a collection to a value which is the accumulated result of running each
 * element in the collection through the callback, where each successive callback execution
 * consumes the return value of the previous execution. If accumulator is not provided the
 * first element of the collection will be used as the initial accumulator value. The callback
 * is bound to thisArg and invoked with four arguments; (accumulator, value, index|key, collection).
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {!_.MemoIterator<T, TResult>} callback The function called per iteration.
 * @param {TResult|?=} accumulator_or_thisArg Initial value of the accumulator.
 * @param {?=} thisArg The this binding of callback.
 * @return {TResult} Returns the accumulated value.
 * 
 */
_.LoDashStatic.prototype.reduce = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashStatic.prototype.inject = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashStatic.prototype.foldl = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TResult
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.reduce = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TResult
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.inject = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TResult
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.foldl = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.reduce = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.inject = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.foldl = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.reduce = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.inject = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduce
 * 
 * @see _.reduce
 * 
 * @template TValue, TResult
 * @param {!_.MemoIterator<TValue, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.foldl = function(callback, accumulator_or_thisArg, thisArg) {};

/**
 * This method is like _.reduce except that it iterates over elements of a collection from
 * right to left.
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {!_.MemoIterator<T, TResult>} callback The function called per iteration.
 * @param {TResult|?=} accumulator_or_thisArg Initial value of the accumulator.
 * @param {?=} thisArg The this binding of callback.
 * @return {TResult} The accumulated value.
 * 
 */
_.LoDashStatic.prototype.reduceRight = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @see _.reduceRight
 * 
 * @template T, TResult
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} collection
 * @param {!_.MemoIterator<T, TResult>} callback
 * @param {TResult|?=} accumulator_or_thisArg
 * @param {?=} thisArg
 * @return {TResult}
 */
_.LoDashStatic.prototype.foldr = function(collection, callback, accumulator_or_thisArg, thisArg) {};

/**
 * The opposite of _.filter; this method returns the elements of collection that predicate does not return
 * truthy for.
 * 
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>|string|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.StringIterator<boolean>|string|W=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {!Array<T>|!Array<string>} Returns the new filtered array.
 */
_.LoDashStatic.prototype.reject = function(collection, predicate, thisArg) {};

/**
 * @see _.reject
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.reject
 * @see _.reject
 * @see _.reject
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.reject = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {!_.List<T>|!_.Dictionary<T>|string|(!_.List<T>|!_.Dictionary<T>)} collection
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.StringIterator<boolean>|string|W=} predicate
 * @param {?=} thisArg
 * @return {!Array<T>|!Array<string>}
 */
_.LoDashStatic.prototype.select = function(collection, predicate, thisArg) {};

/**
 * @see _.filter
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @param {!_.StringIterator<boolean>=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template W
 * @param {!_.ListIterator<T, boolean>|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * @see _.filter
 * @see _.filter
 * @see _.filter
 * @template T, W
 * @param {(!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>)|string|W} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.select = function(predicate, thisArg) {};

/**
 * Gets a random element or n random elements from a collection.
 * 
 * @see _.sample
 * @see _.sample
 * @see _.sample
 * @see _.sample
 * @see _.sample
 * @template T, O
 * @param {(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)|O|!Object} collection The collection to sample.
 * @param {number=} n
 * @return {!Array<T>|T} Returns the random sample(s) of collection.
 */
_.LoDashStatic.prototype.sample = function(collection, n) {};

/**
 * @see _.sample
 * @see _.sample
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<string>|string}
 */
_.LoDashImplicitWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper|T}
 */
_.LoDashImplicitArrayWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @template T
 * @param {number=} n
 * @return {!_.LoDashImplicitArrayWrapper<T>|T}
 */
_.LoDashImplicitObjectWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<string>|!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @template TWrapper
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper|TWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.sample = function(n) {};

/**
 * @see _.sample
 * @see _.sample
 * @template T, TWrapper
 * @param {number=} n
 * @return {!_.LoDashExplicitArrayWrapper<T>|TWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.sample = function(n) {};

/**
 * Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.
 * 
 * @see _.shuffle
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection The collection to shuffle.
 * @return {!Array<T>|!Array<string>} Returns the new shuffled array.
 */
_.LoDashStatic.prototype.shuffle = function(collection) {};

/**
 * @see _.shuffle
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.shuffle = function() {};

/**
 * @see _.shuffle
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.shuffle = function() {};

/**
 * Gets the size of collection by returning its length for array-like values or the number of own enumerable
 * properties for objects.
 * 
 * @see _.size
 * @template T
 * @param {(!_.List<T>|!_.Dictionary<T>)|string} collection The collection to inspect.
 * @return {number} Returns the size of collection.
 */
_.LoDashStatic.prototype.size = function(collection) {};

/**
 * @see _.size
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.size = function() {};

/**
 * @see _.size
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.size = function() {};

/**
 * Checks if predicate returns truthy for any element of collection. The function returns as soon as it finds
 * a passing value and does not iterate over the entire collection. The predicate is bound to thisArg and
 * invoked with three arguments: (value, index|key, collection).
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * \@alias _.any
 * 
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @see _.some
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>|!Object|(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, boolean>|!_.DictionaryIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>|!_.ObjectIterator<?, boolean>|string|TObject|!Object=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {boolean} Returns true if any element passes the predicate check, else false.
 */
_.LoDashStatic.prototype.some = function(collection, predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TObject
 * @param {(!_.ListIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitArrayWrapper.prototype.some = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult, TObject
 * @param {(!_.ObjectIterator<?, boolean>|!_.NumericDictionaryIterator<T, boolean>|!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.some = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TObject
 * @param {(!_.ListIterator<T, boolean>|!_.NumericDictionaryIterator<T, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitArrayWrapper.prototype.some = function(predicate, thisArg) {};

/**
 * @see _.some
 * @see _.some
 * @see _.some
 * @template TResult, TObject
 * @param {(!_.ObjectIterator<?, boolean>|!_.NumericDictionaryIterator<T, boolean>|!_.ListIterator<TResult, boolean>|!_.DictionaryIterator<TResult, boolean>)|string|TObject=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.some = function(predicate, thisArg) {};

/**
 * Creates an array of elements, sorted in ascending order by the results of running each element in a
 * collection through iteratee. This method performs a stable sort, that is, it preserves the original sort
 * order of equal elements. The iteratee is bound to thisArg and invoked with three arguments:
 * (value, index|key, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property
 * valueof the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template T, TSort, W
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, TSort>|!_.DictionaryIterator<T, TSort>|string|W=} iteratee_or_whereValue The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<T>} Returns the new sorted array.
 */
_.LoDashStatic.prototype.sortBy = function(collection, iteratee_or_whereValue, thisArg) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template TSort, W
 * @param {!_.ListIterator<T, TSort>|string|W=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.sortBy = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template T, TSort, W
 * @param {(!_.ListIterator<T, TSort>|!_.DictionaryIterator<T, TSort>)|string|W=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.sortBy = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template TSort, W
 * @param {!_.ListIterator<T, TSort>|string|W=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.sortBy = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @see _.sortBy
 * @template T, TSort, W
 * @param {(!_.ListIterator<T, TSort>|!_.DictionaryIterator<T, TSort>)|string|W=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.sortBy = function(iteratee_or_whereValue, thisArg) {};

/**
 * This method is like "_.sortBy" except that it can sort by multiple iteratees or
 * property names.
 * 
 * If a property name is provided for an iteratee the created "_.property" style callback
 * returns the property value of the given element.
 * 
 * If a value is also provided for thisArg the created "_.matchesProperty" style callback
 * returns true for elements that have a matching property value, else false.
 * 
 * If an object is provided for an iteratee the created "_.matches" style callback returns
 * true for elements that have the properties of the given object, else false.
 * 
 * @see _.sortByAll
 * 
 * @see _.sortByAll
 * 
 * @see _.sortByAll
 * 
 * Sorts by all the given arguments, using either ListIterator, pluckValue, or whereValue foramts
 * @template T
 * @param {!Array<T>|!_.List<T>|(!Array<T>|!_.List<T>)} collection The collection to iterate over.
 * @param {...!Array<(string|!Object|!_.ListIterator<T, ?>)>|(string|!Object|!_.ListIterator<T, ?>)|(string|!Object|!_.ListIterator<T, boolean>)} iteratees_or_args The rules by which to sort
 * @return {!Array<T>} A new array of sorted elements.
 * 
 */
_.LoDashStatic.prototype.sortByAll = function(collection, iteratees_or_args) {};

/**
 * Sorts by all the given arguments, using either ListIterator, pluckValue, or whereValue foramts
 * @see _.sortByAll
 * 
 * @see _.sortByAll
 * 
 * @param {...(string|!Object|!_.ListIterator<T, boolean>)|!Array<(string|!Object|!_.ListIterator<T, ?>)>|(string|!Object|!_.ListIterator<T, ?>)} args_or_iteratees The rules by which to sort
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.sortByAll = function(args_or_iteratees) {};

/**
 * This method is like _.sortByAll except that it allows specifying the sort orders of the iteratees to sort
 * by. If orders is unspecified, all values are sorted in ascending order. Otherwise, a value is sorted in
 * ascending order if its corresponding order is "asc", and descending if "desc".
 * 
 * If a property name is provided for an iteratee the created _.property style callback returns the property
 * value of the given element.
 * 
 * If an object is provided for an iteratee the created _.matches style callback returns true for elements
 * that have the properties of the given object, else false.
 * 
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @template W, T
 * @param {!_.List<T>|!_.NumericDictionary<T>|!_.Dictionary<T>} collection The collection to iterate over.
 * @param {(string|W|!_.ListIterator<T, ?>|!Array<(string|W|!_.ListIterator<T, ?>)>)|(string|!Object|!_.ListIterator<T, ?>|!Array<(string|!Object|!_.ListIterator<T, ?>)>)|(string|W|!_.NumericDictionaryIterator<T, ?>|!Array<(string|W|!_.NumericDictionaryIterator<T, ?>)>)|(string|!Object|!_.NumericDictionaryIterator<T, ?>|!Array<(string|!Object|!_.NumericDictionaryIterator<T, ?>)>)|(string|W|!_.DictionaryIterator<T, ?>|!Array<(string|W|!_.DictionaryIterator<T, ?>)>)|(string|!Object|!_.DictionaryIterator<T, ?>|!Array<(string|!Object|!_.DictionaryIterator<T, ?>)>)} iteratees The iteratees to sort by.
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders The sort orders of iteratees.
 * @return {!Array<T>} Returns the new sorted array.
 */
_.LoDashStatic.prototype.sortByOrder = function(collection, iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @param {(string|!_.ListIterator<T, ?>|!Array<(string|!_.ListIterator<T, ?>)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @template W
 * @param {(string|!_.ListIterator<T, ?>|W|!Array<(string|!_.ListIterator<T, ?>|W)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @template W, T
 * @param {(string|W|!_.ListIterator<T, ?>|!Array<(string|W|!_.ListIterator<T, ?>)>)|(string|!Object|!_.ListIterator<T, ?>|!Array<(string|!Object|!_.ListIterator<T, ?>)>)|(string|W|!_.NumericDictionaryIterator<T, ?>|!Array<(string|W|!_.NumericDictionaryIterator<T, ?>)>)|(string|!Object|!_.NumericDictionaryIterator<T, ?>|!Array<(string|!Object|!_.NumericDictionaryIterator<T, ?>)>)|(string|W|!_.DictionaryIterator<T, ?>|!Array<(string|W|!_.DictionaryIterator<T, ?>)>)|(string|!Object|!_.DictionaryIterator<T, ?>|!Array<(string|!Object|!_.DictionaryIterator<T, ?>)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @param {(string|!_.ListIterator<T, ?>|!Array<(string|!_.ListIterator<T, ?>)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @template W
 * @param {(string|!_.ListIterator<T, ?>|W|!Array<(string|!_.ListIterator<T, ?>|W)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @see _.sortByOrder
 * @template W, T
 * @param {(string|W|!_.ListIterator<T, ?>|!Array<(string|W|!_.ListIterator<T, ?>)>)|(string|!Object|!_.ListIterator<T, ?>|!Array<(string|!Object|!_.ListIterator<T, ?>)>)|(string|W|!_.NumericDictionaryIterator<T, ?>|!Array<(string|W|!_.NumericDictionaryIterator<T, ?>)>)|(string|!Object|!_.NumericDictionaryIterator<T, ?>|!Array<(string|!Object|!_.NumericDictionaryIterator<T, ?>)>)|(string|W|!_.DictionaryIterator<T, ?>|!Array<(string|W|!_.DictionaryIterator<T, ?>)>)|(string|!Object|!_.DictionaryIterator<T, ?>|!Array<(string|!Object|!_.DictionaryIterator<T, ?>)>)} iteratees
 * @param {(string|boolean|!Array<(string|boolean)>)=} orders
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.sortByOrder = function(iteratees, orders) {};

/**
 * Performs a deep comparison of each element in a collection to the given properties
 * object, returning an array of all elements that have equivalent property values.
 * @see _.where
 * 
 * @see _.where
 * 
 * @template T, U
 * @param {!Array<T>|!_.List<T>|!_.Dictionary<T>} list
 * @param {U} properties The object of property values to filter by.
 * @return {!Array<T>} A new array of elements that have the given properties.
 * 
 */
_.LoDashStatic.prototype.where = function(list, properties) {};

/**
 * @see _.where
 * 
 * @template U
 * @param {U} properties
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.where = function(properties) {};

/**
 * Gets the number of milliseconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).
 * 
 * @return {number} The number of milliseconds.
 */
_.LoDashStatic.prototype.now = function() {};

/**
 * @see _.now
 * @return {number}
 */
_.LoDashImplicitWrapperBase.prototype.now = function() {};

/**
 * @see _.now
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapperBase.prototype.now = function() {};

/**
 * The opposite of _.before; this method creates a function that invokes func once itâ€™s called n or more times.
 * 
 * @template TFunc
 * @param {number} n The number of calls before func is invoked.
 * @param {TFunc} func The function to restrict.
 * @return {TFunc} Returns the new restricted function.
 */
_.LoDashStatic.prototype.after = function(n, func) {};

/**
 * @see _.after
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashImplicitObjectWrapper<TFunc>}
 */
_.LoDashImplicitWrapper.prototype.after = function(func) {};

/**
 * @see _.after
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashExplicitObjectWrapper<TFunc>}
 */
_.LoDashExplicitWrapper.prototype.after = function(func) {};

/**
 * Creates a function that accepts up to n arguments ignoring any additional arguments.
 * 
 * @template TResult, T
 * @param {!Function|T} func The function to cap arguments for.
 * @param {number=} n The arity cap.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.ary = function(func, n) {};

/**
 * @see _.ary
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.ary = function(n) {};

/**
 * @see _.ary
 * @template TResult
 * @param {number=} n
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.ary = function(n) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {TResult}
 */
_.LoDashStatic.prototype.backflow = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.backflow = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.backflow = function(funcs) {};

/**
 * Creates a function that invokes func, with the this binding and arguments of the created function, while
 * itâ€™s called less than n times. Subsequent calls to the created function return the result of the last func
 * invocation.
 * 
 * @template TFunc
 * @param {number} n The number of calls at which func is no longer invoked.
 * @param {TFunc} func The function to restrict.
 * @return {TFunc} Returns the new restricted function.
 */
_.LoDashStatic.prototype.before = function(n, func) {};

/**
 * @see _.before
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashImplicitObjectWrapper<TFunc>}
 */
_.LoDashImplicitWrapper.prototype.before = function(func) {};

/**
 * @see _.before
 * 
 * @template TFunc
 * @param {TFunc} func
 * @return {!_.LoDashExplicitObjectWrapper<TFunc>}
 */
_.LoDashExplicitWrapper.prototype.before = function(func) {};
/**
 * @record
 * @struct
 */
_.FunctionBind = function() {};
 /** @type {?} */
_.FunctionBind.prototype.placeholder;

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {!_.FunctionBind} */
_.LoDashStatic.prototype.bind;

/**
 * @see _.bind
 * @template TResult
 * @param {?} thisArg
 * @param {...?} partials
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.bind = function(thisArg, partials) {};

/**
 * @see _.bind
 * @template TResult
 * @param {?} thisArg
 * @param {...?} partials
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.bind = function(thisArg, partials) {};

/**
 * Binds methods of an object to the object itself, overwriting the existing method. Method names may be
 * specified as individual arguments or as arrays of method names. If no method names are provided all
 * enumerable function properties, own and inherited, of object are bound.
 * 
 * Note: This method does not set the "length" property of bound functions.
 * 
 * @template T
 * @param {T} object The object to bind and assign the bound methods to.
 * @param {...(string|!Array<string>)} methodNames The object method names to bind, specified as individual method names or arrays of
 * method names.
 * @return {T} Returns object.
 */
_.LoDashStatic.prototype.bindAll = function(object, methodNames) {};

/**
 * @see _.bindAll
 * @param {...(string|!Array<string>)} methodNames
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.bindAll = function(methodNames) {};

/**
 * @see _.bindAll
 * @param {...(string|!Array<string>)} methodNames
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.bindAll = function(methodNames) {};
/**
 * @record
 * @struct
 */
_.FunctionBindKey = function() {};
 /** @type {?} */
_.FunctionBindKey.prototype.placeholder;

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {!_.FunctionBindKey} */
_.LoDashStatic.prototype.bindKey;

/**
 * @see _.bindKey
 * @template TResult
 * @param {?} key
 * @param {...?} partials
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.bindKey = function(key, partials) {};

/**
 * @see _.bindKey
 * @template TResult
 * @param {?} key
 * @param {...?} partials
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.bindKey = function(key, partials) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {TResult}
 */
_.LoDashStatic.prototype.compose = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.compose = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.compose = function(funcs) {};

/**
 * Produces a callback bound to an optional thisArg. If func is a property name the created
 * callback will return the property value for a given element. If func is an object the created
 * callback will return true for elements that contain the equivalent object properties,
 * otherwise it will return false.
 * @see _.createCallback
 * 
 * @param {string|!_.Dictionary<?>} func The value to convert to a callback.
 * @param {?=} thisArg The this binding of the created callback.
 * @param {number=} argCount The number of arguments the callback accepts.
 * @return {function(): ?|function(): boolean} A callback function.
 * 
 */
_.LoDashStatic.prototype.createCallback = function(func, thisArg, argCount) {};

/**
 * @see _.createCallback
 * 
 * @param {?=} thisArg
 * @param {number=} argCount
 * @return {!_.LoDashImplicitObjectWrapper<function(): ?>}
 */
_.LoDashImplicitWrapper.prototype.createCallback = function(thisArg, argCount) {};

/**
 * @see _.createCallback
 * 
 * @param {?=} thisArg
 * @param {number=} argCount
 * @return {!_.LoDashImplicitObjectWrapper<function(): ?>}
 */
_.LoDashImplicitObjectWrapper.prototype.createCallback = function(thisArg, argCount) {};

/**
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * Creates a function that accepts one or more arguments of func that when called either invokes func returning
 * its result, if all func arguments have been provided, or returns a function that accepts one or more of the
 * remaining func arguments, and so on. The arity of func may be specified if func.length is not sufficient.
 * @template T1, R, T2, T3, T4, T5, TResult
 * @param {function(T1): R|function(T1, T2): R|function(T1, T2, T3): R|function(T1, T2, T3, T4): R|function(T1, T2, T3, T4, T5): R|!Function} func The function to curry.
 * @param {number=} arity The arity of func.
 * @return {!_.CurriedFunction1<T1, R>|!_.CurriedFunction2<T1, T2, R>|!_.CurriedFunction3<T1, T2, T3, R>|!_.CurriedFunction4<T1, T2, T3, T4, R>|!_.CurriedFunction5<T1, T2, T3, T4, T5, R>|TResult} Returns the new curried function.
 */
_.LoDashStatic.prototype.curry = function(func, arity) {};
/**
 * @record
 * @struct
 */
_.CurriedFunction1 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction2 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction3 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction4 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.CurriedFunction5 = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/**
 * @see _.curry
 * 
 * @template TResult
 * @param {number=} arity
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.curry = function(arity) {};

/**
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * This method is like _.curry except that arguments are applied to func in the manner of _.partialRight
 * instead of _.partial.
 * @template T1, R, T2, T3, T4, T5, TResult
 * @param {function(T1): R|function(T1, T2): R|function(T1, T2, T3): R|function(T1, T2, T3, T4): R|function(T1, T2, T3, T4, T5): R|!Function} func The function to curry.
 * @param {number=} arity The arity of func.
 * @return {!_.CurriedFunction1<T1, R>|!_.CurriedFunction2<T2, T1, R>|!_.CurriedFunction3<T3, T2, T1, R>|!_.CurriedFunction4<T4, T3, T2, T1, R>|!_.CurriedFunction5<T5, T4, T3, T2, T1, R>|TResult} Returns the new curried function.
 */
_.LoDashStatic.prototype.curryRight = function(func, arity) {};

/**
 * @see _.curryRight
 * 
 * @template TResult
 * @param {number=} arity
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.curryRight = function(arity) {};
/**
 * @record
 * @struct
 */
_.DebounceSettings = function() {};
 /** @type {boolean} */
_.DebounceSettings.prototype.leading;
 /** @type {number} */
_.DebounceSettings.prototype.maxWait;
 /** @type {boolean} */
_.DebounceSettings.prototype.trailing;

/**
 * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since
 * the last time the debounced function was invoked. The debounced function comes with a cancel method to
 * cancel delayed invocations. Provide an options object to indicate that func should be invoked on the
 * leading and/or trailing edge of the wait timeout. Subsequent calls to the debounced function return the
 * result of the last func invocation.
 * 
 * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only
 * if the the debounced function is invoked more than once during the wait timeout.
 * 
 * See David Corbachoâ€™s article for details over the differences between _.debounce and _.throttle.
 * 
 * @template T
 * @param {T} func The function to debounce.
 * @param {number=} wait The number of milliseconds to delay.
 * @param {!_.DebounceSettings=} options The options object.
 * @return {?} Returns the new debounced function.
 */
_.LoDashStatic.prototype.debounce = function(func, wait, options) {};

/**
 * @see _.debounce
 * @param {number=} wait
 * @param {!_.DebounceSettings=} options
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.debounce = function(wait, options) {};

/**
 * @see _.debounce
 * @param {number=} wait
 * @param {!_.DebounceSettings=} options
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.debounce = function(wait, options) {};

/**
 * Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to
 * func when itâ€™s invoked.
 * 
 * @template T
 * @param {T} func The function to defer.
 * @param {...?} args The arguments to invoke the function with.
 * @return {number} Returns the timer id.
 */
_.LoDashStatic.prototype.defer = function(func, args) {};

/**
 * @see _.defer
 * @param {...?} args
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitObjectWrapper.prototype.defer = function(args) {};

/**
 * @see _.defer
 * @param {...?} args
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.defer = function(args) {};

/**
 * Invokes func after wait milliseconds. Any additional arguments are provided to func when itâ€™s invoked.
 * 
 * @template T
 * @param {T} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...?} args The arguments to invoke the function with.
 * @return {number} Returns the timer id.
 */
_.LoDashStatic.prototype.delay = function(func, wait, args) {};

/**
 * @see _.delay
 * @param {number} wait
 * @param {...?} args
 * @return {!_.LoDashImplicitWrapper<number>}
 */
_.LoDashImplicitObjectWrapper.prototype.delay = function(wait, args) {};

/**
 * @see _.delay
 * @param {number} wait
 * @param {...?} args
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.delay = function(wait, args) {};

/**
 * Creates a function that returns the result of invoking the provided functions with the this binding of the
 * created function, where each successive invocation is supplied the return value of the previous.
 * 
 * @template TResult
 * @param {...!Function} funcs Functions to invoke.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.flow = function(funcs) {};

/**
 * @see _.flow
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.flow = function(funcs) {};

/**
 * @see _.flow
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.flow = function(funcs) {};

/**
 * This method is like _.flow except that it creates a function that invokes the provided functions from right
 * to left.
 * 
 * \@alias _.backflow, _.compose
 * 
 * @template TResult
 * @param {...!Function} funcs Functions to invoke.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.flowRight = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.flowRight = function(funcs) {};

/**
 * @see _.flowRight
 * @template TResult
 * @param {...!Function} funcs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.flowRight = function(funcs) {};
/**
 * @record
 * @struct
 */
_.MemoizedFunction = function() {};
 /** @type {!_.MapCache} */
_.MemoizedFunction.prototype.cache;
 /** @type {?} */
_.LoDashStatic.prototype.memoize;

/**
 * @see _.memoize
 * @param {!Function=} resolver
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.memoize = function(resolver) {};

/**
 * @see _.memoize
 * @param {!Function=} resolver
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.memoize = function(resolver) {};

/**
 * Creates a function that runs each argument through a corresponding transform function.
 * 
 * @see _.modArgs
 * @template T, TResult
 * @param {T} func The function to wrap.
 * @param {...!Function|!Array<!Function>} transforms The functions to transform arguments, specified as individual functions or arrays
 * of functions.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.modArgs = function(func, transforms) {};

/**
 * @see _.modArgs
 * @see _.modArgs
 * @template TResult
 * @param {...!Function|!Array<!Function>} transforms
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.modArgs = function(transforms) {};

/**
 * @see _.modArgs
 * @see _.modArgs
 * @template TResult
 * @param {...!Function|!Array<!Function>} transforms
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.modArgs = function(transforms) {};

/**
 * Creates a function that negates the result of the predicate func. The func predicate is invoked with
 * the this binding and arguments of the created function.
 * 
 * @see _.negate
 * @template T, TResult
 * @param {T} predicate The predicate to negate.
 * @return {function(!Array<?>): boolean|TResult} Returns the new function.
 */
_.LoDashStatic.prototype.negate = function(predicate) {};

/**
 * @see _.negate
 * @see _.negate
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(!Array<?>): boolean>|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.negate = function() {};

/**
 * @see _.negate
 * @see _.negate
 * @template TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(!Array<?>): boolean>|!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.negate = function() {};

/**
 * Creates a function that is restricted to invoking func once. Repeat calls to the function return the value
 * of the first call. The func is invoked with the this binding and arguments of the created function.
 * 
 * @template T
 * @param {T} func The function to restrict.
 * @return {T} Returns the new restricted function.
 */
_.LoDashStatic.prototype.once = function(func) {};

/**
 * @see _.once
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.once = function() {};

/**
 * @see _.once
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.once = function() {};
 /** @type {!_.Partial} */
_.LoDashStatic.prototype.partial;

/** @typedef {!_.LoDashStatic} */
_.PH;
/**
 * @record
 * @struct
 */
_.Function0 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Function1 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Function2 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Function3 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Function4 = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.Partial = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */
 /** @type {!_.PartialRight} */
_.LoDashStatic.prototype.partialRight;
/**
 * @record
 * @struct
 */
_.PartialRight = function() {};

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/* TODO: CallSignature: _ */

/**
 * Creates a function that invokes func with arguments arranged according to the specified indexes where the
 * argument value at the first index is provided as the first argument, the argument value at the second index
 * is provided as the second argument, and so on.
 * @see _.rearg
 * @template TResult
 * @param {!Function} func The function to rearrange arguments for.
 * @param {...!Array<number>|number} indexes The arranged argument indexes, specified as individual indexes or arrays of indexes.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.rearg = function(func, indexes) {};

/**
 * @see _.rearg
 * @see _.rearg
 * @template TResult
 * @param {...!Array<number>|number} indexes
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.rearg = function(indexes) {};

/**
 * Creates a function that invokes func with the this binding of the created function and arguments from start
 * and beyond provided as an array.
 * 
 * Note: This method is based on the rest parameter.
 * 
 * @see _.restParam
 * @template TResult, TFunc
 * @param {!Function|TFunc} func The function to apply a rest parameter to.
 * @param {number=} start The start position of the rest parameter.
 * @return {TResult} Returns the new function.
 */
_.LoDashStatic.prototype.restParam = function(func, start) {};

/**
 * @see _.restParam
 * @template TResult
 * @param {number=} start
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.restParam = function(start) {};

/**
 * @see _.restParam
 * @template TResult
 * @param {number=} start
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.restParam = function(start) {};

/**
 * Creates a function that invokes func with the this binding of the created function and an array of arguments
 * much like Function#apply.
 * 
 * Note: This method is based on the spread operator.
 * 
 * @see _.spread
 * @template F, T
 * @param {F|!Function} func The function to spread arguments over.
 * @return {T} Returns the new function.
 */
_.LoDashStatic.prototype.spread = function(func) {};

/**
 * @see _.spread
 * @template T
 * @return {!_.LoDashImplicitObjectWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.spread = function() {};

/**
 * @see _.spread
 * @template T
 * @return {!_.LoDashExplicitObjectWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.spread = function() {};
/**
 * @record
 * @struct
 */
_.ThrottleSettings = function() {};
 /** @type {boolean} */
_.ThrottleSettings.prototype.leading;
 /** @type {boolean} */
_.ThrottleSettings.prototype.trailing;

/**
 * Creates a throttled function that only invokes func at most once per every wait milliseconds. The throttled
 * function comes with a cancel method to cancel delayed invocations. Provide an options object to indicate
 * that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls to
 * the throttled function return the result of the last func call.
 * 
 * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if
 * the the throttled function is invoked more than once during the wait timeout.
 * 
 * @template T
 * @param {T} func The function to throttle.
 * @param {number=} wait The number of milliseconds to throttle invocations to.
 * @param {!_.ThrottleSettings=} options The options object.
 * @return {?} Returns the new throttled function.
 */
_.LoDashStatic.prototype.throttle = function(func, wait, options) {};

/**
 * @see _.throttle
 * @param {number=} wait
 * @param {!_.ThrottleSettings=} options
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.throttle = function(wait, options) {};

/**
 * @see _.throttle
 * @param {number=} wait
 * @param {!_.ThrottleSettings=} options
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.throttle = function(wait, options) {};

/**
 * Creates a function that provides value to the wrapper function as its first argument. Any additional
 * arguments provided to the function are appended to those provided to the wrapper function. The wrapper is
 * invoked with the this binding of the created function.
 * 
 * @see _.wrap
 * @see _.wrap
 * @template V, W, R
 * @param {V|?} value The value to wrap.
 * @param {W|!Function} wrapper The wrapper function.
 * @return {R} Returns the new function.
 */
_.LoDashStatic.prototype.wrap = function(value, wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashImplicitObjectWrapper<R>}
 */
_.LoDashImplicitWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashImplicitObjectWrapper<R>}
 */
_.LoDashImplicitArrayWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashImplicitObjectWrapper<R>}
 */
_.LoDashImplicitObjectWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashExplicitObjectWrapper<R>}
 */
_.LoDashExplicitWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashExplicitObjectWrapper<R>}
 */
_.LoDashExplicitArrayWrapper.prototype.wrap = function(wrapper) {};

/**
 * @see _.wrap
 * @see _.wrap
 * @template W, R
 * @param {W|!Function} wrapper
 * @return {!_.LoDashExplicitObjectWrapper<R>}
 */
_.LoDashExplicitObjectWrapper.prototype.wrap = function(wrapper) {};
/**
 * @record
 * @struct
 */
_.CloneCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Creates a clone of value. If isDeep is true nested objects are cloned, otherwise they are assigned by
 * reference. If customizer is provided it's invoked to produce the cloned values. If customizer returns
 * undefined cloning is handled by the method instead. The customizer is bound to thisArg and invoked with
 * up to three argument; (value [, index|key, object]).
 * 
 * Note: This method is loosely based on the structured clone algorithm. The enumerable properties of
 * arguments objects and objects created by constructors other than Object are cloned to plain Object
 * objects. An empty object is returned for uncloneable values such as functions, DOM nodes, Maps, Sets,
 * and WeakMaps.
 * 
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult, T
 * @param {?|T} value The value to clone.
 * @param {boolean|!_.CloneCustomizer<?, TResult>|!_.CloneCustomizer<T, TResult>=} isDeep_or_customizer Specify a deep clone.
 * @param {!_.CloneCustomizer<?, TResult>|!_.CloneCustomizer<T, TResult>|?=} customizer_or_thisArg The function to customize cloning values.
 * @param {?=} thisArg The this binding of customizer.
 * @return {TResult|T} Returns the cloned value.
 */
_.LoDashStatic.prototype.clone = function(value, isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<T, TResult>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<T, TResult>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {TResult|T}
 */
_.LoDashImplicitWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<!Array<T>, TResult>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<!Array<T>, TResult>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {TResult|!Array<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<T, TResult>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<T, TResult>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {TResult|T}
 */
_.LoDashImplicitObjectWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<T, TResult>|!_.CloneCustomizer<T, !Array<TResult>>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<T, TResult>|!_.CloneCustomizer<T, !Array<TResult>>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitWrapper}
 */
_.LoDashExplicitWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<!Array<T>, TResult>|!_.CloneCustomizer<!Array<T>, !Array<TResult>>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<!Array<T>, TResult>|!_.CloneCustomizer<!Array<T>, !Array<TResult>>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};

/**
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @see _.clone
 * @template TResult
 * @param {boolean|!_.CloneCustomizer<T, TResult>|!_.CloneCustomizer<T, !Array<TResult>>=} isDeep_or_customizer
 * @param {!_.CloneCustomizer<T, TResult>|!_.CloneCustomizer<T, !Array<TResult>>|?=} customizer_or_thisArg
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.clone = function(isDeep_or_customizer, customizer_or_thisArg, thisArg) {};
/**
 * @record
 * @struct
 */
_.CloneDeepCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Creates a deep clone of value. If customizer is provided it's invoked to produce the cloned values.
 * If customizer returns undefined cloning is handled by the method instead. The customizer is bound to
 * thisArg and invoked with up to three argument; (value [, index|key, object]).
 * 
 * Note: This method is loosely based on the structured clone algorithm. The enumerable properties of
 * arguments objects and objects created by constructors other than Object are cloned to plain Object objects.
 * An empty object is returned for uncloneable values such as functions, DOM nodes, Maps, Sets, and WeakMaps.
 * 
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult, T
 * @param {?|T} value The value to deep clone.
 * @param {!_.CloneDeepCustomizer<?, TResult>|!_.CloneDeepCustomizer<T, TResult>=} customizer The function to customize cloning values.
 * @param {?=} thisArg The this binding of customizer.
 * @return {TResult|T} Returns the deep cloned value.
 */
_.LoDashStatic.prototype.cloneDeep = function(value, customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<T, TResult>=} customizer
 * @param {?=} thisArg
 * @return {TResult|T}
 */
_.LoDashImplicitWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<!Array<T>, TResult>=} customizer
 * @param {?=} thisArg
 * @return {TResult|!Array<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<T, TResult>=} customizer
 * @param {?=} thisArg
 * @return {TResult|T}
 */
_.LoDashImplicitObjectWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<T, TResult>|!_.CloneDeepCustomizer<T, !Array<TResult>>=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitWrapper}
 */
_.LoDashExplicitWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<!Array<T>, TResult>|!_.CloneDeepCustomizer<!Array<T>, !Array<TResult>>=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @see _.cloneDeep
 * @template TResult
 * @param {!_.CloneDeepCustomizer<T, TResult>|!_.CloneDeepCustomizer<T, !Array<TResult>>=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<TResult>|!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.cloneDeep = function(customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} value
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashStatic.prototype.eq = function(value, other, customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.eq = function(other, customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.eq = function(other, customizer, thisArg) {};

/**
 * Checks if value is greater than other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is greater than other, else false.
 */
_.LoDashStatic.prototype.gt = function(value, other) {};

/**
 * @see _.gt
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.gt = function(other) {};

/**
 * @see _.gt
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.gt = function(other) {};

/**
 * Checks if value is greater than or equal to other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is greater than or equal to other, else false.
 */
_.LoDashStatic.prototype.gte = function(value, other) {};

/**
 * @see _.gte
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.gte = function(other) {};

/**
 * @see _.gte
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.gte = function(other) {};

/**
 * Checks if value is classified as an arguments object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isArguments = function(value) {};

/**
 * @see _.isArguments
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isArguments = function() {};

/**
 * @see _.isArguments
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isArguments = function() {};

/**
 * Checks if value is classified as an Array object.
 * @template T
 * @param {?=} value The value to check.
 * 
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isArray = function(value) {};

/**
 * @see _.isArray
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isArray = function() {};

/**
 * @see _.isArray
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isArray = function() {};

/**
 * Checks if value is classified as a boolean primitive or object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isBoolean = function(value) {};

/**
 * @see _.isBoolean
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isBoolean = function() {};

/**
 * @see _.isBoolean
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isBoolean = function() {};

/**
 * Checks if value is classified as a Date object.
 * @param {?=} value The value to check.
 * 
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isDate = function(value) {};

/**
 * @see _.isDate
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isDate = function() {};

/**
 * @see _.isDate
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isDate = function() {};

/**
 * Checks if value is a DOM element.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a DOM element, else false.
 */
_.LoDashStatic.prototype.isElement = function(value) {};

/**
 * @see _.isElement
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isElement = function() {};

/**
 * @see _.isElement
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isElement = function() {};

/**
 * Checks if value is empty. A value is considered empty unless itâ€™s an arguments object, array, string, or
 * jQuery-like collection with a length greater than 0 or an object with own enumerable properties.
 * 
 * @param {?=} value The value to inspect.
 * @return {boolean} Returns true if value is empty, else false.
 */
_.LoDashStatic.prototype.isEmpty = function(value) {};

/**
 * @see _.isEmpty
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isEmpty = function() {};

/**
 * @see _.isEmpty
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isEmpty = function() {};
/**
 * @record
 * @struct
 */
_.IsEqualCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Performs a deep comparison between two values to determine if they are equivalent. If customizer is
 * provided itâ€™s invoked to compare values. If customizer returns undefined comparisons are handled by the
 * method instead. The customizer is bound to thisArg and invoked with up to three arguments: (value, other
 * [, index|key]).
 * 
 * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes,
 * and strings. Objects are compared by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are not supported. Provide a customizer function to extend support for comparing other values.
 * 
 * \@alias _.eq
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @param {!_.IsEqualCustomizer=} customizer The function to customize value comparisons.
 * @param {?=} thisArg The this binding of customizer.
 * @return {boolean} Returns true if the values are equivalent, else false.
 */
_.LoDashStatic.prototype.isEqual = function(value, other, customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isEqual = function(other, customizer, thisArg) {};

/**
 * @see _.isEqual
 * @param {?} other
 * @param {!_.IsEqualCustomizer=} customizer
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isEqual = function(other, customizer, thisArg) {};

/**
 * Checks if value is an Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, or URIError
 * object.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is an error object, else false.
 */
_.LoDashStatic.prototype.isError = function(value) {};

/**
 * @see _.isError
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isError = function() {};

/**
 * @see _.isError
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isError = function() {};

/**
 * Checks if value is a finite primitive number.
 * 
 * Note: This method is based on Number.isFinite.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a finite number, else false.
 */
_.LoDashStatic.prototype.isFinite = function(value) {};

/**
 * @see _.isFinite
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isFinite = function() {};

/**
 * @see _.isFinite
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isFinite = function() {};

/**
 * Checks if value is classified as a Function object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isFunction = function(value) {};

/**
 * @see _.isFunction
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isFunction = function() {};

/**
 * @see _.isFunction
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isFunction = function() {};
/**
 * @record
 * @struct
 */
_.isMatchCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Performs a deep comparison between object and source to determine if object contains equivalent property
 * values. If customizer is provided itâ€™s invoked to compare values. If customizer returns undefined
 * comparisons are handled by the method instead. The customizer is bound to thisArg and invoked with three
 * arguments: (value, other, index|key).
 * @param {!Object} object The object to inspect.
 * @param {!Object} source The object of property values to match.
 * @param {!_.isMatchCustomizer=} customizer The function to customize value comparisons.
 * @param {?=} thisArg The this binding of customizer.
 * @return {boolean} Returns true if object is a match, else false.
 */
_.LoDashStatic.prototype.isMatch = function(object, source, customizer, thisArg) {};

/**
 * @see _.isMatch
 * @param {!Object} source
 * @param {!_.isMatchCustomizer=} customizer
 * @param {?=} thisArg
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.isMatch = function(source, customizer, thisArg) {};

/**
 * Checks if value is NaN.
 * 
 * Note: This method is not the same as isNaN which returns true for undefined and other non-numeric values.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is NaN, else false.
 */
_.LoDashStatic.prototype.isNaN = function(value) {};

/**
 * @see _.isNaN
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNaN = function() {};

/**
 * @see _.isNaN
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNaN = function() {};

/**
 * Checks if value is a native function.
 * \@retrun Returns true if value is a native function, else false.
 * @param {?} value The value to check.
 * 
 * @return {boolean}
 */
_.LoDashStatic.prototype.isNative = function(value) {};

/**
 * see _.isNative
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNative = function() {};

/**
 * see _.isNative
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNative = function() {};

/**
 * Checks if value is null.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is null, else false.
 */
_.LoDashStatic.prototype.isNull = function(value) {};

/**
 * see _.isNull
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNull = function() {};

/**
 * see _.isNull
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNull = function() {};

/**
 * Checks if value is classified as a Number primitive or object.
 * 
 * Note: To exclude Infinity, -Infinity, and NaN, which are classified as numbers, use the _.isFinite method.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isNumber = function(value) {};

/**
 * see _.isNumber
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isNumber = function() {};

/**
 * see _.isNumber
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isNumber = function() {};

/**
 * Checks if value is the language type of Object. (e.g. arrays, functions, objects, regexes, new Number(0),
 * and new String(''))
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is an object, else false.
 */
_.LoDashStatic.prototype.isObject = function(value) {};

/**
 * see _.isObject
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isObject = function() {};

/**
 * see _.isObject
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isObject = function() {};

/**
 * Checks if value is a plain object, that is, an object created by the Object constructor or one with a
 * [[Prototype]] of null.
 * 
 * Note: This method assumes objects created by the Object constructor have no inherited enumerable properties.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is a plain object, else false.
 */
_.LoDashStatic.prototype.isPlainObject = function(value) {};

/**
 * see _.isPlainObject
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isPlainObject = function() {};

/**
 * see _.isPlainObject
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isPlainObject = function() {};

/**
 * Checks if value is classified as a RegExp object.
 * @param {?=} value The value to check.
 * 
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isRegExp = function(value) {};

/**
 * see _.isRegExp
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isRegExp = function() {};

/**
 * see _.isRegExp
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isRegExp = function() {};

/**
 * Checks if value is classified as a String primitive or object.
 * 
 * @param {?=} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isString = function(value) {};

/**
 * see _.isString
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isString = function() {};

/**
 * see _.isString
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isString = function() {};

/**
 * Checks if value is classified as a typed array.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is correctly classified, else false.
 */
_.LoDashStatic.prototype.isTypedArray = function(value) {};

/**
 * see _.isTypedArray
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isTypedArray = function() {};

/**
 * see _.isTypedArray
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isTypedArray = function() {};

/**
 * Checks if value is undefined.
 * 
 * @param {?} value The value to check.
 * @return {boolean} Returns true if value is undefined, else false.
 */
_.LoDashStatic.prototype.isUndefined = function(value) {};

/**
 * see _.isUndefined
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.isUndefined = function() {};

/**
 * see _.isUndefined
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.isUndefined = function() {};

/**
 * Checks if value is less than other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is less than other, else false.
 */
_.LoDashStatic.prototype.lt = function(value, other) {};

/**
 * @see _.lt
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.lt = function(other) {};

/**
 * @see _.lt
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.lt = function(other) {};

/**
 * Checks if value is less than or equal to other.
 * 
 * @param {?} value The value to compare.
 * @param {?} other The other value to compare.
 * @return {boolean} Returns true if value is less than or equal to other, else false.
 */
_.LoDashStatic.prototype.lte = function(value, other) {};

/**
 * @see _.lte
 * @param {?} other
 * @return {boolean}
 */
_.LoDashImplicitWrapperBase.prototype.lte = function(other) {};

/**
 * @see _.lte
 * @param {?} other
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.lte = function(other) {};

/**
 * Converts value to an array.
 * 
 * @see _.toArray
 * @see _.toArray
 * @template T, TValue, TResult
 * @param {(!_.List<T>|!_.Dictionary<T>|!_.NumericDictionary<T>)|TValue|?=} value The value to convert.
 * @return {!Array<T>|!Array<TResult>} Returns the converted array.
 */
_.LoDashStatic.prototype.toArray = function(value) {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @return {!_.LoDashImplicitArrayWrapper}
 */
_.LoDashImplicitArrayWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.toArray = function() {};

/**
 * @see _.toArray
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.toArray = function() {};

/**
 * Converts value to a plain object flattening inherited enumerable properties of value to own properties
 * of the plain object.
 * 
 * @template TResult
 * @param {?=} value The value to convert.
 * @return {TResult} Returns the converted plain object.
 */
_.LoDashStatic.prototype.toPlainObject = function(value) {};

/**
 * @see _.toPlainObject
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.toPlainObject = function() {};

/**
 * Adds two numbers.
 * 
 * @param {number} augend The first number to add.
 * @param {number} addend The second number to add.
 * @return {number} Returns the sum.
 */
_.LoDashStatic.prototype.add = function(augend, addend) {};

/**
 * @see _.add
 * @param {number} addend
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.add = function(addend) {};

/**
 * @see _.add
 * @param {number} addend
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.add = function(addend) {};

/**
 * Calculates n rounded up to precision.
 * 
 * @param {number} n The number to round up.
 * @param {number=} precision The precision to round up to.
 * @return {number} Returns the rounded up number.
 */
_.LoDashStatic.prototype.ceil = function(n, precision) {};

/**
 * @see _.ceil
 * @param {number=} precision
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.ceil = function(precision) {};

/**
 * @see _.ceil
 * @param {number=} precision
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.ceil = function(precision) {};

/**
 * Calculates n rounded down to precision.
 * 
 * @param {number} n The number to round down.
 * @param {number=} precision The precision to round down to.
 * @return {number} Returns the rounded down number.
 */
_.LoDashStatic.prototype.floor = function(n, precision) {};

/**
 * @see _.floor
 * @param {number=} precision
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.floor = function(precision) {};

/**
 * @see _.floor
 * @param {number=} precision
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.floor = function(precision) {};

/**
 * Gets the maximum value of collection. If collection is empty or falsey -Infinity is returned. If an iteratee
 * function is provided itâ€™s invoked for each value in collection to generate the criterion by which the value
 * is ranked. The iteratee is bound to thisArg and invoked with three arguments: (value, index, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property value
 * of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.max
 * @see _.max
 * @see _.max
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|string|TObject=} iteratee_or_whereValue The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {T} Returns the maximum value.
 */
_.LoDashStatic.prototype.max = function(collection, iteratee_or_whereValue, thisArg) {};

/**
 * @see _.max
 * @see _.max
 * @see _.max
 * @template TObject
 * @param {!_.ListIterator<T, ?>|string|TObject=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.max = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.max
 * @see _.max
 * @see _.max
 * @template T, TObject
 * @param {(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|TObject=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.max = function(iteratee_or_whereValue, thisArg) {};

/**
 * Gets the minimum value of collection. If collection is empty or falsey Infinity is returned. If an iteratee
 * function is provided itâ€™s invoked for each value in collection to generate the criterion by which the value
 * is ranked. The iteratee is bound to thisArg and invoked with three arguments: (value, index, collection).
 * 
 * If a property name is provided for iteratee the created _.property style callback returns the property value
 * of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for iteratee the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.min
 * @see _.min
 * @see _.min
 * @template T, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<T>|!_.Dictionary<T>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>|string|TObject=} iteratee_or_whereValue The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {T} Returns the minimum value.
 */
_.LoDashStatic.prototype.min = function(collection, iteratee_or_whereValue, thisArg) {};

/**
 * @see _.min
 * @see _.min
 * @see _.min
 * @template TObject
 * @param {!_.ListIterator<T, ?>|string|TObject=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitArrayWrapper.prototype.min = function(iteratee_or_whereValue, thisArg) {};

/**
 * @see _.min
 * @see _.min
 * @see _.min
 * @template T, TObject
 * @param {(!_.ListIterator<T, ?>|!_.DictionaryIterator<T, ?>)|string|TObject=} iteratee_or_whereValue
 * @param {?=} thisArg
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.min = function(iteratee_or_whereValue, thisArg) {};

/**
 * Calculates n rounded to precision.
 * 
 * @param {number} n The number to round.
 * @param {number=} precision The precision to round to.
 * @return {number} Returns the rounded number.
 */
_.LoDashStatic.prototype.round = function(n, precision) {};

/**
 * @see _.round
 * @param {number=} precision
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.round = function(precision) {};

/**
 * @see _.round
 * @param {number=} precision
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.round = function(precision) {};

/**
 * Gets the sum of the values in collection.
 * 
 * @see _.sum
 * 
 * @see _.sum
 * @see _.sum
 * @see _.sum
 * @template T
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.List<!Object>|!_.Dictionary<?>)|(!_.List<T>|!_.Dictionary<T>)|(!_.Dictionary<number>|!_.List<number>)} collection The collection to iterate over.
 * @param {!_.ListIterator<T, number>|!_.DictionaryIterator<T, number>|string=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {number} Returns the sum.
 */
_.LoDashStatic.prototype.sum = function(collection, iteratee, thisArg) {};

/**
 * @see _.sum
 * @see _.sum
 * @see _.sum
 * @param {!_.ListIterator<T, number>|string=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitArrayWrapper.prototype.sum = function(iteratee, thisArg) {};

/**
 * @see _.sum
 * 
 * @see _.sum
 * @see _.sum
 * @template TValue
 * @param {(!_.ListIterator<TValue, number>|!_.DictionaryIterator<TValue, number>)|string=} iteratee
 * @param {?=} thisArg
 * @return {number}
 */
_.LoDashImplicitObjectWrapper.prototype.sum = function(iteratee, thisArg) {};

/**
 * @see _.sum
 * @see _.sum
 * @see _.sum
 * @param {!_.ListIterator<T, number>|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitArrayWrapper.prototype.sum = function(iteratee, thisArg) {};

/**
 * @see _.sum
 * @see _.sum
 * @see _.sum
 * @template TValue
 * @param {(!_.ListIterator<TValue, number>|!_.DictionaryIterator<TValue, number>)|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitObjectWrapper.prototype.sum = function(iteratee, thisArg) {};

/**
 * Checks if n is between start and up to but not including, end. If end is not specified itâ€™s set to start
 * with start then set to 0.
 * 
 * @see _.inRange
 * @param {number} n The number to check.
 * @param {number} start_or_end The start of the range.
 * @param {number=} end The end of the range.
 * @return {boolean} Returns true if n is in the range, else false.
 */
_.LoDashStatic.prototype.inRange = function(n, start_or_end, end) {};

/**
 * @see _.inRange
 * @see _.inRange
 * @param {number} start_or_end
 * @param {number=} end
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.inRange = function(start_or_end, end) {};

/**
 * @see _.inRange
 * @see _.inRange
 * @param {number} start_or_end
 * @param {number=} end
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.inRange = function(start_or_end, end) {};

/**
 * Produces a random number between min and max (inclusive). If only one argument is provided a number between
 * 0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point
 * number is returned instead of an integer.
 * 
 * @see _.random
 * @see _.random
 * @param {number|boolean=} min_or_floating The minimum possible value.
 * @param {number|boolean=} max_or_floating The maximum possible value.
 * @param {boolean=} floating Specify returning a floating-point number.
 * @return {number} Returns the random number.
 */
_.LoDashStatic.prototype.random = function(min_or_floating, max_or_floating, floating) {};

/**
 * @see _.random
 * @see _.random
 * @param {number|boolean=} max_or_floating
 * @param {boolean=} floating
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.random = function(max_or_floating, floating) {};

/**
 * @see _.random
 * @see _.random
 * @param {number|boolean=} max_or_floating
 * @param {boolean=} floating
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.random = function(max_or_floating, floating) {};
/**
 * @record
 * @struct
 */
_.AssignCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Assigns own enumerable properties of source object(s) to the destination object. Subsequent sources
 * overwrite property assignments of previous sources. If customizer is provided itâ€™s invoked to produce the
 * assigned values. The customizer is bound to thisArg and invoked with five arguments:
 * (objectValue, sourceValue, key, object, source).
 * 
 * Note: This method mutates object and is based on Object.assign.
 * 
 * \@alias _.extend
 * 
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TObject, TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {TObject} object The destination object.
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs The source objects.
 * @return {TResult|TObject} The destination object.
 */
_.LoDashStatic.prototype.assign = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.assign = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.assign = function(source_or_source1_or_otherArgs) {};

/**
 * Creates an object that inherits from the given prototype object. If a properties object is provided its own
 * enumerable properties are assigned to the created object.
 * 
 * @template T, U
 * @param {T} prototype The object to inherit from.
 * @param {U=} properties The properties to assign to the object.
 * @return {?} Returns the new object.
 */
_.LoDashStatic.prototype.create = function(prototype, properties) {};

/**
 * @see _.create
 * @template U
 * @param {U=} properties
 * @return {!_.LoDashImplicitObjectWrapper<?>}
 */
_.LoDashImplicitObjectWrapper.prototype.create = function(properties) {};

/**
 * @see _.create
 * @template U
 * @param {U=} properties
 * @return {!_.LoDashExplicitObjectWrapper<?>}
 */
_.LoDashExplicitObjectWrapper.prototype.create = function(properties) {};

/**
 * Assigns own enumerable properties of source object(s) to the destination object for all destination
 * properties that resolve to undefined. Once a property is set, additional values of the same property are
 * ignored.
 * 
 * Note: This method mutates object.
 * 
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @template Obj, TResult, S1, S2, S3, S4
 * @param {Obj|!Object} object The destination object.
 * @param {...!Object|S1} sources_or_source1 The source objects.
 * @return {TResult} The destination object.
 */
_.LoDashStatic.prototype.defaults = function(object, sources_or_source1) {};

/**
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @template S1, TResult, S2, S3, S4
 * @param {...S1|!Object} source1_or_sources
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.defaults = function(source1_or_sources) {};

/**
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @see _.defaults
 * @template S1, TResult, S2, S3, S4
 * @param {...S1|!Object} source1_or_sources
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.defaults = function(source1_or_sources) {};

/**
 * This method is like _.defaults except that it recursively assigns default properties.
 * @template T, TResult
 * @param {T} object The destination object.
 * @param {...?} sources The source objects.
 * @return {TResult} Returns object.
 * 
 */
_.LoDashStatic.prototype.defaultsDeep = function(object, sources) {};

/**
 * @see _.defaultsDeep
 * 
 * @template TResult
 * @param {...?} sources
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.defaultsDeep = function(sources) {};

/**
 * @see assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TObject, TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {TObject} object
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {TResult|TObject}
 */
_.LoDashStatic.prototype.extend = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<TResult>|!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.extend = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.assign
 * @see assign
 * @see assign
 * @see assign
 * @see _.assign
 * @see _.assign
 * @template TSource, TResult, TSource1, TSource2, TSource3, TSource4
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashExplicitObjectWrapper<TResult>|!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.extend = function(source_or_source1_or_otherArgs) {};

/**
 * This method is like _.find except that it returns the key of the first element predicate returns truthy for
 * instead of the element itself.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @template TValues, TObject, TWhere
 * @param {TObject} object The object to search.
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {string} Returns the key of the matched element, else undefined.
 */
_.LoDashStatic.prototype.findKey = function(object, predicate, thisArg) {};

/**
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @template TValues, TWhere
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {string}
 */
_.LoDashImplicitObjectWrapper.prototype.findKey = function(predicate, thisArg) {};

/**
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @see _.findKey
 * @template TValues, TWhere
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.findKey = function(predicate, thisArg) {};

/**
 * This method is like _.findKey except that it iterates over elements of a collection in the opposite order.
 * 
 * If a property name is provided for predicate the created _.property style callback returns the property
 * value of the given element.
 * 
 * If a value is also provided for thisArg the created _.matchesProperty style callback returns true for
 * elements that have a matching property value, else false.
 * 
 * If an object is provided for predicate the created _.matches style callback returns true for elements that
 * have the properties of the given object, else false.
 * 
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @template TValues, TObject, TWhere
 * @param {TObject} object The object to search.
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate The function invoked per iteration.
 * @param {?=} thisArg The this binding of predicate.
 * @return {string} Returns the key of the matched element, else undefined.
 */
_.LoDashStatic.prototype.findLastKey = function(object, predicate, thisArg) {};

/**
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @template TValues, TWhere
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {string}
 */
_.LoDashImplicitObjectWrapper.prototype.findLastKey = function(predicate, thisArg) {};

/**
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @see _.findLastKey
 * @template TValues, TWhere
 * @param {!_.DictionaryIterator<TValues, boolean>|!_.ObjectIterator<?, boolean>|string|TWhere=} predicate
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.findLastKey = function(predicate, thisArg) {};

/**
 * Iterates over own and inherited enumerable properties of an object invoking iteratee for each property. The
 * iteratee is bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may
 * exit iteration early by explicitly returning false.
 * 
 * @see _.forIn
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forIn = function(object, iteratee, thisArg) {};

/**
 * @see _.forIn
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forIn = function(iteratee, thisArg) {};

/**
 * @see _.forIn
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forIn = function(iteratee, thisArg) {};

/**
 * This method is like _.forIn except that it iterates over properties of object in the opposite order.
 * 
 * @see _.forInRight
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forInRight = function(object, iteratee, thisArg) {};

/**
 * @see _.forInRight
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forInRight = function(iteratee, thisArg) {};

/**
 * @see _.forInRight
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forInRight = function(iteratee, thisArg) {};

/**
 * Iterates over own enumerable properties of an object invoking iteratee for each property. The iteratee is
 * bound to thisArg and invoked with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning false.
 * 
 * @see _.forOwn
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forOwn = function(object, iteratee, thisArg) {};

/**
 * @see _.forOwn
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forOwn = function(iteratee, thisArg) {};

/**
 * @see _.forOwn
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forOwn = function(iteratee, thisArg) {};

/**
 * This method is like _.forOwn except that it iterates over properties of object in the opposite order.
 * 
 * @see _.forOwnRight
 * @template T
 * @param {!_.Dictionary<T>|T} object The object to iterate over.
 * @param {!_.DictionaryIterator<T, ?>|!_.ObjectIterator<?, ?>=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>|T} Returns object.
 */
_.LoDashStatic.prototype.forOwnRight = function(object, iteratee, thisArg) {};

/**
 * @see _.forOwnRight
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper}
 */
_.LoDashImplicitObjectWrapper.prototype.forOwnRight = function(iteratee, thisArg) {};

/**
 * @see _.forOwnRight
 * @template TValue
 * @param {!_.DictionaryIterator<TValue, ?>=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.forOwnRight = function(iteratee, thisArg) {};

/**
 * Creates an array of function property names from all enumerable properties, own and inherited, of object.
 * 
 * \@alias _.methods
 * 
 * @template T
 * @param {?} object The object to inspect.
 * @return {!Array<string>} Returns the new array of property names.
 */
_.LoDashStatic.prototype.functions = function(object) {};

/**
 * @see _.functions
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.functions = function() {};

/**
 * @see _.functions
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.functions = function() {};

/**
 * Gets the property value at path of object. If the resolved value is undefined the defaultValue is used
 * in its place.
 * 
 * @see _.get
 * @template TObject, TResult
 * @param {TObject|?} object The object to query.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to get.
 * @param {TResult=} defaultValue The value returned if the resolved value is undefined.
 * @return {TResult} Returns the resolved value.
 */
_.LoDashStatic.prototype.get = function(object, path, defaultValue) {};

/**
 * @see _.get
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {TResult=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {TResult=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {TResult=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.get = function(path, defaultValue) {};

/**
 * @see _.get
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.get = function(path, defaultValue) {};

/**
 * Checks if path is a direct property.
 * 
 * @template T
 * @param {T} object The object to query.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path to check.
 * @return {boolean} Returns true if path is a direct property, else false.
 */
_.LoDashStatic.prototype.has = function(object, path) {};

/**
 * @see _.has
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {boolean}
 */
_.LoDashImplicitObjectWrapper.prototype.has = function(path) {};

/**
 * @see _.has
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitObjectWrapper.prototype.has = function(path) {};

/**
 * Creates an object composed of the inverted keys and values of object. If object contains duplicate values,
 * subsequent values overwrite property assignments of previous values unless multiValue is true.
 * 
 * @see _.invert
 * @template T, TResult
 * @param {T|!Object} object The object to invert.
 * @param {boolean=} multiValue Allow multiple values per key.
 * @return {TResult} Returns the new inverted object.
 */
_.LoDashStatic.prototype.invert = function(object, multiValue) {};

/**
 * @see _.invert
 * @template TResult
 * @param {boolean=} multiValue
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.invert = function(multiValue) {};

/**
 * @see _.invert
 * @template TResult
 * @param {boolean=} multiValue
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.invert = function(multiValue) {};

/**
 * Creates an array of the own enumerable property names of object.
 * 
 * Note: Non-object values are coerced to objects. See the ES spec for more details.
 * 
 * @param {?=} object The object to query.
 * @return {!Array<string>} Returns the array of property names.
 */
_.LoDashStatic.prototype.keys = function(object) {};

/**
 * @see _.keys
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.keys = function() {};

/**
 * @see _.keys
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.keys = function() {};

/**
 * Creates an array of the own and inherited enumerable property names of object.
 * 
 * Note: Non-object values are coerced to objects.
 * 
 * @param {?=} object The object to query.
 * @return {!Array<string>} An array of property names.
 */
_.LoDashStatic.prototype.keysIn = function(object) {};

/**
 * @see _.keysIn
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.keysIn = function() {};

/**
 * @see _.keysIn
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.keysIn = function() {};

/**
 * The opposite of _.mapValues; this method creates an object with the same values as object and keys generated
 * by running each own enumerable property of object through iteratee.
 * 
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template T, TKey, TObject
 * @param {!_.List<T>|!_.Dictionary<T>|(!_.Dictionary<T>|!_.List<T>)} object The object to iterate over.
 * @param {!_.ListIterator<T, TKey>|!_.DictionaryIterator<T, TKey>|TObject|string=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!_.Dictionary<T>} Returns the new mapped object.
 */
_.LoDashStatic.prototype.mapKeys = function(object, iteratee, thisArg) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TKey, TObject
 * @param {!_.ListIterator<T, TKey>|TObject|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashImplicitArrayWrapper.prototype.mapKeys = function(iteratee, thisArg) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TResult, TKey, TObject
 * @param {(!_.ListIterator<TResult, TKey>|!_.DictionaryIterator<TResult, TKey>)|TObject|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>}
 */
_.LoDashImplicitObjectWrapper.prototype.mapKeys = function(iteratee, thisArg) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TKey, TObject
 * @param {!_.ListIterator<T, TKey>|TObject|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<T>>}
 */
_.LoDashExplicitArrayWrapper.prototype.mapKeys = function(iteratee, thisArg) {};

/**
 * @see _.mapKeys
 * @see _.mapKeys
 * @see _.mapKeys
 * @template TResult, TKey, TObject
 * @param {(!_.ListIterator<TResult, TKey>|!_.DictionaryIterator<TResult, TKey>)|TObject|string=} iteratee
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<!_.Dictionary<TResult>>}
 */
_.LoDashExplicitObjectWrapper.prototype.mapKeys = function(iteratee, thisArg) {};

/**
 * Creates an object with the same keys as object and values generated by running each own
 * enumerable property of object through iteratee. The iteratee function is bound to thisArg
 * and invoked with three arguments: (value, key, object).
 * 
 * If a property name is provided iteratee the created "_.property" style callback returns
 * the property value of the given element.
 * 
 * If a value is also provided for thisArg the creted "_.matchesProperty" style callback returns
 * true for elements that have a matching property value, else false;.
 * 
 * If an object is provided for iteratee the created "_.matches" style callback returns true
 * for elements that have the properties of the given object, else false.
 * 
 * @template T, TResult, TMapped
 * @param {!_.Dictionary<T>|T} obj
 * @param {!_.ObjectIterator<T, TResult>|!_.Dictionary<T>|string|!_.ObjectIterator<?, ?>} callback_or_where_or_pluck
 * @param {?=} thisArg
 * @return {!_.Dictionary<TResult>|!_.Dictionary<boolean>|TMapped|T}
 */
_.LoDashStatic.prototype.mapValues = function(obj, callback_or_where_or_pluck, thisArg) {};

/**
 * @see _.mapValues
 * TValue is the type of the property values of T.
 * TResult is the type output by the ObjectIterator function
 * @see _.mapValues
 * TResult is the type of the property specified by pluck.
 * T should be a Dictionary<Dictionary<TResult>>
 * @see _.mapValues
 * TResult is the type of the properties on the object specified by pluck.
 * T should be a Dictionary<Dictionary<Dictionary<TResult>>>
 * @see _.mapValues
 * TResult is the type of the properties of each object in the values of T
 * T should be a Dictionary<Dictionary<TResult>>
 * @template TValue, TResult
 * @param {!_.ObjectIterator<TValue, TResult>|string|!_.Dictionary<TResult>} callback_or_pluck_or_where
 * @param {?|!_.Dictionary<TResult>=} thisArg_or_where
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>|!_.LoDashImplicitArrayWrapper<!_.Dictionary<boolean>>|!_.LoDashImplicitArrayWrapper<boolean>}
 */
_.LoDashImplicitObjectWrapper.prototype.mapValues = function(callback_or_pluck_or_where, thisArg_or_where) {};
/**
 * @record
 * @struct
 */
_.MergeCustomizer = function() {};

/* TODO: CallSignature: _ */

/**
 * Recursively merges own enumerable properties of the source object(s), that donâ€™t resolve to undefined into
 * the destination object. Subsequent sources overwrite property assignments of previous sources. If customizer
 * is provided itâ€™s invoked to produce the merged values of the destination and source properties. If
 * customizer returns undefined merging is handled by the method instead. The customizer is bound to thisArg
 * and invoked with five arguments: (objectValue, sourceValue, key, object, source).
 * 
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @template TObject, TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {TObject|?} object The destination object.
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs The source objects.
 * @return {?|TResult} Returns object.
 */
_.LoDashStatic.prototype.merge = function(object, source_or_source1_or_otherArgs) {};

/**
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @see _.merge
 * @template TSource, TSource1, TSource2, TSource3, TSource4, TResult
 * @param {...TSource|TSource1|?} source_or_source1_or_otherArgs
 * @return {!_.LoDashImplicitObjectWrapper<?>|!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.merge = function(source_or_source1_or_otherArgs) {};

/**
 * @see _.functions
 * @template T
 * @param {?} object
 * @return {!Array<string>}
 */
_.LoDashStatic.prototype.methods = function(object) {};

/**
 * @see _.functions
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashImplicitObjectWrapper.prototype.methods = function() {};

/**
 * @see _.functions
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitObjectWrapper.prototype.methods = function() {};

/**
 * The opposite of _.pick; this method creates an object composed of the own and inherited enumerable
 * properties of object that are not omitted.
 * 
 * @see _.omit
 * @template TResult, T
 * @param {T} object The source object.
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate The function invoked per iteration or property names to omit, specified as individual
 * property names or arrays of property names.
 * @return {TResult} Returns the new object.
 */
_.LoDashStatic.prototype.omit = function(object, predicate) {};

/**
 * @see _.omit
 * @see _.omit
 * @template TResult
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.omit = function(predicate) {};

/**
 * @see _.omit
 * @see _.omit
 * @template TResult
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.omit = function(predicate) {};

/**
 * Creates a two dimensional array of the key-value pairs for object, e.g. [[key1, value1], [key2, value2]].
 * 
 * @template T, TResult
 * @param {T=} object The object to query.
 * @return {!Array<!Array<?>>|!Array<!Array<TResult>>} Returns the new array of key-value pairs.
 */
_.LoDashStatic.prototype.pairs = function(object) {};

/**
 * @see _.pairs
 * @template TResult
 * @return {!_.LoDashImplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashImplicitObjectWrapper.prototype.pairs = function() {};

/**
 * @see _.pairs
 * @template TResult
 * @return {!_.LoDashExplicitArrayWrapper<!Array<TResult>>}
 */
_.LoDashExplicitObjectWrapper.prototype.pairs = function() {};

/**
 * Creates an object composed of the picked object properties. Property names may be specified as individual
 * arguments or as arrays of property names. If predicate is provided itâ€™s invoked for each property of object
 * picking the properties predicate returns truthy for. The predicate is bound to thisArg and invoked with
 * three arguments: (value, key, object).
 * 
 * @see _.pick
 * @template TResult, T
 * @param {T} object The source object.
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate The function invoked per iteration or property names to pick, specified as individual
 * property names or arrays of property names.
 * @return {TResult} Returns the new object.
 */
_.LoDashStatic.prototype.pick = function(object, predicate) {};

/**
 * @see _.pick
 * @see _.pick
 * @template TResult
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.pick = function(predicate) {};

/**
 * @see _.pick
 * @see _.pick
 * @template TResult
 * @param {...!_.ObjectIterator<?, boolean>|(!_.StringRepresentable|!Array<!_.StringRepresentable>)} predicate
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.pick = function(predicate) {};

/**
 * This method is like _.get except that if the resolved value is a function itâ€™s invoked with the this binding
 * of its parent object and its result is returned.
 * 
 * @see _.result
 * @template TObject, TResult
 * @param {TObject|?} object The object to query.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to resolve.
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue The value returned if the resolved value is undefined.
 * @return {TResult} Returns the resolved value.
 */
_.LoDashStatic.prototype.result = function(object, path, defaultValue) {};

/**
 * @see _.result
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitArrayWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {(TResult|function(!Array<?>): TResult)=} defaultValue
 * @return {TResult}
 */
_.LoDashImplicitObjectWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.result = function(path, defaultValue) {};

/**
 * @see _.result
 * @template TResultWrapper
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?=} defaultValue
 * @return {TResultWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.result = function(path, defaultValue) {};

/**
 * Sets the property value of path on object. If a portion of path does not exist itâ€™s created.
 * 
 * @see _.set
 * @see _.set
 * @template TResult, V, O
 * @param {!Object|O} object The object to augment.
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to set.
 * @param {?|V} value The value to set.
 * @return {TResult} Returns object.
 */
_.LoDashStatic.prototype.set = function(object, path, value) {};

/**
 * @see _.set
 * @see _.set
 * @template TResult, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|V} value
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.set = function(path, value) {};

/**
 * @see _.set
 * @see _.set
 * @template TResult, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path
 * @param {?|V} value
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.set = function(path, value) {};

/**
 * An alternative to _.reduce; this method transforms object to a new accumulator object which is the result of
 * running each of its own enumerable properties through iteratee, with each invocation potentially mutating
 * the accumulator object. The iteratee is bound to thisArg and invoked with four arguments: (accumulator,
 * value, key, object). Iteratee functions may exit iteration early by explicitly returning false.
 * 
 * @see _.transform
 * @see _.transform
 * @see _.transform
 * @template T, TResult
 * @param {!Array<T>|!_.Dictionary<T>} object The object to iterate over.
 * @param {!_.MemoVoidArrayIterator<T, !Array<TResult>>|!_.MemoVoidArrayIterator<T, !_.Dictionary<TResult>>|!_.MemoVoidDictionaryIterator<T, !_.Dictionary<TResult>>|!_.MemoVoidDictionaryIterator<T, !Array<TResult>>=} iteratee The function invoked per iteration.
 * @param {!Array<TResult>|!_.Dictionary<TResult>=} accumulator The custom accumulator value.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<TResult>|!_.Dictionary<TResult>} Returns the accumulated value.
 */
_.LoDashStatic.prototype.transform = function(object, iteratee, accumulator, thisArg) {};

/**
 * @see _.transform
 * @see _.transform
 * @template TResult
 * @param {!_.MemoVoidArrayIterator<T, !Array<TResult>>|!_.MemoVoidArrayIterator<T, !_.Dictionary<TResult>>=} iteratee
 * @param {!Array<TResult>|!_.Dictionary<TResult>=} accumulator
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>}
 */
_.LoDashImplicitArrayWrapper.prototype.transform = function(iteratee, accumulator, thisArg) {};

/**
 * @see _.transform
 * @see _.transform
 * @template T, TResult
 * @param {!_.MemoVoidDictionaryIterator<T, !_.Dictionary<TResult>>|!_.MemoVoidDictionaryIterator<T, !Array<TResult>>=} iteratee
 * @param {!_.Dictionary<TResult>|!Array<TResult>=} accumulator
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<!_.Dictionary<TResult>>|!_.LoDashImplicitArrayWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.transform = function(iteratee, accumulator, thisArg) {};

/**
 * Creates an array of the own enumerable property values of object.
 * 
 * @template T
 * @param {?=} object The object to query.
 * @return {!Array<T>} Returns an array of property values.
 */
_.LoDashStatic.prototype.values = function(object) {};

/**
 * @see _.values
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.values = function() {};

/**
 * @see _.values
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.values = function() {};

/**
 * Creates an array of the own and inherited enumerable property values of object.
 * 
 * @template T
 * @param {?=} object The object to query.
 * @return {!Array<T>} Returns the array of property values.
 */
_.LoDashStatic.prototype.valuesIn = function(object) {};

/**
 * @see _.valuesIn
 * @template T
 * @return {!_.LoDashImplicitArrayWrapper<T>}
 */
_.LoDashImplicitObjectWrapper.prototype.valuesIn = function() {};

/**
 * @see _.valuesIn
 * @template T
 * @return {!_.LoDashExplicitArrayWrapper<T>}
 */
_.LoDashExplicitObjectWrapper.prototype.valuesIn = function() {};

/**
 * Converts string to camel case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the camel cased string.
 */
_.LoDashStatic.prototype.camelCase = function(string) {};

/**
 * @see _.camelCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.camelCase = function() {};

/**
 * @see _.camelCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.camelCase = function() {};

/**
 * @param {string=} string
 * @return {string}
 */
_.LoDashStatic.prototype.capitalize = function(string) {};

/**
 * @see _.capitalize
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.capitalize = function() {};

/**
 * @see _.capitalize
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.capitalize = function() {};

/**
 * Deburrs string by converting latin-1 supplementary letters to basic latin letters and removing combining
 * diacritical marks.
 * 
 * @param {string=} string The string to deburr.
 * @return {string} Returns the deburred string.
 */
_.LoDashStatic.prototype.deburr = function(string) {};

/**
 * @see _.deburr
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.deburr = function() {};

/**
 * @see _.deburr
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.deburr = function() {};

/**
 * Checks if string ends with the given target string.
 * 
 * @param {string=} string The string to search.
 * @param {string=} target The string to search for.
 * @param {number=} position The position to search from.
 * @return {boolean} Returns true if string ends with target, else false.
 */
_.LoDashStatic.prototype.endsWith = function(string, target, position) {};

/**
 * @see _.endsWith
 * @param {string=} target
 * @param {number=} position
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.endsWith = function(target, position) {};

/**
 * @see _.endsWith
 * @param {string=} target
 * @param {number=} position
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.endsWith = function(target, position) {};

/**
 * Converts the characters "&", "<", ">", '"', "'", and "`", in string to their corresponding HTML entities.
 * 
 * Note: No other characters are escaped. To escape additional characters use a third-party library like he.
 * 
 * Though the ">" character is escaped for symmetry, characters like ">" and "/" donâ€™t need escaping in HTML
 * and have no special meaning unless they're part of a tag or unquoted attribute value. See Mathias Bynensâ€™s
 * article (under "semi-related fun fact") for more details.
 * 
 * Backticks are escaped because in Internet Explorer < 9, they can break out of attribute values or HTML
 * comments. See #59, #102, #108, and #133 of the HTML5 Security Cheatsheet for more details.
 * 
 * When working with HTML you should always quote attribute values to reduce XSS vectors.
 * 
 * @param {string=} string The string to escape.
 * @return {string} Returns the escaped string.
 */
_.LoDashStatic.prototype.escape = function(string) {};

/**
 * @see _.escape
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.escape = function() {};

/**
 * @see _.escape
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.escape = function() {};

/**
 * Escapes the RegExp special characters "\", "/", "^", "$", ".", "|", "?", "*", "+", "(", ")", "[", "]",
 * "{" and "}" in string.
 * 
 * @param {string=} string The string to escape.
 * @return {string} Returns the escaped string.
 */
_.LoDashStatic.prototype.escapeRegExp = function(string) {};

/**
 * @see _.escapeRegExp
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.escapeRegExp = function() {};

/**
 * @see _.escapeRegExp
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.escapeRegExp = function() {};

/**
 * Converts string to kebab case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the kebab cased string.
 */
_.LoDashStatic.prototype.kebabCase = function(string) {};

/**
 * @see _.kebabCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.kebabCase = function() {};

/**
 * @see _.kebabCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.kebabCase = function() {};

/**
 * Pads string on the left and right sides if itâ€™s shorter than length. Padding characters are truncated if
 * they canâ€™t be evenly divided by length.
 * 
 * @param {string=} string The string to pad.
 * @param {number=} length The padding length.
 * @param {string=} chars The string used as padding.
 * @return {string} Returns the padded string.
 */
_.LoDashStatic.prototype.pad = function(string, length, chars) {};

/**
 * @see _.pad
 * @param {number=} length
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.pad = function(length, chars) {};

/**
 * @see _.pad
 * @param {number=} length
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.pad = function(length, chars) {};

/**
 * Pads string on the left side if itâ€™s shorter than length. Padding characters are truncated if they exceed
 * length.
 * 
 * @param {string=} string The string to pad.
 * @param {number=} length The padding length.
 * @param {string=} chars The string used as padding.
 * @return {string} Returns the padded string.
 */
_.LoDashStatic.prototype.padLeft = function(string, length, chars) {};

/**
 * @see _.padLeft
 * @param {number=} length
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.padLeft = function(length, chars) {};

/**
 * @see _.padLeft
 * @param {number=} length
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.padLeft = function(length, chars) {};

/**
 * Pads string on the right side if itâ€™s shorter than length. Padding characters are truncated if they exceed
 * length.
 * 
 * @param {string=} string The string to pad.
 * @param {number=} length The padding length.
 * @param {string=} chars The string used as padding.
 * @return {string} Returns the padded string.
 */
_.LoDashStatic.prototype.padRight = function(string, length, chars) {};

/**
 * @see _.padRight
 * @param {number=} length
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.padRight = function(length, chars) {};

/**
 * @see _.padRight
 * @param {number=} length
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.padRight = function(length, chars) {};

/**
 * Converts string to an integer of the specified radix. If radix is undefined or 0, a radix of 10 is used
 * unless value is a hexadecimal, in which case a radix of 16 is used.
 * 
 * Note: This method aligns with the ES5 implementation of parseInt.
 * 
 * @param {string} string The string to convert.
 * @param {number=} radix The radix to interpret value by.
 * @return {number} Returns the converted integer.
 */
_.LoDashStatic.prototype.parseInt = function(string, radix) {};

/**
 * @see _.parseInt
 * @param {number=} radix
 * @return {number}
 */
_.LoDashImplicitWrapper.prototype.parseInt = function(radix) {};

/**
 * @see _.parseInt
 * @param {number=} radix
 * @return {!_.LoDashExplicitWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.parseInt = function(radix) {};

/**
 * Repeats the given string n times.
 * 
 * @param {string=} string The string to repeat.
 * @param {number=} n The number of times to repeat the string.
 * @return {string} Returns the repeated string.
 */
_.LoDashStatic.prototype.repeat = function(string, n) {};

/**
 * @see _.repeat
 * @param {number=} n
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.repeat = function(n) {};

/**
 * @see _.repeat
 * @param {number=} n
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.repeat = function(n) {};

/**
 * Converts string to snake case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the snake cased string.
 */
_.LoDashStatic.prototype.snakeCase = function(string) {};

/**
 * @see _.snakeCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.snakeCase = function() {};

/**
 * @see _.snakeCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.snakeCase = function() {};

/**
 * Splits string by separator.
 * 
 * Note: This method is based on String#split.
 * 
 * @param {(string|!RegExp)=} separator The separator pattern to split by.
 * @param {number=} limit The length to truncate results to.
 * @return {!_.LoDashImplicitArrayWrapper<string>} Returns the new array with the terms splitted.
 */
_.LoDashImplicitWrapper.prototype.split = function(separator, limit) {};

/**
 * @see _.split
 * @param {(string|!RegExp)=} separator
 * @param {number=} limit
 * @return {!_.LoDashImplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.split = function(separator, limit) {};

/**
 * Converts string to start case.
 * 
 * @param {string=} string The string to convert.
 * @return {string} Returns the start cased string.
 */
_.LoDashStatic.prototype.startCase = function(string) {};

/**
 * @see _.startCase
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.startCase = function() {};

/**
 * @see _.startCase
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.startCase = function() {};

/**
 * Checks if string starts with the given target string.
 * 
 * @param {string=} string The string to search.
 * @param {string=} target The string to search for.
 * @param {number=} position The position to search from.
 * @return {boolean} Returns true if string starts with target, else false.
 */
_.LoDashStatic.prototype.startsWith = function(string, target, position) {};

/**
 * @see _.startsWith
 * @param {string=} target
 * @param {number=} position
 * @return {boolean}
 */
_.LoDashImplicitWrapper.prototype.startsWith = function(target, position) {};

/**
 * @see _.startsWith
 * @param {string=} target
 * @param {number=} position
 * @return {!_.LoDashExplicitWrapper<boolean>}
 */
_.LoDashExplicitWrapper.prototype.startsWith = function(target, position) {};
/**
 * @extends {_.TemplateSettings}
 * @record
 * @struct
 */
_.TemplateOptions = function() {};
 /** @type {string} */
_.TemplateOptions.prototype.sourceURL;
/**
 * @record
 * @struct
 */
_.TemplateExecutor = function() {};

/* TODO: CallSignature: _ */
 /** @type {string} */
_.TemplateExecutor.prototype.source;

/**
 * Creates a compiled template function that can interpolate data properties in "interpolate" delimiters,
 * HTML-escape interpolated data properties in "escape" delimiters, and execute JavaScript in "evaluate"
 * delimiters. Data properties may be accessed as free variables in the template. If a setting object is
 * provided it takes precedence over _.templateSettings values.
 * 
 * Note: In the development build _.template utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) for easier
 * debugging.
 * 
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 * 
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 * 
 * @param {string} string The template string.
 * @param {!_.TemplateOptions=} options The options object.
 * @return {!_.TemplateExecutor} Returns the compiled template function.
 */
_.LoDashStatic.prototype.template = function(string, options) {};

/**
 * @see _.template
 * @param {!_.TemplateOptions=} options
 * @return {!_.TemplateExecutor}
 */
_.LoDashImplicitWrapper.prototype.template = function(options) {};

/**
 * @see _.template
 * @param {!_.TemplateOptions=} options
 * @return {!_.LoDashExplicitObjectWrapper<!_.TemplateExecutor>}
 */
_.LoDashExplicitWrapper.prototype.template = function(options) {};

/**
 * Removes leading and trailing whitespace or specified characters from string.
 * 
 * @param {string=} string The string to trim.
 * @param {string=} chars The characters to trim.
 * @return {string} Returns the trimmed string.
 */
_.LoDashStatic.prototype.trim = function(string, chars) {};

/**
 * @see _.trim
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trim = function(chars) {};

/**
 * @see _.trim
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trim = function(chars) {};

/**
 * Removes leading whitespace or specified characters from string.
 * 
 * @param {string=} string The string to trim.
 * @param {string=} chars The characters to trim.
 * @return {string} Returns the trimmed string.
 */
_.LoDashStatic.prototype.trimLeft = function(string, chars) {};

/**
 * @see _.trimLeft
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trimLeft = function(chars) {};

/**
 * @see _.trimLeft
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trimLeft = function(chars) {};

/**
 * Removes trailing whitespace or specified characters from string.
 * 
 * @param {string=} string The string to trim.
 * @param {string=} chars The characters to trim.
 * @return {string} Returns the trimmed string.
 */
_.LoDashStatic.prototype.trimRight = function(string, chars) {};

/**
 * @see _.trimRight
 * @param {string=} chars
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trimRight = function(chars) {};

/**
 * @see _.trimRight
 * @param {string=} chars
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trimRight = function(chars) {};
/**
 * @record
 * @struct
 */
_.TruncOptions = function() {};
 /** @type {number} */
_.TruncOptions.prototype.length;
 /** @type {string} */
_.TruncOptions.prototype.omission;
 /** @type {(string|!RegExp)} */
_.TruncOptions.prototype.separator;

/**
 * Truncates string if itâ€™s longer than the given maximum string length. The last characters of the truncated
 * string are replaced with the omission string which defaults to "â€¦".
 * 
 * @param {string=} string The string to truncate.
 * @param {(number|!_.TruncOptions)=} options The options object or maximum string length.
 * @return {string} Returns the truncated string.
 */
_.LoDashStatic.prototype.trunc = function(string, options) {};

/**
 * @see _.trunc
 * @param {(number|!_.TruncOptions)=} options
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.trunc = function(options) {};

/**
 * @see _.trunc
 * @param {(number|!_.TruncOptions)=} options
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.trunc = function(options) {};

/**
 * The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;, and &#96;
 * in string to their corresponding characters.
 * 
 * @param {string=} string The string to unescape.
 * @return {string} Returns the unescaped string.
 */
_.LoDashStatic.prototype.unescape = function(string) {};

/**
 * @see _.unescape
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.unescape = function() {};

/**
 * @see _.unescape
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.unescape = function() {};

/**
 * Splits string into an array of its words.
 * 
 * @param {string=} string The string to inspect.
 * @param {(string|!RegExp)=} pattern The pattern to match words.
 * @return {!Array<string>} Returns the words of string.
 */
_.LoDashStatic.prototype.words = function(string, pattern) {};

/**
 * @see _.words
 * @param {(string|!RegExp)=} pattern
 * @return {!Array<string>}
 */
_.LoDashImplicitWrapper.prototype.words = function(pattern) {};

/**
 * @see _.words
 * @param {(string|!RegExp)=} pattern
 * @return {!_.LoDashExplicitArrayWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.words = function(pattern) {};

/**
 * Attempts to invoke func, returning either the result or the caught error object. Any additional arguments
 * are provided to func when itâ€™s invoked.
 * 
 * @template TResult
 * @param {function(!Array<?>): TResult} func The function to attempt.
 * @param {...?} args
 * @return {(!Error|TResult)} Returns the func result or error object.
 */
_.LoDashStatic.prototype.attempt = function(func, args) {};

/**
 * @see _.attempt
 * @template TResult
 * @param {...?} args
 * @return {(!Error|TResult)}
 */
_.LoDashImplicitObjectWrapper.prototype.attempt = function(args) {};

/**
 * @see _.attempt
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<(!Error|TResult)>}
 */
_.LoDashExplicitObjectWrapper.prototype.attempt = function(args) {};

/**
 * Creates a function that invokes func with the this binding of thisArg and arguments of the created function.
 * If func is a property name the created callback returns the property value for a given element. If func is
 * an object the created callback returns true for elements that contain the equivalent object properties,
 * otherwise it returns false.
 * 
 * \@result Returns the callback.
 * @see _.callback
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {!Function|string|!Object=} func The value to convert to a callback.
 * @param {?=} thisArg The this binding of func.
 * @return {function(!Array<?>): TResult|function(?): TResult|function(?): boolean|function(TResult): TResult}
 */
_.LoDashStatic.prototype.callback = function(func, thisArg) {};

/**
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitWrapper.prototype.callback = function(thisArg) {};

/**
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<function(?): boolean>|!_.LoDashImplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.callback = function(thisArg) {};

/**
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitWrapper.prototype.callback = function(thisArg) {};

/**
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<function(?): boolean>|!_.LoDashExplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.callback = function(thisArg) {};

/**
 * Creates a function that returns value.
 * 
 * @template T
 * @param {T} value The value to return from the new function.
 * @return {function(): T} Returns the new function.
 */
_.LoDashStatic.prototype.constant = function(value) {};

/**
 * @see _.constant
 * @template TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(): TResult>}
 */
_.LoDashImplicitWrapperBase.prototype.constant = function() {};

/**
 * @see _.constant
 * @template TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(): TResult>}
 */
_.LoDashExplicitWrapperBase.prototype.constant = function() {};

/**
 * This method returns the first argument provided to it.
 * 
 * @template T
 * @param {T=} value Any value.
 * @return {T} Returns value.
 */
_.LoDashStatic.prototype.identity = function(value) {};

/**
 * @see _.identity
 * @return {T}
 */
_.LoDashImplicitWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {!Array<T>}
 */
_.LoDashImplicitArrayWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {T}
 */
_.LoDashImplicitObjectWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {!_.LoDashExplicitWrapper}
 */
_.LoDashExplicitWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {!_.LoDashExplicitArrayWrapper}
 */
_.LoDashExplicitArrayWrapper.prototype.identity = function() {};

/**
 * @see _.identity
 * @return {!_.LoDashExplicitObjectWrapper}
 */
_.LoDashExplicitObjectWrapper.prototype.identity = function() {};

/**
 * @see _.callback
 * @see _.callback
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {!Function|string|!Object=} func
 * @param {?=} thisArg
 * @return {function(!Array<?>): TResult|function(?): TResult|function(?): boolean|function(TResult): TResult}
 */
_.LoDashStatic.prototype.iteratee = function(func, thisArg) {};

/**
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitWrapper.prototype.iteratee = function(thisArg) {};

/**
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashImplicitObjectWrapper<function(?): boolean>|!_.LoDashImplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.iteratee = function(thisArg) {};

/**
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitWrapper.prototype.iteratee = function(thisArg) {};

/**
 * @see _.callback
 * @see _.callback
 * @template TResult
 * @param {?=} thisArg
 * @return {!_.LoDashExplicitObjectWrapper<function(?): boolean>|!_.LoDashExplicitObjectWrapper<function(!Array<?>): TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.iteratee = function(thisArg) {};

/**
 * Creates a function that performs a deep comparison between a given object and source, returning true if the
 * given object has equivalent property values, else false.
 * 
 * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and
 * strings. Objects are compared by their own, not inherited, enumerable properties. For comparing a single own
 * or inherited property value see _.matchesProperty.
 * 
 * @see _.matches
 * @template T, V
 * @param {T} source The object of property values to match.
 * @return {function(?): boolean|function(V): boolean} Returns the new function.
 */
_.LoDashStatic.prototype.matches = function(source) {};

/**
 * @see _.matches
 * @template V
 * @return {!_.LoDashImplicitObjectWrapper<function(V): boolean>}
 */
_.LoDashImplicitWrapperBase.prototype.matches = function() {};

/**
 * @see _.matches
 * @template V
 * @return {!_.LoDashExplicitObjectWrapper<function(V): boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.matches = function() {};

/**
 * Creates a function that compares the property value of path on a given object to value.
 * 
 * Note: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and
 * strings. Objects are compared by their own, not inherited, enumerable properties.
 * 
 * @see _.matchesProperty
 * @template T, V
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to get.
 * @param {T} srcValue The value to match.
 * @return {function(?): boolean|function(V): boolean} Returns the new function.
 */
_.LoDashStatic.prototype.matchesProperty = function(path, srcValue) {};

/**
 * @see _.matchesProperty
 * @see _.matchesProperty
 * @template SrcValue, Value
 * @param {SrcValue} srcValue
 * @return {!_.LoDashImplicitObjectWrapper<function(?): boolean>|!_.LoDashImplicitObjectWrapper<function(Value): boolean>}
 */
_.LoDashImplicitWrapperBase.prototype.matchesProperty = function(srcValue) {};

/**
 * @see _.matchesProperty
 * @see _.matchesProperty
 * @template SrcValue, Value
 * @param {SrcValue} srcValue
 * @return {!_.LoDashExplicitObjectWrapper<function(?): boolean>|!_.LoDashExplicitObjectWrapper<function(Value): boolean>}
 */
_.LoDashExplicitWrapperBase.prototype.matchesProperty = function(srcValue) {};

/**
 * Creates a function that invokes the method at path on a given object. Any additional arguments are provided
 * to the invoked method.
 * 
 * @see _.method
 * @template TObject, TResult
 * @param {(string|!Array<!_.StringRepresentable>)} path The path of the method to invoke.
 * @param {...?} args The arguments to invoke the method with.
 * @return {function(TObject): TResult|function(?): TResult} Returns the new function.
 */
_.LoDashStatic.prototype.method = function(path, args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitObjectWrapper<function(TObject): TResult>|!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitWrapper.prototype.method = function(args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitObjectWrapper<function(TObject): TResult>|!_.LoDashImplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.method = function(args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<function(TObject): TResult>|!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitWrapper.prototype.method = function(args) {};

/**
 * @see _.method
 * @see _.method
 * @template TObject, TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<function(TObject): TResult>|!_.LoDashExplicitObjectWrapper<function(?): TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.method = function(args) {};

/**
 * The opposite of _.method; this method creates a function that invokes the method at a given path on object.
 * Any additional arguments are provided to the invoked method.
 * 
 * @see _.methodOf
 * @template TObject, TResult
 * @param {TObject|!Object} object The object to query.
 * @param {...?} args The arguments to invoke the method with.
 * @return {function((!_.StringRepresentable|!Array<!_.StringRepresentable>)): TResult} Returns the new function.
 */
_.LoDashStatic.prototype.methodOf = function(object, args) {};

/**
 * @see _.methodOf
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashImplicitObjectWrapper<function((!_.StringRepresentable|!Array<!_.StringRepresentable>)): TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.methodOf = function(args) {};

/**
 * @see _.methodOf
 * @template TResult
 * @param {...?} args
 * @return {!_.LoDashExplicitObjectWrapper<function((!_.StringRepresentable|!Array<!_.StringRepresentable>)): TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.methodOf = function(args) {};
/**
 * @record
 * @struct
 */
_.MixinOptions = function() {};
 /** @type {boolean} */
_.MixinOptions.prototype.chain;

/**
 * Adds all own enumerable function properties of a source object to the destination object. If object is a
 * function then methods are added to its prototype as well.
 * 
 * Note: Use _.runInContext to create a pristine lodash function to avoid conflicts caused by modifying
 * the original.
 * 
 * @see _.mixin
 * @template TResult, TObject
 * @param {TObject|!_.Dictionary<!Function>} object_or_source The destination object.
 * @param {!_.Dictionary<!Function>|!_.MixinOptions=} source_or_options The object of functions to add.
 * @param {!_.MixinOptions=} options The options object.
 * @return {TResult} Returns object.
 */
_.LoDashStatic.prototype.mixin = function(object_or_source, source_or_options, options) {};

/**
 * @see _.mixin
 * @see _.mixin
 * @template TResult
 * @param {!_.Dictionary<!Function>|!_.MixinOptions=} source_or_options
 * @param {!_.MixinOptions=} options
 * @return {!_.LoDashImplicitObjectWrapper<TResult>}
 */
_.LoDashImplicitObjectWrapper.prototype.mixin = function(source_or_options, options) {};

/**
 * @see _.mixin
 * @see _.mixin
 * @template TResult
 * @param {!_.Dictionary<!Function>|!_.MixinOptions=} source_or_options
 * @param {!_.MixinOptions=} options
 * @return {!_.LoDashExplicitObjectWrapper<TResult>}
 */
_.LoDashExplicitObjectWrapper.prototype.mixin = function(source_or_options, options) {};

/**
 * Reverts the _ variable to its previous value and returns a reference to the lodash function.
 * 
 * @return {!_.LoDashStatic} Returns the lodash function.
 */
_.LoDashStatic.prototype.noConflict = function() {};

/**
 * @see _.noConflict
 * @return {!_.LoDashStatic}
 */
_.LoDashImplicitWrapperBase.prototype.noConflict = function() {};

/**
 * @see _.noConflict
 * @return {!_.LoDashExplicitObjectWrapper<!_.LoDashStatic>}
 */
_.LoDashExplicitWrapperBase.prototype.noConflict = function() {};

/**
 * A no-operation function that returns undefined regardless of the arguments it receives.
 * 
 * @param {...?} args
 * @return {void} undefined
 */
_.LoDashStatic.prototype.noop = function(args) {};

/**
 * @see _.noop
 * @param {...?} args
 * @return {void}
 */
_.LoDashImplicitWrapperBase.prototype.noop = function(args) {};

/**
 * @see _.noop
 * @param {...?} args
 * @return {!_.LoDashExplicitWrapper<void>}
 */
_.LoDashExplicitWrapperBase.prototype.noop = function(args) {};

/**
 * Creates a function that returns the property value at path on a given object.
 * 
 * @template TObj, TResult
 * @param {(!_.StringRepresentable|!Array<!_.StringRepresentable>)} path The path of the property to get.
 * @return {function(TObj): TResult} Returns the new function.
 */
_.LoDashStatic.prototype.property = function(path) {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashImplicitWrapper.prototype.property = function() {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashImplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashImplicitArrayWrapper.prototype.property = function() {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashExplicitWrapper.prototype.property = function() {};

/**
 * @see _.property
 * @template TObj, TResult
 * @return {!_.LoDashExplicitObjectWrapper<function(TObj): TResult>}
 */
_.LoDashExplicitArrayWrapper.prototype.property = function() {};

/**
 * The opposite of _.property; this method creates a function that returns the property value at a given path
 * on object.
 * 
 * @template T
 * @param {T} object The object to query.
 * @return {function((string|!Array<string>)): ?} Returns the new function.
 */
_.LoDashStatic.prototype.propertyOf = function(object) {};

/**
 * @see _.propertyOf
 * @return {!_.LoDashImplicitObjectWrapper<function((string|!Array<string>)): ?>}
 */
_.LoDashImplicitObjectWrapper.prototype.propertyOf = function() {};

/**
 * @see _.propertyOf
 * @return {!_.LoDashExplicitObjectWrapper<function((string|!Array<string>)): ?>}
 */
_.LoDashExplicitObjectWrapper.prototype.propertyOf = function() {};

/**
 * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.
 * If end is not specified itâ€™s set to start with start then set to 0. If end is less than start a zero-length
 * range is created unless a negative step is specified.
 * 
 * @see _.range
 * @param {number} start_or_end The start of the range.
 * @param {number=} end_or_step The end of the range.
 * @param {number=} step The value to increment or decrement by.
 * @return {!Array<number>} Returns a new range array.
 */
_.LoDashStatic.prototype.range = function(start_or_end, end_or_step, step) {};

/**
 * @see _.range
 * @param {number=} end
 * @param {number=} step
 * @return {!_.LoDashImplicitArrayWrapper<number>}
 */
_.LoDashImplicitWrapper.prototype.range = function(end, step) {};

/**
 * @see _.range
 * @param {number=} end
 * @param {number=} step
 * @return {!_.LoDashExplicitArrayWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.range = function(end, step) {};

/**
 * Create a new pristine lodash function using the given context object.
 * 
 * @param {!Object=} context The context object.
 * @return {!_.LoDashStatic} Returns a new lodash function.
 */
_.LoDashStatic.prototype.runInContext = function(context) {};

/**
 * @see _.runInContext
 * @return {!_.LoDashStatic}
 */
_.LoDashImplicitObjectWrapper.prototype.runInContext = function() {};

/**
 * Invokes the iteratee function n times, returning an array of the results of each invocation. The iteratee is
 * bound to thisArg and invoked with one argument; (index).
 * 
 * @see _.times
 * @template TResult
 * @param {number} n The number of times to invoke iteratee.
 * @param {function(number): TResult=} iteratee The function invoked per iteration.
 * @param {?=} thisArg The this binding of iteratee.
 * @return {!Array<TResult>|!Array<number>} Returns the array of results.
 */
_.LoDashStatic.prototype.times = function(n, iteratee, thisArg) {};

/**
 * @see _.times
 * @see _.times
 * @template TResult
 * @param {function(number): TResult=} iteratee
 * @param {?=} thisArgs
 * @return {!_.LoDashImplicitArrayWrapper<TResult>|!_.LoDashImplicitArrayWrapper<number>}
 */
_.LoDashImplicitWrapper.prototype.times = function(iteratee, thisArgs) {};

/**
 * @see _.times
 * @see _.times
 * @template TResult
 * @param {function(number): TResult=} iteratee
 * @param {?=} thisArgs
 * @return {!_.LoDashExplicitArrayWrapper<TResult>|!_.LoDashExplicitArrayWrapper<number>}
 */
_.LoDashExplicitWrapper.prototype.times = function(iteratee, thisArgs) {};

/**
 * Generates a unique ID. If prefix is provided the ID is appended to it.
 * 
 * @param {string=} prefix The value to prefix the ID with.
 * @return {string} Returns the unique ID.
 */
_.LoDashStatic.prototype.uniqueId = function(prefix) {};

/**
 * @see _.uniqueId
 * @return {string}
 */
_.LoDashImplicitWrapper.prototype.uniqueId = function() {};

/**
 * @see _.uniqueId
 * @return {!_.LoDashExplicitWrapper<string>}
 */
_.LoDashExplicitWrapper.prototype.uniqueId = function() {};
/**
 * @record
 * @struct
 */
_.ListIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.DictionaryIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.NumericDictionaryIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.ObjectIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.StringIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.MemoVoidIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.MemoIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.MemoVoidArrayIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.MemoVoidDictionaryIterator = function() {};

/* TODO: CallSignature: _ */
/**
 * @record
 * @struct
 */
_.List = function() {};

/* TODO: IndexSignature: _ */
 /** @type {number} */
_.List.prototype.length;
/**
 * @record
 * @struct
 */
_.Dictionary = function() {};

/* TODO: IndexSignature: _ */
/**
 * @record
 * @struct
 */
_.NumericDictionary = function() {};

/* TODO: IndexSignature: _ */
/**
 * @record
 * @struct
 */
_.StringRepresentable = function() {};

/**
 * @return {string}
 */
_.StringRepresentable.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
_.Cancelable = function() {};

/**
 * @return {void}
 */
_.Cancelable.prototype.cancel = function() {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "lodash"
/** @const */
tsickle_declare_module.lodash = {};

/* TODO: ExportAssignment in tsickle_declare_module.lodash */
