/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/turf/index.d.ts:
 /** @type {!turf.TurfStatic} */
var turf;
 /** @type {string} */
var TemplateUnits;
 /** @type {string} */
var TemplateType;
/**
 * @record
 * @struct
 */
function OptionsRandom() {}
 /** @type {!Array<number>} */
OptionsRandom.prototype.bbox;
 /** @type {number} */
OptionsRandom.prototype.num_vertices;
 /** @type {number} */
OptionsRandom.prototype.max_radial_length;

/** @typedef {function(?, ?): ?} */
var PropReduceCallback;
/**
 * @record
 * @struct
 */
turf.TurfStatic = function() {};

/**
 * Merges a specified property from a FeatureCollection of points into a FeatureCollection of polygons. Given an `inProperty` on points and an `outProperty` for polygons, this finds every point that lies within each polygon, collects the `inProperty` values from those points, and adds them as an array to `outProperty` on the polygon.
 * 
 * \@name [collect](http://turfjs.org/docs/#collect)
 * \@example 
 * var poly1 = polygon([[[0,0],[10,0],[10,10],[0,10],[0,0]]])
 * var poly2 = polygon([[[10,0],[20,10],[20,20],[20,0],[10,0]]])
 * var polyFC = featurecollection([poly1, poly2])
 * var pt1 = point([5,5], {population: 200})
 * var pt2 = point([1,3], {population: 600})
 * var pt3 = point([14,2], {population: 100})
 * var pt4 = point([13,1], {population: 200})
 * var pt5 = point([19,7], {population: 300})
 * var ptFC = featurecollection([pt1, pt2, pt3, pt4, pt5])
 * var aggregated = aggregate(polyFC, ptFC, 'population', 'values')
 * 
 * aggregated.features[0].properties.values // => [200, 600])
 * @param {?} polygons
 * @param {?} points
 * @param {string} inProperty
 * @param {string} outProperty
 * @return {?}
 */
turf.TurfStatic.prototype.collect = function(polygons, points, inProperty, outProperty) {};

/**
 * Takes a line and returns a point at a specified distance along the line.
 * @param {?} line Input line
 * @param {number} distance Distance along the line
 * @param {string=} units
 * @return {?} Point along the line
 */
turf.TurfStatic.prototype.along = function(line, distance, units) {};

/**
 * Takes one or more features and returns their area in square meters.
 * @param {?} input Input features
 * @return {number} Area in square meters
 */
turf.TurfStatic.prototype.area = function(input) {};

/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 * 
 * \@name bbox
 * \@example 
 * var pt1 = point([114.175329, 22.2524])
 * var pt2 = point([114.170007, 22.267969])
 * var pt3 = point([114.200649, 22.274641])
 * var pt4 = point([114.200649, 22.274641])
 * var pt5 = point([114.186744, 22.265745])
 * var features = featureCollection([pt1, pt2, pt3, pt4, pt5])
 * 
 * var bbox = turf.bbox(features);
 * 
 * var bboxPolygon = turf.bboxPolygon(bbox);
 * 
 * //=bbox
 * 
 * //=bboxPolygon
 * @param {?} bbox
 * @return {!Array<number>}
 */
turf.TurfStatic.prototype.bbox = function(bbox) {};

/**
 * Takes a {\@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.
 * 
 * \@name circle
 * \@example 
 * var center = point([-75.343, 39.984]);
 * var radius = 5;
 * var steps = 10;
 * var units = 'kilometers';
 * 
 * var circle = turf.circle(center, radius, steps, units);
 * 
 * //=circle
 * @param {?} center
 * @param {number} radius
 * @param {number=} steps
 * @param {string=} units
 * @return {?}
 */
turf.TurfStatic.prototype.circle = function(center, radius, steps, units) {};

/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 * 
 * \@name geojsonType
 * @throws {Error} if value is not the expected type.
 * @param {?} value
 * @param {string} type
 * @param {string} name
 * @return {void}
 */
turf.TurfStatic.prototype.geojsonType = function(value, type, name) {};

/**
 * Reduce properties in any GeoJSON object into a single value, similar to how Array.reduce works. However, in this case we lazily run the reduction, so an array of all properties is unnecessary.
 * 
 * \@name propReduce
 * @param {?} layer
 * @param {function(?, ?): ?} callback
 * @param {?} memo
 * @return {?}
 */
turf.TurfStatic.prototype.propReduce = function(layer, callback, memo) {};

/**
 * Get all coordinates from any GeoJSON object, returning an array of coordinate arrays.
 * 
 * \@name coordAll
 * @param {?} layer
 * @return {!Array<!Array<number>>}
 */
turf.TurfStatic.prototype.coordAll = function(layer) {};

/**
 * Tesselates a {\@link Feature<Polygon>} into a {\@link FeatureCollection<Polygon>} of triangles using [earcut](https://github.com/mapbox/earcut).
 * 
 * \@name tesselate
 * \@example 
 * var polygon = turf.random('polygon').features[0];
 * 
 * var triangles = turf.tesselate(polygon);
 * 
 * //=triangles
 * @param {?} poly
 * @return {?}
 */
turf.TurfStatic.prototype.tesselate = function(poly) {};

/**
 * Takes a bbox and returns an equivalent polygon.
 * @param {!Array<number>} bbox An Array of bounding box coordinates in the form: [xLow, yLow, xHigh, yHigh]
 * @return {?} A Polygon representation of the bounding box
 */
turf.TurfStatic.prototype.bboxPolygon = function(bbox) {};

/**
 * Takes two points and finds the geographic bearing between them.
 * @param {?} start Starting Point
 * @param {?} end Ending point
 * @return {number} Bearing in decimal degrees
 */
turf.TurfStatic.prototype.bearing = function(start, end) {};

/**
 * Takes a FeatureCollection and returns the absolute center point of all features.
 * @param {?} features Input features
 * @return {?} A Point feature at the absolute center point of all input features
 */
turf.TurfStatic.prototype.center = function(features) {};

/**
 * Takes one or more features and calculates the centroid using the arithmetic mean of all vertices.
 * This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.
 * @param {?} features Input features
 * @return {?} The centroid of the input features
 */
turf.TurfStatic.prototype.centroid = function(features) {};

/**
 * Takes a Point and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers and bearing in degrees.
 * This uses the Haversine formula to account for global curvature.
 * @param {?} start Starting point
 * @param {number} distance Distance from the starting point
 * @param {number} bearing Ranging from -180 and 180
 * @param {string=} units 'miles', 'kilometers', 'radians', or 'degrees'
 * @return {?} Destination point
 */
turf.TurfStatic.prototype.destination = function(start, distance, bearing, units) {};

/**
 * Calculates the distance between two points in degress, radians, miles, or kilometers.
 * This uses the Haversine formula to account for global curvature.
 * @param {?} from Origin point
 * @param {?} to Destination point
 * @param {string=} units
 * @return {number} Distance between the two points
 */
turf.TurfStatic.prototype.distance = function(from, to, units) {};

/**
 * Takes any number of features and returns a rectangular Polygon that encompasses all vertices.
 * @param {?} fc Input features
 * @return {?} A rectangular Polygon feature that encompasses all vertices
 */
turf.TurfStatic.prototype.envelope = function(fc) {};

/**
 * Takes a line and measures its length in the specified units.
 * @param {?} line Line to measure
 * @param {string=} units 'miles', 'kilometers', 'radians', or 'degrees'
 * @return {number} Length of the input line
 */
turf.TurfStatic.prototype.lineDistance = function(line, units) {};

/**
 * Takes two points and returns a point midway between them.
 * @param {?} pt1 First point
 * @param {?} pt2 Second point
 * @return {?} A point midway between pt1 and pt2
 */
turf.TurfStatic.prototype.midpoint = function(pt1, pt2) {};

/**
 * Takes a feature and returns a Point guaranteed to be on the surface of the feature. Given a Polygon, the point will be in the area of the polygon.
 * Given a LineString, the point will be along the string. Given a Point, the point will the same as the input.
 * @param {?} input Any feature or set of features
 * @return {?} A point on the surface of input
 */
turf.TurfStatic.prototype.pointOnSurface = function(input) {};

/**
 * Takes a bounding box and calculates the minimum square bounding box that would contain the input.
 * @param {!Array<number>} bbox A bounding box
 * @return {!Array<number>} A square surrounding bbox
 */
turf.TurfStatic.prototype.square = function(bbox) {};

/**
 * Takes a line and returns a curved version by applying a Bezier spline algorithm.
 * The bezier spline implementation is by Leszek Rybicki.
 * @param {?} line Input LineString
 * @param {number=} resolution
 * @param {number=} sharpness
 * @return {?} Curved line
 */
turf.TurfStatic.prototype.bezier = function(line, resolution, sharpness) {};

/**
 * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
 * @param {?} feature Input to be buffered
 * @param {number} distance Distance to draw the buffer
 * @param {string=} units 'miles', 'kilometers', 'radians', or 'degrees'
 * @return {?} Buffered features
 */
turf.TurfStatic.prototype.buffer = function(feature, distance, units) {};

/**
 * Takes a set of points and returns a concave hull polygon. Internally, this implements a Monotone chain algorithm.
 * @param {?} points Input points
 * @param {number} maxEdge The size of an edge necessary for part of the hull to become concave (in miles)
 * @param {string=} units Used for maxEdge distance (miles or kilometers)
 * @return {?} A concave hull
 */
turf.TurfStatic.prototype.concave = function(points, maxEdge, units) {};

/**
 * Takes a set of points and returns a convex hull polygon. Internally this uses the convex-hull module that implements a monotone chain hull.
 * @param {?} input Input points
 * @return {?} A convex hull
 */
turf.TurfStatic.prototype.convex = function(input) {};

/**
 * Finds the difference between two polygons by clipping the second polygon from the first.
 * @param {?} poly1 Input Polygon feaure
 * @param {?} poly2 Polygon feature to difference from poly1
 * @return {?} A Polygon feature showing the area of poly1 excluding the area of poly2
 */
turf.TurfStatic.prototype.difference = function(poly1, poly2) {};

/**
 * Takes two Features and finds their intersection.
 * If they share a border, returns the border if they don't intersect, returns undefined.
 * 
 * \@name [intersect](http://turfjs.org/docs/#intersect)
 * \@example 
 * var poly1 = polygon([[
 *   [-122.801742, 45.48565],
 *   [-122.801742, 45.60491],
 *   [-122.584762, 45.60491],
 *   [-122.584762, 45.48565],
 *   [-122.801742, 45.48565]
 * ]]);
 * 
 * var poly2 = polygon([[
 *   [-122.520217, 45.535693],
 *   [-122.64038, 45.553967],
 *   [-122.720031, 45.526554],
 *   [-122.669906, 45.507309],
 *   [-122.723464, 45.446643],
 *   [-122.532577, 45.408574],
 *   [-122.487258, 45.477466],
 *   [-122.520217, 45.535693]
 * ]]);
 * var polygons = featureCollection([poly1, poly2]);
 * 
 * var intersection = turf.intersect(poly1, poly2);
 * 
 * //=polygons
 * 
 * //=intersection
 * @param {?} feature1
 * @param {?} feature2
 * @return {?}
 */
turf.TurfStatic.prototype.intersect = function(feature1, feature2) {};

/**
 * Takes a LineString or Polygon and returns a simplified version.
 * Internally uses simplify-js to perform simplification.
 * @param {?} feature Feature to be simplified
 * @param {number} tolerance Simplification tolerance
 * @param {boolean} highQuality Whether or not to spend more time to create a higher-quality simplification with a different algorithm
 * @return {?} A simplified feature
 */
turf.TurfStatic.prototype.simplify = function(feature, tolerance, highQuality) {};

/**
 * Takes two polygons and returns a combined polygon.
 * If the input polygons are not contiguous, this function returns a MultiPolygon feature.;
 * @param {?} poly1 Input polygon
 * @param {?} poly2 Another input polygon
 * @return {?} A combined Polygon or MultiPolygon feature
 */
turf.TurfStatic.prototype.union = function(poly1, poly2) {};

/**
 * Combines a FeatureCollection of Point, LineString, or Polygon features into MultiPoint, MultiLineString, or MultiPolygon features.
 * @param {?} fc A FeatureCollection of any type
 * @return {?} A FeatureCollection of corresponding type to input
 */
turf.TurfStatic.prototype.combine = function(fc) {};

/**
 * Takes a feature or set of features and returns all positions as points.
 * @param {?} input Input features
 * @return {?} Points representing the exploded input features
 */
turf.TurfStatic.prototype.explode = function(input) {};

/**
 * Takes input features and flips all of their coordinates from [x, y] to [y, x].
 * @param {?} input Input features
 * @return {?} A feature or set of features of the same type as input with flipped coordinates
 */
turf.TurfStatic.prototype.flip = function(input) {};

/**
 * Takes a polygon and returns points at all self-intersections.
 * @param {?} polygon Input polygon
 * @return {?} Self-intersections
 */
turf.TurfStatic.prototype.kinks = function(polygon) {};

/**
 * Takes a line, a start Point, and a stop point and returns the line in between those points.
 * @param {?} point1 Starting point
 * @param {?} point2 Stopping point
 * @param {?} line Line to slice
 * @return {?} Sliced line
 */
turf.TurfStatic.prototype.lineSlice = function(point1, point2, line) {};

/**
 * Takes a Point and a LineString and calculates the closest Point on the LineString.
 * @param {?} line Line to snap to
 * @param {?} point Point to snap from
 * @return {?} Closest point on the line to point
 */
turf.TurfStatic.prototype.pointOnLine = function(line, point) {};

/**
 * Takes one or more {\@link Feature|Features} and creates a {\@link FeatureCollection}.
 * 
 * \@name [featureCollection](http://turfjs.org/docs/#featurecollection)
 * \@example 
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ]
 * 
 * var fc = turf.featureCollection(features)
 * 
 * //=fc
 * @param {!Array<?>} features
 * @return {?}
 */
turf.TurfStatic.prototype.featureCollection = function(features) {};

/**
 * Wraps a GeoJSON {\@link Geometry} in a GeoJSON {\@link Feature}.
 * 
 * \@name [feature](http://turfjs.org/docs/#feature)
 * \@example 
 * var geometry = {
 *      "type": "Point",
 *      "coordinates": [
 *        67.5,
 *        32.84267363195431
 *      ]
 *    }
 * 
 * var feature = turf.feature(geometry)
 * 
 * //=feature
 * @param {?} geometry
 * @param {?=} properties
 * @return {?}
 */
turf.TurfStatic.prototype.feature = function(geometry, properties) {};

/**
 * Creates a {\@link LineString} based on a coordinate array. Properties can be added optionally.
 * 
 * \@name [lineString](http://turfjs.org/docs/#linestring)
 * @throws {Error} if no coordinates are passed
 * \@example 
 * var linestring1 = turf.lineString([
 *    [-21.964416, 64.148203],
 *    [-21.956176, 64.141316],
 *    [-21.93901, 64.135924],
 *    [-21.927337, 64.136673]
 * ])
 * var linestring2 = turf.lineString([
 *    [-21.929054, 64.127985],
 *    [-21.912918, 64.134726],
 *    [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145})
 * 
 * //=linestring1
 * 
 * //=linestring2
 * @param {!Array<!Array<number>>} coordinates
 * @param {?=} properties
 * @return {?}
 */
turf.TurfStatic.prototype.lineString = function(coordinates, properties) {};

/**
 * Creates a {\@link Feature<MultiLineString>} based on a coordinate array. Properties can be added optionally.
 * 
 * \@name [multiLineString](http://turfjs.org/docs/#multilinestring)
 * @throws {Error} if no coordinates are passed
 * \@example 
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]])
 * 
 * //=multiLine
 * 
 * @param {!Array<!Array<!Array<number>>>} coordinates
 * @param {?=} properties
 * @return {?}
 */
turf.TurfStatic.prototype.multiLineString = function(coordinates, properties) {};

/**
 * Takes coordinates and properties (optional) and returns a new {\@link Point} feature.
 * 
 * \@name [point](http://turfjs.org/docs/#point)
 * properties
 * \@example 
 * var pt1 = turf.point([-75.343, 39.984]);
 * 
 * //=pt1
 * @param {!Array<number>} coordinates
 * @param {?=} properties
 * @return {?}
 */
turf.TurfStatic.prototype.point = function(coordinates, properties) {};

/**
 * Creates a {\@link Feature<MultiPoint>} based on a coordinate array. Properties can be added optionally.
 * 
 * \@name [multiPoint](http://turfjs.org/docs/#multipoint)
 * @throws {Error} if no coordinates are passed
 * \@example 
 * var multiPt = turf.multiPoint([[0,0],[10,10]])
 * 
 * //=multiPt
 * 
 * @param {!Array<!Array<number>>} coordinates
 * @param {?=} properties
 * @return {?}
 */
turf.TurfStatic.prototype.multiPoint = function(coordinates, properties) {};

/**
 * Takes an array of LinearRings and optionally an {\@link Object} with properties and returns a {\@link Polygon} feature.
 * 
 * \@name [polygon](http://turfjs.org/docs/#polygon)
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the
 * beginning & end.
 * \@example 
 * var polygon = turf.polygon([[
 *  [-2.275543, 53.464547],
 *  [-2.275543, 53.489271],
 *  [-2.215118, 53.489271],
 *  [-2.215118, 53.464547],
 *  [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 * 
 * //=polygon
 * @param {!Array<!Array<!Array<number>>>} coordinates
 * @param {?=} properties
 * @return {?}
 */
turf.TurfStatic.prototype.polygon = function(coordinates, properties) {};

/**
 * Creates a {\@link Feature<MultiPolygon>} based on a coordinate array. Properties can be added optionally.
 * 
 * \@name [multiPolygon](http://turfjs.org/docs/#multipolygon)
 * @throws {Error} if no coordinates are passed
 * \@example 
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]);
 * 
 * //=multiPoly
 * 
 * @param {!Array<!Array<!Array<!Array<number>>>>} coordinates
 * @param {?=} properties
 * @return {?}
 */
turf.TurfStatic.prototype.multiPolygon = function(coordinates, properties) {};

/**
 * Creates a {\@link Feature<GeometryCollection>} based on acoordinate array. Properties can be added optionally.
 * 
 * \@name [geometryCollection](http://turfjs.org/docs/#geometrycollection)
 * \@example 
 * var point = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([point, line]);
 * 
 * //=collection
 * @param {!Array<?>} geometries
 * @param {?=} properties
 * @return {?}
 */
turf.TurfStatic.prototype.geometryCollection = function(geometries, properties) {};

/**
 * Generates random {\@link GeoJSON} data, including {\@link Point|Points} and {\@link Polygon|Polygons}, for testing and experimentation.
 * 
 * \@name [random](http://turfjs.org/docs/#random)
 * are placed. In the case of {\@link Point} features, they are guaranteed to be within this bounds,
 * while {\@link Polygon} features have their centroid within the bounds.
 * to polygon features.
 * degrees longitude or latitude that a polygon can extent outwards to
 * from its center.
 * \@example 
 * var points = turf.random('points', 100, {
 *   bbox: [-70, 40, -60, 60]
 * })
 * 
 * //=points
 * 
 * var polygons = turf.random('polygons', 4, {
 *   bbox: [-70, 40, -60, 60]
 * })
 * 
 * //=polygons
 * @param {string=} type
 * @param {number=} count
 * @param {!OptionsRandom=} options
 * @return {?}
 */
turf.TurfStatic.prototype.random = function(type, count, options) {};

/**
 * Takes a {\@link FeatureCollection} and returns a FeatureCollection with given number of {\@link Feature|features} at random.
 * 
 * \@name [sample](http://turfjs.org/docs/#sample)
 * \@example 
 * var points = turf.random('points', 1000);
 * 
 * //=points
 * 
 * var sample = turf.sample(points, 10);
 * 
 * //=sample
 * @param {?} featurecollection
 * @param {number} num
 * @return {?}
 */
turf.TurfStatic.prototype.sample = function(featurecollection, num) {};

/**
 * Takes a bounding box and a cell size in degrees and returns a {\@link FeatureCollection} of flat-topped hexagons ({\@link Polygon} features) aligned in an "odd-q" vertical grid as described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).
 * 
 * \@name [hexGrid](http://turfjs.org/docs/#hexgrid)
 * \@example 
 * var bbox = [-96,31,-84,40];
 * var cellSize = 50;
 * var units = 'miles';
 * 
 * var hexgrid = turf.hexGrid(bbox, cellSize, units);
 * 
 * //=hexgrid
 * @param {!Array<number>} bbox
 * @param {number} cellSize
 * @param {string=} units
 * @param {boolean=} triangles
 * @return {?}
 */
turf.TurfStatic.prototype.hexGrid = function(bbox, cellSize, units, triangles) {};

/**
 * Takes a bounding box and a cell depth and returns a set of {\@link Point|points} in a grid.
 * 
 * \@name [pointGrid](http://turfjs.org/docs/#pointgrid)
 * \@example 
 * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 * var cellSize = 3;
 * var units = 'miles';
 * 
 * var grid = turf.pointGrid(extent, cellSize, units);
 * 
 * //=grid
 * @param {!Array<number>} bbox
 * @param {number} cellSize
 * @param {string=} units
 * @return {?}
 */
turf.TurfStatic.prototype.pointGrid = function(bbox, cellSize, units) {};

/**
 * Takes a bounding box and a cell depth and returns a set of square {\@link Polygon|polygons} in a grid.
 * 
 * \@name [squareGrid](http://turfjs.org/docs/#squaregrid)
 * \@example 
 * var bbox = [-96,31,-84,40]
 * var cellSize = 10
 * var units = 'miles'
 * 
 * var squareGrid = turf.squareGrid(bbox, cellSize, units)
 * 
 * //=squareGrid
 * @param {!Array<number>} bbox
 * @param {number} cellSize
 * @param {string=} units
 * @return {?}
 */
turf.TurfStatic.prototype.squareGrid = function(bbox, cellSize, units) {};

/**
 * Takes a bounding box and a cell depth and returns a set of triangular {\@link Polygon|polygons} in a grid.
 * 
 * \@name [triangleGrid](http://turfjs.org/docs/#trianglegrid))
 * \@example 
 * var bbox = [-96,31,-84,40]
 * var cellSize = 10;
 * var units = 'miles';
 * 
 * var triangleGrid = turf.triangleGrid(extent, cellSize, units);
 * 
 * //=triangleGrid
 * @param {!Array<number>} bbox
 * @param {number} cellSize
 * @param {string=} units
 * @return {?}
 */
turf.TurfStatic.prototype.triangleGrid = function(bbox, cellSize, units) {};

/**
 * Takes points with z-values and an array of value breaks and generates isolines.
 * @param {?} points Input points
 * @param {string} z The property name in points from which z-values will be pulled
 * @param {number} resolution Resolution of the underlying grid
 * @param {!Array<number>} breaks Where to draw contours
 * @return {?} Isolines
 */
turf.TurfStatic.prototype.isolines = function(points, z, resolution, breaks) {};

/**
 * Takes a triangular plane as a Polygon and a Point within that triangle and returns the z-value at that point.
 * The Polygon needs to have properties a, b, and c that define the values at its three corners.
 * @param {?} interpolatedpoint
 * @param {?} triangle A Polygon feature with three vertices
 * @return {number} The z-value for interpolatedPoint
 */
turf.TurfStatic.prototype.planepoint = function(interpolatedpoint, triangle) {};

/**
 * Takes a set of points and the name of a z-value property and creates a Triangulated Irregular Network, or a TIN for short, returned as a collection of Polygons.
 * These are often used for developing elevation contour maps or stepped heat visualizations.
 * This triangulates the points, as well as adds properties called a, b, and c representing the value of the given propertyName at each of the points that represent the corners of the triangle.
 * @param {?} points Input points
 * @param {string=} propertyName
 * @return {?} TIN output
 */
turf.TurfStatic.prototype.tin = function(points, propertyName) {};

/**
 * Takes a {<Point>} and a {<Polygon>} or {<MultiPolygon>} and determines if the point resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
 * 
 * \@name [inside](http://turfjs.org/docs/#inside)
 * \@example 
 * var pt = point([-77, 44])
 * var poly = polygon([[[-81, 41], [-81, 47], [-72, 47], [-72, 41], [-81, 41]]])
 * 
 * var isInside = turf.inside(pt, poly)
 * 
 * //=isInside
 * @param {?} point
 * @param {?} polygon
 * @return {boolean}
 */
turf.TurfStatic.prototype.inside = function(point, polygon) {};

/**
 * Takes a {FeatureCollection<Point>} and a {FeatureCollection<Polygon>} and performs a spatial join.
 * 
 * \@name [tag](http://turfjs.org/docs/#inside)
 * \@example 
 * var pt1 = point([-77, 44])
 * var pt2 = point([-77, 38])
 * var poly1 = polygon([[[-81, 41], [-81, 47], [-72, 47], [-72, 41], [-81, 41]]], {pop: 1000})
 * var poly2 = polygon([[[-81, 35], [-81, 41], [-72, 41], [-72, 35], [-81, 35]]], {pop: 3000})
 * 
 * var points = featureCollection([pt1, pt2])
 * var polygons = featureCollection([poly1, poly2])
 * 
 * var tagged = turf.tag(points, polygons, 'pop', 'population')
 * //=tagged
 * @param {?} points
 * @param {?} polygons
 * @param {string} field
 * @param {string} outField
 * @return {?}
 */
turf.TurfStatic.prototype.tag = function(points, polygons, field, outField) {};

/**
 * Takes a set of points and a set of polygons and returns the points that fall within the polygons.
 * @param {?} points Input points
 * @param {?} polygons Input polygons
 * @return {?} Points that land within at least one polygon
 */
turf.TurfStatic.prototype.within = function(points, polygons) {};

/**
 * Takes a reference point and a set of points and returns the point from the set closest to the reference.
 * @param {?} point The reference point
 * @param {?} against Input point set
 * @return {?} The closest point in the set to the reference point
 */
turf.TurfStatic.prototype.nearest = function(point, against) {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "turf"
/** @const */
tsickle_declare_module.turf = {};

/* TODO: ExportAssignment in tsickle_declare_module.turf */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/turf"
/** @const */
tsickle_declare_module._turf_turf = {};

/* TODO: ExportAssignment in tsickle_declare_module._turf_turf */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/collect"
/** @const */
tsickle_declare_module._turf_collect = {};
 /** @type {function(?, ?, string, string): ?} */
tsickle_declare_module._turf_collect.collect;

/* TODO: ExportAssignment in tsickle_declare_module._turf_collect */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/along"
/** @const */
tsickle_declare_module._turf_along = {};
 /** @type {function(?, number, string): ?} */
tsickle_declare_module._turf_along.along;

/* TODO: ExportAssignment in tsickle_declare_module._turf_along */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/area"
/** @const */
tsickle_declare_module._turf_area = {};
 /** @type {function(?): number} */
tsickle_declare_module._turf_area.area;

/* TODO: ExportAssignment in tsickle_declare_module._turf_area */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/bbox-polygon"
/** @const */
tsickle_declare_module._turf_bbox_polygon = {};
 /** @type {function(!Array<number>): ?} */
tsickle_declare_module._turf_bbox_polygon.bboxPolygon;

/* TODO: ExportAssignment in tsickle_declare_module._turf_bbox_polygon */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/bearing"
/** @const */
tsickle_declare_module._turf_bearing = {};
 /** @type {function(?, ?): number} */
tsickle_declare_module._turf_bearing.bearing;

/* TODO: ExportAssignment in tsickle_declare_module._turf_bearing */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/center"
/** @const */
tsickle_declare_module._turf_center = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_center.center;

/* TODO: ExportAssignment in tsickle_declare_module._turf_center */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/centroid"
/** @const */
tsickle_declare_module._turf_centroid = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_centroid.centroid;

/* TODO: ExportAssignment in tsickle_declare_module._turf_centroid */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/destination"
/** @const */
tsickle_declare_module._turf_destination = {};
 /** @type {function(?, number, number, string): ?} */
tsickle_declare_module._turf_destination.destination;

/* TODO: ExportAssignment in tsickle_declare_module._turf_destination */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/distance"
/** @const */
tsickle_declare_module._turf_distance = {};
 /** @type {function(?, ?, string): number} */
tsickle_declare_module._turf_distance.distance;

/* TODO: ExportAssignment in tsickle_declare_module._turf_distance */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/envelope"
/** @const */
tsickle_declare_module._turf_envelope = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_envelope.envelope;

/* TODO: ExportAssignment in tsickle_declare_module._turf_envelope */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/line-distance"
/** @const */
tsickle_declare_module._turf_line_distance = {};
 /** @type {function(?, string): number} */
tsickle_declare_module._turf_line_distance.lineDistance;

/* TODO: ExportAssignment in tsickle_declare_module._turf_line_distance */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/midpoint"
/** @const */
tsickle_declare_module._turf_midpoint = {};
 /** @type {function(?, ?): ?} */
tsickle_declare_module._turf_midpoint.midpoint;

/* TODO: ExportAssignment in tsickle_declare_module._turf_midpoint */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/point-on-surface"
/** @const */
tsickle_declare_module._turf_point_on_surface = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_point_on_surface.pointOnSurface;

/* TODO: ExportAssignment in tsickle_declare_module._turf_point_on_surface */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/square"
/** @const */
tsickle_declare_module._turf_square = {};
 /** @type {function(!Array<number>): !Array<number>} */
tsickle_declare_module._turf_square.square;

/* TODO: ExportAssignment in tsickle_declare_module._turf_square */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/bezier"
/** @const */
tsickle_declare_module._turf_bezier = {};
 /** @type {function(?, number, number): ?} */
tsickle_declare_module._turf_bezier.bezier;

/* TODO: ExportAssignment in tsickle_declare_module._turf_bezier */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/buffer"
/** @const */
tsickle_declare_module._turf_buffer = {};
 /** @type {?} */
tsickle_declare_module._turf_buffer.buffer;

/* TODO: ExportAssignment in tsickle_declare_module._turf_buffer */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/concave"
/** @const */
tsickle_declare_module._turf_concave = {};
 /** @type {function(?, number, string): ?} */
tsickle_declare_module._turf_concave.concave;

/* TODO: ExportAssignment in tsickle_declare_module._turf_concave */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/convex"
/** @const */
tsickle_declare_module._turf_convex = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_convex.convex;

/* TODO: ExportAssignment in tsickle_declare_module._turf_convex */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/difference"
/** @const */
tsickle_declare_module._turf_difference = {};
 /** @type {function(?, ?): ?} */
tsickle_declare_module._turf_difference.difference;

/* TODO: ExportAssignment in tsickle_declare_module._turf_difference */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/intersect"
/** @const */
tsickle_declare_module._turf_intersect = {};
 /** @type {?} */
tsickle_declare_module._turf_intersect.intersect;

/* TODO: ExportAssignment in tsickle_declare_module._turf_intersect */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/simplify"
/** @const */
tsickle_declare_module._turf_simplify = {};
 /** @type {function(?, number, boolean): ?} */
tsickle_declare_module._turf_simplify.simplify;

/* TODO: ExportAssignment in tsickle_declare_module._turf_simplify */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/union"
/** @const */
tsickle_declare_module._turf_union = {};
 /** @type {function(?, ?): ?} */
tsickle_declare_module._turf_union.union;

/* TODO: ExportAssignment in tsickle_declare_module._turf_union */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/combine"
/** @const */
tsickle_declare_module._turf_combine = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_combine.combine;

/* TODO: ExportAssignment in tsickle_declare_module._turf_combine */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/explode"
/** @const */
tsickle_declare_module._turf_explode = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_explode.explode;

/* TODO: ExportAssignment in tsickle_declare_module._turf_explode */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/flip"
/** @const */
tsickle_declare_module._turf_flip = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_flip.flip;

/* TODO: ExportAssignment in tsickle_declare_module._turf_flip */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/kinks"
/** @const */
tsickle_declare_module._turf_kinks = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_kinks.kinks;

/* TODO: ExportAssignment in tsickle_declare_module._turf_kinks */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/line-slice"
/** @const */
tsickle_declare_module._turf_line_slice = {};
 /** @type {function(?, ?, ?): ?} */
tsickle_declare_module._turf_line_slice.lineSlice;

/* TODO: ExportAssignment in tsickle_declare_module._turf_line_slice */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/point-on-line"
/** @const */
tsickle_declare_module._turf_point_on_line = {};
 /** @type {function(?, ?): ?} */
tsickle_declare_module._turf_point_on_line.pointOnLine;

/* TODO: ExportAssignment in tsickle_declare_module._turf_point_on_line */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/helpers"
/** @const */
tsickle_declare_module._turf_helpers = {};
 /** @type {{featureCollection: function(!Array<?>): ?, feature: function(?, ?): ?, lineString: function(!Array<!Array<number>>, ?): ?, multiLineString: function(!Array<!Array<!Array<number>>>, ?): ?, point: function(!Array<number>, ?): ?, multiPoint: function(!Array<!Array<number>>, ?): ?, polygon: function(!Array<!Array<!Array<number>>>, ?): ?, multiPolygon: function(!Array<!Array<!Array<!Array<number>>>>, ?): ?, geometryCollection: function(!Array<?>, ?): ?}} */
tsickle_declare_module._turf_helpers.helpers;

/* TODO: ExportAssignment in tsickle_declare_module._turf_helpers */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/random"
/** @const */
tsickle_declare_module._turf_random = {};
 /** @type {?} */
tsickle_declare_module._turf_random.random;

/* TODO: ExportAssignment in tsickle_declare_module._turf_random */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/sample"
/** @const */
tsickle_declare_module._turf_sample = {};
 /** @type {function(?, number): ?} */
tsickle_declare_module._turf_sample.sample;

/* TODO: ExportAssignment in tsickle_declare_module._turf_sample */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/isolines"
/** @const */
tsickle_declare_module._turf_isolines = {};
 /** @type {function(?, string, number, !Array<number>): ?} */
tsickle_declare_module._turf_isolines.isolines;

/* TODO: ExportAssignment in tsickle_declare_module._turf_isolines */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/planepoint"
/** @const */
tsickle_declare_module._turf_planepoint = {};
 /** @type {function(?, ?): number} */
tsickle_declare_module._turf_planepoint.planepoint;

/* TODO: ExportAssignment in tsickle_declare_module._turf_planepoint */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/tin"
/** @const */
tsickle_declare_module._turf_tin = {};
 /** @type {function(?, string): ?} */
tsickle_declare_module._turf_tin.tin;

/* TODO: ExportAssignment in tsickle_declare_module._turf_tin */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/inside"
/** @const */
tsickle_declare_module._turf_inside = {};
 /** @type {function(?, ?): boolean} */
tsickle_declare_module._turf_inside.inside;

/* TODO: ExportAssignment in tsickle_declare_module._turf_inside */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/tag"
/** @const */
tsickle_declare_module._turf_tag = {};
 /** @type {function(?, ?, string, string): ?} */
tsickle_declare_module._turf_tag.tag;

/* TODO: ExportAssignment in tsickle_declare_module._turf_tag */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/within"
/** @const */
tsickle_declare_module._turf_within = {};
 /** @type {function(?, ?): ?} */
tsickle_declare_module._turf_within.within;

/* TODO: ExportAssignment in tsickle_declare_module._turf_within */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/hex-grid"
/** @const */
tsickle_declare_module._turf_hex_grid = {};
 /** @type {function(!Array<number>, number, string, boolean): ?} */
tsickle_declare_module._turf_hex_grid.hexGrid;

/* TODO: ExportAssignment in tsickle_declare_module._turf_hex_grid */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/point-grid"
/** @const */
tsickle_declare_module._turf_point_grid = {};
 /** @type {function(!Array<number>, number, string): ?} */
tsickle_declare_module._turf_point_grid.pointGrid;

/* TODO: ExportAssignment in tsickle_declare_module._turf_point_grid */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/square-grid"
/** @const */
tsickle_declare_module._turf_square_grid = {};
 /** @type {function(!Array<number>, number, string): ?} */
tsickle_declare_module._turf_square_grid.squareGrid;

/* TODO: ExportAssignment in tsickle_declare_module._turf_square_grid */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/triangle-grid"
/** @const */
tsickle_declare_module._turf_triangle_grid = {};
 /** @type {function(!Array<number>, number, string): ?} */
tsickle_declare_module._turf_triangle_grid.triangleGrid;

/* TODO: ExportAssignment in tsickle_declare_module._turf_triangle_grid */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/nearest"
/** @const */
tsickle_declare_module._turf_nearest = {};
 /** @type {function(?, ?): ?} */
tsickle_declare_module._turf_nearest.nearest;

/* TODO: ExportAssignment in tsickle_declare_module._turf_nearest */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/bbox"
/** @const */
tsickle_declare_module._turf_bbox = {};
 /** @type {function(?): !Array<number>} */
tsickle_declare_module._turf_bbox.bbox;

/* TODO: ExportAssignment in tsickle_declare_module._turf_bbox */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/circle"
/** @const */
tsickle_declare_module._turf_circle = {};
 /** @type {function(?, number, number, string): ?} */
tsickle_declare_module._turf_circle.circle;

/* TODO: ExportAssignment in tsickle_declare_module._turf_circle */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/geojsonType"
/** @const */
tsickle_declare_module._turf_geojsonType = {};
 /** @type {function(?, string, string): void} */
tsickle_declare_module._turf_geojsonType.geojsonType;

/* TODO: ExportAssignment in tsickle_declare_module._turf_geojsonType */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/propReduce"
/** @const */
tsickle_declare_module._turf_propReduce = {};
 /** @type {function(?, function(?, ?): ?, ?): ?} */
tsickle_declare_module._turf_propReduce.propReduce;

/* TODO: ExportAssignment in tsickle_declare_module._turf_propReduce */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/coordAll"
/** @const */
tsickle_declare_module._turf_coordAll = {};
 /** @type {function(?): !Array<!Array<number>>} */
tsickle_declare_module._turf_coordAll.coordAll;

/* TODO: ExportAssignment in tsickle_declare_module._turf_coordAll */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "@turf/tesselate"
/** @const */
tsickle_declare_module._turf_tesselate = {};
 /** @type {function(?): ?} */
tsickle_declare_module._turf_tesselate.tesselate;

/* TODO: ExportAssignment in tsickle_declare_module._turf_tesselate */
