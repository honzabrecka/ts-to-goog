/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/tape/index.d.ts:

/* TODO: ExportAssignment in  */

/**
 * Create a new test with an optional name string and optional opts object.
 * cb(t) fires with the new test object t once all preceeding tests have finished.
 * Tests execute serially.
 * @param {string|!tape.TestCase|!tape.TestOptions} name_or_cb_or_opts
 * @param {!tape.TestCase|!tape.TestOptions=} cb_or_opts
 * @param {!tape.TestCase=} cb
 * @return {void}
 */
function tape(name_or_cb_or_opts, cb_or_opts, cb) {}
/**
 * @record
 * @struct
 */
tape.TestCase = function() {};

/* TODO: CallSignature: tape */
/**
 * @record
 * @struct
 */
tape.TestOptions = function() {};
 /** @type {boolean} */
tape.TestOptions.prototype.skip;
 /** @type {number} */
tape.TestOptions.prototype.timeout;
/**
 * @record
 * @struct
 */
tape.StreamOptions = function() {};
 /** @type {boolean} */
tape.StreamOptions.prototype.objectMode;

/**
 * Generate a new test that will be skipped over.
 * @param {string} name
 * @param {!tape.TestCase} cb
 * @return {void}
 */
tape.skip = function(name, cb) {};

/**
 * The onFinish hook will get invoked when ALL tape tests have finished right before tape is about to print the test summary.
 * @param {function(): void} cb
 * @return {void}
 */
tape.onFinish = function(cb) {};

/**
 * Like test(name, cb) except if you use .only this is the only test case that will run for the entire process, all other test cases using tape will be ignored.
 * @param {string} name
 * @param {!tape.TestCase} cb
 * @return {void}
 */
tape.only = function(name, cb) {};

/**
 * Create a new test harness instance, which is a function like test(), but with a new pending stack and test state.
 * @return {?}
 */
tape.createHarness = function() {};

/**
 * Create a stream of output, bypassing the default output stream that writes messages to console.log().
 * By default stream will be a text stream of TAP output, but you can get an object stream instead by setting opts.objectMode to true.
 * @param {!tape.StreamOptions=} opts
 * @return {!NodeJS.ReadableStream}
 */
tape.createStream = function(opts) {};
/**
 * @record
 * @struct
 */
tape.Test = function() {};

/**
 * Create a subtest with a new test handle st from cb(st) inside the current test.
 * cb(st) will only fire when t finishes.
 * Additional tests queued up after t will not be run until all subtests finish.
 * @param {string} name
 * @param {!tape.TestCase} cb
 * @return {void}
 */
tape.Test.prototype.test = function(name, cb) {};

/**
 * Declare that n assertions should be run. end() will be called automatically after the nth assertion.
 * If there are any more assertions after the nth, or after end() is called, they will generate errors.
 * @param {number} n
 * @return {void}
 */
tape.Test.prototype.plan = function(n) {};

/**
 * Declare the end of a test explicitly.
 * If err is passed in t.end will assert that it is falsey.
 * @param {?=} err
 * @return {void}
 */
tape.Test.prototype.end = function(err) {};

/**
 * Generate a failing assertion with a message msg.
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.fail = function(msg) {};

/**
 * Generate a passing assertion with a message msg.
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.pass = function(msg) {};

/**
 * Automatically timeout the test after X ms.
 * @param {number} ms
 * @return {void}
 */
tape.Test.prototype.timeoutAfter = function(ms) {};

/**
 * Generate an assertion that will be skipped over.
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.skip = function(msg) {};

/**
 * Assert that value is truthy with an optional description message msg.
 * @param {?} value
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.ok = function(value, msg) {};

/**
 * @param {?} value
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.true = function(value, msg) {};

/**
 * @param {?} value
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.assert = function(value, msg) {};

/**
 * Assert that value is falsy with an optional description message msg.
 * @param {?} value
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notOk = function(value, msg) {};

/**
 * @param {?} value
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.false = function(value, msg) {};

/**
 * @param {?} value
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notok = function(value, msg) {};

/**
 * Assert that err is falsy.
 * If err is non-falsy, use its err.message as the description message.
 * @param {?} err
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.error = function(err, msg) {};

/**
 * @param {?} err
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.ifError = function(err, msg) {};

/**
 * @param {?} err
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.ifErr = function(err, msg) {};

/**
 * @param {?} err
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.iferror = function(err, msg) {};

/**
 * Assert that a === b with an optional description msg.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.equal = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.equals = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.isEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.is = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.strictEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.strictEquals = function(actual, expected, msg) {};

/**
 * Assert that a !== b with an optional description msg.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notEquals = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notStrictEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notStrictEquals = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.isNotEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.isNot = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.not = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.doesNotEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.isInequal = function(actual, expected, msg) {};

/**
 * Assert that a and b have the same structure and nested values using node's deepEqual() algorithm with strict comparisons (===) on leaf nodes and an optional description msg.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.deepEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.deepEquals = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.isEquivalent = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.same = function(actual, expected, msg) {};

/**
 * Assert that a and b do not have the same structure and nested values using node's deepEqual() algorithm with strict comparisons (===) on leaf nodes and an optional description msg.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notDeepEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notEquivalent = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notDeeply = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notSame = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.isNotDeepEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.isNotDeeply = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.isNotEquivalent = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.isInequivalent = function(actual, expected, msg) {};

/**
 * Assert that a and b have the same structure and nested values using node's deepEqual() algorithm with loose comparisons (==) on leaf nodes and an optional description msg.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.deepLooseEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.looseEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.looseEquals = function(actual, expected, msg) {};

/**
 * Assert that a and b do not have the same structure and nested values using node's deepEqual() algorithm with loose comparisons (==) on leaf nodes and an optional description msg.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notDeepLooseEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notLooseEqual = function(actual, expected, msg) {};

/**
 * @param {?} actual
 * @param {?} expected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.notLooseEquals = function(actual, expected, msg) {};

/**
 * Assert that the function call fn() throws an exception.
 * expected, if present, must be a RegExp or Function, which is used to test the exception object.
 * @param {function(): void} fn
 * @param {string|(!RegExp|function(): void)=} msg_or_exceptionExpected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.throws = function(fn, msg_or_exceptionExpected, msg) {};

/**
 * Assert that the function call fn() does not throw an exception.
 * @param {function(): void} fn
 * @param {string|(!RegExp|function(): void)=} msg_or_exceptionExpected
 * @param {string=} msg
 * @return {void}
 */
tape.Test.prototype.doesNotThrow = function(fn, msg_or_exceptionExpected, msg) {};

/**
 * Print a message without breaking the tap output.
 * (Useful when using e.g. tap-colorize where output is buffered & console.log will print in incorrect order vis-a-vis tap output.)
 * @param {string} msg
 * @return {void}
 */
tape.Test.prototype.comment = function(msg) {};
