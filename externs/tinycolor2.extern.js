/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/tinycolor2/index.d.ts:
 /** @type {?} */
var tinycolor;

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
 /** @type {!Object<string,string>} */
tinycolor.prototype.hexNames;
 /** @type {!Object<string,string>} */
tinycolor.prototype.names;

/**
 * Create a tinycolor instance based off the relative values.
 * Works with any color formats
 * 
 * @param {?} ratio - the relative color/hue values to apply to the new instance.
 * @return {!tinycolorInstance}
 */
tinycolor.prototype.fromRatio = function(ratio) {};

/**
 * Compares the two colors and returns the difference between their brightness and color/hue
 * 
 * @param {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} firstColor - the first color to be used in the comparison.
 * @param {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} secondColor - the second color to be used in the comparison.
 * @return {!Readable.Readable}
 */
tinycolor.prototype.readability = function(firstColor, secondColor) {};

/**
 * Ensure that foreground and background color combinations meet WCAG2 guidelines.
 * 
 * @param {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} foreColor - the fore color wanted.
 * @param {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} backColor - the back color wanted.
 * @param {{level: string, size: string}=} wcag2 - The 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA'; the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'. If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.
 * @return {boolean}
 */
tinycolor.prototype.isReadable = function(foreColor, backColor, wcag2) {};

/**
 * Given a base color and a list of possible foreground or background colors for that base,
 *  returns the most readable color. Optionally returns Black or White if the most readable color is unreadable.
 * 
 * @param {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} color - the base color.
 * @param {!Array<(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)>} colorsToCompare - array of colors to pick the most readable one from.
 * @param {{includeFallbackColors: boolean, level: string, size: string}=} args - and object with extra arguments
 * @return {!tinycolorInstance}
 */
tinycolor.prototype.mostReadable = function(color, colorsToCompare, args) {};

/**
 * @param {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} color1
 * @param {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} color2
 * @param {number=} amount
 * @return {!tinycolorInstance}
 */
tinycolor.prototype.mix = function(color1, color2, amount) {};

/**
 * Can be called with any tinycolor input
 * @param {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} color1
 * @param {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} color2
 * @return {boolean}
 */
tinycolor.prototype.equals = function(color1, color2) {};

/**
 * Returns a random color
 * @return {!tinycolorInstance}
 */
tinycolor.prototype.random = function() {};
/**
 * @record
 * @struct
 */
function tinycolorInstance() {}

/**
 * Return an indication whether the color was successfully parsed.
 * @return {boolean}
 */
tinycolorInstance.prototype.isValid = function() {};

/**
 * Return an indication whether the color's perceived brightness is light.
 * @return {boolean}
 */
tinycolorInstance.prototype.isLight = function() {};

/**
 * Return an indication whether the color's perceived brightness is dark.
 * @return {boolean}
 */
tinycolorInstance.prototype.isDark = function() {};

/**
 * Returns the format used to create the tinycolor instance.
 * @return {string}
 */
tinycolorInstance.prototype.getFormat = function() {};

/**
 * Returns the input passed into the constructer used to create the tinycolor instance.
 * @return {?}
 */
tinycolorInstance.prototype.getOriginalInput = function() {};

/**
 * Returns the alpha value of the color
 * @return {number}
 */
tinycolorInstance.prototype.getAlpha = function() {};

/**
 * Returns the perceived brightness of the color, from 0-255.
 * @return {number}
 */
tinycolorInstance.prototype.getBrightness = function() {};

/**
 * Returns the perceived luminance of a color, from 0-1.
 * @return {number}
 */
tinycolorInstance.prototype.getLuminance = function() {};

/**
 * Sets the alpha value on the current color.
 * 
 * @param {number} alpha - The new alpha value. The accepted range is 0-1.
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.setAlpha = function(alpha) {};

/**
 * Returns the object as a HSVA object.
 * @return {!ColorFormats.HSVA}
 */
tinycolorInstance.prototype.toHsv = function() {};

/**
 * Returns the hsva values interpolated into a string with the following format:
 * "hsva(xxx, xxx, xxx, xx)".
 * @return {string}
 */
tinycolorInstance.prototype.toHsvString = function() {};

/**
 * Returns the object as a HSLA object.
 * @return {!ColorFormats.HSLA}
 */
tinycolorInstance.prototype.toHsl = function() {};

/**
 * Returns the hsla values interpolated into a string with the following format:
 * "hsla(xxx, xxx, xxx, xx)".
 * @return {string}
 */
tinycolorInstance.prototype.toHslString = function() {};

/**
 * Returns the hex value of the color.
 * @return {string}
 */
tinycolorInstance.prototype.toHex = function() {};

/**
 * Returns the hex value of the color -with a # appened.
 * @return {string}
 */
tinycolorInstance.prototype.toHexString = function() {};

/**
 * Returns the hex 8 value of the color.
 * @return {string}
 */
tinycolorInstance.prototype.toHex8 = function() {};

/**
 * Returns the hex 8  value of the color -with a # appened.
 * @return {string}
 */
tinycolorInstance.prototype.toHex8String = function() {};

/**
 * Returns the object as a RGBA object.
 * @return {!ColorFormats.RGBA}
 */
tinycolorInstance.prototype.toRgb = function() {};

/**
 * Returns the RGBA values interpolated into a string with the following format:
 * "RGBA(xxx, xxx, xxx, xx)".
 * @return {string}
 */
tinycolorInstance.prototype.toRgbString = function() {};

/**
 * Returns the object as a RGBA object.
 * @return {!ColorFormats.RGBA}
 */
tinycolorInstance.prototype.toPercentageRgb = function() {};

/**
 * Returns the RGBA relative values interpolated into a string with the following format:
 * "RGBA(xxx, xxx, xxx, xx)".
 * @return {string}
 */
tinycolorInstance.prototype.toPercentageRgbString = function() {};

/**
 * The 'real' name of the color -if there is one.
 * @return {string}
 */
tinycolorInstance.prototype.toName = function() {};

/**
 * Returns the color represented as a Microsoft filter for use in old versions of IE.
 * @return {string}
 */
tinycolorInstance.prototype.toFilter = function() {};

/**
 * String representation of the color.
 * 
 * @param {string=} format - The format to be used when displaying the string representation.
 *  The accepted values are: "rgb", "prgb", "hex6", "hex3", "hex8", "name", "hsl", "hsv".
 * @return {string}
 */
tinycolorInstance.prototype.toString = function(format) {};

/**
 * Lighten the color a given amount. Providing 100 will always return white.
 * 
 * @param {number=} amount - The amount to lighten by. The valid range is 0 to 100.
 *  Default value: 10.
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.lighten = function(amount) {};

/**
 * Brighten the color a given amount.
 * 
 * @param {number=} amount - The amount to brighten by. The valid range is 0 to 100.
 *  Default value: 10.
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.brighten = function(amount) {};

/**
 * Darken the color a given amount.
 *  Providing 100 will always return black.
 * 
 * @param {number=} amount - The amount to darken by. The valid range is 0 to 100.
 *  Default value: 10.
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.darken = function(amount) {};

/**
 * Desaturate the color a given amount.
 *  Providing 100 will is the same as calling greyscale.
 * 
 * @param {number=} amount - The amount to desaturate by. The valid range is 0 to 100.
 *  Default value: 10.
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.desaturate = function(amount) {};

/**
 * Saturate the color a given amount.
 * 
 * @param {number=} amount - The amount to saturate by. The valid range is 0  to 100.
 *  Default value: 10.
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.saturate = function(amount) {};

/**
 * Completely desaturates a color into greyscale.
 * Same as calling desaturate(100).
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.greyscale = function() {};

/**
 * Spin the hue a given amount. Calling with 0, 360, or -360 will do nothing.
 * 
 * @param {number=} amount - The amount to spin by. The valid range is -360 to 360.
 *  Default value: 0.
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.spin = function(amount) {};

/**
 * Gets an analogous color scheme based off of the current color.
 * 
 * @param {number=} results - The amount of results to return.
 *  Default value: 6.
 * @param {number=} slices - The amount to slice the input color by.
 *  Default value: 30.
 * @return {!Array<!tinycolorInstance>}
 */
tinycolorInstance.prototype.analogous = function(results, slices) {};

/**
 * Gets a monochromatic color scheme based off of the current color.
 * 
 * @param {number=} results - The amount of results to return.
 *  Default value: 6.
 * @return {!Array<!tinycolorInstance>}
 */
tinycolorInstance.prototype.monochromatic = function(results) {};

/**
 * Gets a split complement color scheme based off of the current color.
 * @return {!Array<!tinycolorInstance>}
 */
tinycolorInstance.prototype.splitcomplement = function() {};

/**
 * Gets a triad based off of the current color.
 * @return {!Array<!tinycolorInstance>}
 */
tinycolorInstance.prototype.triad = function() {};

/**
 * Gets a tetrad based off of the current color.
 * @return {!Array<!tinycolorInstance>}
 */
tinycolorInstance.prototype.tetrad = function() {};

/**
 * Gets the complement of the current color
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.complement = function() {};

/**
 * Gets a new instance with the current color
 * @return {!tinycolorInstance}
 */
tinycolorInstance.prototype.clone = function() {};
/** @const */
var Readable = {};
/**
 * @record
 * @struct
 */
Readable.Readable = function() {};
 /** @type {number} */
Readable.Readable.prototype.brightness;
 /** @type {number} */
Readable.Readable.prototype.color;
/** @const */
var ColorFormats = {};
/**
 * @record
 * @struct
 */
ColorFormats.RGB = function() {};
 /** @type {number} */
ColorFormats.RGB.prototype.r;
 /** @type {number} */
ColorFormats.RGB.prototype.g;
 /** @type {number} */
ColorFormats.RGB.prototype.b;
/**
 * @extends {ColorFormats.RGB}
 * @record
 * @struct
 */
ColorFormats.RGBA = function() {};
 /** @type {number} */
ColorFormats.RGBA.prototype.a;
/**
 * @record
 * @struct
 */
ColorFormats.HSL = function() {};
 /** @type {number} */
ColorFormats.HSL.prototype.h;
 /** @type {number} */
ColorFormats.HSL.prototype.s;
 /** @type {number} */
ColorFormats.HSL.prototype.l;
/**
 * @extends {ColorFormats.HSL}
 * @record
 * @struct
 */
ColorFormats.HSLA = function() {};
 /** @type {number} */
ColorFormats.HSLA.prototype.a;
/**
 * @record
 * @struct
 */
ColorFormats.HSV = function() {};
 /** @type {number} */
ColorFormats.HSV.prototype.h;
 /** @type {number} */
ColorFormats.HSV.prototype.s;
 /** @type {number} */
ColorFormats.HSV.prototype.v;
/**
 * @extends {ColorFormats.HSV}
 * @record
 * @struct
 */
ColorFormats.HSVA = function() {};
 /** @type {number} */
ColorFormats.HSVA.prototype.a;

/** @typedef {(string|!tinycolorInstance|!ColorFormats.RGB|!ColorFormats.RGBA|!ColorFormats.HSL|!ColorFormats.HSLA|!ColorFormats.HSV|!ColorFormats.HSVA)} */
var ColorInput;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "tinycolor2"
/** @const */
tsickle_declare_module.tinycolor_ = {};

/* TODO: ExportAssignment in tsickle_declare_module.tinycolor_ */
