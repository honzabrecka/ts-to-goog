/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bytebuffer/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */
/** @const */
var ByteBuffer = {};

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
 /** @type {boolean} */
ByteBuffer.BIG_ENDIAN;
 /** @type {number} */
ByteBuffer.DEFAULT_CAPACITY;
 /** @type {boolean} */
ByteBuffer.DEFAULT_ENDIAN;
 /** @type {boolean} */
ByteBuffer.DEFAULT_NOASSERT;
 /** @type {boolean} */
ByteBuffer.LITTLE_ENDIAN;
 /** @type {number} */
ByteBuffer.MAX_VARINT32_BYTES;
 /** @type {number} */
ByteBuffer.MAX_VARINT64_BYTES;
 /** @type {number} */
ByteBuffer.METRICS_BYTES;
 /** @type {number} */
ByteBuffer.METRICS_CHARS;
 /** @type {string} */
ByteBuffer.VERSION;
 /** @type {!ArrayBuffer} */
ByteBuffer.prototype.buffer;
 /** @type {number} */
ByteBuffer.prototype.limit;
 /** @type {boolean} */
ByteBuffer.prototype.littleEndian;
 /** @type {number} */
ByteBuffer.prototype.markedOffset;
 /** @type {boolean} */
ByteBuffer.prototype.noAssert;
 /** @type {number} */
ByteBuffer.prototype.offset;
 /** @type {!DataView} */
ByteBuffer.prototype.view;

/**
 * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
 * @param {number=} capacity
 * @param {boolean=} littleEndian
 * @param {boolean=} noAssert
 * @return {!ByteBuffer}
 */
ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {};

/**
 * Decodes a base64 encoded string to binary like window.atob does.
 * @param {string} b64
 * @return {string}
 */
ByteBuffer.atob = function(b64) {};

/**
 * Encodes a binary string to base64 like window.btoa does.
 * @param {string} str
 * @return {string}
 */
ByteBuffer.btoa = function(str) {};

/**
 * Calculates the number of UTF8 bytes of a string.
 * @param {string} str
 * @return {number}
 */
ByteBuffer.calculateUTF8Byte = function(str) {};

/**
 * Calculates the number of UTF8 characters of a string.JavaScript itself uses UTF- 16, so that a string's length property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
 * @param {string} str
 * @return {number}
 */
ByteBuffer.calculateUTF8Char = function(str) {};

/**
 * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
 * @param {number} value
 * @return {number}
 */
ByteBuffer.calculateVariant32 = function(value) {};

/**
 * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
 * @param {(number|!Long)} value
 * @return {number}
 */
ByteBuffer.calculateVariant64 = function(value) {};

/**
 * Concatenates multiple ByteBuffers into one.
 * @param {!Array<(string|!ArrayBuffer|!ByteBuffer|!Uint8Array)>} buffers
 * @param {(string|boolean)=} encoding
 * @param {boolean=} litteEndian
 * @param {boolean=} noAssert
 * @return {!ByteBuffer}
 */
ByteBuffer.concat = function(buffers, encoding, litteEndian, noAssert) {};

/**
 * Decodes a base64 encoded string to a ByteBuffer.
 * @param {string} str
 * @param {boolean=} littleEndian
 * @param {boolean=} noAssert
 * @return {!ByteBuffer}
 */
ByteBuffer.fromBase64 = function(str, littleEndian, noAssert) {};

/**
 * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
 * @param {string} str
 * @param {boolean=} littleEndian
 * @param {boolean=} noAssert
 * @return {!ByteBuffer}
 */
ByteBuffer.fromBinary = function(str, littleEndian, noAssert) {};

/**
 * Decodes a hex encoded string with marked offsets to a ByteBuffer.
 * @param {string} str
 * @param {boolean=} littleEndian
 * @param {boolean=} noAssert
 * @return {!ByteBuffer}
 */
ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {};

/**
 * Decodes a hex encoded string to a ByteBuffer.
 * @param {string} str
 * @param {boolean=} littleEndian
 * @param {boolean=} noAssert
 * @return {!ByteBuffer}
 */
ByteBuffer.fromHex = function(str, littleEndian, noAssert) {};

/**
 * Decodes an UTF8 encoded string to a ByteBuffer.
 * @param {string} str
 * @param {boolean=} littleEndian
 * @param {boolean=} noAssert
 * @return {!ByteBuffer}
 */
ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {};

/**
 * Gets the backing buffer type.
 * @param {?} bb
 * @return {boolean}
 */
ByteBuffer.isByteBuffer = function(bb) {};

/**
 * Wraps a buffer or a string. Sets the allocated ByteBuffer's ByteBuffer#offset to 0 and its ByteBuffer#limit to the length of the wrapped data.
 * @param {(string|!ArrayBuffer|!ByteBuffer|!Uint8Array)} buffer Anything that can be wrapped
 * @param {(string|boolean)=} enc
 * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to ByteBuffer.DEFAULT_ENDIAN.
 * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to ByteBuffer.DEFAULT_NOASSERT.
 * @return {!ByteBuffer}
 */
ByteBuffer.wrap = function(buffer, enc, littleEndian, noAssert) {};

/**
 * Decodes a zigzag encoded signed 32bit integer.
 * @param {number} n
 * @return {number}
 */
ByteBuffer.zigZagDecode32 = function(n) {};

/**
 * Decodes a zigzag encoded signed 64bit integer.
 * @param {(number|!Long)} n
 * @return {!Long}
 */
ByteBuffer.zigZagDecode64 = function(n) {};

/**
 * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
 * @param {number} n
 * @return {number}
 */
ByteBuffer.zigZagEncode32 = function(n) {};

/**
 * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
 * @param {(number|!Long)} n
 * @return {!Long}
 */
ByteBuffer.zigZagEncode64 = function(n) {};

/**
 * Switches (to) big endian byte order.
 * @param {boolean=} bigEndian
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.BE = function(bigEndian) {};

/**
 * Switches (to) little endian byte order.
 * @param {boolean=} bigEndian
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.LE = function(bigEndian) {};

/**
 * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended data's length.
 * @param {(string|!ArrayBuffer|!ByteBuffer|!Uint8Array)} source
 * @param {(string|number)=} encoding
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.append = function(source, encoding, offset) {};

/**
 * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents behind the specified offset up to the length of this ByteBuffer's data.
 * @param {!ByteBuffer} target
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.appendTo = function(target, offset) {};

/**
 * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to disable them if your code already makes sure that everything is valid.
 * @param {boolean} assert
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.assert = function(assert) {};

/**
 * Gets the capacity of this ByteBuffer's backing buffer.
 * @return {number}
 */
ByteBuffer.prototype.capacity = function() {};

/**
 * Clears this ByteBuffer's offsets by setting ByteBuffer#offset to 0 and
 * ByteBuffer#limit to the backing buffer's capacity. Discards ByteBuffer#markedOffset.
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.clear = function() {};

/**
 * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for ByteBuffer#offset, ByteBuffer#markedOffset and ByteBuffer#limit.
 * @param {boolean=} copy
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.clone = function(copy) {};

/**
 * Compacts this ByteBuffer to be backed by a ByteBuffer#buffer of its contents' length. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit. Will set offset = 0 and limit = capacity and adapt ByteBuffer#markedOffset to the same relative position if set.
 * @param {number=} begin
 * @param {number=} end
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.compact = function(begin, end) {};

/**
 * Creates a copy of this ByteBuffer's contents. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit.
 * @param {number=} begin
 * @param {number=} end
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.copy = function(begin, end) {};

/**
 * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit.
 * @param {!ByteBuffer} target
 * @param {number=} targetOffset
 * @param {number=} sourceOffset
 * @param {number=} sourceLimit
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {};

/**
 * Makes sure that this ByteBuffer is backed by a ByteBuffer#buffer of at least the specified capacity. If the current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity, the required capacity will be used instead.
 * @param {number} capacity
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.ensureCapacity = function(capacity) {};

/**
 * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit.
 * @param {(string|number)} value
 * @param {number=} begin
 * @param {number=} end
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.fill = function(value, begin, end) {};

/**
 * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets limit = offset and offset = 0. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.flip = function() {};

/**
 * Marks an offset on this ByteBuffer to be used later.
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.mark = function(offset) {};

/**
 * Sets the byte order.
 * @param {boolean} littleEndian
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.order = function(littleEndian) {};

/**
 * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the prepended data's length. If there is not enough space available before the specified offset, the backing buffer will be resized and its contents moved accordingly.
 * @param {(string|!ArrayBuffer|!ByteBuffer)} source
 * @param {(string|number)=} encoding
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.prepend = function(source, encoding, offset) {};

/**
 * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the prepended data's length. If there is not enough space available before the specified offset, the backing buffer will be resized and its contents moved accordingly.
 * @param {!ByteBuffer} target
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.prependTo = function(target, offset) {};

/**
 * Prints debug information about this ByteBuffer's contents.
 * @param {function(string): void=} out
 * @return {void}
 */
ByteBuffer.prototype.printDebug = function(out) {};

/**
 * Reads an 8bit signed integer. This is an alias of ByteBuffer#readInt8.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readByte = function(offset) {};

/**
 * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters itself.
 * @param {number=} offset
 * @return {string}
 */
ByteBuffer.prototype.readCString = function(offset) {};

/**
 * Reads a 64bit float. This is an alias of ByteBuffer#readFloat64.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readDouble = function(offset) {};

/**
 * Reads a 32bit float. This is an alias of ByteBuffer#readFloat32.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readFloat = function(offset) {};

/**
 * Reads a 32bit float.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readFloat32 = function(offset) {};

/**
 * Reads a 64bit float.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readFloat64 = function(offset) {};

/**
 * Reads a length as uint32 prefixed UTF8 encoded string.
 * @param {number=} offset
 * @return {string}
 */
ByteBuffer.prototype.readIString = function(offset) {};

/**
 * Reads a 32bit signed integer.This is an alias of ByteBuffer#readInt32.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readInt = function(offset) {};

/**
 * Reads a 16bit signed integer.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readInt16 = function(offset) {};

/**
 * Reads a 32bit signed integer.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readInt32 = function(offset) {};

/**
 * Reads a 64bit signed integer.
 * @param {number=} offset
 * @return {!Long}
 */
ByteBuffer.prototype.readInt64 = function(offset) {};

/**
 * Reads an 8bit signed integer.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readInt8 = function(offset) {};

/**
 * Reads a 64bit signed integer. This is an alias of ByteBuffer#readInt64.
 * @param {number=} offset
 * @return {!Long}
 */
ByteBuffer.prototype.readLong = function(offset) {};

/**
 * Reads a 16bit signed integer. This is an alias of ByteBuffer#readInt16.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readShort = function(offset) {};

/**
 * Reads an UTF8 encoded string. This is an alias of ByteBuffer#readUTF8String.
 * @param {number} length
 * @param {number=} metrics
 * @param {number=} offset
 * @return {string}
 */
ByteBuffer.prototype.readString = function(length, metrics, offset) {};

/**
 * Reads an UTF8 encoded string.
 * @param {number} chars
 * @param {number=} offset
 * @return {string}
 */
ByteBuffer.prototype.readUTF8String = function(chars, offset) {};

/**
 * Reads a 16bit unsigned integer.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readUint16 = function(offset) {};

/**
 * Reads a 32bit unsigned integer.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readUint32 = function(offset) {};

/**
 * Reads a 64bit unsigned integer.
 * @param {number=} offset
 * @return {!Long}
 */
ByteBuffer.prototype.readUint64 = function(offset) {};

/**
 * Reads an 8bit unsigned integer.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readUint8 = function(offset) {};

/**
 * Reads a length as varint32 prefixed UTF8 encoded string.
 * @param {number=} offset
 * @return {string}
 */
ByteBuffer.prototype.readVString = function(offset) {};

/**
 * Reads a 32bit base 128 variable-length integer.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readVarint32 = function(offset) {};

/**
 * Reads a zig-zag encoded 32bit base 128 variable-length integer.
 * @param {number=} offset
 * @return {number}
 */
ByteBuffer.prototype.readVarint32ZiZag = function(offset) {};

/**
 * Reads a 64bit base 128 variable-length integer. Requires Long.js.
 * @param {number=} offset
 * @return {!Long}
 */
ByteBuffer.prototype.readVarint64 = function(offset) {};

/**
 * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
 * @param {number=} offset
 * @return {!Long}
 */
ByteBuffer.prototype.readVarint64ZigZag = function(offset) {};

/**
 * Gets the number of remaining readable bytes. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit, so this returns limit - offset.
 * @return {number}
 */
ByteBuffer.prototype.remaining = function() {};

/**
 * Resets this ByteBuffer's ByteBuffer#offset. If an offset has been marked through ByteBuffer#mark before, offset will be set to ByteBuffer#markedOffset, which will then be discarded. If no offset has been marked, sets offset = 0.
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.reset = function() {};

/**
 * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that large or larger.
 * @param {number} capacity
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.resize = function(capacity) {};

/**
 * Reverses this ByteBuffer's contents
 * @param {number=} begin
 * @param {number=} end
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.reverse = function(begin, end) {};

/**
 * Skips the next length bytes. This will just advance
 * @param {number} length
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.skip = function(length) {};

/**
 * Slices this ByteBuffer by creating a cloned instance with offset = begin and limit = end.
 * @param {number=} begin
 * @param {number=} end
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.slice = function(begin, end) {};

/**
 * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit. Will transparently ByteBuffer#flip this ByteBuffer if offset > limit but the actual offsets remain untouched. This is an alias of ByteBuffer#toBuffer.
 * @param {boolean=} forceCopy
 * @return {!ArrayBuffer}
 */
ByteBuffer.prototype.toArrayBuffer = function(forceCopy) {};

/**
 * Encodes this ByteBuffer's contents to a base64 encoded string.
 * @param {number=} begin
 * @param {number=} end
 * @return {string}
 */
ByteBuffer.prototype.toBase64 = function(begin, end) {};

/**
 * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
 * @param {number=} begin
 * @param {number=} end
 * @return {string}
 */
ByteBuffer.prototype.toBinary = function(begin, end) {};

/**
 * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit. Will transparently ByteBuffer#flip this ByteBuffer if offset > limit but the actual offsets remain untouched.
 * @param {boolean=} forceCopy
 * @return {!ArrayBuffer}
 */
ByteBuffer.prototype.toBuffer = function(forceCopy) {};

/**
 * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
 *  < : offset,
 *  ' : markedOffset,
 *  > : limit,
 *  | : offset and limit,
 *  [ : offset and markedOffset,
 *  ] : markedOffset and limit,
 *  ! : offset, markedOffset and limit
 * @param {boolean=} columns
 * @return {(string|!Array<string>)}
 */
ByteBuffer.prototype.toDebug = function(columns) {};

/**
 * Encodes this ByteBuffer's contents to a hex encoded string.
 * @param {number=} begin
 * @param {number=} end
 * @return {string}
 */
ByteBuffer.prototype.toHex = function(begin, end) {};

/**
 * Converts the ByteBuffer's contents to a string.
 * @param {string=} encoding
 * @return {string}
 */
ByteBuffer.prototype.toString = function(encoding) {};

/**
 * Encodes this ByteBuffer's contents between ByteBuffer#offset and ByteBuffer#limit to an UTF8 encoded string.
 * @return {string}
 */
ByteBuffer.prototype.toUTF8 = function() {};

/**
 * Writes an 8bit signed integer. This is an alias of ByteBuffer#writeInt8.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeByte = function(value, offset) {};

/**
 * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL characters itself.
 * @param {string} str
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeCString = function(str, offset) {};

/**
 * Writes a 64bit float. This is an alias of ByteBuffer#writeFloat64.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeDouble = function(value, offset) {};

/**
 * Writes a 32bit float. This is an alias of ByteBuffer#writeFloat32.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeFloat = function(value, offset) {};

/**
 * Writes a 32bit float.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeFloat32 = function(value, offset) {};

/**
 * Writes a 64bit float.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeFloat64 = function(value, offset) {};

/**
 * Writes a length as uint32 prefixed UTF8 encoded string.
 * @param {string} str
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeIString = function(str, offset) {};

/**
 * Writes a 32bit signed integer. This is an alias of ByteBuffer#writeInt32.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeInt = function(value, offset) {};

/**
 * Writes a 16bit signed integer.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeInt16 = function(value, offset) {};

/**
 * Writes a 32bit signed integer.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeInt32 = function(value, offset) {};

/**
 * Writes a 64bit signed integer.
 * @param {(number|!Long)} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeInt64 = function(value, offset) {};

/**
 * Writes an 8bit signed integer.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeInt8 = function(value, offset) {};

/**
 * Writes a 16bit signed integer. This is an alias of ByteBuffer#writeInt16.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeShort = function(value, offset) {};

/**
 * Writes an UTF8 encoded string.This is an alias of ByteBuffer#writeUTF8String.
 * @param {string} str
 * @param {number=} offset
 * @return {(number|!ByteBuffer)}
 */
ByteBuffer.prototype.WriteString = function(str, offset) {};

/**
 * Writes an UTF8 encoded string.
 * @param {string} str
 * @param {number=} offset
 * @return {(number|!ByteBuffer)}
 */
ByteBuffer.prototype.writeUTF8String = function(str, offset) {};

/**
 * Writes a 16bit unsigned integer.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeUint16 = function(value, offset) {};

/**
 * Writes a 32bit unsigned integer.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeUint32 = function(value, offset) {};

/**
 * Writes a 64bit unsigned integer.
 * @param {(number|!Long)} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeUint64 = function(value, offset) {};

/**
 * Writes an 8bit unsigned integer.
 * @param {number} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeUint8 = function(value, offset) {};

/**
 * Writes a length as varint32 prefixed UTF8 encoded string.
 * @param {string} str
 * @param {number=} offset
 * @return {(number|!ByteBuffer)}
 */
ByteBuffer.prototype.writeVString = function(str, offset) {};

/**
 * Writes a 32bit base 128 variable-length integer.
 * @param {number} value
 * @param {number=} offset
 * @return {(number|!ByteBuffer)}
 */
ByteBuffer.prototype.writeVarint32 = function(value, offset) {};

/**
 * Writes a zig-zag encoded 32bit base 128 variable-length integer.
 * @param {number} value
 * @param {number=} offset
 * @return {(number|!ByteBuffer)}
 */
ByteBuffer.prototype.writeVarint32ZigZag = function(value, offset) {};

/**
 * Writes a 64bit base 128 variable-length integer.
 * @param {(number|!Long)} value
 * @param {number=} offset
 * @return {!ByteBuffer}
 */
ByteBuffer.prototype.writeVarint64 = function(value, offset) {};

/**
 * Writes a zig-zag encoded 64bit base 128 variable-length integer.
 * @param {(number|!Long)} value
 * @param {number=} offset
 * @return {(number|!ByteBuffer)}
 */
ByteBuffer.prototype.writeVarint64ZigZag = function(value, offset) {};
