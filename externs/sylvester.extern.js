/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/sylvester/index.d.ts:
/** @const */
var Sylvester = {};
/**
 * @record
 * @struct
 */
Sylvester.VectorStatic = function() {};
 /** @type {?} */
Sylvester.VectorStatic.prototype.i;
 /** @type {?} */
Sylvester.VectorStatic.prototype.j;
 /** @type {?} */
Sylvester.VectorStatic.prototype.k;

/**
 * Constructor function.
 * @param {(?|!Array<number>)} elements
 * @return {?}
 */
Sylvester.VectorStatic.prototype.create = function(elements) {};

/**
 * Random vector of size n.
 * 
 * @param {number} n
 * @return {?}
 */
Sylvester.VectorStatic.prototype.Random = function(n) {};

/**
 * Vector filled with zeros.
 * 
 * @param {number} n
 * @return {?}
 */
Sylvester.VectorStatic.prototype.Zero = function(n) {};
/**
 * @record
 * @struct
 */
Sylvester.MatrixStatic = function() {};

/**
 * Constructor function.
 * 
 * @param {(?|!Array<number>|!Array<!Array<number>>)} elements
 * @return {?}
 */
Sylvester.MatrixStatic.prototype.create = function(elements) {};

/**
 * Identity matrix of size n.
 * 
 * @param {number} n
 * @return {?}
 */
Sylvester.MatrixStatic.prototype.I = function(n) {};

/**
 * Diagonal matrix - all off-diagonal elements are zero
 * 
 * @param {(?|!Array<number>|!Array<!Array<number>>)} elements
 * @return {?}
 */
Sylvester.MatrixStatic.prototype.Diagonal = function(elements) {};

/**
 * Rotation matrix about some axis. If no axis is supplied, assume we're after a 2D transform.
 * 
 * @param {number} theta
 * @param {?=} a
 * @return {?}
 */
Sylvester.MatrixStatic.prototype.Rotation = function(theta, a) {};

/**
 * @param {number} t
 * @return {?}
 */
Sylvester.MatrixStatic.prototype.RotationX = function(t) {};

/**
 * @param {number} t
 * @return {?}
 */
Sylvester.MatrixStatic.prototype.RotationY = function(t) {};

/**
 * @param {number} t
 * @return {?}
 */
Sylvester.MatrixStatic.prototype.RotationZ = function(t) {};

/**
 * Random matrix of n rows, m columns.
 * 
 * @param {number} n
 * @param {number} m
 * @return {?}
 */
Sylvester.MatrixStatic.prototype.Random = function(n, m) {};

/**
 * Matrix filled with zeros.
 * 
 * @param {number} n
 * @param {number} m
 * @return {?}
 */
Sylvester.MatrixStatic.prototype.Zero = function(n, m) {};
/**
 * @record
 * @struct
 */
Sylvester.LineStatic = function() {};
 /** @type {?} */
Sylvester.LineStatic.prototype.X;
 /** @type {?} */
Sylvester.LineStatic.prototype.Y;
 /** @type {?} */
Sylvester.LineStatic.prototype.Z;

/**
 * Constructor function.
 * 
 * @param {(?|!Array<number>)} anchor
 * @param {(?|!Array<number>)} direction
 * @return {?}
 */
Sylvester.LineStatic.prototype.create = function(anchor, direction) {};
/**
 * @record
 * @struct
 */
Sylvester.PlaneStatic = function() {};
 /** @type {?} */
Sylvester.PlaneStatic.prototype.XY;
 /** @type {?} */
Sylvester.PlaneStatic.prototype.YZ;
 /** @type {?} */
Sylvester.PlaneStatic.prototype.ZX;
 /** @type {?} */
Sylvester.PlaneStatic.prototype.YX;

/**
 * Constructor function.
 * Constructor function.
 * @param {(?|!Array<number>)} anchor
 * @param {(?|!Array<number>)} normal_or_v1
 * @param {(?|!Array<number>)=} v2
 * @return {?}
 */
Sylvester.PlaneStatic.prototype.create = function(anchor, normal_or_v1, v2) {};
/**
 * @record
 * @struct
 */
function Vector() {}
 /** @type {!Array<number>} */
Vector.prototype.elements;

/**
 * Returns element i of the vector.
 * @param {number} i
 * @return {number}
 */
Vector.prototype.e = function(i) {};

/**
 * Returns the number of elements the vector has.
 * @return {number}
 */
Vector.prototype.dimensions = function() {};

/**
 * Returns the modulus ('length') of the vector.
 * @return {number}
 */
Vector.prototype.modulus = function() {};

/**
 * Returns true if the vector is equal to the argument.
 * 
 * @param {(?|!Array<number>)} vector
 * @return {boolean}
 */
Vector.prototype.eql = function(vector) {};

/**
 * Returns a copy of the vector.
 * @return {?}
 */
Vector.prototype.dup = function() {};

/**
 * Maps the vector to another vector according to the given function.
 * 
 * @param {function(number, number): ?} fn
 * @return {?}
 */
Vector.prototype.map = function(fn) {};

/**
 * Calls the iterator for each element of the vector in turn.
 * 
 * @param {function(number, number): ?} fn
 * @return {void}
 */
Vector.prototype.each = function(fn) {};

/**
 * Returns a new vector created by normalizing the receiver.
 * @return {?}
 */
Vector.prototype.toUnitVector = function() {};

/**
 * Returns the angle between the vector and the argument (also a vector).
 * 
 * @param {?} vector
 * @return {number}
 */
Vector.prototype.angleFrom = function(vector) {};

/**
 * Returns true if the vector is parallel to the argument.
 * 
 * @param {?} vector
 * @return {boolean}
 */
Vector.prototype.isParallelTo = function(vector) {};

/**
 * Returns true if the vector is antiparallel to the argument.
 * 
 * @param {?} vector
 * @return {boolean}
 */
Vector.prototype.isAntiparallelTo = function(vector) {};

/**
 * Returns true iff the vector is perpendicular to the argument.
 * 
 * @param {?} vector
 * @return {boolean}
 */
Vector.prototype.isPerpendicularTo = function(vector) {};

/**
 * Returns the result of adding the argument to the vector.
 * 
 * @param {(?|!Array<number>)} vector
 * @return {?}
 */
Vector.prototype.add = function(vector) {};

/**
 * Returns the result of subtracting the argument from the vector.
 * 
 * @param {(?|!Array<number>)} vector
 * @return {?}
 */
Vector.prototype.subtract = function(vector) {};

/**
 * Returns the result of multiplying the elements of the vector by the argument.
 * 
 * @param {number} k
 * @return {?}
 */
Vector.prototype.multiply = function(k) {};

/**
 * Returns the result of multiplying the elements of the vector by the argument (Alias for multiply(k)).
 * 
 * @param {number} k
 * @return {?}
 */
Vector.prototype.x = function(k) {};

/**
 * Returns the scalar product of the vector with the argument. Both vectors must have equal dimensionality.
 * 
 * \@param: {Vector|Array<number>} vector The other vector.
 * @param {(?|!Array<number>)} vector
 * @return {number}
 */
Vector.prototype.dot = function(vector) {};

/**
 * Returns the vector product of the vector with the argument. Both vectors must have dimensionality 3.
 * 
 * @param {(?|!Array<number>)} vector
 * @return {?}
 */
Vector.prototype.cross = function(vector) {};

/**
 * Returns the (absolute) largest element of the vector.
 * @return {number}
 */
Vector.prototype.max = function() {};

/**
 * Returns the index of the first match found.
 * 
 * @param {number} x
 * @return {number}
 */
Vector.prototype.indexOf = function(x) {};

/**
 * Returns a diagonal matrix with the vector's elements as its diagonal elements.
 * @return {?}
 */
Vector.prototype.toDiagonalMatrix = function() {};

/**
 * Returns the result of rounding the elements of the vector.
 * @return {?}
 */
Vector.prototype.round = function() {};

/**
 * Returns a copy of the vector with elements set to the given value if they differ from
 * it by less than Sylvester.precision.
 * 
 * @param {number} x
 * @return {?}
 */
Vector.prototype.snapTo = function(x) {};

/**
 * Returns the vector's distance from the argument, when considered as a point in space.
 * 
 * @param {?} obj
 * @return {number}
 */
Vector.prototype.distanceFrom = function(obj) {};

/**
 * Returns true if the vector is point on the given line.
 * 
 * @param {?} line
 * @return {boolean}
 */
Vector.prototype.liesOn = function(line) {};

/**
 * Return true if the vector is a point in the given plane.
 * 
 * @param {?} plane
 * @return {boolean}
 */
Vector.prototype.liesIn = function(plane) {};

/**
 * Rotates the vector about the given object. The object should be a point if the vector is 2D,
 * and a line if it is 3D. Be careful with line directions!
 * 
 * @param {number} t
 * @param {?} obj
 * @return {?}
 */
Vector.prototype.rotate = function(t, obj) {};

/**
 * Returns the result of reflecting the point in the given point, line or plane.
 * 
 * @param {?} obj
 * @return {?}
 */
Vector.prototype.reflectionIn = function(obj) {};

/**
 * Utility to make sure vectors are 3D. If they are 2D, a zero z-component is added.
 * @return {?}
 */
Vector.prototype.to3D = function() {};

/**
 * Returns a string representation of the vector.
 * @return {string}
 */
Vector.prototype.inspect = function() {};

/**
 * Set vector's elements from an array.
 * 
 * @param {(?|!Array<number>)} els
 * @return {?}
 */
Vector.prototype.setElements = function(els) {};
/**
 * @record
 * @struct
 */
function Matrix() {}
 /** @type {!Array<!Array<number>>} */
Matrix.prototype.elements;

/**
 * Returns element (i,j) of the matrix.
 * 
 * @param {number} i
 * @param {number} j
 * @return {?}
 */
Matrix.prototype.e = function(i, j) {};

/**
 * Returns row k of the matrix as a vector.
 * 
 * @param {number} i
 * @return {?}
 */
Matrix.prototype.row = function(i) {};

/**
 * Returns column k of the matrix as a vector.
 * 
 * @param {number} j
 * @return {?}
 */
Matrix.prototype.col = function(j) {};

/**
 * Returns the number of rows/columns the matrix has.
 * 
 * @return {?}
 */
Matrix.prototype.dimensions = function() {};

/**
 * Returns the number of rows in the matrix.
 * @return {number}
 */
Matrix.prototype.rows = function() {};

/**
 * Returns the number of columns in the matrix.
 * @return {number}
 */
Matrix.prototype.cols = function() {};

/**
 * Returns true if the matrix is equal to the argument. You can supply a vector as the argument,
 * in which case the receiver must be a one-column matrix equal to the vector.
 * 
 * @param {?} matrix
 * @return {boolean}
 */
Matrix.prototype.eql = function(matrix) {};

/**
 * Returns a copy of the matrix.
 * @return {?}
 */
Matrix.prototype.dup = function() {};

/**
 * Maps the matrix to another matrix (of the same dimensions) according to the given function.
 * 
 * @param {function(number, number, number): ?} fn
 * @return {?}
 */
Matrix.prototype.map = function(fn) {};

/**
 * Returns true iff the argument has the same dimensions as the matrix.
 * 
 * @param {?} matrix
 * @return {boolean}
 */
Matrix.prototype.isSameSizeAs = function(matrix) {};

/**
 * Returns the result of adding the argument to the matrix.
 * 
 * @param {?} matrix
 * @return {?}
 */
Matrix.prototype.add = function(matrix) {};

/**
 * Returns the result of subtracting the argument from the matrix.
 * 
 * @param {?} matrix
 * @return {?}
 */
Matrix.prototype.subtract = function(matrix) {};

/**
 * Returns true iff the matrix can multiply the argument from the left.
 * 
 * @param {?} matrix
 * @return {boolean}
 */
Matrix.prototype.canMultiplyFromLeft = function(matrix) {};

/**
 * Returns the result of multiplying the matrix from the right by the argument. If the argument is a scalar
 * then just multiply all the elements. If the argument is a vector, a vector is returned, which saves you
 * having to remember calling col(1) on the result.
 * 
 * Returns the result of multiplying the matrix from the right by the argument. If the argument is a scalar
 * then just multiply all the elements. If the argument is a vector, a vector is returned, which saves you
 * having to remember calling col(1) on the result.
 * 
 * @param {(number|?)|?} matrix_or_vector
 * @return {?}
 */
Matrix.prototype.multiply = function(matrix_or_vector) {};

/**
 * @param {(number|?)|?} matrix_or_vector
 * @return {?}
 */
Matrix.prototype.x = function(matrix_or_vector) {};

/**
 * Returns a submatrix taken from the matrix. Argument order is: start row, start col, nrows, ncols.
 * Element selection wraps if the required index is outside the matrix's bounds, so you could use
 * this to perform row/column cycling or copy-augmenting.
 * 
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @return {?}
 */
Matrix.prototype.minor = function(a, b, c, d) {};

/**
 * Returns the transpose of the matrix.
 * @return {?}
 */
Matrix.prototype.transpose = function() {};

/**
 * Returns true if the matrix is square.
 * @return {boolean}
 */
Matrix.prototype.isSquare = function() {};

/**
 * Returns the (absolute) largest element of the matrix.
 * @return {number}
 */
Matrix.prototype.max = function() {};

/**
 * Returns the indeces of the first match found by reading row-by-row from left to right.
 * 
 * 
 * @param {number} x
 * @return {?}
 */
Matrix.prototype.indexOf = function(x) {};

/**
 * If the matrix is square, returns the diagonal elements as a vector; otherwise, returns null.
 * @return {?}
 */
Matrix.prototype.diagonal = function() {};

/**
 * Make the matrix upper (right) triangular by Gaussian elimination. This method only adds multiples
 * of rows to other rows. No rows are scaled up or switched, and the determinant is preserved.
 * @return {?}
 */
Matrix.prototype.toRightTriangular = function() {};

/**
 * @return {?}
 */
Matrix.prototype.toUpperTriangular = function() {};

/**
 * Returns the determinant for square matrices.
 * @return {number}
 */
Matrix.prototype.determinant = function() {};

/**
 * @return {number}
 */
Matrix.prototype.det = function() {};

/**
 * Returns true if the matrix is singular.
 * @return {boolean}
 */
Matrix.prototype.isSingular = function() {};

/**
 * Returns the trace for square matrices.
 * @return {number}
 */
Matrix.prototype.trace = function() {};

/**
 * @return {number}
 */
Matrix.prototype.tr = function() {};

/**
 * Returns the rank of the matrix.
 * @return {number}
 */
Matrix.prototype.rank = function() {};

/**
 * @return {number}
 */
Matrix.prototype.rk = function() {};

/**
 * Returns the result of attaching the given argument to the right-hand side of the matrix.
 * 
 * @param {?} matrix
 * @return {?}
 */
Matrix.prototype.augment = function(matrix) {};

/**
 * Returns the inverse (if one exists) using Gauss-Jordan.
 * @return {?}
 */
Matrix.prototype.inverse = function() {};

/**
 * @return {?}
 */
Matrix.prototype.inv = function() {};

/**
 * Returns the result of rounding all the elements.
 * @return {?}
 */
Matrix.prototype.round = function() {};

/**
 * Returns a copy of the matrix with elements set to the given value if they differ from it
 * by less than Sylvester.precision.
 * 
 * @param {number} x
 * @return {?}
 */
Matrix.prototype.snapTo = function(x) {};

/**
 * Returns a string representation of the matrix.
 * @return {string}
 */
Matrix.prototype.inspect = function() {};

/**
 * Set the matrix's elements from an array. If the argument passed is a vector, the resulting matrix
 * will be a single column.
 * 
 * @param {(?|!Array<number>|!Array<!Array<number>>)} matrix
 * @return {?}
 */
Matrix.prototype.setElements = function(matrix) {};
/**
 * @record
 * @struct
 */
function Line() {}
 /** @type {?} */
Line.prototype.anchor;
 /** @type {?} */
Line.prototype.direction;

/**
 * Returns true if the argument occupies the same space as the line.
 * 
 * @param {?} line
 * @return {boolean}
 */
Line.prototype.eql = function(line) {};

/**
 * Returns a copy of the line.
 * @return {?}
 */
Line.prototype.dup = function() {};

/**
 * Returns the result of translating the line by the given vector/array.
 * 
 * @param {(?|!Array<number>)} vector
 * @return {?}
 */
Line.prototype.translate = function(vector) {};

/**
 * Returns true if the line is parallel to the argument. Here, 'parallel to' means that the argument's
 * direction is either parallel or antiparallel to the line's own direction. A line is parallel to a
 * plane if the two do not have a unique intersection.
 * 
 * @param {?} obj
 * @return {boolean}
 */
Line.prototype.isParallelTo = function(obj) {};

/**
 * Returns the line's perpendicular distance from the argument, which can be a point, a line or a plane.
 * 
 * @param {?} obj
 * @return {number}
 */
Line.prototype.distanceFrom = function(obj) {};

/**
 * Returns true if the argument is a point on the line.
 * 
 * @param {?} point
 * @return {boolean}
 */
Line.prototype.contains = function(point) {};

/**
 * Returns true if the line lies in the given plane.
 * 
 * @param {?} plane
 * @return {boolean}
 */
Line.prototype.liesIn = function(plane) {};

/**
 * Returns true if the line has a unique point of intersection with the argument.
 * 
 * @param {?} obj
 * @return {boolean}
 */
Line.prototype.intersects = function(obj) {};

/**
 * Returns the unique intersection point with the argument, if one exists.
 * 
 * @param {?} obj
 * @return {?}
 */
Line.prototype.intersectionWith = function(obj) {};

/**
 * Returns the point on the line that is closest to the given point or line.
 * 
 * @param {?} obj
 * @return {?}
 */
Line.prototype.pointClosestTo = function(obj) {};

/**
 * Returns a copy of the line rotated by t radians about the given line. Works by finding the argument's
 * closest point to this line's anchor point (call this C) and rotating the anchor about C. Also rotates
 * the line's direction about the argument's. Be careful with this - the rotation axis' direction
 * affects the outcome!
 * 
 * @param {number} t
 * @param {?} axis
 * @return {?}
 */
Line.prototype.rotate = function(t, axis) {};

/**
 * Returns the line's reflection in the given point or line.
 * 
 * @param {?} obj
 * @return {?}
 */
Line.prototype.reflectionIn = function(obj) {};

/**
 * Set the line's anchor point and direction.
 * 
 * @param {(?|!Array<number>)} anchor
 * @param {(?|!Array<number>)} direction
 * @return {?}
 */
Line.prototype.setVectors = function(anchor, direction) {};
/**
 * @record
 * @struct
 */
function Plane() {}
 /** @type {?} */
Plane.prototype.anchor;
 /** @type {?} */
Plane.prototype.normal;

/**
 * Returns true if the plane occupies the same space as the argument.
 * 
 * @param {?} plane
 * @return {boolean}
 */
Plane.prototype.eql = function(plane) {};

/**
 * Returns a copy of the plane.
 * @return {?}
 */
Plane.prototype.dup = function() {};

/**
 * Returns the result of translating the plane by the given vector.
 * 
 * @param {(?|!Array<number>)} vector
 * @return {?}
 */
Plane.prototype.translate = function(vector) {};

/**
 * Returns true if the plane is parallel to the argument. Will return true if the planes are equal,
 * or if you give a line and it lies in the plane.
 * 
 * @param {?} obj
 * @return {boolean}
 */
Plane.prototype.isParallelTo = function(obj) {};

/**
 * Returns true if the receiver is perpendicular to the argument.
 * 
 * @param {?} plane
 * @return {boolean}
 */
Plane.prototype.isPerpendicularTo = function(plane) {};

/**
 * Returns the plane's distance from the given object (point, line or plane).
 * 
 * \@parm {Vector|Line|Plane} obj The object.
 * @param {?} obj
 * @return {number}
 */
Plane.prototype.distanceFrom = function(obj) {};

/**
 * Returns true if the plane contains the given point or line.
 * 
 * @param {?} obj
 * @return {boolean}
 */
Plane.prototype.contains = function(obj) {};

/**
 * Returns true if the plane has a unique point/line of intersection with the argument.
 * 
 * @param {?} obj
 * @return {boolean}
 */
Plane.prototype.intersects = function(obj) {};

/**
 * Returns the unique intersection with the argument, if one exists.
 * 
 * Returns the unique intersection with the argument, if one exists.
 * 
 * @param {?} line_or_plane
 * @return {?}
 */
Plane.prototype.intersectionWith = function(line_or_plane) {};

/**
 * Returns the point in the plane closest to the given point.
 * 
 * @param {?} point
 * @return {?}
 */
Plane.prototype.pointClosestTo = function(point) {};

/**
 * Returns a copy of the plane, rotated by t radians about the given line. See notes on Line#rotate.
 * 
 * @param {number} t
 * @param {?} axis
 * @return {?}
 */
Plane.prototype.rotate = function(t, axis) {};

/**
 * Returns the reflection of the plane in the given point, line or plane.
 * 
 * @param {?} obj
 * @return {?}
 */
Plane.prototype.reflectionIn = function(obj) {};

/**
 * Sets the anchor point and normal to the plane. Normal vector is normalised before storage.
 * 
 * Sets the anchor point and normal to the plane. The normal is calculated by assuming the three points
 * should lie in the same plane. Normal vector is normalised before storage.
 * 
 * @param {(?|!Array<number>)} anchor
 * @param {(?|!Array<number>)} normal_or_v1
 * @param {(?|!Array<number>)=} v2
 * @return {?}
 */
Plane.prototype.setVectors = function(anchor, normal_or_v1, v2) {};
 /** @type {string} */
Sylvester.version;
 /** @type {number} */
Sylvester.precision;
 /** @type {!Sylvester.VectorStatic} */
var Vector;
 /** @type {!Sylvester.MatrixStatic} */
var Matrix;
 /** @type {!Sylvester.LineStatic} */
var Line;
 /** @type {!Sylvester.PlaneStatic} */
var Plane;

/**
 * Constructor function.
 * 
 * @param {(?|!Array<number>)} elements
 * @return {?}
 */
function $V(elements) {}

/**
 * Constructor function.
 * 
 * @param {(?|!Array<number>|!Array<!Array<number>>)} elements
 * @return {?}
 */
function $M(elements) {}

/**
 * Constructor function.
 * 
 * @param {(?|!Array<number>)} anchor
 * @param {(?|!Array<number>)} direction
 * @return {?}
 */
function $L(anchor, direction) {}

/**
 * Constructor function.
 * 
 * Constructor function.
 * 
 * @param {(?|!Array<number>)} anchor
 * @param {(?|!Array<number>)} normal_or_v1
 * @param {(?|!Array<number>)=} v2
 * @return {?}
 */
function $P(anchor, normal_or_v1, v2) {}
