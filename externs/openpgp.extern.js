/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/openpgp/index.d.ts:
/** @const */
var openpgp = {};
/**
 * @record
 * @struct
 */
openpgp.KeyPair = function() {};
 /** @type {!openpgp.key.Key} */
openpgp.KeyPair.prototype.key;
 /** @type {string} */
openpgp.KeyPair.prototype.privateKeyArmored;
 /** @type {string} */
openpgp.KeyPair.prototype.publicKeyArmored;
/**
 * @record
 * @struct
 */
openpgp.KeyOptions = function() {};
 /** @type {openpgp.enums.publicKey} */
openpgp.KeyOptions.prototype.keyType;
 /** @type {number} */
openpgp.KeyOptions.prototype.numBits;
 /** @type {string} */
openpgp.KeyOptions.prototype.userId;
 /** @type {string} */
openpgp.KeyOptions.prototype.passphrase;
 /** @type {boolean} */
openpgp.KeyOptions.prototype.unlocked;
/**
 * @record
 * @struct
 */
openpgp.Keyid = function() {};
 /** @type {string} */
openpgp.Keyid.prototype.bytes;
/**
 * @record
 * @struct
 */
openpgp.Signature = function() {};
 /** @type {!openpgp.Keyid} */
openpgp.Signature.prototype.keyid;
 /** @type {boolean} */
openpgp.Signature.prototype.valid;
/**
 * @record
 * @struct
 */
openpgp.VerifiedMessage = function() {};
 /** @type {string} */
openpgp.VerifiedMessage.prototype.text;
 /** @type {!Array<!openpgp.Signature>} */
openpgp.VerifiedMessage.prototype.signatures;

/**
 * Decrypts message and verifies signatures
 * Decrypts message and verifies signatures
 * @param {!openpgp.key.Key} privateKey private key with decrypted secret key data
 * @param {!Array<!openpgp.key.Key>|!openpgp.key.Key} publicKeys_or_publicKey array of keys to verify signatures / single key to verify signatures
 * @param {string} msg the message object with signed and encrypted data
 * @return {!Promise<!openpgp.VerifiedMessage>}
 */
openpgp.decryptAndVerifyMessage = function(privateKey, publicKeys_or_publicKey, msg) {};

/**
 * Decrypts message
 * @param {!openpgp.key.Key} privateKey private key with decrypted secret key data
 * @param {!openpgp.message.Message} msg the message object with the encrypted data
 * @return {!Promise<string>}
 */
openpgp.decryptMessage = function(privateKey, msg) {};

/**
 * Encrypts message text with keys
 * Encrypts message text with keys
 * @param {!Array<!openpgp.key.Key>|!openpgp.key.Key} keys_or_key array of keys used to encrypt the message
 * @param {string} message
 * @return {!Promise<string>} encrypted ASCII armored message
 */
openpgp.encryptMessage = function(keys_or_key, message) {};

/**
 * Generates a new OpenPGP key pair. Currently only supports RSA keys. Primary and subkey will be of same type.
 * @param {!openpgp.KeyOptions} options
 * @return {!Promise<!openpgp.KeyPair>}
 */
openpgp.generateKeyPair = function(options) {};

/**
 * Signs message text and encrypts it
 * Signs message text and encrypts it
 * @param {!Array<!openpgp.key.Key>|!openpgp.key.Key} publicKeys_or_publicKey array of keys used to encrypt the message
 * @param {!openpgp.key.Key} privateKey private key with decrypted secret key data for signing
 * @param {string} text private key with decrypted secret key data for signing
 * @return {!Promise<string>}
 */
openpgp.signAndEncryptMessage = function(publicKeys_or_publicKey, privateKey, text) {};

/**
 * Signs a cleartext message
 * Signs a cleartext message
 * @param {!Array<!openpgp.key.Key>|!openpgp.key.Key} privateKeys_or_privateKey array of keys with decrypted secret key data to sign cleartext
 * @param {string} text cleartext
 * @return {!Promise<string>}
 */
openpgp.signClearMessage = function(privateKeys_or_privateKey, text) {};

/**
 * Verifies signatures of cleartext signed message
 * Verifies signatures of cleartext signed message
 * @param {!Array<!openpgp.key.Key>|!openpgp.key.Key} publicKeys_or_publicKey array of keys to verify signatures
 * @param {!openpgp.cleartext.CleartextMessage} msg cleartext message object with signatures
 * @return {!Promise<!openpgp.VerifiedMessage>}
 */
openpgp.verifyClearSignedMessage = function(publicKeys_or_publicKey, msg) {};
/** @const */
openpgp.armor = {};

/**
 * Armor an OpenPGP binary packet block
 * @param {openpgp.enums.armor} messagetype type of the message
 * @param {!Object} body
 * @param {number} partindex
 * @param {number} parttotal
 * @return {string}
 */
openpgp.armor.armor = function(messagetype, body, partindex, parttotal) {};

/**
 * DeArmor an OpenPGP armored message; verify the checksum and return the encoded bytes
 * @param {string} text OpenPGP armored message
 * @return {!Object}
 */
openpgp.armor.dearmor = function(text) {};
/** @const */
openpgp.cleartext = {};
/**
 * @record
 * @struct
 */
openpgp.cleartext.CleartextMessage = function() {};

/**
 * Returns ASCII armored text of cleartext signed message
 * @return {string}
 */
openpgp.cleartext.CleartextMessage.prototype.armor = function() {};

/**
 * Returns the key IDs of the keys that signed the cleartext message
 * @return {!Array<!openpgp.Keyid>}
 */
openpgp.cleartext.CleartextMessage.prototype.getSigningKeyIds = function() {};

/**
 * Get cleartext
 * @return {string}
 */
openpgp.cleartext.CleartextMessage.prototype.getText = function() {};

/**
 * Sign the cleartext message
 * @param {!Array<!openpgp.key.Key>} privateKeys private keys with decrypted secret key data for signing
 * @return {void}
 */
openpgp.cleartext.CleartextMessage.prototype.sign = function(privateKeys) {};

/**
 * Verify signatures of cleartext signed message
 * @param {!Array<!openpgp.key.Key>} keys array of keys to verify signatures
 * @return {!Array<!openpgp.VerifiedMessage>}
 */
openpgp.cleartext.CleartextMessage.prototype.verify = function(keys) {};

/**
 * @param {string} armoredText
 * @return {!openpgp.cleartext.CleartextMessage}
 */
openpgp.cleartext.readArmored = function(armoredText) {};
/** @const */
openpgp.config = {};
 /** @type {openpgp.enums.hash} */
openpgp.config.prefer_hash_algorithm;
 /** @type {openpgp.enums.symmetric} */
openpgp.config.encryption_cipher;
 /** @type {openpgp.enums.compression} */
openpgp.config.compression;
 /** @type {boolean} */
openpgp.config.show_version;
 /** @type {boolean} */
openpgp.config.show_comment;
 /** @type {boolean} */
openpgp.config.integrity_protect;
 /** @type {string} */
openpgp.config.keyserver;
 /** @type {boolean} */
openpgp.config.debug;
/** @const */
openpgp.crypto = {};
/**
 * @record
 * @struct
 */
openpgp.crypto.Mpi = function() {};
 /** @type {number} */
openpgp.crypto.Mpi.prototype.data;

/**
 * @param {string} input
 * @return {number}
 */
openpgp.crypto.Mpi.prototype.read = function(input) {};

/**
 * @return {string}
 */
openpgp.crypto.Mpi.prototype.write = function() {};

/**
 * Generating a session key for the specified symmetric algorithm
 * @param {openpgp.enums.symmetric} algo Algorithm to use
 * @return {string}
 */
openpgp.crypto.generateSessionKey = function(algo) {};

/**
 * generate random byte prefix as string for the specified algorithm
 * @param {openpgp.enums.symmetric} algo Algorithm to use
 * @return {string}
 */
openpgp.crypto.getPrefixRandom = function(algo) {};

/**
 * Returns the number of integers comprising the private key of an algorithm
 * @param {openpgp.enums.symmetric} algo The public key algorithm
 * @return {number}
 */
openpgp.crypto.getPrivateMpiCount = function(algo) {};

/**
 * Decrypts data using the specified public key multiprecision integers of the private key, the specified secretMPIs of the private key and the specified algorithm.
 * @param {openpgp.enums.publicKey} algo Algorithm to be used
 * @param {!Array<!openpgp.crypto.Mpi>} publicMPIs Algorithm dependent multiprecision integers of the public key part of the private key
 * @param {!Array<!openpgp.crypto.Mpi>} secretMPIs Algorithm dependent multiprecision integers of the private key used
 * @param {!openpgp.crypto.Mpi} data Data to be encrypted as MPI
 * @return {!openpgp.crypto.Mpi}
 */
openpgp.crypto.publicKeyDecrypt = function(algo, publicMPIs, secretMPIs, data) {};

/**
 * Encrypts data using the specified public key multiprecision integers and the specified algorithm.
 * @param {openpgp.enums.publicKey} algo Algorithm to be used
 * @param {!Array<!openpgp.crypto.Mpi>} publicMPIs Algorithm dependent multiprecision integers
 * @param {!openpgp.crypto.Mpi} data Data to be encrypted as MPI
 * @return {!Array<!openpgp.crypto.Mpi>}
 */
openpgp.crypto.publicKeyEncrypt = function(algo, publicMPIs, data) {};
/** @const */
openpgp.crypto.cfb = {};

/**
 * This function decrypts a given plaintext using the specified blockcipher to decrypt a message
 * @param {string} cipherfn the algorithm cipher class to decrypt data in one block_size encryption
 * @param {string} key binary string representation of key to be used to decrypt the ciphertext. This will be passed to the cipherfn
 * @param {string} ciphertext to be decrypted provided as a string
 * @param {boolean} resync a boolean value specifying if a resync of the IV should be used or not. The encrypteddatapacket uses the "old" style with a resync. Decryption within an encryptedintegrityprotecteddata packet is not resyncing the IV.
 * @return {string}
 */
openpgp.crypto.cfb.decrypt = function(cipherfn, key, ciphertext, resync) {};

/**
 * This function encrypts a given with the specified prefixrandom using the specified blockcipher to encrypt a message
 * @param {string} prefixrandom random bytes of block_size length provided as a string to be used in prefixing the data
 * @param {string} cipherfn the algorithm cipher class to encrypt data in one block_size encryption
 * @param {string} plaintext data to be encrypted provided as a string
 * @param {string} key binary string representation of key to be used to encrypt the plaintext. This will be passed to the cipherfn
 * @param {boolean} resync a boolean value specifying if a resync of the IV should be used or not. The encrypteddatapacket uses the "old" style with a resync. Encryption within an encryptedintegrityprotecteddata packet is not resyncing the IV.
 * @return {string}
 */
openpgp.crypto.cfb.encrypt = function(prefixrandom, cipherfn, plaintext, key, resync) {};

/**
 * Decrypts the prefixed data for the Modification Detection Code (MDC) computation
 * @param {!Object} cipherfn cipherfn.encrypt Cipher function to use
 * @param {string} key binary string representation of key to be used to check the mdc This will be passed to the cipherfn
 * @param {string} ciphertext The encrypted data
 * @return {string}
 */
openpgp.crypto.cfb.mdc = function(cipherfn, key, ciphertext) {};
/** @const */
openpgp.crypto.hash = {};

/**
 * Create a hash on the specified data using the specified algorithm
 * @param {openpgp.enums.hash} algo Hash algorithm type
 * @param {string} data Data to be hashed
 * @return {string}
 */
openpgp.crypto.hash.digest = function(algo, data) {};

/**
 * Returns the hash size in bytes of the specified hash algorithm type
 * @param {openpgp.enums.hash} algo Hash algorithm type
 * @return {number}
 */
openpgp.crypto.hash.getHashByteLength = function(algo) {};
/** @const */
openpgp.crypto.random = {};

/**
 * Create a secure random big integer of bits length
 * @param {number} bits Bit length of the MPI to create
 * @return {number}
 */
openpgp.crypto.random.getRandomBigInteger = function(bits) {};

/**
 * Retrieve secure random byte string of the specified length
 * @param {number} length Length in bytes to generate
 * @return {string}
 */
openpgp.crypto.random.getRandomBytes = function(length) {};

/**
 * Helper routine which calls platform specific crypto random generator
 * @param {!Uint8Array} buf
 * @return {void}
 */
openpgp.crypto.random.getRandomValues = function(buf) {};

/**
 * Return a secure random number in the specified range
 * @param {number} from Min of the random number
 * @param {number} to Max of the random number (max 32bit)
 * @return {number}
 */
openpgp.crypto.random.getSecureRandom = function(from, to) {};
/** @const */
openpgp.crypto.signature = {};

/**
 * Create a signature on data using the specified algorithm
 * @param {openpgp.enums.hash} hash_algo hash Algorithm to use
 * @param {openpgp.enums.publicKey} algo Asymmetric cipher algorithm to use
 * @param {!Array<!openpgp.crypto.Mpi>} publicMPIs Public key multiprecision integers of the private key
 * @param {!Array<!openpgp.crypto.Mpi>} secretMPIs Private key multiprecision integers which is used to sign the data
 * @param {string} data Data to be signed
 * @return {!openpgp.crypto.Mpi}
 */
openpgp.crypto.signature.sign = function(hash_algo, algo, publicMPIs, secretMPIs, data) {};

/**
 * @param {openpgp.enums.publicKey} algo public Key algorithm
 * @param {openpgp.enums.hash} hash_algo Hash algorithm
 * @param {!Array<!openpgp.crypto.Mpi>} msg_MPIs Signature multiprecision integers
 * @param {!Array<!openpgp.crypto.Mpi>} publickey_MPIs Public key multiprecision integers
 * @param {string} data Data on where the signature was computed on
 * @return {boolean}
 */
openpgp.crypto.signature.verify = function(algo, hash_algo, msg_MPIs, publickey_MPIs, data) {};
/** @const */
openpgp.enums = {};

/** @const */
openpgp.enums.armor = {};
/** @const {number} */
openpgp.enums.armor.multipart_section;
/** @const {number} */
openpgp.enums.armor.multipart_last;
/** @const {number} */
openpgp.enums.armor.signed;
/** @const {number} */
openpgp.enums.armor.message;
/** @const {number} */
openpgp.enums.armor.public_key;
/** @const {number} */
openpgp.enums.armor.private_key;

/** @const */
openpgp.enums.compression = {};
/** @const {number} */
openpgp.enums.compression.uncompressed;
/** @const {number} */
openpgp.enums.compression.zip;
/** @const {number} */
openpgp.enums.compression.zlib;
/** @const {number} */
openpgp.enums.compression.bzip2;

/** @const */
openpgp.enums.hash = {};
/** @const {number} */
openpgp.enums.hash.md5;
/** @const {number} */
openpgp.enums.hash.sha1;
/** @const {number} */
openpgp.enums.hash.ripemd;
/** @const {number} */
openpgp.enums.hash.sha256;
/** @const {number} */
openpgp.enums.hash.sha384;
/** @const {number} */
openpgp.enums.hash.sha512;
/** @const {number} */
openpgp.enums.hash.sha224;

/** @const */
openpgp.enums.packet = {};
/** @const {number} */
openpgp.enums.packet.publicKeyEncryptedSessionKey;
/** @const {number} */
openpgp.enums.packet.signature;
/** @const {number} */
openpgp.enums.packet.symEncryptedSessionKey;
/** @const {number} */
openpgp.enums.packet.onePassSignature;
/** @const {number} */
openpgp.enums.packet.secretKey;
/** @const {number} */
openpgp.enums.packet.publicKey;
/** @const {number} */
openpgp.enums.packet.secretSubkey;
/** @const {number} */
openpgp.enums.packet.compressed;
/** @const {number} */
openpgp.enums.packet.symmetricallyEncrypted;
/** @const {number} */
openpgp.enums.packet.marker;
/** @const {number} */
openpgp.enums.packet.literal;
/** @const {number} */
openpgp.enums.packet.trust;
/** @const {number} */
openpgp.enums.packet.userid;
/** @const {number} */
openpgp.enums.packet.publicSubkey;
/** @const {number} */
openpgp.enums.packet.userAttribute;
/** @const {number} */
openpgp.enums.packet.symEncryptedIntegrityProtected;
/** @const {number} */
openpgp.enums.packet.modificationDetectionCode;

/** @const */
openpgp.enums.publicKey = {};
/** @const {number} */
openpgp.enums.publicKey.rsa_encrypt_sign;
/** @const {number} */
openpgp.enums.publicKey.rsa_encrypt;
/** @const {number} */
openpgp.enums.publicKey.rsa_sign;
/** @const {number} */
openpgp.enums.publicKey.elgamal;
/** @const {number} */
openpgp.enums.publicKey.dsa;

/** @const */
openpgp.enums.symmetric = {};
/** @const {number} */
openpgp.enums.symmetric.plaintext;
/** @const {number} */
openpgp.enums.symmetric.idea;
/** @const {number} */
openpgp.enums.symmetric.tripledes;
/** @const {number} */
openpgp.enums.symmetric.cast5;
/** @const {number} */
openpgp.enums.symmetric.blowfish;
/** @const {number} */
openpgp.enums.symmetric.aes128;
/** @const {number} */
openpgp.enums.symmetric.aes192;
/** @const {number} */
openpgp.enums.symmetric.aes256;
/** @const {number} */
openpgp.enums.symmetric.twofish;

/** @const */
openpgp.enums.keyStatus = {};
/** @const {number} */
openpgp.enums.keyStatus.invalid;
/** @const {number} */
openpgp.enums.keyStatus.expired;
/** @const {number} */
openpgp.enums.keyStatus.revoked;
/** @const {number} */
openpgp.enums.keyStatus.valid;
/** @const {number} */
openpgp.enums.keyStatus.no_self_cert;
/** @const */
openpgp.key = {};
/**
 * @record
 * @struct
 */
openpgp.key.KeyResult = function() {};
 /** @type {!Array<!openpgp.key.Key>} */
openpgp.key.KeyResult.prototype.keys;
 /** @type {!Array<!Error>} */
openpgp.key.KeyResult.prototype.err;
/**
 * @record
 * @struct
 */
openpgp.key.Key = function() {};
 /** @type {!openpgp.packet.PublicKey} */
openpgp.key.Key.prototype.primaryKey;

/**
 * @return {string}
 */
openpgp.key.Key.prototype.armor = function() {};

/**
 * @param {string} passphrase
 * @return {boolean}
 */
openpgp.key.Key.prototype.decrypt = function(passphrase) {};

/**
 * @return {!Date}
 */
openpgp.key.Key.prototype.getExpirationTime = function() {};

/**
 * @return {!Array<!openpgp.Keyid>}
 */
openpgp.key.Key.prototype.getKeyIds = function() {};

/**
 * @return {string}
 */
openpgp.key.Key.prototype.getPreferredHashAlgorithm = function() {};

/**
 * @return {?}
 */
openpgp.key.Key.prototype.getPrimaryUser = function() {};

/**
 * @return {!Array<string>}
 */
openpgp.key.Key.prototype.getUserIds = function() {};

/**
 * @return {boolean}
 */
openpgp.key.Key.prototype.isPrivate = function() {};

/**
 * @return {boolean}
 */
openpgp.key.Key.prototype.isPublic = function() {};

/**
 * @return {!openpgp.key.Key}
 */
openpgp.key.Key.prototype.toPublic = function() {};

/**
 * @param {!openpgp.key.Key} key
 * @return {void}
 */
openpgp.key.Key.prototype.update = function(key) {};

/**
 * @return {openpgp.enums.keyStatus}
 */
openpgp.key.Key.prototype.verifyPrimaryKey = function() {};

/**
 * Generates a new OpenPGP key. Currently only supports RSA keys. Primary and subkey will be of same type.
 * @param {!openpgp.KeyOptions} options
 * @return {!openpgp.key.Key}
 */
openpgp.key.generate = function(options) {};

/**
 * Reads an OpenPGP armored text and returns one or multiple key objects
 * @param {string} armoredText text to be parsed
 * @return {!openpgp.key.KeyResult}
 */
openpgp.key.readArmored = function(armoredText) {};
/** @const */
openpgp.message = {};
/**
 * @record
 * @struct
 */
openpgp.message.Message = function() {};

/**
 * Returns ASCII armored text of message
 * @return {string}
 */
openpgp.message.Message.prototype.armor = function() {};

/**
 * Decrypt the message
 * @param {!openpgp.key.Key} privateKey private key with decrypted secret data
 * @return {!Array<!openpgp.message.Message>}
 */
openpgp.message.Message.prototype.decrypt = function(privateKey) {};

/**
 * Encrypt the message
 * @param {!Array<!openpgp.key.Key>} keys array of keys, used to encrypt the message
 * @return {!Array<!openpgp.message.Message>}
 */
openpgp.message.Message.prototype.encrypt = function(keys) {};

/**
 * Returns the key IDs of the keys to which the session key is encrypted
 * @return {!Array<!openpgp.Keyid>}
 */
openpgp.message.Message.prototype.getEncryptionKeyIds = function() {};

/**
 * Get literal data that is the body of the message
 * @return {string}
 */
openpgp.message.Message.prototype.getLiteralData = function() {};

/**
 * Returns the key IDs of the keys that signed the message
 * @return {!Array<!openpgp.Keyid>}
 */
openpgp.message.Message.prototype.getSigningKeyIds = function() {};

/**
 * Get literal data as text
 * @return {string}
 */
openpgp.message.Message.prototype.getText = function() {};

/**
 * Sign the message (the literal data packet of the message)
 * @param {!Array<!openpgp.key.Key>} privateKey private keys with decrypted secret key data for signing
 * @return {!openpgp.message.Message}
 */
openpgp.message.Message.prototype.sign = function(privateKey) {};

/**
 * Unwrap compressed message
 * @return {!openpgp.message.Message}
 */
openpgp.message.Message.prototype.unwrapCompressed = function() {};

/**
 * Verify message signatures
 * @param {!Array<!openpgp.key.Key>} keys array of keys to verify signatures
 * @return {!Array<!Object>}
 */
openpgp.message.Message.prototype.verify = function(keys) {};

/**
 * creates new message object from binary data
 * @param {string} bytes
 * @return {!openpgp.message.Message}
 */
openpgp.message.fromBinary = function(bytes) {};

/**
 * creates new message object from text
 * @param {string} text
 * @return {!openpgp.message.Message}
 */
openpgp.message.fromText = function(text) {};

/**
 * reads an OpenPGP armored message and returns a message object
 * @param {string} armoredText text to be parsed
 * @return {!openpgp.message.Message}
 */
openpgp.message.readArmored = function(armoredText) {};
/** @const */
openpgp.packet = {};
/**
 * @record
 * @struct
 */
openpgp.packet.PublicKey = function() {};
 /** @type {openpgp.enums.publicKey} */
openpgp.packet.PublicKey.prototype.algorithm;
 /** @type {!Date} */
openpgp.packet.PublicKey.prototype.created;
 /** @type {string} */
openpgp.packet.PublicKey.prototype.fingerprint;

/**
 * @return {number}
 */
openpgp.packet.PublicKey.prototype.getBitSize = function() {};

/**
 * @return {string}
 */
openpgp.packet.PublicKey.prototype.getFingerprint = function() {};

/**
 * @return {string}
 */
openpgp.packet.PublicKey.prototype.getKeyId = function() {};

/**
 * @param {string} input
 * @return {?}
 */
openpgp.packet.PublicKey.prototype.read = function(input) {};

/**
 * @return {?}
 */
openpgp.packet.PublicKey.prototype.write = function() {};
/**
 * @extends {openpgp.packet.PublicKey}
 * @record
 * @struct
 */
openpgp.packet.SecretKey = function() {};

/**
 * @param {string} bytes
 * @return {void}
 */
openpgp.packet.SecretKey.prototype.read = function(bytes) {};

/**
 * @return {string}
 */
openpgp.packet.SecretKey.prototype.write = function() {};

/**
 * @param {string} str_passphrase
 * @return {boolean}
 */
openpgp.packet.SecretKey.prototype.clearPrivateMPIs = function(str_passphrase) {};

/**
 * @param {string} passphrase
 * @return {void}
 */
openpgp.packet.SecretKey.prototype.encrypt = function(passphrase) {};

/**
 * Allocate a new packet from structured packet clone
 * @param {!Object} packetClone packet clone
 * @return {!Object}
 */
openpgp.packet.fromStructuredClone = function(packetClone) {};

/**
 * Allocate a new packet
 * @param {string} tag
 * @return {!Object}
 */
openpgp.packet.newPacketFromTag = function(tag) {};
/** @const */
openpgp.util = {};

/**
 * Convert an array of integers(0.255) to a string
 * @param {!Array<number>} bin An array of (binary) integers to convert
 * @return {string}
 */
openpgp.util.bin2str = function(bin) {};

/**
 * Calculates a 16bit sum of a string by adding each character codes modulus 65535
 * @param {string} text string to create a sum of
 * @return {number}
 */
openpgp.util.calc_checksum = function(text) {};

/**
 * Convert a string of utf8 bytes to a native javascript string
 * @param {string} utf8 A valid squence of utf8 bytes
 * @return {string}
 */
openpgp.util.decode_utf8 = function(utf8) {};

/**
 * Convert a native javascript string to a string of utf8 bytes
 * param str The string to convert
 * @param {string} str
 * @return {string}
 */
openpgp.util.encode_utf8 = function(str) {};

/**
 * Return the algorithm type as string
 * @return {string}
 */
openpgp.util.get_hashAlgorithmString = function() {};

/**
 * Get native Web Cryptography api. The default configuration is to use the api when available. But it can also be deactivated with config.useWebCrypto
 * @return {!Object}
 */
openpgp.util.getWebCrypto = function() {};

/**
 * Create binary string from a hex encoded string
 * @param {string} str Hex string to convert
 * @return {string}
 */
openpgp.util.hex2bin = function(str) {};

/**
 * Creating a hex string from an binary array of integers (0..255)
 * @param {string} str Array of bytes to convert
 * @return {string}
 */
openpgp.util.hexidump = function(str) {};

/**
 * Create hexstring from a binary
 * @param {string} str string to convert
 * @return {string}
 */
openpgp.util.hexstrdump = function(str) {};

/**
 * Helper function to print a debug message. Debug messages are only printed if
 * @param {string} str string of the debug message
 * @return {void}
 */
openpgp.util.print_debug = function(str) {};

/**
 * Helper function to print a debug message. Debug messages are only printed if
 * @param {string} str string of the debug message
 * @return {void}
 */
openpgp.util.print_debug_hexstr_dump = function(str) {};

/**
 * Shifting a string to n bits right
 * @param {string} value The string to shift
 * @param {number} bitcount Amount of bits to shift (MUST be smaller than 9)
 * @return {string}
 */
openpgp.util.shiftRight = function(value, bitcount) {};

/**
 * Convert a string to an array of integers(0.255)
 * @param {string} str string to convert
 * @return {!Array<number>}
 */
openpgp.util.str2bin = function(str) {};

/**
 * Convert a string to a Uint8Array
 * @param {string} str string to convert
 * @return {!Uint8Array}
 */
openpgp.util.str2Uint8Array = function(str) {};

/**
 * Convert a Uint8Array to a string. This currently functions the same as bin2str.
 * @param {!Uint8Array} bin An array of (binary) integers to convert
 * @return {string}
 */
openpgp.util.Uint8Array2str = function(bin) {};
