/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/couchbase/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */

/** @const */
var errors = {};
/** @const {number} */
errors.success;
/** @const {number} */
errors.authContinue;
/** @const {number} */
errors.authError;
/** @const {number} */
errors.deltaBadVal;
/** @const {number} */
errors.objectTooBig;
/** @const {number} */
errors.serverBusy;
/** @const {number} */
errors.cLibInternal;
/** @const {number} */
errors.cLinInvalidArgument;
/** @const {number} */
errors.cLibOutOfMemory;
/** @const {number} */
errors.invalidRange;
/** @const {number} */
errors.cLibGenericError;
/** @const {number} */
errors.temporaryError;
/** @const {number} */
errors.keyAlreadyExists;
/** @const {number} */
errors.keyNotFound;
/** @const {number} */
errors.failedToOpenLibrary;
/** @const {number} */
errors.failedToFindSymbol;
/** @const {number} */
errors.networkError;
/** @const {number} */
errors.wrongServer;
/** @const {number} */
errors.notMyVBucket;
/** @const {number} */
errors.notSorted;
/** @const {number} */
errors.notSupported;
/** @const {number} */
errors.unknownCommand;
/** @const {number} */
errors.unknownHost;
/** @const {number} */
errors.protocolError;
/** @const {number} */
errors.timedOut;
/** @const {number} */
errors.connectError;
/** @const {number} */
errors.bukcketNotFound;
/** @const {number} */
errors.clientOutOfMemory;
/** @const {number} */
errors.clientTemporaryError;
/** @const {number} */
errors.badHandle;
/** @const {number} */
errors.serverBug;
/** @const {number} */
errors.invalidHostFormat;
/** @const {number} */
errors.notEnoughNodes;
/** @const {number} */
errors.duplicateItems;
/** @const {number} */
errors.noMatchingServerForKey;
/** @const {number} */
errors.badEnvironmentVariable;
/** @const {number} */
errors.outOfMemory;
/** @const {number} */
errors.invalidArguments;
/** @const {number} */
errors.schedulingError;
/** @const {number} */
errors.checkResults;
/** @const {number} */
errors.genericError;
/** @const {number} */
errors.durabilityFailed;
/** @const {number} */
errors.restError;

/**
 * @constructor
 * @struct
 * Create a new instance of the Cluster class.
 * @param {string=} cnstr The connection string for your cluster.
 * @param {?=} options The options object.
 */
function Cluster(cnstr, options) {}

/**
 * Creates a manager allowing the management of a Couchbase cluster.
 * Creates a manager allowing the management of a Couchbase cluster using credentials.
 * @param {string=} username The username for your cluster.
 * @param {string=} password The password for your cluster.
 * @return {?}
 */
Cluster.prototype.manager = function(username, password) {};

/**
 * Open a bucket to perform operations. This will begin the handshake process immediately and operations will complete later. Subscribe to the connect event to be alerted when the connection is ready, though be aware operations can be successfully queued before this.
 * Open a bucket to perform operations. This will begin the handshake process immediately and operations will complete later. Subscribe to the connect event to be alerted when the connection is ready, though be aware operations can be successfully queued before this.
 * Open a bucket to perform operations. This will begin the handshake process immediately and operations will complete later. Subscribe to the connect event to be alerted when the connection is ready, though be aware operations can be successfully queued before this.
 * Open a bucket to perform operations. This will begin the handshake process immediately and operations will complete later. Subscribe to the connect event to be alerted when the connection is ready, though be aware operations can be successfully queued before this.
 * @param {string=} name The name of the bucket to open.
 * @param {string|!Function=} password_or_callback Password for the bucket. / Callback to invoke on connection success or failure.
 * @param {!Function=} callback Callback to invoke on connection success or failure.
 * @return {?}
 */
Cluster.prototype.openBucket = function(name, password_or_callback, callback) {};
/**
 * @record
 * @struct
 */
function ClusterConstructorOptions() {}
 /** @type {string} */
ClusterConstructorOptions.prototype.certpath;
/**
 * @record
 * @struct
 */
function CreateBucketOptions() {}
 /** @type {string} */
CreateBucketOptions.prototype.name;
 /** @type {string} */
CreateBucketOptions.prototype.authType;
 /** @type {string} */
CreateBucketOptions.prototype.bucketType;
 /** @type {number} */
CreateBucketOptions.prototype.ramQuotaMB;
 /** @type {number} */
CreateBucketOptions.prototype.replicaNumber;
/**
 * @record
 * @struct
 */
function ClusterManager() {}

/**
 *
 *
 * @param {string} name
 * @param {!Function|?} callback_or_opts
 * @param {!Function=} callback
 * @return {void}
 */
ClusterManager.prototype.createBucket = function(name, callback_or_opts, callback) {};

/**
 *
 * @param {!Function} callback
 * @return {void}
 */
ClusterManager.prototype.listBuckets = function(callback) {};

/**
 *
 * @param {string} name
 * @param {!Function} callback
 * @return {void}
 */
ClusterManager.prototype.removeBucket = function(name, callback) {};
/**
 * @record
 * @struct
 */
function CouchbaseError() {}
 /** @type {errors} */
CouchbaseError.prototype.code;
/**
 * @record
 * @struct
 */
function AppendOptions() {}
 /** @type {!Bucket.CAS} */
AppendOptions.prototype.cas;
 /** @type {number} */
AppendOptions.prototype.persist_to;
 /** @type {number} */
AppendOptions.prototype.replicate_to;
/**
 * @extends {AppendOptions}
 * @record
 * @struct
 */
function PrependOptions() {}
/**
 * @extends {AppendOptions}
 * @record
 * @struct
 */
function RemoveOptions() {}
/**
 * @extends {AppendOptions}
 * @record
 * @struct
 */
function ReplaceOptions() {}
 /** @type {number} */
ReplaceOptions.prototype.expiry;
/**
 * @extends {ReplaceOptions}
 * @record
 * @struct
 */
function UpsertOptions() {}
/**
 * @record
 * @struct
 */
function TouchOptions() {}
 /** @type {number} */
TouchOptions.prototype.persist_to;
 /** @type {number} */
TouchOptions.prototype.replicate_to;
/**
 * @record
 * @struct
 */
function CounterOptions() {}
 /** @type {number} */
CounterOptions.prototype.initial;
 /** @type {number} */
CounterOptions.prototype.expiry;
 /** @type {number} */
CounterOptions.prototype.persist_to;
 /** @type {number} */
CounterOptions.prototype.replicate_to;
/**
 * @record
 * @struct
 */
function GetAndLockOptions() {}
 /** @type {number} */
GetAndLockOptions.prototype.lockTime;
/**
 * @record
 * @struct
 */
function GetReplicaOptions() {}
 /** @type {number} */
GetReplicaOptions.prototype.index;
/**
 * @record
 * @struct
 */
function InsertOptions() {}
 /** @type {number} */
InsertOptions.prototype.expiry;
 /** @type {number} */
InsertOptions.prototype.persist_to;
 /** @type {number} */
InsertOptions.prototype.replicate_to;
/**
 * @record
 * @struct
 */
function BucketManager() {}

/**
 * Flushes the cluster, deleting all data stored within this bucket. Note that this method requires the Flush permission to be enabled on the bucket from the management console before it will work.
 * @param {!Function} callback The callback function.
 * @return {void}
 */
BucketManager.prototype.flush = function(callback) {};

/**
 * Retrieves a specific design document from this bucket.
 * @param {string} name
 * @param {!Function} callback The callback function.
 * @return {void}
 */
BucketManager.prototype.getDesignDocument = function(name, callback) {};

/**
 * Retrieves a list of all design documents registered to a bucket.
 * @param {!Function} callback The callback function.
 * @return {void}
 */
BucketManager.prototype.getDesignDocuments = function(callback) {};

/**
 * Registers a design document to this bucket, failing if it already exists.
 * @param {string} name
 * @param {?} data
 * @param {!Function} callback The callback function.
 * @return {void}
 */
BucketManager.prototype.insertDesignDocument = function(name, data, callback) {};

/**
 * Unregisters a design document from this bucket.
 * @param {string} name
 * @param {!Function} callback The callback function.
 * @return {void}
 */
BucketManager.prototype.removeDesignDocument = function(name, callback) {};

/**
 * Registers a design document to this bucket, overwriting any existing design document that was previously registered.
 * @param {string} name
 * @param {?} data
 * @param {!Function} callback The callback function.
 * @return {void}
 */
BucketManager.prototype.upsertDesignDocument = function(name, data, callback) {};
/**
 * @constructor
 * @struct
 */
function ViewQuery() {}

/**
 * Instantiates a ViewQuery object for the specified design document and view name.
 * @param {string} ddoc The design document to use.
 * @param {string} name The view to use.
 * @return {!ViewQuery}
 */
ViewQuery.from = function(ddoc, name) {};

/**
 * Specifies the design document and view name to use for this query.
 * @param {string} ddoc The design document to use.
 * @param {string} name The view to use.
 * @return {!ViewQuery}
 */
ViewQuery.prototype.from = function(ddoc, name) {};

/**
 * Allows you to specify custom view options that may not be available though the fluent interface defined by this class.
 * @param {?} opts
 * @return {!ViewQuery}
 */
ViewQuery.prototype.custom = function(opts) {};

/**
 * Flag to request a view request accross all nodes in the case of a development view.
 * @param {boolean} full_set
 * @return {!ViewQuery}
 */
ViewQuery.prototype.full_set = function(full_set) {};

/**
 * Specifies whether to preform grouping during view execution.
 * @param {boolean} group
 * @return {!ViewQuery}
 */
ViewQuery.prototype.group = function(group) {};

/**
 * Specifies the level at which to perform view grouping.
 * @param {number} group_level
 * @return {!ViewQuery}
 */
ViewQuery.prototype.group_level = function(group_level) {};

/**
 * Specifies a range of document id's to retrieve from the index.
 * @param {?} start
 * @param {?} end
 * @return {!ViewQuery}
 */
ViewQuery.prototype.id_range = function(start, end) {};

/**
 * Flag to request a view request include the full document value.
 * @param {boolean} include_docs
 * @return {!ViewQuery}
 */
ViewQuery.prototype.include_docs = function(include_docs) {};

/**
 * Specifies a specified key to retrieve from the index.
 * @param {?} key
 * @return {!ViewQuery}
 */
ViewQuery.prototype.key = function(key) {};

/**
 * Specifies a list of keys you wish to retrieve from the index.
 * @param {!Array<?>} key
 * @return {!ViewQuery}
 */
ViewQuery.prototype.keys = function(key) {};

/**
 * Specifies the maximum number of results to return.
 * @param {number} limit
 * @return {!ViewQuery}
 */
ViewQuery.prototype.limit = function(limit) {};

/**
 * Sets the error handling mode for this query.
 * @param {ViewQuery.ErrorMode} mode
 * @return {!ViewQuery}
 */
ViewQuery.prototype.on_error = function(mode) {};

/**
 * Specifies the desired ordering for the results.
 * @param {ViewQuery.Order} order
 * @return {!ViewQuery}
 */
ViewQuery.prototype.order = function(order) {};

/**
 * Specifies a range of keys to retrieve from the index. You may specify both a start and an end point and additionally specify whether or not the end value is inclusive or exclusive.
 * @param {?} start
 * @param {?} end
 * @param {boolean=} inclusive_end
 * @return {!ViewQuery}
 */
ViewQuery.prototype.range = function(start, end, inclusive_end) {};

/**
 * Specifies whether to execute the map-reduce reduce step.
 * @param {boolean} reduce
 * @return {!ViewQuery}
 */
ViewQuery.prototype.reduce = function(reduce) {};

/**
 * Specifies how many results to skip from the beginning of the result set.
 * @param {number} skip
 * @return {!ViewQuery}
 */
ViewQuery.prototype.skip = function(skip) {};

/**
 * Specifies how this query will affect view indexing, both before and after the query is executed.
 * @param {ViewQuery.Update} stale
 * @return {!ViewQuery}
 */
ViewQuery.prototype.stale = function(stale) {};

/** @const */
ViewQuery.ErrorMode = {};
/** @const {number} */
ViewQuery.ErrorMode.CONTINUE;
/** @const {number} */
ViewQuery.ErrorMode.STOP;

/** @const */
ViewQuery.Order = {};
/** @const {number} */
ViewQuery.Order.ASCENDING;
/** @const {number} */
ViewQuery.Order.DESCENDING;

/** @const */
ViewQuery.Update = {};
/** @const {number} */
ViewQuery.Update.BEFORE;
/** @const {number} */
ViewQuery.Update.NONE;
/** @const {number} */
ViewQuery.Update.AFTER;
/**
 * @constructor
 * @struct
 */
function N1qlQuery() {}

/**
 * Creates a query object directly from the passed query string.
 * @param {string} str
 * @return {!N1qlStringQuery}
 */
N1qlQuery.fromString = function(str) {};

/**
 * Returns the fully prepared string representation of this query.
 * @return {string}
 */
N1qlQuery.prototype.toString = function() {};

/** @const */
N1qlQuery.Consistency = {};
/** @const {number} */
N1qlQuery.Consistency.NOT_BOUND;
/** @const {number} */
N1qlQuery.Consistency.REQUEST_PLUS;
/** @const {number} */
N1qlQuery.Consistency.STATEMENT_PLUS;
/**
 * @extends {N1qlQuery}
 * @constructor
 * @struct
 */
function N1qlStringQuery() {}

/**
 * Specifies whether this query is adhoc or should be prepared.
 * @param {boolean} adhoc
 * @return {!N1qlStringQuery}
 */
N1qlStringQuery.prototype.adhoc = function(adhoc) {};

/**
 * Specify the consistency level for this query.
 * @param {N1qlQuery.Consistency} val
 * @return {!N1qlStringQuery}
 */
N1qlStringQuery.prototype.consistency = function(val) {};

/**
 * Returns the fully prepared object representation of this query.
 * @return {?}
 */
N1qlStringQuery.prototype.toObject = function() {};

/**
 * Returns the fully prepared string representation of this query.
 * @return {string}
 */
N1qlStringQuery.prototype.toString = function() {};
/**
 * @constructor
 * @struct
 */
function SpatialQuery() {}

/**
 * Instantiates a SpatialQuery object for the specified design document and view name.
 * @param {string} ddoc The design document to use.
 * @param {string} name 	The view to use.
 * @return {!SpatialQuery}
 */
SpatialQuery.from = function(ddoc, name) {};

/**
 * Specifies the design document and view name to use for this query.
 * @param {string} ddoc
 * @param {string} name
 * @return {!SpatialQuery}
 */
SpatialQuery.prototype.from = function(ddoc, name) {};

/**
 * Specifies a bounding box to query the index for. This value must be an array of exactly 4 numbers which represents the left, top, right and bottom edges of the bounding box (in that order).
 * @param {!Array<number>} bbox
 * @return {!SpatialQuery}
 */
SpatialQuery.prototype.bbox = function(bbox) {};

/**
 * Allows you to specify custom view options that may not be available though the fluent interface defined by this class.
 * @param {?} opts
 * @return {!SpatialQuery}
 */
SpatialQuery.prototype.custom = function(opts) {};

/**
 * Specifies the maximum number of results to return.
 * @param {number} limit
 * @return {!SpatialQuery}
 */
SpatialQuery.prototype.limit = function(limit) {};

/**
 * Specifies how many results to skip from the beginning of the result set.
 * @param {number} skip
 * @return {!SpatialQuery}
 */
SpatialQuery.prototype.skip = function(skip) {};

/**
 * Specifies how this query will affect view indexing, both before and after the query is executed.
 * @param {SpatialQuery.Update} stale
 * @return {!SpatialQuery}
 */
SpatialQuery.prototype.stale = function(stale) {};

/** @const */
SpatialQuery.Update = {};
/** @const {number} */
SpatialQuery.Update.BEFORE;
/** @const {number} */
SpatialQuery.Update.NONE;
/** @const {number} */
SpatialQuery.Update.AFTER;
/**
 * @record
 * @struct
 */
function Bucket() {}
 /** @type {string} */
Bucket.prototype.clientVersion;
 /** @type {number} */
Bucket.prototype.configThrottle;
 /** @type {number} */
Bucket.prototype.connectionTimeout;
 /** @type {number} */
Bucket.prototype.durabilityInterval;
 /** @type {number} */
Bucket.prototype.durabilityTimeout;
 /** @type {string} */
Bucket.prototype.lcbVersion;
 /** @type {number} */
Bucket.prototype.managementTimeout;
 /** @type {number} */
Bucket.prototype.nodeConnectionTimeout;
 /** @type {number} */
Bucket.prototype.operationTimeout;
 /** @type {number} */
Bucket.prototype.viewTimeout;

/**
 * Similar to Bucket#upsert, but instead of setting a new key, it appends data to the existing key. Note that this function only makes sense when the stored data is a string; 'appending' to a JSON document may result in parse errors when the document is later retrieved.
 *
 * @param {?} key The target document key.
 * @param {?} fragment The document's contents to append.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.append = function(key, fragment, callback_or_options, callback) {};

/**
 * Increments or decrements a key's numeric value.
 * Note that JavaScript does not support 64-bit integers (while libcouchbase and the server do). You might receive an inaccurate value if the number is greater than 53-bits (JavaScript's maximum integer precision).
 *
 * @param {?} key The target document key.
 * @param {number} delta The amount to add or subtract from the counter value. This value may be any non-zero integer.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.counter = function(key, delta, callback_or_options, callback) {};

/**
 * Shuts down this connection.
 * @return {void}
 */
Bucket.prototype.disconnect = function() {};

/**
 * Enables N1QL support on the client. A cbq-server URI must be passed. This method will be deprecated in the future in favor of automatic configuration through the connected cluster.
 * @param {(string|!Array<string>)} hosts An array of host/port combinations which are N1QL servers attached to this cluster.
 * @return {void}
 */
Bucket.prototype.enableN1ql = function(hosts) {};

/**
 * Retrieves a document.
 * @param {?} key The target document key.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.get = function(key, callback_or_options, callback) {};

/**
 * Lock the document on the server and retrieve it. When an document is locked, its CAS changes and subsequent operations on the document (without providing the current CAS) will fail until the lock is no longer held.
 * This function behaves identically to Bucket#get in that it will return the value. It differs in that the document is also locked. This ensures that attempts by other client instances to access this document while the lock is held will fail.
 * Once locked, a document can be unlocked either by explicitly calling Bucket#unlock or by performing a storage operation (e.g. Bucket#upsert, Bucket#replace, Bucket::append) with the current CAS value. Note that any other lock operations on this key will fail while a document is locked.
 * Lock the document on the server and retrieve it. When an document is locked, its CAS changes and subsequent operations on the document (without providing the current CAS) will fail until the lock is no longer held.
 * This function behaves identically to Bucket#get in that it will return the value. It differs in that the document is also locked. This ensures that attempts by other client instances to access this document while the lock is held will fail.
 * Once locked, a document can be unlocked either by explicitly calling Bucket#unlock or by performing a storage operation (e.g. Bucket#upsert, Bucket#replace, Bucket::append) with the current CAS value. Note that any other lock operations on this key will fail while a document is locked.
 * @param {?} key The target document key.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.getAndLock = function(key, callback_or_options, callback) {};

/**
 * Retrieves a document and updates the expiry of the item at the same time.
 * Retrieves a document and updates the expiry of the item at the same time.
 * @param {?} key The target document key.
 * @param {number} expiry The expiration time to use. If a value of 0 is provided, then the current expiration time is cleared and the key is set to never expire. Otherwise, the key is updated to expire in the time provided (in seconds).
 * @param {?|!Bucket.OpCallback} options_or_callback The options object. / The callback function.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.getAndTouch = function(key, expiry, options_or_callback, callback) {};

/**
 * Retrieves a list of keys
 * @param {!Array<?>} key
 * @param {!Bucket.MultiGetCallback} callback The callback function.
 * @return {void}
 */
Bucket.prototype.getMulti = function(key, callback) {};

/**
 * Get a document from a replica server in your cluster.
 * Get a document from a replica server in your cluster.
 * @param {?} key The target document key.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.getReplica = function(key, callback_or_options, callback) {};

/**
 * Identical to Bucket#upsert but will fail if the document already exists.
 * Identical to Bucket#upsert but will fail if the document already exists.
 * @param {?} key The target document key.
 * @param {?} value The document's contents.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.insert = function(key, value, callback_or_options, callback) {};

/**
 * Returns an instance of a BuckerManager for performing management operations against a bucket.
 * @return {?}
 */
Bucket.prototype.manager = function() {};

/**
 * Like Bucket#append, but prepends data to the existing value.
 * Like Bucket#append, but prepends data to the existing value.
 * @param {?} key The target document key.
 * @param {?} fragment The document's contents to prepend.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.prepend = function(key, fragment, callback_or_options, callback) {};

/**
 * Executes a previously prepared query object. This could be a ViewQuery or a N1qlQuery.
 * Note: N1qlQuery queries are currently an uncommitted interface and may be subject to change in 2.0.0's final release.
 * Executes a previously prepared query object. This could be a ViewQuery or a N1qlQuery.
 * Note: N1qlQuery queries are currently an uncommitted interface and may be subject to change in 2.0.0's final release.
 * @param {(!ViewQuery|!N1qlQuery)} query The query to execute.
 * @param {!Bucket.QueryCallback|(!Object|!Array<?>)} callback_or_params The callback function. / A list or map to do replacements on a N1QL query.
 * @param {!Bucket.QueryCallback=} callback The callback function.
 * @return {(!Bucket.ViewQueryResponse|!Bucket.N1qlQueryResponse)}
 */
Bucket.prototype.query = function(query, callback_or_params, callback) {};

/**
 * Deletes a document on the server.
 * Deletes a document on the server.
 * @param {?} key The target document key.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.remove = function(key, callback_or_options, callback) {};

/**
 * Identical to Bucket#upsert, but will only succeed if the document exists already (i.e. the inverse of Bucket#insert).
 * Identical to Bucket#upsert, but will only succeed if the document exists already (i.e. the inverse of Bucket#insert).
 * @param {?} key The target document key.
 * @param {?} value The document's contents.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.replace = function(key, value, callback_or_options, callback) {};

/**
 * Configures a custom set of transcoder functions for encoding and decoding values that are being stored or retreived from the server.
 * @param {!Bucket.EncoderFunction} encoder The function for encoding.
 * @param {!Bucket.DecoderFunction} decoder The function for decoding.
 * @return {void}
 */
Bucket.prototype.setTranscoder = function(encoder, decoder) {};

/**
 * Update the document expiration time.
 * @param {?} key The target document key.
 * @param {number} expiry The expiration time to use. If a value of 0 is provided, then the current expiration time is cleared and the key is set to never expire. Otherwise, the key is updated to expire in the time provided (in seconds). Values larger than 302460*60 seconds (30 days) are interpreted as absolute times (from the epoch).
 * @param {?} options The options object.
 * @param {!Bucket.OpCallback} callback The callback function.
 * @return {void}
 */
Bucket.prototype.touch = function(key, expiry, options, callback) {};

/**
 * Unlock a previously locked document on the server. See the Bucket#lock method for more details on locking.
 * Unlock a previously locked document on the server. See the Bucket#lock method for more details on locking.
 * @param {?} key The target document key.
 * @param {!Bucket.CAS} cas The CAS value returned when the key was locked. This operation will fail if the CAS value provided does not match that which was the result of the original lock operation.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.unlock = function(key, cas, callback_or_options, callback) {};

/**
 * Stores a document to the bucket.
 * Stores a document to the bucket.
 * @param {?} key The target document key.
 * @param {?} value The document's contents.
 * @param {!Bucket.OpCallback|?} callback_or_options The callback function. / The options object.
 * @param {!Bucket.OpCallback=} callback The callback function.
 * @return {void}
 */
Bucket.prototype.upsert = function(key, value, callback_or_options, callback) {};
/**
 * @record
 * @struct
 */
Bucket.QueryCallback = function() {};

/* TODO: CallSignature: Bucket */
/**
 * @record
 * @struct
 */
Bucket.OpCallback = function() {};

/* TODO: CallSignature: Bucket */
/**
 * @record
 * @struct
 */
Bucket.MultiGetCallback = function() {};

/* TODO: CallSignature: Bucket */
/**
 * @record
 * @struct
 */
Bucket.EncoderFunction = function() {};

/* TODO: CallSignature: Bucket */
/**
 * @record
 * @struct
 */
Bucket.DecoderFunction = function() {};

/* TODO: CallSignature: Bucket */
/**
 * @record
 * @struct
 */
Bucket.CAS = function() {};
/**
 * @record
 * @struct
 */
Bucket.N1qlQueryResponse = function() {};
/**
 * @record
 * @struct
 */
Bucket.N1qlQueryResponse.Meta = function() {};
 /** @type {number} */
Bucket.N1qlQueryResponse.Meta.prototype.requestID;
/**
 * @constructor
 * @struct
 */
Bucket.TranscoderDoc = function() {};
 /** @type {?} */
Bucket.TranscoderDoc.prototype.value;
 /** @type {number} */
Bucket.TranscoderDoc.prototype.flags;
/**
 * @record
 * @struct
 */
Bucket.ViewQueryResponse = function() {};
/**
 * @record
 * @struct
 */
Bucket.ViewQueryResponse.Meta = function() {};
 /** @type {number} */
Bucket.ViewQueryResponse.Meta.prototype.total_rows;
