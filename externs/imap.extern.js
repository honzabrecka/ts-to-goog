/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/imap/index.d.ts:
/** @const */
var Connection = {};
/**
 * @record
 * @struct
 */
Connection.Config = function() {};
 /** @type {string} */
Connection.Config.prototype.user;
 /** @type {string} */
Connection.Config.prototype.password;
 /** @type {string} */
Connection.Config.prototype.xoauth;
 /** @type {string} */
Connection.Config.prototype.xoauth2;
 /** @type {string} */
Connection.Config.prototype.host;
 /** @type {number} */
Connection.Config.prototype.port;
 /** @type {boolean} */
Connection.Config.prototype.tls;
 /** @type {!Object} */
Connection.Config.prototype.tlsOptions;
 /** @type {string} */
Connection.Config.prototype.autotls;
 /** @type {number} */
Connection.Config.prototype.connTimeout;
 /** @type {number} */
Connection.Config.prototype.authTimeout;
 /** @type {?} */
Connection.Config.prototype.keepalive;
 /** @type {!Function} */
Connection.Config.prototype.debug;
/**
 * @record
 * @struct
 */
Connection.KeepAlive = function() {};
 /** @type {number} */
Connection.KeepAlive.prototype.interval;
 /** @type {number} */
Connection.KeepAlive.prototype.idleInterval;
 /** @type {boolean} */
Connection.KeepAlive.prototype.forceNoop;
/**
 * @record
 * @struct
 */
Connection.Box = function() {};
 /** @type {string} */
Connection.Box.prototype.name;
 /** @type {boolean} */
Connection.Box.prototype.readOnly;
 /** @type {boolean} */
Connection.Box.prototype.newKeywords;
 /** @type {number} */
Connection.Box.prototype.uidvalidity;
 /** @type {number} */
Connection.Box.prototype.uidnext;
 /** @type {!Array<string>} */
Connection.Box.prototype.flags;
 /** @type {!Array<string>} */
Connection.Box.prototype.permFlags;
 /** @type {boolean} */
Connection.Box.prototype.persistentUIDs;
 /** @type {{total: number, new: number, unseen: number}} */
Connection.Box.prototype.messages;
/**
 * @record
 * @struct
 */
Connection.ImapMessageBodyInfo = function() {};
 /** @type {string} */
Connection.ImapMessageBodyInfo.prototype.which;
 /** @type {number} */
Connection.ImapMessageBodyInfo.prototype.size;
/**
 * @record
 * @struct
 */
Connection.ImapMessageAttributes = function() {};
 /** @type {number} */
Connection.ImapMessageAttributes.prototype.uid;
 /** @type {!Array<string>} */
Connection.ImapMessageAttributes.prototype.flags;
 /** @type {!Date} */
Connection.ImapMessageAttributes.prototype.date;
 /** @type {!Array<?>} */
Connection.ImapMessageAttributes.prototype.struct;
 /** @type {number} */
Connection.ImapMessageAttributes.prototype.size;
/**
 * @record
 * @struct
 */
Connection.ImapMessage = function() {};

/**
 * @param {string} event
 * @param {!Function|function(!NodeJS.ReadableStream, !Connection.ImapMessageBodyInfo): void|function(!Connection.ImapMessageAttributes): void|function(): void} listener
 * @return {ImapMessage}
 */
Connection.ImapMessage.prototype.on = function(event, listener) {};
/**
 * @record
 * @struct
 */
Connection.FetchOptions = function() {};
 /** @type {boolean} */
Connection.FetchOptions.prototype.markSeen;
 /** @type {boolean} */
Connection.FetchOptions.prototype.struct;
 /** @type {boolean} */
Connection.FetchOptions.prototype.envelope;
 /** @type {boolean} */
Connection.FetchOptions.prototype.size;
 /** @type {!Object} */
Connection.FetchOptions.prototype.modifiers;
 /** @type {(string|!Array<string>)} */
Connection.FetchOptions.prototype.bodies;
/**
 * @record
 * @struct
 */
Connection.ImapFetch = function() {};

/**
 * @param {string} event
 * @param {!Function|function(!Connection.ImapMessage, number): void|function(!Error): void} listener
 * @return {ImapFetch}
 */
Connection.ImapFetch.prototype.on = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function|function(!Error): void} listener
 * @return {ImapFetch}
 */
Connection.ImapFetch.prototype.once = function(event, listener) {};
/**
 * @record
 * @struct
 */
Connection.Folder = function() {};
 /** @type {!Array<string>} */
Connection.Folder.prototype.attribs;
 /** @type {string} */
Connection.Folder.prototype.delimiter;
 /** @type {!Connection.MailBoxes} */
Connection.Folder.prototype.children;
 /** @type {!Connection.Folder} */
Connection.Folder.prototype.parent;
/**
 * @record
 * @struct
 */
Connection.MailBoxes = function() {};

/* TODO: IndexSignature: Connection */
/**
 * @record
 * @struct
 */
Connection.AppendOptions = function() {};
 /** @type {string} */
Connection.AppendOptions.prototype.mailbox;
 /** @type {?} */
Connection.AppendOptions.prototype.flags;
 /** @type {!Date} */
Connection.AppendOptions.prototype.date;
/**
 * @record
 * @struct
 */
Connection.MessageFunctions = function() {};

/**
 * Searches the currently open mailbox for messages using given criteria. criteria is a list describing what you want to find. For criteria types that require arguments, use an array instead of just the string criteria type name (e.g. ['FROM', 'foo\@bar.com']). Prefix criteria types with an "!" to negate.
 * The following message flags are valid types that do not have arguments:
 * ALL:            void;    // All messages.
 * ANSWERED:       void;    // Messages with the Answered flag set.
 * DELETED:        void;    // Messages with the Deleted flag set.
 * DRAFT:          void;    // Messages with the Draft flag set.
 * FLAGGED:        void;    // Messages with the Flagged flag set.
 * NEW:            void;    // Messages that have the Recent flag set but not the Seen flag.
 * SEEN:           void;    // Messages that have the Seen flag set.
 * RECENT:         void;    // Messages that have the Recent flag set.
 * OLD:            void;    // Messages that do not have the Recent flag set. This is functionally equivalent to "!RECENT" (as opposed to "!NEW").
 * UNANSWERED:     void;    // Messages that do not have the Answered flag set.
 * UNDELETED:      void;    // Messages that do not have the Deleted flag set.
 * UNDRAFT:        void;    // Messages that do not have the Draft flag set.
 * UNFLAGGED:      void;    // Messages that do not have the Flagged flag set.
 * UNSEEN:         void;    // Messages that do not have the Seen flag set.
 * The following are valid types that require string value(s):
 * BCC:            any;    // Messages that contain the specified string in the BCC field.
 * CC:             any;    // Messages that contain the specified string in the CC field.
 * FROM:           any;    // Messages that contain the specified string in the FROM field.
 * SUBJECT:        any;    // Messages that contain the specified string in the SUBJECT field.
 * TO:             any;    // Messages that contain the specified string in the TO field.
 * BODY:           any;    // Messages that contain the specified string in the message body.
 * TEXT:           any;    // Messages that contain the specified string in the header OR the message body.
 * KEYWORD:        any;    // Messages with the specified keyword set.
 * HEADER:         any;    // Requires two string values, with the first being the header name and the second being the value to search for. If this second string is empty, all messages that contain the given header name will be returned.
 * The following are valid types that require a string parseable by JavaScripts Date object OR a Date instance:
 * BEFORE:         any;    // Messages whose internal date (disregarding time and timezone) is earlier than the specified date.
 * ON:             any;    // Messages whose internal date (disregarding time and timezone) is within the specified date.
 * SINCE:          any;    // Messages whose internal date (disregarding time and timezone) is within or later than the specified date.
 * SENTBEFORE:     any;    // Messages whose Date header (disregarding time and timezone) is earlier than the specified date.
 * SENTON:         any;    // Messages whose Date header (disregarding time and timezone) is within the specified date.
 * SENTSINCE:      any;    // Messages whose Date header (disregarding time and timezone) is within or later than the specified date.
 * The following are valid types that require one Integer value:
 * LARGER:         number;    // Messages with a size larger than the specified number of bytes.
 * SMALLER:        number;    // Messages with a size smaller than the specified number of bytes.
 * The following are valid criterion that require one or more Integer values:
 * UID:            any;    // Messages with UIDs corresponding to the specified UID set. Ranges are permitted (e.g. '2504:2507' or '*' or '2504:*').
 * @param {!Array<?>} criteria
 * @param {function(!Error, !Array<number>): void} callback
 * @return {void}
 */
Connection.MessageFunctions.prototype.search = function(criteria, callback) {};

/**
 * Fetches message(s) in the currently open mailbox; source can be a single message identifier, a message identifier range (e.g. '2504:2507' or '*' or '2504:*'), an array of message identifiers, or an array of message identifier ranges.
 * @param {?} source
 * @param {!Connection.FetchOptions} options
 * @return {!Connection.ImapFetch}
 */
Connection.MessageFunctions.prototype.fetch = function(source, options) {};

/**
 * Copies message(s) in the currently open mailbox to another mailbox.
 * @param {?} source
 * @param {string} mailboxName
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.MessageFunctions.prototype.copy = function(source, mailboxName, callback) {};

/**
 * Moves message(s) in the currently open mailbox to another mailbox. Note: The message(s) in the destination mailbox will have a new message UID.
 * @param {?} source
 * @param {string} mailboxName
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.MessageFunctions.prototype.move = function(source, mailboxName, callback) {};

/**
 * Adds flag(s) to message(s).
 * @param {?} source
 * @param {?} flags
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.MessageFunctions.prototype.addFlags = function(source, flags, callback) {};

/**
 * Removes flag(s) from message(s).
 * @param {?} source
 * @param {?} flags
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.MessageFunctions.prototype.delFlags = function(source, flags, callback) {};

/**
 * Sets the flag(s) for message(s).
 * @param {?} source
 * @param {?} flags
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.MessageFunctions.prototype.setFlags = function(source, flags, callback) {};

/**
 * Adds keyword(s) to message(s). keywords is either a single keyword or an array of keywords.
 * @param {?} source
 * @param {?} keywords
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.MessageFunctions.prototype.addKeywords = function(source, keywords, callback) {};

/**
 * Removes keyword(s) from message(s). keywords is either a single keyword or an array of keywords.
 * @param {?} source
 * @param {?} keywords
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.MessageFunctions.prototype.delKeywords = function(source, keywords, callback) {};

/**
 * Sets keyword(s) for message(s). keywords is either a single keyword or an array of keywords.
 * @param {?} source
 * @param {?} keywords
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.MessageFunctions.prototype.setKeywords = function(source, keywords, callback) {};

/**
 * Checks if the server supports the specified capability.
 * @param {string} capability
 * @return {boolean}
 */
Connection.MessageFunctions.prototype.serverSupports = function(capability) {};
 /** @type {string} */
Connection.prototype.state;
 /** @type {string} */
Connection.prototype.delimiter;
 /** @type {{personal: !Array<?>, other: !Array<?>, shared: !Array<?>}} */
Connection.prototype.namespaces;
 /** @type {!Connection.MessageFunctions} */
Connection.prototype.seq;

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Connection}
 */
Connection.prototype.addListener = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Connection}
 */
Connection.prototype.on = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Connection}
 */
Connection.prototype.once = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Connection}
 */
Connection.prototype.removeListener = function(event, listener) {};

/**
 * @param {string=} event
 * @return {Connection}
 */
Connection.prototype.removeAllListeners = function(event) {};

/**
 * @param {number} n
 * @return {Connection}
 */
Connection.prototype.setMaxListeners = function(n) {};

/**
 * @return {number}
 */
Connection.prototype.getMaxListeners = function() {};

/**
 * @param {string} event
 * @return {!Array<!Function>}
 */
Connection.prototype.listeners = function(event) {};

/**
 * @param {string} event
 * @param {...?} args
 * @return {boolean}
 */
Connection.prototype.emit = function(event, args) {};

/**
 * @param {string} type
 * @return {number}
 */
Connection.prototype.listenerCount = function(type) {};

/**
 * Searches the currently open mailbox for messages using given criteria. criteria is a list describing what you want to find. For criteria types that require arguments, use an array instead of just the string criteria type name (e.g. ['FROM', 'foo\@bar.com']). Prefix criteria types with an "!" to negate.
 * @param {!Array<?>} criteria
 * @param {function(!Error, !Array<number>): void} callback
 * @return {void}
 */
Connection.prototype.search = function(criteria, callback) {};

/**
 * Fetches message(s) in the currently open mailbox.
 * @param {?} source
 * @param {!Connection.FetchOptions} options
 * @return {!Connection.ImapFetch}
 */
Connection.prototype.fetch = function(source, options) {};

/**
 * Copies message(s) in the currently open mailbox to another mailbox.
 * @param {?} source
 * @param {string} mailboxName
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.copy = function(source, mailboxName, callback) {};

/**
 * Moves message(s) in the currently open mailbox to another mailbox. Note: The message(s) in the destination mailbox will have a new message UID.
 * @param {?} source
 * @param {string} mailboxName
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.move = function(source, mailboxName, callback) {};

/**
 * Adds flag(s) to message(s).
 * @param {?} source
 * @param {?} flags
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.addFlags = function(source, flags, callback) {};

/**
 * Removes flag(s) from message(s).
 * @param {?} source
 * @param {?} flags
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.delFlags = function(source, flags, callback) {};

/**
 * Sets the flag(s) for message(s).
 * @param {?} source
 * @param {?} flags
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.setFlags = function(source, flags, callback) {};

/**
 * Adds keyword(s) to message(s). keywords is either a single keyword or an array of keywords.
 * @param {?} source
 * @param {?} keywords
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.addKeywords = function(source, keywords, callback) {};

/**
 * Removes keyword(s) from message(s). keywords is either a single keyword or an array of keywords.
 * @param {?} source
 * @param {?} keywords
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.delKeywords = function(source, keywords, callback) {};

/**
 * Sets keyword(s) for message(s). keywords is either a single keyword or an array of keywords.
 * @param {?} source
 * @param {?} keywords
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.setKeywords = function(source, keywords, callback) {};

/**
 * Checks if the server supports the specified capability.
 * @param {string} capability
 * @return {boolean}
 */
Connection.prototype.serverSupports = function(capability) {};

/**
 * Parses a raw header and returns an object keyed on header fields and the values are Arrays of header field values. Set disableAutoDecode to true to disable automatic decoding of MIME encoded-words that may exist in header field values.
 * @param {string} rawHeader
 * @param {boolean=} disableAutoDecode
 * @return {!Object<string,!Array<string>>}
 */
Connection.parseHeader = function(rawHeader, disableAutoDecode) {};

/**
 * Attempts to connect and authenticate with the IMAP server.
 * @return {void}
 */
Connection.prototype.connect = function() {};

/**
 * Closes the connection to the server after all requests in the queue have been sent.
 * @return {void}
 */
Connection.prototype.end = function() {};

/**
 * Immediately destroys the connection to the server.
 * @return {void}
 */
Connection.prototype.destroy = function() {};

/**
 * Opens a specific mailbox that exists on the server. mailboxName should include any necessary prefix/path. modifiers is used by IMAP extensions.
 * @param {string} mailboxName
 * @param {function(!Error, !Connection.Box): void|boolean} callback_or_openReadOnly
 * @param {function(!Error, !Connection.Box): void|!Object=} callback_or_modifiers
 * @param {function(!Error, !Connection.Box): void=} callback
 * @return {void}
 */
Connection.prototype.openBox = function(mailboxName, callback_or_openReadOnly, callback_or_modifiers, callback) {};

/**
 * Closes the currently open mailbox. If autoExpunge is true, any messages marked as Deleted in the currently open mailbox will be removed if the mailbox was NOT opened in read-only mode. If autoExpunge is false, you disconnect, or you open another mailbox, messages marked as Deleted will NOT be removed from the currently open mailbox.
 * @param {function(!Error): void|boolean} callback_or_autoExpunge
 * @param {function(!Error): void=} callback
 * @return {void}
 */
Connection.prototype.closeBox = function(callback_or_autoExpunge, callback) {};

/**
 * Creates a new mailbox on the server. mailboxName should include any necessary prefix/path.
 * @param {string} mailboxName
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.addBox = function(mailboxName, callback) {};

/**
 * Removes a specific mailbox that exists on the server. mailboxName should including any necessary prefix/path.
 * @param {string} mailboxName
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.delBox = function(mailboxName, callback) {};

/**
 * Renames a specific mailbox that exists on the server. Both oldMailboxName and newMailboxName should include any necessary prefix/path. Note: Renaming the 'INBOX' mailbox will instead cause all messages in 'INBOX' to be moved to the new mailbox.
 * @param {string} oldMailboxName
 * @param {string} newMailboxName
 * @param {function(!Error, !Connection.Box): void} callback
 * @return {void}
 */
Connection.prototype.renameBox = function(oldMailboxName, newMailboxName, callback) {};

/**
 * Subscribes to a specific mailbox that exists on the server. mailboxName should include any necessary prefix/path.
 * @param {string} mailboxName
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.subscribeBox = function(mailboxName, callback) {};

/**
 * Unsubscribes from a specific mailbox that exists on the server. mailboxName should include any necessary prefix/path.
 * @param {string} mailboxName
 * @param {function(!Error): void} callback
 * @return {void}
 */
Connection.prototype.unsubscribeBox = function(mailboxName, callback) {};

/**
 * Fetches information about a mailbox other than the one currently open. Note: There is no guarantee that this will be a fast operation on the server. Also, do not call this on the currently open mailbox.
 * @param {string} mailboxName
 * @param {function(!Error, !Connection.Box): void} callback
 * @return {void}
 */
Connection.prototype.status = function(mailboxName, callback) {};

/**
 * Obtains the full list of mailboxes. If nsPrefix is not specified, the main personal namespace is used.
 * @param {function(!Error, !Connection.MailBoxes): void|string} callback_or_nsPrefix
 * @param {function(!Error, !Connection.MailBoxes): void=} callback
 * @return {void}
 */
Connection.prototype.getBoxes = function(callback_or_nsPrefix, callback) {};

/**
 * Obtains the full list of subscribed mailboxes. If nsPrefix is not specified, the main personal namespace is used.
 * @param {function(!Error, !Connection.MailBoxes): void|string} callback_or_nsPrefix
 * @param {function(!Error, !Connection.MailBoxes): void=} callback
 * @return {void}
 */
Connection.prototype.getSubscribedBoxes = function(callback_or_nsPrefix, callback) {};

/**
 * Permanently removes all messages flagged as Deleted in the currently open mailbox. If the server supports the 'UIDPLUS' capability, uids can be supplied to only remove messages that both have their uid in uids and have the \Deleted flag set. Note: At least on Gmail, performing this operation with any currently open mailbox that is not the Spam or Trash mailbox will merely archive any messages marked as Deleted (by moving them to the 'All Mail' mailbox).
 * @param {function(!Error): void|?} callback_or_uids
 * @param {function(!Error): void=} callback
 * @return {void}
 */
Connection.prototype.expunge = function(callback_or_uids, callback) {};

/**
 * Appends a message to selected mailbox. msgData is a string or Buffer containing an RFC-822 compatible MIME message. Valid options properties are:
 * @param {?} msgData
 * @param {function(!Error): void|!Connection.AppendOptions} callback_or_options
 * @param {function(!Error): void=} callback
 * @return {void}
 */
Connection.prototype.append = function(msgData, callback_or_options, callback) {};

/* TODO: ExportAssignment in  */
