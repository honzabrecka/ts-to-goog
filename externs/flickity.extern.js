/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/flickity/index.d.ts:
/**
 * @record
 * @struct
 */
function JQuery() {}
 /** @type {!FlickityJquery} */
JQuery.prototype.flickity;
/**
 * @record
 * @struct
 */
function FlickityJquery() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/**
 * @constructor
 * @struct
 * Initializes an new instance of Flickity .
 * 
 * Initializes an new instance of Flickity .
 * 
 * @param {string|!Element} selector_or_element Container Element to initialize Flickity on
 * @param {!FlickityOptions=} options (IFlickityOptions) Flickity options
 */
function Flickity(selector_or_element, options) {}
 /** @type {number} */
Flickity.prototype.selectedIndex;
 /** @type {!Element} */
Flickity.prototype.selectedElement;
 /** @type {!Array<!Element>} */
Flickity.prototype.cells;

/**
 * (static) Get the Flickity instance via selector.
 * 
 * (static) Get the Flickity instance via its element.
 * 
 * @param {string|!Element} element Element selector string / The element
 * @return {!Flickity}
 */
Flickity.data = function(element) {};

/**
 * Select a cell.
 * 
 * @param {number} index Integer Zero-based index of the cell to select.
 * @param {boolean=} isWrapped (Optional) If true, the last cell will be selected if at the first cell.
 * @param {boolean=} isInstant (Optional) If true, immediately view the selected cell without animation.
 * @return {void}
 */
Flickity.prototype.select = function(index, isWrapped, isInstant) {};

/**
 * Select the previous cell.
 * 
 * @param {boolean=} isWrapped (Optional) If true, the first cell will be selected if at the last cell.
 * @return {void}
 */
Flickity.prototype.previous = function(isWrapped) {};

/**
 * Select the next cell.
 * @param {boolean=} isWrapped (Optional) If true, the first cell will be selected if at the first cell.
 * @return {void}
 */
Flickity.prototype.next = function(isWrapped) {};

/**
 * Resize the gallery and re-position cells.
 * @return {void}
 */
Flickity.prototype.resize = function() {};

/**
 * Position cells at selected position.
 * Trigger reposition after the size of a cell has been changed.
 * @return {void}
 */
Flickity.prototype.reposition = function() {};

/**
 * Prepend elements and create cells to the beginning of the gallery.
 * 
 * @param {(!Element|!NodeList)} elements JQuery, Element[], Element, or NodeList
 * @return {void}
 */
Flickity.prototype.prepend = function(elements) {};

/**
 * Append elements and create cells to the end of the gallery.
 * 
 * @param {(!Element|!NodeList)} elements JQuery, Element[], Element, or NodeList
 * @return {void}
 */
Flickity.prototype.append = function(elements) {};

/**
 * Insert elements into the gallery and create cells.
 * 
 * @param {(!Element|!Array<!Element>|!NodeList)} elements Element[], Element, or NodeList
 * @param {number} index Integer: Zero-based index to insert elements.
 * @return {void}
 */
Flickity.prototype.insert = function(elements, index) {};

/**
 * Remove cells from gallery and remove elements from DOM.
 * 
 * @param {(!Element|!Array<!Element>|!NodeList)} elements Element[], Element, or NodeList
 * @return {void}
 */
Flickity.prototype.remove = function(elements) {};

/**
 * Remove Flickity functionality completely. destroy will return the element back to its pre-initialized state.
 * @return {void}
 */
Flickity.prototype.destroy = function() {};

/**
 * Re-collect all cell elements in flickity-slider.
 * @return {void}
 */
Flickity.prototype.reloadCells = function() {};

/**
 * Get the elements of the cells.
 * @return {!Array<!Element>} Element[]
 */
Flickity.prototype.getCellElements = function() {};

/**
 * Add new classic event listener
 * @param {...?} params
 * @return {void}
 */
Flickity.prototype.listener = function(params) {};

/**
 * bind event listener
 * bind event listener
 * bind event listener
 * bind event listener
 * @param {string} eventname
 * @param {function(!Event, (!Element|!Touch), !Element, number): ?|function(!Event, (!Element|!Touch), !Object): ?|function(!Event, !Element): ?|function(!Event, (!Element|!Touch)): ?} callback callback funtion to execute when event fires
 * @return {void}
 */
Flickity.prototype.on = function(eventname, callback) {};

/**
 * Remove event listener
 * Remove event listener
 * Remove event listener
 * Remove event listener
 * @param {string} eventname
 * @param {function(!Event, (!Element|!Touch), !Element, number): ?|function(!Event, (!Element|!Touch), !Object): ?|function(!Event, !Element): ?|function(!Event, (!Element|!Touch)): ?} callback callback funtion to execute when event fires
 * @return {void}
 */
Flickity.prototype.off = function(eventname, callback) {};

/**
 * one time event handler
 * one time event handler
 * one time event handler
 * one time event handler
 * @param {string} eventname
 * @param {function(!Event, (!Element|!Touch), !Element, number): ?|function(!Event, (!Element|!Touch), !Object): ?|function(!Event, !Element): ?|function(!Event, (!Element|!Touch)): ?} callback callback funtion to execute when event fires
 * @return {void}
 */
Flickity.prototype.once = function(eventname, callback) {};
/**
 * @record
 * @struct
 */
function FlickityOptions() {}
 /** @type {string} */
FlickityOptions.prototype.cellSelector;
 /** @type {number} */
FlickityOptions.prototype.initialIndex;
 /** @type {boolean} */
FlickityOptions.prototype.accessibility;
 /** @type {boolean} */
FlickityOptions.prototype.setGallerySize;
 /** @type {boolean} */
FlickityOptions.prototype.resize;
 /** @type {string} */
FlickityOptions.prototype.cellAlign;
 /** @type {boolean} */
FlickityOptions.prototype.contain;
 /** @type {boolean} */
FlickityOptions.prototype.imagesLoaded;
 /** @type {boolean} */
FlickityOptions.prototype.percentPosition;
 /** @type {boolean} */
FlickityOptions.prototype.rightToLeft;
 /** @type {boolean} */
FlickityOptions.prototype.draggable;
 /** @type {boolean} */
FlickityOptions.prototype.freeScroll;
 /** @type {boolean} */
FlickityOptions.prototype.wrapAround;
 /** @type {(number|boolean)} */
FlickityOptions.prototype.lazyLoad;
 /** @type {(number|boolean)} */
FlickityOptions.prototype.autoPlay;
 /** @type {(string|boolean)} */
FlickityOptions.prototype.watchCSS;
 /** @type {string} */
FlickityOptions.prototype.asNavFor;
 /** @type {number} */
FlickityOptions.prototype.selectedAttraction;
 /** @type {number} */
FlickityOptions.prototype.friction;
 /** @type {number} */
FlickityOptions.prototype.freeScrollFriction;
 /** @type {boolean} */
FlickityOptions.prototype.prevNextButtons;
 /** @type {boolean} */
FlickityOptions.prototype.pageDots;
 /** @type {?} */
FlickityOptions.prototype.arrowShape;
