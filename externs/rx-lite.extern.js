/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/rx-lite/index.d.ts:
/** @const */
Rx.internals = {};

/**
 * @param {?} left
 * @param {?} right
 * @return {boolean}
 */
Rx.internals.isEqual = function(left, right) {};

/**
 * @template T
 * @param {?<T>} xs
 * @param {{getDisposable: function(): !Rx.IDisposable}} r
 * @return {?<T>}
 */
Rx.internals.addRef = function(xs, r) {};

/**
 * @constructor
 * @struct
 * @param {number} capacity
 */
Rx.internals.PriorityQueue = function(capacity) {};
 /** @type {number} */
Rx.internals.PriorityQueue.prototype.length;
 /** @type {number} */
Rx.internals.PriorityQueue.count;

/**
 * @param {number} left
 * @param {number} right
 * @return {boolean}
 */
Rx.internals.PriorityQueue.prototype.isHigherPriority = function(left, right) {};

/**
 * @param {number} index
 * @return {void}
 */
Rx.internals.PriorityQueue.prototype.percolate = function(index) {};

/**
 * @param {number} index
 * @return {void}
 */
Rx.internals.PriorityQueue.prototype.heapify = function(index) {};

/**
 * @return {!Rx.internals.ScheduledItem<TTime>}
 */
Rx.internals.PriorityQueue.prototype.peek = function() {};

/**
 * @param {number} index
 * @return {void}
 */
Rx.internals.PriorityQueue.prototype.removeAt = function(index) {};

/**
 * @return {!Rx.internals.ScheduledItem<TTime>}
 */
Rx.internals.PriorityQueue.prototype.dequeue = function() {};

/**
 * @param {!Rx.internals.ScheduledItem<TTime>} item
 * @return {void}
 */
Rx.internals.PriorityQueue.prototype.enqueue = function(item) {};

/**
 * @param {!Rx.internals.ScheduledItem<TTime>} item
 * @return {boolean}
 */
Rx.internals.PriorityQueue.prototype.remove = function(item) {};

/**
 * @constructor
 * @struct
 * @param {!Rx.IScheduler} scheduler
 * @param {?} state
 * @param {function(!Rx.IScheduler, ?): !Rx.IDisposable} action
 * @param {TTime} dueTime
 * @param {function(TTime, TTime): number=} comparer
 */
Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {};
 /** @type {!Rx.IScheduler} */
Rx.internals.ScheduledItem.prototype.scheduler;
 /** @type {TTime} */
Rx.internals.ScheduledItem.prototype.state;
 /** @type {function(!Rx.IScheduler, ?): !Rx.IDisposable} */
Rx.internals.ScheduledItem.prototype.action;
 /** @type {TTime} */
Rx.internals.ScheduledItem.prototype.dueTime;
 /** @type {function(TTime, TTime): number} */
Rx.internals.ScheduledItem.prototype.comparer;
 /** @type {!Rx.SingleAssignmentDisposable} */
Rx.internals.ScheduledItem.prototype.disposable;

/**
 * @return {void}
 */
Rx.internals.ScheduledItem.prototype.invoke = function() {};

/**
 * @param {!Rx.internals.ScheduledItem} other
 * @return {number}
 */
Rx.internals.ScheduledItem.prototype.compareTo = function(other) {};

/**
 * @return {boolean}
 */
Rx.internals.ScheduledItem.prototype.isCancelled = function() {};

/**
 * @return {!Rx.IDisposable}
 */
Rx.internals.ScheduledItem.prototype.invokeCore = function() {};
/** @const */
Rx.config = {};
 /** @type {function(new: (!Rx.IPromise<T>), function(function(T): void, function(?): void): void): ?} */
Rx.config.Promise;
/** @const */
Rx.helpers = {};

/**
 * @return {void}
 */
Rx.helpers.noop = function() {};

/**
 * @param {?} value
 * @return {boolean}
 */
Rx.helpers.notDefined = function(value) {};

/**
 * @template T
 * @param {T} value
 * @return {T}
 */
Rx.helpers.identity = function(value) {};

/**
 * @return {number}
 */
Rx.helpers.defaultNow = function() {};

/**
 * @param {?} left
 * @param {?} right
 * @return {boolean}
 */
Rx.helpers.defaultComparer = function(left, right) {};

/**
 * @param {?} left
 * @param {?} right
 * @return {number}
 */
Rx.helpers.defaultSubComparer = function(left, right) {};

/**
 * @param {?} key
 * @return {string}
 */
Rx.helpers.defaultKeySerializer = function(key) {};

/**
 * @param {?} err
 * @return {void}
 */
Rx.helpers.defaultError = function(err) {};

/**
 * @param {?} p
 * @return {boolean}
 */
Rx.helpers.isPromise = function(p) {};

/**
 * @template T
 * @param {...T} args
 * @return {!Array<T>}
 */
Rx.helpers.asArray = function(args) {};

/**
 * @param {?} value
 * @return {boolean}
 */
Rx.helpers.not = function(value) {};

/**
 * @param {?} value
 * @return {boolean}
 */
Rx.helpers.isFunction = function(value) {};

/**
 * @constructor
 * @struct
 * @param {...!Rx.IDisposable|!Array<!Rx.IDisposable>} disposables
 */
Rx.CompositeDisposable = function(disposables) {};
 /** @type {boolean} */
Rx.CompositeDisposable.prototype.isDisposed;
 /** @type {number} */
Rx.CompositeDisposable.prototype.length;

/**
 * @return {void}
 */
Rx.CompositeDisposable.prototype.dispose = function() {};

/**
 * @param {!Rx.IDisposable} item
 * @return {void}
 */
Rx.CompositeDisposable.prototype.add = function(item) {};

/**
 * @param {!Rx.IDisposable} item
 * @return {boolean}
 */
Rx.CompositeDisposable.prototype.remove = function(item) {};

/**
 * @return {!Array<!Rx.IDisposable>}
 */
Rx.CompositeDisposable.prototype.toArray = function() {};

/**
 * @constructor
 * @struct
 * @param {function(): void} action
 */
Rx.Disposable = function(action) {};
 /** @type {!Rx.IDisposable} */
Rx.Disposable.empty;

/**
 * @param {function(): void} action
 * @return {!Rx.IDisposable}
 */
Rx.Disposable.create = function(action) {};

/**
 * @return {void}
 */
Rx.Disposable.prototype.dispose = function() {};

/**
 * @constructor
 * @struct
 */
Rx.SingleAssignmentDisposable = function() {};
 /** @type {boolean} */
Rx.SingleAssignmentDisposable.prototype.isDisposed;
 /** @type {!Rx.IDisposable} */
Rx.SingleAssignmentDisposable.prototype.current;

/**
 * @return {void}
 */
Rx.SingleAssignmentDisposable.prototype.dispose = function() {};

/**
 * @return {!Rx.IDisposable}
 */
Rx.SingleAssignmentDisposable.prototype.getDisposable = function() {};

/**
 * @param {!Rx.IDisposable} value
 * @return {void}
 */
Rx.SingleAssignmentDisposable.prototype.setDisposable = function(value) {};

/**
 * @constructor
 * @struct
 */
Rx.SerialDisposable = function() {};

/**
 * @constructor
 * @struct
 * @param {!Rx.IDisposable} disposable
 */
Rx.RefCountDisposable = function(disposable) {};
 /** @type {boolean} */
Rx.RefCountDisposable.prototype.isDisposed;

/**
 * @return {void}
 */
Rx.RefCountDisposable.prototype.dispose = function() {};

/**
 * @return {!Rx.IDisposable}
 */
Rx.RefCountDisposable.prototype.getDisposable = function() {};

/**
 * @return {number}
 */
Rx.IScheduler.prototype.now = function() {};

/**
 * @param {?} value
 * @return {boolean}
 */
Rx.IScheduler.prototype.isScheduler = function(value) {};

/**
 * @param {function(): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.schedule = function(action) {};

/**
 * @template TState
 * @param {TState} state
 * @param {function(!Rx.IScheduler, TState): !Rx.IDisposable} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleWithState = function(state, action) {};

/**
 * @param {number} dueTime
 * @param {function(): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleWithAbsolute = function(dueTime, action) {};

/**
 * @template TState
 * @param {TState} state
 * @param {number} dueTime
 * @param {function(!Rx.IScheduler, TState): !Rx.IDisposable} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleWithAbsoluteAndState = function(state, dueTime, action) {};

/**
 * @param {number} dueTime
 * @param {function(): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleWithRelative = function(dueTime, action) {};

/**
 * @template TState
 * @param {TState} state
 * @param {number} dueTime
 * @param {function(!Rx.IScheduler, TState): !Rx.IDisposable} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleWithRelativeAndState = function(state, dueTime, action) {};

/**
 * @param {function(function(): void): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleRecursive = function(action) {};

/**
 * @template TState
 * @param {TState} state
 * @param {function(TState, function(TState): void): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleRecursiveWithState = function(state, action) {};

/**
 * @param {number} dueTime
 * @param {function(function(number): void): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleRecursiveWithAbsolute = function(dueTime, action) {};

/**
 * @template TState
 * @param {TState} state
 * @param {number} dueTime
 * @param {function(TState, function(TState, number): void): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleRecursiveWithAbsoluteAndState = function(state, dueTime, action) {};

/**
 * @param {number} dueTime
 * @param {function(function(number): void): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleRecursiveWithRelative = function(dueTime, action) {};

/**
 * @template TState
 * @param {TState} state
 * @param {number} dueTime
 * @param {function(TState, function(TState, number): void): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.scheduleRecursiveWithRelativeAndState = function(state, dueTime, action) {};

/**
 * @param {number} period
 * @param {function(): void} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.schedulePeriodic = function(period, action) {};

/**
 * @template TState
 * @param {TState} state
 * @param {number} period
 * @param {function(TState): TState} action
 * @return {!Rx.IDisposable}
 */
Rx.IScheduler.prototype.schedulePeriodicWithState = function(state, period, action) {};
/**
 * @extends {Rx.IScheduler}
 * @record
 * @struct
 */
Rx.Scheduler = function() {};
/**
 * @record
 * @struct
 */
Rx.SchedulerStatic = function() {};

/* TODO: ConstructSignature: Rx */
 /** @type {!Rx.IScheduler} */
Rx.SchedulerStatic.prototype.immediate;
 /** @type {!Rx.ICurrentThreadScheduler} */
Rx.SchedulerStatic.prototype.currentThread;
 /** @type {!Rx.IScheduler} */
Rx.SchedulerStatic.prototype.default;
 /** @type {!Rx.IScheduler} */
Rx.SchedulerStatic.prototype.timeout;

/**
 * @param {number} timeSpan
 * @return {number}
 */
Rx.SchedulerStatic.prototype.normalize = function(timeSpan) {};
 /** @type {!Rx.SchedulerStatic} */
Rx.Scheduler;
/**
 * @extends {Rx.IScheduler}
 * @record
 * @struct
 */
Rx.ICurrentThreadScheduler = function() {};

/**
 * @return {boolean}
 */
Rx.ICurrentThreadScheduler.prototype.scheduleRequired = function() {};
/**
 * @constructor
 * @struct
 */
Rx.Notification = function() {};
 /** @type {boolean} */
Rx.Notification.prototype.hasValue;
 /** @type {string} */
Rx.Notification.prototype.kind;
 /** @type {T} */
Rx.Notification.prototype.value;
 /** @type {?} */
Rx.Notification.prototype.exception;

/**
 * @template TResult
 * @param {!Rx.IObserver<T>|function(T): TResult} observer_or_onNext
 * @param {function(?): TResult=} onError
 * @param {function(): TResult=} onCompleted
 * @return {void|TResult}
 */
Rx.Notification.prototype.accept = function(observer_or_onNext, onError, onCompleted) {};

/**
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.Notification.prototype.toObservable = function(scheduler) {};

/**
 * @param {!Rx.Notification} other
 * @return {boolean}
 */
Rx.Notification.prototype.equals = function(other) {};

/**
 * @template T
 * @param {T} value
 * @return {!Rx.Notification<T>}
 */
Rx.Notification.createOnNext = function(value) {};

/**
 * @template T
 * @param {?} exception
 * @return {!Rx.Notification<T>}
 */
Rx.Notification.createOnError = function(exception) {};

/**
 * @template T
 * @return {!Rx.Notification<T>}
 */
Rx.Notification.createOnCompleted = function() {};
/**
 * @record
 * @struct
 */
Rx.IObserver = function() {};

/**
 * @param {T} value
 * @return {void}
 */
Rx.IObserver.prototype.onNext = function(value) {};

/**
 * @param {?} exception
 * @return {void}
 */
Rx.IObserver.prototype.onError = function(exception) {};

/**
 * @return {void}
 */
Rx.IObserver.prototype.onCompleted = function() {};

/**
 * @return {function(!Rx.Notification<T>): void}
 */
Rx.Observer.prototype.toNotifier = function() {};

/**
 * @return {?}
 */
Rx.Observer.prototype.asObserver = function() {};

/**
 * @template T
 * @param {function(T): void=} onNext
 * @param {function(?): void=} onError
 * @param {function(): void=} onCompleted
 * @return {?<T>}
 */
Rx.ObserverStatic.prototype.create = function(onNext, onError, onCompleted) {};

/**
 * @template T
 * @param {function(!Rx.Notification<T>, ?): void} handler
 * @return {?<T>}
 */
Rx.ObserverStatic.prototype.fromNotifier = function(handler) {};
 /** @type {!Rx.ObserverStatic} */
Rx.Observer;
/**
 * @record
 * @struct
 */
Rx.IObservable = function() {};

/**
 * @param {?<T>|function(T): void=} observer_or_onNext
 * @param {function(?): void=} onError
 * @param {function(): void=} onCompleted
 * @return {!Rx.IDisposable}
 */
Rx.IObservable.prototype.subscribe = function(observer_or_onNext, onError, onCompleted) {};

/**
 * @param {function(T): void} onNext
 * @param {?=} thisArg
 * @return {!Rx.IDisposable}
 */
Rx.IObservable.prototype.subscribeOnNext = function(onNext, thisArg) {};

/**
 * @param {function(?): void} onError
 * @param {?=} thisArg
 * @return {!Rx.IDisposable}
 */
Rx.IObservable.prototype.subscribeOnError = function(onError, thisArg) {};

/**
 * @param {function(): void} onCompleted
 * @param {?=} thisArg
 * @return {!Rx.IDisposable}
 */
Rx.IObservable.prototype.subscribeOnCompleted = function(onCompleted, thisArg) {};

/**
 * @param {function(T): void=} onNext
 * @param {function(?): void=} onError
 * @param {function(): void=} onCompleted
 * @return {!Rx.IDisposable}
 */
Rx.Observable.prototype.forEach = function(onNext, onError, onCompleted) {};

/**
 * @return {?<!Array<T>>}
 */
Rx.Observable.prototype.toArray = function() {};

/**
 * @param {function(!Error): (?|!Rx.IPromise<T>)|?} handler_or_second
 * @return {?}
 */
Rx.Observable.prototype.catch = function(handler_or_second) {};

/**
 * @param {function(!Error): (?|!Rx.IPromise<T>)|?} handler_or_second
 * @return {?}
 */
Rx.Observable.prototype.catchException = function(handler_or_second) {};

/**
 * @template T2, TResult, T3, T4, T5, TOther
 * @param {(?<T2>|!Rx.IPromise<T2>)|!Array<(?<TOther>|!Rx.IPromise<TOther>)>} second_or_souces
 * @param {function(T, T2): TResult|(?<T3>|!Rx.IPromise<T3>)|function(T, !Array<TOther>): TResult=} resultSelector_or_third
 * @param {function(T, T2, T3): TResult|(?<T4>|!Rx.IPromise<T4>)=} resultSelector_or_fourth
 * @param {function(T, T2, T3, T4): TResult|(?<T5>|!Rx.IPromise<T5>)=} resultSelector_or_fifth
 * @param {function(T, T2, T3, T4, T5): TResult=} resultSelector
 * @return {?<!Array<?>>|?<TResult>}
 */
Rx.Observable.prototype.combineLatest = function(second_or_souces, resultSelector_or_third, resultSelector_or_fourth, resultSelector_or_fifth, resultSelector) {};

/**
 * @template T2, TResult, T3, T4, T5, TOther
 * @param {(?<T2>|!Rx.IPromise<T2>)|!Array<(?<TOther>|!Rx.IPromise<TOther>)>} second_or_souces
 * @param {function(T, T2): TResult|(?<T3>|!Rx.IPromise<T3>)|function(T, !Array<TOther>): TResult=} resultSelector_or_third
 * @param {function(T, T2, T3): TResult|(?<T4>|!Rx.IPromise<T4>)=} resultSelector_or_fourth
 * @param {function(T, T2, T3, T4): TResult|(?<T5>|!Rx.IPromise<T5>)=} resultSelector_or_fifth
 * @param {function(T, T2, T3, T4, T5): TResult=} resultSelector
 * @return {?<!Array<?>>|?<TResult>}
 */
Rx.Observable.prototype.withLatestFrom = function(second_or_souces, resultSelector_or_third, resultSelector_or_fourth, resultSelector_or_fifth, resultSelector) {};

/**
 * @param {...(?|!Rx.IPromise<T>)|!Array<(?|!Rx.IPromise<T>)>} sources
 * @return {?}
 */
Rx.Observable.prototype.concat = function(sources) {};

/**
 * @return {T}
 */
Rx.Observable.prototype.concatAll = function() {};

/**
 * @return {?}
 */
Rx.Observable.prototype.concatObservable = function() {};

/**
 * @template T2, R
 * @param {function(T, number): ?<T2>|function(T, number): !Rx.IPromise<T2>|function(T, number): ?<R>|function(T, number): !Rx.IPromise<R>|function(T, number): !Array<R>|?<R>|!Array<R>} selector_or_sequence
 * @param {function(T, T2, number): R=} resultSelector
 * @return {?<R>}
 */
Rx.Observable.prototype.concatMap = function(selector_or_sequence, resultSelector) {};

/**
 * @param {number|?|!Rx.IPromise<T>} maxConcurrent_or_other
 * @return {T|?}
 */
Rx.Observable.prototype.merge = function(maxConcurrent_or_other) {};

/**
 * @return {?}
 */
Rx.Observable.prototype.mergeAll = function() {};

/**
 * @return {?}
 */
Rx.Observable.prototype.mergeObservable = function() {};

/**
 * @template T2
 * @param {?<T2>|!Rx.IPromise<T2>} other
 * @return {?}
 */
Rx.Observable.prototype.skipUntil = function(other) {};

/**
 * @return {T}
 */
Rx.Observable.prototype.switch = function() {};

/**
 * @return {T}
 */
Rx.Observable.prototype.switchLatest = function() {};

/**
 * @template T2
 * @param {?<T2>|!Rx.IPromise<T2>} other
 * @return {?}
 */
Rx.Observable.prototype.takeUntil = function(other) {};

/**
 * @template T2, TResult, T3, T4, T5, TOther
 * @param {(?<T2>|!Rx.IPromise<T2>)|!Array<(?<TOther>|!Rx.IPromise<TOther>)>} second
 * @param {function(T, T2): TResult|(?<T3>|!Rx.IPromise<T3>)|function(T, !Array<TOther>): TResult=} resultSelector_or_third
 * @param {function(T, T2, T3): TResult|(?<T4>|!Rx.IPromise<T4>)=} resultSelector_or_fourth
 * @param {function(T, T2, T3, T4): TResult|(?<T5>|!Rx.IPromise<T5>)=} resultSelector_or_fifth
 * @param {function(T, T2, T3, T4, T5): TResult=} resultSelector
 * @return {?<!Array<?>>|?<TResult>}
 */
Rx.Observable.prototype.zip = function(second, resultSelector_or_third, resultSelector_or_fourth, resultSelector_or_fifth, resultSelector) {};

/**
 * @return {?}
 */
Rx.Observable.prototype.asObservable = function() {};

/**
 * @template TOrigin
 * @return {?<TOrigin>}
 */
Rx.Observable.prototype.dematerialize = function() {};

/**
 * @template TValue
 * @param {boolean|function(T): TValue=} skipParameter_or_keySelector
 * @param {function(T, T): boolean|function(TValue, TValue): boolean=} comparer
 * @return {?}
 */
Rx.Observable.prototype.distinctUntilChanged = function(skipParameter_or_keySelector, comparer) {};

/**
 * @param {?<T>|function(T): void=} observer_or_onNext
 * @param {function(!Error): void=} onError
 * @param {function(): void=} onCompleted
 * @return {?}
 */
Rx.Observable.prototype.do = function(observer_or_onNext, onError, onCompleted) {};

/**
 * @param {?<T>|function(T): void=} observer_or_onNext
 * @param {function(!Error): void=} onError
 * @param {function(): void=} onCompleted
 * @return {?}
 */
Rx.Observable.prototype.doAction = function(observer_or_onNext, onError, onCompleted) {};

/**
 * @param {?<T>|function(T): void=} observer_or_onNext
 * @param {function(!Error): void=} onError
 * @param {function(): void=} onCompleted
 * @return {?}
 */
Rx.Observable.prototype.tap = function(observer_or_onNext, onError, onCompleted) {};

/**
 * @param {function(T): void} onNext
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.doOnNext = function(onNext, thisArg) {};

/**
 * @param {function(?): void} onError
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.doOnError = function(onError, thisArg) {};

/**
 * @param {function(): void} onCompleted
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.doOnCompleted = function(onCompleted, thisArg) {};

/**
 * @param {function(T): void} onNext
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.tapOnNext = function(onNext, thisArg) {};

/**
 * @param {function(?): void} onError
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.tapOnError = function(onError, thisArg) {};

/**
 * @param {function(): void} onCompleted
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.tapOnCompleted = function(onCompleted, thisArg) {};

/**
 * @param {function(): void} action
 * @return {?}
 */
Rx.Observable.prototype.finally = function(action) {};

/**
 * @param {function(): void} action
 * @return {?}
 */
Rx.Observable.prototype.finallyAction = function(action) {};

/**
 * @return {?}
 */
Rx.Observable.prototype.ignoreElements = function() {};

/**
 * @return {?<!Rx.Notification<T>>}
 */
Rx.Observable.prototype.materialize = function() {};

/**
 * @param {number=} repeatCount
 * @return {?}
 */
Rx.Observable.prototype.repeat = function(repeatCount) {};

/**
 * @param {number=} retryCount
 * @return {?}
 */
Rx.Observable.prototype.retry = function(retryCount) {};

/**
 * @template TError
 * @param {function(?<TError>): ?<?>} notifier
 * @return {?}
 */
Rx.Observable.prototype.retryWhen = function(notifier) {};

/**
 *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.
 *  For aggregation behavior with no intermediate results, see Observable.aggregate.
 * \@example 
 *  var res = source.scan(function (acc, x) { return acc + x; });
 *  var res = source.scan(function (acc, x) { return acc + x; }, 0);
 * @template TAcc
 * @param {function(TAcc, T, number, ?<TAcc>): TAcc|function(T, T, number, ?): T} accumulator An accumulator function to be invoked on each element.
 * @param {TAcc=} seed The initial accumulator value.
 * @return {?<TAcc>|?} An observable sequence containing the accumulated values.
 */
Rx.Observable.prototype.scan = function(accumulator, seed) {};

/**
 * @param {number} count
 * @return {?}
 */
Rx.Observable.prototype.skipLast = function(count) {};

/**
 * @param {...T|!Rx.IScheduler} values_or_scheduler
 * @return {?}
 */
Rx.Observable.prototype.startWith = function(values_or_scheduler) {};

/**
 * @param {number} count
 * @return {?}
 */
Rx.Observable.prototype.takeLast = function(count) {};

/**
 * @param {number} count
 * @return {?<!Array<T>>}
 */
Rx.Observable.prototype.takeLastBuffer = function(count) {};

/**
 * @template TResult
 * @param {function(T, number, ?): TResult} selector
 * @param {?=} thisArg
 * @return {?<TResult>}
 */
Rx.Observable.prototype.select = function(selector, thisArg) {};

/**
 * @template TResult
 * @param {function(T, number, ?): TResult} selector
 * @param {?=} thisArg
 * @return {?<TResult>}
 */
Rx.Observable.prototype.map = function(selector, thisArg) {};

/**
 * @template TResult
 * @param {string} prop
 * @return {?<TResult>}
 */
Rx.Observable.prototype.pluck = function(prop) {};

/**
 * @template TOther, TResult
 * @param {function(T): ?<TOther>|function(T): !Rx.IPromise<TOther>|function(T): ?<TResult>|function(T): !Rx.IPromise<TResult>|?<TResult>|!Rx.IPromise<TResult>|function(T): !Array<TResult>} selector_or_other
 * @param {function(T, TOther): TResult=} resultSelector
 * @return {?<TResult>}
 */
Rx.Observable.prototype.selectMany = function(selector_or_other, resultSelector) {};

/**
 * @template TOther, TResult
 * @param {function(T): ?<TOther>|function(T): !Rx.IPromise<TOther>|function(T): ?<TResult>|function(T): !Rx.IPromise<TResult>|?<TResult>|!Rx.IPromise<TResult>|function(T): !Array<TResult>} selector_or_other
 * @param {function(T, TOther): TResult=} resultSelector
 * @return {?<TResult>}
 */
Rx.Observable.prototype.flatMap = function(selector_or_other, resultSelector) {};

/**
 * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
 * @template T2, T3, T4
 * @param {function(T, number): ?<T2>} onNext
 * @param {function(?): ?<T3>} onError
 * @param {function(): ?<T4>} onCompleted
 * @param {?=} thisArg
 * @return {?<(T2|T3|T4)>}
 */
Rx.Observable.prototype.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {};

/**
 * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
 * @template T2, T3, T4
 * @param {function(T, number): ?<T2>} onNext
 * @param {function(?): ?<T3>} onError
 * @param {function(): ?<T4>} onCompleted
 * @param {?=} thisArg
 * @return {?<(T2|T3|T4)>}
 */
Rx.Observable.prototype.flatMapObserver = function(onNext, onError, onCompleted, thisArg) {};

/**
 * @template T2, R
 * @param {function(T, number): ?<T2>|function(T, number): !Rx.IPromise<T2>|function(T, number): ?<R>|function(T, number): !Rx.IPromise<R>|?<R>} selector_or_sequence
 * @param {function(T, T2, number): R=} resultSelector
 * @return {?<R>}
 */
Rx.Observable.prototype.selectConcat = function(selector_or_sequence, resultSelector) {};

/**
 *  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then
 *  transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
 * @template TResult
 * @param {function(T, number, ?): ?<TResult>} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
 * @param {?=} thisArg
 * @return {?<TResult>} An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences
 *  and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
 */
Rx.Observable.prototype.selectSwitch = function(selector, thisArg) {};

/**
 *  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then
 *  transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
 * @template TResult
 * @param {function(T, number, ?): ?<TResult>} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
 * @param {?=} thisArg
 * @return {?<TResult>} An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences
 *  and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
 */
Rx.Observable.prototype.flatMapLatest = function(selector, thisArg) {};

/**
 *  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then
 *  transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
 * \@since 2.2.28
 * @template TResult
 * @param {function(T, number, ?): TResult} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
 * @param {?=} thisArg
 * @return {?<TResult>} An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences
 *  and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
 */
Rx.Observable.prototype.switchMap = function(selector, thisArg) {};

/**
 * @param {number} count
 * @return {?}
 */
Rx.Observable.prototype.skip = function(count) {};

/**
 * @param {function(T, number, ?): boolean} predicate
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.skipWhile = function(predicate, thisArg) {};

/**
 * @param {number} count
 * @param {!Rx.IScheduler=} scheduler
 * @return {?}
 */
Rx.Observable.prototype.take = function(count, scheduler) {};

/**
 * @param {function(T, number, ?): boolean} predicate
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.takeWhile = function(predicate, thisArg) {};

/**
 * @param {function(T, number, ?): boolean} predicate
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.where = function(predicate, thisArg) {};

/**
 * @param {function(T, number, ?): boolean} predicate
 * @param {?=} thisArg
 * @return {?}
 */
Rx.Observable.prototype.filter = function(predicate, thisArg) {};

/**
 * Converts an existing observable sequence to an ES6 Compatible Promise
 * \@example 
 * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
 * Converts an existing observable sequence to an ES6 Compatible Promise
 * \@example 
 * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
 * 
 * // With config
 * Rx.config.Promise = RSVP.Promise;
 * var promise = Rx.Observable.return(42).toPromise();
 * @template TPromise
 * @param {function(new: (TPromise), function(function(T): void, function(?): void): void): ?|function(new: (!Rx.IPromise<T>), function(function(T): void, function(?): void): void): ?=} promiseCtor The constructor of the promise.
 * @return {TPromise|!Rx.IPromise<T>} An ES6 compatible promise with the last value from the observable sequence.
 */
Rx.Observable.prototype.toPromise = function(promiseCtor) {};

/**
 * Performs a exclusive waiting for the first to finish before subscribing to another observable.
 * Observables that come in between subscriptions will be dropped on the floor.
 * Can be applied on `Observable<Observable<R>>` or `Observable<IPromise<R>>`.
 * \@since 2.2.28
 * @template R
 * @return {?<R>} A exclusive observable with only the results that happen when subscribed.
 */
Rx.Observable.prototype.exclusive = function() {};

/**
 * Performs a exclusive map waiting for the first to finish before subscribing to another observable.
 * Observables that come in between subscriptions will be dropped on the floor.
 * Can be applied on `Observable<Observable<I>>` or `Observable<IPromise<I>>`.
 * \@since 2.2.28
 * @template I, R
 * @param {function(I, number, ?<I>): R} selector Selector to invoke for every item in the current subscription.
 * @param {?=} thisArg
 * @return {?<R>}
 */
Rx.Observable.prototype.exclusiveMap = function(selector, thisArg) {};

/**
 * @return {?<T>}
 */
Rx.Observable.prototype.publish = function() {};

/**
 * @return {!Rx.Disposable}
 */
Rx.ConnectableObservable.prototype.connect = function() {};
 /** @type {?} */
Rx.ObservableStatic.prototype.prototype;

/**
 * @template T
 * @param {function(?<T>): !Rx.IDisposable|function(?<T>): function(): void|function(?<T>): void} subscribe
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.create = function(subscribe) {};

/**
 * @template T
 * @param {function(?<T>): !Rx.IDisposable} subscribe
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.createWithDisposable = function(subscribe) {};

/**
 * @template T
 * @param {function(): ?<T>|function(): !Rx.IPromise<T>} observableFactory
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.defer = function(observableFactory) {};

/**
 * @template T
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.empty = function(scheduler) {};

/**
 * This method creates a new Observable sequence from an array object.
 * This method creates a new Observable sequence from an array object.
 * This method creates a new Observable sequence from an array-like object.
 * This method creates a new Observable sequence from an array-like object.
 * This method creates a new Observable sequence from an array-like or iterable object.
 * @template T, TResult
 * @param {!Array<T>|?} array_or_iterable An array-like or iterable object to convert to an Observable sequence.
 * @param {function(T, number): TResult|function(T, number): T|function(?, number): T=} mapFn Map function to call on every element of the array.
 * @param {?=} thisArg
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<TResult>|?<T>}
 */
Rx.ObservableStatic.prototype.from = function(array_or_iterable, mapFn, thisArg, scheduler) {};

/**
 * @template T
 * @param {!Array<T>|?} array
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.fromArray = function(array, scheduler) {};

/**
 * @template TState, TResult
 * @param {TState} initialState
 * @param {function(TState): boolean} condition
 * @param {function(TState): TState} iterate
 * @param {function(TState): TResult} resultSelector
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<TResult>}
 */
Rx.ObservableStatic.prototype.generate = function(initialState, condition, iterate, resultSelector, scheduler) {};

/**
 * @template T
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.never = function() {};

/**
 *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
 * 
 * \@example 
 *  var res = Rx.Observable.of(1, 2, 3);
 * \@since 2.2.28
 * @template T
 * @param {...T} values
 * @return {?<T>} The observable sequence whose elements are pulled from the given arguments.
 */
Rx.ObservableStatic.prototype.of = function(values) {};

/**
 *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
 * \@example 
 *  var res = Rx.Observable.ofWithScheduler(Rx.Scheduler.timeout, 1, 2, 3);
 * \@since 2.2.28
 * @template T
 * @param {!Rx.IScheduler=} scheduler
 * @param {...T} values
 * @return {?<T>} The observable sequence whose elements are pulled from the given arguments.
 */
Rx.ObservableStatic.prototype.ofWithScheduler = function(scheduler, values) {};

/**
 * @param {number} start
 * @param {number} count
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<number>}
 */
Rx.ObservableStatic.prototype.range = function(start, count, scheduler) {};

/**
 * @template T
 * @param {T} value
 * @param {number=} repeatCount
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.repeat = function(value, repeatCount, scheduler) {};

/**
 * @template T
 * @param {T} value
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.return = function(value, scheduler) {};

/**
 * \@since 2.2.28
 * @template T
 * @param {T} value
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.just = function(value, scheduler) {};

/**
 * @template T
 * @param {T} value
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.returnValue = function(value, scheduler) {};

/**
 * @template T
 * @param {!Error} exception
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.throw = function(exception, scheduler) {};

/**
 * @template T
 * @param {!Error} exception
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.throwException = function(exception, scheduler) {};

/**
 * @template T
 * @param {!Error} error
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.throwError = function(error, scheduler) {};

/**
 * @template T
 * @param {...(!Array<!Rx.IPromise<T>>|!Array<?<T>>)|?<T>|!Rx.IPromise<T>} sources
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.catch = function(sources) {};

/**
 * @template T
 * @param {...(!Array<!Rx.IPromise<T>>|!Array<?<T>>)|?<T>|!Rx.IPromise<T>} sources
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.catchException = function(sources) {};

/**
 * @template T
 * @param {...(!Array<!Rx.IPromise<T>>|!Array<?<T>>)|?<T>|!Rx.IPromise<T>} sources
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.catchError = function(sources) {};

/**
 * @template T, T2, TResult, T3, T4, T5, TOther
 * @param {(?<T>|!Rx.IPromise<T>)|!Array<(?<T>|!Rx.IPromise<T>)>|!Array<(?<TOther>|!Rx.IPromise<TOther>)>} first_or_sources
 * @param {(?<T2>|!Rx.IPromise<T2>)|function(!Array<TOther>): TResult=} second_or_resultSelector
 * @param {function(T, T2): TResult|(?<T3>|!Rx.IPromise<T3>)=} resultSelector_or_third
 * @param {function(T, T2, T3): TResult|(?<T4>|!Rx.IPromise<T4>)=} resultSelector_or_fourth
 * @param {function(T, T2, T3, T4): TResult|(?<T5>|!Rx.IPromise<T5>)=} resultSelector_or_fifth
 * @param {function(T, T2, T3, T4, T5): TResult=} resultSelector
 * @return {?<!Array<?>>|?<TResult>|?<!Array<T>>}
 */
Rx.ObservableStatic.prototype.combineLatest = function(first_or_sources, second_or_resultSelector, resultSelector_or_third, resultSelector_or_fourth, resultSelector_or_fifth, resultSelector) {};

/**
 * @template T, T2, TResult, T3, T4, T5, TOther
 * @param {(?<T>|!Rx.IPromise<T>)|!Array<(?<TOther>|!Rx.IPromise<TOther>)>} first_or_souces
 * @param {(?<T2>|!Rx.IPromise<T2>)|function(!Array<TOther>): TResult} second_or_resultSelector
 * @param {function(T, T2): TResult|(?<T3>|!Rx.IPromise<T3>)=} resultSelector_or_third
 * @param {function(T, T2, T3): TResult|(?<T4>|!Rx.IPromise<T4>)=} resultSelector_or_fourth
 * @param {function(T, T2, T3, T4): TResult|(?<T5>|!Rx.IPromise<T5>)=} resultSelector_or_fifth
 * @param {function(T, T2, T3, T4, T5): TResult=} resultSelector
 * @return {?<!Array<?>>|?<TResult>}
 */
Rx.ObservableStatic.prototype.withLatestFrom = function(first_or_souces, second_or_resultSelector, resultSelector_or_third, resultSelector_or_fourth, resultSelector_or_fifth, resultSelector) {};

/**
 * @template T
 * @param {...?<T>|!Rx.IPromise<T>|(!Array<!Rx.IPromise<T>>|!Array<?<T>>)} sources
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.concat = function(sources) {};

/**
 * @template T
 * @param {...?<T>|!Rx.IPromise<T>|(!Array<!Rx.IPromise<T>>|!Array<?<T>>)|!Rx.IScheduler} sources_or_scheduler
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.merge = function(sources_or_scheduler) {};

/**
 * @template T
 * @param {!Object<string,T>} obj
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<!Array<?>>}
 */
Rx.ObservableStatic.prototype.pairs = function(obj, scheduler) {};

/**
 * @template T1, T2, TResult, T3, T4, T5
 * @param {(?<T1>|!Rx.IPromise<T1>)} first_or_source1
 * @param {(?<T2>|!Rx.IPromise<T2>|!Array<(?<T2>|!Rx.IPromise<T2>)>)|!Array<(?<T2>|!Rx.IPromise<T2>)>|(?<T2>|!Rx.IPromise<T2>)} sources_or_source2
 * @param {function(T1, !Array<T2>): TResult|function(T1, T2): TResult|(?<T3>|!Rx.IPromise<T3>)=} resultSelector_or_source3
 * @param {function(T1, T2, T3): TResult|(?<T4>|!Rx.IPromise<T4>)=} resultSelector_or_source4
 * @param {function(T1, T2, T3, T4): TResult|(?<T5>|!Rx.IPromise<T5>)=} resultSelector_or_source5
 * @param {function(T1, T2, T3, T4, T5): TResult=} resultSelector
 * @return {?<!Array<?>>|?<TResult>}
 */
Rx.ObservableStatic.prototype.zip = function(first_or_source1, sources_or_source2, resultSelector_or_source3, resultSelector_or_source4, resultSelector_or_source5, resultSelector) {};

/**
 * @template T
 * @param {...(?<T>|!Rx.IPromise<T>)|!Array<(?<T>|!Rx.IPromise<T>)>} sources
 * @return {?<!Array<T>>}
 */
Rx.ObservableStatic.prototype.zipArray = function(sources) {};

/**
 * Converts a Promise to an Observable sequence
 * @template T
 * @param {!Rx.IPromise<T>} promise An ES6 Compliant promise.
 * @return {?<T>} An Observable sequence which wraps the existing promise success and failure.
 */
Rx.ObservableStatic.prototype.fromPromise = function(promise) {};
 /** @type {!Rx.ObservableStatic} */
Rx.Observable;
 /** @type {boolean} */
Rx.config.useNativeEvents;
 /** @type {?} */
Rx.ObservableStatic.prototype.fromCallback;
 /** @type {?} */
Rx.ObservableStatic.prototype.fromNodeCallback;

/**
 * @template T
 * @param {(!Rx.DOMEventTarget|!ArrayLike<!Rx.DOMEventTarget>|!Rx.NodeEventTarget|!Rx.NativeEventTarget)} element
 * @param {string} eventName
 * @param {function(!Array<?>): T=} selector
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.fromEvent = function(element, eventName, selector) {};

/**
 * @template T
 * @param {function(!Function): void} addHandler
 * @param {function(!Function): void} removeHandler
 * @param {function(!Array<?>): T=} selector
 * @return {?<T>}
 */
Rx.ObservableStatic.prototype.fromEventPattern = function(addHandler, removeHandler, selector) {};
/**
 * @record
 * @struct
 */
Rx.NodeEventTarget = function() {};

/**
 * @param {string} name
 * @param {function(?): ?} cb
 * @return {void}
 */
Rx.NodeEventTarget.prototype.addListener = function(name, cb) {};
/**
 * @record
 * @struct
 */
Rx.NativeEventTarget = function() {};

/**
 * @param {string} name
 * @param {function(?): ?} cb
 * @return {void}
 */
Rx.NativeEventTarget.prototype.on = function(name, cb) {};

/**
 * @param {string} name
 * @param {function(?): ?} cb
 * @return {void}
 */
Rx.NativeEventTarget.prototype.off = function(name, cb) {};
/**
 * @record
 * @struct
 */
Rx.DOMEventTarget = function() {};

/**
 * @param {string} type
 * @param {function(?): ?} listener
 * @param {boolean} useCapture
 * @return {void}
 */
Rx.DOMEventTarget.prototype.addEventListener = function(type, listener, useCapture) {};

/**
 * @param {string} type
 * @param {function(?): ?} listener
 * @param {boolean} useCapture
 * @return {void}
 */
Rx.DOMEventTarget.prototype.removeEventListener = function(type, listener, useCapture) {};
/**
 * @record
 * @struct
 */
Rx.TimeInterval = function() {};
 /** @type {T} */
Rx.TimeInterval.prototype.value;
 /** @type {number} */
Rx.TimeInterval.prototype.interval;
/**
 * @record
 * @struct
 */
Rx.Timestamp = function() {};
 /** @type {T} */
Rx.Timestamp.prototype.value;
 /** @type {number} */
Rx.Timestamp.prototype.timestamp;

/**
 * @param {!Date|number} dueTime
 * @param {!Rx.IScheduler=} scheduler
 * @return {?}
 */
Rx.Observable.prototype.delay = function(dueTime, scheduler) {};

/**
 * @param {number} dueTime
 * @param {!Rx.IScheduler=} scheduler
 * @return {?}
 */
Rx.Observable.prototype.debounce = function(dueTime, scheduler) {};

/**
 * @param {number} dueTime
 * @param {!Rx.IScheduler=} scheduler
 * @return {?}
 */
Rx.Observable.prototype.throttleWithTimeout = function(dueTime, scheduler) {};

/**
 * @deprecated use #debounce or #throttleWithTimeout instead.
 * @param {number} dueTime
 * @param {!Rx.IScheduler=} scheduler
 * @return {?}
 */
Rx.Observable.prototype.throttle = function(dueTime, scheduler) {};

/**
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<!Rx.TimeInterval<T>>}
 */
Rx.Observable.prototype.timeInterval = function(scheduler) {};

/**
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<!Rx.Timestamp<T>>}
 */
Rx.Observable.prototype.timestamp = function(scheduler) {};

/**
 * @template TSample
 * @param {number|?<TSample>} interval_or_sampler
 * @param {!Rx.IScheduler=} scheduler
 * @return {?}
 */
Rx.Observable.prototype.sample = function(interval_or_sampler, scheduler) {};

/**
 * @param {!Date|number} dueTime
 * @param {?=} other
 * @param {!Rx.IScheduler=} scheduler
 * @return {?}
 */
Rx.Observable.prototype.timeout = function(dueTime, other, scheduler) {};

/**
 * @param {number} period_or_dutTime
 * @param {!Rx.IScheduler|number=} scheduler_or_period
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<number>}
 */
Rx.ObservableStatic.prototype.interval = function(period_or_dutTime, scheduler_or_period, scheduler) {};

/**
 * @param {number} dueTime
 * @param {number|!Rx.IScheduler=} period_or_scheduler
 * @param {!Rx.IScheduler=} scheduler
 * @return {?<number>}
 */
Rx.ObservableStatic.prototype.timer = function(dueTime, period_or_scheduler, scheduler) {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "rx-lite"
/** @const */
tsickle_declare_module.rx_lite = {};

/* TODO: ExportAssignment in tsickle_declare_module.rx_lite */
