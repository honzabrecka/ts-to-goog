/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/ssh2-streams/index.d.ts:

/* TODO: ImportDeclaration in  */

/**
 * @constructor
 * @struct
 * Creates and returns a new SSH2Stream instance.
 * @param {?=} config
 */
function SSH2Stream(config) {}
 /** @type {number} */
SSH2Stream.prototype.bytesSent;
 /** @type {number} */
SSH2Stream.prototype.bytesReceived;

/**
 * (Client/Server)
 * Writes a dummy GLOBAL_REQUEST packet (specifically "keepalive\@openssh.com") that requests a reply.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @return {boolean}
 */
SSH2Stream.prototype.ping = function() {};

/**
 * (Client/Server)
 * Writes a disconnect packet and closes the stream.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number=} reasonCode
 * @return {boolean}
 */
SSH2Stream.prototype.disconnect = function(reasonCode) {};

/**
 * (Client/Server)
 * Starts the re-keying process. Incoming/Outgoing packets are buffered until the re-keying
 * process has finished. Returns `false` to indicate that no more packets should be written
 * until the `NEWKEYS` event is seen.
 * @return {boolean}
 */
SSH2Stream.prototype.rekey = function() {};

/**
 * (Client/Server)
 * Writes a request success packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?=} data
 * @return {boolean}
 */
SSH2Stream.prototype.requestSuccess = function(data) {};

/**
 * (Client/Server)
 * Writes a request failure packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @return {boolean}
 */
SSH2Stream.prototype.requestFailure = function() {};

/**
 * (Client/Server)
 * Writes a channel success packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @return {boolean}
 */
SSH2Stream.prototype.channelSuccess = function(channel) {};

/**
 * (Client/Server)
 * Writes a channel failure packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @return {boolean}
 */
SSH2Stream.prototype.channelFailure = function(channel) {};

/**
 * (Client/Server)
 * Writes a channel EOF packet for the given `channel`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @return {boolean}
 */
SSH2Stream.prototype.channelEOF = function(channel) {};

/**
 * (Client/Server)
 * Writes a channel close packet for the given `channel`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @return {boolean}
 */
SSH2Stream.prototype.channelClose = function(channel) {};

/**
 * (Client/Server)
 * Writes a channel window adjust packet for the given `channel` where `amount` is the
 * number of bytes to add to the channel window.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} amount
 * @return {boolean}
 */
SSH2Stream.prototype.channelWindowAdjust = function(channel, amount) {};

/**
 * (Client/Server)
 * Writes a channel data packet for the given `channel` where `data` is a _Buffer_ or _string_.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {(string|?)} data
 * @return {boolean}
 */
SSH2Stream.prototype.channelData = function(channel, data) {};

/**
 * (Client/Server)
 * Writes a channel extended data packet for the given `channel` where `data is a _Buffer_
 * or _string_.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {(string|?)} data
 * @param {number} type
 * @return {boolean}
 */
SSH2Stream.prototype.channelExtData = function(channel, data, type) {};

/**
 * (Client/Server)
 * Writes a channel open confirmation packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} remoteChannel
 * @param {number} localChannel
 * @param {number} initWindow
 * @param {number} maxPacket
 * @return {boolean}
 */
SSH2Stream.prototype.channelOpenConfirm = function(remoteChannel, localChannel, initWindow, maxPacket) {};

/**
 * (Client/Server)
 * Writes a channel open failure packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} remoteChannel
 * @param {number} reasonCode
 * @param {string=} description
 * @param {string=} lang
 * @return {boolean}
 */
SSH2Stream.prototype.channelOpenFail = function(remoteChannel, reasonCode, description, lang) {};

/**
 * (Client-only)
 * Writes a service request packet for `serviceName`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} serviceName
 * @return {boolean}
 */
SSH2Stream.prototype.service = function(serviceName) {};

/**
 * (Client-only)
 * Writes a tcpip forward global request packet. `wantReply` defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} bindAddr
 * @param {number} bindPort
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.tcpipForward = function(bindAddr, bindPort, wantReply) {};

/**
 * (Client-only)
 * Writes a cancel tcpip forward global request packet. `wantReply` defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} bindAddr
 * @param {number} bindPort
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.cancelTcpipForward = function(bindAddr, bindPort, wantReply) {};

/**
 * (Client-only)
 * Writes a password userauth request packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} username
 * @param {string} password
 * @return {boolean}
 */
SSH2Stream.prototype.authPassword = function(username, password) {};

/**
 * (Client-only)
 * Writes a publickey userauth request packet. `pubKey` is the object returned from using
 * `utils.parseKey()` on a private or public key. If `cbSign` is not present, a pubkey
 * check userauth packet is written. Otherwise `cbSign` is called with `(blob, callback)`,
 * where `blob` is the data to sign with the private key and the resulting signature
 * _Buffer_ is passed to `callback` as the first argument.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} username
 * @param {?} pubKey
 * @param {?=} cbSign
 * @return {boolean}
 */
SSH2Stream.prototype.authPK = function(username, pubKey, cbSign) {};

/**
 * (Client-only)
 * Writes a hostbased userauth request packet. `pubKey` is the object returned from using
 * `utils.parseKey()` on a private or public key. `cbSign` is called with `(blob, callback)`,
 * where `blob` is the data to sign with the private key and the resulting signature
 * _Buffer_ is passed to `callback` as the first argument.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} username
 * @param {?} pubKey
 * @param {string} localHostname
 * @param {string} localUsername
 * @param {?=} cbSign
 * @return {boolean}
 */
SSH2Stream.prototype.authHostBased = function(username, pubKey, localHostname, localUsername, cbSign) {};

/**
 * (Client-only)
 * Writes a keyboard-interactive userauth request packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} username
 * @return {boolean}
 */
SSH2Stream.prototype.authKeyboard = function(username) {};

/**
 * (Client-only)
 * Writes a "none" userauth request packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} username
 * @return {boolean}
 */
SSH2Stream.prototype.authNone = function(username) {};

/**
 * (Client-only)
 * Writes a userauth info response packet. `responses` is an _array_ of zero or more strings
 * corresponding to responses to prompts previously sent by the server.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {!Array<string>=} responses
 * @return {boolean}
 */
SSH2Stream.prototype.authInfoRes = function(responses) {};

/**
 * (Client-only)
 * Writes a direct tcpip channel open packet. `config` must contain `srcIP`, `srcPort`,
 * `dstIP`, and `dstPort`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} initWindow
 * @param {number} maxPacket
 * @param {?} config
 * @return {boolean}
 */
SSH2Stream.prototype.directTcpip = function(channel, initWindow, maxPacket, config) {};

/**
 * (Client-only)
 * Writes a session channel open packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} initWindow
 * @param {number} maxPacket
 * @return {boolean}
 */
SSH2Stream.prototype.session = function(channel, initWindow, maxPacket) {};

/**
 * (Client-only)
 * Writes an `auth-agent-req\@openssh.com` channel request packet. `wantReply` defaults to
 * `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.openssh_agentForward = function(channel, wantReply) {};

/**
 * (Client-only)
 * Writes a window change channel request packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} rows
 * @param {number} cols
 * @param {number} height
 * @param {number} width
 * @return {boolean}
 */
SSH2Stream.prototype.windowChange = function(channel, rows, cols, height, width) {};

/**
 * (Client-only)
 * Writes a pty channel request packet. If `terminalType` is falsey, `vt100` is used.
 * `terminalModes` can be the raw bytes, an _object_ of the terminal modes to set, or a falsey value for no modes. `wantReply` defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} rows
 * @param {number} cols
 * @param {number} height
 * @param {number} width
 * @param {string=} terminalType
 * @param {?=} terminalModes
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.pty = function(channel, rows, cols, height, width, terminalType, terminalModes, wantReply) {};

/**
 * (Client-only)
 * Writes an env channel request packet. `value` can be a _string_ or _Buffer_. `wantReply`
 * defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {string} key
 * @param {(string|?)} value
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.env = function(channel, key, value, wantReply) {};

/**
 * (Client-only)
 * Writes a shell channel request packet. `wantReply` defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.shell = function(channel, wantReply) {};

/**
 * (Client-only)
 * Writes an exec channel request packet. `wantReply` defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {string} command
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.exec = function(channel, command, wantReply) {};

/**
 * (Client-only)
 * Writes a signal channel request packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {string} signalName
 * @return {boolean}
 */
SSH2Stream.prototype.signal = function(channel, signalName) {};

/**
 * (Client-only)
 * Writes an X11 forward channel request packet. `wantReply` defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {?} config
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.x11Forward = function(channel, config, wantReply) {};

/**
 * (Client-only)
 * Writes a subsystem channel request packet. `name` is the name of the subsystem (e.g.
 * `sftp` or `netconf`). `wantReply` defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {string} name
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.subsystem = function(channel, name, wantReply) {};

/**
 * (Client-only)
 * Writes a no-more-sessions\@openssh.com request packet. `wantReply` defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.openssh_noMoreSessions = function(wantReply) {};

/**
 * (Client-only)
 * Writes a streamlocal-forward\@openssh.com request packet. `wantReply` defaults to `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} socketPath
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.openssh_streamLocalForward = function(socketPath, wantReply) {};

/**
 * (Client-only)
 * Writes a cancel-streamlocal-forward\@openssh.com request packet. `wantReply` defaults to
 * `true`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} socketPath
 * @param {boolean=} wantReply
 * @return {boolean}
 */
SSH2Stream.prototype.openssh_cancelStreamLocalForward = function(socketPath, wantReply) {};

/**
 * (Client-only)
 * Writes a direct-streamlocal\@openssh.com channel open packet. `config` must contain
 * `socketPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} initWindow
 * @param {number} maxPacket
 * @param {?} config
 * @return {boolean}
 */
SSH2Stream.prototype.openssh_directStreamLocal = function(channel, initWindow, maxPacket, config) {};

/**
 * (Server-only)
 * Writes a service accept packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} serviceName
 * @return {boolean}
 */
SSH2Stream.prototype.serviceAccept = function(serviceName) {};

/**
 * (Server-only)
 * Writes a userauth failure packet. `authMethods` is an _array_ of authentication methods
 * that can continue.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {!Array<string>=} authMethods
 * @param {boolean=} partialSuccess
 * @return {boolean}
 */
SSH2Stream.prototype.authFailure = function(authMethods, partialSuccess) {};

/**
 * (Server-only)
 * Writes a userauth success packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @return {boolean}
 */
SSH2Stream.prototype.authSuccess = function() {};

/**
 * (Server-only)
 * Writes a userauth PK OK packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} keyAlgorithm
 * @param {?} keyData
 * @return {boolean}
 */
SSH2Stream.prototype.authPKOK = function(keyAlgorithm, keyData) {};

/**
 * (Server-only)
 * Writes a userauth info request packet. `prompts` is an array of `Prompt` objects.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} name
 * @param {string} instructions
 * @param {!Array<?>} prompts
 * @return {boolean}
 */
SSH2Stream.prototype.authInfoReq = function(name, instructions, prompts) {};

/**
 * (Server-only)
 * Writes a forwarded tcpip channel open packet. `info` must contain `boundAddr`,
 * `boundPort`, `remoteAddr`, and `remotePort`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} initWindow
 * @param {number} maxPacket
 * @param {?} info
 * @return {boolean}
 */
SSH2Stream.prototype.forwardedTcpip = function(channel, initWindow, maxPacket, info) {};

/**
 * (Server-only)
 * Writes an X11 channel open packet. `info` must contain `originAddr` and `originPort`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} initWindow
 * @param {number} maxPacket
 * @param {?} info
 * @return {boolean}
 */
SSH2Stream.prototype.x11 = function(channel, initWindow, maxPacket, info) {};

/**
 * (Server-only)
 * Writes an forwarded-streamlocal\@openssh.com channel open packet. `info` must contain
 * `socketPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} initWindow
 * @param {number} maxPacket
 * @param {?} info
 * @return {boolean}
 */
SSH2Stream.prototype.openssh_forwardedStreamLocal = function(channel, initWindow, maxPacket, info) {};

/**
 * (Server-only)
 * Writes an exit status channel request packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {number} exitCode
 * @return {boolean}
 */
SSH2Stream.prototype.exitStatus = function(channel, exitCode) {};

/**
 * (Server-only)
 * Writes an exit signal channel request packet.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} channel
 * @param {string} signalName
 * @param {boolean} coreDumped
 * @param {string} errorMessage
 * @return {boolean}
 */
SSH2Stream.prototype.exitSignal = function(channel, signalName, coreDumped, errorMessage) {};

/**
 * (Client/Server)
 * Emitted when the protocol header is seen.
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client/Server)
 * (Client-only)
 * This event allows you to verify a host's key. If `callback` is called with `true`, the
 * handshake continues. Otherwise a disconnection will occur if `callback` is called with
 * `false`. The default behavior is to auto-allow any host key if there are no handlers
 * for this event.
 * (Client-only)
 * (Client-only)
 * (Client-only)
 * (Client-only)
 * (Client-only)
 * (Client-only)
 * (Client-only)
 * (Server-only)
 * (Server-only)
 * (Server-only)
 * Emitted when the connection has authenticated.
 * Emitted when the socket has disconnected.
 * Emitted when the client socket was closed.
 * Emitted when more requests/data can be sent to the stream.
 * Emitted when an error occurred.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
SSH2Stream.prototype.on = function(event, listener) {};
/**
 * @record
 * @struct
 */
function SSH2StreamConfig() {}
 /** @type {boolean} */
SSH2StreamConfig.prototype.server;
 /** @type {?} */
SSH2StreamConfig.prototype.hostKeys;
 /** @type {string} */
SSH2StreamConfig.prototype.banner;
 /** @type {string} */
SSH2StreamConfig.prototype.ident;
 /** @type {number} */
SSH2StreamConfig.prototype.maxPacketSize;
 /** @type {number} */
SSH2StreamConfig.prototype.highWaterMark;
 /** @type {?} */
SSH2StreamConfig.prototype.algorithms;
 /** @type {?} */
SSH2StreamConfig.prototype.debug;
/**
 * @record
 * @struct
 */
function HostKeys() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function HostKey() {}
 /** @type {?} */
HostKey.prototype.privatekey;
 /** @type {?} */
HostKey.prototype.publickey;
/**
 * @record
 * @struct
 */
function Algorithms() {}
 /** @type {!Array<string>} */
Algorithms.prototype.kex;
 /** @type {!Array<string>} */
Algorithms.prototype.cipher;
 /** @type {!Array<string>} */
Algorithms.prototype.serverHostKey;
 /** @type {!Array<string>} */
Algorithms.prototype.hmac;
 /** @type {!Array<string>} */
Algorithms.prototype.compress;
/**
 * @record
 * @struct
 */
function Header() {}
 /** @type {string} */
Header.prototype.greeting;
 /** @type {string} */
Header.prototype.identRaw;
 /** @type {?} */
Header.prototype.versions;
 /** @type {string} */
Header.prototype.comments;
/**
 * @record
 * @struct
 */
function Versions() {}
 /** @type {string} */
Versions.prototype.protocol;
 /** @type {string} */
Versions.prototype.software;
/**
 * @record
 * @struct
 */
function TcpipForwardGlobalRequest() {}
 /** @type {string} */
TcpipForwardGlobalRequest.prototype.bindAddr;
 /** @type {number} */
TcpipForwardGlobalRequest.prototype.bindPort;
/**
 * @record
 * @struct
 */
function openssh_StreamLocalForwardGlobalRequest() {}
 /** @type {string} */
openssh_StreamLocalForwardGlobalRequest.prototype.socketPath;

/** @typedef {?} */
var GlobalRequest;
/**
 * @record
 * @struct
 */
function ChannelOpenConfirmationInfo() {}
 /** @type {number} */
ChannelOpenConfirmationInfo.prototype.recipient;
 /** @type {number} */
ChannelOpenConfirmationInfo.prototype.sender;
 /** @type {number} */
ChannelOpenConfirmationInfo.prototype.window;
 /** @type {number} */
ChannelOpenConfirmationInfo.prototype.packetSize;
/**
 * @record
 * @struct
 */
function ChannelOpenFailureInfo() {}
 /** @type {number} */
ChannelOpenFailureInfo.prototype.recipient;
 /** @type {number} */
ChannelOpenFailureInfo.prototype.reasonCode;
 /** @type {string} */
ChannelOpenFailureInfo.prototype.reason;
 /** @type {string} */
ChannelOpenFailureInfo.prototype.description;
/**
 * @record
 * @struct
 */
function X11ChannelInfo() {}
 /** @type {string} */
X11ChannelInfo.prototype.type;
 /** @type {number} */
X11ChannelInfo.prototype.sender;
 /** @type {number} */
X11ChannelInfo.prototype.window;
 /** @type {number} */
X11ChannelInfo.prototype.packetSize;
 /** @type {?} */
X11ChannelInfo.prototype.data;
/**
 * @record
 * @struct
 */
function X11ChannelData() {}
 /** @type {string} */
X11ChannelData.prototype.srcIP;
 /** @type {number} */
X11ChannelData.prototype.srcPort;
/**
 * @record
 * @struct
 */
function ForwardedTcpipChannelInfo() {}
 /** @type {string} */
ForwardedTcpipChannelInfo.prototype.type;
 /** @type {number} */
ForwardedTcpipChannelInfo.prototype.sender;
 /** @type {number} */
ForwardedTcpipChannelInfo.prototype.window;
 /** @type {number} */
ForwardedTcpipChannelInfo.prototype.packetSize;
 /** @type {?} */
ForwardedTcpipChannelInfo.prototype.data;
/**
 * @record
 * @struct
 */
function DirectTcpipChannelInfo() {}
 /** @type {string} */
DirectTcpipChannelInfo.prototype.type;
 /** @type {number} */
DirectTcpipChannelInfo.prototype.sender;
 /** @type {number} */
DirectTcpipChannelInfo.prototype.window;
 /** @type {number} */
DirectTcpipChannelInfo.prototype.packetSize;
 /** @type {?} */
DirectTcpipChannelInfo.prototype.data;
/**
 * @record
 * @struct
 */
function TcpipChannelData() {}
 /** @type {string} */
TcpipChannelData.prototype.srcIP;
 /** @type {number} */
TcpipChannelData.prototype.srcPort;
 /** @type {string} */
TcpipChannelData.prototype.destIP;
 /** @type {number} */
TcpipChannelData.prototype.destPort;
/**
 * @record
 * @struct
 */
function openssh_ForwardedStreamLocalChannelInfo() {}
 /** @type {string} */
openssh_ForwardedStreamLocalChannelInfo.prototype.type;
 /** @type {number} */
openssh_ForwardedStreamLocalChannelInfo.prototype.sender;
 /** @type {number} */
openssh_ForwardedStreamLocalChannelInfo.prototype.window;
 /** @type {number} */
openssh_ForwardedStreamLocalChannelInfo.prototype.packetSize;
 /** @type {?} */
openssh_ForwardedStreamLocalChannelInfo.prototype.data;
/**
 * @record
 * @struct
 */
function openssh_DirectStreamLocalChannelInfo() {}
 /** @type {string} */
openssh_DirectStreamLocalChannelInfo.prototype.type;
 /** @type {number} */
openssh_DirectStreamLocalChannelInfo.prototype.sender;
 /** @type {number} */
openssh_DirectStreamLocalChannelInfo.prototype.window;
 /** @type {number} */
openssh_DirectStreamLocalChannelInfo.prototype.packetSize;
 /** @type {?} */
openssh_DirectStreamLocalChannelInfo.prototype.data;
/**
 * @record
 * @struct
 */
function SocketChannelData() {}
 /** @type {string} */
SocketChannelData.prototype.socketPath;
/**
 * @record
 * @struct
 */
function openssh_AuthAgentChannelInfo() {}
 /** @type {string} */
openssh_AuthAgentChannelInfo.prototype.type;
 /** @type {number} */
openssh_AuthAgentChannelInfo.prototype.sender;
 /** @type {number} */
openssh_AuthAgentChannelInfo.prototype.window;
 /** @type {number} */
openssh_AuthAgentChannelInfo.prototype.packetSize;
/**
 * @record
 * @struct
 */
function SessionChannelInfo() {}
 /** @type {string} */
SessionChannelInfo.prototype.type;
 /** @type {number} */
SessionChannelInfo.prototype.sender;
 /** @type {number} */
SessionChannelInfo.prototype.window;
 /** @type {number} */
SessionChannelInfo.prototype.packetSize;

/** @typedef {?} */
var ChannelOpenInfo;
/**
 * @record
 * @struct
 */
function ExitStatusChannelRequest() {}
 /** @type {string} */
ExitStatusChannelRequest.prototype.request;
 /** @type {number} */
ExitStatusChannelRequest.prototype.recipient;
 /** @type {number} */
ExitStatusChannelRequest.prototype.code;
/**
 * @record
 * @struct
 */
function ExitSignalChannelRequest() {}
 /** @type {string} */
ExitSignalChannelRequest.prototype.request;
 /** @type {number} */
ExitSignalChannelRequest.prototype.recipient;
 /** @type {string} */
ExitSignalChannelRequest.prototype.signal;
 /** @type {boolean} */
ExitSignalChannelRequest.prototype.coredump;
 /** @type {string} */
ExitSignalChannelRequest.prototype.description;
/**
 * @record
 * @struct
 */
function PseudoTtyChannelRequest() {}
 /** @type {string} */
PseudoTtyChannelRequest.prototype.request;
 /** @type {number} */
PseudoTtyChannelRequest.prototype.recipient;
 /** @type {boolean} */
PseudoTtyChannelRequest.prototype.wantReply;
 /** @type {string} */
PseudoTtyChannelRequest.prototype.term;
 /** @type {number} */
PseudoTtyChannelRequest.prototype.cols;
 /** @type {number} */
PseudoTtyChannelRequest.prototype.rows;
 /** @type {number} */
PseudoTtyChannelRequest.prototype.width;
 /** @type {number} */
PseudoTtyChannelRequest.prototype.height;
 /** @type {?} */
PseudoTtyChannelRequest.prototype.modes;
/**
 * @record
 * @struct
 */
function WindowChangeChannelRequest() {}
 /** @type {string} */
WindowChangeChannelRequest.prototype.request;
 /** @type {number} */
WindowChangeChannelRequest.prototype.recipient;
 /** @type {number} */
WindowChangeChannelRequest.prototype.cols;
 /** @type {number} */
WindowChangeChannelRequest.prototype.rows;
 /** @type {number} */
WindowChangeChannelRequest.prototype.width;
 /** @type {number} */
WindowChangeChannelRequest.prototype.height;
/**
 * @record
 * @struct
 */
function X11ChannelRequest() {}
 /** @type {string} */
X11ChannelRequest.prototype.request;
 /** @type {number} */
X11ChannelRequest.prototype.recipient;
 /** @type {boolean} */
X11ChannelRequest.prototype.wantReply;
 /** @type {boolean} */
X11ChannelRequest.prototype.single;
 /** @type {string} */
X11ChannelRequest.prototype.protocol;
 /** @type {string} */
X11ChannelRequest.prototype.cookie;
 /** @type {number} */
X11ChannelRequest.prototype.screen;
/**
 * @record
 * @struct
 */
function EnvChannelRequest() {}
 /** @type {string} */
EnvChannelRequest.prototype.request;
 /** @type {number} */
EnvChannelRequest.prototype.recipient;
 /** @type {boolean} */
EnvChannelRequest.prototype.wantReply;
 /** @type {string} */
EnvChannelRequest.prototype.key;
 /** @type {string} */
EnvChannelRequest.prototype.val;
/**
 * @record
 * @struct
 */
function ShellChannelRequest() {}
 /** @type {string} */
ShellChannelRequest.prototype.request;
 /** @type {number} */
ShellChannelRequest.prototype.recipient;
 /** @type {boolean} */
ShellChannelRequest.prototype.wantReply;
/**
 * @record
 * @struct
 */
function ExecChannelRequest() {}
 /** @type {string} */
ExecChannelRequest.prototype.request;
 /** @type {number} */
ExecChannelRequest.prototype.recipient;
 /** @type {boolean} */
ExecChannelRequest.prototype.wantReply;
 /** @type {string} */
ExecChannelRequest.prototype.command;
/**
 * @record
 * @struct
 */
function SubsystemChannelRequest() {}
 /** @type {string} */
SubsystemChannelRequest.prototype.request;
 /** @type {number} */
SubsystemChannelRequest.prototype.recipient;
 /** @type {boolean} */
SubsystemChannelRequest.prototype.wantReply;
 /** @type {string} */
SubsystemChannelRequest.prototype.subsystem;
/**
 * @record
 * @struct
 */
function SignalChannelRequest() {}
 /** @type {string} */
SignalChannelRequest.prototype.request;
 /** @type {number} */
SignalChannelRequest.prototype.recipient;
 /** @type {string} */
SignalChannelRequest.prototype.signal;
/**
 * @record
 * @struct
 */
function FlowControlChannelRequest() {}
 /** @type {string} */
FlowControlChannelRequest.prototype.request;
 /** @type {number} */
FlowControlChannelRequest.prototype.recipient;
 /** @type {boolean} */
FlowControlChannelRequest.prototype.clientControl;
/**
 * @record
 * @struct
 */
function openssh_AuthAgentChannelRequest() {}
 /** @type {string} */
openssh_AuthAgentChannelRequest.prototype.request;
 /** @type {number} */
openssh_AuthAgentChannelRequest.prototype.recipient;

/** @typedef {?} */
var ChannelRequest;
/**
 * @record
 * @struct
 */
function PublicKeyAuthMethodData() {}
 /** @type {string} */
PublicKeyAuthMethodData.prototype.keyAlgo;
 /** @type {?} */
PublicKeyAuthMethodData.prototype.key;
 /** @type {?} */
PublicKeyAuthMethodData.prototype.signature;
 /** @type {?} */
PublicKeyAuthMethodData.prototype.blob;
/**
 * @record
 * @struct
 */
function HostbasedAuthMethodData() {}
 /** @type {string} */
HostbasedAuthMethodData.prototype.keyAlgo;
 /** @type {?} */
HostbasedAuthMethodData.prototype.key;
 /** @type {?} */
HostbasedAuthMethodData.prototype.signature;
 /** @type {?} */
HostbasedAuthMethodData.prototype.blob;
 /** @type {string} */
HostbasedAuthMethodData.prototype.localHostname;
 /** @type {string} */
HostbasedAuthMethodData.prototype.localUsername;

/** @typedef {(string|?)} */
var AuthMethodData;
/**
 * @record
 * @struct
 */
function TcpipForwardingConfig() {}
 /** @type {string} */
TcpipForwardingConfig.prototype.srcIP;
 /** @type {number} */
TcpipForwardingConfig.prototype.srcPort;
 /** @type {string} */
TcpipForwardingConfig.prototype.destIP;
 /** @type {number} */
TcpipForwardingConfig.prototype.destPort;
/**
 * @record
 * @struct
 */
function X11ForwardingConfig() {}
 /** @type {boolean} */
X11ForwardingConfig.prototype.single;
 /** @type {string} */
X11ForwardingConfig.prototype.protocol;
 /** @type {string} */
X11ForwardingConfig.prototype.cookie;
 /** @type {number} */
X11ForwardingConfig.prototype.screen;
/**
 * @record
 * @struct
 */
function SocketForwardingConfig() {}
 /** @type {string} */
SocketForwardingConfig.prototype.socketPath;
/**
 * @record
 * @struct
 */
function Prompt() {}
 /** @type {string} */
Prompt.prototype.prompt;
 /** @type {boolean} */
Prompt.prototype.echo;
/**
 * @record
 * @struct
 */
function ForwardedTcpip() {}
 /** @type {string} */
ForwardedTcpip.prototype.bindAddr;
 /** @type {number} */
ForwardedTcpip.prototype.bindPort;
 /** @type {string} */
ForwardedTcpip.prototype.remoteAddr;
 /** @type {number} */
ForwardedTcpip.prototype.remotePort;
/**
 * @record
 * @struct
 */
function ForwardedX11() {}
 /** @type {string} */
ForwardedX11.prototype.originAddr;
 /** @type {number} */
ForwardedX11.prototype.originPort;
/**
 * @record
 * @struct
 */
function ForwardedSocket() {}
 /** @type {string} */
ForwardedSocket.prototype.socketPath;

/**
 * @constructor
 * @struct
 * Creates and returns a new SFTPStream instance.
 * Creates and returns a new SFTPStream instance.
 * @param {string|?=} remoteIdentRaw_or_cfg
 * @param {string=} remoteIdentRaw
 */
function SFTPStream(remoteIdentRaw_or_cfg, remoteIdentRaw) {}

/**
 * Converts string flags (e.g. `'r'`, `'a+'`, etc.) to the appropriate
 * `SFTPStream.OPEN_MODE` flag mask.
 * 
 * Returns `null` if conversion failed.
 * @param {string} flagsStr
 * @return {number}
 */
SFTPStream.stringToFlags = function(flagsStr) {};

/**
 * Converts flag mask (e.g. number containing `SFTPStream.OPEN_MODE` values) to the
 * appropriate string value.
 * 
 * Returns `null` if conversion failed.
 * @param {number} flagsMask
 * @return {string}
 */
SFTPStream.flagsToString = function(flagsMask) {};

/**
 * (Client-only)
 * Downloads a file at `remotePath` to `localPath` using parallel reads for faster throughput.
 * (Client-only)
 * Downloads a file at `remotePath` to `localPath` using parallel reads for faster throughput.
 * @param {string} remotePath
 * @param {string} localPath
 * @param {?} options_or_callback
 * @param {?=} callback
 * @return {void}
 */
SFTPStream.prototype.fastGet = function(remotePath, localPath, options_or_callback, callback) {};

/**
 * (Client-only)
 * Uploads a file from `localPath` to `remotePath` using parallel reads for faster throughput.
 * (Client-only)
 * Uploads a file from `localPath` to `remotePath` using parallel reads for faster throughput.
 * @param {string} localPath
 * @param {string} remotePath
 * @param {?} options_or_callback
 * @param {?=} callback
 * @return {void}
 */
SFTPStream.prototype.fastPut = function(localPath, remotePath, options_or_callback, callback) {};

/**
 * (Client-only)
 * Returns a new readable stream for `path`.
 * @param {string} path
 * @param {?=} options
 * @return {!internal.Readable}
 */
SFTPStream.prototype.createReadStream = function(path, options) {};

/**
 * (Client-only)
 * Returns a new writable stream for `path`.
 * @param {string} path
 * @param {?=} options
 * @return {!internal.Writable}
 */
SFTPStream.prototype.createWriteStream = function(path, options) {};

/**
 * (Client-only)
 * Opens a file `filename` for `mode` with optional `attributes`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * (Client-only)
 * Opens a file `filename` for `mode`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} filename
 * @param {string} mode
 * @param {?} attributes_or_callback
 * @param {?=} callback
 * @return {boolean}
 */
SFTPStream.prototype.open = function(filename, mode, attributes_or_callback, callback) {};

/**
 * (Client-only)
 * Closes the resource associated with `handle` given by `open()` or `opendir()`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.close = function(handle, callback) {};

/**
 * (Client-only)
 * Reads `length` bytes from the resource associated with `handle` starting at `position`
 * and stores the bytes in `buffer` starting at `offset`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} buffer
 * @param {number} offset
 * @param {number} length
 * @param {number} position
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.readData = function(handle, buffer, offset, length, position, callback) {};

/**
 * (Client-only)
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} buffer
 * @param {number} offset
 * @param {number} length
 * @param {number} position
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.writeData = function(handle, buffer, offset, length, position, callback) {};

/**
 * (Client-only)
 * Retrieves attributes for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.fstat = function(handle, callback) {};

/**
 * (Client-only)
 * Sets the attributes defined in `attributes` for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} attributes
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.fsetstat = function(handle, attributes, callback) {};

/**
 * (Client-only)
 * Sets the access time and modified time for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {(number|!Date)} atime
 * @param {(number|!Date)} mtime
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.futimes = function(handle, atime, mtime, callback) {};

/**
 * (Client-only)
 * Sets the owner for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {number} uid
 * @param {number} gid
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.fchown = function(handle, uid, gid, callback) {};

/**
 * (Client-only)
 * Sets the mode for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {(string|number)} mode
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.fchmod = function(handle, mode, callback) {};

/**
 * (Client-only)
 * Opens a directory `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.opendir = function(path, callback) {};

/**
 * (Client-only)
 * Retrieves a directory listing.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {(string|?)} location
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.readdir = function(location, callback) {};

/**
 * (Client-only)
 * Removes the file/symlink at `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.unlink = function(path, callback) {};

/**
 * (Client-only)
 * Renames/moves `srcPath` to `destPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} srcPath
 * @param {string} destPath
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.rename = function(srcPath, destPath, callback) {};

/**
 * (Client-only)
 * Creates a new directory `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * (Client-only)
 * Creates a new directory `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} attributes_or_callback
 * @param {?=} callback
 * @return {boolean}
 */
SFTPStream.prototype.mkdir = function(path, attributes_or_callback, callback) {};

/**
 * (Client-only)
 * Removes the directory at `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.rmdir = function(path, callback) {};

/**
 * (Client-only)
 * Retrieves attributes for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.stat = function(path, callback) {};

/**
 * (Client-only)
 * Retrieves attributes for `path`. If `path` is a symlink, the link itself is stat'ed
 * instead of the resource it refers to.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.lstat = function(path, callback) {};

/**
 * (Client-only)
 * Sets the attributes defined in `attributes` for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} attributes
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.setstat = function(path, attributes, callback) {};

/**
 * (Client-only)
 * Sets the access time and modified time for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {(number|!Date)} atime
 * @param {(number|!Date)} mtime
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.utimes = function(path, atime, mtime, callback) {};

/**
 * (Client-only)
 * Sets the owner for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {number} uid
 * @param {number} gid
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.chown = function(path, uid, gid, callback) {};

/**
 * (Client-only)
 * Sets the mode for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {(string|number)} mode
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.chmod = function(path, mode, callback) {};

/**
 * (Client-only)
 * Retrieves the target for a symlink at `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.readlink = function(path, callback) {};

/**
 * (Client-only)
 * Creates a symlink at `linkPath` to `targetPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} targetPath
 * @param {string} linkPath
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.symlink = function(targetPath, linkPath, callback) {};

/**
 * (Client-only)
 * Resolves `path` to an absolute path.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.realpath = function(path, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX rename(3) from `srcPath` to `destPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} srcPath
 * @param {string} destPath
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.ext_openssh_rename = function(srcPath, destPath, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX statvfs(2) on `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.ext_openssh_statvfs = function(path, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX fstatvfs(2) on open handle `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.ext_openssh_fstatvfs = function(handle, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX link(2) to create a hard link to `targetPath` at `linkPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} targetPath
 * @param {string} linkPath
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.ext_openssh_hardlink = function(targetPath, linkPath, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX fsync(3) on the open handle `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} callback
 * @return {boolean}
 */
SFTPStream.prototype.ext_openssh_fsync = function(handle, callback) {};

/**
 * (Server-only)
 * Sends a status response for the request identified by `id`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} reqID
 * @param {number} statusCode
 * @param {string=} message
 * @return {boolean}
 */
SFTPStream.prototype.status = function(reqID, statusCode, message) {};

/**
 * (Server-only)
 * Sends a handle response for the request identified by `id`.
 * 
 * @param {number} reqID
 * @param {?} handle A handle must be less than 256 bytes and is an opaque value that could
 *          merely contain the value of a backing file descriptor or some other unique,
 *          custom value.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @return {boolean}
 */
SFTPStream.prototype.handle = function(reqID, handle) {};

/**
 * (Server-only)
 * Sends a data response for the request identified by `id`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} reqID
 * @param {(string|?)} data
 * @param {string=} encoding
 * @return {boolean}
 */
SFTPStream.prototype.data = function(reqID, data, encoding) {};

/**
 * (Server-only)
 * Sends a name response for the request identified by `id`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} reqID
 * @param {!Array<?>} names
 * @return {boolean}
 */
SFTPStream.prototype.name = function(reqID, names) {};

/**
 * (Server-only)
 * Sends an attrs response for the request identified by `id`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} reqID
 * @param {?} attrs
 * @return {boolean}
 */
SFTPStream.prototype.attrs = function(reqID, attrs) {};

/**
 * (Client/Server)
 * Emitted after initial protocol version check has passed.
 * (Server-only)
 * Emitted when the client requests to open a file.
 * 
 * Respond with:
 * * `handle()` - This indicates a successful opening of the file and passes the given handle back to the client to use to refer to this open file for future operations (e.g. reading, writing, closing).
 * * `status()` - Use this to indicate a failure to open the requested file.
 * (Server-only)
 * Emitted when the client requests to read data from a file handle.
 * 
 * Respond with:
 * * `data()` - Use this to send the requested chunk of data back to the client. The amount of data sent is allowed to be less than the `length` requested.
 * * `status()` - Use this to indicate either end of file (`STATUS_CODE.EOF`) has been reached (`offset` is past the end of the file) or if an error occurred while reading the requested part of the file.
 * (Server-only)
 * Emitted when the client requests to write data to a file handle.
 * 
 * Respond with:
 * * `status()` - Use this to indicate success/failure of the write to the file.
 * (Server-only)
 * Emitted when the client requests attributes for the resource associated with `handle`.
 * 
 * Respond with:
 * * `attrs()` - Use this to send the attributes for the requested file/directory back to the client.
 * * `status()` - Use this to indicate an error occurred while accessing the file/directory.
 * (Server-only)
 * Emitted when the client requests to write attributes for the resource associated with `handle`.
 * 
 * Respond with:
 * * `status()` - Use this to indicates success/failure of the setting of the given file/directory attributes.
 * (Server-only)
 * Emitted when the client requests to close a handle.
 * 
 * Respond with:
 * * `status()` - Use this to indicate success (`STATUS_CODE.OK`) or failure of the closing of the file identified by `handle`.
 * (Server-only)
 * Emitted when the client requests to open a directory.
 * 
 * Respond with:
 * * `handle()` - This indicates a successful opening of the directory and passes the given handle back to the client to use to refer to this open directory for future operations (e.g. reading directory contents, closing).
 * * `status()` - Use this to indicate a failure to open the requested directory.
 * (Server-only)
 * Emitted when the client requests to read the contents of a directory.
 * 
 * Respond with:
 * * `name()` - Use this to send one or more directory listings for the open directory back to the client.
 * * `status()` - Use this to indicate either end of directory contents (`STATUS_CODE.EOF`) or if an error occurred while reading the directory contents.
 * (Server-only)
 * Emitted when the client requests attributes for a path. If `path` is a symlink, the
 * link itself should stat'ed instead of the resource it refers to.
 * 
 * Respond with:
 * * `attrs()` - Use this to send the attributes for the requested file/directory back to the client.
 * * `status()` - Use this to indicate an error occurred while accessing the file/directory.
 * (Server-only)
 * Emitted when the client requests attributes for a path.
 * 
 * Respond with:
 * * `attrs()` - Use this to send the attributes for the requested file/directory back to the client.
 * * `status()` - Use this to indicate an error occurred while accessing the file/directory.
 * (Server-only)
 * Emitted when the client requests to delete a file or symlink.
 * 
 * Respond with:
 * * `status()` - Use this to indicate success/failure of the removal of the file at `path`.
 * (Server-only)
 * Emitted when the client requests to remove a directory.
 * 
 * Respond with:
 * * `status()` - Use this to indicate success/failure of the removal of the directory at `path`.
 * (Server-only)
 * Emitted when the client requests the absolute path for a path.
 * 
 * Respond with:
 * * `name()` - Use this to respond with a normalized version of `path`. No file/directory attributes are required to be sent in this response.
 * * `status()` - Use this to indicate a failure in normalizing `path`.
 * (Server-only)
 * Emitted when the client requests the target for a symlink at `path`.
 * 
 * Respond with:
 * * `name()` - Use this to respond with the target of the symlink at `path`. No file/directory attributes are required to be sent in this response.
 * * `status()` - Use this to indicate a failure in reading the symlink at `path`.
 * (Server-only)
 * Emitted when the client requests to set the attributes defined in `attrs` for `path`.
 * 
 * Respond with:
 * * `status()` - Use this to indicates success/failure of the setting of the given file/directory attributes.
 * (Server-only)
 * Emitted when the client requests a new directory be created.
 * 
 * Respond with:
 * * `status()` - Use this to indicate success/failure of the creation of the directory at `path`.
 * (Server-only)
 * Emitted when the client requests a path be renamed.
 * 
 * Respond with:
 * * `status()` - Use this to indicate success/failure of the renaming of the file/directory at `oldPath` to `newPath`.
 * (Server-only)
 * Emitted when the client requests a new symlink be created for a path.
 * 
 * Respond with:
 * * `status()` - Use this to indicate success/failure of the symlink creation.
 * Emitted when the socket has disconnected.
 * Emitted when the client socket was closed.
 * Emitted when more requests/data can be sent to the stream.
 * Emitted when an error occurred.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
SFTPStream.prototype.on = function(event, listener) {};

/** @const */
SFTPStream.STATUS_CODE = {};
/** @const {number} */
SFTPStream.STATUS_CODE.OK;
/** @const {number} */
SFTPStream.STATUS_CODE.EOF;
/** @const {number} */
SFTPStream.STATUS_CODE.NO_SUCH_FILE;
/** @const {number} */
SFTPStream.STATUS_CODE.PERMISSION_DENIED;
/** @const {number} */
SFTPStream.STATUS_CODE.FAILURE;
/** @const {number} */
SFTPStream.STATUS_CODE.BAD_MESSAGE;
/** @const {number} */
SFTPStream.STATUS_CODE.NO_CONNECTION;
/** @const {number} */
SFTPStream.STATUS_CODE.CONNECTION_LOST;
/** @const {number} */
SFTPStream.STATUS_CODE.OP_UNSUPPORTED;

/** @const */
SFTPStream.OPEN_MODE = {};
/** @const {number} */
SFTPStream.OPEN_MODE.READ;
/** @const {number} */
SFTPStream.OPEN_MODE.WRITE;
/** @const {number} */
SFTPStream.OPEN_MODE.APPEND;
/** @const {number} */
SFTPStream.OPEN_MODE.CREAT;
/** @const {number} */
SFTPStream.OPEN_MODE.TRUNC;
/** @const {number} */
SFTPStream.OPEN_MODE.EXCL;
/**
 * @record
 * @struct
 */
function SFTPStreamConfig() {}
 /** @type {boolean} */
SFTPStreamConfig.prototype.server;
 /** @type {number} */
SFTPStreamConfig.prototype.highWaterMark;
 /** @type {?} */
SFTPStreamConfig.prototype.debug;
/**
 * @record
 * @struct
 */
function TransferOptions() {}
 /** @type {number} */
TransferOptions.prototype.concurrency;
 /** @type {number} */
TransferOptions.prototype.chunkSize;
 /** @type {?} */
TransferOptions.prototype.step;
/**
 * @record
 * @struct
 */
function ReadStreamOptions() {}
 /** @type {string} */
ReadStreamOptions.prototype.flags;
 /** @type {string} */
ReadStreamOptions.prototype.encoding;
 /** @type {?} */
ReadStreamOptions.prototype.handle;
 /** @type {number} */
ReadStreamOptions.prototype.mode;
 /** @type {boolean} */
ReadStreamOptions.prototype.autoClose;
 /** @type {number} */
ReadStreamOptions.prototype.start;
 /** @type {number} */
ReadStreamOptions.prototype.end;
/**
 * @record
 * @struct
 */
function WriteStreamOptions() {}
 /** @type {string} */
WriteStreamOptions.prototype.flags;
 /** @type {string} */
WriteStreamOptions.prototype.encoding;
 /** @type {number} */
WriteStreamOptions.prototype.mode;
/**
 * @record
 * @struct
 */
function FileEntry() {}
 /** @type {string} */
FileEntry.prototype.filename;
 /** @type {string} */
FileEntry.prototype.longname;
 /** @type {?} */
FileEntry.prototype.attrs;
/**
 * @record
 * @struct
 */
function InputAttributes() {}
 /** @type {(string|number)} */
InputAttributes.prototype.mode;
 /** @type {number} */
InputAttributes.prototype.uid;
 /** @type {number} */
InputAttributes.prototype.gid;
 /** @type {number} */
InputAttributes.prototype.size;
 /** @type {(number|!Date)} */
InputAttributes.prototype.atime;
 /** @type {(number|!Date)} */
InputAttributes.prototype.mtime;
/**
 * @record
 * @struct
 */
function Attributes() {}
 /** @type {number} */
Attributes.prototype.mode;
 /** @type {number} */
Attributes.prototype.uid;
 /** @type {number} */
Attributes.prototype.gid;
 /** @type {number} */
Attributes.prototype.size;
 /** @type {number} */
Attributes.prototype.atime;
 /** @type {number} */
Attributes.prototype.mtime;
/**
 * @extends {Attributes}
 * @record
 * @struct
 */
function Stats() {}

/**
 * @return {boolean}
 */
Stats.prototype.isDirectory = function() {};

/**
 * @return {boolean}
 */
Stats.prototype.isFile = function() {};

/**
 * @return {boolean}
 */
Stats.prototype.isBlockDevice = function() {};

/**
 * @return {boolean}
 */
Stats.prototype.isCharacterDevice = function() {};

/**
 * @return {boolean}
 */
Stats.prototype.isSymbolicLink = function() {};

/**
 * @return {boolean}
 */
Stats.prototype.isFIFO = function() {};

/**
 * @return {boolean}
 */
Stats.prototype.isSocket = function() {};
/** @const */
var utils = {};

/**
 * @param {(string|?)} keyData
 * @return {(?|!Error)}
 */
utils.parseKey = function(keyData) {};

/**
 * @param {?} privKeyInfo
 * @return {?}
 */
utils.genPublicKey = function(privKeyInfo) {};

/**
 * @param {?} privKeyInfo
 * @param {string} passphrase
 * @return {void}
 */
utils.decryptKey = function(privKeyInfo, passphrase) {};
/**
 * @record
 * @struct
 */
function ParsedKey() {}
 /** @type {string} */
ParsedKey.prototype.fulltype;
 /** @type {string} */
ParsedKey.prototype.type;
 /** @type {string} */
ParsedKey.prototype.extra;
 /** @type {string} */
ParsedKey.prototype.comment;
 /** @type {string} */
ParsedKey.prototype.encryption;
 /** @type {?} */
ParsedKey.prototype.private;
 /** @type {?} */
ParsedKey.prototype.privateOrig;
 /** @type {?} */
ParsedKey.prototype.public;
 /** @type {?} */
ParsedKey.prototype.publicOrig;
 /** @type {boolean} */
ParsedKey.prototype.ppk;
 /** @type {string} */
ParsedKey.prototype.privateMAC;
