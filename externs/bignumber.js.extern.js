/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bignumber.js/index.d.ts:
 /** @type {!BigNumber.BigNumberStatic} */
var BigNumber;

/* TODO: NamespaceExportDeclaration in  */

/* TODO: ExportAssignment in  */
/**
 * @record
 * @struct
 */
BigNumber.FormatConfig = function() {};
 /** @type {string} */
BigNumber.FormatConfig.prototype.decimalSeparator;
 /** @type {string} */
BigNumber.FormatConfig.prototype.groupSeparator;
 /** @type {number} */
BigNumber.FormatConfig.prototype.groupSize;
 /** @type {number} */
BigNumber.FormatConfig.prototype.secondaryGroupSize;
 /** @type {string} */
BigNumber.FormatConfig.prototype.fractionGroupSeparator;
 /** @type {number} */
BigNumber.FormatConfig.prototype.fractionGroupSize;
/**
 * @record
 * @struct
 */
BigNumber.BigNumberConfig = function() {};
 /** @type {number} */
BigNumber.BigNumberConfig.prototype.DECIMAL_PLACES;
 /** @type {number} */
BigNumber.BigNumberConfig.prototype.ROUNDING_MODE;
 /** @type {(number|!Array<number>)} */
BigNumber.BigNumberConfig.prototype.EXPONENTIAL_AT;
 /** @type {(number|!Array<number>)} */
BigNumber.BigNumberConfig.prototype.RANGE;
 /** @type {(boolean|number)} */
BigNumber.BigNumberConfig.prototype.ERRORS;
 /** @type {(boolean|number)} */
BigNumber.BigNumberConfig.prototype.CRYPTO;
 /** @type {number} */
BigNumber.BigNumberConfig.prototype.MODULO_MODE;
 /** @type {number} */
BigNumber.BigNumberConfig.prototype.POW_PRECISION;
 /** @type {?} */
BigNumber.BigNumberConfig.prototype.FORMAT;

/** @typedef {(string|number|!BigNumber.BigNumber)} */
BigNumber.NumberLike;

/** @typedef {number} */
BigNumber.RoundingMode;

/** @typedef {number} */
BigNumber.ModuloMode;
/**
 * @record
 * @struct
 */
BigNumber.BigNumberStatic = function() {};

/* TODO: CallSignature: BigNumber */

/* TODO: ConstructSignature: BigNumber */
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.ROUND_UP;
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.ROUND_DOWN;
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.ROUND_CEIL;
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.ROUND_FLOOR;
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.ROUND_HALF_UP;
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.ROUND_HALF_DOWN;
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.ROUND_HALF_EVEN;
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.ROUND_HALF_CEIL;
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.ROUND_HALF_FLOOR;
 /** @type {number} */
BigNumber.BigNumberStatic.prototype.EUCLID;

/**
 * Returns a new independent BigNumber constructor with configuration as described by obj, or with the default configuration if obj is null or undefined.
 * @param {?=} obj
 * @return {!BigNumber.BigNumberStatic}
 */
BigNumber.BigNumberStatic.prototype.another = function(obj) {};

/**
 * Configures the settings for this particular BigNumber constructor.
 * 
 * Configures the settings for this particular BigNumber constructor.
 * @param {?|number=} obj_or_DECIMAL_PLACES
 * @param {number=} ROUNDING_MODE
 * @param {(number|!Array<number>)=} EXPONENTIAL_AT
 * @param {(number|!Array<number>)=} RANGE
 * @param {(boolean|number)=} ERRORS
 * @param {(boolean|number)=} CRYPTO
 * @param {number=} MODULO_MODE
 * @param {number=} POW_PRECISION
 * @return {!BigNumber.BigNumberConfig}
 */
BigNumber.BigNumberStatic.prototype.config = function(obj_or_DECIMAL_PLACES, ROUNDING_MODE, EXPONENTIAL_AT, RANGE, ERRORS, CRYPTO, MODULO_MODE, POW_PRECISION) {};

/**
 * Configures the settings for this particular BigNumber constructor.
 * Configures the settings for this particular BigNumber constructor.
 * @param {?|number=} obj_or_DECIMAL_PLACES
 * @param {number=} ROUNDING_MODE
 * @param {(number|!Array<number>)=} EXPONENTIAL_AT
 * @param {(number|!Array<number>)=} RANGE
 * @param {(boolean|number)=} ERRORS
 * @param {(boolean|number)=} CRYPTO
 * @param {number=} MODULO_MODE
 * @param {number=} POW_PRECISION
 * @return {!BigNumber.BigNumberConfig}
 */
BigNumber.BigNumberStatic.prototype.set = function(obj_or_DECIMAL_PLACES, ROUNDING_MODE, EXPONENTIAL_AT, RANGE, ERRORS, CRYPTO, MODULO_MODE, POW_PRECISION) {};

/**
 * Returns a BigNumber whose value is the maximum of `args`.
 * Returns a BigNumber whose value is the maximum of `args`.
 * @param {...(string|number|!BigNumber.BigNumber)|!Array<(string|number|!BigNumber.BigNumber)>} args
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumberStatic.prototype.max = function(args) {};

/**
 * Returns a BigNumber whose value is the minimum of `args`.
 * Returns a BigNumber whose value is the minimum of `args`.
 * @param {...(string|number|!BigNumber.BigNumber)|!Array<(string|number|!BigNumber.BigNumber)>} args
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumberStatic.prototype.min = function(args) {};

/**
 * Returns a new BigNumber with a pseudo-random value equal to or greater than `0` and less than `1`.
 * 
 * The return value will have `dp` decimal places (or less if trailing zeros are produced).
 * If `dp` is omitted then the number of decimal places will default to the current `DECIMAL_PLACES` setting.
 * 
 * Depending on the value of this BigNumber constructor's `CRYPTO` setting and the support for the `crypto` object in the host environment,
 * the random digits of the return value are generated by either
 * `Math.random` (fastest),
 * `crypto.getRandomValues` (Web Cryptography API in recent browsers)
 * or `crypto.randomBytes` (Node.js).
 * 
 * If `CRYPTO` is `true`, i.e. one of the `crypto` methods is to be used,
 * the value of a returned BigNumber should be cryptographically-secure and statistically indistinguishable from a random value.
 * @param {number=} dp
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumberStatic.prototype.random = function(dp) {};
/**
 * @record
 * @struct
 */
BigNumber.BigNumber = function() {};
 /** @type {!Array<number>} */
BigNumber.BigNumber.prototype.c;
 /** @type {number} */
BigNumber.BigNumber.prototype.e;
 /** @type {number} */
BigNumber.BigNumber.prototype.s;
 /** @type {boolean} */
BigNumber.BigNumber.prototype.isBigNumber;

/**
 * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this BigNumber.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.absoluteValue = function() {};

/**
 * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this BigNumber.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.abs = function() {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber rounded to a whole number in the direction of positive Infinity.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.ceil = function() {};

/**
 * Returns
 * 
 *  `1` if the value of this BigNumber is greater than the value of `n`
 * 
 * `-1` if the value of this BigNumber is less than the value of `n`
 * 
 * `0` if this BigNumber and `n` have the same value
 * 
 * `null` if the value of either this BigNumber or `n` is `NaN`
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {number}
 */
BigNumber.BigNumber.prototype.comparedTo = function(n, base) {};

/**
 * Returns
 * 
 *  `1` if the value of this BigNumber is greater than the value of `n`
 * 
 * `-1` if the value of this BigNumber is less than the value of `n`
 * 
 * `0` if this BigNumber and `n` have the same value
 * 
 * `null` if the value of either this BigNumber or `n` is `NaN`
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {number}
 */
BigNumber.BigNumber.prototype.cmp = function(n, base) {};

/**
 * Return the number of decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is `±Infinity` or `NaN`.
 * @return {number}
 */
BigNumber.BigNumber.prototype.decimalPlaces = function() {};

/**
 * Return the number of decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is `±Infinity` or `NaN`.
 * @return {number}
 */
BigNumber.BigNumber.prototype.dp = function() {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` configuration.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.dividedBy = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` configuration.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.div = function(n, base) {};

/**
 * Return a BigNumber whose value is the integer part of dividing the value of this BigNumber by `n`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.dividedToIntegerBy = function(n, base) {};

/**
 * Return a BigNumber whose value is the integer part of dividing the value of this BigNumber by `n`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.divToInt = function(n, base) {};

/**
 * Returns `true` if the value of this BigNumber equals the value of `n`, otherwise returns `false`.
 * 
 * As with JavaScript, `NaN` does not equal `NaN`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.equals = function(n, base) {};

/**
 * Returns `true` if the value of this BigNumber equals the value of `n`, otherwise returns `false`.
 * 
 * As with JavaScript, `NaN` does not equal `NaN`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.eq = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber rounded to a whole number in the direction of negative `Infinity`.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.floor = function() {};

/**
 * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise returns `false`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.greaterThan = function(n, base) {};

/**
 * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise returns `false`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.gt = function(n, base) {};

/**
 * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`, otherwise returns `false`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.greaterThanOrEqualTo = function(n, base) {};

/**
 * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`, otherwise returns `false`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.gte = function(n, base) {};

/**
 * Returns `true` if the value of this BigNumber is a finite number, otherwise returns `false`.
 * 
 * The only possible non-finite values of a BigNumber are `NaN`, `Infinity` and `-Infinity`.
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.isFinite = function() {};

/**
 * Returns `true` if the value of this BigNumber is a whole number, otherwise returns `false`.
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.isInteger = function() {};

/**
 * Returns `true` if the value of this BigNumber is a whole number, otherwise returns `false`.
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.isInt = function() {};

/**
 * Returns `true` if the value of this BigNumber is NaN, otherwise returns `false`.
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.isNaN = function() {};

/**
 * Returns `true` if the value of this BigNumber is negative, otherwise returns `false`.
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.isNegative = function() {};

/**
 * Returns `true` if the value of this BigNumber is negative, otherwise returns `false`.
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.isNeg = function() {};

/**
 * Returns `true` if the value of this BigNumber is zero or minus zero, otherwise returns `false`.
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.isZero = function() {};

/**
 * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns `false`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.lessThan = function(n, base) {};

/**
 * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns `false`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.lt = function(n, base) {};

/**
 * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`, otherwise returns
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.lessThanOrEqualTo = function(n, base) {};

/**
 * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`, otherwise returns
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {boolean}
 */
BigNumber.BigNumber.prototype.lte = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber minus `n`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.minus = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber minus `n`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.sub = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer remainder of dividing this BigNumber by `n`.
 * 
 * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE` setting of this BigNumber constructor.
 * If it is `1` (default value), the result will have the same sign as this BigNumber,
 * and it will match that of Javascript's `%` operator (within the limits of double precision) and BigDecimal's `remainder` method.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.modulo = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer remainder of dividing this BigNumber by `n`.
 * 
 * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE` setting of this BigNumber constructor.
 * If it is `1` (default value), the result will have the same sign as this BigNumber,
 * and it will match that of Javascript's `%` operator (within the limits of double precision) and BigDecimal's `remainder` method.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.mod = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber negated, i.e. multiplied by `-1`.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.negated = function() {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber negated, i.e. multiplied by `-1`.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.neg = function() {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber plus `n`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.plus = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber plus `n`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.add = function(n, base) {};

/**
 * Returns the number of significant digits of the value of this BigNumber.
 * 
 * If `z` is `true` or `1` then any trailing zeros of the integer part of a number are counted as significant digits, otherwise they are not.
 * @param {(boolean|number)=} z
 * @return {number}
 */
BigNumber.BigNumber.prototype.precision = function(z) {};

/**
 * Returns the number of significant digits of the value of this BigNumber.
 * 
 * If `z` is `true` or `1` then any trailing zeros of the integer part of a number are counted as significant digits, otherwise they are not.
 * @param {(boolean|number)=} z
 * @return {number}
 */
BigNumber.BigNumber.prototype.sd = function(z) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode `rm` to a maximum of `dp` decimal places.
 * 
 * If `dp` is omitted, or is `null` or `undefined`, the return value is `n` rounded to a whole number.
 * 
 * If `rm` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.
 * @param {number=} dp
 * @param {number=} rm
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.round = function(dp, rm) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber shifted `n` places.
 * 
 * The shift is of the decimal point, i.e. of powers of ten, and is to the left if `n` is negative or to the right if `n` is positive.
 * @param {number} n
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.shift = function(n) {};

/**
 * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` configuration.
 * 
 * The return value will be correctly rounded, i.e. rounded as if the result was first calculated to an infinite number of correct digits before rounding.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.squareRoot = function() {};

/**
 * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` configuration.
 * 
 * The return value will be correctly rounded, i.e. rounded as if the result was first calculated to an infinite number of correct digits before rounding.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.sqrt = function() {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber times `n`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.times = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber times `n`.
 * @param {(string|number|!BigNumber.BigNumber)} n
 * @param {number=} base
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.mul = function(n, base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber rounded to `sd` significant digits using rounding mode `rm`.
 * 
 * If `sd` is omitted or is `null` or `undefined`, the return value will not be rounded.
 * 
 * If `rm` is omitted or is `null` or `undefined`, ROUNDING_MODE will be used.
 * @param {number=} sd
 * @param {number=} rm
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.toDigits = function(sd, rm) {};

/**
 * Returns a string representing the value of this BigNumber in exponential notation rounded using rounding mode `rm` to `dp` decimal places,
 * i.e with one digit before the decimal point and `dp` digits after it.
 * 
 * If the value of this BigNumber in exponential notation has fewer than `dp` fraction digits, the return value will be appended with zeros accordingly.
 * 
 * If `dp` is omitted, or is `null` or `undefined`, the number of digits after the decimal point defaults to the minimum number of digits necessary to represent the value exactly.
 * 
 * If `rm` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.
 * @param {number=} dp
 * @param {number=} rm
 * @return {string}
 */
BigNumber.BigNumber.prototype.toExponential = function(dp, rm) {};

/**
 * Returns a string representing the value of this BigNumber in normal (fixed-point) notation rounded to `dp` decimal places using rounding mode `rm`.
 * 
 * If the value of this BigNumber in normal notation has fewer than `dp` fraction digits, the return value will be appended with zeros accordingly.
 * 
 * Unlike `Number.prototype.toFixed`, which returns exponential notation if a number is greater or equal to `10e21`, this method will always return normal notation.
 * 
 * If `dp` is omitted or is `null` or `undefined`, the return value will be unrounded and in normal notation.
 * This is also unlike `Number.prototype.toFixed`, which returns the value to zero decimal places.
 * It is useful when fixed-point notation is required and the current `EXPONENTIAL_AT` setting causes `toString` to return exponential notation.
 * 
 * If `rm` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.
 * @param {number=} dp
 * @param {number=} rm
 * @return {string}
 */
BigNumber.BigNumber.prototype.toFixed = function(dp, rm) {};

/**
 * Returns a string representing the value of this BigNumber in normal (fixed-point) notation rounded to `dp` decimal places using rounding mode `rm`,
 *  and formatted according to the properties of the `FORMAT` object.
 * 
 * If `dp` is omitted or is `null` or `undefined`, then the return value is not rounded to a fixed number of decimal places.
 * 
 * If `rm` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.
 * @param {number=} dp
 * @param {number=} rm
 * @return {string}
 */
BigNumber.BigNumber.prototype.toFormat = function(dp, rm) {};

/**
 * Returns a string array representing the value of this BigNumber as a simple fraction with an integer numerator and an integer denominator.
 * The denominator will be a positive non-zero value less than or equal to `max`.
 * 
 * If a maximum denominator, `max`, is not specified, or is `null` or `undefined`, the denominator will be the lowest value necessary to represent the number exactly.
 * @param {(string|number|!BigNumber.BigNumber)=} max
 * @return {!Array<?>}
 */
BigNumber.BigNumber.prototype.toFraction = function(max) {};

/**
 * As `valueOf`.
 * @return {string}
 */
BigNumber.BigNumber.prototype.toJSON = function() {};

/**
 * Returns the value of this BigNumber as a JavaScript number primitive.
 * 
 * Type coercion with, for example, the unary plus operator will also work, except that a BigNumber with the value minus zero will be converted to positive zero.
 * @return {number}
 */
BigNumber.BigNumber.prototype.toNumber = function() {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber raised to the power `n`, and optionally modulo a modulus `m`.
 * 
 * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` configuration.
 * @param {number} n
 * @param {(string|number|!BigNumber.BigNumber)=} m
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.toPower = function(n, m) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber raised to the power `n`, and optionally modulo a modulus `m`.
 * 
 * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` configuration.
 * @param {number} n
 * @param {(string|number|!BigNumber.BigNumber)=} m
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.pow = function(n, m) {};

/**
 * Returns a string representing the value of this BigNumber rounded to `sd` significant digits using rounding mode `rm`.
 * 
 * If `sd` is less than the number of digits necessary to represent the integer part of the value in normal (fixed-point) notation, then exponential notation is used.
 * 
 * If `sd` is omitted, or is `null` or `undefined`, then the return value is the same as `n.toString()`.
 * 
 * If `rm` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.
 * @param {number=} sd
 * @param {number=} rm
 * @return {string}
 */
BigNumber.BigNumber.prototype.toPrecision = function(sd, rm) {};

/**
 * Returns a string representing the value of this BigNumber in the specified base, or base `10` if `base` is omitted or is `null` or `undefined`.
 * @param {number=} base
 * @return {string}
 */
BigNumber.BigNumber.prototype.toString = function(base) {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber truncated to a whole number.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.truncated = function() {};

/**
 * Returns a BigNumber whose value is the value of this BigNumber truncated to a whole number.
 * @return {!BigNumber.BigNumber}
 */
BigNumber.BigNumber.prototype.trunc = function() {};

/**
 * As `toString`, but does not accept a base argument and includes the minus sign for negative zero.
 * @return {string}
 */
BigNumber.BigNumber.prototype.valueOf = function() {};
