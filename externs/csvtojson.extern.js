/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/csvtojson/index.d.ts:

/* TODO: ImportDeclaration in  */
/** @const */
var csvtojson = {};

/** @typedef {!internal.TransformOptions} */
csvtojson.StreamOptions;
/**
 * @record
 * @struct
 */
csvtojson.ConverterOptions = function() {};
 /** @type {boolean} */
csvtojson.ConverterOptions.prototype.constructResult;
 /** @type {(string|!Array<string>)} */
csvtojson.ConverterOptions.prototype.delimiter;
 /** @type {string} */
csvtojson.ConverterOptions.prototype.quote;
 /** @type {boolean} */
csvtojson.ConverterOptions.prototype.trim;
 /** @type {boolean} */
csvtojson.ConverterOptions.prototype.checkType;
 /** @type {boolean} */
csvtojson.ConverterOptions.prototype.toArrayString;
 /** @type {boolean} */
csvtojson.ConverterOptions.prototype.ignoreEmpty;
 /** @type {number} */
csvtojson.ConverterOptions.prototype.workerNum;
 /** @type {boolean} */
csvtojson.ConverterOptions.prototype.noheader;
 /** @type {!Array<string>} */
csvtojson.ConverterOptions.prototype.headers;
 /** @type {boolean} */
csvtojson.ConverterOptions.prototype.flatKeys;
 /** @type {number} */
csvtojson.ConverterOptions.prototype.maxRowLength;
 /** @type {boolean} */
csvtojson.ConverterOptions.prototype.checkColumn;
 /** @type {string} */
csvtojson.ConverterOptions.prototype.eol;
 /** @type {string} */
csvtojson.ConverterOptions.prototype.escape;
 /** @type {!Array<number>} */
csvtojson.ConverterOptions.prototype.includeColumns;
 /** @type {!Array<number>} */
csvtojson.ConverterOptions.prototype.ignoreColumns;
 /** @type {number} */
csvtojson.ConverterOptions.prototype.fork;

/** @typedef {function(?, ?): void} */
csvtojson.ParseResultHandler;

/** @typedef {function(?, number): void} */
csvtojson.JsonEventHandler;

/** @typedef {function(!Array<string>, number): void} */
csvtojson.CsvEventHandler;

/** @typedef {function(?): void} */
csvtojson.DataEventHandler;

/** @typedef {function(?): void} */
csvtojson.ErrorEventHandler;

/** @typedef {function(?, !Array<string>, number): void} */
csvtojson.RecordParsedEventHandler;

/** @typedef {function(): void} */
csvtojson.EndEventHandler;

/** @typedef {function(!Array<?>): void} */
csvtojson.EndParsedEventHandler;

/** @typedef {function(?): void} */
csvtojson.DoneEventHandler;

/**
 * @constructor
 * @struct
 * Initializes a new instance of a Converter
 * @param {!csvtojson.ConverterOptions=} options
 * @param {!internal.TransformOptions=} streamOptions
 */
csvtojson.Converter = function(options, streamOptions) {};

/**
 * Reads in a CSV from a string.
 * Reads in a CSV from a string.
 * @param {string} str
 * @param {function(?, ?): void=} callback
 * @return {Converter|void}
 */
csvtojson.Converter.prototype.fromString = function(str, callback) {};

/**
 * Reads in a CSV from a file.
 * Reads in a CSV from a file.
 * @param {string} filePath
 * @param {function(?, ?): void=} callback
 * @return {Converter|void}
 */
csvtojson.Converter.prototype.fromFile = function(filePath, callback) {};

/**
 * Reads in a CSV from a stream.
 * Reads in a CSV from a stream.
 * @param {!NodeJS.ReadableStream|!internal.Stream} stream
 * @param {function(?, ?): void=} callback
 * @return {Converter|void}
 */
csvtojson.Converter.prototype.fromStream = function(stream, callback) {};

/**
 * @param {string} event
 * @param {(!Function|function(?, number): void|function(!Array<string>, number): void|function(?): void|function(?, !Array<string>, number): void|function(): void|function(!Array<?>): void)} listener
 * @return {Converter}
 */
csvtojson.Converter.prototype.on = function(event, listener) {};

/**
 * Transform objects after CSV parsing but before result being emitted or pushed downstream.
 * @param {function(?, !Array<string>, number): void} callback
 * @return {Converter}
 */
csvtojson.Converter.prototype.transf = function(callback) {};

/**
 * The function in preRawData will be called directly with the string from upper stream.
 * @param {function(string, function(?): void): void} callback
 * @return {Converter}
 */
csvtojson.Converter.prototype.preRawData = function(callback) {};

/**
 * The function is called each time a file line being found in csv stream.
 * @param {function(string, number): string} callback
 * @return {Converter}
 */
csvtojson.Converter.prototype.preFileLine = function(callback) {};

/**
 * Factory function which creates an instance of a Converter object.
 * @param {!csvtojson.ConverterOptions=} options
 * @param {!internal.TransformOptions=} streamOptions
 * @return {!csvtojson.Converter}
 */
function csvtojson(options, streamOptions) {}

/* TODO: ExportAssignment in  */
