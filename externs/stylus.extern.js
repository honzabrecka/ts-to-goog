/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/stylus/index.d.ts:
 /** @type {!Stylus.Static} */
var stylus;

/* TODO: ExportAssignment in  */
/** @const */
var Stylus = {};
/**
 * @record
 * @struct
 */
Stylus.Static = function() {};

/* TODO: CallSignature: Stylus */

/* TODO: CallSignature: Stylus */
 /** @type {string} */
Stylus.Static.prototype.version;
 /** @type {!Stylus.NodeStatic} */
Stylus.Static.prototype.nodes;
 /** @type {!Stylus.Functions} */
Stylus.Static.prototype.functions;
 /** @type {!Stylus.Utils} */
Stylus.Static.prototype.utils;
 /** @type {?} */
Stylus.Static.prototype.Visitor;
 /** @type {?} */
Stylus.Static.prototype.Parser;
 /** @type {?} */
Stylus.Static.prototype.Evaluator;
 /** @type {?} */
Stylus.Static.prototype.Compiler;
 /** @type {!Stylus.UrlFunction} */
Stylus.Static.prototype.url;

/**
 * Expose middleware.
 * @param {string|?} dir_or_options
 * @return {!Stylus.Middleware}
 */
Stylus.Static.prototype.middleware = function(dir_or_options) {};

/**
 * Convert the given `css` to `stylus` source.
 * @param {string} css
 * @return {string}
 */
Stylus.Static.prototype.convertCSS = function(css) {};

/**
 * Render the given `str` with `options` and callback `fn(err, css)`.
 * @param {string} str
 * @param {!Stylus.RenderCallback|!Stylus.RenderOptions} callback_or_options
 * @param {!Stylus.RenderCallback=} callback
 * @return {void}
 */
Stylus.Static.prototype.render = function(str, callback_or_options, callback) {};

/**
 * Return a url() function with the given `options`.
 * @param {?} options
 * @return {!Stylus.LiteralFunction}
 */
Stylus.Static.prototype.resolver = function(options) {};
/**
 * @record
 * @struct
 */
Stylus.NodeStatic = function() {};
 /** @type {?} */
Stylus.NodeStatic.prototype.Node;
 /** @type {?} */
Stylus.NodeStatic.prototype.Root;
 /** @type {?} */
Stylus.NodeStatic.prototype.Null;
 /** @type {?} */
Stylus.NodeStatic.prototype.Each;
 /** @type {?} */
Stylus.NodeStatic.prototype.If;
 /** @type {?} */
Stylus.NodeStatic.prototype.Call;
 /** @type {?} */
Stylus.NodeStatic.prototype.UnaryOp;
 /** @type {?} */
Stylus.NodeStatic.prototype.BinOp;
 /** @type {?} */
Stylus.NodeStatic.prototype.Ternary;
 /** @type {?} */
Stylus.NodeStatic.prototype.Block;
 /** @type {?} */
Stylus.NodeStatic.prototype.Unit;
 /** @type {?} */
Stylus.NodeStatic.prototype.String;
 /** @type {?} */
Stylus.NodeStatic.prototype.HSLA;
 /** @type {?} */
Stylus.NodeStatic.prototype.RGBA;
 /** @type {?} */
Stylus.NodeStatic.prototype.Ident;
 /** @type {?} */
Stylus.NodeStatic.prototype.Group;
 /** @type {?} */
Stylus.NodeStatic.prototype.Literal;
 /** @type {?} */
Stylus.NodeStatic.prototype.Boolean;
 /** @type {?} */
Stylus.NodeStatic.prototype.Return;
 /** @type {?} */
Stylus.NodeStatic.prototype.Media;
 /** @type {?} */
Stylus.NodeStatic.prototype.QueryList;
 /** @type {?} */
Stylus.NodeStatic.prototype.Query;
 /** @type {?} */
Stylus.NodeStatic.prototype.QueryExpr;
 /** @type {?} */
Stylus.NodeStatic.prototype.Params;
 /** @type {?} */
Stylus.NodeStatic.prototype.Comment;
 /** @type {?} */
Stylus.NodeStatic.prototype.Keyframes;
 /** @type {?} */
Stylus.NodeStatic.prototype.Member;
 /** @type {?} */
Stylus.NodeStatic.prototype.Charset;
 /** @type {?} */
Stylus.NodeStatic.prototype.Namespace;
 /** @type {?} */
Stylus.NodeStatic.prototype.Import;
 /** @type {?} */
Stylus.NodeStatic.prototype.Extend;
 /** @type {?} */
Stylus.NodeStatic.prototype.Object;
 /** @type {?} */
Stylus.NodeStatic.prototype.Function;
 /** @type {?} */
Stylus.NodeStatic.prototype.Property;
 /** @type {?} */
Stylus.NodeStatic.prototype.Selector;
 /** @type {?} */
Stylus.NodeStatic.prototype.Expression;
 /** @type {?} */
Stylus.NodeStatic.prototype.Arguments;
 /** @type {?} */
Stylus.NodeStatic.prototype.Atblock;
 /** @type {?} */
Stylus.NodeStatic.prototype.Atrule;
 /** @type {!Stylus.Nodes.Boolean} */
Stylus.NodeStatic.prototype.true;
 /** @type {!Stylus.Nodes.Boolean} */
Stylus.NodeStatic.prototype.false;
 /** @type {!Stylus.Nodes.Null} */
Stylus.NodeStatic.prototype.null;
/**
 * @record
 * @struct
 */
Stylus.Functions = function() {};

/**
 * Convert the given `color` to an `HSLA` node,
 * or h,s,l,a component values.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA|!Stylus.Nodes.Unit} rgba_or_hsla_or_hue
 * @param {!Stylus.Nodes.Unit=} saturation
 * @param {!Stylus.Nodes.Unit=} lightness
 * @param {!Stylus.Nodes.Unit=} alpha
 * @return {!Stylus.Nodes.HSLA}
 */
Stylus.Functions.prototype.hsla = function(rgba_or_hsla_or_hue, saturation, lightness, alpha) {};

/**
 * Convert the given `color` to an `HSLA` node,
 * or h,s,l component values.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA|!Stylus.Nodes.Unit} rgba_or_hsla_or_hue
 * @param {!Stylus.Nodes.Unit=} saturation
 * @param {!Stylus.Nodes.Unit=} lightness
 * @return {!Stylus.Nodes.HSLA}
 */
Stylus.Functions.prototype.hsl = function(rgba_or_hsla_or_hue, saturation, lightness) {};

/**
 * Return type of `node`.
 * @param {!Stylus.Nodes.Node} node
 * @return {string}
 */
Stylus.Functions.prototype.type = function(node) {};

/**
 * Return type of `node`.
 * @param {!Stylus.Nodes.Node} node
 * @return {string}
 */
Stylus.Functions.prototype.typeof = function(node) {};

/**
 * Return type of `node`.
 * @param {!Stylus.Nodes.Node} node
 * @return {string}
 */
Stylus.Functions.prototype"type-of" = function(node) {};

/**
 * Return component `name` for the given `color`.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} color
 * @param {!Stylus.Nodes.String} name
 * @return {!Stylus.Nodes.Unit}
 */
Stylus.Functions.prototype.component = function(color, name) {};

/**
 * Return component `name` for the given `color`.
 * @param {!Stylus.Nodes.String} path
 * @param {!Stylus.Nodes.String=} ext
 * @return {string}
 */
Stylus.Functions.prototype.basename = function(path, ext) {};

/**
 * Return the dirname of `path`.
 * @param {!Stylus.Nodes.String} path
 * @return {string}
 */
Stylus.Functions.prototype.dirname = function(path) {};

/**
 * Return the extension of `path`.
 * @param {!Stylus.Nodes.String} path
 * @return {string}
 */
Stylus.Functions.prototype.extname = function(path) {};

/**
 * Joins given paths
 * @param {...!Stylus.Nodes.String} paths
 * @return {string}
 */
Stylus.Functions.prototype.pathjoin = function(paths) {};

/**
 * Return the red component of the given `color`,
 * or set the red component to the optional second `value` argument.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} color
 * @param {!Stylus.Nodes.Unit=} value
 * @return {!Stylus.Nodes.Unit|!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.red = function(color, value) {};

/**
 * Return the green component of the given `color`,
 * or set the green component to the optional second `value` argument.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} color
 * @param {!Stylus.Nodes.Unit=} value
 * @return {!Stylus.Nodes.Unit|!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.green = function(color, value) {};

/**
 * Return the blue component of the given `color`,
 * or set the blue component to the optional second `value` argument.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} color
 * @param {!Stylus.Nodes.Unit=} value
 * @return {!Stylus.Nodes.Unit|!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.blue = function(color, value) {};

/**
 * Return the alpha component of the given `color`,
 * or set the alpha component to the optional second `value` argument.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} color
 * @param {!Stylus.Nodes.Unit=} value
 * @return {!Stylus.Nodes.Unit|!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.alpha = function(color, value) {};

/**
 * Return the hue component of the given `color`,
 * or set the hue component to the optional second `value` argument.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} color
 * @param {!Stylus.Nodes.Unit=} value
 * @return {!Stylus.Nodes.Unit|!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.hue = function(color, value) {};

/**
 * Return the saturation component of the given `color`,
 * or set the saturation component to the optional second `value` argument.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} color
 * @param {!Stylus.Nodes.Unit=} value
 * @return {!Stylus.Nodes.Unit|!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.saturation = function(color, value) {};

/**
 * Return the lightness component of the given `color`,
 * or set the lightness component to the optional second `value` argument.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} color
 * @param {!Stylus.Nodes.Unit=} value
 * @return {!Stylus.Nodes.Unit|!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.lightness = function(color, value) {};

/**
 * Return a `RGBA` from the r,g,b,a channels.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA|!Stylus.Nodes.Unit} rgba_or_hsla_or_hue
 * @param {!Stylus.Nodes.Unit=} saturation
 * @param {!Stylus.Nodes.Unit=} lightness
 * @param {!Stylus.Nodes.Unit=} alpha
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.rgba = function(rgba_or_hsla_or_hue, saturation, lightness, alpha) {};

/**
 * Return a `RGBA` from the r,g,b channels.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA|!Stylus.Nodes.Unit} rgba_or_hsla_or_hue
 * @param {!Stylus.Nodes.Unit=} saturation
 * @param {!Stylus.Nodes.Unit=} lightness
 * @param {!Stylus.Nodes.Unit=} alpha
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.rgb = function(rgba_or_hsla_or_hue, saturation, lightness, alpha) {};

/**
 * Blend the `top` color over the `bottom`
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} top
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA=} bottom
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.blend = function(top, bottom) {};

/**
 * Returns the relative luminance of the given `color`,
 * see http://www.w3.org/TR/WCAG20/#relativeluminancedef
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} rgba
 * @return {!Stylus.Nodes.Unit}
 */
Stylus.Functions.prototype.luminosity = function(rgba) {};

/**
 * Returns the contrast ratio object between `top` and `bottom` colors,
 * based on http://leaverou.github.io/contrast-ratio/
 * and https://github.com/LeaVerou/contrast-ratio/blob/gh-pages/color.js#L108
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} top
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA=} bottom
 * @return {!Stylus.Nodes.Object}
 */
Stylus.Functions.prototype.contrast = function(top, bottom) {};

/**
 * Returns the transparent version of the given `top` color,
 * as if it was blend over the given `bottom` color.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} top
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA=} bottom
 * @param {!Stylus.Nodes.Unit=} alpha
 * @return {!Stylus.Nodes.Object}
 */
Stylus.Functions.prototype.transparentify = function(top, bottom, alpha) {};

/**
 * Convert a .json file into stylus variables or object.
 * Nested variable object keys are joined with a dash (-)
 * 
 * Given this sample media-queries.json file:
 * {
 *   "small": "screen and (max-width:400px)",
 *   "tablet": {
 *     "landscape": "screen and (min-width:600px) and (orientation:landscape)",
 *     "portrait": "screen and (min-width:600px) and (orientation:portrait)"
 *   }
 * }
 * @param {!Stylus.Nodes.String} path
 * @param {!Stylus.Nodes.Boolean} local
 * @param {!Stylus.Nodes.String} namePrefix
 * @return {?}
 */
Stylus.Functions.prototype.json = function(path, local, namePrefix) {};

/**
 * Use the given `plugin`.
 * @param {!Stylus.Nodes.String} plugin
 * @param {?=} options
 * @return {void}
 */
Stylus.Functions.prototype.use = function(plugin, options) {};

/**
 * Unquote the given `string`.
 * @param {!Stylus.Nodes.String} str
 * @return {!Stylus.Nodes.Literal}
 */
Stylus.Functions.prototype.unquote = function(str) {};

/**
 * Like `unquote` but tries to convert the given `str` to a Stylus node.
 * @param {!Stylus.Nodes.String} str
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Functions.prototype.convert = function(str) {};

/**
 * Assign `type` to the given `unit` or return `unit`'s type.
 * @param {!Stylus.Nodes.Unit} unit
 * @param {!Stylus.Nodes.String} type
 * @return {!Stylus.Nodes.Unit}
 */
Stylus.Functions.prototype.unit = function(unit, type) {};

/**
 * Lookup variable `name` or return Null.
 * @param {!Stylus.Nodes.String} name
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Functions.prototype.lookup = function(name) {};

/**
 * Set a variable `name` on current scope.
 * @param {!Stylus.Nodes.String} name
 * @param {!Stylus.Nodes.Expression} expr
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Functions.prototype.define = function(name, expr) {};

/**
 * Perform `op` on the `left` and `right` operands.
 * @param {!Stylus.Nodes.String} op
 * @param {!Stylus.Nodes.Node} left
 * @param {!Stylus.Nodes.Node} right
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Functions.prototype.operate = function(op, left, right) {};

/**
 * Test if `val` matches the given `pattern`.
 * @param {!Stylus.Nodes.String} pattern
 * @param {!Stylus.Nodes.String|!Stylus.Nodes.Ident} val
 * @return {!Stylus.Nodes.Boolean}
 */
Stylus.Functions.prototype.match = function(pattern, val) {};

/**
 * Returns substring of the given `val`.
 * @param {!Stylus.Nodes.String|!Stylus.Nodes.Ident} val
 * @param {!Stylus.Nodes.Number} start
 * @param {!Stylus.Nodes.Number} length
 * @return {!Stylus.Nodes.String|!Stylus.Nodes.Ident}
 */
Stylus.Functions.prototype.substr = function(val, start, length) {};

/**
 * Returns string with all matches of `pattern` replaced by `replacement` in given `val`
 * @param {!Stylus.Nodes.String} pattern
 * @param {!Stylus.Nodes.String} replacement
 * @param {!Stylus.Nodes.String|!Stylus.Nodes.Ident} val
 * @return {!Stylus.Nodes.String|!Stylus.Nodes.Ident}
 */
Stylus.Functions.prototype.replace = function(pattern, replacement, val) {};

/**
 * Splits the given `val` by `delim`
 * @param {!Stylus.Nodes.String} pattern
 * @param {!Stylus.Nodes.String|!Stylus.Nodes.Ident} val
 * @return {!Stylus.Nodes.Expression}
 */
Stylus.Functions.prototype.split = function(pattern, val) {};

/**
 * Return length of the given `expr`.
 * Inspect the given `expr`.
 * @param {...!Stylus.Nodes.Expression} expr
 * @return {!Stylus.Nodes.Unit|!Stylus.Nodes.Null}
 */
Stylus.Functions.prototype.length = function(expr) {};

/**
 * Throw an error with the given `msg`.
 * @param {!Stylus.Nodes.String} msg
 * @return {void}
 */
Stylus.Functions.prototype.error = function(msg) {};

/**
 * Warn with the given `msg` prefixed by "Warning: ".
 * @param {!Stylus.Nodes.String} msg
 * @return {!Stylus.Nodes.Null}
 */
Stylus.Functions.prototype.warn = function(msg) {};

/**
 * Output stack trace.
 * @return {!Stylus.Nodes.Null}
 */
Stylus.Functions.prototype.trace = function() {};

/**
 * Push the given args to `expr`.
 * @param {!Stylus.Nodes.Expression} expr
 * @param {...!Stylus.Nodes.Node} nodes
 * @return {!Stylus.Nodes.Unit}
 */
Stylus.Functions.prototype.push = function(expr, nodes) {};

/**
 * Pop a value from `expr`.
 * @param {!Stylus.Nodes.Expression} expr
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Functions.prototype.pop = function(expr) {};

/**
 * Unshift the given args to `expr`.
 * @param {!Stylus.Nodes.Expression} expr
 * @param {...!Stylus.Nodes.Node} nodes
 * @return {!Stylus.Nodes.Unit}
 */
Stylus.Functions.prototype.unshift = function(expr, nodes) {};

/**
 * Unshift the given args to `expr`..
 * @param {!Stylus.Nodes.Expression} expr
 * @param {...!Stylus.Nodes.Node} nodes
 * @return {!Stylus.Nodes.Unit}
 */
Stylus.Functions.prototype.prepend = function(expr, nodes) {};

/**
 * Shift a value from `expr`.
 * @param {!Stylus.Nodes.Expression} expr
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Functions.prototype.shift = function(expr) {};

/**
 * Return a `Literal` with the given `fmt`, and variable number of arguments.
 * @param {!Stylus.Nodes.String} fmt
 * @param {...!Stylus.Nodes.Node} nodes
 * @return {!Stylus.Nodes.Literal}
 */
Stylus.Functions.prototype.s = function(fmt, nodes) {};

/**
 * Return a `Literal` `num` converted to the provided `base`, padded to `width`
 * with zeroes (default width is 2)
 * @param {!Stylus.Nodes.Number} num
 * @param {!Stylus.Nodes.Number} base
 * @param {!Stylus.Nodes.Number} width
 * @return {!Stylus.Nodes.Literal}
 */
Stylus.Functions.prototype"base-convert" = function(num, base, width) {};

/**
 * Return the opposites of the given `positions`.
 * @param {!Stylus.Nodes.Expression} positions
 * @return {!Stylus.Nodes.Expression}
 */
Stylus.Functions.prototype"opposite-position" = function(positions) {};

/**
 * Return the width and height of the given `img` path.
 * @param {!Stylus.Nodes.String} img
 * @param {!Stylus.Nodes.Boolean} ignoreErr
 * @return {!Stylus.Nodes.Expression}
 */
Stylus.Functions.prototype"image-size" = function(img, ignoreErr) {};

/**
 * Return the tangent of the given `angle`.
 * @param {!Stylus.Nodes.Unit} angle
 * @return {!Stylus.Nodes.Unit}
 */
Stylus.Functions.prototype.tan = function(angle) {};

/**
 * Return the tangent of the given `angle`.
 * @param {!Stylus.Nodes.Unit} n
 * @param {!Stylus.Nodes.String} fn
 * @return {!Stylus.Nodes.Unit}
 */
Stylus.Functions.prototype.math = function(n, fn) {};

/**
 * Return the opposites of the given `positions`.
 * @param {!Stylus.Nodes.String} prop
 * @return {!Stylus.Nodes.Unit}
 */
Stylus.Functions.prototype"-math-prop" = function(prop) {};

/**
 * Adjust HSL `color` `prop` by `amount`.
 * @param {!Stylus.Nodes.RGBA|!Stylus.Nodes.HSLA} rgba_or_hsla
 * @param {!Stylus.Nodes.String} prop
 * @param {!Stylus.Nodes.Unit} amount
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Functions.prototype.adjust = function(rgba_or_hsla, prop, amount) {};

/**
 * Return a clone of the given `expr`.
 * @param {!Stylus.Nodes.Expression} expr
 * @return {!Stylus.Nodes.Expression}
 */
Stylus.Functions.prototype.clone = function(expr) {};

/**
 * Add property `name` with the given `expr` to the mixin-able block.
 * @param {!Stylus.Nodes.String} name
 * @param {!Stylus.Nodes.Expression} expr
 * @return {!Stylus.Nodes.Property}
 */
Stylus.Functions.prototype"add-property" = function(name, expr) {};

/**
 * Merge the object `dest` with the given args.
 * @param {!Stylus.Nodes.Object} dest
 * @param {...!Stylus.Nodes.Object} objs
 * @return {!Stylus.Nodes.Object}
 */
Stylus.Functions.prototype.merge = function(dest, objs) {};

/**
 * Merge the object `dest` with the given args.
 * @param {!Stylus.Nodes.Object} dest
 * @param {...!Stylus.Nodes.Object} objs
 * @return {!Stylus.Nodes.Object}
 */
Stylus.Functions.prototype.extend = function(dest, objs) {};

/**
 * Return the current selector or compile `sel` selector.
 * @param {!Stylus.Nodes.String=} sel
 * @return {string}
 */
Stylus.Functions.prototype.selector = function(sel) {};

/**
 * Prefix css classes in a block
 * @param {!Stylus.Nodes.String} prefix
 * @param {!Stylus.Nodes.Block} block
 * @return {!Stylus.Nodes.Block}
 */
Stylus.Functions.prototype"-prefix-classes" = function(prefix, block) {};

/**
 * Returns the \@media string for the current block
 * @return {!Stylus.Nodes.String}
 */
Stylus.Functions.prototype"current-media" = function() {};

/**
 * Return the separator of the given `list`.
 * @param {!Stylus.Nodes.Expression} list
 * @return {!Stylus.Nodes.String}
 */
Stylus.Functions.prototype"list-separator" = function(list) {};
/**
 * @record
 * @struct
 */
Stylus.Utils = function() {};

/**
 * Check if `path` looks absolute.
 * @param {string} path
 * @return {boolean}
 */
Stylus.Utils.prototype.absolute = function(path) {};

/**
 * Attempt to lookup `path` within `paths` from tail to head.
 * Optionally a path to `ignore` may be passed.
 * @param {string} path
 * @param {string} paths
 * @param {string} ignore
 * @param {boolean} resolveURL
 * @return {string}
 */
Stylus.Utils.prototype.lookup = function(path, paths, ignore, resolveURL) {};

/**
 * Attempt to lookup `path` within `paths` from tail to head.
 * Optionally a path to `ignore` may be passed.
 * @param {string} path
 * @param {string} paths
 * @param {string} filename
 * @return {!Array<string>}
 */
Stylus.Utils.prototype.lookupIndex = function(path, paths, filename) {};

/**
 * Like `utils.lookup` but uses `glob` to find files.
 * @param {string} path
 * @param {string} paths
 * @param {string} ignore
 * @return {!Array<string>}
 */
Stylus.Utils.prototype.find = function(path, paths, ignore) {};

/**
 * Format the given `err` with the given `options`.
 * @param {!Error} err
 * @param {!Stylus.ExceptionOptions} options
 * @return {!Error}
 */
Stylus.Utils.prototype.formatException = function(err, options) {};

/**
 * Assert that `node` is of the given `type`, or throw.
 * @param {!Stylus.Nodes.Node} node
 * @param {string} type
 * @param {string} param
 * @return {void}
 */
Stylus.Utils.prototype.assertType = function(node, type, param) {};

/**
 * Assert that `node` is a `String` or `Ident`.
 * @param {!Stylus.Nodes.Node} node
 * @param {string} param
 * @return {void}
 */
Stylus.Utils.prototype.assertString = function(node, param) {};

/**
 * Assert that `node` is a `RGBA` or `HSLA`.
 * @param {!Stylus.Nodes.Node} node
 * @param {string} param
 * @return {void}
 */
Stylus.Utils.prototype.assertColor = function(node, param) {};

/**
 * Assert that param `name` is given, aka the `node` is passed.
 * @param {!Stylus.Nodes.Node} node
 * @param {string} name
 * @return {void}
 */
Stylus.Utils.prototype.assertPresent = function(node, name) {};

/**
 * Unwrap `expr`.
 * 
 * Takes an expressions with length of 1
 * such as `((1 2 3))` and unwraps it to `(1 2 3)`.
 * @param {!Stylus.Nodes.Expression} expr
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Utils.prototype.unwrap = function(expr) {};

/**
 * Coerce JavaScript values to their Stylus equivalents.
 * @param {?} val
 * @param {boolean=} raw
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Utils.prototype.coerce = function(val, raw) {};

/**
 * Coerce a javascript `Array` to a Stylus `Expression`.
 * @param {?} val
 * @param {boolean=} raw
 * @return {!Stylus.Nodes.Expression}
 */
Stylus.Utils.prototype.coerceArray = function(val, raw) {};

/**
 * Coerce a javascript object to a Stylus `Expression` or `Object`.
 * 
 * For example `{ foo: 'bar', bar: 'baz' }` would become
 * the expression `(foo 'bar') (bar 'baz')`. If `raw` is true
 * given `obj` would become a Stylus hash object.
 * @param {?} obj
 * @param {boolean=} raw
 * @return {!Stylus.Nodes.Expression}
 */
Stylus.Utils.prototype.coerceObject = function(obj, raw) {};

/**
 * Return param names for `fn`.
 * @param {!Function} fn
 * @return {!Array<string>}
 */
Stylus.Utils.prototype.params = function(fn) {};

/**
 * Merge object `b` with `a`.
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Stylus.Utils.prototype.merge = function(a, b) {};

/**
 * Returns an array with unique values.
 * @param {!Array<?>} arr
 * @return {!Array<?>}
 */
Stylus.Utils.prototype.uniq = function(arr) {};

/**
 * Compile selector strings in `arr` from the bottom-up
 * to produce the selector combinations. For example
 * the following Stylus:
 * @param {!Array<string>} arr
 * @param {boolean} leaveHidden
 * @return {!Array<string>}
 */
Stylus.Utils.prototype.compileSelectors = function(arr, leaveHidden) {};
/**
 * @record
 * @struct
 */
Stylus.UrlFunction = function() {};

/* TODO: CallSignature: Stylus */
 /** @type {{.gif: string, .png: string, .jpg: string, .jpeg: string, .svg: string, .ttf: string, .eot: string, .woff: string}} */
Stylus.UrlFunction.prototype.mimes;
/**
 * @record
 * @struct
 */
Stylus.Middleware = function() {};

/* TODO: CallSignature: Stylus */
/**
 * @constructor
 * @struct
 */
Stylus.Visitor = function() {};
/**
 * @constructor
 * @struct
 */
Stylus.Parser = function() {};
/**
 * @constructor
 * @struct
 */
Stylus.Evaluator = function() {};
/**
 * @constructor
 * @struct
 */
Stylus.Compiler = function() {};

/**
 * @constructor
 * @struct
 * @param {string} str
 * @param {!Stylus.RenderOptions=} options
 */
Stylus.Renderer = function(str, options) {};
 /** @type {!Stylus.RenderOptions} */
Stylus.Renderer.prototype.options;
 /** @type {string} */
Stylus.Renderer.prototype.str;
 /** @type {?} */
Stylus.Renderer.prototype.events;

/**
 * Parse and evaluate AST, then callback `fn(err, css, js)`.
 * Parse and evaluate AST and return the result.
 * @param {!Stylus.RenderCallback=} callback
 * @return {void|string}
 */
Stylus.Renderer.prototype.render = function(callback) {};

/**
 * Get dependencies of the compiled file.
 * @param {string} filename
 * @return {!Array<string>}
 */
Stylus.Renderer.prototype.deps = function(filename) {};

/**
 * Set option `key` to `val`.
 * @param {string} key
 * @param {?} val
 * @return {!Stylus.Renderer}
 */
Stylus.Renderer.prototype.set = function(key, val) {};

/**
 * Get option `key`.
 * @param {string} key
 * @return {?}
 */
Stylus.Renderer.prototype.get = function(key) {};

/**
 * Include the given `path` to the lookup paths array.
 * @param {string} path
 * @return {!Stylus.Renderer}
 */
Stylus.Renderer.prototype.include = function(path) {};

/**
 * Use the given `fn`.
 * 
 * This allows for plugins to alter the renderer in
 * any way they wish, exposing paths etc.
 * @param {function(!Stylus.Renderer): ?} fn
 * @return {!Stylus.Renderer}
 */
Stylus.Renderer.prototype.use = function(fn) {};

/**
 * Define function or global var with the given `name`. Optionally
 * the function may accept full expressions, by setting `raw`
 * to `true`.
 * @param {string} name
 * @param {!Function|!Stylus.Nodes.Node|?} fn_or_node_or_val
 * @param {boolean=} raw
 * @return {!Stylus.Renderer}
 */
Stylus.Renderer.prototype.define = function(name, fn_or_node_or_val, raw) {};

/**
 * Import the given `file`.
 * @param {string} file
 * @return {!Stylus.Renderer}
 */
Stylus.Renderer.prototype.import = function(file) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Renderer}
 */
Stylus.Renderer.prototype.addListener = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Renderer}
 */
Stylus.Renderer.prototype.on = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Renderer}
 */
Stylus.Renderer.prototype.once = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Renderer}
 */
Stylus.Renderer.prototype.removeListener = function(event, listener) {};

/**
 * @param {string=} event
 * @return {Renderer}
 */
Stylus.Renderer.prototype.removeAllListeners = function(event) {};

/**
 * @param {number} n
 * @return {Renderer}
 */
Stylus.Renderer.prototype.setMaxListeners = function(n) {};

/**
 * @return {number}
 */
Stylus.Renderer.prototype.getMaxListeners = function() {};

/**
 * @param {string} event
 * @return {!Array<!Function>}
 */
Stylus.Renderer.prototype.listeners = function(event) {};

/**
 * @param {string} event
 * @param {...?} args
 * @return {boolean}
 */
Stylus.Renderer.prototype.emit = function(event, args) {};

/**
 * @param {string} type
 * @return {number}
 */
Stylus.Renderer.prototype.listenerCount = function(type) {};
/** @const */
Stylus.Nodes = {};

/**
 * @constructor
 * @struct
 */
Stylus.Nodes.Node = function() {};
 /** @type {number} */
Stylus.Nodes.Node.prototype.lineno;
 /** @type {number} */
Stylus.Nodes.Node.prototype.column;
 /** @type {string} */
Stylus.Nodes.Node.prototype.filename;
 /** @type {!Stylus.Nodes.Node} */
Stylus.Nodes.Node.prototype.first;
 /** @type {string} */
Stylus.Nodes.Node.prototype.hash;
 /** @type {string} */
Stylus.Nodes.Node.prototype.nodeName;

/**
 * Return a clone of this node.
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Nodes.Node.prototype.clone = function() {};

/**
 * Return a JSON representation of this node.
 * @return {{lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Node.prototype.toJSON = function() {};

/**
 * Nodes by default evaluate to themselves.
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Nodes.Node.prototype.eval = function() {};

/**
 * Return true.
 * @return {!Stylus.Nodes.Boolean}
 */
Stylus.Nodes.Node.prototype.toBoolean = function() {};

/**
 * Return the expression, or wrap this node in an expression.
 * @return {!Stylus.Nodes.Expression}
 */
Stylus.Nodes.Node.prototype.toExpression = function() {};

/**
 * Return false if `op` is generally not coerced.
 * @param {string} op
 * @return {boolean}
 */
Stylus.Nodes.Node.prototype.shouldCoerce = function(op) {};

/**
 * Operate on `right` with the given `op`.
 * @param {string} op
 * @param {!Stylus.Nodes.Node} right
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Nodes.Node.prototype.operate = function(op, right) {};

/**
 *  Default coercion throws.
 * @param {!Stylus.Nodes.Node} other
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Nodes.Node.prototype.coerce = function(other) {};
/**
 * @extends {Stylus.Nodes.Node}
 * @constructor
 * @struct
 */
Stylus.Nodes.Root = function() {};
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.Root.prototype.nodes;

/**
 * Push a `node` to this block.
 * @param {!Stylus.Nodes.Node} node
 * @return {void}
 */
Stylus.Nodes.Root.prototype.push = function(node) {};

/**
 * Unshift a `node` to this block.
 * @param {!Stylus.Nodes.Node} node
 * @return {void}
 */
Stylus.Nodes.Root.prototype.unshift = function(node) {};

/**
 * Return a JSON representation of this node.
 * @return {{nodes: !Array<!Stylus.Nodes.Node>, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Root.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} val
 * @param {string=} quote
 */
Stylus.Nodes.String = function(val, quote) {};
 /** @type {string} */
Stylus.Nodes.String.prototype.val;
 /** @type {string} */
Stylus.Nodes.String.prototype.string;
 /** @type {boolean} */
Stylus.Nodes.String.prototype.prefixed;
 /** @type {string} */
Stylus.Nodes.String.prototype.quote;

/**
 * Return a JSON representation of this node.
 * @return {{val: string, quote: string, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.String.prototype.toJSON = function() {};
/**
 * @extends {Stylus.Nodes.Node}
 * @constructor
 * @struct
 */
Stylus.Nodes.Number = function() {};

/**
 * @constructor
 * @struct
 * @param {boolean=} val
 */
Stylus.Nodes.Boolean = function(val) {};
 /** @type {boolean} */
Stylus.Nodes.Boolean.prototype.val;
 /** @type {boolean} */
Stylus.Nodes.Boolean.prototype.isTrue;
 /** @type {boolean} */
Stylus.Nodes.Boolean.prototype.isFalse;

/**
 * Negate the value.
 * @return {!Stylus.Nodes.Boolean}
 */
Stylus.Nodes.Boolean.prototype.negate = function() {};

/**
 * Return 'Boolean'.
 * @return {!Stylus.Nodes.Boolean}
 */
Stylus.Nodes.Boolean.prototype.inspect = function() {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, val: boolean, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Boolean.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 */
Stylus.Nodes.Object = function() {};
 /** @type {!Stylus.Dictionary<!Stylus.Nodes.Node>} */
Stylus.Nodes.Object.prototype.vals;
 /** @type {number} */
Stylus.Nodes.Object.prototype.length;

/**
 * Set `key` to `val`.
 * @param {string} key
 * @param {!Stylus.Nodes.Node} value
 * @return {!Stylus.Nodes.Object}
 */
Stylus.Nodes.Object.prototype.set = function(key, value) {};

/**
 * Get `key`.
 * @param {string} key
 * @return {!Stylus.Nodes.Node}
 */
Stylus.Nodes.Object.prototype.get = function(key) {};

/**
 * Has `key`?
 * @param {string} key
 * @return {boolean}
 */
Stylus.Nodes.Object.prototype.has = function(key) {};

/**
 * Convert object to string with properties.
 * @return {string}
 */
Stylus.Nodes.Object.prototype.toBlock = function() {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, vals: !Stylus.Dictionary<!Stylus.Nodes.Node>, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Object.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 */
Stylus.Nodes.Null = function() {};
 /** @type {boolean} */
Stylus.Nodes.Null.prototype.isNull;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Null.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {!Stylus.Nodes.Node} val
 * @param {boolean=} mixin
 */
Stylus.Nodes.Ident = function(name, val, mixin) {};
 /** @type {string} */
Stylus.Nodes.Ident.prototype.name;
 /** @type {string} */
Stylus.Nodes.Ident.prototype.string;
 /** @type {!Stylus.Nodes.Node} */
Stylus.Nodes.Ident.prototype.val;
 /** @type {boolean} */
Stylus.Nodes.Ident.prototype.mixin;
 /** @type {boolean} */
Stylus.Nodes.Ident.prototype.isEmpty;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, name: string, val: !Stylus.Nodes.Node, mixin: boolean, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Ident.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} str
 */
Stylus.Nodes.Literal = function(str) {};
 /** @type {string} */
Stylus.Nodes.Literal.prototype.val;
 /** @type {string} */
Stylus.Nodes.Literal.prototype.string;
 /** @type {boolean} */
Stylus.Nodes.Literal.prototype.prefixed;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, string: string, val: string, prefixed: boolean, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Literal.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {number} val
 * @param {string} type
 */
Stylus.Nodes.Unit = function(val, type) {};
 /** @type {number} */
Stylus.Nodes.Unit.prototype.val;
 /** @type {string} */
Stylus.Nodes.Unit.prototype.type;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, val: number, type: string, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Unit.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @param {number} a
 */
Stylus.Nodes.RGBA = function(r, g, b, a) {};
 /** @type {number} */
Stylus.Nodes.RGBA.prototype.r;
 /** @type {number} */
Stylus.Nodes.RGBA.prototype.g;
 /** @type {number} */
Stylus.Nodes.RGBA.prototype.b;
 /** @type {number} */
Stylus.Nodes.RGBA.prototype.a;
 /** @type {!Stylus.Nodes.RGBA} */
Stylus.Nodes.RGBA.prototype.rgba;
 /** @type {!Stylus.Nodes.HSLA} */
Stylus.Nodes.RGBA.prototype.hsla;

/**
 * Return an `RGBA` without clamping values.
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @param {number} a
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Nodes.RGBA.withoutClamping = function(r, g, b, a) {};

/**
 * Return a `RGBA` from the given `hsla`.
 * @param {!Stylus.Nodes.HSLA} hsla
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Nodes.RGBA.fromHSLA = function(hsla) {};

/**
 * Add r,g,b,a to the current component values
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @param {number} a
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Nodes.RGBA.prototype.add = function(r, g, b, a) {};

/**
 * Subtract r,g,b,a from the current component values
 * @param {number} r
 * @param {number} g
 * @param {number} b
 * @param {number} a
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Nodes.RGBA.prototype.substract = function(r, g, b, a) {};

/**
 * Multiply rgb components by `n`.
 * @param {number} n
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Nodes.RGBA.prototype.multiply = function(n) {};

/**
 * Divide rgb components by `n`.
 * @param {number} n
 * @return {!Stylus.Nodes.RGBA}
 */
Stylus.Nodes.RGBA.prototype.divide = function(n) {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, r: number, g: number, b: number, a: number, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.RGBA.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {number} h
 * @param {number} s
 * @param {number} l
 * @param {number} a
 */
Stylus.Nodes.HSLA = function(h, s, l, a) {};
 /** @type {number} */
Stylus.Nodes.HSLA.prototype.h;
 /** @type {number} */
Stylus.Nodes.HSLA.prototype.s;
 /** @type {number} */
Stylus.Nodes.HSLA.prototype.l;
 /** @type {number} */
Stylus.Nodes.HSLA.prototype.a;
 /** @type {!Stylus.Nodes.HSLA} */
Stylus.Nodes.HSLA.prototype.hsla;
 /** @type {!Stylus.Nodes.RGBA} */
Stylus.Nodes.HSLA.prototype.rgba;

/**
 * Return a `HSLA` from the given `hsla`.
 * @param {!Stylus.Nodes.RGBA} rgba
 * @return {!Stylus.Nodes.HSLA}
 */
Stylus.Nodes.HSLA.fromRGBA = function(rgba) {};

/**
 * Add h,s,l to the current component values
 * @param {number} h
 * @param {number} s
 * @param {number} l
 * @return {!Stylus.Nodes.HSLA}
 */
Stylus.Nodes.HSLA.prototype.add = function(h, s, l) {};

/**
 * Subtract h,s,l from the current component values
 * @param {number} h
 * @param {number} s
 * @param {number} l
 * @return {!Stylus.Nodes.HSLA}
 */
Stylus.Nodes.HSLA.prototype.substract = function(h, s, l) {};

/**
 * Adjust lightness by `percent`.
 * @param {number} percent
 * @return {!Stylus.Nodes.HSLA}
 */
Stylus.Nodes.HSLA.prototype.adjustLightness = function(percent) {};

/**
 * djust hue by `deg`.
 * @param {number} deg
 * @return {!Stylus.Nodes.HSLA}
 */
Stylus.Nodes.HSLA.prototype.adjustHue = function(deg) {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, h: number, s: number, l: number, a: number, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.HSLA.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Stylus.Nodes.Block} parent
 * @param {!Stylus.Nodes.Node=} node
 */
Stylus.Nodes.Block = function(parent, node) {};
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.Block.prototype.nodes;
 /** @type {!Stylus.Nodes.Block} */
Stylus.Nodes.Block.prototype.parent;
 /** @type {!Stylus.Nodes.Node} */
Stylus.Nodes.Block.prototype.node;
 /** @type {boolean} */
Stylus.Nodes.Block.prototype.scope;
 /** @type {boolean} */
Stylus.Nodes.Block.prototype.hasProperties;
 /** @type {boolean} */
Stylus.Nodes.Block.prototype.hasMedia;
 /** @type {boolean} */
Stylus.Nodes.Block.prototype.isEmpty;

/**
 * Push a `node` to this block.
 * @param {!Stylus.Nodes.Node} node
 * @return {void}
 */
Stylus.Nodes.Block.prototype.push = function(node) {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, nodes: !Array<!Stylus.Nodes.Node>, scope: boolean, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Block.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 */
Stylus.Nodes.Group = function() {};
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.Group.prototype.nodes;
 /** @type {!Stylus.Nodes.Block} */
Stylus.Nodes.Group.prototype.block;
 /** @type {boolean} */
Stylus.Nodes.Group.prototype.hasOnlyPlaceholders;

/**
 * Push the given `selector` node.
 * @param {!Stylus.Nodes.Node} node
 * @return {void}
 */
Stylus.Nodes.Group.prototype.push = function(node) {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, nodes: !Array<!Stylus.Nodes.Node>, block: !Stylus.Nodes.Block, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Group.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {boolean} isList
 */
Stylus.Nodes.Expression = function(isList) {};
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.Expression.prototype.nodes;
 /** @type {boolean} */
Stylus.Nodes.Expression.prototype.isList;
 /** @type {boolean} */
Stylus.Nodes.Expression.prototype.isEmpty;
 /** @type {!Stylus.Nodes.Node} */
Stylus.Nodes.Expression.prototype.first;

/**
 * Push the given node.
 * @param {!Stylus.Nodes.Node} node
 * @return {void}
 */
Stylus.Nodes.Expression.prototype.push = function(node) {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, nodes: !Array<!Stylus.Nodes.Node>, isList: boolean, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Expression.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Array<!Stylus.Nodes.Node>} segs
 * @param {!Stylus.Nodes.Expression} expr
 */
Stylus.Nodes.Property = function(segs, expr) {};
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.Property.prototype.segments;
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.Property.prototype.expr;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, segments: !Array<!Stylus.Nodes.Node>, name: string, expr: !Stylus.Nodes.Expression, literal: !Stylus.Nodes.Literal, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Property.prototype.toJSON = function() {};
/**
 * @extends {Stylus.Nodes.Node}
 * @constructor
 * @struct
 */
Stylus.Nodes.Each = function() {};
 /** @type {string} */
Stylus.Nodes.Each.prototype.val;
 /** @type {string} */
Stylus.Nodes.Each.prototype.key;
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.Each.prototype.expr;
 /** @type {!Stylus.Nodes.Block} */
Stylus.Nodes.Each.prototype.block;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, val: string, key: string, expr: !Stylus.Nodes.Expression, block: !Stylus.Nodes.Block, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Each.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Stylus.Nodes.Expression} cond
 * @param {boolean|!Stylus.Nodes.Block} negate_or_block
 */
Stylus.Nodes.If = function(cond, negate_or_block) {};
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.If.prototype.cond;
 /** @type {!Array<!Stylus.Nodes.Expression>} */
Stylus.Nodes.If.prototype.elses;
 /** @type {!Stylus.Nodes.Block} */
Stylus.Nodes.If.prototype.block;
 /** @type {boolean} */
Stylus.Nodes.If.prototype.negate;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, cond: !Stylus.Nodes.Expression, elses: !Array<!Stylus.Nodes.Expression>, block: !Stylus.Nodes.Block, negate: boolean, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.If.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {!Stylus.Nodes.Expression} args
 */
Stylus.Nodes.Call = function(name, args) {};
 /** @type {string} */
Stylus.Nodes.Call.prototype.name;
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.Call.prototype.args;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, name: string, args: !Stylus.Nodes.Expression, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Call.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} op
 * @param {!Stylus.Nodes.Expression} expr
 */
Stylus.Nodes.UnaryOp = function(op, expr) {};
 /** @type {string} */
Stylus.Nodes.UnaryOp.prototype.op;
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.UnaryOp.prototype.expr;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, op: string, expr: !Stylus.Nodes.Expression, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.UnaryOp.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} op
 * @param {!Stylus.Nodes.Expression} left
 * @param {!Stylus.Nodes.Expression} right
 */
Stylus.Nodes.BinOp = function(op, left, right) {};
 /** @type {string} */
Stylus.Nodes.BinOp.prototype.op;
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.BinOp.prototype.left;
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.BinOp.prototype.right;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, op: string, left: !Stylus.Nodes.Expression, right: !Stylus.Nodes.Expression, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.BinOp.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} op
 * @param {!Stylus.Nodes.Expression} trueExpr
 * @param {!Stylus.Nodes.Expression} falseExpr
 */
Stylus.Nodes.Ternary = function(op, trueExpr, falseExpr) {};
 /** @type {string} */
Stylus.Nodes.Ternary.prototype.op;
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.Ternary.prototype.trueExpr;
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.Ternary.prototype.falseExpr;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, op: string, trueExpr: !Stylus.Nodes.Expression, falseExpr: !Stylus.Nodes.Expression, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Ternary.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Stylus.Nodes.Expression} expr
 */
Stylus.Nodes.Return = function(expr) {};
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.Return.prototype.expr;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, expr: !Stylus.Nodes.Expression, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Return.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} val
 */
Stylus.Nodes.Media = function(val) {};
 /** @type {string} */
Stylus.Nodes.Media.prototype.val;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, val: string, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Media.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 */
Stylus.Nodes.QueryList = function() {};
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.QueryList.prototype.nodes;

/**
 * Push the given `node`.
 * @param {!Stylus.Nodes.Node} node
 * @return {void}
 */
Stylus.Nodes.QueryList.prototype.push = function(node) {};

/**
 * Merges this query list with the `other`.
 * @param {!MediaQueryList} other
 * @return {!MediaQueryList}
 */
Stylus.Nodes.QueryList.prototype.merge = function(other) {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, nodes: !Array<!Stylus.Nodes.Node>, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.QueryList.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 */
Stylus.Nodes.Query = function() {};
 /** @type {!Array<!Stylus.Nodes.QueryExpr>} */
Stylus.Nodes.Query.prototype.nodes;
 /** @type {string} */
Stylus.Nodes.Query.prototype.type;
 /** @type {string} */
Stylus.Nodes.Query.prototype.predicate;
 /** @type {string} */
Stylus.Nodes.Query.prototype.resolvedType;
 /** @type {string} */
Stylus.Nodes.Query.prototype.resolvedPredicate;

/**
 * Push the given `expr`.
 * @param {!Stylus.Nodes.QueryExpr} expr
 * @return {void}
 */
Stylus.Nodes.Query.prototype.push = function(expr) {};

/**
 * Merges this query with the `other`.
 * @param {!Stylus.Nodes.Query} other
 * @return {!Stylus.Nodes.Query}
 */
Stylus.Nodes.Query.prototype.merge = function(other) {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, nodes: !Array<!Stylus.Nodes.QueryExpr>, predicate: string, type: string, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Query.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Array<!Stylus.Nodes.Node>} segs
 */
Stylus.Nodes.QueryExpr = function(segs) {};
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.QueryExpr.prototype.segments;
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.QueryExpr.prototype.expr;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, segments: !Array<!Stylus.Nodes.Node>, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.QueryExpr.prototype.toJSON = function() {};
/**
 * @extends {Stylus.Nodes.Node}
 * @constructor
 * @struct
 */
Stylus.Nodes.Params = function() {};
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.Params.prototype.nodes;
 /** @type {number} */
Stylus.Nodes.Params.prototype.length;

/**
 * Push the given `node`.
 * @param {!Stylus.Nodes.Node} node
 * @return {void}
 */
Stylus.Nodes.Params.prototype.push = function(node) {};

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, nodes: !Array<!Stylus.Nodes.Node>, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Params.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} str
 * @param {boolean} suppress
 * @param {boolean} inline
 */
Stylus.Nodes.Comment = function(str, suppress, inline) {};
 /** @type {string} */
Stylus.Nodes.Comment.prototype.str;
 /** @type {boolean} */
Stylus.Nodes.Comment.prototype.suppress;
 /** @type {boolean} */
Stylus.Nodes.Comment.prototype.inline;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, str: string, suppress: boolean, inline: boolean, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Comment.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Array<!Stylus.Nodes.Node>} segs
 * @param {string=} prefix
 */
Stylus.Nodes.Keyframes = function(segs, prefix) {};
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.Keyframes.prototype.segments;
 /** @type {string} */
Stylus.Nodes.Keyframes.prototype.prefix;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, segments: !Array<!Stylus.Nodes.Node>, prefix: string, block: !Stylus.Nodes.Block, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Keyframes.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Stylus.Nodes.Node} left
 * @param {!Stylus.Nodes.Node} right
 */
Stylus.Nodes.Member = function(left, right) {};
 /** @type {!Stylus.Nodes.Node} */
Stylus.Nodes.Member.prototype.left;
 /** @type {!Stylus.Nodes.Node} */
Stylus.Nodes.Member.prototype.right;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, left: !Stylus.Nodes.Node, right: !Stylus.Nodes.Node, val: string, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Member.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} val
 */
Stylus.Nodes.Charset = function(val) {};
 /** @type {string} */
Stylus.Nodes.Charset.prototype.val;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, val: string, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Charset.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} val
 * @param {string} prefix
 */
Stylus.Nodes.Namespace = function(val, prefix) {};
 /** @type {string} */
Stylus.Nodes.Namespace.prototype.val;
 /** @type {string} */
Stylus.Nodes.Namespace.prototype.prefix;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, val: string, prefix: string, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Namespace.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Stylus.Nodes.Expression} path
 * @param {boolean=} once
 */
Stylus.Nodes.Import = function(path, once) {};
 /** @type {!Stylus.Nodes.Expression} */
Stylus.Nodes.Import.prototype.path;
 /** @type {boolean} */
Stylus.Nodes.Import.prototype.once;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, path: !Stylus.Nodes.Expression, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Import.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Array<!Stylus.Nodes.Selector>} selectors
 */
Stylus.Nodes.Extend = function(selectors) {};
 /** @type {!Array<!Stylus.Nodes.Selector>} */
Stylus.Nodes.Extend.prototype.selectors;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, selectors: !Array<!Stylus.Nodes.Selector>, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Extend.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {!Stylus.Nodes.Params} params
 * @param {!Stylus.Nodes.Block} body
 */
Stylus.Nodes.Function = function(name, params, body) {};
 /** @type {string} */
Stylus.Nodes.Function.prototype.name;
 /** @type {!Stylus.Nodes.Params} */
Stylus.Nodes.Function.prototype.params;
 /** @type {!Stylus.Nodes.Block} */
Stylus.Nodes.Function.prototype.body;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, name: string, params: !Stylus.Nodes.Params, body: !Stylus.Nodes.Block, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Function.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {!Array<!Stylus.Nodes.Node>} segs
 */
Stylus.Nodes.Selector = function(segs) {};
 /** @type {boolean} */
Stylus.Nodes.Selector.prototype.inherits;
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.Selector.prototype.segments;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, segments: !Array<!Stylus.Nodes.Node>, inherits: boolean, val: string, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Selector.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 */
Stylus.Nodes.Arguments = function() {};
 /** @type {!Stylus.Dictionary<!Stylus.Nodes.Node>} */
Stylus.Nodes.Arguments.prototype.map;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, map: !Stylus.Dictionary<!Stylus.Nodes.Node>, isList: boolean, preserve: boolean, nodes: !Array<!Stylus.Nodes.Node>, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Arguments.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 */
Stylus.Nodes.Atblock = function() {};
 /** @type {!Stylus.Nodes.Block} */
Stylus.Nodes.Atblock.prototype.block;
 /** @type {!Array<!Stylus.Nodes.Node>} */
Stylus.Nodes.Atblock.prototype.nodes;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, block: !Stylus.Nodes.Block, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Atblock.prototype.toJSON = function() {};

/**
 * @constructor
 * @struct
 * @param {string} type
 */
Stylus.Nodes.Atrule = function(type) {};
 /** @type {string} */
Stylus.Nodes.Atrule.prototype.type;
 /** @type {boolean} */
Stylus.Nodes.Atrule.prototype.hasOnlyProperties;

/**
 * Return a JSON representation of this node.
 * @return {{___type: string, type: string, segments: !Array<!Stylus.Nodes.Node>, block: !Stylus.Nodes.Block, lineno: number, column: number, filename: string}}
 */
Stylus.Nodes.Atrule.prototype.toJSON = function() {};
/**
 * @record
 * @struct
 */
Stylus.Dictionary = function() {};

/* TODO: IndexSignature: Stylus */
/**
 * @record
 * @struct
 */
Stylus.RenderOptions = function() {};
 /** @type {!Stylus.Dictionary<?>} */
Stylus.RenderOptions.prototype.globals;
 /** @type {!Stylus.Dictionary<?>} */
Stylus.RenderOptions.prototype.functions;
 /** @type {!Array<string>} */
Stylus.RenderOptions.prototype.imports;
 /** @type {!Array<string>} */
Stylus.RenderOptions.prototype.paths;
 /** @type {string} */
Stylus.RenderOptions.prototype.filename;
 /** @type {?} */
Stylus.RenderOptions.prototype.Evaluator;
/**
 * @record
 * @struct
 */
Stylus.RenderCallback = function() {};

/* TODO: CallSignature: Stylus */
/**
 * @record
 * @struct
 */
Stylus.UrlOptions = function() {};
 /** @type {string} */
Stylus.UrlOptions.prototype.limit;
 /** @type {string} */
Stylus.UrlOptions.prototype.path;
/**
 * @record
 * @struct
 */
Stylus.LiteralFunction = function() {};

/* TODO: CallSignature: Stylus */
 /** @type {boolean} */
Stylus.LiteralFunction.prototype.raw;
/**
 * @record
 * @struct
 */
Stylus.ExceptionOptions = function() {};
 /** @type {string} */
Stylus.ExceptionOptions.prototype.filename;
 /** @type {number} */
Stylus.ExceptionOptions.prototype.context;
 /** @type {number} */
Stylus.ExceptionOptions.prototype.lineno;
 /** @type {number} */
Stylus.ExceptionOptions.prototype.column;
 /** @type {string} */
Stylus.ExceptionOptions.prototype.input;
