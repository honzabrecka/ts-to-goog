/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/orchestrator/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */
/**
 * @extends {internal.EventEmitter}
 * @constructor
 * @struct
 */
function Orchestrator() {}
 /** @type {function(?): ?} */
Orchestrator.prototype.doneCallback;
 /** @type {boolean} */
Orchestrator.prototype.isRunning;
 /** @type {!Array<?>} */
Orchestrator.prototype.seq;
 /** @type {!Object<string,!Orchestrator.Task>} */
Orchestrator.prototype.tasks;
 /** @type {!Orchestrator.StartMethod} */
Orchestrator.prototype.start;
 /** @type {function(!Array<{dep: !Array<string>}>, !Array<string>): {sequence: !Array<string>, missingTasks: !Array<string>, recursiveDependencies: !Array<string>}} */
Orchestrator.prototype.sequence;

/**
 * @return {!Orchestrator}
 */
Orchestrator.prototype.reset = function() {};

/**
 * Define a task
 * Define a task
 * @param {string} name The name of the task.
 * @param {function(function(?): void): ?|!Array<string>=} fn_or_deps The function that performs the task's operations. For asynchronous tasks, you need to provide a hint when the task is complete:
 *  - Take in a callback
 *  - Return a stream or a promise / An array of task names to be executed and completed before your task will run.
 * @param {function(function(?): void): ?=} fn The function that performs the task's operations. For asynchronous tasks, you need to provide a hint when the task is complete:
 *  - Take in a callback
 *  - Return a stream or a promise
 * @return {!Orchestrator}
 */
Orchestrator.prototype.add = function(name, fn_or_deps, fn) {};

/**
 * @param {string} name
 * @param {function(function(?): void): ?|!Array<string>=} fn_or_dep
 * @param {function(function(?): void): ?=} fn
 * @return {!Orchestrator.Task|void}
 */
Orchestrator.prototype.task = function(name, fn_or_dep, fn) {};

/**
 * Have you defined a task with this name?
 * @param {string} name The task name to query
 * @return {boolean}
 */
Orchestrator.prototype.hasTask = function(name) {};

/**
 * @param {?=} err
 * @param {boolean=} successfulFinish
 * @return {void}
 */
Orchestrator.prototype.stop = function(err, successfulFinish) {};

/**
 * @return {boolean}
 */
Orchestrator.prototype.allDone = function() {};

/**
 * Listen to orchestrator internals
 * @param {string} event Event name to listen to:
 *  - start: from start() method, shows you the task sequence
 *  - stop: from stop() method, the queue finished successfully
 *  - err: from stop() method, the queue was aborted due to a task error
 *  - task_start: from _runTask() method, task was started
 *  - task_stop: from _runTask() method, task completed successfully
 *  - task_err: from _runTask() method, task errored
 *  - task_not_found: from start() method, you're trying to start a task that doesn't exist
 *  - task_recursion: from start() method, there are recursive dependencies in your task list
 * @param {function(!Orchestrator.OnCallbackEvent): ?} cb Passes single argument: e: event details
 * @return {Orchestrator}
 */
Orchestrator.prototype.on = function(event, cb) {};

/**
 * Listen to all orchestrator events from one callback
 * @param {function(!Orchestrator.OnAllCallbackEvent): ?} cb Passes single argument: e: event details
 * @return {void}
 */
Orchestrator.prototype.onAll = function(cb) {};

/**
 * @param {!Orchestrator.Task} task
 * @return {void}
 */
Orchestrator.prototype._resetTask = function(task) {};

/**
 * @return {void}
 */
Orchestrator.prototype._resetAllTasks = function() {};

/**
 * @param {!Array<string>} names
 * @return {void}
 */
Orchestrator.prototype._resetSpecificTasks = function(names) {};

/**
 * @return {void}
 */
Orchestrator.prototype._runStep = function() {};

/**
 * @param {!Orchestrator.Task} task
 * @return {boolean}
 */
Orchestrator.prototype._readyToRunTask = function(task) {};

/**
 * @param {!Orchestrator.Task} task
 * @param {!Orchestrator.Meta} meta
 * @return {void}
 */
Orchestrator.prototype._stopTask = function(task, meta) {};

/**
 * @param {!Orchestrator.Task} task
 * @param {string} message
 * @param {?=} err
 * @return {void}
 */
Orchestrator.prototype._emitTaskDone = function(task, message, err) {};

/**
 * @param {!Orchestrator.Task} task
 * @return {void}
 */
Orchestrator.prototype._runTask = function(task) {};

/** @typedef {(string|!Array<string>)} */
Orchestrator.Strings;

/** @typedef {function(function(function(?): void): ?, function(?, !Orchestrator.Meta): void): void} */
Orchestrator.RunTask;

/** @typedef {function(!Array<{dep: !Array<string>}>, !Array<string>): {sequence: !Array<string>, missingTasks: !Array<string>, recursiveDependencies: !Array<string>}} */
Orchestrator.Sequencify;

/** @typedef {function(function(?): void): ?} */
Orchestrator.TaskFunc;
/**
 * @record
 * @struct
 */
Orchestrator.AddMethod = function() {};

/* TODO: CallSignature: Orchestrator */

/* TODO: CallSignature: Orchestrator */
/**
 * @record
 * @struct
 */
Orchestrator.StartMethod = function() {};

/* TODO: CallSignature: Orchestrator */

/* TODO: CallSignature: Orchestrator */

/* TODO: CallSignature: Orchestrator */

/* TODO: CallSignature: Orchestrator */

/* TODO: CallSignature: Orchestrator */

/* TODO: CallSignature: Orchestrator */

/* TODO: CallSignature: Orchestrator */
/**
 * @record
 * @struct
 */
Orchestrator.OnCallbackEvent = function() {};
 /** @type {string} */
Orchestrator.OnCallbackEvent.prototype.message;
 /** @type {string} */
Orchestrator.OnCallbackEvent.prototype.task;
 /** @type {?} */
Orchestrator.OnCallbackEvent.prototype.err;
 /** @type {number} */
Orchestrator.OnCallbackEvent.prototype.duration;
/**
 * @extends {Orchestrator.OnCallbackEvent}
 * @record
 * @struct
 */
Orchestrator.OnAllCallbackEvent = function() {};
 /** @type {string} */
Orchestrator.OnAllCallbackEvent.prototype.src;
/**
 * @record
 * @struct
 */
Orchestrator.Task = function() {};
 /** @type {function(function(?): void): ?} */
Orchestrator.Task.prototype.fn;
 /** @type {!Array<string>} */
Orchestrator.Task.prototype.dep;
 /** @type {string} */
Orchestrator.Task.prototype.name;
 /** @type {boolean} */
Orchestrator.Task.prototype.done;
 /** @type {number} */
Orchestrator.Task.prototype.duration;
 /** @type {!Array<?>} */
Orchestrator.Task.prototype.hrDuration;
 /** @type {boolean} */
Orchestrator.Task.prototype.running;
/**
 * @record
 * @struct
 */
Orchestrator.Meta = function() {};
 /** @type {number} */
Orchestrator.Meta.prototype.duration;
 /** @type {!Array<?>} */
Orchestrator.Meta.prototype.hrDuration;
 /** @type {string} */
Orchestrator.Meta.prototype.runMethod;

/** @typedef {string} */
Orchestrator.EventNames;

/* TODO: ExportAssignment in  */
