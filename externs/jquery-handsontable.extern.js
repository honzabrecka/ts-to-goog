/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/jquery-handsontable/index.d.ts:
/** @const */
var Handsontable = {};
/**
 * @record
 * @struct
 */
Handsontable.CellPosition = function() {};
 /** @type {number} */
Handsontable.CellPosition.prototype.row;
 /** @type {number} */
Handsontable.CellPosition.prototype.col;
/**
 * @record
 * @struct
 */
Handsontable.Options = function() {};
 /** @type {?} */
Handsontable.Options.prototype.data;
 /** @type {?} */
Handsontable.Options.prototype.width;
 /** @type {?} */
Handsontable.Options.prototype.height;
 /** @type {number} */
Handsontable.Options.prototype.minRows;
 /** @type {number} */
Handsontable.Options.prototype.minCols;
 /** @type {number} */
Handsontable.Options.prototype.maxRows;
 /** @type {number} */
Handsontable.Options.prototype.maxCols;
 /** @type {number} */
Handsontable.Options.prototype.startRows;
 /** @type {number} */
Handsontable.Options.prototype.startCols;
 /** @type {?} */
Handsontable.Options.prototype.rowHeaders;
 /** @type {?} */
Handsontable.Options.prototype.colHeaders;
 /** @type {?} */
Handsontable.Options.prototype.colWidths;
 /** @type {!Array<?>} */
Handsontable.Options.prototype.columns;
 /** @type {function(number, number, string): void} */
Handsontable.Options.prototype.cells;
 /** @type {?} */
Handsontable.Options.prototype.dataSchema;
 /** @type {number} */
Handsontable.Options.prototype.minSpareRows;
 /** @type {number} */
Handsontable.Options.prototype.minSpareCols;
 /** @type {boolean} */
Handsontable.Options.prototype.multiSelect;
 /** @type {?} */
Handsontable.Options.prototype.fillHandle;
 /** @type {?} */
Handsontable.Options.prototype.contextMenu;
 /** @type {boolean} */
Handsontable.Options.prototype.undo;
 /** @type {boolean} */
Handsontable.Options.prototype.outsideClickDeselects;
 /** @type {boolean} */
Handsontable.Options.prototype.enterBeginsEditing;
 /** @type {?} */
Handsontable.Options.prototype.enterMoves;
 /** @type {?} */
Handsontable.Options.prototype.tabMoves;
 /** @type {boolean} */
Handsontable.Options.prototype.autoWrapRow;
 /** @type {boolean} */
Handsontable.Options.prototype.autoWrapCol;
 /** @type {!Array<?>} */
Handsontable.Options.prototype.autoComplete;
 /** @type {number} */
Handsontable.Options.prototype.copyRowsLimit;
 /** @type {number} */
Handsontable.Options.prototype.copyColsLimit;
 /** @type {string} */
Handsontable.Options.prototype.pasteMode;
 /** @type {string} */
Handsontable.Options.prototype.stretchH;
 /** @type {function(number): boolean} */
Handsontable.Options.prototype.isEmptyRow;
 /** @type {function(number): boolean} */
Handsontable.Options.prototype.isEmptyCol;
 /** @type {?} */
Handsontable.Options.prototype.manualColumnResize;
 /** @type {?} */
Handsontable.Options.prototype.manualColumnMove;
 /** @type {boolean} */
Handsontable.Options.prototype.columnSorting;
 /** @type {boolean} */
Handsontable.Options.prototype.persistentState;
 /** @type {string} */
Handsontable.Options.prototype.currentRowClassName;
 /** @type {string} */
Handsontable.Options.prototype.currentColClassName;
 /** @type {number} */
Handsontable.Options.prototype.fixedRowsTop;
 /** @type {number} */
Handsontable.Options.prototype.fixedColumnsLeft;
 /** @type {boolean} */
Handsontable.Options.prototype.fragmentSelection;
 /** @type {boolean} */
Handsontable.Options.prototype.wordWrap;
 /** @type {string} */
Handsontable.Options.prototype.noWordWrapClassName;
 /** @type {?} */
Handsontable.Options.prototype.placeholder;
 /** @type {string} */
Handsontable.Options.prototype.placeholderCellClassName;
 /** @type {string} */
Handsontable.Options.prototype.invalidCellClassName;
 /** @type {string} */
Handsontable.Options.prototype.readOnlyCellClassName;
 /** @type {boolean} */
Handsontable.Options.prototype.debug;
 /** @type {boolean} */
Handsontable.Options.prototype.observeDOMVisibility;
 /** @type {(boolean|!Object)} */
Handsontable.Options.prototype.autoColumnSize;
 /** @type {boolean} */
Handsontable.Options.prototype.observeChanges;
 /** @type {boolean} */
Handsontable.Options.prototype.manualRowResize;
 /** @type {boolean} */
Handsontable.Options.prototype.manualRowMove;
 /** @type {boolean} */
Handsontable.Options.prototype.copyPaste;
 /** @type {boolean} */
Handsontable.Options.prototype.search;
 /** @type {?} */
Handsontable.Options.prototype.mergeCells;
 /** @type {!Function} */
Handsontable.Options.prototype.beforeInitWalkontable;
 /** @type {!Function} */
Handsontable.Options.prototype.beforeInit;
 /** @type {function(boolean): void} */
Handsontable.Options.prototype.beforeRender;
 /** @type {function(!Array<!Array<?>>, string): void} */
Handsontable.Options.prototype.beforeChange;
 /** @type {!Function} */
Handsontable.Options.prototype.beforeChangeRender;
 /** @type {function(number, boolean): void} */
Handsontable.Options.prototype.beforeColumnSort;
 /** @type {function(!Object): void} */
Handsontable.Options.prototype.beforeSet;
 /** @type {function(number, number, !Object): void} */
Handsontable.Options.prototype.beforeGetCellMeta;
 /** @type {function(!Handsontable.CellPosition, !Handsontable.CellPosition, !Array<!Array<string>>): void} */
Handsontable.Options.prototype.beforeAutofill;
 /** @type {function(!KeyboardEvent): void} */
Handsontable.Options.prototype.beforeKeyDown;
 /** @type {function(?, number, string, string): void} */
Handsontable.Options.prototype.beforeValidate;
 /** @type {!Function} */
Handsontable.Options.prototype.afterInit;
 /** @type {!Function} */
Handsontable.Options.prototype.afterLoadData;
 /** @type {function(boolean): void} */
Handsontable.Options.prototype.afterRender;
 /** @type {function(!Array<?>, string): void} */
Handsontable.Options.prototype.afterChange;
 /** @type {function(number, boolean): void} */
Handsontable.Options.prototype.afterColumnSort;
 /** @type {function(number, number, number, number): void} */
Handsontable.Options.prototype.afterSelection;
 /** @type {function(number, string, number, string): void} */
Handsontable.Options.prototype.afterSelectionByProp;
 /** @type {function(number, number, number, number): void} */
Handsontable.Options.prototype.afterSelectionEnd;
 /** @type {function(number, string, number, string): void} */
Handsontable.Options.prototype.afterSelectionEndByProp;
 /** @type {!Function} */
Handsontable.Options.prototype.afterDeselect;
 /** @type {function(number, number, !Object): void} */
Handsontable.Options.prototype.afterGetCellMeta;
 /** @type {function(number, !HTMLTableHeaderCellElement): void} */
Handsontable.Options.prototype.afterGetColHeader;
 /** @type {function(number, !Object): void} */
Handsontable.Options.prototype.afterGetColWidth;
 /** @type {!Function} */
Handsontable.Options.prototype.afterDestroy;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.afterCreateRow;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.afterCreateCol;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.beforeRemoveRow;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.afterRemoveRow;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.beforeRemoveCol;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.afterRemoveCol;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.afterColumnResize;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.afterColumnMove;
 /** @type {function(number, number, number, number): void} */
Handsontable.Options.prototype.afterCopyLimit;
 /** @type {function(boolean, ?, number, string, string): boolean} */
Handsontable.Options.prototype.afterValidate;
 /** @type {function(!Array<?>): void} */
Handsontable.Options.prototype.beforeSetRangeEnd;
 /** @type {!Function} */
Handsontable.Options.prototype.afterUpdateSettings;
 /** @type {function(!HTMLTableDataCellElement, number, number, string, string, !Object): void} */
Handsontable.Options.prototype.afterRenderer;
 /** @type {function(!MouseEvent, !Handsontable.CellPosition, !HTMLTableDataCellElement): void} */
Handsontable.Options.prototype.afterOnCellMouseDown;
 /** @type {function(!MouseEvent, !Handsontable.CellPosition, !HTMLTableDataCellElement): void} */
Handsontable.Options.prototype.afterOnCellMouseOver;
 /** @type {function(!MouseEvent): void} */
Handsontable.Options.prototype.afterOnCellCornerMouseDown;
 /** @type {!Function} */
Handsontable.Options.prototype.afterScrollVertically;
 /** @type {!Function} */
Handsontable.Options.prototype.afterScrollHorizontally;
 /** @type {!Function} */
Handsontable.Options.prototype.afterCellMetaReset;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.modifyColWidth;
 /** @type {function(number, number): void} */
Handsontable.Options.prototype.modifyRowHeight;
 /** @type {function(number): void} */
Handsontable.Options.prototype.modifyRow;
 /** @type {function(number): void} */
Handsontable.Options.prototype.modifyCol;
 /** @type {!Function} */
Handsontable.Options.prototype.afterSetCellMeta;
 /** @type {function(number, number, number, number): void} */
Handsontable.Options.prototype.onSelection;
 /** @type {function(number, number, number, number): void} */
Handsontable.Options.prototype.onSelectionByProp;
 /** @type {function(number, number, number, number): void} */
Handsontable.Options.prototype.onSelectionEnd;
 /** @type {function(number, number, number, number): void} */
Handsontable.Options.prototype.onSelectionEndByProp;
 /** @type {function(!Array<?>, string): void} */
Handsontable.Options.prototype.onBeforeChange;
 /** @type {function(!Array<?>, string): void} */
Handsontable.Options.prototype.onChange;
 /** @type {function(number, number, number, number): void} */
Handsontable.Options.prototype.onCopyLimit;
/**
 * @record
 * @struct
 */
Handsontable.Context = function() {};

/**
 * Use it if you need to change configuration after initialization.
 * @param {!Handsontable.Options} options
 * @return {void}
 */
Handsontable.Context.prototype.updateSettings = function(options) {};

/**
 * Returns an object containing the current grid settings.
 * @return {!Handsontable.Options}
 */
Handsontable.Context.prototype.getSettings = function() {};

/**
 * Reset all cells in the grid to contain data from the data array.
 * @param {!Array<?>} data
 * @return {void}
 */
Handsontable.Context.prototype.loadData = function(data) {};

/**
 * Listen to keyboard input on document body.
 * @return {void}
 */
Handsontable.Context.prototype.listen = function() {};

/**
 * Returns rederer type/
 * @param {number} row
 * @param {number} col
 * @return {string}
 */
Handsontable.Context.prototype.getCellRenderer = function(row, col) {};

/**
 * Stop listening to keyboard input on document body.
 * @return {void}
 */
Handsontable.Context.prototype.unlisten = function() {};

/**
 * Returns true if current Handsontable instance is listening to keyboard input on document body.
 * @return {boolean}
 */
Handsontable.Context.prototype.isListening = function() {};

/**
 * Rerender the table.
 * @return {void}
 */
Handsontable.Context.prototype.render = function() {};

/**
 * Remove grid from DOM.
 * @return {void}
 */
Handsontable.Context.prototype.destroy = function() {};

/**
 * Validates all cells using their validator functions and calls callback when finished. Does not render the view.
 * @param {!Function} callback
 * @return {void}
 */
Handsontable.Context.prototype.validateCells = function(callback) {};

/**
 * Return the current data object (the same that was passed by data configuration option or loadData method). Optionally you can provide cell range row, col, row2, col2 to get only a fragment of grid data
 * Return the current data object (the same that was passed by data configuration option or loadData method). Optionally you can provide cell range row, col, row2, col2 to get only a fragment of grid data
 * @param {number=} row
 * @param {number=} col
 * @param {number=} row2
 * @param {number=} col2
 * @return {?}
 */
Handsontable.Context.prototype.getData = function(row, col, row2, col2) {};

/**
 * Return cell value at row, col. row and col are the visible indexes (note that if columns were reordered or sorted, the current order will be used).
 * @param {number} row
 * @param {number} col
 * @return {?}
 */
Handsontable.Context.prototype.getDataAtCell = function(row, col) {};

/**
 * Same as getDataAtCell, except instead of col, you provide name of the object property (e.g. 'first.name').
 * @param {number} row
 * @param {string} prop
 * @return {?}
 */
Handsontable.Context.prototype.getDataAtRowProp = function(row, prop) {};

/**
 * Returns a single row of the data (array or object, depending on what you have). row is the visible index of the row
 * @param {number} row
 * @return {?}
 */
Handsontable.Context.prototype.getDataAtRow = function(row) {};

/**
 * Returns a single row of the data (array or object, depending on what you have). row is the index of the row in the data source.
 * @param {number} row
 * @return {?}
 */
Handsontable.Context.prototype.getSourceDataAtRow = function(row) {};

/**
 * Returns array of column values from the data source. col is the visible index of the column.
 * @param {number} col
 * @return {!Array<?>}
 */
Handsontable.Context.prototype.getDataAtCol = function(col) {};

/**
 * Returns array of column values from the data source. col is the index of the row in the data source.
 * @param {number} col
 * @return {!Array<?>}
 */
Handsontable.Context.prototype.getSourceDataAtCol = function(col) {};

/**
 * Given the object property name (e.g. 'first.name'), returns array of column values from the data source.
 * @param {string} prop
 * @return {!Array<?>}
 */
Handsontable.Context.prototype.getDataAtProp = function(prop) {};

/**
 * Get value of selected range. Each column is separated by tab, each row is separated by new line character.
 * @param {number} startRow
 * @param {number} startCol
 * @param {number} endRow
 * @param {number} endCol
 * @return {?}
 */
Handsontable.Context.prototype.getCopyableData = function(startRow, startCol, endRow, endCol) {};

/**
 * Returns value of selected cell.
 * @return {?}
 */
Handsontable.Context.prototype.getValue = function() {};

/**
 * Set new value to a cell. To change many cells at once, pass an array of changes in format [ [row, col, value], ... ] as the only parameter. col is the index of visible column (note that if columns were reordered, the current order will be used). source is a flag for before/afterChange events. If you pass only array of changes then source could be set as second parameter.
 * Set new value to a cell. To change many cells at once, pass an array of changes in format [ [row, col, value], ... ] as the only parameter. col is the index of visible column (note that if columns were reordered, the current order will be used). source is a flag for before/afterChange events. If you pass only array of changes then source could be set as second parameter.
 * @param {number|!Array<?>} row_or_changes
 * @param {number|string=} col_or_source
 * @param {?=} value
 * @param {string=} source
 * @return {void}
 */
Handsontable.Context.prototype.setDataAtCell = function(row_or_changes, col_or_source, value, source) {};

/**
 * Same as above, except instead of col, you provide name of the object property (e.g. [0, 'first.name', 'Jennifer']).
 * Same as above, except instead of col, you provide name of the object property (e.g. [0, 'first.name', 'Jennifer']).
 * @param {number|!Array<?>} row_or_changes
 * @param {string=} prop_or_source
 * @param {?=} value
 * @param {string=} source
 * @return {void}
 */
Handsontable.Context.prototype.setDataAtRowProp = function(row_or_changes, prop_or_source, value, source) {};

/**
 * Populate cells at position with 2D input array (e.g. [ [1, 2], [3, 4] ]).
 * Use endRow, endCol when you want to cut input when certain row is reached.
 * @param {number} row
 * @param {number} col
 * @param {!Array<?>} input
 * @param {number} endRow
 * @param {number} endCol
 * @param {string=} source (default value "populateFromArray") is used to identify this call in the resulting events (beforeChange, afterChange).
 * @param {string=} populateMethod (default value "overwrite", possible values "shift_down" and "shift_right") has the same effect as pasteMethod option (see Options page).
 * @return {void}
 */
Handsontable.Context.prototype.populateFromArray = function(row, col, input, endRow, endCol, source, populateMethod) {};

/**
 * Adds/removes data from the column. This function works is modelled after Array.splice. Parameter col is the index of column in which do you want to do splice. Parameter index is the row index at which to start changing the array. If negative, will begin that many elements from the end. Parameter amount, is the number of old array elements to remove. If the amount is 0, no elements are removed. Fourth and further parameters are the elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.
 * @param {number} col
 * @param {number} index
 * @param {number} amount
 * @param {...?} elements
 * @return {void}
 */
Handsontable.Context.prototype.spliceCol = function(col, index, amount, elements) {};

/**
 * Adds/removes data from the row. This function works is modelled after Array.splice. Parameter row is the index of row in which do you want to do splice. Parameter index is the column index at which to start changing the array. If negative, will begin that many elements from the end. Parameter amount, is the number of old array elements to remove. If the amount is 0, no elements are removed. Fourth and further parameters are the elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.
 * @param {number} row
 * @param {number} index
 * @param {number} amount
 * @param {...?} elements
 * @return {void}
 */
Handsontable.Context.prototype.spliceRow = function(row, index, amount, elements) {};

/**
 * Insert new row(s) above the row at given index. If index is null or undefined, the new row will be added after the current last row. Default amount equals 1.
 * Insert new column(s) before the column at given index. If index is null or undefined, the new column will be added after the current last column. Default amount equals 1.
 * Remove the row(s) at given index. Default amount equals 1.
 * Remove the column(s) at given index. Default amount equals 1.
 * @param {string} type
 * @param {number} index
 * @param {number=} amount
 * @param {string=} source
 * @return {void}
 */
Handsontable.Context.prototype.alter = function(type, index, amount, source) {};

/**
 * Returns TD element for given row, col if it is rendered on screen.
 * Returns null if the TD is not rendered on screen (probably because that part of table is not visible).
 * @param {number} row
 * @param {number} col
 * @return {?}
 */
Handsontable.Context.prototype.getCell = function(row, col) {};

/**
 * Return cell properties for given row, col coordinates.
 * @param {number} row
 * @param {number} col
 * @return {?}
 */
Handsontable.Context.prototype.getCellMeta = function(row, col) {};

/**
 * Sets cell meta data object key corresponding to params row, col.
 * @param {number} row
 * @param {number} col
 * @param {string} key
 * @param {string} val
 * @return {void}
 */
Handsontable.Context.prototype.setCellMeta = function(row, col, key, val) {};

/**
 * Destroys current editor, renders and selects current cell. If revertOriginal == false, edited data is saved. Otherwise previous value is restored.
 * @param {boolean=} revertOriginal
 * @return {void}
 */
Handsontable.Context.prototype.destroyEditor = function(revertOriginal) {};

/**
 * Select cell row, col or range finishing at row2, col2. By default, viewport will be scrolled to selection.
 * @param {number} row
 * @param {number} col
 * @param {number} row2
 * @param {number} col2
 * @param {boolean=} scrollToSelection
 * @return {void}
 */
Handsontable.Context.prototype.selectCell = function(row, col, row2, col2, scrollToSelection) {};

/**
 * Deselect current selection.
 * @return {void}
 */
Handsontable.Context.prototype.deselectCell = function() {};

/**
 * Return index of the currently selected cells as an array [startRow, startCol, endRow, endCol]. Start row and start col are the coordinates of the active cell (where the selection was started).
 * @return {!Array<number>}
 */
Handsontable.Context.prototype.getSelected = function() {};

/**
 * Returns current selection as a WalkontableCellRange object. Returns undefined if there is no selection.
 * @return {void}
 */
Handsontable.Context.prototype.getSelectedRange = function() {};

/**
 * Clears grid.
 * @return {void}
 */
Handsontable.Context.prototype.clear = function() {};

/**
 * Returns total number of rows in the grid.
 * @return {number}
 */
Handsontable.Context.prototype.countRows = function() {};

/**
 * Returns total number of columns in the grid.
 * @return {number}
 */
Handsontable.Context.prototype.countCols = function() {};

/**
 * Returns property name that corresponds with the given column index.
 * @param {number} column
 * @return {string}
 */
Handsontable.Context.prototype.colToProp = function(column) {};

/**
 * Returns index of first visible row.
 * @return {number}
 */
Handsontable.Context.prototype.rowOffset = function() {};

/**
 * Returns index of first visible column.
 * @return {number}
 */
Handsontable.Context.prototype.colOffset = function() {};

/**
 * Returns number of visible rows.
 * @return {number}
 */
Handsontable.Context.prototype.countVisibleRows = function() {};

/**
 * Returns number of visible columns.
 * @return {number}
 */
Handsontable.Context.prototype.countVisibleCols = function() {};

/**
 * Returns number of empty rows. If the optional ending parameter is true, returns number of empty rows at the bottom of the table.
 * @param {boolean=} ending
 * @return {number}
 */
Handsontable.Context.prototype.countEmptyRows = function(ending) {};

/**
 * Returns number of empty columns.If the optional ending parameter is true, returns number of empty columns at right hand edge of the table.
 * @param {boolean=} ending
 * @return {number}
 */
Handsontable.Context.prototype.countEmptyCols = function(ending) {};

/**
 * Returns true if the row at the given index is empty, false otherwise.
 * @param {number} row
 * @return {boolean}
 */
Handsontable.Context.prototype.isEmptyRow = function(row) {};

/**
 * Returns true if the column at the given index is empty, false otherwise.
 * @param {number} col
 * @return {boolean}
 */
Handsontable.Context.prototype.isEmptyCol = function(col) {};

/**
 * Returns array of row headers (if they are enabled). If param row given, return header at given row as string.
 * @param {number} row
 * @return {?}
 */
Handsontable.Context.prototype.getRowHeader = function(row) {};

/**
 * Returns array of col headers (if they are enabled). If param col given, return header at given col as string.
 * @param {number} col
 * @return {?}
 */
Handsontable.Context.prototype.getColHeader = function(col) {};

/**
 * Returns information of this table is configured to display row headers.
 * @return {boolean}
 */
Handsontable.Context.prototype.hasRowHeaders = function() {};

/**
 * Returns information of this table is configured to display column headers.
 * @return {boolean}
 */
Handsontable.Context.prototype.hasColHeaders = function() {};

/**
 * Return column width.
 * @param {number} col
 * @return {number}
 */
Handsontable.Context.prototype.getColWidth = function(col) {};

/**
 * Return row height.
 * @param {number} row
 * @return {number}
 */
Handsontable.Context.prototype.getRowHeight = function(row) {};

/**
 * Returns column index that corresponds with the given property.
 * @param {string} property
 * @return {number}
 */
Handsontable.Context.prototype.propToCol = function(property) {};

/**
 * Clear undo history.
 * @return {void}
 */
Handsontable.Context.prototype.clearUndo = function() {};

/**
 * Return true if undo can be performed, false otherwise.
 * @return {boolean}
 */
Handsontable.Context.prototype.isUndoAvailable = function() {};

/**
 * Return true if redo can be performed, false otherwise.
 * @return {boolean}
 */
Handsontable.Context.prototype.isRedoAvailable = function() {};

/**
 * Undo last edit.
 * @return {void}
 */
Handsontable.Context.prototype.undo = function() {};

/**
 * Redo edit (used to reverse an undo).
 * @return {void}
 */
Handsontable.Context.prototype.redo = function() {};

/**
 * Sorts table content by cell values in given column, using order. column is a zero-based column index. Order of sorting can be either ascending (order = true) or descending (order = false).
 * Note I: This method is only available when coulmnSorting plugin is enabled. See column sorting demo for details.
 * Note II: Running this method will not alter the table data. Sorting takes place only in view layer.
 * @param {number} column
 * @param {boolean} order
 * @return {void}
 */
Handsontable.Context.prototype.sort = function(column, order) {};

/**
 * @param {string|!Handsontable.Options=} methodName_or_options
 * @param {...?} tsickle_arguments
 * @return {?<!HTMLElement>|?}
 */
JQuery.prototype.handsontable = function(methodName_or_options, tsickle_arguments) {};
