/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/signalr/index.d.ts:
/** @const */
var SignalR = {};

/** @const */
SignalR.ConnectionState = {};
/** @const {number} */
SignalR.ConnectionState.Connecting;
/** @const {number} */
SignalR.ConnectionState.Connected;
/** @const {number} */
SignalR.ConnectionState.Reconnecting;
/** @const {number} */
SignalR.ConnectionState.Disconnected;
/**
 * @record
 * @struct
 */
SignalR.AvailableEvents = function() {};
 /** @type {string} */
SignalR.AvailableEvents.prototype.onStart;
 /** @type {string} */
SignalR.AvailableEvents.prototype.onStarting;
 /** @type {string} */
SignalR.AvailableEvents.prototype.onReceived;
 /** @type {string} */
SignalR.AvailableEvents.prototype.onError;
 /** @type {string} */
SignalR.AvailableEvents.prototype.onConnectionSlow;
 /** @type {string} */
SignalR.AvailableEvents.prototype.onReconnect;
 /** @type {string} */
SignalR.AvailableEvents.prototype.onStateChanged;
 /** @type {string} */
SignalR.AvailableEvents.prototype.onDisconnect;
/**
 * @record
 * @struct
 */
SignalR.Transport = function() {};
 /** @type {string} */
SignalR.Transport.prototype.name;

/**
 * @return {boolean}
 */
SignalR.Transport.prototype.supportsKeepAlive = function() {};

/**
 * @param {!SignalR.Connection} connection
 * @param {?} data
 * @return {void}
 */
SignalR.Transport.prototype.send = function(connection, data) {};

/**
 * @param {!SignalR.Connection} connection
 * @param {function(): void} onSuccess
 * @param {function(!SignalR.ConnectionError): void} onFailed
 * @return {void}
 */
SignalR.Transport.prototype.start = function(connection, onSuccess, onFailed) {};

/**
 * @param {!SignalR.Connection} connection
 * @return {void}
 */
SignalR.Transport.prototype.reconnect = function(connection) {};

/**
 * @param {!SignalR.Connection} connection
 * @return {void}
 */
SignalR.Transport.prototype.lostConnection = function(connection) {};

/**
 * @param {!SignalR.Connection} connection
 * @return {void}
 */
SignalR.Transport.prototype.stop = function(connection) {};

/**
 * @param {!SignalR.Connection} connection
 * @param {boolean} async
 * @return {void}
 */
SignalR.Transport.prototype.abort = function(connection, async) {};
/**
 * @record
 * @struct
 */
SignalR.Transports = function() {};
 /** @type {!SignalR.Transport} */
SignalR.Transports.prototype.foreverFrame;
 /** @type {!SignalR.Transport} */
SignalR.Transports.prototype.longPolling;
 /** @type {!SignalR.Transport} */
SignalR.Transports.prototype.serverSentEvents;
 /** @type {!SignalR.Transport} */
SignalR.Transports.prototype.webSockets;
/** @const */
SignalR.Hub = {};
/**
 * @record
 * @struct
 */
SignalR.Hub.Proxy = function() {};
 /** @type {?} */
SignalR.Hub.Proxy.prototype.state;
 /** @type {!SignalR.Hub.Connection} */
SignalR.Hub.Proxy.prototype.connection;
 /** @type {string} */
SignalR.Hub.Proxy.prototype.hubName;

/**
 * @param {!SignalR.Hub.Connection} connection
 * @param {string} hubName
 * @return {void}
 */
SignalR.Hub.Proxy.prototype.init = function(connection, hubName) {};

/**
 * @return {boolean}
 */
SignalR.Hub.Proxy.prototype.hasSubscriptions = function() {};

/**
 * Wires up a callback to be invoked when a invocation request is received from the server hub.
 * 
 * @param {string} eventName The name of the hub event to register the callback for.
 * @param {function(!Array<?>): void} callback The callback to be invoked.
 * @return {!SignalR.Hub.Proxy}
 */
SignalR.Hub.Proxy.prototype.on = function(eventName, callback) {};

/**
 * Removes the callback invocation request from the server hub for the given event name.
 * 
 * @param {string} eventName The name of the hub event to unregister the callback for.
 * @param {function(!Array<?>): void} callback The callback to be invoked.
 * @return {!SignalR.Hub.Proxy}
 */
SignalR.Hub.Proxy.prototype.off = function(eventName, callback) {};

/**
 * Invokes a server hub method with the given arguments.
 * 
 * @param {string} methodName The name of the server hub method.
 * @param {...?} args
 * @return {!JQueryPromise<?>}
 */
SignalR.Hub.Proxy.prototype.invoke = function(methodName, args) {};
/**
 * @record
 * @struct
 */
SignalR.Hub.Options = function() {};
 /** @type {string} */
SignalR.Hub.Options.prototype.qs;
 /** @type {boolean} */
SignalR.Hub.Options.prototype.logging;
 /** @type {boolean} */
SignalR.Hub.Options.prototype.useDefaultPath;
/**
 * @record
 * @struct
 */
SignalR.Hub.ClientHubInvocation = function() {};
 /** @type {string} */
SignalR.Hub.ClientHubInvocation.prototype.Hub;
 /** @type {string} */
SignalR.Hub.ClientHubInvocation.prototype.Method;
 /** @type {string} */
SignalR.Hub.ClientHubInvocation.prototype.Args;
 /** @type {string} */
SignalR.Hub.ClientHubInvocation.prototype.State;
/**
 * @extends {SignalR.Connection}
 * @record
 * @struct
 */
SignalR.Hub.Connection = function() {};
 /** @type {!Object<string,?>} */
SignalR.Hub.Connection.prototype.proxies;
 /** @type {{name: string, supportsKeepAlive: function(): boolean}} */
SignalR.Hub.Connection.prototype.transport;

/**
 * Creates a new proxy object for the given hub connection that can be used to invoke
 * methods on server hubs and handle client method invocation requests from the server.
 * 
 * @param {string} hubName The name of the hub on the server to create the proxy for.
 * @return {!SignalR.Hub.Proxy}
 */
SignalR.Hub.Connection.prototype.createHubProxy = function(hubName) {};
/**
 * @record
 * @struct
 */
SignalR.Hub.HubCreator = function() {};

/* TODO: CallSignature: SignalR.Hub */
/**
 * @record
 * @struct
 */
SignalR.Hub.IHub = function() {};

/**
 * @return {void}
 */
SignalR.Hub.IHub.prototype.start = function() {};
/**
 * @record
 * @struct
 */
SignalR.StateChanged = function() {};
 /** @type {number} */
SignalR.StateChanged.prototype.oldState;
 /** @type {number} */
SignalR.StateChanged.prototype.newState;
/**
 * @record
 * @struct
 */
SignalR.ConnectionStates = function() {};
 /** @type {number} */
SignalR.ConnectionStates.prototype.connecting;
 /** @type {number} */
SignalR.ConnectionStates.prototype.connected;
 /** @type {number} */
SignalR.ConnectionStates.prototype.reconnecting;
 /** @type {number} */
SignalR.ConnectionStates.prototype.disconnected;
/**
 * @record
 * @struct
 */
SignalR.Resources = function() {};
 /** @type {string} */
SignalR.Resources.prototype.nojQuery;
 /** @type {string} */
SignalR.Resources.prototype.noTransportOnInit;
 /** @type {string} */
SignalR.Resources.prototype.errorOnNegotiate;
 /** @type {string} */
SignalR.Resources.prototype.stoppedWhileLoading;
 /** @type {string} */
SignalR.Resources.prototype.stoppedWhileNegotiating;
 /** @type {string} */
SignalR.Resources.prototype.errorParsingNegotiateResponse;
 /** @type {string} */
SignalR.Resources.prototype.errorDuringStartRequest;
 /** @type {string} */
SignalR.Resources.prototype.stoppedDuringStartRequest;
 /** @type {string} */
SignalR.Resources.prototype.errorParsingStartResponse;
 /** @type {string} */
SignalR.Resources.prototype.invalidStartResponse;
 /** @type {string} */
SignalR.Resources.prototype.protocolIncompatible;
 /** @type {string} */
SignalR.Resources.prototype.sendFailed;
 /** @type {string} */
SignalR.Resources.prototype.parseFailed;
 /** @type {string} */
SignalR.Resources.prototype.longPollFailed;
 /** @type {string} */
SignalR.Resources.prototype.eventSourceFailedToConnect;
 /** @type {string} */
SignalR.Resources.prototype.eventSourceError;
 /** @type {string} */
SignalR.Resources.prototype.webSocketClosed;
 /** @type {string} */
SignalR.Resources.prototype.pingServerFailedInvalidResponse;
 /** @type {string} */
SignalR.Resources.prototype.pingServerFailed;
 /** @type {string} */
SignalR.Resources.prototype.pingServerFailedStatusCode;
 /** @type {string} */
SignalR.Resources.prototype.pingServerFailedParse;
 /** @type {string} */
SignalR.Resources.prototype.noConnectionTransport;
 /** @type {string} */
SignalR.Resources.prototype.webSocketsInvalidState;
 /** @type {string} */
SignalR.Resources.prototype.reconnectTimeout;
 /** @type {string} */
SignalR.Resources.prototype.reconnectWindowTimeout;
/**
 * @record
 * @struct
 */
SignalR.AjaxDefaults = function() {};
 /** @type {boolean} */
SignalR.AjaxDefaults.prototype.processData;
 /** @type {number} */
SignalR.AjaxDefaults.prototype.timeout;
 /** @type {boolean} */
SignalR.AjaxDefaults.prototype.async;
 /** @type {boolean} */
SignalR.AjaxDefaults.prototype.global;
 /** @type {boolean} */
SignalR.AjaxDefaults.prototype.cache;
/**
 * @record
 * @struct
 */
SignalR.ConnectionOptions = function() {};
 /** @type {(string|!SignalR.Transport|!Array<string>)} */
SignalR.ConnectionOptions.prototype.transport;
 /** @type {!Function} */
SignalR.ConnectionOptions.prototype.callback;
 /** @type {boolean} */
SignalR.ConnectionOptions.prototype.waitForPageLoad;
 /** @type {boolean} */
SignalR.ConnectionOptions.prototype.jsonp;
 /** @type {number} */
SignalR.ConnectionOptions.prototype.pingInterval;
 /** @type {boolean} */
SignalR.ConnectionOptions.prototype.withCredentials;
/**
 * @record
 * @struct
 */
SignalR.SimplifyLocation = function() {};
 /** @type {string} */
SignalR.SimplifyLocation.prototype.protocol;
 /** @type {string} */
SignalR.SimplifyLocation.prototype.host;
/**
 * @record
 * @struct
 */
SignalR.ConnectionErrorContext = function() {};
 /** @type {number} */
SignalR.ConnectionErrorContext.prototype.readyState;
 /** @type {string} */
SignalR.ConnectionErrorContext.prototype.responseText;
 /** @type {number} */
SignalR.ConnectionErrorContext.prototype.status;
 /** @type {string} */
SignalR.ConnectionErrorContext.prototype.statusText;
/**
 * @record
 * @struct
 */
SignalR.ConnectionError = function() {};
 /** @type {!SignalR.ConnectionErrorContext} */
SignalR.ConnectionError.prototype.context;
 /** @type {string} */
SignalR.ConnectionError.prototype.transport;
 /** @type {string} */
SignalR.ConnectionError.prototype.source;
/**
 * @record
 * @struct
 */
SignalR.Connection = function() {};
 /** @type {string} */
SignalR.Connection.prototype.clientProtocol;
 /** @type {string} */
SignalR.Connection.prototype.ajaxDataType;
 /** @type {string} */
SignalR.Connection.prototype.contentType;
 /** @type {string} */
SignalR.Connection.prototype.id;
 /** @type {!JSON} */
SignalR.Connection.prototype.json;
 /** @type {boolean} */
SignalR.Connection.prototype.logging;
 /** @type {string} */
SignalR.Connection.prototype.url;
 /** @type {(string|!Object)} */
SignalR.Connection.prototype.qs;
 /** @type {number} */
SignalR.Connection.prototype.state;
 /** @type {number} */
SignalR.Connection.prototype.reconnectDelay;
 /** @type {number} */
SignalR.Connection.prototype.transportConnectTimeout;
 /** @type {number} */
SignalR.Connection.prototype.disconnectTimeout;
 /** @type {number} */
SignalR.Connection.prototype.reconnectWindow;
 /** @type {number} */
SignalR.Connection.prototype.keepAliveWarnAt;
 /** @type {!SignalR.Hub.Connection} */
SignalR.Connection.prototype.hub;
 /** @type {!SignalR.ConnectionError} */
SignalR.Connection.prototype.lastError;
 /** @type {!SignalR.Resources} */
SignalR.Connection.prototype.resources;

/**
 * Starts the connection
 * Starts the connection
 * 
 * Starts the connection
 * 
 * Starts the connection
 * 
 * @param {function(): void|!SignalR.ConnectionOptions=} callback_or_options A callback function to execute when the connection has started / Options map
 * @param {function(): void=} callback
 * @return {!JQueryPromise<?>}
 */
SignalR.Connection.prototype.start = function(callback_or_options, callback) {};

/**
 * Adds a callback that will be invoked before anything is sent over the connection
 * 
 * @param {function(): void} callback
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.starting = function(callback) {};

/**
 * Sends data over the connection
 * 
 * @param {string} data
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.send = function(data) {};

/**
 * Adds a callback that will be invoked after anything is received over the connection
 * 
 * @param {function(?): void} callback
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.received = function(callback) {};

/**
 * Adds a callback that will be invoked when the connection state changes
 * 
 * @param {function(!SignalR.StateChanged): void} callback
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.stateChanged = function(callback) {};

/**
 * Adds a callback that will be invoked after an error occurs with the connection
 * 
 * @param {function(!SignalR.ConnectionError): void} callback
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.error = function(callback) {};

/**
 * Adds a callback that will be invoked when the client disconnects
 * 
 * @param {function(): void} callback
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.disconnected = function(callback) {};

/**
 * Adds a callback that will be invoked when the client detects a slow connection
 * 
 * @param {function(): void} callback
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.connectionSlow = function(callback) {};

/**
 * Adds a callback that will be invoked when the underlying transport begins reconnecting
 * 
 * @param {function(): void} callback
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.reconnecting = function(callback) {};

/**
 * Adds a callback that will be invoked when the underlying transport reconnects
 * 
 * @param {function(): void} callback
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.reconnected = function(callback) {};

/**
 * Stops listening
 * 
 * @param {boolean=} async Whether or not to asynchronously abort the connection
 * @param {boolean=} notifyServer Whether we want to notify the server that we are aborting the connection
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.stop = function(async, notifyServer) {};

/**
 * @param {string} msg
 * @return {!SignalR.Connection}
 */
SignalR.Connection.prototype.log = function(msg) {};

/**
 * Checks if url is cross domain
 * 
 * @param {string} url The base URL
 * @param {(!Location|!SignalR.SimplifyLocation)=} against An optional argument to compare the URL against, if not specified it will be set to window.location. If specified it must contain a protocol and a host property.
 * @return {boolean}
 */
SignalR.Connection.prototype.isCrossDomain = function(url, against) {};

/* TODO: CallSignature:  */
 /** @type {!SignalR.AjaxDefaults} */
SignalR.prototype.ajaxDefaults;
 /** @type {!SignalR.ConnectionStates} */
SignalR.prototype.connectionState;
 /** @type {!SignalR.AvailableEvents} */
SignalR.prototype.events;
 /** @type {!SignalR.Transports} */
SignalR.prototype.transports;
 /** @type {!SignalR.Hub.Connection} */
SignalR.prototype.hub;
 /** @type {!SignalR.Hub.HubCreator} */
SignalR.prototype.hubConnection;
 /** @type {string} */
SignalR.prototype.version;

/**
 * @param {!SignalR.Connection} connection
 * @param {number} expectedState
 * @param {number} newState
 * @return {void}
 */
SignalR.prototype.changeState = function(connection, expectedState, newState) {};

/**
 * @param {!SignalR.Connection} connection
 * @return {boolean}
 */
SignalR.prototype.isDisconnecting = function(connection) {};

/**
 *   Reinstates the original value of $.connection and returns the signalR object for manual assignment.
 * @return {!SignalR.Connection}
 */
SignalR.prototype.noConflict = function() {};
 /** @type {?} */
JQueryStatic.prototype.signalR;
 /** @type {?} */
JQueryStatic.prototype.connection;
 /** @type {!SignalR.Hub.HubCreator} */
JQueryStatic.prototype.hubConnection;
