/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/node-schedule/index.d.ts:

/* TODO: ImportDeclaration in  */

/** @typedef {?} */
var JobCallback;

/**
 * @constructor
 * @struct
 * Use the function scheduleJob() to create new Job objects.
 * 
 * \@internal
 * @param {(string|?)} name
 * @param {?=} job
 * @param {?=} callback
 */
function Job(name, job, callback) {}
 /** @type {string} */
Job.prototype.name;

/**
 * Adds an Invocation to this job. For internal use.
 * \@internal
 * @param {?} invocation
 * @return {boolean}
 */
Job.prototype.trackInvocation = function(invocation) {};

/**
 * removes an Invocation from this Job's tracking list. For internal use.
 * \@internal
 * @param {?} invocation
 * @return {boolean} boolean whether the invocation was successful. Removing an Invocation that doesn't exist, returns false.
 */
Job.prototype.stopTrackingInvocation = function(invocation) {};

/**
 * \@internal
 * @return {number}
 */
Job.prototype.triggeredJobs = function() {};

/**
 * set the number of currently running Jobs.
 * \@internal
 * @param {number} triggeredJobs
 * @return {void}
 */
Job.prototype.setTriggeredJobs = function(triggeredJobs) {};

/**
 * cancel all pending Invocations of this Job.
 * @param {boolean=} reschedule
 * @return {boolean}
 */
Job.prototype.cancel = function(reschedule) {};

/**
 * cancel the next Invocation of this Job.
 * @param {boolean=} reschedule
 * @return {boolean}
 */
Job.prototype.cancelNext = function(reschedule) {};

/**
 * Changes the scheduling information for this Job.
 * @param {(string|number|?)} spec
 * @return {boolean}
 */
Job.prototype.reschedule = function(spec) {};

/**
 * Returns the Date on which this Job will be run next.
 * @return {!Date}
 */
Job.prototype.nextInvocation = function() {};

/**
 * @return {!Array<?>} Invocation[] a list of all pending Invocations
 */
Job.prototype.pendingInvocations = function() {};

/**
 * run this Job immediately.
 * @return {void}
 */
Job.prototype.invoke = function() {};

/**
 * schedule this Job to be run on the specified date.
 * @param {!Date} date {Date}
 * @return {void}
 */
Job.prototype.runOnDate = function(date) {};

/**
 * set scheduling information
 * @param {(string|number|!Date)} date
 * @return {boolean}
 */
Job.prototype.schedule = function(date) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 * @param {number=} start
 * @param {number=} end
 * @param {number=} step
 */
function Range(start, end, step) {}

/**
 * Return a {boolean} if the class contains the specified value.
 * 
 * @param {number} value
 * @return {boolean}
 */
Range.prototype.contains = function(value) {};

/** @typedef {(string|number|?)} */
var Recurrence;

/** @typedef {(string|number|?|!Array<(string|number|?)>)} */
var RecurrenceSegment;

/**
 * @constructor
 * @struct
 * @param {(string|number|?|!Array<(string|number|?)>)=} year
 * @param {(string|number|?|!Array<(string|number|?)>)=} month
 * @param {(string|number|?|!Array<(string|number|?)>)=} date
 * @param {(string|number|?|!Array<(string|number|?)>)=} dayOfWeek
 * @param {(string|number|?|!Array<(string|number|?)>)=} hour
 * @param {(string|number|?|!Array<(string|number|?)>)=} minute
 * @param {(string|number|?|!Array<(string|number|?)>)=} second
 */
function RecurrenceRule(year, month, date, dayOfWeek, hour, minute, second) {}
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceRule.prototype.date;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceRule.prototype.dayOfWeek;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceRule.prototype.hour;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceRule.prototype.minute;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceRule.prototype.month;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceRule.prototype.second;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceRule.prototype.year;

/**
 * @param {!Date} base
 * @return {!Date}
 */
RecurrenceRule.prototype.nextInvocationDate = function(base) {};
/**
 * @record
 * @struct
 */
function RecurrenceSpecDateRange() {}
 /** @type {(string|number|!Date)} */
RecurrenceSpecDateRange.prototype.start;
 /** @type {(string|number|!Date)} */
RecurrenceSpecDateRange.prototype.end;
 /** @type {string} */
RecurrenceSpecDateRange.prototype.rule;
/**
 * @record
 * @struct
 */
function RecurrenceSpecObjLit() {}
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceSpecObjLit.prototype.date;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceSpecObjLit.prototype.dayOfWeek;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceSpecObjLit.prototype.hour;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceSpecObjLit.prototype.minute;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceSpecObjLit.prototype.month;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceSpecObjLit.prototype.second;
 /** @type {(string|number|?|!Array<(string|number|?)>)} */
RecurrenceSpecObjLit.prototype.year;

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 * @param {?} job
 * @param {!Date} fireDate
 * @param {?} recurrenceRule
 */
function Invocation(job, fireDate, recurrenceRule) {}
 /** @type {!Date} */
Invocation.prototype.fireDate;
 /** @type {?} */
Invocation.prototype.job;
 /** @type {?} */
Invocation.prototype.recurrenceRule;
 /** @type {number} */
Invocation.prototype.timerID;

/**
 * Create a schedule job.
 * 
 * Create a schedule job.
 * 
 * @param {string|(string|?|!Date)} name_or_rule
 * @param {(string|?|!Date)|?} rule_or_callback
 * @param {?=} callback
 * @return {?}
 */
function scheduleJob(name_or_rule, rule_or_callback, callback) {}

/**
 * Changes the timing of a Job, canceling all pending invocations.
 * 
 * @param {(string|?)} job
 * @param {(string|?|!Date)} spec
 * @return {?}
 */
function rescheduleJob(job, spec) {}
 /** @type {?} */
var scheduledJobs;

/**
 * Cancels the job.
 * 
 * @param {(string|?)} job
 * @return {boolean}
 */
function cancelJob(job) {}
