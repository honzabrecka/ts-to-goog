/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/graphlib/index.d.ts:
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "graphlib"
/** @const */
tsickle_declare_module.graphlib = {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.graphlib.GraphOptions = function() {};
 /** @type {boolean} */
tsickle_declare_module.graphlib.GraphOptions.prototype.directed;
 /** @type {boolean} */
tsickle_declare_module.graphlib.GraphOptions.prototype.multigraph;
 /** @type {boolean} */
tsickle_declare_module.graphlib.GraphOptions.prototype.compound;
/**
 * @record
 * @struct
 */
tsickle_declare_module.graphlib.Edge = function() {};
 /** @type {string} */
tsickle_declare_module.graphlib.Edge.prototype.v;
 /** @type {string} */
tsickle_declare_module.graphlib.Edge.prototype.w;
 /** @type {string} */
tsickle_declare_module.graphlib.Edge.prototype.name;

/**
 * @constructor
 * @struct
 * @param {!GraphOptions=} options
 */
tsickle_declare_module.graphlib.Graph = function(options) {};

/**
 * Sets the default node label. This label will be assigned as default label
 * in case if no label was specified while setting a node.
 * Complexity: O(1).
 * 
 * @argument label - default node label.
 * Sets the default node label factory function. This function will be invoked
 * each time when setting a node with no label specified and returned value 
 * will be used as a label for node.
 * Complexity: O(1).
 * 
 * @argument labelFn - default node label factory function.
 * @param {?|function(string): ?} label_or_labelFn
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.setDefaultNodeLabel = function(label_or_labelFn) {};

/**
 * Creates or updates the value for the node v in the graph. If label is supplied
 * it is set as the value for the node. If label is not supplied and the node was
 * created by this call then the default node label will be assigned.
 * Complexity: O(1).
 * 
 * @argument name - node name.
 * @argument label - value to set for node.
 * @param {string} name
 * @param {?=} label
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.setNode = function(name, label) {};

/**
 * Invokes setNode method for each node in names list.
 * Complexity: O(|names|).
 * 
 * @argument names - list of nodes names to be set.
 * @argument label - value to set for each node in list.
 * @param {!Array<string>} names
 * @param {?=} label
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.setNodes = function(names, label) {};

/**
 * Sets node p as a parent for node v if it is defined, or removes the
 * parent for v if p is undefined. Method throws an exception in case of
 * invoking it in context of noncompound graph.
 * Average-case complexity: O(1).
 * 
 * @argument v - node to be child for p.
 * @argument p - node to be parent for v.
 * @param {string} v
 * @param {string=} p
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.setParent = function(v, p) {};

/**
 * Gets parent node for node v.
 * Complexity: O(1).
 * 
 * @argument v - node to get parent of.
 * @param {string} v
 * @return {(string|void)} parent node name or void if v has no parent.
 */
tsickle_declare_module.graphlib.Graph.prototype.parent = function(v) {};

/**
 * Gets list of direct children of node v.
 * Complexity: O(1).
 * 
 * @argument v - node to get children of.
 * @param {string} v
 * @return {!Array<string>} children nodes names list.
 */
tsickle_declare_module.graphlib.Graph.prototype.children = function(v) {};

/**
 * Creates new graph with nodes filtered via filter. Edges incident to rejected node
 * are also removed. In case of compound graph, if parent is rejected by filter,
 * than all its children are rejected too.
 * Average-case complexity: O(|E|+|V|).
 * 
 * @argument filter - filtration function detecting whether the node should stay or not.
 * @param {function(string): boolean} filter
 * @return {!Graph} new graph made from current and nodes filtered.
 */
tsickle_declare_module.graphlib.Graph.prototype.filterNodes = function(filter) {};

/**
 * Sets the default edge label. This label will be assigned as default label
 * in case if no label was specified while setting an edge.
 * Complexity: O(1).
 * 
 * @argument label - default edge label.
 * Sets the default edge label factory function. This function will be invoked
 * each time when setting an edge with no label specified and returned value 
 * will be used as a label for edge.
 * Complexity: O(1).
 * 
 * @argument labelFn - default edge label factory function.
 * @param {?|function(string): ?} label_or_labelFn
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.setDefaultEdgeLabel = function(label_or_labelFn) {};

/**
 * Establish an edges path over the nodes in nodes list. If some edge is already
 * exists, it will update its label, otherwise it will create an edge between pair
 * of nodes with label provided or default label if no label provided.
 * Complexity: O(|nodes|).
 * 
 * @argument nodes - list of nodes to be connected in series.
 * @argument label - value to set for each edge between pairs of nodes.
 * @param {!Array<string>} nodes
 * @param {?=} label
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.setPath = function(nodes, label) {};

/**
 * Detects whether graph has a node with specified name or not.
 * 
 * @argument name - name of the node.
 * @param {string} name
 * @return {boolean} true if graph has node with specified name, false - otherwise.
 */
tsickle_declare_module.graphlib.Graph.prototype.hasNode = function(name) {};

/**
 * Remove the node with the name from the graph or do nothing if the node is not in
 * the graph. If the node was removed this function also removes any incident
 * edges.
 * Complexity: O(1).
 * 
 * @argument name - name of the node.
 * @param {string} name
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.removeNode = function(name) {};

/**
 * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
 * not included in list.
 * Complexity: O(1).
 * 
 * @return {!Array<string>} list of graph nodes.
 */
tsickle_declare_module.graphlib.Graph.prototype.nodes = function() {};

/**
 * Gets the label of node with specified name.
 * Complexity: O(|V|).
 * 
 * @param {string} name
 * @return {?} label value of the node.
 */
tsickle_declare_module.graphlib.Graph.prototype.node = function(name) {};

/**
 * Creates or updates the label for the edge (v, w) with the optionally supplied
 * name. If label is supplied it is set as the value for the edge. If label is not
 * supplied and the edge was created by this call then the default edge label will
 * be assigned. The name parameter is only useful with multigraphs.
 * Complexity: O(1).
 * 
 * @argument v - edge source node.
 * @argument w - edge sink node.
 * @argument label - value to associate with the edge.
 * @argument name - unique name of the edge in order to identify it in multigraph.
 * Creates or updates the label for the specified edge. If label is supplied it is 
 * set as the value for the edge. If label is not supplied and the edge was created 
 * by this call then the default edge label will be assigned. The name parameter is 
 * only useful with multigraphs.
 * Complexity: O(1).
 * 
 * @argument edge - edge descriptor.
 * @argument label - value to associate with the edge.
 * @param {string|!Edge} v_or_edge
 * @param {string|?=} w_or_label
 * @param {?=} label
 * @param {string=} name
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.setEdge = function(v_or_edge, w_or_label, label, name) {};

/**
 * Gets edges of the graph. In case of compound graph subgraphs are not considered.
 * Complexity: O(|E|).
 * 
 * @return {!Array<!Edge>} graph edges list.
 */
tsickle_declare_module.graphlib.Graph.prototype.edges = function() {};

/**
 * Gets the label for the specified edge.
 * Complexity: O(1).
 * 
 * @argument v - edge source node.
 * @argument w - edge sink node.
 * @argument name - name of the edge (actual for multigraph).
 * Gets the label for the specified edge.
 * Complexity: O(1).
 * 
 * @argument edge - edge descriptor.
 * @param {string|!Edge} v_or_e
 * @param {string=} w
 * @param {string=} name
 * @return {?} value associated with specified edge.
 */
tsickle_declare_module.graphlib.Graph.prototype.edge = function(v_or_e, w, name) {};

/**
 * Detects whether the graph contains specified edge or not. No subgraphs are considered.
 * Complexity: O(1).
 * 
 * @argument v - edge source node.
 * @argument w - edge sink node.
 * @argument name - name of the edge (actual for multigraph).
 * Detects whether the graph contains specified edge or not. No subgraphs are considered.
 * Complexity: O(1).
 * 
 * @argument edge - edge descriptor.
 * @param {string|!Edge} v_or_edge
 * @param {string=} w
 * @param {string=} name
 * @return {boolean} whether the graph contains the specified edge or not.
 */
tsickle_declare_module.graphlib.Graph.prototype.hasEdge = function(v_or_edge, w, name) {};

/**
 * Removes the specified edge from the graph. No subgraphs are considered.
 * Complexity: O(1).
 * 
 * @argument edge - edge descriptor.
 * Removes the specified edge from the graph. No subgraphs are considered.
 * Complexity: O(1).
 * 
 * @argument v - edge source node.
 * @argument w - edge sink node.
 * @argument name - name of the edge (actual for multigraph).
 * @param {!Edge|string} edge_or_v
 * @param {string=} w
 * @param {string=} name
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.removeEdge = function(edge_or_v, w, name) {};

/**
 * Return all edges that point to the node v. Optionally filters those edges down to just those
 * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
 * Complexity: O(|E|).
 * 
 * @argument v - edge sink node.
 * @argument w - edge source node.
 * @param {string} v
 * @param {string=} w
 * @return {(void|!Array<!Edge>)} edges descriptors list if v is in the graph, or undefined otherwise.
 */
tsickle_declare_module.graphlib.Graph.prototype.inEdges = function(v, w) {};

/**
 * Return all edges that are pointed at by node v. Optionally filters those edges down to just
 * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
 * Complexity: O(|E|).
 * 
 * @argument v - edge source node.
 * @argument w - edge sink node.
 * @param {string} v
 * @param {string=} w
 * @return {(void|!Array<!Edge>)} edges descriptors list if v is in the graph, or undefined otherwise.
 */
tsickle_declare_module.graphlib.Graph.prototype.outEdges = function(v, w) {};

/**
 * Returns all edges to or from node v regardless of direction. Optionally filters those edges
 * down to just those between nodes v and w regardless of direction.
 * Complexity: O(|E|).
 * 
 * @argument v - edge adjacent node.
 * @argument w - edge adjacent node.
 * @param {string} v
 * @param {string=} w
 * @return {(void|!Array<!Edge>)} edges descriptors list if v is in the graph, or undefined otherwise.
 */
tsickle_declare_module.graphlib.Graph.prototype.nodeEdges = function(v, w) {};

/**
 * Return all nodes that are predecessors of the specified node or undefined if node v is not in
 * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
 * Complexity: O(|V|).
 * 
 * @argument v - node identifier.
 * @param {string} v
 * @return {(void|!Array<string>)} node identifiers list or undefined if v is not in the graph.
 */
tsickle_declare_module.graphlib.Graph.prototype.predecessors = function(v) {};

/**
 * Return all nodes that are successors of the specified node or undefined if node v is not in
 * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
 * Complexity: O(|V|).
 * 
 * @argument v - node identifier.
 * @param {string} v
 * @return {(void|!Array<string>)} node identifiers list or undefined if v is not in the graph.
 */
tsickle_declare_module.graphlib.Graph.prototype.successors = function(v) {};

/**
 * Return all nodes that are predecessors or successors of the specified node or undefined if
 * node v is not in the graph.
 * Complexity: O(|V|).
 * 
 * @argument v - node identifier.
 * @param {string} v
 * @return {(void|!Array<string>)} node identifiers list or undefined if v is not in the graph.
 */
tsickle_declare_module.graphlib.Graph.prototype.neighbors = function(v) {};

/**
 * Whether graph was created with 'directed' flag set to true or not.
 * 
 * @return {boolean} whether the graph edges have an orientation.
 */
tsickle_declare_module.graphlib.Graph.prototype.isDirected = function() {};

/**
 * Whether graph was created with 'multigraph' flag set to true or not.
 * 
 * @return {boolean} whether the pair of nodes of the graph can have multiple edges.
 */
tsickle_declare_module.graphlib.Graph.prototype.isMultigraph = function() {};

/**
 * Whether graph was created with 'compound' flag set to true or not.
 * 
 * @return {boolean} whether a node of the graph can have subnodes.
 */
tsickle_declare_module.graphlib.Graph.prototype.isCompound = function() {};

/**
 * Sets the label of the graph.
 * 
 * @argument label - label value.
 * @param {string} label
 * @return {!Graph} the graph, allowing this to be chained with other functions.
 */
tsickle_declare_module.graphlib.Graph.prototype.setGraph = function(label) {};

/**
 * Gets the graph label.
 * 
 * @return {(string|void)} currently assigned label for the graph or undefined if no label assigned.
 */
tsickle_declare_module.graphlib.Graph.prototype.graph = function() {};

/**
 * Gets the number of nodes in the graph.
 * Complexity: O(1).
 * 
 * @return {number} nodes count.
 */
tsickle_declare_module.graphlib.Graph.prototype.nodeCount = function() {};

/**
 * Gets the number of edges in the graph.
 * Complexity: O(1).
 * 
 * @return {number} edges count.
 */
tsickle_declare_module.graphlib.Graph.prototype.edgeCount = function() {};

/**
 * Gets list of nodes without in-edges.
 * Complexity: O(|V|).
 * 
 * @return {!Array<string>} the graph source nodes.
 */
tsickle_declare_module.graphlib.Graph.prototype.sources = function() {};

/**
 * Gets list of nodes without out-edges.
 * Complexity: O(|V|).
 * 
 * @return {!Array<string>} the graph source nodes.
 */
tsickle_declare_module.graphlib.Graph.prototype.sinks = function() {};
/** @const */
tsickle_declare_module.graphlib.json = {};

/**
 * Creates a JSON representation of the graph that can be serialized to a string with
 * JSON.stringify. The graph can later be restored using json.read.
 * 
 * @argument graph - target to create JSON representation of.
 * @param {!Graph} graph
 * @return {!Object} JSON serializable graph representation
 */
tsickle_declare_module.graphlib.json.write = function(graph) {};

/**
 * Takes JSON as input and returns the graph representation.
 * 
 * \@example 
 * var g2 = graphlib.json.read(JSON.parse(str));
 * g2.nodes();
 * // ['a', 'b']
 * g2.edges()
 * // [ { v: 'a', w: 'b' } ]
 * 
 * @argument json - JSON serializable graph representation
 * @param {!Object} json
 * @return {!Graph} graph constructed acccording to specified representation
 */
tsickle_declare_module.graphlib.json.read = function(json) {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.graphlib.Path = function() {};
 /** @type {number} */
tsickle_declare_module.graphlib.Path.prototype.distance;
 /** @type {string} */
tsickle_declare_module.graphlib.Path.prototype.predecessor;
/** @const */
tsickle_declare_module.graphlib.alg = {};

/**
 * Finds all connected components in a graph and returns an array of these components.
 * Each component is itself an array that contains the ids of nodes in the component.
 * Complexity: O(|V|).
 * 
 * @argument graph - graph to find components in.
 * @param {!Graph} graph
 * @return {!Array<!Array<string>>} array of nodes list representing components
 */
tsickle_declare_module.graphlib.alg.components = function(graph) {};

/**
 * This function is an implementation of Dijkstra's algorithm which finds the shortest
 * path from source to all other nodes in graph. This function returns a map of
 * v -> { distance, predecessor }. The distance property holds the sum of the weights
 * from source to v along the shortest path or Number.POSITIVE_INFINITY if there is no path
 * from source. The predecessor property can be used to walk the individual elements of the
 * path from source to v in reverse order.
 * Complexity: O((|E| + |V|) * log |V|).
 * 
 * @argument graph - graph where to search pathes.
 * @argument source - node to start pathes from.
 * @argument weightFn - function which takes edge e and returns the weight of it. If no weightFn
 * is supplied then each edge is assumed to have a weight of 1. This function throws an
 * Error if any of the traversed edges have a negative edge weight.
 * @argument edgeFn - function which takes a node v and returns the ids of all edges incident to it
 * for the purposes of shortest path traversal. By default this function uses the graph.outEdges.
 * @param {!Graph} graph
 * @param {string} source
 * @param {function(!Edge): number=} weightFn
 * @param {function(string): !Array<!Edge>=} edgeFn
 * @return {!Object<string,!Path>} shortest pathes map that starts from node source
 */
tsickle_declare_module.graphlib.alg.dijkstra = function(graph, source, weightFn, edgeFn) {};

/**
 * This function finds the shortest path from each node to every other reachable node in
 * the graph. It is similar to alg.dijkstra, but instead of returning a single-source
 * array, it returns a mapping of source -> alg.dijksta(g, source, weightFn, edgeFn).
 * Complexity: O(|V| * (|E| + |V|) * log |V|).
 * 
 * @argument graph - graph where to search pathes.
 * @argument weightFn - function which takes edge e and returns the weight of it. If no weightFn
 * is supplied then each edge is assumed to have a weight of 1. This function throws an
 * Error if any of the traversed edges have a negative edge weight.
 * @argument edgeFn - function which takes a node v and returns the ids of all edges incident to it
 * for the purposes of shortest path traversal. By default this function uses the graph.outEdges.
 * @param {!Graph} graph
 * @param {function(!Edge): number=} weightFn
 * @param {function(string): !Array<!Edge>=} edgeFn
 * @return {!Object<string,!Object<string,!Path>>} shortest pathes map.
 */
tsickle_declare_module.graphlib.alg.dijkstraAll = function(graph, weightFn, edgeFn) {};

/**
 * Given a Graph, graph, this function returns all nodes that are part of a cycle. As there
 * may be more than one cycle in a graph this function return an array of these cycles,
 * where each cycle is itself represented by an array of ids for each node involved in
 * that cycle. Method alg.isAcyclic is more efficient if you only need to determine whether a graph has a
 * cycle or not.
 * Complexity: O(|V| + |E|).
 * 
 * @argument graph - graph where to search cycles.
 * @param {!Graph} graph
 * @return {!Array<!Array<string>>} cycles list.
 */
tsickle_declare_module.graphlib.alg.findCycles = function(graph) {};

/**
 * Given a Graph, graph, this function returns true if the graph has no cycles and returns false if it
 * does. This algorithm returns as soon as it detects the first cycle. You can use alg.findCycles
 * to get the actual list of cycles in the graph.
 * 
 * @argument graph - graph to detect whether it acyclic ot not.
 * @param {!Graph} graph
 * @return {boolean} whether graph contain cycles or not.
 */
tsickle_declare_module.graphlib.alg.isAcyclic = function(graph) {};

/**
 * This function is an implementation of the Floyd-Warshall algorithm, which finds the
 * shortest path from each node to every other reachable node in the graph. It is similar
 * to alg.dijkstraAll, but it handles negative edge weights and is more efficient for some types
 * of graphs. This function returns a map of source -> { target -> { distance, predecessor }.
 * The distance property holds the sum of the weights from source to target along the shortest
 * path of Number.POSITIVE_INFINITY if there is no path from source. The predecessor property
 * can be used to walk the individual elements of the path from source to target in reverse
 * order.
 * Complexity: O(|V|^3).
 * 
 * @argument graph - graph where to search pathes.
 * @argument weightFn - function which takes edge e and returns the weight of it. If no weightFn
 * is supplied then each edge is assumed to have a weight of 1. This function throws an
 * Error if any of the traversed edges have a negative edge weight.
 * @argument edgeFn - function which takes a node v and returns the ids of all edges incident to it
 * for the purposes of shortest path traversal. By default this function uses the graph.outEdges.
 * @param {!Graph} graph
 * @param {function(!Edge): number=} weightFn
 * @param {function(string): !Array<!Edge>=} edgeFn
 * @return {!Object<string,!Object<string,!Path>>} shortest pathes map.
 */
tsickle_declare_module.graphlib.alg.floydWarshall = function(graph, weightFn, edgeFn) {};

/**
 * Prim's algorithm takes a connected undirected graph and generates a minimum spanning tree. This
 * function returns the minimum spanning tree as an undirected graph. This algorithm is derived
 * from the description in "Introduction to Algorithms", Third Edition, Cormen, et al., Pg 634.
 * Complexity: O(|E| * log |V|);
 * 
 * @argument graph - graph to generate a minimum spanning tree of.
 * @argument weightFn - function which takes edge e and returns the weight of it. It throws an Error if
 *           the graph is not connected.
 * @param {!Graph} graph
 * @param {function(!Edge): number} weightFn
 * @return {!Graph} minimum spanning tree of graph.
 */
tsickle_declare_module.graphlib.alg.prim = function(graph, weightFn) {};

/**
 * This function is an implementation of Tarjan's algorithm which finds all strongly connected
 * components in the directed graph g. Each strongly connected component is composed of nodes that
 * can reach all other nodes in the component via directed edges. A strongly connected component
 * can consist of a single node if that node cannot both reach and be reached by any other
 * specific node in the graph. Components of more than one node are guaranteed to have at least
 * one cycle.
 * Complexity: O(|V| + |E|).
 * 
 * @argument graph - graph to find all strongly connected components of.
 * @param {!Graph} graph
 * @return {!Array<!Array<string>>} an array of components. Each component is itself an array that contains
 *          the ids of all nodes in the component.
 */
tsickle_declare_module.graphlib.alg.tarjan = function(graph) {};

/**
 * Given a Graph graph this function applies topological sorting to it.
 * If the graph has a cycle it is impossible to generate such a list and CycleException is thrown.
 * Complexity: O(|V| + |E|).
 * 
 * @argument graph - graph to apply topological sorting to.
 * @param {!Graph} graph
 * @return {!Array<string>} an array of nodes such that for each edge u -> v, u appears before v in the array.
 */
tsickle_declare_module.graphlib.alg.topsort = function(graph) {};

/**
 * Performs pre-order depth first traversal on the input graph. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 * 
 * @argument graph - depth first traversal target.
 * @argument vs - nodes list to traverse.
 * @param {!Graph} graph
 * @param {!Array<string>} vs
 * @return {!Array<string>} the nodes in the order they were visited as a list of their names.
 */
tsickle_declare_module.graphlib.alg.preorder = function(graph, vs) {};

/**
 * Performs post-order depth first traversal on the input graph. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 * 
 * @argument graph - depth first traversal target.
 * @argument vs - nodes list to traverse.
 * @param {!Graph} graph
 * @param {!Array<string>} vs
 * @return {!Array<string>} the nodes in the order they were visited as a list of their names.
 */
tsickle_declare_module.graphlib.alg.postorder = function(graph, vs) {};
