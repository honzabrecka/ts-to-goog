/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/ldapjs/index.d.ts:

/* TODO: ImportDeclaration in  */
/**
 * @record
 * @struct
 */
function Error() {}
 /** @type {number} */
Error.prototype.code;
 /** @type {string} */
Error.prototype.name;
 /** @type {string} */
Error.prototype.message;
/**
 * @record
 * @struct
 */
function ErrorCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function CompareCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ExopCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function CallBack() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ClientOptions() {}
 /** @type {string} */
ClientOptions.prototype.url;
 /** @type {!Object} */
ClientOptions.prototype.tlsOptions;
 /** @type {string} */
ClientOptions.prototype.socketPath;
 /** @type {?} */
ClientOptions.prototype.log;
 /** @type {number} */
ClientOptions.prototype.timeout;
 /** @type {number} */
ClientOptions.prototype.connectTimeout;
 /** @type {number} */
ClientOptions.prototype.idleTimeout;
 /** @type {(boolean|?)} */
ClientOptions.prototype.reconnect;
 /** @type {boolean} */
ClientOptions.prototype.strictDN;
 /** @type {number} */
ClientOptions.prototype.queueSize;
 /** @type {number} */
ClientOptions.prototype.queueTimeout;
 /** @type {boolean} */
ClientOptions.prototype.queueDisable;
 /** @type {string} */
ClientOptions.prototype.bindDN;
 /** @type {string} */
ClientOptions.prototype.bindCredentials;
/**
 * @record
 * @struct
 */
function SearchOptions() {}
 /** @type {string} */
SearchOptions.prototype.scope;
 /** @type {string} */
SearchOptions.prototype.filter;
 /** @type {!Array<string>} */
SearchOptions.prototype.attributes;
 /** @type {number} */
SearchOptions.prototype.sizeLimit;
 /** @type {number} */
SearchOptions.prototype.timeLimit;
 /** @type {number} */
SearchOptions.prototype.derefAliases;
 /** @type {boolean} */
SearchOptions.prototype.typesOnly;
 /** @type {(boolean|?)} */
SearchOptions.prototype.paged;
/**
 * @record
 * @struct
 */
function Change() {}
 /** @type {string} */
Change.prototype.operation;
 /** @type {?} */
Change.prototype.modification;
/**
 * @record
 * @struct
 */
function SearchCallBack() {}

/* TODO: CallSignature:  */

/** @typedef {?} */
var Control;
/**
 * @record
 * @struct
 */
function Client() {}
 /** @type {boolean} */
Client.prototype.connected;

/**
 * Performs a simple authentication against the server.
 * 
 * @throws {TypeError} on invalid input.
 * @param {string} dn the DN to bind as.
 * @param {string} password the userPassword associated with name.
 * @param {?} callback_or_controls callback of the form f(err, res).
 * @param {?=} callback
 * @return {void}
 */
Client.prototype.bind = function(dn, password, callback_or_controls, callback) {};

/**
 * Adds an entry to the LDAP server.
 * 
 * Entry can be either [Attribute] or a plain JS object where the
 * values are either a plain value or an array of values.  Any value (that's
 * not an array) will get converted to a string, so keep that in mind.
 * 
 * @throws {TypeError} on invalid input.
 * @param {string} name the DN of the entry to add.
 * @param {!Object} entry an array of Attributes to be added or a JS object.
 * @param {?} callback_or_controls of the form f(err, res).
 * @param {?=} callback
 * @return {void}
 */
Client.prototype.add = function(name, entry, callback_or_controls, callback) {};

/**
 * Compares an attribute/value pair with an entry on the LDAP server.
 * 
 * @throws {TypeError} on invalid input.
 * @param {string} name the DN of the entry to compare attributes with.
 * @param {string} attr name of an attribute to check.
 * @param {string} value value of an attribute to check.
 * @param {?} callback_or_controls of the form f(err, boolean, res).
 * @param {?=} callback
 * @return {void}
 */
Client.prototype.compare = function(name, attr, value, callback_or_controls, callback) {};

/**
 * Deletes an entry from the LDAP server.
 * 
 * @throws {TypeError} on invalid input.
 * @param {string} name the DN of the entry to delete.
 * @param {?} callback_or_controls of the form f(err, res).
 * @param {?=} callback
 * @return {void}
 */
Client.prototype.del = function(name, callback_or_controls, callback) {};

/**
 * Performs an extended operation on the LDAP server.
 * 
 * Pretty much none of the LDAP extended operations return an OID
 * (responseName), so I just don't bother giving it back in the callback.
 * It's on the third param in `res` if you need it.
 * 
 * @throws {TypeError} on invalid input.
 * @param {string} name the OID of the extended operation to perform.
 * @param {string} value value to pass in for this operation.
 * @param {?} callback_or_controls of the form f(err, value, res).
 * @param {?=} callback
 * @return {void}
 */
Client.prototype.exop = function(name, value, callback_or_controls, callback) {};

/**
 * Performs an LDAP modify against the server.
 * 
 * @throws {TypeError} on invalid input.
 * @param {string} name the DN of the entry to modify.
 * @param {(?|!Array<?>)} change update to perform (can be [Change]).
 * @param {?} callback_or_controls of the form f(err, res).
 * @param {?=} callback
 * @return {void}
 */
Client.prototype.modify = function(name, change, callback_or_controls, callback) {};

/**
 * Performs an LDAP modifyDN against the server.
 * 
 * This does not allow you to keep the old DN, as while the LDAP protocol
 * has a facility for that, it's stupid. Just Search/Add.
 * 
 * This will automatically deal with "new superior" logic.
 * 
 * @throws {TypeError} on invalid input.
 * @param {string} name
 * @param {string} newName
 * @param {?} callback_or_controls
 * @param {?=} callback
 * @return {void}
 */
Client.prototype.modifyDN = function(name, newName, callback_or_controls, callback) {};

/**
 * Performs an LDAP search against the server.
 * 
 * Note that the defaults for options are a 'base' search, if that's what
 * you want you can just pass in a string for options and it will be treated
 * as the search filter.  Also, you can either pass in programatic Filter
 * objects or a filter string as the filter option.
 * 
 * Note that this method is 'special' in that the callback 'res' param will
 * have two important events on it, namely 'entry' and 'end' that you can hook
 * to.  The former will emit a SearchEntry object for each record that comes
 * back, and the latter will emit a normal LDAPResult object.
 * 
 * @throws {TypeError} on invalid input.
 * @param {string} base
 * @param {?} options
 * @param {?} callback_or_controls
 * @param {boolean|?=} _bypass_or_callback
 * @param {boolean=} _bypass
 * @return {void}
 */
Client.prototype.search = function(base, options, callback_or_controls, _bypass_or_callback, _bypass) {};

/**
 * Attempt to secure connection with StartTLS.
 * @param {!Object} options
 * @param {?} controls
 * @param {?} callback
 * @param {boolean=} _bypass
 * @return {void}
 */
Client.prototype.starttls = function(options, controls, callback, _bypass) {};

/**
 * Unbinds this client from the LDAP server.
 * 
 * Note that unbind does not have a response, so this callback is actually
 * optional; either way, the client is disconnected.
 * 
 * @throws {TypeError} if you pass in callback as not a function.
 * @param {?=} callback
 * @return {void}
 */
Client.prototype.unbind = function(callback) {};

/**
 * Disconnect from the LDAP server and do not allow reconnection.
 * 
 * If the client is instantiated with proper reconnection options, it's
 * possible to initiate new requests after a call to unbind since the client
 * will attempt to reconnect in order to fulfill the request.
 * 
 * Calling destroy will prevent any further reconnection from occurring.
 * 
 * @param {?=} err
 * @return {void}
 */
Client.prototype.destroy = function(err) {};

/**
 * @param {?=} options
 * @return {?}
 */
function createClient(options) {}
