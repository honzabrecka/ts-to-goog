/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/tapable/index.d.ts:
/**
 * @constructor
 * @struct
 */
function Tapable() {}
 /** @type {!Object<string,!Array<!Tapable.Handler>>} */
Tapable.prototype._plugins;

/**
 * Register plugin(s)
 * This acts as the same as on() of EventEmitter, for registering a handler/listener to do something when the
 * signal/event happens.
 * 
 * @param {string|!Array<string>} names a string or an array of strings to generate the id(group name) of plugins
 * @param {function(!Array<?>): void} handler a function which provides the plugin functionality *
 * @return {void}
 */
Tapable.prototype.plugin = function(names, handler) {};

/**
 * invoke all plugins with this attached.
 * This method is just to "apply" plugins' definition, so that the real event listeners can be registered into
 * registry. Mostly the `apply` method of a plugin is the main place to place extension logic.
 * @param {...(function(): ?|!Tapable.Plugin)} plugins
 * @return {void}
 */
Tapable.prototype.apply = function(plugins) {};

/**
 * synchronously applies all registered handlers for target name(event id).
 * 
 * The handlers are called with all the rest arguments.
 * 
 * @param {string} name - plugin group name
 * @param {...?} args
 * @return {void}
 */
Tapable.prototype.applyPlugins = function(name, args) {};

/**
 * @param {string} name
 * @return {void}
 */
Tapable.prototype.applyPlugins0 = function(name) {};

/**
 * @param {string} name
 * @param {?} param
 * @return {void}
 */
Tapable.prototype.applyPlugins1 = function(name, param) {};

/**
 * @param {string} name
 * @param {?} param1
 * @param {?} param2
 * @return {void}
 */
Tapable.prototype.applyPlugins2 = function(name, param1, param2) {};

/**
 * synchronously applies all registered handlers for target name(event id).
 * 
 * The handlers are called with the return value of the previous handler and all the rest arguments.
 * 
 * `init` is used for the first handler.
 * 
 * return the returned value of the last handler
 * @param {string} name
 * @param {?} init
 * @param {...?} args
 * @return {?}
 */
Tapable.prototype.applyPluginsWaterfall = function(name, init, args) {};

/**
 * synchronously applies all registered handlers for target name(event id).
 * 
 * The handlers are called ONLY with the return value of the previous handler.
 * 
 * `init` is used for the first handler.
 * 
 * return the returned value of the last handler
 * @param {string} name
 * @param {?} init
 * @return {?}
 */
Tapable.prototype.applyPluginsWaterfall0 = function(name, init) {};

/**
 * synchronously applies all registered handlers for target name(event id).
 * 
 * The handlers are called with all the rest arguments.
 * 
 * If a handler returns something !== undefined, that value is returned and no more handlers will be applied.
 * @param {string} name
 * @param {...?} args
 * @return {?}
 */
Tapable.prototype.applyPluginsBailResult = function(name, args) {};

/**
 * synchronously applies all registered handlers for target name(event id).
 * 
 * The handlers are called with target param
 * 
 * If a handler returns something !== undefined, the value is returned and no more handlers are applied.
 * 
 * Note: the fundamental difference with `{\@link applyPluginsBailResult}`, is that,
 *       `{\@link applyPluginsBailResult}` passes the arguments as arguments list for plugins
 *       while `{\@link applyPluginsBailResult1}` passes the arguments as single param(any type) for plugins
 * @param {string} name
 * @param {?} param
 * @return {?}
 */
Tapable.prototype.applyPluginsBailResult1 = function(name, param) {};

/**
 * asynchronously applies all registered handlers for target name(event id).
 * 
 * The handlers are called with all the rest arguments
 * and a callback function with the signature (err: Error) => void.
 * 
 * The handlers are called in series, one at a time. After all handlers are applied, callback is called.
 * 
 * If any handler invokes the (anonymous)callback with error, no more handlers will be called
 * and the real callback is call with that error.
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Tapable.prototype.applyPluginsAsync = function(name, args) {};

/**
 * same as `applyPluginsAsync`
 * @see applyPluginsAsync
 * \@alias Tapable.applyPluginsAsync
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Tapable.prototype.applyPluginsAsyncSeries = function(name, args) {};

/**
 * @param {string} name
 * @param {?} param
 * @param {!Tapable.CallbackFunction} callback
 * @return {void}
 */
Tapable.prototype.applyPluginsAsyncSeries1 = function(name, param, callback) {};

/**
 * asynchronously applies all registered handlers for target name(event id).
 * 
 * The handlers are called with all the rest arguments
 * and a callback function with the signature (...params) => void.
 * 
 * Handlers must invoke the (anonymous)callback, otherwise the series is cut down and real callback won't be
 * invoked.
 * 
 * The order is defined by registration order not by speed of the handler function.
 * 
 * If a handler returns something !== undefined, that value is returned and no more handlers will be applied.
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Tapable.prototype.applyPluginsAsyncSeriesBailResult = function(name, args) {};

/**
 * asynchronously applies all registered handlers for target name(event id).
 * 
 * @see applyPluginsAsyncSeriesBailResult
 * 
 * Note: the fundamental difference with `{\@link applyPluginsAsyncSeriesBailResult}`, is that,
 *       `{\@link applyPluginsAsyncSeriesBailResult}` passes the arguments as arguments list for plugins
 *       while `{\@link applyPluginsAsyncSeriesBailResult1}` passes the arguments as single param(any type)
 *       and a callback for plugins
 * @param {string} name
 * @param {?} param
 * @param {!Tapable.CallbackFunction} callback
 * @return {void}
 */
Tapable.prototype.applyPluginsAsyncSeriesBailResult1 = function(name, param, callback) {};

/**
 * Asynchronously applies all registered handlers for target name(event id).
 * 
 * The handlers are called with the current value and a callback function with the signature (err: Error,
 * nextValue: any) => void.
 * 
 * `init` is used for the first handler. The rest handles are called with the value which previous handler uses
 * to invoke the (anonymous)callback invoked
 * 
 * After all handlers are applied, callback is called with the last value.
 * 
 * If any handler invokes the (anonymous)callback with error, no more handlers will be called
 * and the real callback is call with that error.
 * @param {string} name
 * @param {?} init
 * @param {!Tapable.CallbackFunction} callback
 * @return {void}
 */
Tapable.prototype.applyPluginsAsyncWaterfall = function(name, init, callback) {};

/**
 * applies all registered handlers for target name(event id) in parallel.
 * 
 * The handlers are called with all the rest arguments
 * and a callback function with the signature (err?: Error) => void.
 * 
 * The callback function is called when all handlers call the callback without err.
 * 
 * If any handler invokes the callback with err, callback is invoked with this error and the other handlers are
 * skipped.
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Tapable.prototype.applyPluginsParallel = function(name, args) {};

/**
 * applies all registered handlers for target name(event id) in parallel.
 * 
 * The handlers are called with all the rest arguments
 * and a callback function with the signature (currentResult?: []) => void.
 * 
 * Handlers must call the callback.
 * 
 * The first result (either error or value) with is not undefined is passed to the callback.
 * 
 * The order is defined by registration not by speed of the handler function.
 * @param {string} name
 * @param {...?} args
 * @return {void}
 */
Tapable.prototype.applyPluginsParallelBailResult = function(name, args) {};

/**
 * applies all registered handlers for target name(event id) in parallel.
 * 
 * @see applyPluginsParallelBailResult
 * 
 * Note: the fundamental difference with `{\@link applyPluginsParallelBailResult}`, is that,
 *       `{\@link applyPluginsParallelBailResult}` passes the arguments as arguments list for plugins
 *       while `{\@link applyPluginsParallelBailResult1}` passes the arguments as single param(any type)
 *       and a callback for plugins
 * @param {string} name
 * @param {?} param
 * @param {!Tapable.CallbackFunction} callback
 * @return {void}
 */
Tapable.prototype.applyPluginsParallelBailResult1 = function(name, param, callback) {};

/**
 * @param {?} proto
 * @return {void}
 */
Tapable.mixin = function(proto) {};
/**
 * @record
 * @struct
 */
Tapable.Handler = function() {};

/* TODO: CallSignature: Tapable */
/**
 * @record
 * @struct
 */
Tapable.Plugin = function() {};

/**
 * @param {...?} args
 * @return {void}
 */
Tapable.Plugin.prototype.apply = function(args) {};
/**
 * @record
 * @struct
 */
Tapable.CallbackFunction = function() {};

/* TODO: CallSignature: Tapable */

/* TODO: ExportAssignment in  */
