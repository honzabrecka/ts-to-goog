/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/jest v16/index.d.ts:
 /** @type {!jest.Lifecycle} */
var beforeAll;
 /** @type {!jest.Lifecycle} */
var beforeEach;
 /** @type {!jest.Lifecycle} */
var afterAll;
 /** @type {!jest.Lifecycle} */
var afterEach;
 /** @type {!jest.Describe} */
var describe;
 /** @type {!jest.Describe} */
var fdescribe;
 /** @type {!jest.Describe} */
var xdescribe;
 /** @type {!jest.It} */
var it;
 /** @type {!jest.It} */
var fit;
 /** @type {!jest.It} */
var xit;
 /** @type {!jest.It} */
var test;
 /** @type {!jest.It} */
var xtest;

/**
 * @param {?} actual
 * @return {!jest.Matchers}
 */
function expect(actual) {}
/**
 * @record
 * @struct
 */
function NodeRequire() {}

/**
 * Returns the actual module instead of a mock, bypassing all checks on whether the module should receive a mock implementation or not.
 * @param {string} moduleName
 * @return {?}
 */
NodeRequire.prototype.requireActual = function(moduleName) {};

/**
 * Returns a mock module instead of the actual module, bypassing all checks on whether the module should be required normally or not.
 * @param {string} moduleName
 * @return {?}
 */
NodeRequire.prototype.requireMock = function(moduleName) {};
/** @const */
var jest = {};

/**
 * @param {!jasmine.CustomMatcherFactories} matchers
 * @return {?}
 */
jest.addMatchers = function(matchers) {};

/**
 * Disables automatic mocking in the module loader.
 * @return {?}
 */
jest.autoMockOff = function() {};

/**
 * Enables automatic mocking in the module loader.
 * @return {?}
 */
jest.autoMockOn = function() {};

/**
 * Clears the mock.calls and mock.instances properties of all mocks. Equivalent to calling .mockClear() on every mocked function.
 * @return {?}
 */
jest.clearAllMocks = function() {};

/**
 * Removes any pending timers from the timer system. If any timers have been scheduled, they will be cleared and will never have the opportunity to execute in the future.
 * @return {?}
 */
jest.clearAllTimers = function() {};

/**
 * Indicates that the module system should never return a mocked version of the specified module, including all of the specificied module's dependencies.
 * @param {string} moduleName
 * @return {?}
 */
jest.deepUnmock = function(moduleName) {};

/**
 * Disables automatic mocking in the module loader.
 * @return {?}
 */
jest.disableAutomock = function() {};

/**
 * Mocks a module with an auto-mocked version when it is being required.
 * @param {string} moduleName
 * @return {?}
 */
jest.doMock = function(moduleName) {};

/**
 * Indicates that the module system should never return a mocked version of the specified module from require() (e.g. that it should always return the real module).
 * @param {string} moduleName
 * @return {?}
 */
jest.dontMock = function(moduleName) {};

/**
 * Enables automatic mocking in the module loader.
 * @return {?}
 */
jest.enableAutomock = function() {};

/**
 * Creates a mock function. Optionally takes a mock implementation.
 * @template T
 * @param {!Function=} implementation
 * @return {!jest.Mock<T>}
 */
jest.fn = function(implementation) {};

/**
 * Use the automatic mocking system to generate a mocked version of the given module.
 * @template T
 * @param {string} moduleName
 * @return {T}
 */
jest.genMockFromModule = function(moduleName) {};

/**
 * Returns whether the given function is a mock function.
 * @param {?} fn
 * @return {boolean}
 */
jest.isMockFunction = function(fn) {};

/**
 * Mocks a module with an auto-mocked version when it is being required.
 * @param {string} moduleName
 * @param {?=} factory
 * @param {!jest.MockOptions=} options
 * @return {?}
 */
jest.mock = function(moduleName, factory, options) {};

/**
 * Resets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests.
 * @return {?}
 */
jest.resetModuleRegistry = function() {};

/**
 * Resets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests.
 * @return {?}
 */
jest.resetModules = function() {};

/**
 * Exhausts tasks queued by setImmediate().
 * @return {?}
 */
jest.runAllImmediates = function() {};

/**
 * Exhausts the micro-task queue (usually interfaced in node via process.nextTick).
 * @return {?}
 */
jest.runAllTicks = function() {};

/**
 * Exhausts the macro-task queue (i.e., all tasks queued by setTimeout() and setInterval()).
 * @return {?}
 */
jest.runAllTimers = function() {};

/**
 * Executes only the macro-tasks that are currently pending (i.e., only the tasks that have been queued by setTimeout() or setInterval() up to this point).
 * If any of the currently pending macro-tasks schedule new macro-tasks, those new tasks will not be executed by this call.
 * @return {?}
 */
jest.runOnlyPendingTimers = function() {};

/**
 * Executes only the macro task queue (i.e. all tasks queued by setTimeout() or setInterval() and setImmediate()).
 * @param {number} msToRun
 * @return {?}
 */
jest.runTimersToTime = function(msToRun) {};

/**
 * Explicitly supplies the mock object that the module system should return for the specified module.
 * @template T
 * @param {string} moduleName
 * @param {T} moduleExports
 * @return {?}
 */
jest.setMock = function(moduleName, moduleExports) {};

/**
 * Indicates that the module system should never return a mocked version of the specified module from require() (e.g. that it should always return the real module).
 * @param {string} moduleName
 * @return {?}
 */
jest.unmock = function(moduleName) {};

/**
 * Instructs Jest to use fake versions of the standard timer functions.
 * @return {?}
 */
jest.useFakeTimers = function() {};

/**
 * Instructs Jest to use the real versions of the standard timer functions.
 * @return {?}
 */
jest.useRealTimers = function() {};
/**
 * @record
 * @struct
 */
jest.MockOptions = function() {};
 /** @type {boolean} */
jest.MockOptions.prototype.virtual;
/**
 * @record
 * @struct
 */
jest.EmptyFunction = function() {};

/* TODO: CallSignature: jest */
/**
 * @record
 * @struct
 */
jest.DoneCallback = function() {};

/* TODO: CallSignature: jest */

/**
 * @param {(string|{message: string})=} error
 * @return {?}
 */
jest.DoneCallback.prototype.fail = function(error) {};
/**
 * @record
 * @struct
 */
jest.ProvidesCallback = function() {};

/* TODO: CallSignature: jest */
/**
 * @record
 * @struct
 */
jest.Lifecycle = function() {};

/* TODO: CallSignature: jest */
/**
 * @record
 * @struct
 */
jest.It = function() {};

/* TODO: CallSignature: jest */
 /** @type {!jest.It} */
jest.It.prototype.only;
 /** @type {!jest.It} */
jest.It.prototype.skip;
 /** @type {!jest.It} */
jest.It.prototype.concurrent;
/**
 * @record
 * @struct
 */
jest.Describe = function() {};

/* TODO: CallSignature: jest */
 /** @type {!jest.Describe} */
jest.Describe.prototype.only;
 /** @type {!jest.Describe} */
jest.Describe.prototype.skip;
/**
 * @record
 * @struct
 */
jest.Matchers = function() {};
 /** @type {!jest.Matchers} */
jest.Matchers.prototype.not;

/**
 * @param {...?} args
 * @return {void}
 */
jest.Matchers.prototype.lastCalledWith = function(args) {};

/**
 * @param {?} expected
 * @return {void}
 */
jest.Matchers.prototype.toBe = function(expected) {};

/**
 * @return {void}
 */
jest.Matchers.prototype.toBeCalled = function() {};

/**
 * @param {...?} args
 * @return {void}
 */
jest.Matchers.prototype.toBeCalledWith = function(args) {};

/**
 * @param {number} expected
 * @param {number} delta
 * @return {void}
 */
jest.Matchers.prototype.toBeCloseTo = function(expected, delta) {};

/**
 * @return {void}
 */
jest.Matchers.prototype.toBeDefined = function() {};

/**
 * @return {void}
 */
jest.Matchers.prototype.toBeFalsy = function() {};

/**
 * @param {number} expected
 * @return {void}
 */
jest.Matchers.prototype.toBeGreaterThan = function(expected) {};

/**
 * @param {number} expected
 * @return {void}
 */
jest.Matchers.prototype.toBeGreaterThanOrEqual = function(expected) {};

/**
 * @param {?} expected
 * @return {void}
 */
jest.Matchers.prototype.toBeInstanceOf = function(expected) {};

/**
 * @param {number} expected
 * @return {void}
 */
jest.Matchers.prototype.toBeLessThan = function(expected) {};

/**
 * @param {number} expected
 * @return {void}
 */
jest.Matchers.prototype.toBeLessThanOrEqual = function(expected) {};

/**
 * @return {void}
 */
jest.Matchers.prototype.toBeNull = function() {};

/**
 * @return {void}
 */
jest.Matchers.prototype.toBeTruthy = function() {};

/**
 * @return {void}
 */
jest.Matchers.prototype.toBeUndefined = function() {};

/**
 * @param {?} expected
 * @return {void}
 */
jest.Matchers.prototype.toContain = function(expected) {};

/**
 * @param {?} expected
 * @return {void}
 */
jest.Matchers.prototype.toContainEqual = function(expected) {};

/**
 * @param {?} expected
 * @return {void}
 */
jest.Matchers.prototype.toEqual = function(expected) {};

/**
 * @return {boolean}
 */
jest.Matchers.prototype.toHaveBeenCalled = function() {};

/**
 * @param {number} expected
 * @return {boolean}
 */
jest.Matchers.prototype.toHaveBeenCalledTimes = function(expected) {};

/**
 * @param {...?} params
 * @return {boolean}
 */
jest.Matchers.prototype.toHaveBeenCalledWith = function(params) {};

/**
 * @param {...?} params
 * @return {boolean}
 */
jest.Matchers.prototype.toHaveBeenLastCalledWith = function(params) {};

/**
 * @param {(string|!RegExp)} expected
 * @return {void}
 */
jest.Matchers.prototype.toMatch = function(expected) {};

/**
 * @param {!Object} expected
 * @return {void}
 */
jest.Matchers.prototype.toMatchObject = function(expected) {};

/**
 * @return {void}
 */
jest.Matchers.prototype.toMatchSnapshot = function() {};

/**
 * @return {void}
 */
jest.Matchers.prototype.toThrow = function() {};

/**
 * @param {(string|!RegExp|!jest.Constructable)=} error
 * @return {void}
 */
jest.Matchers.prototype.toThrowError = function(error) {};

/**
 * @return {void}
 */
jest.Matchers.prototype.toThrowErrorMatchingSnapshot = function() {};
/**
 * @record
 * @struct
 */
jest.Constructable = function() {};

/* TODO: ConstructSignature: jest */
/**
 * @record
 * @struct
 */
jest.Mock = function() {};

/* TODO: ConstructSignature: jest */

/* TODO: CallSignature: jest */
 /** @type {!jest.MockContext<T>} */
jest.Mock.prototype.mock;

/**
 * @return {void}
 */
jest.Mock.prototype.mockClear = function() {};

/**
 * @return {void}
 */
jest.Mock.prototype.mockReset = function() {};

/**
 * @param {!Function} fn
 * @return {!jest.Mock}
 */
jest.Mock.prototype.mockImplementation = function(fn) {};

/**
 * @param {!Function} fn
 * @return {!jest.Mock}
 */
jest.Mock.prototype.mockImplementationOnce = function(fn) {};

/**
 * @return {!jest.Mock}
 */
jest.Mock.prototype.mockReturnThis = function() {};

/**
 * @param {?} value
 * @return {!jest.Mock}
 */
jest.Mock.prototype.mockReturnValue = function(value) {};

/**
 * @param {?} value
 * @return {!jest.Mock}
 */
jest.Mock.prototype.mockReturnValueOnce = function(value) {};
/**
 * @record
 * @struct
 */
jest.MockContext = function() {};
 /** @type {!Array<!Array<?>>} */
jest.MockContext.prototype.calls;
 /** @type {!Array<T>} */
jest.MockContext.prototype.instances;

/**
 * @param {?} object
 * @param {string} method
 * @return {!jasmine.Spy}
 */
function spyOn(object, method) {}

/**
 * If you call the function pending anywhere in the spec body, no matter the expectations, the spec will be marked pending.
 * @param {string=} reason
 * @return {void}
 */
function pending(reason) {}

/**
 * Fails a test when called within one.
 * @param {?=} error
 * @return {void}
 */
function fail(error) {}
/** @const */
var jasmine = {};
 /** @type {function(): !jasmine.Clock} */
jasmine.clock;

/**
 * @param {?} aclass
 * @return {!jasmine.Any}
 */
jasmine.any = function(aclass) {};

/**
 * @return {!jasmine.Any}
 */
jasmine.anything = function() {};

/**
 * @param {!Array<?>} sample
 * @return {!jasmine.ArrayContaining}
 */
jasmine.arrayContaining = function(sample) {};

/**
 * @param {?} sample
 * @return {!jasmine.ObjectContaining}
 */
jasmine.objectContaining = function(sample) {};

/**
 * @param {string} name
 * @param {!Function=} originalFn
 * @return {!jasmine.Spy}
 */
jasmine.createSpy = function(name, originalFn) {};

/**
 * @template T
 * @param {string} baseName
 * @param {!Array<?>} methodNames
 * @return {?|T}
 */
jasmine.createSpyObj = function(baseName, methodNames) {};

/**
 * @param {?} value
 * @return {string}
 */
jasmine.pp = function(value) {};

/**
 * @param {!jasmine.CustomEqualityTester} equalityTester
 * @return {void}
 */
jasmine.addCustomEqualityTester = function(equalityTester) {};

/**
 * @param {!jasmine.CustomMatcherFactories} matchers
 * @return {void}
 */
jasmine.addMatchers = function(matchers) {};

/**
 * @param {(string|!RegExp)} value
 * @return {!jasmine.Any}
 */
jasmine.stringMatching = function(value) {};
/**
 * @record
 * @struct
 */
jasmine.Clock = function() {};

/**
 * @return {void}
 */
jasmine.Clock.prototype.install = function() {};

/**
 * @return {void}
 */
jasmine.Clock.prototype.uninstall = function() {};

/**
 * Calls to any registered callback are triggered when the clock is ticked forward via the jasmine.clock().tick function, which takes a number of milliseconds.
 * @param {number} ms
 * @return {void}
 */
jasmine.Clock.prototype.tick = function(ms) {};

/**
 * @param {!Date=} date
 * @return {void}
 */
jasmine.Clock.prototype.mockDate = function(date) {};
/**
 * @record
 * @struct
 */
jasmine.Any = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} other
 * @return {boolean}
 */
jasmine.Any.prototype.jasmineMatches = function(other) {};

/**
 * @return {string}
 */
jasmine.Any.prototype.jasmineToString = function() {};
/**
 * @record
 * @struct
 */
jasmine.ArrayContaining = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} other
 * @return {boolean}
 */
jasmine.ArrayContaining.prototype.asymmetricMatch = function(other) {};

/**
 * @return {string}
 */
jasmine.ArrayContaining.prototype.jasmineToString = function() {};
/**
 * @record
 * @struct
 */
jasmine.ObjectContaining = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} other
 * @param {!Array<?>} mismatchKeys
 * @param {!Array<?>} mismatchValues
 * @return {boolean}
 */
jasmine.ObjectContaining.prototype.jasmineMatches = function(other, mismatchKeys, mismatchValues) {};

/**
 * @return {string}
 */
jasmine.ObjectContaining.prototype.jasmineToString = function() {};
/**
 * @record
 * @struct
 */
jasmine.Spy = function() {};

/* TODO: CallSignature: jasmine */
 /** @type {string} */
jasmine.Spy.prototype.identity;
 /** @type {!jasmine.SpyAnd} */
jasmine.Spy.prototype.and;
 /** @type {!jasmine.Calls} */
jasmine.Spy.prototype.calls;
 /** @type {{args: !Array<?>}} */
jasmine.Spy.prototype.mostRecentCall;
 /** @type {!Array<?>} */
jasmine.Spy.prototype.argsForCall;
 /** @type {boolean} */
jasmine.Spy.prototype.wasCalled;
/**
 * @record
 * @struct
 */
jasmine.SpyAnd = function() {};

/**
 * By chaining the spy with and.callThrough, the spy will still track all calls to it but in addition it will delegate to the actual implementation.
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.callThrough = function() {};

/**
 * By chaining the spy with and.returnValue, all calls to the function will return a specific value.
 * @param {?} val
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.returnValue = function(val) {};

/**
 * By chaining the spy with and.returnValues, all calls to the function will return specific values in order until it reaches the end of the return values list.
 * @param {...?} values
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.returnValues = function(values) {};

/**
 * By chaining the spy with and.callFake, all calls to the spy will delegate to the supplied function.
 * @param {!Function} fn
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.callFake = function(fn) {};

/**
 * By chaining the spy with and.throwError, all calls to the spy will throw the specified value.
 * @param {string} msg
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.throwError = function(msg) {};

/**
 * When a calling strategy is used for a spy, the original stubbing behavior can be returned at any time with and.stub.
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.stub = function() {};
/**
 * @record
 * @struct
 */
jasmine.Calls = function() {};

/**
 * By chaining the spy with calls.any(), will return false if the spy has not been called at all, and then true once at least one call happens.
 * @return {boolean}
 */
jasmine.Calls.prototype.any = function() {};

/**
 * By chaining the spy with calls.count(), will return the number of times the spy was called
 * @return {number}
 */
jasmine.Calls.prototype.count = function() {};

/**
 * By chaining the spy with calls.argsFor(), will return the arguments passed to call number index
 * @param {number} index
 * @return {!Array<?>}
 */
jasmine.Calls.prototype.argsFor = function(index) {};

/**
 * By chaining the spy with calls.allArgs(), will return the arguments to all calls
 * @return {!Array<?>}
 */
jasmine.Calls.prototype.allArgs = function() {};

/**
 * By chaining the spy with calls.all(), will return the context (the this) and arguments passed all calls
 * @return {!Array<!jasmine.CallInfo>}
 */
jasmine.Calls.prototype.all = function() {};

/**
 * By chaining the spy with calls.mostRecent(), will return the context (the this) and arguments for the most recent call
 * @return {!jasmine.CallInfo}
 */
jasmine.Calls.prototype.mostRecent = function() {};

/**
 * By chaining the spy with calls.first(), will return the context (the this) and arguments for the first call
 * @return {!jasmine.CallInfo}
 */
jasmine.Calls.prototype.first = function() {};

/**
 * By chaining the spy with calls.reset(), will clears all tracking for a spy
 * @return {void}
 */
jasmine.Calls.prototype.reset = function() {};
/**
 * @record
 * @struct
 */
jasmine.CallInfo = function() {};
 /** @type {?} */
jasmine.CallInfo.prototype.object;
 /** @type {!Array<?>} */
jasmine.CallInfo.prototype.args;
 /** @type {?} */
jasmine.CallInfo.prototype.returnValue;
/**
 * @record
 * @struct
 */
jasmine.CustomMatcherFactories = function() {};

/* TODO: IndexSignature: jasmine */
/**
 * @record
 * @struct
 */
jasmine.CustomMatcherFactory = function() {};

/* TODO: CallSignature: jasmine */
/**
 * @record
 * @struct
 */
jasmine.MatchersUtil = function() {};

/**
 * @param {?} a
 * @param {?} b
 * @param {!Array<!jasmine.CustomEqualityTester>=} customTesters
 * @return {boolean}
 */
jasmine.MatchersUtil.prototype.equals = function(a, b, customTesters) {};

/**
 * @template T
 * @param {(string|!jasmine.ArrayLike<T>)} haystack
 * @param {?} needle
 * @param {!Array<!jasmine.CustomEqualityTester>=} customTesters
 * @return {boolean}
 */
jasmine.MatchersUtil.prototype.contains = function(haystack, needle, customTesters) {};

/**
 * @param {string} matcherName
 * @param {boolean} isNot
 * @param {?} actual
 * @param {...?} expected
 * @return {string}
 */
jasmine.MatchersUtil.prototype.buildFailureMessage = function(matcherName, isNot, actual, expected) {};
/**
 * @record
 * @struct
 */
jasmine.CustomEqualityTester = function() {};

/* TODO: CallSignature: jasmine */
/**
 * @record
 * @struct
 */
jasmine.CustomMatcher = function() {};

/**
 * @template T
 * @param {T|?} actual
 * @param {T|?} expected
 * @return {!jasmine.CustomMatcherResult}
 */
jasmine.CustomMatcher.prototype.compare = function(actual, expected) {};
/**
 * @record
 * @struct
 */
jasmine.CustomMatcherResult = function() {};
 /** @type {boolean} */
jasmine.CustomMatcherResult.prototype.pass;
 /** @type {(string|function(): string)} */
jasmine.CustomMatcherResult.prototype.message;
/**
 * @record
 * @struct
 */
jasmine.ArrayLike = function() {};
 /** @type {number} */
jasmine.ArrayLike.prototype.length;

/* TODO: IndexSignature: jasmine */
