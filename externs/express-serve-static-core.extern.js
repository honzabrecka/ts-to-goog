/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/express-serve-static-core/index.d.ts:
/** @const */
var Express = {};
/**
 * @record
 * @struct
 */
Express.Request = function() {};
/**
 * @record
 * @struct
 */
Express.Response = function() {};
/**
 * @record
 * @struct
 */
Express.Application = function() {};

/* TODO: ImportDeclaration in  */
/**
 * @record
 * @struct
 */
function NextFunction() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function RequestHandler() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ErrorRequestHandler() {}

/* TODO: CallSignature:  */

/** @typedef {(string|!RegExp|!Array<(string|!RegExp)>)} */
var PathParams;

/** @typedef {(?|!Array<?>)} */
var RequestHandlerParams;
/**
 * @record
 * @struct
 */
function IRouterMatcher() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IRouterHandler() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @extends {RequestHandler}
 * @record
 * @struct
 */
function IRouter() {}
 /** @type {?} */
IRouter.prototype.all;
 /** @type {?} */
IRouter.prototype.get;
 /** @type {?} */
IRouter.prototype.post;
 /** @type {?} */
IRouter.prototype.put;
 /** @type {?} */
IRouter.prototype.delete;
 /** @type {?} */
IRouter.prototype.patch;
 /** @type {?} */
IRouter.prototype.options;
 /** @type {?} */
IRouter.prototype.head;
 /** @type {?} */
IRouter.prototype.checkout;
 /** @type {?} */
IRouter.prototype.connect;
 /** @type {?} */
IRouter.prototype.copy;
 /** @type {?} */
IRouter.prototype.lock;
 /** @type {?} */
IRouter.prototype.merge;
 /** @type {?} */
IRouter.prototype.mkactivity;
 /** @type {?} */
IRouter.prototype.mkcol;
 /** @type {?} */
IRouter.prototype.move;

/* TODO: PropertySignature: "m-search" */
 /** @type {?} */
IRouter.prototype.notify;
 /** @type {?} */
IRouter.prototype.propfind;
 /** @type {?} */
IRouter.prototype.proppatch;
 /** @type {?} */
IRouter.prototype.purge;
 /** @type {?} */
IRouter.prototype.report;
 /** @type {?} */
IRouter.prototype.search;
 /** @type {?} */
IRouter.prototype.subscribe;
 /** @type {?} */
IRouter.prototype.trace;
 /** @type {?} */
IRouter.prototype.unlock;
 /** @type {?} */
IRouter.prototype.unsubscribe;
 /** @type {?} */
IRouter.prototype.use;
 /** @type {!Array<?>} */
IRouter.prototype.stack;

/**
 * Map the given param placeholder `name`(s) to the given callback(s).
 * 
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code,
 * 
 * The callback uses the samesignature as middleware, the only differencing
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 * 
 *      app.param('user_id', function(req, res, next, id){
 *        User.find(id, function(err, user){
 *          if (err) {
 *            next(err);
 *          } else if (user) {
 *            req.user = user;
 *            next();
 *          } else {
 *            next(new Error('failed to load user'));
 *          }
 *        });
 *      });
 * 
 * @param {string|?} name_or_callback
 * @param {?=} handler
 * @return {?}
 */
IRouter.prototype.param = function(name_or_callback, handler) {};

/**
 * @param {(string|!RegExp|!Array<(string|!RegExp)>)} prefix
 * @return {?}
 */
IRouter.prototype.route = function(prefix) {};
/**
 * @record
 * @struct
 */
function IRoute() {}
 /** @type {string} */
IRoute.prototype.path;
 /** @type {?} */
IRoute.prototype.stack;
 /** @type {?} */
IRoute.prototype.all;
 /** @type {?} */
IRoute.prototype.get;
 /** @type {?} */
IRoute.prototype.post;
 /** @type {?} */
IRoute.prototype.put;
 /** @type {?} */
IRoute.prototype.delete;
 /** @type {?} */
IRoute.prototype.patch;
 /** @type {?} */
IRoute.prototype.options;
 /** @type {?} */
IRoute.prototype.head;
 /** @type {?} */
IRoute.prototype.checkout;
 /** @type {?} */
IRoute.prototype.copy;
 /** @type {?} */
IRoute.prototype.lock;
 /** @type {?} */
IRoute.prototype.merge;
 /** @type {?} */
IRoute.prototype.mkactivity;
 /** @type {?} */
IRoute.prototype.mkcol;
 /** @type {?} */
IRoute.prototype.move;

/* TODO: PropertySignature: "m-search" */
 /** @type {?} */
IRoute.prototype.notify;
 /** @type {?} */
IRoute.prototype.purge;
 /** @type {?} */
IRoute.prototype.report;
 /** @type {?} */
IRoute.prototype.search;
 /** @type {?} */
IRoute.prototype.subscribe;
 /** @type {?} */
IRoute.prototype.trace;
 /** @type {?} */
IRoute.prototype.unlock;
 /** @type {?} */
IRoute.prototype.unsubscribe;
/**
 * @extends {IRouter}
 * @record
 * @struct
 */
function Router() {}
/**
 * @record
 * @struct
 */
function CookieOptions() {}
 /** @type {number} */
CookieOptions.prototype.maxAge;
 /** @type {boolean} */
CookieOptions.prototype.signed;
 /** @type {(boolean|!Date)} */
CookieOptions.prototype.expires;
 /** @type {boolean} */
CookieOptions.prototype.httpOnly;
 /** @type {string} */
CookieOptions.prototype.path;
 /** @type {string} */
CookieOptions.prototype.domain;
 /** @type {(boolean|string)} */
CookieOptions.prototype.secure;
 /** @type {?} */
CookieOptions.prototype.encode;
 /** @type {(string|boolean)} */
CookieOptions.prototype.sameSite;
/**
 * @record
 * @struct
 */
function ByteRange() {}
 /** @type {number} */
ByteRange.prototype.start;
 /** @type {number} */
ByteRange.prototype.end;
/**
 * @record
 * @struct
 */
function RequestRanges() {}
 /** @type {string} */
RequestRanges.prototype.type;
/**
 * @record
 * @struct
 */
function Errback() {}

/* TODO: CallSignature:  */
/**
 * @extends {Express.Request}
 * @record
 * @struct
 */
function Request() {}
 /** @type {!Array<?>} */
Request.prototype.accepted;
 /** @type {string} */
Request.prototype.protocol;
 /** @type {boolean} */
Request.prototype.secure;
 /** @type {string} */
Request.prototype.ip;
 /** @type {!Array<string>} */
Request.prototype.ips;
 /** @type {!Array<string>} */
Request.prototype.subdomains;
 /** @type {string} */
Request.prototype.path;
 /** @type {string} */
Request.prototype.hostname;
 /** @type {string} */
Request.prototype.host;
 /** @type {boolean} */
Request.prototype.fresh;
 /** @type {boolean} */
Request.prototype.stale;
 /** @type {boolean} */
Request.prototype.xhr;
 /** @type {?} */
Request.prototype.body;
 /** @type {?} */
Request.prototype.cookies;
 /** @type {string} */
Request.prototype.method;
 /** @type {?} */
Request.prototype.params;
 /** @type {?} */
Request.prototype.query;
 /** @type {?} */
Request.prototype.route;
 /** @type {?} */
Request.prototype.signedCookies;
 /** @type {string} */
Request.prototype.originalUrl;
 /** @type {string} */
Request.prototype.url;
 /** @type {string} */
Request.prototype.baseUrl;
 /** @type {?} */
Request.prototype.app;

/**
 * Return request header.
 * 
 * The `Referrer` header field is special-cased,
 * both `Referrer` and `Referer` are interchangeable.
 * 
 * Examples:
 * 
 *     req.get('Content-Type');
 *     // => "text/plain"
 * 
 *     req.get('content-type');
 *     // => "text/plain"
 * 
 *     req.get('Something');
 *     // => undefined
 * 
 * Aliased as `req.header()`.
 * 
 * @param {string} name
 * @return {string}
 */
Request.prototype.get = function(name) {};

/**
 * @param {string} name
 * @return {string}
 */
Request.prototype.header = function(name) {};

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 * 
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json", a comma-delimted list such as "json, html, text/plain",
 * or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 * 
 * Examples:
 * 
 *     // Accept: text/html
 *     req.accepts('html');
 *     // => "html"
 * 
 *     // Accept: text/*, application/json
 *     req.accepts('html');
 *     // => "html"
 *     req.accepts('text/html');
 *     // => "text/html"
 *     req.accepts('json, text');
 *     // => "json"
 *     req.accepts('application/json');
 *     // => "application/json"
 * 
 *     // Accept: text/*, application/json
 *     req.accepts('image/png');
 *     req.accepts('png');
 *     // => undefined
 * 
 *     // Accept: text/*;q=.5, application/json
 *     req.accepts(['html', 'json']);
 *     req.accepts('html, json');
 *     // => "json"
 * @param {...string|!Array<string>} type
 * @return {!Array<string>|(string|boolean)}
 */
Request.prototype.accepts = function(type) {};

/**
 * Returns the first accepted charset of the specified character sets,
 * based on the request's Accept-Charset HTTP header field.
 * If none of the specified charsets is accepted, returns false.
 * 
 * For more information, or if you have issues or concerns, see accepts.
 * @param {...string|!Array<string>} charset
 * @return {!Array<string>|(string|boolean)}
 */
Request.prototype.acceptsCharsets = function(charset) {};

/**
 * Returns the first accepted encoding of the specified encodings,
 * based on the request's Accept-Encoding HTTP header field.
 * If none of the specified encodings is accepted, returns false.
 * 
 * For more information, or if you have issues or concerns, see accepts.
 * @param {...string|!Array<string>} encoding
 * @return {!Array<string>|(string|boolean)}
 */
Request.prototype.acceptsEncodings = function(encoding) {};

/**
 * Returns the first accepted language of the specified languages,
 * based on the request's Accept-Language HTTP header field.
 * If none of the specified languages is accepted, returns false.
 * 
 * For more information, or if you have issues or concerns, see accepts.
 * 
 * @param {...string|!Array<string>} lang
 * @return {!Array<string>|(string|boolean)}
 */
Request.prototype.acceptsLanguages = function(lang) {};

/**
 * Parse Range header field,
 * capping to the given `size`.
 * 
 * Unspecified ranges such as "0-" require
 * knowledge of your resource length. In
 * the case of a byte range this is of course
 * the total number of bytes. If the Range
 * header field is not given `null` is returned,
 * `-1` when unsatisfiable, `-2` when syntactically invalid.
 * 
 * NOTE: remember that ranges are inclusive, so
 * for example "Range: users=0-3" should respond
 * with 4 users when available, not 3.
 * 
 * @param {number} size
 * @return {(?|number)}
 */
Request.prototype.range = function(size) {};

/**
 * @deprecated Use either req.params, req.body or req.query, as applicable.
 * 
 * Return the value of param `name` when present or `defaultValue`.
 * 
 *  - Checks route placeholders, ex: _/user/:id_
 *  - Checks body params, ex: id=12, {"id":12}
 *  - Checks query string params, ex: ?id=12
 * 
 * To utilize request bodies, `req.body`
 * should be an object. This can be done by using
 * the `connect.bodyParser()` middleware.
 * 
 * @param {string} name
 * @param {?=} defaultValue
 * @return {string}
 */
Request.prototype.param = function(name, defaultValue) {};

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains the give mime `type`.
 * 
 * Examples:
 * 
 *      // With Content-Type: text/html; charset=utf-8
 *      req.is('html');
 *      req.is('text/html');
 *      req.is('text/*');
 *      // => true
 * 
 *      // When Content-Type is application/json
 *      req.is('json');
 *      req.is('application/json');
 *      req.is('application/*');
 *      // => true
 * 
 *      req.is('html');
 *      // => false
 * 
 * @param {string} type
 * @return {boolean}
 */
Request.prototype.is = function(type) {};

/**
 * Clear cookie `name`.
 * 
 * @param {string} name
 * @param {?=} options
 * @return {?}
 */
Request.prototype.clearCookie = function(name, options) {};
/**
 * @record
 * @struct
 */
function MediaType() {}
 /** @type {string} */
MediaType.prototype.value;
 /** @type {number} */
MediaType.prototype.quality;
 /** @type {string} */
MediaType.prototype.type;
 /** @type {string} */
MediaType.prototype.subtype;
/**
 * @record
 * @struct
 */
function Send() {}

/* TODO: CallSignature:  */
/**
 * @extends {Express.Response}
 * @record
 * @struct
 */
function Response() {}
 /** @type {?} */
Response.prototype.send;
 /** @type {?} */
Response.prototype.json;
 /** @type {?} */
Response.prototype.jsonp;
 /** @type {boolean} */
Response.prototype.headersSent;
 /** @type {?} */
Response.prototype.locals;
 /** @type {string} */
Response.prototype.charset;
 /** @type {?} */
Response.prototype.app;

/**
 * Set status `code`.
 * 
 * @param {number} code
 * @return {?}
 */
Response.prototype.status = function(code) {};

/**
 * Set the response HTTP status code to `statusCode` and send its string representation as the response body.
 * @link http://expressjs.com/4x/api.html#res.sendStatus
 * 
 * Examples:
 * 
 *    res.sendStatus(200); // equivalent to res.status(200).send('OK')
 *    res.sendStatus(403); // equivalent to res.status(403).send('Forbidden')
 *    res.sendStatus(404); // equivalent to res.status(404).send('Not Found')
 *    res.sendStatus(500); // equivalent to res.status(500).send('Internal Server Error')
 * 
 * @param {number} code
 * @return {?}
 */
Response.prototype.sendStatus = function(code) {};

/**
 * Set Link header field with the given `links`.
 * 
 * Examples:
 * 
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5'
 *    });
 * 
 * @param {?} links
 * @return {?}
 */
Response.prototype.links = function(links) {};

/**
 * Transfer the file at the given `path`.
 * 
 * Automatically sets the _Content-Type_ response header field.
 * The callback `fn(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 * 
 * Options:
 * 
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 * 
 * Other options are passed along to `send`.
 * 
 * Examples:
 * 
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 * 
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 * 
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 * 
 * \@api public
 * @param {string} path
 * @param {?=} options_or_fn
 * @param {?=} fn
 * @return {void}
 */
Response.prototype.sendFile = function(path, options_or_fn, fn) {};

/**
 * @deprecated Use sendFile instead.
 * @param {string} path
 * @param {?=} options_or_fn
 * @param {?=} fn
 * @return {void}
 */
Response.prototype.sendfile = function(path, options_or_fn, fn) {};

/**
 * Transfer the file at the given `path` as an attachment.
 * 
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `fn(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * ocurred. Be sure to check `res.headerSent` if you plan to respond.
 * 
 * This method uses `res.sendfile()`.
 * @param {string} path
 * @param {string|?=} filename_or_fn
 * @param {?=} fn
 * @return {void}
 */
Response.prototype.download = function(path, filename_or_fn, fn) {};

/**
 * Set _Content-Type_ response header with `type` through `mime.lookup()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 * 
 * Examples:
 * 
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 * 
 * @param {string} type
 * @return {?}
 */
Response.prototype.contentType = function(type) {};

/**
 * Set _Content-Type_ response header with `type` through `mime.lookup()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 * 
 * Examples:
 * 
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 * 
 * @param {string} type
 * @return {?}
 */
Response.prototype.type = function(type) {};

/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 * 
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 * 
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set('Content-Type', ...)`.
 * 
 *    res.format({
 *      'text/plain': function(){
 *        res.send('hey');
 *      },
 * 
 *      'text/html': function(){
 *        res.send('<p>hey</p>');
 *      },
 * 
 *      'appliation/json': function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 * 
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 * 
 *    res.format({
 *      text: function(){
 *        res.send('hey');
 *      },
 * 
 *      html: function(){
 *        res.send('<p>hey</p>');
 *      },
 * 
 *      json: function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 * 
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 * 
 * @param {?} obj
 * @return {?}
 */
Response.prototype.format = function(obj) {};

/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 * 
 * @param {string=} filename
 * @return {?}
 */
Response.prototype.attachment = function(filename) {};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 * 
 * Examples:
 * 
 *    res.set('Foo', ['bar', 'baz']);
 *    res.set('Accept', 'application/json');
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 * 
 * Aliased as `res.header()`.
 * @param {?|string} field
 * @param {string=} value
 * @return {?}
 */
Response.prototype.set = function(field, value) {};

/**
 * @param {?|string} field
 * @param {string=} value
 * @return {?}
 */
Response.prototype.header = function(field, value) {};

/**
 * Get value for header `field`.
 * 
 * @param {string} field
 * @return {string}
 */
Response.prototype.get = function(field) {};

/**
 * Clear cookie `name`.
 * 
 * @param {string} name
 * @param {?=} options
 * @return {?}
 */
Response.prototype.clearCookie = function(name, options) {};

/**
 * Set cookie `name` to `val`, with the given `options`.
 * 
 * Options:
 * 
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 * 
 * Examples:
 * 
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
 * 
 *    // save as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
 * @param {string} name
 * @param {string|?} val
 * @param {?=} options
 * @return {?}
 */
Response.prototype.cookie = function(name, val, options) {};

/**
 * Set the location header to `url`.
 * 
 * The given `url` can also be the name of a mapped url, for
 * example by default express supports "back" which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 * 
 * Examples:
 * 
 *    res.location('/foo/bar').;
 *    res.location('http://example.com');
 *    res.location('../login'); // /blog/post/1 -> /blog/login
 * 
 * Mounting:
 * 
 *   When an application is mounted and `res.location()`
 *   is given a path that does _not_ lead with "/" it becomes
 *   relative to the mount-point. For example if the application
 *   is mounted at "/blog", the following would become "/blog/login".
 * 
 *      res.location('login');
 * 
 *   While the leading slash would result in a location of "/login":
 * 
 *      res.location('/login');
 * 
 * @param {string} url
 * @return {?}
 */
Response.prototype.location = function(url) {};

/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 * 
 * The resulting `url` is determined by `res.location()`, so
 * it will play nicely with mounted apps, relative paths,
 * `"back"` etc.
 * 
 * Examples:
 * 
 *    res.redirect('/foo/bar');
 *    res.redirect('http://example.com');
 *    res.redirect(301, 'http://example.com');
 *    res.redirect('http://example.com', 301);
 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
 * @param {string|number} url_or_status
 * @param {string|number=} url_or_status1
 * @return {void}
 */
Response.prototype.redirect = function(url_or_status, url_or_status1) {};

/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 * 
 * Options:
 * 
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 * @param {string} view
 * @param {!Object|?=} options_or_callback
 * @param {?=} callback
 * @return {void}
 */
Response.prototype.render = function(view, options_or_callback, callback) {};

/**
 * Adds the field to the Vary response header, if it is not there already.
 * Examples:
 * 
 *     res.vary('User-Agent').render('docs');
 * 
 * @param {string} field
 * @return {?}
 */
Response.prototype.vary = function(field) {};
/**
 * @extends {RequestHandler}
 * @record
 * @struct
 */
function Handler() {}
/**
 * @record
 * @struct
 */
function RequestParamHandler() {}

/* TODO: CallSignature:  */

/** @typedef {?} */
var ApplicationRequestHandler;
/**
 * @extends {IRouter}
 * @extends {Express.Application}
 * @record
 * @struct
 */
function Application() {}

/* TODO: CallSignature:  */
 /** @type {?} */
Application.prototype.get;
 /** @type {string} */
Application.prototype.router;
 /** @type {?} */
Application.prototype.settings;
 /** @type {?} */
Application.prototype.resource;
 /** @type {?} */
Application.prototype.map;
 /** @type {?} */
Application.prototype.locals;
 /** @type {?} */
Application.prototype.routes;
 /** @type {?} */
Application.prototype._router;
 /** @type {?} */
Application.prototype.use;

/**
 * Initialize the server.
 * 
 *   - setup default configuration
 *   - setup default middleware
 *   - setup route reflection methods
 * @return {void}
 */
Application.prototype.init = function() {};

/**
 * Initialize application configuration.
 * @return {void}
 */
Application.prototype.defaultConfiguration = function() {};

/**
 * Register the given template engine callback `fn`
 * as `ext`.
 * 
 * By default will `require()` the engine based on the
 * file extension. For example if you try to render
 * a "foo.jade" file Express will invoke the following internally:
 * 
 *     app.engine('jade', require('jade').__express);
 * 
 * For engines that do not provide `.__express` out of the box,
 * or if you wish to "map" a different extension to the template engine
 * you may use this method. For example mapping the EJS template engine to
 * ".html" files:
 * 
 *     app.engine('html', require('ejs').renderFile);
 * 
 * In this case EJS provides a `.renderFile()` method with
 * the same signature that Express expects: `(path, options, callback)`,
 * though note that it aliases this method as `ejs.__express` internally
 * so if you're using ".ejs" extensions you dont need to do anything.
 * 
 * Some template engines do not follow this convention, the
 * [Consolidate.js](https://github.com/visionmedia/consolidate.js)
 * library was created to map all of node's popular template
 * engines to follow this convention, thus allowing them to
 * work seamlessly within Express.
 * @param {string} ext
 * @param {!Function} fn
 * @return {?}
 */
Application.prototype.engine = function(ext, fn) {};

/**
 * Assign `setting` to `val`, or return `setting`'s value.
 * 
 *    app.set('foo', 'bar');
 *    app.get('foo');
 *    // => "bar"
 *    app.set('foo', ['bar', 'baz']);
 *    app.get('foo');
 *    // => ["bar", "baz"]
 * 
 * Mounted servers inherit their parent server's settings.
 * 
 * @param {string} setting
 * @param {?} val
 * @return {?}
 */
Application.prototype.set = function(setting, val) {};

/**
 * @param {(string|!Array<string>)|?} name_or_callback
 * @param {?=} handler
 * @return {?}
 */
Application.prototype.param = function(name_or_callback, handler) {};

/**
 * Return the app's absolute pathname
 * based on the parent(s) that have
 * mounted it.
 * 
 * For example if the application was
 * mounted as "/admin", which itself
 * was mounted as "/blog" then the
 * return value would be "/blog/admin".
 * @return {string}
 */
Application.prototype.path = function() {};

/**
 * Check if `setting` is enabled (truthy).
 * 
 *    app.enabled('foo')
 *    // => false
 * 
 *    app.enable('foo')
 *    app.enabled('foo')
 *    // => true
 * @param {string} setting
 * @return {boolean}
 */
Application.prototype.enabled = function(setting) {};

/**
 * Check if `setting` is disabled.
 * 
 *    app.disabled('foo')
 *    // => true
 * 
 *    app.enable('foo')
 *    app.disabled('foo')
 *    // => false
 * 
 * @param {string} setting
 * @return {boolean}
 */
Application.prototype.disabled = function(setting) {};

/**
 * Enable `setting`.
 * 
 * @param {string} setting
 * @return {?}
 */
Application.prototype.enable = function(setting) {};

/**
 * Disable `setting`.
 * 
 * @param {string} setting
 * @return {?}
 */
Application.prototype.disable = function(setting) {};

/**
 * Configure callback for zero or more envs,
 * when no `env` is specified that callback will
 * be invoked for all environments. Any combination
 * can be used multiple times, in any order desired.
 * 
 * Examples:
 * 
 *    app.configure(function(){
 *      // executed for all envs
 *    });
 * 
 *    app.configure('stage', function(){
 *      // executed staging env
 *    });
 * 
 *    app.configure('stage', 'production', function(){
 *      // executed for stage and production
 *    });
 * 
 * Note:
 * 
 *  These callbacks are invoked immediately, and
 *  are effectively sugar for the following:
 * 
 *     var env = process.env.NODE_ENV || 'development';
 * 
 *      switch (env) {
 *        case 'development':
 *          ...
 *          break;
 *        case 'stage':
 *          ...
 *          break;
 *        case 'production':
 *          ...
 *          break;
 *      }
 * 
 * @param {!Function|string} fn_or_env0
 * @param {!Function|string=} fn_or_env1
 * @param {!Function|string=} fn_or_env2
 * @param {!Function|string=} fn_or_env3
 * @param {!Function|string=} fn_or_env4
 * @param {!Function=} fn
 * @return {?}
 */
Application.prototype.configure = function(fn_or_env0, fn_or_env1, fn_or_env2, fn_or_env3, fn_or_env4, fn) {};

/**
 * Render the given view `name` name with `options`
 * and a callback accepting an error and the
 * rendered template string.
 * 
 * Example:
 * 
 *    app.render('email', { name: 'Tobi' }, function(err, html){
 *      // ...
 *    })
 * 
 * @param {string} name
 * @param {!Object|?=} options_or_callback or fn
 * @param {?=} callback
 * @return {void}
 */
Application.prototype.render = function(name, options_or_callback, callback) {};

/**
 * Listen for connections.
 * 
 * A node `http.Server` is returned, with this
 * application (which is a `Function`) as its
 * callback. If you wish to create both an HTTP
 * and HTTPS server you may do so with the "http"
 * and "https" modules as shown here:
 * 
 *    var http = require('http')
 *      , https = require('https')
 *      , express = require('express')
 *      , app = express();
 * 
 *    http.createServer(app).listen(80);
 *    https.createServer({ ... }, app).listen(443);
 * @param {number|string|?} port_or_path_or_handle
 * @param {string|!Function=} hostname_or_callback_or_listeningListener
 * @param {number|!Function=} backlog_or_callback
 * @param {!Function=} callback
 * @return {!Server}
 */
Application.prototype.listen = function(port_or_path_or_handle, hostname_or_callback_or_listeningListener, backlog_or_callback, callback) {};
/**
 * @extends {Application}
 * @record
 * @struct
 */
function Express() {}
 /** @type {?} */
Express.prototype.request;
 /** @type {?} */
Express.prototype.response;
