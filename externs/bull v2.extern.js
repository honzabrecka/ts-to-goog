/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bull v2/index.d.ts:
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "bull"
/** @const */
tsickle_declare_module.bull = {};

/* TODO: ImportDeclaration in tsickle_declare_module.bull */

/**
 * This is the Queue constructor.
 * It creates a new Queue that is persisted in Redis.
 * Everytime the same queue is instantiated it tries to process all the old jobs that may exist from a previous unfinished session.
 * @param {string} queueName
 * @param {number} redisPort
 * @param {string} redisHost
 * @param {?=} redisOpt
 * @return {!Bull.Queue}
 */
tsickle_declare_module.bull.Bull = function(queueName, redisPort, redisHost, redisOpt) {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.DoneCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.Job = function() {};
 /** @type {string} */
tsickle_declare_module.bull.Bull.Job.prototype.jobId;
 /** @type {!Object} */
tsickle_declare_module.bull.Bull.Job.prototype.data;

/**
 * Report progress on a job
 * @param {?} value
 * @return {!Promise<void>}
 */
tsickle_declare_module.bull.Bull.Job.prototype.progress = function(value) {};

/**
 * Removes a Job from the queue from all the lists where it may be included.
 * @return {!Promise<void>}
 */
tsickle_declare_module.bull.Bull.Job.prototype.remove = function() {};

/**
 * Rerun a Job that has failed.
 * @return {!Promise<void>}
 */
tsickle_declare_module.bull.Bull.Job.prototype.retry = function() {};

/**
 * Returns a promise the resolves when the job has been finished.
 * TODO: Add a watchdog to check if the job has finished periodically.
 * since pubsub does not give any guarantees.
 * @return {!Promise<void>}
 */
tsickle_declare_module.bull.Bull.Job.prototype.finished = function() {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.Backoff = function() {};
 /** @type {string} */
tsickle_declare_module.bull.Bull.Backoff.prototype.type;
 /** @type {number} */
tsickle_declare_module.bull.Bull.Backoff.prototype.delay;
/**
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.AddOptions = function() {};
 /** @type {number} */
tsickle_declare_module.bull.Bull.AddOptions.prototype.delay;
 /** @type {number} */
tsickle_declare_module.bull.Bull.AddOptions.prototype.attempts;
 /** @type {(number|!Bull.Backoff)} */
tsickle_declare_module.bull.Bull.AddOptions.prototype.backoff;
 /** @type {boolean} */
tsickle_declare_module.bull.Bull.AddOptions.prototype.lifo;
 /** @type {number} */
tsickle_declare_module.bull.Bull.AddOptions.prototype.timeout;
/**
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.Queue = function() {};

/**
 * Defines a processing function for the jobs placed into a given Queue.
 * 
 * The callback is called everytime a job is placed in the queue.
 * It is passed an instance of the job as first argument.
 * 
 * The done callback can be called with an Error instance, to signal that the job did not complete successfully,
 * or with a result as second argument as second argument (e.g.: done(null, result);) when the job is successful.
 * Errors will be passed as a second argument to the "failed" event;
 * results, as a second argument to the "completed" event.
 * 
 * concurrency: Bull will then call you handler in parallel respecting this max number.
 * Defines a processing function for the jobs placed into a given Queue.
 * 
 * The callback is called everytime a job is placed in the queue.
 * It is passed an instance of the job as first argument.
 * 
 * The done callback can be called with an Error instance, to signal that the job did not complete successfully,
 * or with a result as second argument as second argument (e.g.: done(null, result);) when the job is successful.
 * Errors will be passed as a second argument to the "failed" event;
 * results, as a second argument to the "completed" event.
 * Defines a processing function for the jobs placed into a given Queue.
 * 
 * The callback is called everytime a job is placed in the queue.
 * It is passed an instance of the job as first argument.
 * 
 * A promise must be returned to signal job completion.
 * If the promise is rejected, the error will be passed as a second argument to the "failed" event.
 * If it is resolved, its value will be the "completed" event's second argument.
 * 
 * concurrency: Bull will then call you handler in parallel respecting this max number.
 * Defines a processing function for the jobs placed into a given Queue.
 * 
 * The callback is called everytime a job is placed in the queue.
 * It is passed an instance of the job as first argument.
 * 
 * A promise must be returned to signal job completion.
 * If the promise is rejected, the error will be passed as a second argument to the "failed" event.
 * If it is resolved, its value will be the "completed" event's second argument.
 * @param {number|function(!Bull.Job, !Bull.DoneCallback): void|function(!Bull.Job): void} concurrency_or_callback
 * @param {function(!Bull.Job, !Bull.DoneCallback): void|function(!Bull.Job): void=} callback
 * @return {void|!Promise<?>}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.process = function(concurrency_or_callback, callback) {};

/**
 * Creates a new job and adds it to the queue.
 * If the queue is empty the job will be executed directly,
 * otherwise it will be placed in the queue and executed as soon as possible.
 * @param {!Object} data
 * @param {!Bull.AddOptions=} opts
 * @return {!Promise<!Bull.Job>}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.add = function(data, opts) {};

/**
 * Returns a promise that resolves when the queue is paused.
 * The pause is global, meaning that all workers in all queue instances for a given queue will be paused.
 * A paused queue will not process new jobs until resumed,
 * but current jobs being processed will continue until they are finalized.
 * 
 * Pausing a queue that is already paused does nothing.
 * @return {!Promise<void>}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.pause = function() {};

/**
 * Returns a promise that resolves when the queue is resumed after being paused.
 * The resume is global, meaning that all workers in all queue instances for a given queue will be resumed.
 * 
 * Resuming a queue that is not paused does nothing.
 * @return {!Promise<void>}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.resume = function() {};

/**
 * Returns a promise that returns the number of jobs in the queue, waiting or paused.
 * Since there may be other processes adding or processing jobs, this value may be true only for a very small amount of time.
 * @return {!Promise<number>}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.count = function() {};

/**
 * Empties a queue deleting all the input lists and associated jobs.
 * @return {!Promise<void>}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.empty = function() {};

/**
 * Closes the underlying redis client. Use this to perform a graceful shutdown.
 * 
 * `close` can be called from anywhere, with one caveat:
 * if called from within a job handler the queue won't close until after the job has been processed
 * @return {!Promise<void>}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.close = function() {};

/**
 * Returns a promise that will return the job instance associated with the jobId parameter.
 * If the specified job cannot be located, the promise callback parameter will be set to null.
 * @param {string} jobId
 * @return {!Promise<!Bull.Job>}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.getJob = function(jobId) {};

/**
 * Tells the queue remove all jobs created outside of a grace period in milliseconds.
 * You can clean the jobs with the following states: completed, waiting, active, delayed, and failed.
 * @param {number} gracePeriod
 * @param {string=} jobsState
 * @return {!Promise<!Array<!Bull.Job>>}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.clean = function(gracePeriod, jobsState) {};

/**
 * Listens to queue events
 * 'ready', 'error', 'activ', 'progress', 'completed', 'failed', 'paused', 'resumed', 'cleaned'
 * @param {string} eventName
 * @param {!Bull.EventCallback} callback
 * @return {void}
 */
tsickle_declare_module.bull.Bull.Queue.prototype.on = function(eventName, callback) {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.EventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @extends {Bull.EventCallback}
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.ReadyEventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @extends {Bull.EventCallback}
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.ErrorEventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.JobPromise = function() {};

/**
 * Abort this job
 * @return {void}
 */
tsickle_declare_module.bull.Bull.JobPromise.prototype.cancel = function() {};
/**
 * @extends {Bull.EventCallback}
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.ActiveEventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @extends {Bull.EventCallback}
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.ProgressEventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @extends {Bull.EventCallback}
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.CompletedEventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @extends {Bull.EventCallback}
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.FailedEventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @extends {Bull.EventCallback}
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.PausedEventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @extends {Bull.EventCallback}
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.ResumedEventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */
/**
 * @extends {Bull.EventCallback}
 * @record
 * @struct
 */
tsickle_declare_module.bull.Bull.CleanedEventCallback = function() {};

/* TODO: CallSignature: tsickle_declare_module.bull.Bull */

/* TODO: ExportAssignment in tsickle_declare_module.bull */
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "bull/lib/priority-queue"
/** @const */
tsickle_declare_module.bull_lib_priority_queue = {};

/* TODO: ImportDeclaration in tsickle_declare_module.bull_lib_priority_queue */

/* TODO: ImportDeclaration in tsickle_declare_module.bull_lib_priority_queue */

/**
 * This is the Queue constructor of priority queue.
 * 
 * It works same a normal queue, with same function and parameters.
 * The only difference is that the Queue#add() allow an options opts.priority
 * that could take ["low", "normal", "medium", "hight", "critical"]. If no options provider, "normal" will be taken.
 * 
 * The priority queue will process more often highter priority jobs than lower.
 * @param {string} queueName
 * @param {number} redisPort
 * @param {string} redisHost
 * @param {?=} redisOpt
 * @return {!PQueue.PriorityQueue}
 */
tsickle_declare_module.bull_lib_priority_queue.PQueue = function(queueName, redisPort, redisHost, redisOpt) {};
/**
 * @extends {Bull.AddOptions}
 * @record
 * @struct
 */
tsickle_declare_module.bull_lib_priority_queue.PQueue.AddOptions = function() {};
 /** @type {string} */
tsickle_declare_module.bull_lib_priority_queue.PQueue.AddOptions.prototype.priority;
/**
 * @extends {Bull.Queue}
 * @record
 * @struct
 */
tsickle_declare_module.bull_lib_priority_queue.PQueue.PriorityQueue = function() {};

/**
 * Creates a new job and adds it to the queue.
 * If the queue is empty the job will be executed directly,
 * otherwise it will be placed in the queue and executed as soon as possible.
 * @param {!Object} data
 * @param {!PQueue.AddOptions=} opts
 * @return {!Promise<!Bull.Job>}
 */
tsickle_declare_module.bull_lib_priority_queue.PQueue.PriorityQueue.prototype.add = function(data, opts) {};

/* TODO: ExportAssignment in tsickle_declare_module.bull_lib_priority_queue */
