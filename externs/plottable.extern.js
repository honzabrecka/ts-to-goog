/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/plottable/index.d.ts:

/* TODO: ImportDeclaration in  */
/** @const */
var Plottable = {};
/** @const */
Plottable.Utils = {};
/** @const */
Plottable.Utils.Math = {};

/**
 * Checks if x is between a and b.
 * 
 * @param {number} x
 * @param {number} a
 * @param {number} b
 * @return {boolean}
 */
Plottable.Utils.Math.inRange = function(x, a, b) {};

/**
 * Clamps x to the range [min, max].
 * 
 * @param {number} x
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
Plottable.Utils.Math.clamp = function(x, min, max) {};

/**
 * Applies the accessor, if provided, to each element of `array` and returns the maximum value.
 * If no maximum value can be computed, returns defaultValue.
 * @template C, T
 * @param {!Array<C>|!Array<T>} array
 * @param {C|function(T, number): C} defaultValue_or_accessor
 * @param {C=} defaultValue
 * @return {C}
 */
Plottable.Utils.Math.max = function(array, defaultValue_or_accessor, defaultValue) {};

/**
 * Applies the accessor, if provided, to each element of `array` and returns the minimum value.
 * If no minimum value can be computed, returns defaultValue.
 * @template C, T
 * @param {!Array<C>|!Array<T>} array
 * @param {C|function(T, number): C} defaultValue_or_accessor
 * @param {C=} defaultValue
 * @return {C}
 */
Plottable.Utils.Math.min = function(array, defaultValue_or_accessor, defaultValue) {};

/**
 * Returns true **only** if x is NaN
 * @param {?} n
 * @return {boolean}
 */
Plottable.Utils.Math.isNaN = function(n) {};

/**
 * Returns true if the argument is a number, which is not NaN
 * Numbers represented as strings do not pass this function
 * @param {?} n
 * @return {boolean}
 */
Plottable.Utils.Math.isValidNumber = function(n) {};

/**
 * Generates an array of consecutive, strictly increasing numbers
 * in the range [start, stop) separeted by step
 * @param {number} start
 * @param {number} stop
 * @param {number=} step
 * @return {!Array<number>}
 */
Plottable.Utils.Math.range = function(start, stop, step) {};

/**
 * Returns the square of the distance between two points
 * 
 * @param {{x: number, y: number}} p1
 * @param {{x: number, y: number}} p2
 * @return {number}
 */
Plottable.Utils.Math.distanceSquared = function(p1, p2) {};

/**
 * @constructor
 * @struct
 */
Plottable.Utils.Map = function() {};

/**
 * @param {K} key
 * @param {V} value
 * @return {!Plottable.Utils.Map}
 */
Plottable.Utils.Map.prototype.set = function(key, value) {};

/**
 * @param {K} key
 * @return {V}
 */
Plottable.Utils.Map.prototype.get = function(key) {};

/**
 * @param {K} key
 * @return {boolean}
 */
Plottable.Utils.Map.prototype.has = function(key) {};

/**
 * @param {function(V, K, !Plottable.Utils.Map): void} callbackFn
 * @param {?=} thisArg
 * @return {void}
 */
Plottable.Utils.Map.prototype.forEach = function(callbackFn, thisArg) {};

/**
 * @param {K} key
 * @return {boolean}
 */
Plottable.Utils.Map.prototype.delete = function(key) {};

/**
 * @constructor
 * @struct
 */
Plottable.Utils.Set = function() {};
 /** @type {number} */
Plottable.Utils.Set.prototype.size;

/**
 * @param {T} value
 * @return {!Plottable.Utils.Set}
 */
Plottable.Utils.Set.prototype.add = function(value) {};

/**
 * @param {T} value
 * @return {boolean}
 */
Plottable.Utils.Set.prototype.delete = function(value) {};

/**
 * @param {T} value
 * @return {boolean}
 */
Plottable.Utils.Set.prototype.has = function(value) {};

/**
 * @param {function(T, T, !Plottable.Utils.Set): void} callback
 * @param {?=} thisArg
 * @return {void}
 */
Plottable.Utils.Set.prototype.forEach = function(callback, thisArg) {};
/** @const */
Plottable.Utils.DOM = {};

/**
 * Gets the bounding box of an element.
 * @param {!d3.Selection<?>} element
 * @return {!SVGRect}
 */
Plottable.Utils.DOM.elementBBox = function(element) {};
 /** @type {number} */
Plottable.Utils.DOM.SCREEN_REFRESH_RATE_MILLISECONDS;

/**
 * Polyfill for `window.requestAnimationFrame`.
 * If the function exists, then we use the function directly.
 * Otherwise, we set a timeout on `SCREEN_REFRESH_RATE_MILLISECONDS` and then perform the function.
 * 
 * @param {function(): void} callback
 * @return {void}
 */
Plottable.Utils.DOM.requestAnimationFramePolyfill = function(callback) {};

/**
 * Calculates the width of the element.
 * The width includes the padding and the border on the element's left and right sides.
 * 
 * @param {!Element} element
 * @return {number}
 */
Plottable.Utils.DOM.elementWidth = function(element) {};

/**
 * Calculates the height of the element.
 * The height includes the padding the and the border on the element's top and bottom sides.
 * 
 * @param {!Element} element
 * @return {number}
 */
Plottable.Utils.DOM.elementHeight = function(element) {};

/**
 * Retrieves the number array representing the translation for the selection
 * 
 * Translates the given selection by the input x / y pixel amounts.
 * 
 * @param {!d3.Selection<?>} selection
 * @param {number=} x
 * @param {number=} y
 * @return {!Array<?>|!d3.Selection<?>}
 */
Plottable.Utils.DOM.translate = function(selection, x, y) {};

/**
 * Checks if the first ClientRect overlaps the second.
 * 
 * @param {!ClientRect} clientRectA
 * @param {!ClientRect} clientRectB
 * @return {boolean}
 */
Plottable.Utils.DOM.clientRectsOverlap = function(clientRectA, clientRectB) {};

/**
 * Returns true if and only if innerClientRect is inside outerClientRect.
 * 
 * @param {!ClientRect} innerClientRect
 * @param {!ClientRect} outerClientRect
 * @return {boolean}
 */
Plottable.Utils.DOM.clientRectInside = function(innerClientRect, outerClientRect) {};

/**
 * Retrieves the bounding svg of the input element
 * 
 * @param {!SVGElement} element
 * @return {!SVGElement}
 */
Plottable.Utils.DOM.boundingSVG = function(element) {};

/**
 * Generates a ClipPath ID that is unique for this instance of Plottable
 * @return {string}
 */
Plottable.Utils.DOM.generateUniqueClipPathId = function() {};

/**
 * Returns true if the supplied coordinates or Ranges intersect or are contained by bbox.
 * 
 * testing intersection
 * 
 * contained by bbox, false otherwise.
 * @param {(number|{min: number, max: number})} xValOrRange
 * @param {(number|{min: number, max: number})} yValOrRange
 * @param {!SVGRect} bbox
 * @param {number=} tolerance
 * @return {boolean}
 */
Plottable.Utils.DOM.intersectsBBox = function(xValOrRange, yValOrRange, bbox, tolerance) {};
/** @const */
Plottable.Utils.Color = {};

/**
 * Return contrast ratio between two colors
 * Based on implementation from chroma.js by Gregor Aisch (gka) (licensed under BSD)
 * chroma.js may be found here: https://github.com/gka/chroma.js
 * License may be found here: https://github.com/gka/chroma.js/blob/master/LICENSE
 * see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
Plottable.Utils.Color.contrast = function(a, b) {};

/**
 * Returns a brighter copy of this color. Each channel is multiplied by 0.7 ^ -factor.
 * Channel values are capped at the maximum value of 255, and the minimum value of 30.
 * @param {string} color
 * @param {number} factor
 * @return {string}
 */
Plottable.Utils.Color.lightenColor = function(color, factor) {};

/**
 * Gets the Hex Code of the color resulting by applying the className CSS class to the
 * colorTester selection. Returns null if the tester is transparent.
 * 
 * @param {!d3.Selection<void>} colorTester
 * @param {string} className
 * @return {string}
 */
Plottable.Utils.Color.colorTest = function(colorTester, className) {};
/** @const */
Plottable.Utils.Array = {};

/**
 * Takes two arrays of numbers and adds them together
 * 
 * @param {!Array<number>} aList
 * @param {!Array<number>} bList
 * @return {!Array<number>}
 */
Plottable.Utils.Array.add = function(aList, bList) {};

/**
 * Take an array of values, and return the unique values.
 * Will work iff âˆ€ a, b, a.toString() == b.toString() => a == b; will break on Object inputs
 * 
 * @template T
 * @param {!Array<T>} arr
 * @return {!Array<T>}
 */
Plottable.Utils.Array.uniq = function(arr) {};

/**
 * @template T
 * @param {!Array<!Array<T>>} a
 * @return {!Array<T>}
 */
Plottable.Utils.Array.flatten = function(a) {};

/**
 * Creates an array of length `count`, filled with value or (if value is a function), value()
 * 
 * @template T
 * @param {(T|function(number): T)} value
 * @param {number} count
 * @return {!Array<T>}
 */
Plottable.Utils.Array.createFilledArray = function(value, count) {};
/**
 * @extends {Plottable.Utils.Set}
 * @constructor
 * @struct
 */
Plottable.Utils.CallbackSet = function() {};

/**
 * @param {...?} args
 * @return {!Plottable.Utils.CallbackSet}
 */
Plottable.Utils.CallbackSet.prototype.callCallbacks = function(args) {};
/** @const */
Plottable.Utils.Stacking = {};

/** @typedef {{value: number, offset: number}} */
Plottable.Utils.Stacking.StackedDatum;

/** @typedef {!Plottable.Utils.Map<!Plottable.Dataset, !Plottable.Utils.Map<string, {value: number, offset: number}>>} */
Plottable.Utils.Stacking.StackingResult;

/**
 * Computes the StackingResult (value and offset) for each data point in each Dataset.
 * 
 * @param {!Array<!Plottable.Dataset>} datasets
 * @param {!Plottable.Accessor<?>} keyAccessor
 * @param {!Plottable.Accessor<number>} valueAccessor
 * @return {!Plottable.Utils.Map<!Plottable.Dataset, !Plottable.Utils.Map<string, {value: number, offset: number}>>}
 */
Plottable.Utils.Stacking.stack = function(datasets, keyAccessor, valueAccessor) {};

/**
 * Computes the total extent over all data points in all Datasets, taking stacking into consideration.
 * 
 * \@oaram {Accessor<any>} keyAccessor Accessor for the key of the data existent in the stackingResult
 * @param {!Plottable.Utils.Map<!Plottable.Dataset, !Plottable.Utils.Map<string, {value: number, offset: number}>>} stackingResult
 * @param {!Plottable.Accessor<?>} keyAccessor
 * @param {!Plottable.Accessor<boolean>} filter
 * @return {!Array<number>}
 */
Plottable.Utils.Stacking.stackedExtent = function(stackingResult, keyAccessor, filter) {};

/**
 * Normalizes a key used for stacking
 * 
 * @param {?} key
 * @return {string}
 */
Plottable.Utils.Stacking.normalizeKey = function(key) {};
/** @const */
Plottable.Utils.Window = {};

/**
 * Print a warning message to the console, if it is available.
 * 
 * @param {string} warning
 * @return {void}
 */
Plottable.Utils.Window.warn = function(warning) {};

/**
 * Is like setTimeout, but activates synchronously if time=0
 * We special case 0 because of an observed issue where calling setTimeout causes visible flickering.
 * We believe this is because when requestAnimationFrame calls into the paint function, as soon as that function finishes
 * evaluating, the results are painted to the screen. As a result, if we want something to occur immediately but call setTimeout
 * with time=0, then it is pushed to the call stack and rendered in the next frame, so the component that was rendered via
 * setTimeout appears out-of-sync with the rest of the plot.
 * @param {!Function} f
 * @param {number} time
 * @param {...?} args
 * @return {number}
 */
Plottable.Utils.Window.setTimeout = function(f, time, args) {};

/**
 * Sends a deprecation warning to the console. The warning includes the name of the deprecated method,
 * version number of the deprecation, and an optional message.
 * 
 * To be used in the first line of a deprecated method.
 * 
 * @param {string} callingMethod
 * @param {string} version
 * @param {string=} message
 * @return {void}
 */
Plottable.Utils.Window.deprecated = function(callingMethod, version, message) {};

/**
 * @constructor
 * @struct
 * @param {!SVGElement} svg
 */
Plottable.Utils.ClientToSVGTranslator = function(svg) {};

/**
 * Returns the ClientToSVGTranslator for the <svg> containing elem.
 * If one already exists on that <svg>, it will be returned; otherwise, a new one will be created.
 * @param {!SVGElement} elem
 * @return {!Plottable.Utils.ClientToSVGTranslator}
 */
Plottable.Utils.ClientToSVGTranslator.getTranslator = function(elem) {};

/**
 * Computes the position relative to the <svg> in svg-coordinate-space.
 * @param {number} clientX
 * @param {number} clientY
 * @return {{x: number, y: number}}
 */
Plottable.Utils.ClientToSVGTranslator.prototype.computePosition = function(clientX, clientY) {};

/**
 * Checks whether event happened inside <svg> element.
 * @param {!Event} e
 * @return {boolean}
 */
Plottable.Utils.ClientToSVGTranslator.prototype.insideSVG = function(e) {};
/** @const */
Plottable.Configs = {};
 /** @type {boolean} */
Plottable.Configs.SHOW_WARNINGS;
 /** @type {string} */
Plottable.version;

/** @typedef {function(!Plottable.Dataset): void} */
Plottable.DatasetCallback;

/**
 * @constructor
 * @struct
 * A Dataset contains an array of data and some metadata.
 * Changes to the data or metadata will cause anything subscribed to the Dataset to update.
 * 
 * @param {!Array<?>=} data
 * @param {?=} metadata
 */
Plottable.Dataset = function(data, metadata) {};

/**
 * Adds a callback to be called when the Dataset updates.
 * 
 * @param {function(!Plottable.Dataset): void} callback
 * @return {!Plottable.Dataset}
 */
Plottable.Dataset.prototype.onUpdate = function(callback) {};

/**
 * Removes a callback that would be called when the Dataset updates.
 * 
 * @param {function(!Plottable.Dataset): void} callback
 * @return {!Plottable.Dataset}
 */
Plottable.Dataset.prototype.offUpdate = function(callback) {};

/**
 * Gets the data.
 * 
 * Sets the data.
 * 
 * @param {!Array<?>=} data
 * @return {!Array<?>|!Plottable.Dataset}
 */
Plottable.Dataset.prototype.data = function(data) {};

/**
 * Gets the metadata.
 * 
 * Sets the metadata.
 * 
 * @param {?=} metadata
 * @return {?|!Plottable.Dataset}
 */
Plottable.Dataset.prototype.metadata = function(metadata) {};
/** @const */
Plottable.RenderPolicies = {};
/**
 * @record
 * @struct
 */
Plottable.RenderPolicies.RenderPolicy = function() {};

/**
 * @return {?}
 */
Plottable.RenderPolicies.RenderPolicy.prototype.render = function() {};
/**
 * @implements {Plottable.RenderPolicies.RenderPolicy}
 * @constructor
 * @struct
 */
Plottable.RenderPolicies.Immediate = function() {};

/**
 * @return {void}
 */
Plottable.RenderPolicies.Immediate.prototype.render = function() {};
/**
 * @implements {Plottable.RenderPolicies.RenderPolicy}
 * @constructor
 * @struct
 */
Plottable.RenderPolicies.AnimationFrame = function() {};

/**
 * @return {void}
 */
Plottable.RenderPolicies.AnimationFrame.prototype.render = function() {};
/**
 * @implements {Plottable.RenderPolicies.RenderPolicy}
 * @constructor
 * @struct
 */
Plottable.RenderPolicies.Timeout = function() {};

/**
 * @return {void}
 */
Plottable.RenderPolicies.Timeout.prototype.render = function() {};
/** @const */
Plottable.RenderController = {};
/** @const */
Plottable.RenderController.Policy = {};
 /** @type {string} */
Plottable.RenderController.Policy.IMMEDIATE;
 /** @type {string} */
Plottable.RenderController.Policy.ANIMATION_FRAME;
 /** @type {string} */
Plottable.RenderController.Policy.TIMEOUT;

/**
 * @param {string=} renderPolicy
 * @return {!Plottable.RenderPolicies.RenderPolicy|void}
 */
Plottable.RenderController.renderPolicy = function(renderPolicy) {};

/**
 * Enqueues the Component for rendering.
 * 
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.RenderController.registerToRender = function(component) {};

/**
 * Enqueues the Component for layout and rendering.
 * 
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.RenderController.registerToComputeLayout = function(component) {};

/**
 * Renders all Components waiting to be rendered immediately
 * instead of waiting until the next frame.
 * 
 * Useful to call when debugging.
 * @return {void}
 */
Plottable.RenderController.flush = function() {};
/**
 * @record
 * @struct
 */
Plottable.Accessor = function() {};

/* TODO: CallSignature: Plottable */

/** @typedef {function(?, number, !Plottable.Dataset): ?} */
Plottable.Projector;

/** @typedef {!Object<string,function(?, number, !Plottable.Dataset): ?>} */
Plottable.AttributeToProjector;

/** @typedef {function(?, number): ?} */
Plottable.AppliedProjector;

/** @typedef {!Object<string,function(?, number): ?>} */
Plottable.AttributeToAppliedProjector;

/** @typedef {{minWidth: number, minHeight: number}} */
Plottable.SpaceRequest;

/** @typedef {{min: number, max: number}} */
Plottable.Range;

/** @typedef {{x: number, y: number}} */
Plottable.Point;

/** @typedef {{topLeft: {x: number, y: number}, bottomRight: ?}} */
Plottable.Bounds;
/**
 * @record
 * @struct
 */
Plottable.Entity = function() {};
 /** @type {?} */
Plottable.Entity.prototype.datum;
 /** @type {{x: number, y: number}} */
Plottable.Entity.prototype.position;
 /** @type {!d3.Selection<?>} */
Plottable.Entity.prototype.selection;
 /** @type {C} */
Plottable.Entity.prototype.component;

/** @typedef {function(?): string} */
Plottable.Formatter;
 /** @type {number} */
Plottable.MILLISECONDS_IN_ONE_DAY;
/** @const */
Plottable.Formatters = {};

/**
 * Creates a formatter for currency values.
 * 
 * 
 * @param {number=} precision
 * @param {string=} symbol
 * @param {boolean=} prefix
 * @return {function(?): string}
 */
Plottable.Formatters.currency = function(precision, symbol, prefix) {};

/**
 * Creates a formatter that displays exactly [precision] decimal places.
 * 
 * 
 * @param {number=} precision
 * @return {function(?): string}
 */
Plottable.Formatters.fixed = function(precision) {};

/**
 * Creates a formatter that formats numbers to show no more than
 * [precision] decimal places. All other values are stringified.
 * 
 * 
 * @param {number=} precision
 * @return {function(?): string}
 */
Plottable.Formatters.general = function(precision) {};

/**
 * Creates a formatter that stringifies its input.
 * 
 * @return {function(?): string}
 */
Plottable.Formatters.identity = function() {};

/**
 * Creates a formatter for percentage values.
 * Multiplies the input by 100 and appends "%".
 * 
 * 
 * @param {number=} precision
 * @return {function(?): string}
 */
Plottable.Formatters.percentage = function(precision) {};

/**
 * Creates a formatter for values that displays [precision] significant figures
 * and puts SI notation.
 * 
 * 
 * @param {number=} precision
 * @return {function(?): string}
 */
Plottable.Formatters.siSuffix = function(precision) {};

/**
 * Creates a multi time formatter that displays dates.
 * 
 * @return {function(?): string}
 */
Plottable.Formatters.multiTime = function() {};

/**
 * Creates a time formatter that displays time/date using given specifier.
 * 
 * List of directives can be found on: https://github.com/mbostock/d3/wiki/Time-Formatting#format
 * 
 * 
 * @param {string} specifier
 * @return {function(?): string}
 */
Plottable.Formatters.time = function(specifier) {};

/**
 * Creates a formatter for relative dates.
 * 
 * 
 * @param {number=} baseValue
 * @param {number=} increment
 * @param {string=} label
 * @return {function(?): string}
 */
Plottable.Formatters.relativeDate = function(baseValue, increment, label) {};

/** @typedef {function(number): string} */
Plottable.SymbolFactory;
/** @const */
Plottable.SymbolFactories = {};

/**
 * @return {function(number): string}
 */
Plottable.SymbolFactories.circle = function() {};

/**
 * @return {function(number): string}
 */
Plottable.SymbolFactories.square = function() {};

/**
 * @return {function(number): string}
 */
Plottable.SymbolFactories.cross = function() {};

/**
 * @return {function(number): string}
 */
Plottable.SymbolFactories.diamond = function() {};

/**
 * @return {function(number): string}
 */
Plottable.SymbolFactories.triangleUp = function() {};

/**
 * @return {function(number): string}
 */
Plottable.SymbolFactories.triangleDown = function() {};
/**
 * @record
 * @struct
 */
Plottable.ScaleCallback = function() {};

/* TODO: CallSignature: Plottable */
/** @const */
Plottable.Scales = {};
/**
 * @record
 * @struct
 */
Plottable.Scales.IncludedValuesProvider = function() {};

/* TODO: CallSignature: Plottable.Scales */
/**
 * @record
 * @struct
 */
Plottable.Scales.PaddingExceptionsProvider = function() {};

/* TODO: CallSignature: Plottable.Scales */

/**
 * @constructor
 * @struct
 * A Scale is a function (in the mathematical sense) that maps values from a domain to a range.
 * 
 */
Plottable.Scale = function() {};

/**
 * Given an array of potential domain values, computes the extent of those values.
 * 
 * @param {!Array<D>} values
 * @return {!Array<D>}
 */
Plottable.Scale.prototype.extentOfValues = function(values) {};

/**
 * @return {!Array<D>}
 */
Plottable.Scale.prototype._getAllIncludedValues = function() {};

/**
 * @return {!Array<D>}
 */
Plottable.Scale.prototype._getExtent = function() {};

/**
 * Adds a callback to be called when the Scale updates.
 * 
 * @param {!Plottable.ScaleCallback<!Plottable.Scale>} callback
 * @return {!Plottable.Scale}
 */
Plottable.Scale.prototype.onUpdate = function(callback) {};

/**
 * Removes a callback that would be called when the Scale updates.
 * 
 * @param {!Plottable.ScaleCallback<!Plottable.Scale>} callback
 * @return {!Plottable.Scale}
 */
Plottable.Scale.prototype.offUpdate = function(callback) {};

/**
 * @return {void}
 */
Plottable.Scale.prototype._dispatchUpdate = function() {};

/**
 * Sets the Scale's domain so that it spans the Extents of all its ExtentsProviders.
 * 
 * @return {!Plottable.Scale}
 */
Plottable.Scale.prototype.autoDomain = function() {};

/**
 * @return {void}
 */
Plottable.Scale.prototype._autoDomainIfAutomaticMode = function() {};

/**
 * Computes the range value corresponding to a given domain value.
 * 
 * @param {D} value
 * @return {R}
 */
Plottable.Scale.prototype.scale = function(value) {};

/**
 * Gets the domain.
 * 
 * Sets the domain.
 * 
 * @param {!Array<D>=} values
 * @return {!Array<D>|!Plottable.Scale}
 */
Plottable.Scale.prototype.domain = function(values) {};

/**
 * @return {void}
 */
Plottable.Scale.prototype._getDomain = function() {};

/**
 * @param {!Array<D>} values
 * @return {void}
 */
Plottable.Scale.prototype._setDomain = function(values) {};

/**
 * @param {!Array<D>} values
 * @return {void}
 */
Plottable.Scale.prototype._setBackingScaleDomain = function(values) {};

/**
 * Gets the range.
 * 
 * Sets the range.
 * 
 * @param {!Array<R>=} values
 * @return {!Array<R>|!Plottable.Scale}
 */
Plottable.Scale.prototype.range = function(values) {};

/**
 * @return {void}
 */
Plottable.Scale.prototype._getRange = function() {};

/**
 * @param {!Array<R>} values
 * @return {void}
 */
Plottable.Scale.prototype._setRange = function(values) {};

/**
 * Adds an IncludedValuesProvider to the Scale.
 * 
 * @param {!Plottable.Scales.IncludedValuesProvider<D>} provider
 * @return {!Plottable.Scale}
 */
Plottable.Scale.prototype.addIncludedValuesProvider = function(provider) {};

/**
 * Removes the IncludedValuesProvider from the Scale.
 * 
 * @param {!Plottable.Scales.IncludedValuesProvider<D>} provider
 * @return {!Plottable.Scale}
 */
Plottable.Scale.prototype.removeIncludedValuesProvider = function(provider) {};

/**
 * @constructor
 * @struct
 * A QuantitativeScale is a Scale that maps number-like values to numbers.
 * It is invertible and continuous.
 * 
 */
Plottable.QuantitativeScale = function() {};
 /** @type {number} */
Plottable.QuantitativeScale._DEFAULT_NUM_TICKS;

/**
 * @return {!Plottable.QuantitativeScale}
 */
Plottable.QuantitativeScale.prototype.autoDomain = function() {};

/**
 * @return {void}
 */
Plottable.QuantitativeScale.prototype._autoDomainIfAutomaticMode = function() {};

/**
 * @return {!Array<D>}
 */
Plottable.QuantitativeScale.prototype._getExtent = function() {};

/**
 * Adds a padding exception provider.
 * If one end of the domain is set to an excepted value as a result of autoDomain()-ing,
 * that end of the domain will not be padded.
 * 
 * @param {!Plottable.Scales.PaddingExceptionsProvider<D>} provider
 * @return {!Plottable.QuantitativeScale}
 */
Plottable.QuantitativeScale.prototype.addPaddingExceptionsProvider = function(provider) {};

/**
 * Removes the padding exception provider.
 * 
 * @param {!Plottable.Scales.PaddingExceptionsProvider<D>} provider
 * @return {!Plottable.QuantitativeScale}
 */
Plottable.QuantitativeScale.prototype.removePaddingExceptionsProvider = function(provider) {};

/**
 * Gets the padding proportion.
 * Sets the padding porportion.
 * When autoDomain()-ing, the computed domain will be expanded by this proportion,
 * then rounded to human-readable values.
 * 
 * @param {number=} padProportion
 * @return {number|!Plottable.QuantitativeScale}
 */
Plottable.QuantitativeScale.prototype.padProportion = function(padProportion) {};

/**
 * @param {!Array<D>} singleValueDomain
 * @return {!Array<D>}
 */
Plottable.QuantitativeScale.prototype._expandSingleValueDomain = function(singleValueDomain) {};

/**
 * Computes the domain value corresponding to a supplied range value.
 * 
 * @param {number} value
 * @return {D}
 */
Plottable.QuantitativeScale.prototype.invert = function(value) {};

/**
 * @param {!Array<D>=} values
 * @return {!Array<D>|!Plottable.QuantitativeScale}
 */
Plottable.QuantitativeScale.prototype.domain = function(values) {};

/**
 * Gets the lower end of the domain.
 * 
 * Sets the lower end of the domain.
 * 
 * @param {D=} domainMin
 * @return {D|!Plottable.QuantitativeScale}
 */
Plottable.QuantitativeScale.prototype.domainMin = function(domainMin) {};

/**
 * Gets the upper end of the domain.
 * 
 * Sets the upper end of the domain.
 * 
 * @param {D=} domainMax
 * @return {D|!Plottable.QuantitativeScale}
 */
Plottable.QuantitativeScale.prototype.domainMax = function(domainMax) {};

/**
 * @param {!Array<D>} values
 * @return {!Array<D>}
 */
Plottable.QuantitativeScale.prototype.extentOfValues = function(values) {};

/**
 * @param {!Array<D>} values
 * @return {void}
 */
Plottable.QuantitativeScale.prototype._setDomain = function(values) {};

/**
 * Gets the array of tick values generated by the default algorithm.
 * @return {!Array<D>}
 */
Plottable.QuantitativeScale.prototype.defaultTicks = function() {};

/**
 * Gets an array of tick values spanning the domain.
 * 
 * @return {!Array<D>}
 */
Plottable.QuantitativeScale.prototype.ticks = function() {};

/**
 * Given a domain, expands its domain onto "nice" values, e.g. whole
 * numbers.
 * @param {!Array<D>} domain
 * @param {number=} count
 * @return {!Array<D>}
 */
Plottable.QuantitativeScale.prototype._niceDomain = function(domain, count) {};

/**
 * @return {!Array<D>}
 */
Plottable.QuantitativeScale.prototype._defaultExtent = function() {};

/**
 * Gets the TickGenerator.
 * Sets the TickGenerator
 * 
 * @param {!Plottable.Scales.TickGenerators.TickGenerator<D>=} generator
 * @return {!Plottable.Scales.TickGenerators.TickGenerator<D>|!Plottable.QuantitativeScale}
 */
Plottable.QuantitativeScale.prototype.tickGenerator = function(generator) {};

/**
 * @constructor
 * @struct
 */
Plottable.Scales.Linear = function() {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.Linear.prototype._defaultExtent = function() {};

/**
 * @param {!Array<number>} singleValueDomain
 * @return {!Array<number>}
 */
Plottable.Scales.Linear.prototype._expandSingleValueDomain = function(singleValueDomain) {};

/**
 * @param {number} value
 * @return {number}
 */
Plottable.Scales.Linear.prototype.scale = function(value) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.Linear.prototype._getDomain = function() {};

/**
 * @param {!Array<number>} values
 * @return {void}
 */
Plottable.Scales.Linear.prototype._setBackingScaleDomain = function(values) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.Linear.prototype._getRange = function() {};

/**
 * @param {!Array<number>} values
 * @return {void}
 */
Plottable.Scales.Linear.prototype._setRange = function(values) {};

/**
 * @param {number} value
 * @return {number}
 */
Plottable.Scales.Linear.prototype.invert = function(value) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.Linear.prototype.defaultTicks = function() {};

/**
 * @param {!Array<number>} domain
 * @param {number=} count
 * @return {!Array<number>}
 */
Plottable.Scales.Linear.prototype._niceDomain = function(domain, count) {};

/**
 * @constructor
 * @struct
 * A ModifiedLog Scale acts as a regular log scale for large numbers.
 * As it approaches 0, it gradually becomes linear.
 * Consequently, a ModifiedLog Scale can process 0 and negative numbers.
 * 
 *        The base of the log. Must be > 1.
 * 
 *        For x <= base, scale(x) = log(x).
 * 
 *        For 0 < x < base, scale(x) will become more and more
 *        linear as it approaches 0.
 * 
 *        At x == 0, scale(x) == 0.
 * 
 *        For negative values, scale(-x) = -scale(x).
 * @param {number=} base
 */
Plottable.Scales.ModifiedLog = function(base) {};

/**
 * @param {number} x
 * @return {number}
 */
Plottable.Scales.ModifiedLog.prototype.scale = function(x) {};

/**
 * @param {number} x
 * @return {number}
 */
Plottable.Scales.ModifiedLog.prototype.invert = function(x) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.ModifiedLog.prototype._getDomain = function() {};

/**
 * @param {!Array<number>} values
 * @return {void}
 */
Plottable.Scales.ModifiedLog.prototype._setDomain = function(values) {};

/**
 * @param {!Array<number>} values
 * @return {void}
 */
Plottable.Scales.ModifiedLog.prototype._setBackingScaleDomain = function(values) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.ModifiedLog.prototype.ticks = function() {};

/**
 * @param {!Array<number>} domain
 * @param {number=} count
 * @return {!Array<number>}
 */
Plottable.Scales.ModifiedLog.prototype._niceDomain = function(domain, count) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.ModifiedLog.prototype._defaultExtent = function() {};

/**
 * @param {!Array<number>} singleValueDomain
 * @return {!Array<number>}
 */
Plottable.Scales.ModifiedLog.prototype._expandSingleValueDomain = function(singleValueDomain) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.ModifiedLog.prototype._getRange = function() {};

/**
 * @param {!Array<number>} values
 * @return {void}
 */
Plottable.Scales.ModifiedLog.prototype._setRange = function(values) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.ModifiedLog.prototype.defaultTicks = function() {};

/**
 * @constructor
 * @struct
 * A Category Scale maps strings to numbers.
 * 
 */
Plottable.Scales.Category = function() {};

/**
 * @param {!Array<string>} values
 * @return {!Array<string>}
 */
Plottable.Scales.Category.prototype.extentOfValues = function(values) {};

/**
 * @return {!Array<string>}
 */
Plottable.Scales.Category.prototype._getExtent = function() {};

/**
 * @param {!Array<string>=} values
 * @return {!Array<string>|!Plottable.Scales.Category}
 */
Plottable.Scales.Category.prototype.domain = function(values) {};

/**
 * @param {!Array<string>} values
 * @return {void}
 */
Plottable.Scales.Category.prototype._setDomain = function(values) {};

/**
 * @param {!Array<?>=} values
 * @return {!Array<?>|!Plottable.Scales.Category}
 */
Plottable.Scales.Category.prototype.range = function(values) {};

/**
 * Returns the width of the range band.
 * 
 * @return {number}
 */
Plottable.Scales.Category.prototype.rangeBand = function() {};

/**
 * Returns the step width of the scale.
 * 
 * The step width is the pixel distance between adjacent values in the domain.
 * 
 * @return {number}
 */
Plottable.Scales.Category.prototype.stepWidth = function() {};

/**
 * Gets the inner padding.
 * 
 * The inner padding is defined as the padding in between bands on the scale,
 * expressed as a multiple of the rangeBand().
 * 
 * Sets the inner padding.
 * 
 * The inner padding is defined as the padding in between bands on the scale,
 * expressed as a multiple of the rangeBand().
 * 
 * @param {number=} innerPadding
 * @return {number|!Plottable.Scales.Category}
 */
Plottable.Scales.Category.prototype.innerPadding = function(innerPadding) {};

/**
 * Gets the outer padding.
 * 
 * The outer padding is the padding in between the outer bands and the edges of the range,
 * expressed as a multiple of the rangeBand().
 * 
 * Sets the outer padding.
 * 
 * The outer padding is the padding in between the outer bands and the edges of the range,
 * expressed as a multiple of the rangeBand().
 * 
 * @param {number=} outerPadding
 * @return {number|!Plottable.Scales.Category}
 */
Plottable.Scales.Category.prototype.outerPadding = function(outerPadding) {};

/**
 * @param {string} value
 * @return {number}
 */
Plottable.Scales.Category.prototype.scale = function(value) {};

/**
 * @return {!Array<string>}
 */
Plottable.Scales.Category.prototype._getDomain = function() {};

/**
 * @param {!Array<string>} values
 * @return {void}
 */
Plottable.Scales.Category.prototype._setBackingScaleDomain = function(values) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.Category.prototype._getRange = function() {};

/**
 * @param {!Array<number>} values
 * @return {void}
 */
Plottable.Scales.Category.prototype._setRange = function(values) {};

/**
 * @constructor
 * @struct
 * A Color Scale maps string values to color hex values expressed as a string.
 * 
 *   (see https://github.com/mbostock/d3/wiki/Ordinal-Scales#categorical-colors)
 *   If not supplied, reads the colors defined using CSS -- see plottable.css.
 * @param {string=} scaleType
 */
Plottable.Scales.Color = function(scaleType) {};

/**
 * @param {!Array<string>} values
 * @return {!Array<string>}
 */
Plottable.Scales.Color.prototype.extentOfValues = function(values) {};

/**
 * @return {!Array<string>}
 */
Plottable.Scales.Color.prototype._getExtent = function() {};

/**
 * @return {void}
 */
Plottable.Scales.Color.invalidateColorCache = function() {};

/**
 * Returns the color-string corresponding to a given string.
 * If there are not enough colors in the range(), a lightened version of an existing color will be used.
 * 
 * @param {string} value
 * @return {string}
 */
Plottable.Scales.Color.prototype.scale = function(value) {};

/**
 * @return {!Array<string>}
 */
Plottable.Scales.Color.prototype._getDomain = function() {};

/**
 * @param {!Array<string>} values
 * @return {void}
 */
Plottable.Scales.Color.prototype._setBackingScaleDomain = function(values) {};

/**
 * @return {!Array<string>}
 */
Plottable.Scales.Color.prototype._getRange = function() {};

/**
 * @param {!Array<string>} values
 * @return {void}
 */
Plottable.Scales.Color.prototype._setRange = function(values) {};

/**
 * @constructor
 * @struct
 * A Time Scale maps Date objects to numbers.
 * 
 */
Plottable.Scales.Time = function() {};

/**
 * Returns an array of ticks values separated by the specified interval.
 * 
 * @param {string} interval
 * @param {number=} step
 * @return {!Array<!Date>}
 */
Plottable.Scales.Time.prototype.tickInterval = function(interval, step) {};

/**
 * @param {!Array<!Date>} values
 * @return {void}
 */
Plottable.Scales.Time.prototype._setDomain = function(values) {};

/**
 * @return {!Array<!Date>}
 */
Plottable.Scales.Time.prototype._defaultExtent = function() {};

/**
 * @param {!Array<!Date>} singleValueDomain
 * @return {!Array<!Date>}
 */
Plottable.Scales.Time.prototype._expandSingleValueDomain = function(singleValueDomain) {};

/**
 * @param {!Date} value
 * @return {number}
 */
Plottable.Scales.Time.prototype.scale = function(value) {};

/**
 * @return {!Array<!Date>}
 */
Plottable.Scales.Time.prototype._getDomain = function() {};

/**
 * @param {!Array<!Date>} values
 * @return {void}
 */
Plottable.Scales.Time.prototype._setBackingScaleDomain = function(values) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.Time.prototype._getRange = function() {};

/**
 * @param {!Array<number>} values
 * @return {void}
 */
Plottable.Scales.Time.prototype._setRange = function(values) {};

/**
 * @param {number} value
 * @return {!Date}
 */
Plottable.Scales.Time.prototype.invert = function(value) {};

/**
 * @return {!Array<!Date>}
 */
Plottable.Scales.Time.prototype.defaultTicks = function() {};

/**
 * @param {!Array<!Date>} domain
 * @return {!Array<!Date>}
 */
Plottable.Scales.Time.prototype._niceDomain = function(domain) {};

/**
 * Transforms the Plottable TimeInterval string into a d3 time interval equivalent.
 * If the provided TimeInterval is incorrect, the default is d3.time.year
 * @param {string} timeInterval
 * @return {!d3.time.Interval}
 */
Plottable.Scales.Time.timeIntervalToD3Time = function(timeInterval) {};

/**
 * @constructor
 * @struct
 * An InterpolatedColor Scale maps numbers to color hex values, expressed as strings.
 * 
 * @param {string=} scaleType
 */
Plottable.Scales.InterpolatedColor = function(scaleType) {};
 /** @type {!Array<string>} */
Plottable.Scales.InterpolatedColor.REDS;
 /** @type {!Array<string>} */
Plottable.Scales.InterpolatedColor.BLUES;
 /** @type {!Array<string>} */
Plottable.Scales.InterpolatedColor.POSNEG;

/**
 * @param {!Array<number>} values
 * @return {!Array<number>}
 */
Plottable.Scales.InterpolatedColor.prototype.extentOfValues = function(values) {};

/**
 * @return {!Plottable.Scales.InterpolatedColor}
 */
Plottable.Scales.InterpolatedColor.prototype.autoDomain = function() {};

/**
 * @param {number} value
 * @return {string}
 */
Plottable.Scales.InterpolatedColor.prototype.scale = function(value) {};

/**
 * @return {!Array<number>}
 */
Plottable.Scales.InterpolatedColor.prototype._getDomain = function() {};

/**
 * @param {!Array<number>} values
 * @return {void}
 */
Plottable.Scales.InterpolatedColor.prototype._setBackingScaleDomain = function(values) {};

/**
 * @return {!Array<string>}
 */
Plottable.Scales.InterpolatedColor.prototype._getRange = function() {};

/**
 * @param {!Array<string>} range
 * @return {void}
 */
Plottable.Scales.InterpolatedColor.prototype._setRange = function(range) {};
/** @const */
Plottable.Scales.TickGenerators = {};
/**
 * @record
 * @struct
 */
Plottable.Scales.TickGenerators.TickGenerator = function() {};

/* TODO: CallSignature: Plottable.Scales.TickGenerators */

/**
 * Creates a TickGenerator using the specified interval.
 * 
 * Generates ticks at multiples of the interval while also including the domain boundaries.
 * 
 * @param {number} interval
 * @return {!Plottable.Scales.TickGenerators.TickGenerator<number>}
 */
Plottable.Scales.TickGenerators.intervalTickGenerator = function(interval) {};

/**
 * Creates a TickGenerator returns only integer tick values.
 * 
 * @return {!Plottable.Scales.TickGenerators.TickGenerator<number>}
 */
Plottable.Scales.TickGenerators.integerTickGenerator = function() {};
/** @const */
Plottable.Drawers = {};

/** @typedef {{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}} */
Plottable.Drawers.DrawStep;

/** @typedef {{attrToAppliedProjector: !Object<string,function(?, number): ?>, animator: !Plottable.Animator}} */
Plottable.Drawers.AppliedDrawStep;

/**
 * @constructor
 * @struct
 * A Drawer draws svg elements based on the input Dataset.
 * 
 * @param {!Plottable.Dataset} dataset
 */
Plottable.Drawer = function(dataset) {};
 /** @type {string} */
Plottable.Drawer.prototype._svgElementName;
 /** @type {string} */
Plottable.Drawer.prototype._className;

/**
 * Retrieves the renderArea selection for the Drawer.
 * Sets the renderArea selection for the Drawer.
 * 
 * @param {!d3.Selection<void>=} area
 * @return {!d3.Selection<void>|!Plottable.Drawer}
 */
Plottable.Drawer.prototype.renderArea = function(area) {};

/**
 * Removes the Drawer and its renderArea
 * @return {void}
 */
Plottable.Drawer.prototype.remove = function() {};

/**
 * @param {!d3.Selection<?>} selection
 * @return {void}
 */
Plottable.Drawer.prototype._applyDefaultAttributes = function(selection) {};

/**
 * Calculates the total time it takes to use the input drawSteps to draw the input data
 * 
 * @param {!Array<?>} data
 * @param {!Array<{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}>} drawSteps
 * @return {number}
 */
Plottable.Drawer.prototype.totalDrawTime = function(data, drawSteps) {};

/**
 * Draws the data into the renderArea using the spefic steps and metadata
 * 
 * \@param{any[]} data The data to be drawn
 * \@param{DrawStep[]} drawSteps The list of steps, which needs to be drawn
 * @param {!Array<?>} data
 * @param {!Array<{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}>} drawSteps
 * @return {!Plottable.Drawer}
 */
Plottable.Drawer.prototype.draw = function(data, drawSteps) {};

/**
 * @return {!d3.Selection<?>}
 */
Plottable.Drawer.prototype.selection = function() {};

/**
 * Returns the CSS selector for this Drawer's visual elements.
 * @return {string}
 */
Plottable.Drawer.prototype.selector = function() {};

/**
 * Returns the D3 selection corresponding to the datum with the specified index.
 * @param {number} index
 * @return {!d3.Selection<?>}
 */
Plottable.Drawer.prototype.selectionForIndex = function(index) {};

/**
 * @constructor
 * @struct
 * @param {!Plottable.Dataset} dataset
 */
Plottable.Drawers.Line = function(dataset) {};

/**
 * @param {!d3.Selection<?>} selection
 * @return {void}
 */
Plottable.Drawers.Line.prototype._applyDefaultAttributes = function(selection) {};

/**
 * @param {number} index
 * @return {!d3.Selection<?>}
 */
Plottable.Drawers.Line.prototype.selectionForIndex = function(index) {};

/**
 * @constructor
 * @struct
 * @param {!Plottable.Dataset} dataset
 */
Plottable.Drawers.Area = function(dataset) {};

/**
 * @param {!d3.Selection<?>} selection
 * @return {void}
 */
Plottable.Drawers.Area.prototype._applyDefaultAttributes = function(selection) {};

/**
 * @param {number} index
 * @return {!d3.Selection<?>}
 */
Plottable.Drawers.Area.prototype.selectionForIndex = function(index) {};

/**
 * @constructor
 * @struct
 * @param {!Plottable.Dataset} dataset
 */
Plottable.Drawers.Rectangle = function(dataset) {};

/**
 * @constructor
 * @struct
 * @param {!Plottable.Dataset} dataset
 */
Plottable.Drawers.Arc = function(dataset) {};

/**
 * @constructor
 * @struct
 * @param {!Plottable.Dataset} dataset
 */
Plottable.Drawers.Symbol = function(dataset) {};

/**
 * @constructor
 * @struct
 * @param {!Plottable.Dataset} dataset
 */
Plottable.Drawers.Segment = function(dataset) {};

/** @typedef {function(!Plottable.Component): void} */
Plottable.ComponentCallback;
/** @const */
Plottable.Components = {};
/**
 * @constructor
 * @struct
 */
Plottable.Components.Alignment = function() {};
 /** @type {string} */
Plottable.Components.Alignment.TOP;
 /** @type {string} */
Plottable.Components.Alignment.BOTTOM;
 /** @type {string} */
Plottable.Components.Alignment.LEFT;
 /** @type {string} */
Plottable.Components.Alignment.RIGHT;
 /** @type {string} */
Plottable.Components.Alignment.CENTER;

/**
 * @constructor
 * @struct
 */
Plottable.Component = function() {};
 /** @type {!d3.Selection<void>} */
Plottable.Component.prototype._boundingBox;
 /** @type {boolean} */
Plottable.Component.prototype._clipPathEnabled;
 /** @type {boolean} */
Plottable.Component.prototype._isSetup;
 /** @type {boolean} */
Plottable.Component.prototype._isAnchored;

/**
 * Attaches the Component as a child of a given d3 Selection.
 * 
 * @param {!d3.Selection<void>} selection
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.anchor = function(selection) {};

/**
 * Adds a callback to be called on anchoring the Component to the DOM.
 * If the Component is already anchored, the callback is called immediately.
 * 
 * @param {function(!Plottable.Component): void} callback
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.onAnchor = function(callback) {};

/**
 * Removes a callback that would be called on anchoring the Component to the DOM.
 * The callback is identified by reference equality.
 * 
 * @param {function(!Plottable.Component): void} callback
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.offAnchor = function(callback) {};

/**
 * Creates additional elements as necessary for the Component to function.
 * Called during anchor() if the Component's element has not been created yet.
 * Override in subclasses to provide additional functionality.
 * @return {void}
 */
Plottable.Component.prototype._setup = function() {};

/**
 * Given available space in pixels, returns the minimum width and height this Component will need.
 * 
 * @param {number} availableWidth
 * @param {number} availableHeight
 * @return {{minWidth: number, minHeight: number}}
 */
Plottable.Component.prototype.requestedSpace = function(availableWidth, availableHeight) {};

/**
 * Computes and sets the size, position, and alignment of the Component from the specified values.
 * If no parameters are supplied and the Component is a root node,
 * they are inferred from the size of the Component's element.
 * 
 * @param {{x: number, y: number}=} origin
 * @param {number=} availableWidth
 * @param {number=} availableHeight
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.computeLayout = function(origin, availableWidth, availableHeight) {};

/**
 * @param {number} availableWidth
 * @param {number} availableHeight
 * @return {{width: number, height: number}}
 */
Plottable.Component.prototype._sizeFromOffer = function(availableWidth, availableHeight) {};

/**
 * Queues the Component for rendering.
 * 
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.render = function() {};

/**
 * Renders the Component without waiting for the next frame.
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.renderImmediately = function() {};

/**
 * Causes the Component to re-layout and render.
 * 
 * This function should be called when a CSS change has occured that could
 * influence the layout of the Component, such as changing the font size.
 * 
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.redraw = function() {};

/**
 * Renders the Component to a given <svg>.
 * 
 * @param {(!String|!d3.Selection<void>)} element
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.renderTo = function(element) {};

/**
 * Gets the x alignment of the Component.
 * Sets the x alignment of the Component.
 * 
 * @param {string=} xAlignment
 * @return {string|!Plottable.Component}
 */
Plottable.Component.prototype.xAlignment = function(xAlignment) {};

/**
 * Gets the y alignment of the Component.
 * Sets the y alignment of the Component.
 * 
 * @param {string=} yAlignment
 * @return {string|!Plottable.Component}
 */
Plottable.Component.prototype.yAlignment = function(yAlignment) {};

/**
 * Checks if the Component has a given CSS class.
 * 
 * @param {string} cssClass
 * @return {boolean}
 */
Plottable.Component.prototype.hasClass = function(cssClass) {};

/**
 * Adds a given CSS class to the Component.
 * 
 * @param {string} cssClass
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.addClass = function(cssClass) {};

/**
 * Removes a given CSS class from the Component.
 * 
 * @param {string} cssClass
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.removeClass = function(cssClass) {};

/**
 * Checks if the Component has a fixed width or if it grows to fill available space.
 * Returns false by default on the base Component class.
 * @return {boolean}
 */
Plottable.Component.prototype.fixedWidth = function() {};

/**
 * Checks if the Component has a fixed height or if it grows to fill available space.
 * Returns false by default on the base Component class.
 * @return {boolean}
 */
Plottable.Component.prototype.fixedHeight = function() {};

/**
 * Detaches a Component from the DOM. The Component can be reused.
 * 
 * This should only be used if you plan on reusing the calling Component. Otherwise, use destroy().
 * 
 * @return {!Plottable.Component} The calling Component.
 */
Plottable.Component.prototype.detach = function() {};

/**
 * Adds a callback to be called when the Component is detach()-ed.
 * 
 * @param {function(!Plottable.Component): void} callback
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.onDetach = function(callback) {};

/**
 * Removes a callback to be called when the Component is detach()-ed.
 * The callback is identified by reference equality.
 * 
 * @param {function(!Plottable.Component): void} callback
 * @return {!Plottable.Component}
 */
Plottable.Component.prototype.offDetach = function(callback) {};

/**
 * Gets the parent ComponentContainer for this Component.
 * Sets the parent ComponentContainer for this Component.
 * An error will be thrown if the parent does not contain this Component.
 * Adding a Component to a ComponentContainer should be done
 * using the appropriate method on the ComponentContainer.
 * @param {!Plottable.ComponentContainer=} parent
 * @return {!Plottable.ComponentContainer|!Plottable.Component}
 */
Plottable.Component.prototype.parent = function(parent) {};

/**
 * Removes a Component from the DOM and disconnects all listeners.
 * @return {void}
 */
Plottable.Component.prototype.destroy = function() {};

/**
 * Gets the width of the Component in pixels.
 * @return {number}
 */
Plottable.Component.prototype.width = function() {};

/**
 * Gets the height of the Component in pixels.
 * @return {number}
 */
Plottable.Component.prototype.height = function() {};

/**
 * Gets the origin of the Component relative to its parent.
 * 
 * @return {{x: number, y: number}}
 */
Plottable.Component.prototype.origin = function() {};

/**
 * Gets the origin of the Component relative to the root <svg>.
 * 
 * @return {{x: number, y: number}}
 */
Plottable.Component.prototype.originToSVG = function() {};

/**
 * Gets the Selection containing the <g> in front of the visual elements of the Component.
 * 
 * Will return undefined if the Component has not been anchored.
 * 
 * @return {!d3.Selection<void>}
 */
Plottable.Component.prototype.foreground = function() {};

/**
 * Gets a Selection containing a <g> that holds the visual elements of the Component.
 * 
 * Will return undefined if the Component has not been anchored.
 * 
 * @return {!d3.Selection<void>}
 */
Plottable.Component.prototype.content = function() {};

/**
 * Gets the Selection containing the <g> behind the visual elements of the Component.
 * 
 * Will return undefined if the Component has not been anchored.
 * 
 * @return {!d3.Selection<void>}
 */
Plottable.Component.prototype.background = function() {};

/**
 * @constructor
 * @struct
 */
Plottable.ComponentContainer = function() {};

/**
 * @param {!d3.Selection<void>} selection
 * @return {!Plottable.ComponentContainer}
 */
Plottable.ComponentContainer.prototype.anchor = function(selection) {};

/**
 * @return {!Plottable.ComponentContainer}
 */
Plottable.ComponentContainer.prototype.render = function() {};

/**
 * Checks whether the specified Component is in the ComponentContainer.
 * @param {!Plottable.Component} component
 * @return {boolean}
 */
Plottable.ComponentContainer.prototype.has = function(component) {};

/**
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.ComponentContainer.prototype._adoptAndAnchor = function(component) {};

/**
 * Removes the specified Component from the ComponentContainer.
 * @param {!Plottable.Component} component
 * @return {!Plottable.ComponentContainer}
 */
Plottable.ComponentContainer.prototype.remove = function(component) {};

/**
 * Carry out the actual removal of a Component.
 * Implementation dependent on the type of container.
 * 
 * @param {!Plottable.Component} component
 * @return {boolean}
 */
Plottable.ComponentContainer.prototype._remove = function(component) {};

/**
 * Invokes a callback on each Component in the ComponentContainer.
 * @param {function(!Plottable.Component): void} callback
 * @return {void}
 */
Plottable.ComponentContainer.prototype._forEach = function(callback) {};

/**
 * Destroys the ComponentContainer and all Components within it.
 * @return {void}
 */
Plottable.ComponentContainer.prototype.destroy = function() {};

/**
 * @constructor
 * @struct
 * Constructs a Group.
 * 
 * A Group contains Components that will be rendered on top of each other.
 * Components added later will be rendered above Components already in the Group.
 * 
 * @param {!Array<!Plottable.Component>=} components
 */
Plottable.Components.Group = function(components) {};

/**
 * @param {function(!Plottable.Component): ?} callback
 * @return {void}
 */
Plottable.Components.Group.prototype._forEach = function(callback) {};

/**
 * Checks whether the specified Component is in the Group.
 * @param {!Plottable.Component} component
 * @return {boolean}
 */
Plottable.Components.Group.prototype.has = function(component) {};

/**
 * @param {number} offeredWidth
 * @param {number} offeredHeight
 * @return {{minWidth: number, minHeight: number}}
 */
Plottable.Components.Group.prototype.requestedSpace = function(offeredWidth, offeredHeight) {};

/**
 * @param {{x: number, y: number}=} origin
 * @param {number=} availableWidth
 * @param {number=} availableHeight
 * @return {!Plottable.Components.Group}
 */
Plottable.Components.Group.prototype.computeLayout = function(origin, availableWidth, availableHeight) {};

/**
 * @param {number} availableWidth
 * @param {number} availableHeight
 * @return {{width: number, height: number}}
 */
Plottable.Components.Group.prototype._sizeFromOffer = function(availableWidth, availableHeight) {};

/**
 * @return {boolean}
 */
Plottable.Components.Group.prototype.fixedWidth = function() {};

/**
 * @return {boolean}
 */
Plottable.Components.Group.prototype.fixedHeight = function() {};

/**
 * @return {!Array<!Plottable.Component>}
 */
Plottable.Components.Group.prototype.components = function() {};

/**
 * Adds a Component to this Group.
 * The added Component will be rendered above Components already in the Group.
 * @param {!Plottable.Component} component
 * @return {!Plottable.Components.Group}
 */
Plottable.Components.Group.prototype.append = function(component) {};

/**
 * @param {!Plottable.Component} component
 * @return {boolean}
 */
Plottable.Components.Group.prototype._remove = function(component) {};

/**
 * @constructor
 * @struct
 * Constructs an Axis.
 * An Axis is a visual representation of a Scale.
 * 
 * @param {!Plottable.Scale<D, number>} scale
 * @param {string} orientation
 */
Plottable.Axis = function(scale, orientation) {};
 /** @type {string} */
Plottable.Axis.END_TICK_MARK_CLASS;
 /** @type {string} */
Plottable.Axis.TICK_MARK_CLASS;
 /** @type {string} */
Plottable.Axis.TICK_LABEL_CLASS;
 /** @type {!d3.Selection<void>} */
Plottable.Axis.prototype._tickMarkContainer;
 /** @type {!d3.Selection<void>} */
Plottable.Axis.prototype._tickLabelContainer;
 /** @type {!d3.Selection<void>} */
Plottable.Axis.prototype._baseline;
 /** @type {!Plottable.Scale<D, number>} */
Plottable.Axis.prototype._scale;
 /** @type {number} */
Plottable.Axis.prototype._computedWidth;
 /** @type {number} */
Plottable.Axis.prototype._computedHeight;

/**
 * @return {void}
 */
Plottable.Axis.prototype.destroy = function() {};

/**
 * @return {boolean}
 */
Plottable.Axis.prototype._isHorizontal = function() {};

/**
 * @return {number}
 */
Plottable.Axis.prototype._computeWidth = function() {};

/**
 * @return {number}
 */
Plottable.Axis.prototype._computeHeight = function() {};

/**
 * @param {number} offeredWidth
 * @param {number} offeredHeight
 * @return {{minWidth: number, minHeight: number}}
 */
Plottable.Axis.prototype.requestedSpace = function(offeredWidth, offeredHeight) {};

/**
 * @return {boolean}
 */
Plottable.Axis.prototype.fixedHeight = function() {};

/**
 * @return {boolean}
 */
Plottable.Axis.prototype.fixedWidth = function() {};

/**
 * @return {void}
 */
Plottable.Axis.prototype._rescale = function() {};

/**
 * @param {{x: number, y: number}=} origin
 * @param {number=} availableWidth
 * @param {number=} availableHeight
 * @return {!Plottable.Axis}
 */
Plottable.Axis.prototype.computeLayout = function(origin, availableWidth, availableHeight) {};

/**
 * @return {void}
 */
Plottable.Axis.prototype._setup = function() {};

/**
 * @return {!Array<D>}
 */
Plottable.Axis.prototype._getTickValues = function() {};

/**
 * @return {!Plottable.Axis}
 */
Plottable.Axis.prototype.renderImmediately = function() {};

/**
 * @return {!Object<string,number>}
 */
Plottable.Axis.prototype._generateBaselineAttrHash = function() {};

/**
 * @param {boolean=} isEndTickMark
 * @return {!Object<string,(number|function(?): number)>}
 */
Plottable.Axis.prototype._generateTickMarkAttrHash = function(isEndTickMark) {};

/**
 * @return {!Plottable.Component}
 */
Plottable.Axis.prototype.redraw = function() {};

/**
 * @return {void}
 */
Plottable.Axis.prototype._setDefaultAlignment = function() {};

/**
 * Gets the Formatter on the Axis. Tick values are passed through the
 * Formatter before being displayed.
 * Sets the Formatter on the Axis. Tick values are passed through the
 * Formatter before being displayed.
 * 
 * @param {function(?): string=} formatter
 * @return {function(?): string|!Plottable.Axis}
 */
Plottable.Axis.prototype.formatter = function(formatter) {};

/**
 * @deprecated As of release 1.3, replaced by innerTickLength()
 * 
 * Gets the tick mark length in pixels.
 * Sets the tick mark length in pixels.
 * 
 * @param {number=} length
 * @return {number|!Plottable.Axis}
 */
Plottable.Axis.prototype.tickLength = function(length) {};

/**
 * Gets the tick mark length in pixels.
 * Sets the tick mark length in pixels.
 * 
 * @param {number=} length
 * @return {number|!Plottable.Axis}
 */
Plottable.Axis.prototype.innerTickLength = function(length) {};

/**
 * Gets the end tick mark length in pixels.
 * Sets the end tick mark length in pixels.
 * 
 * @param {number=} length
 * @return {number|!Plottable.Axis}
 */
Plottable.Axis.prototype.endTickLength = function(length) {};

/**
 * @return {number}
 */
Plottable.Axis.prototype._maxLabelTickLength = function() {};

/**
 * Gets the padding between each tick mark and its associated label in pixels.
 * Sets the padding between each tick mark and its associated label in pixels.
 * 
 * @param {number=} padding
 * @return {number|!Plottable.Axis}
 */
Plottable.Axis.prototype.tickLabelPadding = function(padding) {};

/**
 * Gets the margin in pixels.
 * The margin is the amount of space between the tick labels and the outer edge of the Axis.
 * Sets the margin in pixels.
 * The margin is the amount of space between the tick labels and the outer edge of the Axis.
 * 
 * @param {number=} size
 * @return {number|!Plottable.Axis}
 */
Plottable.Axis.prototype.margin = function(size) {};

/**
 * Gets the orientation of the Axis.
 * Sets the orientation of the Axis.
 * 
 * @param {string=} orientation
 * @return {string|!Plottable.Axis}
 */
Plottable.Axis.prototype.orientation = function(orientation) {};

/**
 * Gets whether the Axis shows the end tick labels.
 * Sets whether the Axis shows the end tick labels.
 * 
 * @param {boolean=} show
 * @return {boolean|!Plottable.Axis}
 */
Plottable.Axis.prototype.showEndTickLabels = function(show) {};
/** @const */
Plottable.TimeInterval = {};
 /** @type {string} */
Plottable.TimeInterval.second;
 /** @type {string} */
Plottable.TimeInterval.minute;
 /** @type {string} */
Plottable.TimeInterval.hour;
 /** @type {string} */
Plottable.TimeInterval.day;
 /** @type {string} */
Plottable.TimeInterval.week;
 /** @type {string} */
Plottable.TimeInterval.month;
 /** @type {string} */
Plottable.TimeInterval.year;
/** @const */
Plottable.Axes = {};

/** @typedef {{interval: string, step: number, formatter: function(?): string}} */
Plottable.Axes.TimeAxisTierConfiguration;

/** @typedef {!Array<{interval: string, step: number, formatter: function(?): string}>} */
Plottable.Axes.TimeAxisConfiguration;

/**
 * @constructor
 * @struct
 * Constructs a Time Axis.
 * 
 * A Time Axis is a visual representation of a Time Scale.
 * 
 * @param {!Plottable.Scales.Time} scale
 * @param {string} orientation
 */
Plottable.Axes.Time = function(scale, orientation) {};
 /** @type {string} */
Plottable.Axes.Time.TIME_AXIS_TIER_CLASS;

/**
 * Gets the label positions for each tier.
 * Sets the label positions for each tier.
 * 
 * @param {!Array<string>=} newPositions
 * @return {!Array<string>|!Plottable.Axes.Time}
 */
Plottable.Axes.Time.prototype.tierLabelPositions = function(newPositions) {};

/**
 * Gets the possible TimeAxisConfigurations.
 * Sets the possible TimeAxisConfigurations.
 * The Time Axis will choose the most precise configuration that will display in the available space.
 * 
 * @param {!Array<!Array<{interval: string, step: number, formatter: function(?): string}>>=} configurations
 * @return {!Array<!Array<{interval: string, step: number, formatter: function(?): string}>>|!Plottable.Axes.Time}
 */
Plottable.Axes.Time.prototype.axisConfigurations = function(configurations) {};

/**
 * @param {string=} orientation
 * @return {string|!Plottable.Axes.Time}
 */
Plottable.Axes.Time.prototype.orientation = function(orientation) {};

/**
 * @return {number}
 */
Plottable.Axes.Time.prototype._computeHeight = function() {};

/**
 * @param {number} availableWidth
 * @param {number} availableHeight
 * @return {{width: number, height: number}}
 */
Plottable.Axes.Time.prototype._sizeFromOffer = function(availableWidth, availableHeight) {};

/**
 * @return {void}
 */
Plottable.Axes.Time.prototype._setup = function() {};

/**
 * @return {!Array<?>}
 */
Plottable.Axes.Time.prototype._getTickValues = function() {};

/**
 * @return {!Plottable.Axes.Time}
 */
Plottable.Axes.Time.prototype.renderImmediately = function() {};

/**
 * @constructor
 * @struct
 * Constructs a Numeric Axis.
 * 
 * A Numeric Axis is a visual representation of a QuantitativeScale.
 * 
 * @param {!Plottable.QuantitativeScale<number>} scale
 * @param {string} orientation
 */
Plottable.Axes.Numeric = function(scale, orientation) {};

/**
 * @return {void}
 */
Plottable.Axes.Numeric.prototype._setup = function() {};

/**
 * @return {number}
 */
Plottable.Axes.Numeric.prototype._computeWidth = function() {};

/**
 * @return {number}
 */
Plottable.Axes.Numeric.prototype._computeHeight = function() {};

/**
 * @return {!Array<number>}
 */
Plottable.Axes.Numeric.prototype._getTickValues = function() {};

/**
 * @return {void}
 */
Plottable.Axes.Numeric.prototype._rescale = function() {};

/**
 * @return {!Plottable.Axes.Numeric}
 */
Plottable.Axes.Numeric.prototype.renderImmediately = function() {};

/**
 * Gets the tick label position relative to the tick marks.
 * 
 * Sets the tick label position relative to the tick marks.
 * 
 *                          "left"/"center"/"right" for a horizontal Numeric Axis.
 * @param {string=} position
 * @return {string|!Plottable.Axes.Numeric}
 */
Plottable.Axes.Numeric.prototype.tickLabelPosition = function(position) {};

/**
 * @constructor
 * @struct
 * Constructs a Category Axis.
 * 
 * A Category Axis is a visual representation of a Category Scale.
 * 
 * @param {!Plottable.Scales.Category} scale
 * @param {string} orientation
 */
Plottable.Axes.Category = function(scale, orientation) {};

/**
 * @return {void}
 */
Plottable.Axes.Category.prototype._setup = function() {};

/**
 * @return {!Plottable.Component}
 */
Plottable.Axes.Category.prototype._rescale = function() {};

/**
 * @param {number} offeredWidth
 * @param {number} offeredHeight
 * @return {{minWidth: number, minHeight: number}}
 */
Plottable.Axes.Category.prototype.requestedSpace = function(offeredWidth, offeredHeight) {};

/**
 * @return {!Array<string>}
 */
Plottable.Axes.Category.prototype._getTickValues = function() {};

/**
 * Gets the tick label angle in degrees.
 * Sets the tick label angle in degrees.
 * Right now only -90/0/90 are supported. 0 is horizontal.
 * 
 * @param {number=} angle
 * @return {number|!Plottable.Axes.Category}
 */
Plottable.Axes.Category.prototype.tickLabelAngle = function(angle) {};

/**
 * @return {!Plottable.Axes.Category}
 */
Plottable.Axes.Category.prototype.renderImmediately = function() {};

/**
 * @param {{x: number, y: number}=} origin
 * @param {number=} availableWidth
 * @param {number=} availableHeight
 * @return {!Plottable.Axis<string>}
 */
Plottable.Axes.Category.prototype.computeLayout = function(origin, availableWidth, availableHeight) {};

/**
 * @constructor
 * @struct
 * A Label is a Component that displays a single line of text.
 * 
 * @param {string=} displayText
 * @param {number=} angle
 */
Plottable.Components.Label = function(displayText, angle) {};

/**
 * @param {number} offeredWidth
 * @param {number} offeredHeight
 * @return {{minWidth: number, minHeight: number}}
 */
Plottable.Components.Label.prototype.requestedSpace = function(offeredWidth, offeredHeight) {};

/**
 * @return {void}
 */
Plottable.Components.Label.prototype._setup = function() {};

/**
 * Gets the Label's text.
 * Sets the Label's text.
 * 
 * @param {string=} displayText
 * @return {string|!Plottable.Components.Label}
 */
Plottable.Components.Label.prototype.text = function(displayText) {};

/**
 * Gets the angle of the Label in degrees.
 * Sets the angle of the Label in degrees.
 * 
 * @param {number=} angle
 * @return {number|!Plottable.Components.Label}
 */
Plottable.Components.Label.prototype.angle = function(angle) {};

/**
 * Gets the amount of padding around the Label in pixels.
 * Sets the amount of padding around the Label in pixels.
 * 
 * @param {number=} padAmount
 * @return {number|!Plottable.Components.Label}
 */
Plottable.Components.Label.prototype.padding = function(padAmount) {};

/**
 * @return {boolean}
 */
Plottable.Components.Label.prototype.fixedWidth = function() {};

/**
 * @return {boolean}
 */
Plottable.Components.Label.prototype.fixedHeight = function() {};

/**
 * @return {!Plottable.Components.Label}
 */
Plottable.Components.Label.prototype.renderImmediately = function() {};

/**
 * @constructor
 * @struct
 * @param {string=} text
 * @param {number=} angle
 */
Plottable.Components.TitleLabel = function(text, angle) {};
 /** @type {string} */
Plottable.Components.TitleLabel.TITLE_LABEL_CLASS;

/**
 * @constructor
 * @struct
 * @param {string=} text
 * @param {number=} angle
 */
Plottable.Components.AxisLabel = function(text, angle) {};
 /** @type {string} */
Plottable.Components.AxisLabel.AXIS_LABEL_CLASS;

/**
 * @constructor
 * @struct
 * The Legend consists of a series of entries, each with a color and label taken from the Color Scale.
 * 
 * @param {!Plottable.Scales.Color} colorScale
 */
Plottable.Components.Legend = function(colorScale) {};
 /** @type {string} */
Plottable.Components.Legend.LEGEND_ROW_CLASS;
 /** @type {string} */
Plottable.Components.Legend.LEGEND_ENTRY_CLASS;
 /** @type {string} */
Plottable.Components.Legend.LEGEND_SYMBOL_CLASS;

/**
 * @return {void}
 */
Plottable.Components.Legend.prototype._setup = function() {};

/**
 * Gets the maximum number of entries per row.
 * 
 * Sets the maximum number of entries perrow.
 * 
 * @param {number=} maxEntriesPerRow
 * @return {number|!Plottable.Components.Legend}
 */
Plottable.Components.Legend.prototype.maxEntriesPerRow = function(maxEntriesPerRow) {};

/**
 * Gets the current comparator for the Legend's entries.
 * 
 * Sets a new comparator for the Legend's entries.
 * The comparator is used to set the display order of the entries.
 * 
 * @param {function(string, string): number=} comparator
 * @return {function(string, string): number|!Plottable.Components.Legend}
 */
Plottable.Components.Legend.prototype.comparator = function(comparator) {};

/**
 * Gets the Color Scale.
 * 
 * Sets the Color Scale.
 * 
 * @param {!Plottable.Scales.Color=} colorScale
 * @return {!Plottable.Scales.Color|!Plottable.Components.Legend}
 */
Plottable.Components.Legend.prototype.colorScale = function(colorScale) {};

/**
 * @return {void}
 */
Plottable.Components.Legend.prototype.destroy = function() {};

/**
 * @param {number} offeredWidth
 * @param {number} offeredHeight
 * @return {{minWidth: number, minHeight: number}}
 */
Plottable.Components.Legend.prototype.requestedSpace = function(offeredWidth, offeredHeight) {};

/**
 * Gets the Entities (representing Legend entries) at a particular point.
 * Returns an empty array if no Entities are present at that location.
 * 
 * @param {{x: number, y: number}} p
 * @return {!Array<!Plottable.Entity<!Plottable.Components.Legend>>}
 */
Plottable.Components.Legend.prototype.entitiesAt = function(p) {};

/**
 * @return {!Plottable.Components.Legend}
 */
Plottable.Components.Legend.prototype.renderImmediately = function() {};

/**
 * Gets the function determining the symbols of the Legend.
 * 
 * Sets the function determining the symbols of the Legend.
 * 
 * @param {function(?, number): function(number): string=} symbol
 * @return {function(?, number): function(number): string|!Plottable.Components.Legend}
 */
Plottable.Components.Legend.prototype.symbol = function(symbol) {};

/**
 * @return {boolean}
 */
Plottable.Components.Legend.prototype.fixedWidth = function() {};

/**
 * @return {boolean}
 */
Plottable.Components.Legend.prototype.fixedHeight = function() {};

/**
 * @constructor
 * @struct
 * Creates an InterpolatedColorLegend.
 * 
 * The InterpolatedColorLegend consists of a sequence of swatches that show the
 * associated InterpolatedColor Scale sampled at various points.
 * Two labels show the maximum and minimum values of the InterpolatedColor Scale.
 * 
 * @param {!Plottable.Scales.InterpolatedColor} interpolatedColorScale
 */
Plottable.Components.InterpolatedColorLegend = function(interpolatedColorScale) {};
 /** @type {string} */
Plottable.Components.InterpolatedColorLegend.LEGEND_LABEL_CLASS;

/**
 * @return {void}
 */
Plottable.Components.InterpolatedColorLegend.prototype.destroy = function() {};

/**
 * Gets the Formatter for the labels.
 * Sets the Formatter for the labels.
 * 
 * @param {function(?): string=} formatter
 * @return {function(?): string|!Plottable.Components.InterpolatedColorLegend}
 */
Plottable.Components.InterpolatedColorLegend.prototype.formatter = function(formatter) {};

/**
 * Gets the orientation.
 * Sets the orientation.
 * 
 * @param {string=} orientation
 * @return {string|!Plottable.Components.InterpolatedColorLegend}
 */
Plottable.Components.InterpolatedColorLegend.prototype.orientation = function(orientation) {};

/**
 * @return {boolean}
 */
Plottable.Components.InterpolatedColorLegend.prototype.fixedWidth = function() {};

/**
 * @return {boolean}
 */
Plottable.Components.InterpolatedColorLegend.prototype.fixedHeight = function() {};

/**
 * @return {void}
 */
Plottable.Components.InterpolatedColorLegend.prototype._setup = function() {};

/**
 * @param {number} offeredWidth
 * @param {number} offeredHeight
 * @return {{minWidth: number, minHeight: number}}
 */
Plottable.Components.InterpolatedColorLegend.prototype.requestedSpace = function(offeredWidth, offeredHeight) {};

/**
 * @return {!Plottable.Components.InterpolatedColorLegend}
 */
Plottable.Components.InterpolatedColorLegend.prototype.renderImmediately = function() {};

/**
 * @constructor
 * @struct
 * @param {!Plottable.QuantitativeScale<?>} xScale
 * @param {!Plottable.QuantitativeScale<?>} yScale
 */
Plottable.Components.Gridlines = function(xScale, yScale) {};

/**
 * @return {!Plottable.Components.Gridlines}
 */
Plottable.Components.Gridlines.prototype.destroy = function() {};

/**
 * @return {void}
 */
Plottable.Components.Gridlines.prototype._setup = function() {};

/**
 * @return {!Plottable.Components.Gridlines}
 */
Plottable.Components.Gridlines.prototype.renderImmediately = function() {};

/**
 * @constructor
 * @struct
 * A Table combines Components in the form of a grid. A
 * common case is combining a y-axis, x-axis, and the plotted data via
 * ```typescript
 * new Table([[yAxis, plot],
 *            [null,  xAxis]]);
 * ```
 * 
 *   null can be used if a cell is empty.
 * @param {!Array<!Array<!Plottable.Component>>=} rows
 */
Plottable.Components.Table = function(rows) {};

/**
 * @param {function(!Plottable.Component): ?} callback
 * @return {void}
 */
Plottable.Components.Table.prototype._forEach = function(callback) {};

/**
 * Checks whether the specified Component is in the Table.
 * @param {!Plottable.Component} component
 * @return {boolean}
 */
Plottable.Components.Table.prototype.has = function(component) {};

/**
 * Adds a Component in the specified row and column position.
 * 
 * For example, instead of calling `new Table([[a, b], [null, c]])`, you
 * could call
 * ```typescript
 * var table = new Table();
 * table.add(a, 0, 0);
 * table.add(b, 0, 1);
 * table.add(c, 1, 1);
 * ```
 * 
 * @param {!Plottable.Component} component
 * @param {number} row
 * @param {number} col
 * @return {!Plottable.Components.Table}
 */
Plottable.Components.Table.prototype.add = function(component, row, col) {};

/**
 * @param {!Plottable.Component} component
 * @return {boolean}
 */
Plottable.Components.Table.prototype._remove = function(component) {};

/**
 * @param {number} offeredWidth
 * @param {number} offeredHeight
 * @return {{minWidth: number, minHeight: number}}
 */
Plottable.Components.Table.prototype.requestedSpace = function(offeredWidth, offeredHeight) {};

/**
 * @param {{x: number, y: number}=} origin
 * @param {number=} availableWidth
 * @param {number=} availableHeight
 * @return {!Plottable.Components.Table}
 */
Plottable.Components.Table.prototype.computeLayout = function(origin, availableWidth, availableHeight) {};

/**
 * Gets the padding above and below each row in pixels.
 * Sets the padding above and below each row in pixels.
 * 
 * @param {number=} rowPadding
 * @return {number|!Plottable.Components.Table}
 */
Plottable.Components.Table.prototype.rowPadding = function(rowPadding) {};

/**
 * Gets the padding to the left and right of each column in pixels.
 * Sets the padding to the left and right of each column in pixels.
 * 
 * @param {number=} columnPadding
 * @return {number|!Plottable.Components.Table}
 */
Plottable.Components.Table.prototype.columnPadding = function(columnPadding) {};

/**
 * Gets the weight of the specified row.
 * 
 * Sets the weight of the specified row.
 * Space is allocated to rows based on their weight. Rows with higher weights receive proportionally more space.
 * 
 * A common case would be to have one row take up 2/3rds of the space,
 * and the other row take up 1/3rd.
 * 
 * Example:
 * 
 * ```JavaScript
 * plot = new Plottable.Component.Table([
 *  [row1],
 *  [row2]
 * ]);
 * 
 * // assign twice as much space to the first row
 * plot
 *  .rowWeight(0, 2)
 *  .rowWeight(1, 1)
 * ```
 * 
 * @param {number} index
 * @param {number=} weight
 * @return {number|!Plottable.Components.Table}
 */
Plottable.Components.Table.prototype.rowWeight = function(index, weight) {};

/**
 * Gets the weight of the specified column.
 * 
 * Sets the weight of the specified column.
 * Space is allocated to columns based on their weight. Columns with higher weights receive proportionally more space.
 * 
 * Please see `rowWeight` docs for an example.
 * 
 * @param {number} index
 * @param {number=} weight
 * @return {number|!Plottable.Components.Table}
 */
Plottable.Components.Table.prototype.columnWeight = function(index, weight) {};

/**
 * @return {boolean}
 */
Plottable.Components.Table.prototype.fixedWidth = function() {};

/**
 * @return {boolean}
 */
Plottable.Components.Table.prototype.fixedHeight = function() {};

/**
 * @constructor
 * @struct
 */
Plottable.Components.SelectionBoxLayer = function() {};
 /** @type {!d3.Selection<void>} */
Plottable.Components.SelectionBoxLayer.prototype._box;

/**
 * @return {void}
 */
Plottable.Components.SelectionBoxLayer.prototype._setup = function() {};

/**
 * @param {number} availableWidth
 * @param {number} availableHeight
 * @return {{width: number, height: number}}
 */
Plottable.Components.SelectionBoxLayer.prototype._sizeFromOffer = function(availableWidth, availableHeight) {};

/**
 * Gets the Bounds of the box.
 * Sets the Bounds of the box.
 * 
 * @param {{topLeft: {x: number, y: number}, bottomRight: ?}=} newBounds
 * @return {{topLeft: {x: number, y: number}, bottomRight: ?}|!Plottable.Components.SelectionBoxLayer}
 */
Plottable.Components.SelectionBoxLayer.prototype.bounds = function(newBounds) {};

/**
 * @param {{topLeft: {x: number, y: number}, bottomRight: ?}} newBounds
 * @return {void}
 */
Plottable.Components.SelectionBoxLayer.prototype._setBounds = function(newBounds) {};

/**
 * @return {!Plottable.Components.SelectionBoxLayer}
 */
Plottable.Components.SelectionBoxLayer.prototype.renderImmediately = function() {};

/**
 * Gets whether the box is being shown.
 * Shows or hides the selection box.
 * 
 * @param {boolean=} show
 * @return {boolean|!Plottable.Components.SelectionBoxLayer}
 */
Plottable.Components.SelectionBoxLayer.prototype.boxVisible = function(show) {};

/**
 * @return {boolean}
 */
Plottable.Components.SelectionBoxLayer.prototype.fixedWidth = function() {};

/**
 * @return {boolean}
 */
Plottable.Components.SelectionBoxLayer.prototype.fixedHeight = function() {};
/** @const */
Plottable.Plots = {};
/**
 * @extends {Plottable.Entity}
 * @record
 * @struct
 */
Plottable.Plots.PlotEntity = function() {};
 /** @type {!Plottable.Dataset} */
Plottable.Plots.PlotEntity.prototype.dataset;
 /** @type {number} */
Plottable.Plots.PlotEntity.prototype.index;
 /** @type {!Plottable.Plot} */
Plottable.Plots.PlotEntity.prototype.component;
/**
 * @record
 * @struct
 */
Plottable.Plots.AccessorScaleBinding = function() {};
 /** @type {!Plottable.Accessor<?>} */
Plottable.Plots.AccessorScaleBinding.prototype.accessor;
 /** @type {!Plottable.Scale<D, R>} */
Plottable.Plots.AccessorScaleBinding.prototype.scale;
/** @const */
Plottable.Plots.Animator = {};
 /** @type {string} */
Plottable.Plots.Animator.MAIN;
 /** @type {string} */
Plottable.Plots.Animator.RESET;

/**
 * @constructor
 * @struct
 * A Plot draws some visualization of the inputted Datasets.
 * 
 */
Plottable.Plot = function() {};
 /** @type {number} */
Plottable.Plot._ANIMATION_MAX_DURATION;
 /** @type {!d3.Selection<void>} */
Plottable.Plot.prototype._renderArea;
 /** @type {!Plottable.ScaleCallback<!Plottable.Scale<?, ?>>} */
Plottable.Plot.prototype._renderCallback;
 /** @type {!d3.Map<!Array<?>>} */
Plottable.Plot.prototype._propertyExtents;
 /** @type {!d3.Map<!Plottable.Plots.AccessorScaleBinding<?, ?>>} */
Plottable.Plot.prototype._propertyBindings;

/**
 * @param {!d3.Selection<void>} selection
 * @return {!Plottable.Plot}
 */
Plottable.Plot.prototype.anchor = function(selection) {};

/**
 * @return {void}
 */
Plottable.Plot.prototype._setup = function() {};

/**
 * @return {void}
 */
Plottable.Plot.prototype.destroy = function() {};

/**
 * Adds a Dataset to the Plot.
 * 
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Plot}
 */
Plottable.Plot.prototype.addDataset = function(dataset) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawer}
 */
Plottable.Plot.prototype._createNodesForDataset = function(dataset) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawer}
 */
Plottable.Plot.prototype._createDrawer = function(dataset) {};

/**
 * @param {string} key
 * @return {!Plottable.Animator}
 */
Plottable.Plot.prototype._getAnimator = function(key) {};

/**
 * @return {void}
 */
Plottable.Plot.prototype._onDatasetUpdate = function() {};

/**
 * Gets the AccessorScaleBinding for a particular attribute.
 * 
 * Sets a particular attribute to a constant value or the result of an Accessor.
 * 
 * Sets a particular attribute to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the attribute values when autoDomain()-ing.
 * 
 * @template A
 * @param {string} attr
 * @param {(string|number|!Plottable.Accessor<number>|!Plottable.Accessor<string>)|(A|!Plottable.Accessor<A>)=} attrValue
 * @param {!Plottable.Scale<A, (string|number)>=} scale
 * @return {!Plottable.Plots.AccessorScaleBinding<A, (string|number)>|!Plottable.Plot}
 */
Plottable.Plot.prototype.attr = function(attr, attrValue, scale) {};

/**
 * @param {string} property
 * @param {?} value
 * @param {!Plottable.Scale<?, ?>} scale
 * @return {void}
 */
Plottable.Plot.prototype._bindProperty = function(property, value, scale) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plot.prototype._generateAttrToProjector = function() {};

/**
 * @return {!Plottable.Plot}
 */
Plottable.Plot.prototype.renderImmediately = function() {};

/**
 * Returns whether the plot will be animated.
 * Enables or disables animation.
 * @param {boolean=} willAnimate
 * @return {boolean|!Plottable.Plot}
 */
Plottable.Plot.prototype.animated = function(willAnimate) {};

/**
 * @return {!Plottable.Plot}
 */
Plottable.Plot.prototype.detach = function() {};

/**
 * Updates the extents associated with each attribute, then autodomains all scales the Plot uses.
 * @return {void}
 */
Plottable.Plot.prototype._updateExtents = function() {};

/**
 * @param {string} property
 * @return {void}
 */
Plottable.Plot.prototype._updateExtentsForProperty = function(property) {};

/**
 * @param {string} property
 * @return {!Plottable.Accessor<boolean>}
 */
Plottable.Plot.prototype._filterForProperty = function(property) {};

/**
 * Override in subclass to add special extents, such as included values
 * @param {string} property
 * @return {!Array<?>}
 */
Plottable.Plot.prototype._extentsForProperty = function(property) {};

/**
 * Get the Animator associated with the specified Animator key.
 * 
 * Set the Animator associated with the specified Animator key.
 * 
 * @param {string} animatorKey
 * @param {!Plottable.Animator=} animator
 * @return {!Plottable.Animator|!Plottable.Plot}
 */
Plottable.Plot.prototype.animator = function(animatorKey, animator) {};

/**
 * Removes a Dataset from the Plot.
 * 
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Plot}
 */
Plottable.Plot.prototype.removeDataset = function(dataset) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {void}
 */
Plottable.Plot.prototype._removeDatasetNodes = function(dataset) {};

/**
 * @param {!Array<!Plottable.Dataset>=} datasets
 * @return {!Array<!Plottable.Dataset>|!Plottable.Plot}
 */
Plottable.Plot.prototype.datasets = function(datasets) {};

/**
 * @return {!Array<!Plottable.Drawer>}
 */
Plottable.Plot.prototype._getDrawersInOrder = function() {};

/**
 * @return {!Array<{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}>}
 */
Plottable.Plot.prototype._generateDrawSteps = function() {};

/**
 * @param {number} time
 * @return {void}
 */
Plottable.Plot.prototype._additionalPaint = function(time) {};

/**
 * @return {!Plottable.Utils.Map<!Plottable.Dataset, !Array<?>>}
 */
Plottable.Plot.prototype._getDataToDraw = function() {};

/**
 * Retrieves Selections of this Plot for the specified Datasets.
 * 
 *   If not provided, Selections will be retrieved for all Datasets on the Plot.
 * @param {!Array<!Plottable.Dataset>=} datasets
 * @return {!d3.Selection<?>}
 */
Plottable.Plot.prototype.selections = function(datasets) {};

/**
 * Gets the Entities associated with the specified Datasets.
 * 
 *   If not provided, returns defaults to all Datasets on the Plot.
 * @param {!Array<!Plottable.Dataset>=} datasets
 * @return {!Array<!Plottable.Plots.PlotEntity>}
 */
Plottable.Plot.prototype.entities = function(datasets) {};

/**
 * Returns the PlotEntity nearest to the query point by the Euclidian norm, or undefined if no PlotEntity can be found.
 * 
 * @param {{x: number, y: number}} queryPoint
 * @return {!Plottable.Plots.PlotEntity}
 */
Plottable.Plot.prototype.entityNearest = function(queryPoint) {};

/**
 * @param {?} datum
 * @param {{x: number, y: number}} pixelPoint
 * @param {!d3.Selection<void>} selection
 * @return {boolean}
 */
Plottable.Plot.prototype._visibleOnPlot = function(datum, pixelPoint, selection) {};

/**
 * @param {{x: number, y: number}} pixelPoint
 * @param {?} datum
 * @param {number} index
 * @param {!Plottable.Dataset} dataset
 * @return {boolean}
 */
Plottable.Plot.prototype._entityVisibleOnPlot = function(pixelPoint, datum, index, dataset) {};

/**
 * @param {!Plottable.Scale<?, ?>} scale
 * @param {string} key
 * @return {void}
 */
Plottable.Plot.prototype._uninstallScaleForKey = function(scale, key) {};

/**
 * @param {!Plottable.Scale<?, ?>} scale
 * @param {string} key
 * @return {void}
 */
Plottable.Plot.prototype._installScaleForKey = function(scale, key) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plot.prototype._propertyProjectors = function() {};

/**
 * @template D, R
 * @param {!Plottable.Plots.AccessorScaleBinding<D, R>} binding
 * @return {!Plottable.Accessor<?>}
 */
Plottable.Plot._scaledAccessor = function(binding) {};

/**
 * @param {?} datum
 * @param {number} index
 * @param {!Plottable.Dataset} dataset
 * @return {{x: number, y: number}}
 */
Plottable.Plot.prototype._pixelPoint = function(datum, index, dataset) {};

/**
 * @return {boolean}
 */
Plottable.Plot.prototype._animateOnNextRender = function() {};

/**
 * @constructor
 * @struct
 */
Plottable.Plots.Pie = function() {};

/**
 * @param {{x: number, y: number}=} origin
 * @param {number=} availableWidth
 * @param {number=} availableHeight
 * @return {!Plottable.Plots.Pie}
 */
Plottable.Plots.Pie.prototype.computeLayout = function(origin, availableWidth, availableHeight) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Plots.Pie}
 */
Plottable.Plots.Pie.prototype.addDataset = function(dataset) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Plots.Pie}
 */
Plottable.Plots.Pie.prototype.removeDataset = function(dataset) {};

/**
 * @return {void}
 */
Plottable.Plots.Pie.prototype._onDatasetUpdate = function() {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawers.Arc}
 */
Plottable.Plots.Pie.prototype._createDrawer = function(dataset) {};

/**
 * @param {!Array<!Plottable.Dataset>=} datasets
 * @return {!Array<!Plottable.Plots.PlotEntity>}
 */
Plottable.Plots.Pie.prototype.entities = function(datasets) {};

/**
 * Gets the AccessorScaleBinding for the sector value.
 * Sets the sector value to a constant number or the result of an Accessor<number>.
 * 
 * Sets the sector value to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @template S
 * @param {(number|!Plottable.Accessor<number>)|(S|!Plottable.Accessor<S>)=} sectorValue
 * @param {!Plottable.Scale<S, number>=} scale
 * @return {!Plottable.Plots.AccessorScaleBinding<S, number>|!Plottable.Plots.Pie}
 */
Plottable.Plots.Pie.prototype.sectorValue = function(sectorValue, scale) {};

/**
 * Gets the AccessorScaleBinding for the inner radius.
 * Sets the inner radius to a constant number or the result of an Accessor<number>.
 * 
 * Sets the inner radius to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @template R
 * @param {(number|!Plottable.Accessor<number>)|(R|!Plottable.Accessor<R>)=} innerRadius
 * @param {!Plottable.Scale<R, number>=} scale
 * @return {!Plottable.Plots.AccessorScaleBinding<R, number>|!Plottable.Plots.Pie}
 */
Plottable.Plots.Pie.prototype.innerRadius = function(innerRadius, scale) {};

/**
 * Gets the AccessorScaleBinding for the outer radius.
 * Sets the outer radius to a constant number or the result of an Accessor<number>.
 * 
 * Sets the outer radius to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @template R
 * @param {(number|!Plottable.Accessor<number>)|(R|!Plottable.Accessor<R>)=} outerRadius
 * @param {!Plottable.Scale<R, number>=} scale
 * @return {!Plottable.Plots.AccessorScaleBinding<R, number>|!Plottable.Plots.Pie}
 */
Plottable.Plots.Pie.prototype.outerRadius = function(outerRadius, scale) {};

/**
 * Get whether slice labels are enabled.
 * 
 * Sets whether labels are enabled.
 * 
 * @param {boolean=} enabled
 * @return {boolean|!Plottable.Plots.Pie}
 */
Plottable.Plots.Pie.prototype.labelsEnabled = function(enabled) {};

/**
 * Gets the Formatter for the labels.
 * Sets the Formatter for the labels.
 * 
 * @param {function(?): string=} formatter
 * @return {function(?): string|!Plottable.Plots.Pie}
 */
Plottable.Plots.Pie.prototype.labelFormatter = function(formatter) {};

/**
 * @param {{x: number, y: number}} queryPoint
 * @return {!Array<!Plottable.Plots.PlotEntity>}
 */
Plottable.Plots.Pie.prototype.entitiesAt = function(queryPoint) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Pie.prototype._propertyProjectors = function() {};

/**
 * @return {!Plottable.Utils.Map<!Plottable.Dataset, !Array<?>>}
 */
Plottable.Plots.Pie.prototype._getDataToDraw = function() {};

/**
 * @param {?} datum
 * @param {number} index
 * @param {!Plottable.Dataset} dataset
 * @return {{x: number, y: number}}
 */
Plottable.Plots.Pie.prototype._pixelPoint = function(datum, index, dataset) {};

/**
 * @param {number} time
 * @return {void}
 */
Plottable.Plots.Pie.prototype._additionalPaint = function(time) {};

/**
 * @constructor
 * @struct
 * An XYPlot is a Plot that displays data along two primary directions, X and Y.
 * 
 */
Plottable.XYPlot = function() {};
 /** @type {string} */
Plottable.XYPlot._X_KEY;
 /** @type {string} */
Plottable.XYPlot._Y_KEY;

/**
 * Returns the whether or not the rendering is deferred for performance boost.
 * Sets / unsets the deferred rendering option
 * Activating this option improves the performance of plot interaction (pan / zoom) by
 * performing lazy renders, only after the interaction has stopped. Because re-rendering
 * is no longer performed during the interaction, the zooming might experience a small
 * resolution degradation, before the lazy re-render is performed.
 * 
 * This option is intended for cases where performance is an issue.
 * @param {boolean=} deferredRendering
 * @return {boolean|!Plottable.XYPlot}
 */
Plottable.XYPlot.prototype.deferredRendering = function(deferredRendering) {};

/**
 * Gets the AccessorScaleBinding for X.
 * Sets X to a constant number or the result of an Accessor<number>.
 * 
 * Sets X to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @param {(number|!Plottable.Accessor<number>)|(X|!Plottable.Accessor<X>)=} x
 * @param {!Plottable.Scale<X, number>=} xScale
 * @return {!Plottable.Plots.AccessorScaleBinding<X, number>|!Plottable.XYPlot}
 */
Plottable.XYPlot.prototype.x = function(x, xScale) {};

/**
 * Gets the AccessorScaleBinding for Y.
 * Sets Y to a constant number or the result of an Accessor<number>.
 * 
 * Sets Y to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @param {(number|!Plottable.Accessor<number>)|(Y|!Plottable.Accessor<Y>)=} y
 * @param {!Plottable.Scale<Y, number>=} yScale
 * @return {!Plottable.Plots.AccessorScaleBinding<Y, number>|!Plottable.XYPlot}
 */
Plottable.XYPlot.prototype.y = function(y, yScale) {};

/**
 * @param {string} property
 * @return {function(?, number, !Plottable.Dataset): boolean}
 */
Plottable.XYPlot.prototype._filterForProperty = function(property) {};

/**
 * @param {!Plottable.Scale<?, ?>} scale
 * @param {string} key
 * @return {void}
 */
Plottable.XYPlot.prototype._uninstallScaleForKey = function(scale, key) {};

/**
 * @param {!Plottable.Scale<?, ?>} scale
 * @param {string} key
 * @return {void}
 */
Plottable.XYPlot.prototype._installScaleForKey = function(scale, key) {};

/**
 * @return {!Plottable.XYPlot}
 */
Plottable.XYPlot.prototype.destroy = function() {};

/**
 * Gets the automatic domain adjustment mode for visible points.
 * Sets the automatic domain adjustment mode for visible points to operate against the X Scale, Y Scale, or neither.
 * If "x" or "y" is specified the adjustment is immediately performed.
 * 
 *   "x" will adjust the x Scale in relation to changes in the y domain.
 *   "y" will adjust the y Scale in relation to changes in the x domain.
 *   "none" means neither Scale will change automatically.
 * @param {string=} autorangeMode
 * @return {string|!Plottable.XYPlot}
 */
Plottable.XYPlot.prototype.autorangeMode = function(autorangeMode) {};

/**
 * @param {{x: number, y: number}=} origin
 * @param {number=} availableWidth
 * @param {number=} availableHeight
 * @return {!Plottable.XYPlot}
 */
Plottable.XYPlot.prototype.computeLayout = function(origin, availableWidth, availableHeight) {};

/**
 * Adjusts the domains of both X and Y scales to show all data.
 * This call does not override the autorange() behavior.
 * 
 * @return {!Plottable.XYPlot}
 */
Plottable.XYPlot.prototype.showAllData = function() {};

/**
 * @return {boolean}
 */
Plottable.XYPlot.prototype._projectorsReady = function() {};

/**
 * @param {?} datum
 * @param {number} index
 * @param {!Plottable.Dataset} dataset
 * @return {{x: number, y: number}}
 */
Plottable.XYPlot.prototype._pixelPoint = function(datum, index, dataset) {};

/**
 * @return {!Plottable.Utils.Map<!Plottable.Dataset, !Array<?>>}
 */
Plottable.XYPlot.prototype._getDataToDraw = function() {};

/**
 * @constructor
 * @struct
 * A Rectangle Plot displays rectangles based on the data.
 * The left and right edges of each rectangle can be set with x() and x2().
 *   If only x() is set the Rectangle Plot will attempt to compute the correct left and right edge positions.
 * The top and bottom edges of each rectangle can be set with y() and y2().
 *   If only y() is set the Rectangle Plot will attempt to compute the correct top and bottom edge positions.
 * 
 */
Plottable.Plots.Rectangle = function() {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawers.Rectangle}
 */
Plottable.Plots.Rectangle.prototype._createDrawer = function(dataset) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Rectangle.prototype._generateAttrToProjector = function() {};

/**
 * @return {!Array<{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}>}
 */
Plottable.Plots.Rectangle.prototype._generateDrawSteps = function() {};

/**
 * @param {string} property
 * @return {void}
 */
Plottable.Plots.Rectangle.prototype._updateExtentsForProperty = function(property) {};

/**
 * @param {string} property
 * @return {function(?, number, !Plottable.Dataset): boolean}
 */
Plottable.Plots.Rectangle.prototype._filterForProperty = function(property) {};

/**
 * Gets the AccessorScaleBinding for X.
 * Sets X to a constant number or the result of an Accessor<number>.
 * 
 * Sets X to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @param {(number|!Plottable.Accessor<number>)|(X|!Plottable.Accessor<X>)=} x
 * @param {!Plottable.Scale<X, number>=} xScale
 * @return {!Plottable.Plots.AccessorScaleBinding<X, number>|!Plottable.Plots.Rectangle}
 */
Plottable.Plots.Rectangle.prototype.x = function(x, xScale) {};

/**
 * Gets the AccessorScaleBinding for X2.
 * Sets X2 to a constant number or the result of an Accessor.
 * If a Scale has been set for X, it will also be used to scale X2.
 * 
 * @param {(number|!Plottable.Accessor<number>|X|!Plottable.Accessor<X>)=} x2
 * @return {!Plottable.Plots.AccessorScaleBinding<X, number>|!Plottable.Plots.Rectangle}
 */
Plottable.Plots.Rectangle.prototype.x2 = function(x2) {};

/**
 * Gets the AccessorScaleBinding for Y.
 * Sets Y to a constant number or the result of an Accessor<number>.
 * 
 * Sets Y to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @param {(number|!Plottable.Accessor<number>)|(Y|!Plottable.Accessor<Y>)=} y
 * @param {!Plottable.Scale<Y, number>=} yScale
 * @return {!Plottable.Plots.AccessorScaleBinding<Y, number>|!Plottable.Plots.Rectangle}
 */
Plottable.Plots.Rectangle.prototype.y = function(y, yScale) {};

/**
 * Gets the AccessorScaleBinding for Y2.
 * Sets Y2 to a constant number or the result of an Accessor.
 * If a Scale has been set for Y, it will also be used to scale Y2.
 * 
 * @param {(number|!Plottable.Accessor<number>|Y|!Plottable.Accessor<Y>)=} y2
 * @return {!Plottable.Plots.AccessorScaleBinding<Y, number>|!Plottable.Plots.Rectangle}
 */
Plottable.Plots.Rectangle.prototype.y2 = function(y2) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Rectangle.prototype._propertyProjectors = function() {};

/**
 * @param {?} datum
 * @param {number} index
 * @param {!Plottable.Dataset} dataset
 * @return {{x: ?, y: ?}}
 */
Plottable.Plots.Rectangle.prototype._pixelPoint = function(datum, index, dataset) {};

/**
 * @return {!Plottable.Utils.Map<!Plottable.Dataset, !Array<?>>}
 */
Plottable.Plots.Rectangle.prototype._getDataToDraw = function() {};

/**
 * @constructor
 * @struct
 * A Scatter Plot draws a symbol at each data point.
 * 
 */
Plottable.Plots.Scatter = function() {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawers.Symbol}
 */
Plottable.Plots.Scatter.prototype._createDrawer = function(dataset) {};

/**
 * Gets the AccessorScaleBinding for the size property of the plot.
 * The size property corresponds to the area of the symbol.
 * Sets the size property to a constant number or the result of an Accessor<number>.
 * 
 * Sets the size property to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @template S
 * @param {(number|!Plottable.Accessor<number>)|(S|!Plottable.Accessor<S>)=} size
 * @param {!Plottable.Scale<S, number>=} scale
 * @return {!Plottable.Plots.AccessorScaleBinding<S, number>|!Plottable.Plots.Scatter}
 */
Plottable.Plots.Scatter.prototype.size = function(size, scale) {};

/**
 * Gets the AccessorScaleBinding for the symbol property of the plot.
 * The symbol property corresponds to how the symbol will be drawn.
 * Sets the symbol property to an Accessor<SymbolFactory>.
 * 
 * @param {!Plottable.Accessor<function(number): string>=} symbol
 * @return {!Plottable.Plots.AccessorScaleBinding<?, ?>|!Plottable.Plots.Scatter}
 */
Plottable.Plots.Scatter.prototype.symbol = function(symbol) {};

/**
 * @return {!Array<{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}>}
 */
Plottable.Plots.Scatter.prototype._generateDrawSteps = function() {};

/**
 * @param {?} datum
 * @param {{x: number, y: number}} pixelPoint
 * @param {!d3.Selection<void>} selection
 * @return {boolean}
 */
Plottable.Plots.Scatter.prototype._visibleOnPlot = function(datum, pixelPoint, selection) {};

/**
 * @param {{x: number, y: number}} pixelPoint
 * @param {?} datum
 * @param {number} index
 * @param {!Plottable.Dataset} dataset
 * @return {boolean}
 */
Plottable.Plots.Scatter.prototype._entityVisibleOnPlot = function(pixelPoint, datum, index, dataset) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Scatter.prototype._propertyProjectors = function() {};

/**
 * @constructor
 * @struct
 * A Bar Plot draws bars growing out from a baseline to some value
 * 
 * @param {string=} orientation
 */
Plottable.Plots.Bar = function(orientation) {};
 /** @type {string} */
Plottable.Plots.Bar.ORIENTATION_VERTICAL;
 /** @type {string} */
Plottable.Plots.Bar.ORIENTATION_HORIZONTAL;
 /** @type {boolean} */
Plottable.Plots.Bar.prototype._isVertical;

/**
 * @param {(number|!Plottable.Accessor<number>)|(X|!Plottable.Accessor<X>)=} x
 * @param {!Plottable.Scale<X, number>=} xScale
 * @return {!Plottable.Plots.AccessorScaleBinding<X, number>|!Plottable.Plots.Bar}
 */
Plottable.Plots.Bar.prototype.x = function(x, xScale) {};

/**
 * @param {(number|!Plottable.Accessor<number>)|(Y|!Plottable.Accessor<Y>)=} y
 * @param {!Plottable.Scale<Y, number>=} yScale
 * @return {!Plottable.Plots.AccessorScaleBinding<Y, number>|!Plottable.Plots.Bar}
 */
Plottable.Plots.Bar.prototype.y = function(y, yScale) {};

/**
 * Gets the orientation of the plot
 * 
 * @return {string} "vertical" | "horizontal"
 */
Plottable.Plots.Bar.prototype.orientation = function() {};

/**
 * @return {!Plottable.Plots.Bar}
 */
Plottable.Plots.Bar.prototype.render = function() {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawers.Rectangle}
 */
Plottable.Plots.Bar.prototype._createDrawer = function(dataset) {};

/**
 * @return {void}
 */
Plottable.Plots.Bar.prototype._setup = function() {};

/**
 * Gets the baseline value.
 * The baseline is the line that the bars are drawn from.
 * 
 * Sets the baseline value.
 * The baseline is the line that the bars are drawn from.
 * 
 * @param {(X|Y)=} value
 * @return {(X|Y)|!Plottable.Plots.Bar}
 */
Plottable.Plots.Bar.prototype.baselineValue = function(value) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Plots.Bar}
 */
Plottable.Plots.Bar.prototype.addDataset = function(dataset) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Plots.Bar}
 */
Plottable.Plots.Bar.prototype.removeDataset = function(dataset) {};

/**
 * Get whether bar labels are enabled.
 * 
 * Sets whether labels are enabled.
 * 
 * @param {boolean=} enabled
 * @return {boolean|!Plottable.Plots.Bar}
 */
Plottable.Plots.Bar.prototype.labelsEnabled = function(enabled) {};

/**
 * Gets the Formatter for the labels.
 * Sets the Formatter for the labels.
 * 
 * @param {function(?): string=} formatter
 * @return {function(?): string|!Plottable.Plots.Bar}
 */
Plottable.Plots.Bar.prototype.labelFormatter = function(formatter) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawer}
 */
Plottable.Plots.Bar.prototype._createNodesForDataset = function(dataset) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {void}
 */
Plottable.Plots.Bar.prototype._removeDatasetNodes = function(dataset) {};

/**
 * Returns the PlotEntity nearest to the query point according to the following algorithm:
 *   - If the query point is inside a bar, returns the PlotEntity for that bar.
 *   - Otherwise, gets the nearest PlotEntity by the primary direction (X for vertical, Y for horizontal),
 *     breaking ties with the secondary direction.
 * Returns undefined if no PlotEntity can be found.
 * 
 * @param {{x: number, y: number}} queryPoint
 * @return {!Plottable.Plots.PlotEntity}
 */
Plottable.Plots.Bar.prototype.entityNearest = function(queryPoint) {};

/**
 * @param {?} datum
 * @param {{x: number, y: number}} pixelPoint
 * @param {!d3.Selection<void>} selection
 * @return {boolean}
 */
Plottable.Plots.Bar.prototype._visibleOnPlot = function(datum, pixelPoint, selection) {};

/**
 * @param {{x: number, y: number}} pixelPoint
 * @param {?} datum
 * @param {number} index
 * @param {!Plottable.Dataset} dataset
 * @return {boolean}
 */
Plottable.Plots.Bar.prototype._entityVisibleOnPlot = function(pixelPoint, datum, index, dataset) {};

/**
 * Gets the Entities at a particular Point.
 * 
 * @param {{x: number, y: number}} p
 * @return {!Array<!Plottable.Plots.PlotEntity>}
 */
Plottable.Plots.Bar.prototype.entitiesAt = function(p) {};

/**
 * Gets the Entities that intersect the Bounds.
 * 
 * Gets the Entities that intersect the area defined by the ranges.
 * 
 * @param {{topLeft: {x: number, y: number}, bottomRight: ?}|{min: number, max: number}} bounds_or_xRange
 * @param {{min: number, max: number}=} yRange
 * @return {!Array<!Plottable.Plots.PlotEntity>}
 */
Plottable.Plots.Bar.prototype.entitiesIn = function(bounds_or_xRange, yRange) {};

/**
 * @param {number} time
 * @return {void}
 */
Plottable.Plots.Bar.prototype._additionalPaint = function(time) {};

/**
 * @return {!Array<{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}>}
 */
Plottable.Plots.Bar.prototype._generateDrawSteps = function() {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Bar.prototype._generateAttrToProjector = function() {};

/**
 * Computes the barPixelWidth of all the bars in the plot.
 * 
 * If the position scale of the plot is a CategoryScale and in bands mode, then the rangeBands function will be used.
 * If the position scale of the plot is a CategoryScale and in points mode, then
 *   from https://github.com/mbostock/d3/wiki/Ordinal-Scales#ordinal_rangePoints, the max barPixelWidth is step * padding
 * If the position scale of the plot is a QuantitativeScale, then _getMinimumDataWidth is scaled to compute the barPixelWidth
 * @return {number}
 */
Plottable.Plots.Bar.prototype._getBarPixelWidth = function() {};

/**
 * @param {!Array<!Plottable.Dataset>=} datasets
 * @return {!Array<!Plottable.Plots.PlotEntity>}
 */
Plottable.Plots.Bar.prototype.entities = function(datasets) {};

/**
 * @param {?} datum
 * @param {number} index
 * @param {!Plottable.Dataset} dataset
 * @return {{x: ?, y: ?}}
 */
Plottable.Plots.Bar.prototype._pixelPoint = function(datum, index, dataset) {};

/**
 * @param {!Plottable.Scale<?, number>} scale
 * @param {string} key
 * @return {void}
 */
Plottable.Plots.Bar.prototype._uninstallScaleForKey = function(scale, key) {};

/**
 * @return {!Plottable.Utils.Map<!Plottable.Dataset, !Array<?>>}
 */
Plottable.Plots.Bar.prototype._getDataToDraw = function() {};

/**
 * @constructor
 * @struct
 * A Line Plot draws line segments starting from the first data point to the next.
 * 
 */
Plottable.Plots.Line = function() {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawer}
 */
Plottable.Plots.Line.prototype._createDrawer = function(dataset) {};

/**
 * @return {function(?, number, !Plottable.Dataset): number}
 */
Plottable.Plots.Line.prototype._getResetYFunction = function() {};

/**
 * @return {!Array<{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}>}
 */
Plottable.Plots.Line.prototype._generateDrawSteps = function() {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Line.prototype._generateAttrToProjector = function() {};

/**
 * Returns the PlotEntity nearest to the query point by X then by Y, or undefined if no PlotEntity can be found.
 * 
 * @param {{x: number, y: number}} queryPoint
 * @return {!Plottable.Plots.PlotEntity}
 */
Plottable.Plots.Line.prototype.entityNearest = function(queryPoint) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Line.prototype._propertyProjectors = function() {};

/**
 * @param {function(?, number, !Plottable.Dataset): ?} xProjector
 * @param {function(?, number, !Plottable.Dataset): ?} yProjector
 * @return {function(?, number, !Plottable.Dataset): string}
 */
Plottable.Plots.Line.prototype._constructLineProjector = function(xProjector, yProjector) {};

/**
 * @return {!Plottable.Utils.Map<!Plottable.Dataset, !Array<?>>}
 */
Plottable.Plots.Line.prototype._getDataToDraw = function() {};

/**
 * @constructor
 * @struct
 * An Area Plot draws a filled region (area) between Y and Y0.
 * 
 */
Plottable.Plots.Area = function() {};

/**
 * @return {void}
 */
Plottable.Plots.Area.prototype._setup = function() {};

/**
 * @param {(number|!Plottable.Accessor<number>)=} y
 * @param {!Plottable.QuantitativeScale<number>=} yScale
 * @return {!Plottable.Plots.AccessorScaleBinding<number, number>|!Plottable.Plots.Area}
 */
Plottable.Plots.Area.prototype.y = function(y, yScale) {};

/**
 * Gets the AccessorScaleBinding for Y0.
 * Sets Y0 to a constant number or the result of an Accessor<number>.
 * If a Scale has been set for Y, it will also be used to scale Y0.
 * 
 * @param {(number|!Plottable.Accessor<number>)=} y0
 * @return {!Plottable.Plots.AccessorScaleBinding<number, number>|!Plottable.Plots.Area}
 */
Plottable.Plots.Area.prototype.y0 = function(y0) {};

/**
 * @return {void}
 */
Plottable.Plots.Area.prototype._onDatasetUpdate = function() {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Plots.Area}
 */
Plottable.Plots.Area.prototype.addDataset = function(dataset) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {void}
 */
Plottable.Plots.Area.prototype._removeDatasetNodes = function(dataset) {};

/**
 * @return {void}
 */
Plottable.Plots.Area.prototype._additionalPaint = function() {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawers.Area}
 */
Plottable.Plots.Area.prototype._createDrawer = function(dataset) {};

/**
 * @return {!Array<{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}>}
 */
Plottable.Plots.Area.prototype._generateDrawSteps = function() {};

/**
 * @return {void}
 */
Plottable.Plots.Area.prototype._updateYScale = function() {};

/**
 * @return {!Plottable.Accessor<?>}
 */
Plottable.Plots.Area.prototype._getResetYFunction = function() {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Area.prototype._propertyProjectors = function() {};

/**
 * @param {!Array<!Plottable.Dataset>=} datasets
 * @return {!d3.Selection<?>}
 */
Plottable.Plots.Area.prototype.selections = function(datasets) {};

/**
 * @param {function(?, number, !Plottable.Dataset): ?} xProjector
 * @param {function(?, number, !Plottable.Dataset): ?} yProjector
 * @param {function(?, number, !Plottable.Dataset): ?} y0Projector
 * @return {function(!Array<?>, number, !Plottable.Dataset): string}
 */
Plottable.Plots.Area.prototype._constructAreaProjector = function(xProjector, yProjector, y0Projector) {};

/**
 * @constructor
 * @struct
 * A ClusteredBar Plot groups bars across Datasets based on the primary value of the bars.
 *   On a vertical ClusteredBar Plot, the bars with the same X value are grouped.
 *   On a horizontal ClusteredBar Plot, the bars with the same Y value are grouped.
 * 
 * @param {string=} orientation
 */
Plottable.Plots.ClusteredBar = function(orientation) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.ClusteredBar.prototype._generateAttrToProjector = function() {};

/**
 * @return {!Plottable.Utils.Map<!Plottable.Dataset, !Array<?>>}
 */
Plottable.Plots.ClusteredBar.prototype._getDataToDraw = function() {};

/**
 * @constructor
 * @struct
 */
Plottable.Plots.StackedArea = function() {};

/**
 * @param {string} key
 * @return {!Plottable.Animator}
 */
Plottable.Plots.StackedArea.prototype._getAnimator = function(key) {};

/**
 * @return {void}
 */
Plottable.Plots.StackedArea.prototype._setup = function() {};

/**
 * @param {(number|!Plottable.Accessor<number>)|(X|!Plottable.Accessor<X>)=} x
 * @param {!Plottable.Scale<X, number>=} xScale
 * @return {!Plottable.Plots.AccessorScaleBinding<X, number>|!Plottable.Plots.StackedArea}
 */
Plottable.Plots.StackedArea.prototype.x = function(x, xScale) {};

/**
 * @param {(number|!Plottable.Accessor<number>)=} y
 * @param {!Plottable.QuantitativeScale<number>=} yScale
 * @return {!Plottable.Plots.AccessorScaleBinding<number, number>|!Plottable.Plots.StackedArea}
 */
Plottable.Plots.StackedArea.prototype.y = function(y, yScale) {};

/**
 * @return {void}
 */
Plottable.Plots.StackedArea.prototype._additionalPaint = function() {};

/**
 * @return {void}
 */
Plottable.Plots.StackedArea.prototype._updateYScale = function() {};

/**
 * @return {!Plottable.Plots.StackedArea}
 */
Plottable.Plots.StackedArea.prototype._onDatasetUpdate = function() {};

/**
 * @param {string} property
 * @return {void}
 */
Plottable.Plots.StackedArea.prototype._updateExtentsForProperty = function(property) {};

/**
 * @param {string} attr
 * @return {!Array<?>}
 */
Plottable.Plots.StackedArea.prototype._extentsForProperty = function(attr) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.StackedArea.prototype._propertyProjectors = function() {};

/**
 * @param {?} datum
 * @param {number} index
 * @param {!Plottable.Dataset} dataset
 * @return {{x: number, y: number}}
 */
Plottable.Plots.StackedArea.prototype._pixelPoint = function(datum, index, dataset) {};

/**
 * @constructor
 * @struct
 * A StackedBar Plot stacks bars across Datasets based on the primary value of the bars.
 *   On a vertical StackedBar Plot, the bars with the same X value are stacked.
 *   On a horizontal StackedBar Plot, the bars with the same Y value are stacked.
 * 
 * @param {string=} orientation
 */
Plottable.Plots.StackedBar = function(orientation) {};

/**
 * @param {(number|!Plottable.Accessor<number>)|(X|!Plottable.Accessor<X>)=} x
 * @param {!Plottable.Scale<X, number>=} xScale
 * @return {!Plottable.Plots.AccessorScaleBinding<X, number>|!Plottable.Plots.StackedBar}
 */
Plottable.Plots.StackedBar.prototype.x = function(x, xScale) {};

/**
 * @param {(number|!Plottable.Accessor<number>)|(Y|!Plottable.Accessor<Y>)=} y
 * @param {!Plottable.Scale<Y, number>=} yScale
 * @return {!Plottable.Plots.AccessorScaleBinding<Y, number>|!Plottable.Plots.StackedBar}
 */
Plottable.Plots.StackedBar.prototype.y = function(y, yScale) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.StackedBar.prototype._generateAttrToProjector = function() {};

/**
 * @return {!Plottable.Plots.StackedBar}
 */
Plottable.Plots.StackedBar.prototype._onDatasetUpdate = function() {};

/**
 * @param {string} property
 * @return {void}
 */
Plottable.Plots.StackedBar.prototype._updateExtentsForProperty = function(property) {};

/**
 * @param {string} attr
 * @return {!Array<?>}
 */
Plottable.Plots.StackedBar.prototype._extentsForProperty = function(attr) {};

/**
 * @constructor
 * @struct
 * A Segment Plot displays line segments based on the data.
 * 
 */
Plottable.Plots.Segment = function() {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawers.Segment}
 */
Plottable.Plots.Segment.prototype._createDrawer = function(dataset) {};

/**
 * @return {!Array<{attrToProjector: !Object<string,function(?, number, !Plottable.Dataset): ?>, animator: !Plottable.Animator}>}
 */
Plottable.Plots.Segment.prototype._generateDrawSteps = function() {};

/**
 * @param {string} property
 * @return {void}
 */
Plottable.Plots.Segment.prototype._updateExtentsForProperty = function(property) {};

/**
 * @param {string} property
 * @return {function(?, number, !Plottable.Dataset): boolean}
 */
Plottable.Plots.Segment.prototype._filterForProperty = function(property) {};

/**
 * Gets the AccessorScaleBinding for X
 * Sets X to a constant value or the result of an Accessor.
 * 
 * Sets X to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @param {(number|!Plottable.Accessor<number>)|(X|!Plottable.Accessor<X>)=} x
 * @param {!Plottable.Scale<X, number>=} xScale
 * @return {!Plottable.Plots.AccessorScaleBinding<X, number>|!Plottable.Plots.Segment}
 */
Plottable.Plots.Segment.prototype.x = function(x, xScale) {};

/**
 * Gets the AccessorScaleBinding for X2
 * Sets X2 to a constant number or the result of an Accessor.
 * If a Scale has been set for X, it will also be used to scale X2.
 * 
 * @param {(number|!Plottable.Accessor<number>|X|!Plottable.Accessor<X>)=} x2
 * @return {!Plottable.Plots.AccessorScaleBinding<X, number>|!Plottable.Plots.Segment}
 */
Plottable.Plots.Segment.prototype.x2 = function(x2) {};

/**
 * Gets the AccessorScaleBinding for Y
 * Sets Y to a constant value or the result of an Accessor.
 * 
 * Sets Y to a scaled constant value or scaled result of an Accessor.
 * The provided Scale will account for the values when autoDomain()-ing.
 * 
 * @param {(number|!Plottable.Accessor<number>)|(Y|!Plottable.Accessor<Y>)=} y
 * @param {!Plottable.Scale<Y, number>=} yScale
 * @return {!Plottable.Plots.AccessorScaleBinding<Y, number>|!Plottable.Plots.Segment}
 */
Plottable.Plots.Segment.prototype.y = function(y, yScale) {};

/**
 * Gets the AccessorScaleBinding for Y2.
 * Sets Y2 to a constant number or the result of an Accessor.
 * If a Scale has been set for Y, it will also be used to scale Y2.
 * 
 * @param {(number|!Plottable.Accessor<number>|Y|!Plottable.Accessor<Y>)=} y2
 * @return {!Plottable.Plots.AccessorScaleBinding<Y, number>|!Plottable.Plots.Segment}
 */
Plottable.Plots.Segment.prototype.y2 = function(y2) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Segment.prototype._propertyProjectors = function() {};

/**
 * @constructor
 * @struct
 */
Plottable.Plots.Waterfall = function() {};

/**
 * Gets whether connectors are enabled.
 * 
 * Sets whether connectors are enabled.
 * 
 * @param {boolean=} enabled
 * @return {boolean|!Plottable.Plots.Waterfall}
 */
Plottable.Plots.Waterfall.prototype.connectorsEnabled = function(enabled) {};

/**
 * Gets the AccessorScaleBinding for whether a bar represents a total or a delta.
 * Sets total to a constant number or the result of an Accessor
 * 
 * @template T
 * @param {!Plottable.Accessor<boolean>=} total
 * @return {!Plottable.Plots.AccessorScaleBinding<T, boolean>|!Plottable.Plots.Waterfall}
 */
Plottable.Plots.Waterfall.prototype.total = function(total) {};

/**
 * @param {number} time
 * @return {void}
 */
Plottable.Plots.Waterfall.prototype._additionalPaint = function(time) {};

/**
 * @param {!Plottable.Dataset} dataset
 * @return {!Plottable.Drawer}
 */
Plottable.Plots.Waterfall.prototype._createNodesForDataset = function(dataset) {};

/**
 * @param {string} attr
 * @return {!Array<?>}
 */
Plottable.Plots.Waterfall.prototype._extentsForProperty = function(attr) {};

/**
 * @return {!Object<string,function(?, number, !Plottable.Dataset): ?>}
 */
Plottable.Plots.Waterfall.prototype._generateAttrToProjector = function() {};

/**
 * @return {!Plottable.Plots.Waterfall}
 */
Plottable.Plots.Waterfall.prototype._onDatasetUpdate = function() {};
/**
 * @record
 * @struct
 */
Plottable.Animator = function() {};

/**
 * Applies the supplied attributes to a d3.Selection with some animation.
 * 
 *     AppliedProjectors that we will use to set attributes on the selection.
 *     transition object so that plots may chain the transitions between
 *     animators.
 * @param {!d3.Selection<?>} selection
 * @param {!Object<string,function(?, number): ?>} attrToAppliedProjector
 * @return {(!d3.Selection<?>|!d3.Transition<?>)}
 */
Plottable.Animator.prototype.animate = function(selection, attrToAppliedProjector) {};

/**
 * Given the number of elements, return the total time the animation requires
 * 
 * @param {number} numberOfIterations
 * @return {number}
 */
Plottable.Animator.prototype.totalTime = function(numberOfIterations) {};
/** @const */
Plottable.Animators = {};
/**
 * @implements {Plottable.Animator}
 * @constructor
 * @struct
 */
Plottable.Animators.Null = function() {};

/**
 * @param {?} selection
 * @return {number}
 */
Plottable.Animators.Null.prototype.totalTime = function(selection) {};

/**
 * @param {!d3.Selection<?>} selection
 * @param {!Object<string,function(?, number): ?>} attrToAppliedProjector
 * @return {!d3.Selection<?>}
 */
Plottable.Animators.Null.prototype.animate = function(selection, attrToAppliedProjector) {};

/**
 * @constructor
 * @struct
 * Constructs the default animator
 * 
 */
Plottable.Animators.Easing = function() {};

/**
 * @param {number} numberOfSteps
 * @return {number}
 */
Plottable.Animators.Easing.prototype.totalTime = function(numberOfSteps) {};

/**
 * @param {!d3.Selection<?>} selection
 * @param {!Object<string,function(?, number): ?>} attrToAppliedProjector
 * @return {!d3.Transition<?>}
 */
Plottable.Animators.Easing.prototype.animate = function(selection, attrToAppliedProjector) {};

/**
 * Gets the start delay of the animation in milliseconds.
 * 
 * Sets the start delay of the animation in milliseconds.
 * 
 * @param {number=} startDelay
 * @return {number|!Plottable.Animators.Easing}
 */
Plottable.Animators.Easing.prototype.startDelay = function(startDelay) {};

/**
 * Gets the duration of one animation step in milliseconds.
 * 
 * Sets the duration of one animation step in milliseconds.
 * 
 * @param {number=} stepDuration
 * @return {number|!Plottable.Animators.Easing}
 */
Plottable.Animators.Easing.prototype.stepDuration = function(stepDuration) {};

/**
 * Gets the maximum start delay between animation steps in milliseconds.
 * 
 * Sets the maximum start delay between animation steps in milliseconds.
 * 
 * @param {number=} stepDelay
 * @return {number|!Plottable.Animators.Easing}
 */
Plottable.Animators.Easing.prototype.stepDelay = function(stepDelay) {};

/**
 * Gets the maximum total animation duration constraint in milliseconds.
 * 
 * If the animation time would exceed the specified time, the duration of each step
 * and the delay between each step will be reduced until the animation fits within
 * the specified time.
 * 
 * Sets the maximum total animation duration constraint in miliseconds.
 * 
 * If the animation time would exceed the specified time, the duration of each step
 * and the delay between each step will be reduced until the animation fits within
 * the specified time.
 * 
 * @param {number=} maxTotalDuration
 * @return {number|!Plottable.Animators.Easing}
 */
Plottable.Animators.Easing.prototype.maxTotalDuration = function(maxTotalDuration) {};

/**
 * Gets the current easing mode of the animation.
 * 
 * Sets the easing mode of the animation.
 * 
 * @param {string=} easingMode
 * @return {string|!Plottable.Animators.Easing}
 */
Plottable.Animators.Easing.prototype.easingMode = function(easingMode) {};
/**
 * @constructor
 * @struct
 */
Plottable.Dispatcher = function() {};
 /** @type {!Object<string,function(!Event): ?>} */
Plottable.Dispatcher.prototype._eventToCallback;
 /** @type {!Array<!Plottable.Utils.CallbackSet<!Function>>} */
Plottable.Dispatcher.prototype._callbacks;

/**
 * @param {!Plottable.Utils.CallbackSet<!Function>} callbackSet
 * @param {!Function} callback
 * @return {void}
 */
Plottable.Dispatcher.prototype._setCallback = function(callbackSet, callback) {};

/**
 * @param {!Plottable.Utils.CallbackSet<!Function>} callbackSet
 * @param {!Function} callback
 * @return {void}
 */
Plottable.Dispatcher.prototype._unsetCallback = function(callbackSet, callback) {};
/** @const */
Plottable.Dispatchers = {};

/** @typedef {function({x: number, y: number}, !MouseEvent): void} */
Plottable.Dispatchers.MouseCallback;

/**
 * @constructor
 * @struct
 * This constructor not be invoked directly.
 * 
 * @param {!SVGElement} svg
 */
Plottable.Dispatchers.Mouse = function(svg) {};

/**
 * Get a Mouse Dispatcher for the <svg> containing elem.
 * If one already exists on that <svg>, it will be returned; otherwise, a new one will be created.
 * 
 * @param {!SVGElement} elem
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.getDispatcher = function(elem) {};

/**
 * Registers a callback to be called when the mouse position changes.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.onMouseMove = function(callback) {};

/**
 * Removes a callback that would be called when the mouse position changes.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.offMouseMove = function(callback) {};

/**
 * Registers a callback to be called when a mousedown occurs.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.onMouseDown = function(callback) {};

/**
 * Removes a callback that would be called when a mousedown occurs.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.offMouseDown = function(callback) {};

/**
 * Registers a callback to be called when a mouseup occurs.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.onMouseUp = function(callback) {};

/**
 * Removes a callback that would be called when a mouseup occurs.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.offMouseUp = function(callback) {};

/**
 * Registers a callback to be called when a wheel event occurs.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.onWheel = function(callback) {};

/**
 * Removes a callback that would be called when a wheel event occurs.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.offWheel = function(callback) {};

/**
 * Registers a callback to be called when a dblClick occurs.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.onDblClick = function(callback) {};

/**
 * Removes a callback that would be called when a dblClick occurs.
 * 
 * @param {function({x: number, y: number}, !MouseEvent): void} callback
 * @return {!Plottable.Dispatchers.Mouse}
 */
Plottable.Dispatchers.Mouse.prototype.offDblClick = function(callback) {};

/**
 * Returns the last computed mouse position in <svg> coordinate space.
 * 
 * @return {{x: number, y: number}}
 */
Plottable.Dispatchers.Mouse.prototype.lastMousePosition = function() {};

/** @typedef {function(!Array<number>, !Object<number,{x: number, y: number}>, !TouchEvent): void} */
Plottable.Dispatchers.TouchCallback;

/**
 * @constructor
 * @struct
 * This constructor should not be invoked directly.
 * 
 * @param {!SVGElement} svg
 */
Plottable.Dispatchers.Touch = function(svg) {};

/**
 * Gets a Touch Dispatcher for the <svg> containing elem.
 * If one already exists on that <svg>, it will be returned; otherwise, a new one will be created.
 * 
 * @param {!SVGElement} elem
 * @return {!Plottable.Dispatchers.Touch}
 */
Plottable.Dispatchers.Touch.getDispatcher = function(elem) {};

/**
 * Registers a callback to be called when a touch starts.
 * 
 * @param {function(!Array<number>, !Object<number,{x: number, y: number}>, !TouchEvent): void} callback
 * @return {!Plottable.Dispatchers.Touch}
 */
Plottable.Dispatchers.Touch.prototype.onTouchStart = function(callback) {};

/**
 * Removes a callback that would be called when a touch starts.
 * 
 * @param {function(!Array<number>, !Object<number,{x: number, y: number}>, !TouchEvent): void} callback
 * @return {!Plottable.Dispatchers.Touch}
 */
Plottable.Dispatchers.Touch.prototype.offTouchStart = function(callback) {};

/**
 * Registers a callback to be called when the touch position changes.
 * 
 * @param {function(!Array<number>, !Object<number,{x: number, y: number}>, !TouchEvent): void} callback
 * @return {!Plottable.Dispatchers.Touch}
 */
Plottable.Dispatchers.Touch.prototype.onTouchMove = function(callback) {};

/**
 * Removes a callback that would be called when the touch position changes.
 * 
 * @param {function(!Array<number>, !Object<number,{x: number, y: number}>, !TouchEvent): void} callback
 * @return {!Plottable.Dispatchers.Touch}
 */
Plottable.Dispatchers.Touch.prototype.offTouchMove = function(callback) {};

/**
 * Registers a callback to be called when a touch ends.
 * 
 * @param {function(!Array<number>, !Object<number,{x: number, y: number}>, !TouchEvent): void} callback
 * @return {!Plottable.Dispatchers.Touch}
 */
Plottable.Dispatchers.Touch.prototype.onTouchEnd = function(callback) {};

/**
 * Removes a callback that would be called when a touch ends.
 * 
 * @param {function(!Array<number>, !Object<number,{x: number, y: number}>, !TouchEvent): void} callback
 * @return {!Plottable.Dispatchers.Touch}
 */
Plottable.Dispatchers.Touch.prototype.offTouchEnd = function(callback) {};

/**
 * Registers a callback to be called when a touch is cancelled.
 * 
 * @param {function(!Array<number>, !Object<number,{x: number, y: number}>, !TouchEvent): void} callback
 * @return {!Plottable.Dispatchers.Touch}
 */
Plottable.Dispatchers.Touch.prototype.onTouchCancel = function(callback) {};

/**
 * Removes a callback that would be called when a touch is cancelled.
 * 
 * @param {function(!Array<number>, !Object<number,{x: number, y: number}>, !TouchEvent): void} callback
 * @return {!Plottable.Dispatchers.Touch}
 */
Plottable.Dispatchers.Touch.prototype.offTouchCancel = function(callback) {};

/** @typedef {function(number, !KeyboardEvent): void} */
Plottable.Dispatchers.KeyCallback;

/**
 * @constructor
 * @struct
 * This constructor should not be invoked directly.
 * 
 */
Plottable.Dispatchers.Key = function() {};

/**
 * Gets a Key Dispatcher. If one already exists it will be returned;
 * otherwise, a new one will be created.
 * 
 * @return {!Plottable.Dispatchers.Key}
 */
Plottable.Dispatchers.Key.getDispatcher = function() {};

/**
 * Registers a callback to be called whenever a key is pressed.
 * 
 * @param {function(number, !KeyboardEvent): void} callback
 * @return {!Plottable.Dispatchers.Key}
 */
Plottable.Dispatchers.Key.prototype.onKeyDown = function(callback) {};

/**
 * Removes the callback to be called whenever a key is pressed.
 * 
 * @param {function(number, !KeyboardEvent): void} callback
 * @return {!Plottable.Dispatchers.Key}
 */
Plottable.Dispatchers.Key.prototype.offKeyDown = function(callback) {};
/**
 * @constructor
 * @struct
 */
Plottable.Interaction = function() {};
 /** @type {!Plottable.Component} */
Plottable.Interaction.prototype._componentAttachedTo;

/**
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.Interaction.prototype._anchor = function(component) {};

/**
 * @return {void}
 */
Plottable.Interaction.prototype._unanchor = function() {};

/**
 * Attaches this Interaction to a Component.
 * If the Interaction was already attached to a Component, it first detaches itself from the old Component.
 * 
 * @param {!Plottable.Component} component
 * @return {!Plottable.Interaction}
 */
Plottable.Interaction.prototype.attachTo = function(component) {};

/**
 * Detaches this Interaction from the Component.
 * This Interaction can be reused.
 * 
 * @param {!Plottable.Component} component
 * @return {!Plottable.Interaction}
 */
Plottable.Interaction.prototype.detachFrom = function(component) {};

/**
 * Gets whether this Interaction is enabled.
 * Enables or disables this Interaction.
 * 
 * @param {boolean=} enabled
 * @return {boolean|!Plottable.Interaction}
 */
Plottable.Interaction.prototype.enabled = function(enabled) {};

/**
 * Translates an <svg>-coordinate-space point to Component-space coordinates.
 * 
 * @param {{x: number, y: number}} p
 * @return {{x: number, y: number}}
 */
Plottable.Interaction.prototype._translateToComponentSpace = function(p) {};

/**
 * Checks whether a Component-coordinate-space Point is inside the Component.
 * 
 * @param {{x: number, y: number}} p
 * @return {boolean}
 */
Plottable.Interaction.prototype._isInsideComponent = function(p) {};

/** @typedef {function({x: number, y: number}): void} */
Plottable.ClickCallback;
/** @const */
Plottable.Interactions = {};
/**
 * @extends {Plottable.Interaction}
 * @constructor
 * @struct
 */
Plottable.Interactions.Click = function() {};

/**
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.Interactions.Click.prototype._anchor = function(component) {};

/**
 * @return {void}
 */
Plottable.Interactions.Click.prototype._unanchor = function() {};

/**
 * Adds a callback to be called when the Component is clicked.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.Click}
 */
Plottable.Interactions.Click.prototype.onClick = function(callback) {};

/**
 * Removes a callback that would be called when the Component is clicked.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.Click}
 */
Plottable.Interactions.Click.prototype.offClick = function(callback) {};
/**
 * @extends {Plottable.Interaction}
 * @constructor
 * @struct
 */
Plottable.Interactions.DoubleClick = function() {};

/**
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.Interactions.DoubleClick.prototype._anchor = function(component) {};

/**
 * @return {void}
 */
Plottable.Interactions.DoubleClick.prototype._unanchor = function() {};

/**
 * Adds a callback to be called when the Component is double-clicked.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.DoubleClick}
 */
Plottable.Interactions.DoubleClick.prototype.onDoubleClick = function(callback) {};

/**
 * Removes a callback that would be called when the Component is double-clicked.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.DoubleClick}
 */
Plottable.Interactions.DoubleClick.prototype.offDoubleClick = function(callback) {};

/** @typedef {function(number): void} */
Plottable.KeyCallback;
/**
 * @extends {Plottable.Interaction}
 * @constructor
 * @struct
 */
Plottable.Interactions.Key = function() {};

/**
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.Interactions.Key.prototype._anchor = function(component) {};

/**
 * @return {void}
 */
Plottable.Interactions.Key.prototype._unanchor = function() {};

/**
 * Adds a callback to be called when the key with the given keyCode is
 * pressed and the user is moused over the Component.
 * 
 * @param {number} keyCode
 * @param {function(number): void} callback
 * @return {!Plottable.Interactions.Key}
 */
Plottable.Interactions.Key.prototype.onKeyPress = function(keyCode, callback) {};

/**
 * Removes a callback that would be called when the key with the given keyCode is
 * pressed and the user is moused over the Component.
 * 
 * @param {number} keyCode
 * @param {function(number): void} callback
 * @return {!Plottable.Interactions.Key}
 */
Plottable.Interactions.Key.prototype.offKeyPress = function(keyCode, callback) {};

/** @typedef {function({x: number, y: number}): void} */
Plottable.PointerCallback;
/**
 * @extends {Plottable.Interaction}
 * @constructor
 * @struct
 */
Plottable.Interactions.Pointer = function() {};

/**
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.Interactions.Pointer.prototype._anchor = function(component) {};

/**
 * @return {void}
 */
Plottable.Interactions.Pointer.prototype._unanchor = function() {};

/**
 * Adds a callback to be called when the pointer enters the Component.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.Pointer}
 */
Plottable.Interactions.Pointer.prototype.onPointerEnter = function(callback) {};

/**
 * Removes a callback that would be called when the pointer enters the Component.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.Pointer}
 */
Plottable.Interactions.Pointer.prototype.offPointerEnter = function(callback) {};

/**
 * Adds a callback to be called when the pointer moves within the Component.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.Pointer}
 */
Plottable.Interactions.Pointer.prototype.onPointerMove = function(callback) {};

/**
 * Removes a callback that would be called when the pointer moves within the Component.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.Pointer}
 */
Plottable.Interactions.Pointer.prototype.offPointerMove = function(callback) {};

/**
 * Adds a callback to be called when the pointer exits the Component.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.Pointer}
 */
Plottable.Interactions.Pointer.prototype.onPointerExit = function(callback) {};

/**
 * Removes a callback that would be called when the pointer exits the Component.
 * 
 * @param {function({x: number, y: number}): void} callback
 * @return {!Plottable.Interactions.Pointer}
 */
Plottable.Interactions.Pointer.prototype.offPointerExit = function(callback) {};

/**
 * @constructor
 * @struct
 * A PanZoom Interaction updates the domains of an x-scale and/or a y-scale
 * in response to the user panning or zooming.
 * 
 * @param {!Plottable.QuantitativeScale<?>=} xScale
 * @param {!Plottable.QuantitativeScale<?>=} yScale
 */
Plottable.Interactions.PanZoom = function(xScale, yScale) {};

/**
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.Interactions.PanZoom.prototype._anchor = function(component) {};

/**
 * @return {void}
 */
Plottable.Interactions.PanZoom.prototype._unanchor = function() {};

/**
 * Gets the x scales for this PanZoom Interaction.
 * Sets the x scales for this PanZoom Interaction.
 * 
 * @param {!Array<!Plottable.QuantitativeScale<?>>=} xScales
 * @return {!Array<!Plottable.QuantitativeScale<?>>|!Plottable.Interactions.PanZoom}
 */
Plottable.Interactions.PanZoom.prototype.xScales = function(xScales) {};

/**
 * Gets the y scales for this PanZoom Interaction.
 * Sets the y scales for this PanZoom Interaction.
 * 
 * @param {!Array<!Plottable.QuantitativeScale<?>>=} yScales
 * @return {!Array<!Plottable.QuantitativeScale<?>>|!Plottable.Interactions.PanZoom}
 */
Plottable.Interactions.PanZoom.prototype.yScales = function(yScales) {};

/**
 * Adds an x scale to this PanZoom Interaction
 * 
 * @param {!Plottable.QuantitativeScale<?>} xScale
 * @return {!Plottable.Interactions.PanZoom}
 */
Plottable.Interactions.PanZoom.prototype.addXScale = function(xScale) {};

/**
 * Removes an x scale from this PanZoom Interaction
 * 
 * @param {!Plottable.QuantitativeScale<?>} xScale
 * @return {!Plottable.Interactions.PanZoom}
 */
Plottable.Interactions.PanZoom.prototype.removeXScale = function(xScale) {};

/**
 * Adds a y scale to this PanZoom Interaction
 * 
 * @param {!Plottable.QuantitativeScale<?>} yScale
 * @return {!Plottable.Interactions.PanZoom}
 */
Plottable.Interactions.PanZoom.prototype.addYScale = function(yScale) {};

/**
 * Removes a y scale from this PanZoom Interaction
 * 
 * @param {!Plottable.QuantitativeScale<?>} yScale
 * @return {!Plottable.Interactions.PanZoom}
 */
Plottable.Interactions.PanZoom.prototype.removeYScale = function(yScale) {};

/**
 * Gets the minimum domain extent for the scale, specifying the minimum allowable amount
 * between the ends of the domain.
 * 
 * Note that extents will mainly work on scales that work linearly like Linear Scale and Time Scale
 * 
 * Sets the minimum domain extent for the scale, specifying the minimum allowable amount
 * between the ends of the domain.
 * 
 * Note that extents will mainly work on scales that work linearly like Linear Scale and Time Scale
 * 
 * @template D
 * @param {!Plottable.QuantitativeScale<D>} quantitativeScale
 * @param {D=} minDomainExtent
 * @return {D|!Plottable.Interactions.PanZoom}
 */
Plottable.Interactions.PanZoom.prototype.minDomainExtent = function(quantitativeScale, minDomainExtent) {};

/**
 * Gets the maximum domain extent for the scale, specifying the maximum allowable amount
 * between the ends of the domain.
 * 
 * Note that extents will mainly work on scales that work linearly like Linear Scale and Time Scale
 * 
 * Sets the maximum domain extent for the scale, specifying the maximum allowable amount
 * between the ends of the domain.
 * 
 * Note that extents will mainly work on scales that work linearly like Linear Scale and Time Scale
 * 
 * @template D
 * @param {!Plottable.QuantitativeScale<D>} quantitativeScale
 * @param {D=} maxDomainExtent
 * @return {D|!Plottable.Interactions.PanZoom}
 */
Plottable.Interactions.PanZoom.prototype.maxDomainExtent = function(quantitativeScale, maxDomainExtent) {};

/** @typedef {function({x: number, y: number}, ?): void} */
Plottable.DragCallback;
/**
 * @extends {Plottable.Interaction}
 * @constructor
 * @struct
 */
Plottable.Interactions.Drag = function() {};

/**
 * @param {!Plottable.Component} component
 * @return {void}
 */
Plottable.Interactions.Drag.prototype._anchor = function(component) {};

/**
 * @return {void}
 */
Plottable.Interactions.Drag.prototype._unanchor = function() {};

/**
 * Gets whether the Drag Interaction constrains Points passed to its
 * callbacks to lie inside its Component.
 * 
 * If true, when the user drags outside of the Component, the closest Point
 * inside the Component will be passed to the callback instead of the actual
 * cursor position.
 * 
 * Sets whether the Drag Interaction constrains Points passed to its
 * callbacks to lie inside its Component.
 * 
 * If true, when the user drags outside of the Component, the closest Point
 * inside the Component will be passed to the callback instead of the actual
 * cursor position.
 * 
 * @param {boolean=} constrainedToComponent
 * @return {boolean|!Plottable.Interactions.Drag}
 */
Plottable.Interactions.Drag.prototype.constrainedToComponent = function(constrainedToComponent) {};

/**
 * Adds a callback to be called when dragging starts.
 * 
 * @param {function({x: number, y: number}, ?): void} callback
 * @return {!Plottable.Interactions.Drag}
 */
Plottable.Interactions.Drag.prototype.onDragStart = function(callback) {};

/**
 * Removes a callback that would be called when dragging starts.
 * 
 * @param {function({x: number, y: number}, ?): void} callback
 * @return {!Plottable.Interactions.Drag}
 */
Plottable.Interactions.Drag.prototype.offDragStart = function(callback) {};

/**
 * Adds a callback to be called during dragging.
 * 
 * @param {function({x: number, y: number}, ?): void} callback
 * @return {!Plottable.Interactions.Drag}
 */
Plottable.Interactions.Drag.prototype.onDrag = function(callback) {};

/**
 * Removes a callback that would be called during dragging.
 * 
 * @param {function({x: number, y: number}, ?): void} callback
 * @return {!Plottable.Interactions.Drag}
 */
Plottable.Interactions.Drag.prototype.offDrag = function(callback) {};

/**
 * Adds a callback to be called when dragging ends.
 * 
 * @param {function({x: number, y: number}, ?): void} callback
 * @return {!Plottable.Interactions.Drag}
 */
Plottable.Interactions.Drag.prototype.onDragEnd = function(callback) {};

/**
 * Removes a callback that would be called when dragging ends.
 * 
 * @param {function({x: number, y: number}, ?): void} callback
 * @return {!Plottable.Interactions.Drag}
 */
Plottable.Interactions.Drag.prototype.offDragEnd = function(callback) {};

/** @typedef {function({topLeft: {x: number, y: number}, bottomRight: ?}): void} */
Plottable.DragBoxCallback;

/**
 * @constructor
 * @struct
 * Constructs a DragBoxLayer.
 * 
 * A DragBoxLayer is a SelectionBoxLayer with a built-in Drag Interaction.
 * A drag gesture will set the Bounds of the box.
 * If resizing is enabled using resizable(true), the edges of box can be repositioned.
 * 
 */
Plottable.Components.DragBoxLayer = function() {};
 /** @type {boolean} */
Plottable.Components.DragBoxLayer.prototype._hasCorners;

/**
 * @return {void}
 */
Plottable.Components.DragBoxLayer.prototype._setup = function() {};

/**
 * @return {!Plottable.Components.DragBoxLayer}
 */
Plottable.Components.DragBoxLayer.prototype.renderImmediately = function() {};

/**
 * Gets the detection radius of the drag box in pixels.
 * Sets the detection radius of the drag box in pixels.
 * 
 * @param {number=} r
 * @return {number|!Plottable.Components.DragBoxLayer}
 */
Plottable.Components.DragBoxLayer.prototype.detectionRadius = function(r) {};

/**
 * Gets whether or not the drag box is resizable.
 * Sets whether or not the drag box is resizable.
 * 
 * @param {boolean=} canResize
 * @return {boolean|!Plottable.Components.DragBoxLayer}
 */
Plottable.Components.DragBoxLayer.prototype.resizable = function(canResize) {};

/**
 * @param {boolean} canResize
 * @return {void}
 */
Plottable.Components.DragBoxLayer.prototype._setResizableClasses = function(canResize) {};

/**
 * Sets the callback to be called when dragging starts.
 * 
 * @param {function({topLeft: {x: number, y: number}, bottomRight: ?}): void} callback
 * @return {!Plottable.Components.DragBoxLayer}
 */
Plottable.Components.DragBoxLayer.prototype.onDragStart = function(callback) {};

/**
 * Removes a callback to be called when dragging starts.
 * 
 * @param {function({topLeft: {x: number, y: number}, bottomRight: ?}): void} callback
 * @return {!Plottable.Components.DragBoxLayer}
 */
Plottable.Components.DragBoxLayer.prototype.offDragStart = function(callback) {};

/**
 * Sets a callback to be called during dragging.
 * 
 * @param {function({topLeft: {x: number, y: number}, bottomRight: ?}): void} callback
 * @return {!Plottable.Components.DragBoxLayer}
 */
Plottable.Components.DragBoxLayer.prototype.onDrag = function(callback) {};

/**
 * Removes a callback to be called during dragging.
 * 
 * @param {function({topLeft: {x: number, y: number}, bottomRight: ?}): void} callback
 * @return {!Plottable.Components.DragBoxLayer}
 */
Plottable.Components.DragBoxLayer.prototype.offDrag = function(callback) {};

/**
 * Sets a callback to be called when dragging ends.
 * 
 * @param {function({topLeft: {x: number, y: number}, bottomRight: ?}): void} callback
 * @return {!Plottable.Components.DragBoxLayer}
 */
Plottable.Components.DragBoxLayer.prototype.onDragEnd = function(callback) {};

/**
 * Removes a callback to be called when dragging ends.
 * 
 * @param {function({topLeft: {x: number, y: number}, bottomRight: ?}): void} callback
 * @return {!Plottable.Components.DragBoxLayer}
 */
Plottable.Components.DragBoxLayer.prototype.offDragEnd = function(callback) {};

/**
 * Gets the internal Interactions.Drag of the DragBoxLayer.
 * @return {!Plottable.Interactions.Drag}
 */
Plottable.Components.DragBoxLayer.prototype.dragInteraction = function() {};

/**
 * Enables or disables the interaction and drag box.
 * Gets the enabled state.
 * @param {boolean=} enabled
 * @return {!Plottable.Components.DragBoxLayer|boolean}
 */
Plottable.Components.DragBoxLayer.prototype.enabled = function(enabled) {};

/**
 * @constructor
 * @struct
 * An XDragBoxLayer is a DragBoxLayer whose size can only be set in the X-direction.
 * The y-values of the bounds() are always set to 0 and the height() of the XDragBoxLayer.
 * 
 */
Plottable.Components.XDragBoxLayer = function() {};

/**
 * @param {{x: number, y: number}=} origin
 * @param {number=} availableWidth
 * @param {number=} availableHeight
 * @return {!Plottable.Components.XDragBoxLayer}
 */
Plottable.Components.XDragBoxLayer.prototype.computeLayout = function(origin, availableWidth, availableHeight) {};

/**
 * @param {{topLeft: {x: number, y: number}, bottomRight: ?}} newBounds
 * @return {void}
 */
Plottable.Components.XDragBoxLayer.prototype._setBounds = function(newBounds) {};

/**
 * @param {boolean} canResize
 * @return {void}
 */
Plottable.Components.XDragBoxLayer.prototype._setResizableClasses = function(canResize) {};

/**
 * @constructor
 * @struct
 * A YDragBoxLayer is a DragBoxLayer whose size can only be set in the Y-direction.
 * The x-values of the bounds() are always set to 0 and the width() of the YDragBoxLayer.
 * 
 */
Plottable.Components.YDragBoxLayer = function() {};

/**
 * @param {{x: number, y: number}=} origin
 * @param {number=} availableWidth
 * @param {number=} availableHeight
 * @return {!Plottable.Components.YDragBoxLayer}
 */
Plottable.Components.YDragBoxLayer.prototype.computeLayout = function(origin, availableWidth, availableHeight) {};

/**
 * @param {{topLeft: {x: number, y: number}, bottomRight: ?}} newBounds
 * @return {void}
 */
Plottable.Components.YDragBoxLayer.prototype._setBounds = function(newBounds) {};

/**
 * @param {boolean} canResize
 * @return {void}
 */
Plottable.Components.YDragBoxLayer.prototype._setResizableClasses = function(canResize) {};
