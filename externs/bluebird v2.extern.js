/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bluebird v2/index.d.ts:
 /** @type {!PromiseConstructor} */
var Promise;
/**
 * @record
 * @struct
 */
function PromiseCancelHandlerSetter() {}

/* TODO: CallSignature:  */

/* TODO: ConstructSignature:  */

/**
 * @param {{warnings: (boolean|{wForgottenReturn: boolean}), longStackTraces: boolean, cancellation: boolean, monitoring: boolean}} options
 * @return {void}
 */
PromiseConstructor.prototype.config = function(options) {};

/**
 * @return {!RangeError}
 */
PromiseConstructor.prototype.RangeError = function() {};

/**
 * @return {!Promise.CancellationError}
 */
PromiseConstructor.prototype.CancellationError = function() {};

/**
 * @return {!Promise.TimeoutError}
 */
PromiseConstructor.prototype.TimeoutError = function() {};

/**
 * @return {!Promise.TypeError}
 */
PromiseConstructor.prototype.TypeError = function() {};

/**
 * @return {!Promise.RejectionError}
 */
PromiseConstructor.prototype.RejectionError = function() {};

/**
 * @return {!Promise.OperationalError}
 */
PromiseConstructor.prototype.OperationalError = function() {};

/**
 * Changes how bluebird schedules calls a-synchronously.
 * 
 * @param {function(function(!Array<?>): void): void} scheduler Should be a function that asynchronously schedules
 *                  the calling of the passed in function
 * @return {void}
 */
PromiseConstructor.prototype.setScheduler = function(scheduler) {};

/**
 * Start the chain of promises with `Promise.try`. Any synchronous exceptions will be turned into rejections on the returned promise.
 * 
 * Note about second argument: if it's specifically a true array, its values become respective arguments for the function call. Otherwise it is passed as is as the first argument for the function call.
 * 
 * Alias for `attempt();` for compatibility with earlier ECMAScript version.
 * @template T
 * @param {function(): (T|!PromiseLike<T>)} fn
 * @param {!Array<?>=} args
 * @param {?=} ctx
 * @return {!Promise<T>}
 */
PromiseConstructor.prototype.try = function(fn, args, ctx) {};

/**
 * @template T
 * @param {function(): (T|!PromiseLike<T>)} fn
 * @param {!Array<?>=} args
 * @param {?=} ctx
 * @return {!Promise<T>}
 */
PromiseConstructor.prototype.attempt = function(fn, args, ctx) {};

/**
 * Returns a new function that wraps the given function `fn`. The new function will always return a promise that is fulfilled with the original functions return values or rejected with thrown exceptions from the original function.
 * This method is convenient when a function can sometimes return synchronously or throw synchronously.
 * @param {!Function} fn
 * @return {!Function}
 */
PromiseConstructor.prototype.method = function(fn) {};

/**
 * Create a promise that is resolved with the given `value`. If `value` is a thenable or promise, the returned promise will assume its state.
 * @template T
 * @param {(T|!PromiseLike<T>)=} value
 * @return {!Promise<T>|!Promise<void>}
 */
PromiseConstructor.prototype.resolve = function(value) {};

/**
 * Create a promise that is rejected with the given `reason`.
 * @template T
 * @param {?} reason
 * @return {!Promise<?>|!Promise<T>}
 */
PromiseConstructor.prototype.reject = function(reason) {};

/**
 * Create a promise with undecided fate and return a `PromiseResolver` to control it. See resolution?: Promise(#promise-resolution).
 * @template T
 * @return {!Promise.Resolver<T>}
 */
PromiseConstructor.prototype.defer = function() {};

/**
 * Cast the given `value` to a trusted promise. If `value` is already a trusted `Promise`, it is returned as is. If `value` is not a thenable, a fulfilled is: Promise returned with `value` as its fulfillment value. If `value` is a thenable (Promise-like object, like those returned by jQuery's `$.ajax`), returns a trusted that: Promise assimilates the state of the thenable.
 * @template T
 * @param {(T|!PromiseLike<T>)} value
 * @return {!Promise<T>}
 */
PromiseConstructor.prototype.cast = function(value) {};

/**
 * Sugar for `Promise.resolve(undefined).bind(thisArg);`. See `.bind()`.
 * @param {?} thisArg
 * @return {!Promise<void>}
 */
PromiseConstructor.prototype.bind = function(thisArg) {};

/**
 * See if `value` is a trusted Promise.
 * @param {?} value
 * @return {boolean}
 */
PromiseConstructor.prototype.is = function(value) {};

/**
 * Call this right after the library is loaded to enabled long stack traces. Long stack traces cannot be disabled after being enabled, and cannot be enabled after promises have alread been created. Long stack traces imply a substantial performance penalty, around 4-5x for throughput and 0.5x for latency.
 * @return {void}
 */
PromiseConstructor.prototype.longStackTraces = function() {};

/**
 * @template T
 * @param {number} ms
 * @param {(T|!PromiseLike<T>)=} value
 * @return {!Promise<T>|!Promise<void>}
 */
PromiseConstructor.prototype.delay = function(ms, value) {};

/**
 * Returns a function that will wrap the given `nodeFunction`. Instead of taking a callback, the returned function will return a promise whose fate is decided by the callback behavior of the given node function. The node function should conform to node.js convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument.
 * 
 * If the `nodeFunction` calls its callback with multiple success values, the fulfillment value will be an array of them.
 * 
 * If you pass a `receiver`, the `nodeFunction` will be called as a method on the `receiver`.
 * @template T, A1, A2, A3, A4, A5
 * @param {function(function(?, T): void): void|function(A1, function(?, T): void): void|function(A1, A2, function(?, T): void): void|function(A1, A2, A3, function(?, T): void): void|function(A1, A2, A3, A4, function(?, T): void): void|function(A1, A2, A3, A4, A5, function(?, T): void): void|!Function} func_or_nodeFunction
 * @param {?=} receiver
 * @return {function(): !Promise<T>|function(A1): !Promise<T>|function(A1, A2): !Promise<T>|function(A1, A2, A3): !Promise<T>|function(A1, A2, A3, A4): !Promise<T>|function(A1, A2, A3, A4, A5): !Promise<T>|!Function}
 */
PromiseConstructor.prototype.promisify = function(func_or_nodeFunction, receiver) {};

/**
 * @param {!Object} target
 * @param {!Promise.PromisifyAllOptions=} options
 * @return {?}
 */
PromiseConstructor.prototype.promisifyAll = function(target, options) {};

/**
 * Returns a promise that is resolved by a node style callback function.
 * @param {function(function(?, ?): void): void} resolver
 * @param {{multiArgs: boolean}=} options
 * @return {!Promise<?>}
 */
PromiseConstructor.prototype.fromNode = function(resolver, options) {};

/**
 * @param {function(function(?, ?): void): void} resolver
 * @param {{multiArgs: boolean}=} options
 * @return {!Promise<?>}
 */
PromiseConstructor.prototype.fromCallback = function(resolver, options) {};

/**
 * @template T
 * @param {!Function} generatorFunction
 * @return {!Function}
 */
PromiseConstructor.prototype.coroutine = function(generatorFunction) {};

/**
 * @template T
 * @param {!Function} generatorFunction
 * @return {!Promise<T>}
 */
PromiseConstructor.prototype.spawn = function(generatorFunction) {};

/**
 * This is relevant to browser environments with no module loader.
 * 
 * Release control of the `Promise` namespace to whatever it was before this library was loaded. Returns a reference to the library namespace so you can attach it to something else.
 * @return {!PromiseConstructor}
 */
PromiseConstructor.prototype.noConflict = function() {};

/**
 * Add `handler` as the handler to call when there is a possibly unhandled rejection. The default handler logs the error stack to stderr or `console.error` in browsers.
 * 
 * Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.
 * @param {function(?): ?} handler
 * @return {void}
 */
PromiseConstructor.prototype.onPossiblyUnhandledRejection = function(handler) {};

/**
 * @template T, T1, T2, T3, T4, T5
 * @param {!PromiseLike<!Array<!PromiseLike<T>>>|!PromiseLike<!Array<T>>|!Array<!PromiseLike<T>>|!Array<?>|!Array<T>} values
 * @return {!Promise<!Array<T>>|!Promise<!Array<?>>}
 */
PromiseConstructor.prototype.all = function(values) {};

/**
 * @param {!Promise<!Object>|!Object} object
 * @return {!Promise<!Object>}
 */
PromiseConstructor.prototype.props = function(object) {};

/**
 * @template T
 * @param {!PromiseLike<!Array<!PromiseLike<T>>>|!PromiseLike<!Array<T>>|!Array<!PromiseLike<T>>|!Array<T>} values
 * @return {!Promise<!Array<!Promise.Inspection<T>>>}
 */
PromiseConstructor.prototype.settle = function(values) {};

/**
 * @template T
 * @param {!PromiseLike<!Array<!PromiseLike<T>>>|!PromiseLike<!Array<T>>|!Array<!PromiseLike<T>>|!Array<T>} values
 * @return {!Promise<T>}
 */
PromiseConstructor.prototype.any = function(values) {};

/**
 * @template T
 * @param {!PromiseLike<!Array<!PromiseLike<T>>>|!PromiseLike<!Array<T>>|!Array<!PromiseLike<T>>|!Array<T>} values
 * @return {!Promise<T>}
 */
PromiseConstructor.prototype.race = function(values) {};

/**
 * @template T
 * @param {!PromiseLike<!Array<!PromiseLike<T>>>|!PromiseLike<!Array<T>>|!Array<!PromiseLike<T>>|!Array<T>} values
 * @param {number} count
 * @return {!Promise<!Array<T>>}
 */
PromiseConstructor.prototype.some = function(values, count) {};

/**
 * @template T
 * @param {...!PromiseLike<T>|T} values
 * @return {!Promise<!Array<T>>}
 */
PromiseConstructor.prototype.join = function(values) {};

/**
 * @template T, U
 * @param {!PromiseLike<!Array<!PromiseLike<T>>>|!PromiseLike<!Array<T>>|!Array<!PromiseLike<T>>|!Array<T>} values
 * @param {function(T, number, number): (U|!PromiseLike<U>)} mapper
 * @param {!Promise.ConcurrencyOption=} options
 * @return {!Promise<!Array<U>>}
 */
PromiseConstructor.prototype.map = function(values, mapper, options) {};

/**
 * @template R, U
 * @param {!PromiseLike<!Array<!PromiseLike<R>>>|!PromiseLike<!Array<R>>|!Array<!PromiseLike<R>>|!Array<R>} values
 * @param {function(R, number, number): (U|!PromiseLike<U>)} mapper
 * @return {!Promise<!Array<U>>}
 */
PromiseConstructor.prototype.mapSeries = function(values, mapper) {};

/**
 * @template T, U
 * @param {!PromiseLike<!Array<!PromiseLike<T>>>|!PromiseLike<!Array<T>>|!Array<!PromiseLike<T>>|!Array<T>} values
 * @param {function(U, T, number, number): (U|!PromiseLike<U>)} reducer
 * @param {U=} initialValue
 * @return {!Promise<U>}
 */
PromiseConstructor.prototype.reduce = function(values, reducer, initialValue) {};

/**
 * @template T
 * @param {!PromiseLike<!Array<!PromiseLike<T>>>|!PromiseLike<!Array<T>>|!Array<!PromiseLike<T>>|!Array<T>} values
 * @param {function(T, number, number): (boolean|!PromiseLike<boolean>)} filterer
 * @param {!Promise.ConcurrencyOption=} option
 * @return {!Promise<!Array<T>>}
 */
PromiseConstructor.prototype.filter = function(values, filterer, option) {};

/**
 * @template T, U
 * @param {!PromiseLike<!Array<!PromiseLike<T>>>|!Array<!PromiseLike<T>>|(!Array<T>|!PromiseLike<!Array<T>>)} values
 * @param {function(T, number, number): (U|!PromiseLike<U>)} iterator
 * @return {!Promise<!Array<T>>}
 */
PromiseConstructor.prototype.each = function(values, iterator) {};

/**
 * Promises/A+ `.then()` with progress handler. Returns a new promise chained from this promise. The new promise will be rejected or resolved dedefer on the passed `fulfilledHandler`, `rejectedHandler` and the state of this promise.
 * @template U
 * @param {function(T): (U|!PromiseLike<U>)} onFulfill
 * @param {function(?): (U|!PromiseLike<U>)|function(?): (void|!PromiseLike<void>)=} onReject
 * @param {function(?): ?=} onProgress
 * @return {!Promise<U>}
 */
Promise.prototype.then = function(onFulfill, onReject, onProgress) {};

/**
 * This is a catch-all exception handler, shortcut for calling `.then(null, handler)` on this promise. Any exception happening in a `.then`-chain will propagate to nearest `.catch` handler.
 * 
 * Alias `.caught();` for compatibility with earlier ECMAScript version.
 * This extends `.catch` to work more like catch-clauses in languages like Java or C#. Instead of manually checking `instanceof` or `.name === "SomeError"`, you may specify a number of error constructors which are eligible for this catch handler. The catch handler that is first met that has eligible constructors specified, is the one that will be called.
 * 
 * This method also supports predicate-based filters. If you pass a predicate function instead of an error constructor, the predicate will receive the error as an argument. The return result of the predicate will be used determine whether the error handler should be called.
 * 
 * Alias `.caught();` for compatibility with earlier ECMAScript version.
 * @template U
 * @param {function(?): (void|T|!PromiseLike<void>|!PromiseLike<T>)|function(?): (U|!PromiseLike<U>)|function(?): boolean|!Function=} onReject_or_predicate_or_ErrorClass
 * @param {function(?): (void|T|!PromiseLike<void>|!PromiseLike<T>)|function(?): (U|!PromiseLike<U>)=} onReject
 * @return {!Promise|!Promise<(T|U)>}
 */
Promise.prototype.catch = function(onReject_or_predicate_or_ErrorClass, onReject) {};

/**
 * @template U
 * @param {function(?): (void|T|!PromiseLike<void>|!PromiseLike<T>)|function(?): (U|!PromiseLike<U>)|function(?): boolean|!Function=} onReject_or_predicate_or_ErrorClass
 * @param {function(?): (void|T|!PromiseLike<void>|!PromiseLike<T>)|function(?): (U|!PromiseLike<U>)=} onReject
 * @return {!Promise|!Promise<(T|U)>}
 */
Promise.prototype.caught = function(onReject_or_predicate_or_ErrorClass, onReject) {};

/**
 * Like `.catch` but instead of catching all types of exceptions, it only catches those that don't originate from thrown errors but rather from explicit rejections.
 * @template U
 * @param {function(?): !PromiseLike<U>|function(?): U} onReject
 * @return {!Promise<U>}
 */
Promise.prototype.error = function(onReject) {};

/**
 * Pass a handler that will be called regardless of this promise's fate. Returns a new promise chained from this promise. There are special semantics for `.finally()` in that the final value cannot be modified from the handler.
 * 
 * Alias `.lastly();` for compatibility with earlier ECMAScript version.
 * @template U
 * @param {function(): (U|!PromiseLike<U>)} handler
 * @return {!Promise}
 */
Promise.prototype.finally = function(handler) {};

/**
 * @template U
 * @param {function(): (U|!PromiseLike<U>)} handler
 * @return {!Promise}
 */
Promise.prototype.lastly = function(handler) {};

/**
 * Create a promise that follows this promise, but is bound to the given `thisArg` value. A bound promise will call its handlers with the bound value set to `this`. Additionally promises derived from a bound promise will also be bound promises with the same `thisArg` binding as the original promise.
 * @param {?} thisArg
 * @return {!Promise}
 */
Promise.prototype.bind = function(thisArg) {};

/**
 * Like `.then()`, but any unhandled rejection that ends up here will be thrown as an error.
 * @template U
 * @param {function(T): !PromiseLike<U>|function(T): U=} onFulfilled
 * @param {function(?): (U|!PromiseLike<U>)=} onRejected
 * @param {function(?): ?=} onProgress
 * @return {void}
 */
Promise.prototype.done = function(onFulfilled, onRejected, onProgress) {};

/**
 * Like `.finally()`, but not called for rejections.
 * @template U
 * @param {function(T): (U|!PromiseLike<U>)} onFulFill
 * @return {!Promise}
 */
Promise.prototype.tap = function(onFulFill) {};

/**
 * Shorthand for `.then(null, null, handler);`. Attach a progress handler that will be called if this promise is progressed. Returns a new promise chained from this promise.
 * @param {function(?): ?} handler
 * @return {!Promise}
 */
Promise.prototype.progressed = function(handler) {};

/**
 * Same as calling `Promise.delay(this, ms)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
 * @param {number} ms
 * @return {!Promise}
 */
Promise.prototype.delay = function(ms) {};

/**
 * Returns a promise that will be fulfilled with this promise's fulfillment value or rejection reason. However, if this promise is not fulfilled or rejected within `ms` milliseconds, the returned promise is rejected with a `Promise.TimeoutError` instance.
 * 
 * You may specify a custom error message with the `message` parameter.
 * @param {number} ms
 * @param {string=} message
 * @return {!Promise}
 */
Promise.prototype.timeout = function(ms, message) {};

/**
 * Register a node-style callback on this promise. When this promise is is either fulfilled or rejected, the node callback will be called back with the node.js convention where error reason is the first argument and success value is the second argument. The error argument will be `null` in case of success.
 * Returns back this promise instead of creating a new one. If the `callback` argument is not a function, this method does not do anything.
 * @param {...function(?, T): void|?} callback_or_sink
 * @return {!Promise}
 */
Promise.prototype.nodeify = function(callback_or_sink) {};

/**
 * Marks this promise as cancellable. Promises by default are not cancellable after v0.11 and must be marked as such for `.cancel()` to have any effect. Marking a promise as cancellable is infectious and you don't need to remark any descendant promise.
 * @return {!Promise}
 */
Promise.prototype.cancellable = function() {};

/**
 * @template U
 * @param {?=} reason
 * @return {!Promise<U>}
 */
Promise.prototype.cancel = function(reason) {};

/**
 * Like `.then()`, but cancellation of the the returned promise or any of its descendant will not propagate cancellation to this promise or this promise's ancestors.
 * @template U
 * @param {function(T): (U|!PromiseLike<U>)=} onFulfilled
 * @param {function(?): (U|!PromiseLike<U>)=} onRejected
 * @param {function(?): ?=} onProgress
 * @return {!Promise<U>}
 */
Promise.prototype.fork = function(onFulfilled, onRejected, onProgress) {};

/**
 * Create an uncancellable promise based on this promise.
 * @return {!Promise}
 */
Promise.prototype.uncancellable = function() {};

/**
 * See if this promise can be cancelled.
 * @return {boolean}
 */
Promise.prototype.isCancellable = function() {};

/**
 * See if this `promise` has been fulfilled.
 * @return {boolean}
 */
Promise.prototype.isFulfilled = function() {};

/**
 * See if this `promise` has been rejected.
 * @return {boolean}
 */
Promise.prototype.isRejected = function() {};

/**
 * See if this `promise` is still defer.
 * @return {boolean}
 */
Promise.prototype.isPending = function() {};

/**
 * See if this `promise` is resolved -> either fulfilled or rejected.
 * @return {boolean}
 */
Promise.prototype.isResolved = function() {};

/**
 * Get the fulfillment value of the underlying promise. Throws if the promise isn't fulfilled yet.
 * 
 * throws `TypeError`
 * @return {T}
 */
Promise.prototype.value = function() {};

/**
 * Get the rejection reason for the underlying promise. Throws if the promise isn't rejected yet.
 * 
 * throws `TypeError`
 * @return {?}
 */
Promise.prototype.reason = function() {};

/**
 * Synchronously inspect the state of this `promise`. The `PromiseInspection` will represent the state of the promise as snapshotted at the time of calling `.inspect()`.
 * @return {!Promise.Inspection<T>}
 */
Promise.prototype.inspect = function() {};

/**
 * This is a convenience method for doing:
 * 
 * <code>
 * promise.then(function(obj){
 *     return obj[propertyName].call(obj, arg...);
 * });
 * </code>
 * @param {string} propertyName
 * @param {...?} args
 * @return {!Promise<?>}
 */
Promise.prototype.call = function(propertyName, args) {};

/**
 * Convenience method for:
 * 
 * <code>
 * .then(function() {
 *    return value;
 * });
 * </code>
 * 
 * in the case where `value` doesn't change its value. That means `value` is bound at the time of calling `.return()`
 * 
 * Alias `.thenReturn();` for compatibility with earlier ECMAScript version.
 * @template U
 * @param {U=} value
 * @return {!Promise<?>|!Promise<U>}
 */
Promise.prototype.return = function(value) {};

/**
 * @template U
 * @param {U=} value
 * @return {!Promise<?>|!Promise<U>}
 */
Promise.prototype.thenReturn = function(value) {};

/**
 * Convenience method for:
 * 
 * <code>
 * .then(function() {
 *    throw reason;
 * });
 * </code>
 * Same limitations apply as with `.return()`.
 * 
 * Alias `.thenThrow();` for compatibility with earlier ECMAScript version.
 * @param {!Error} reason
 * @return {!Promise}
 */
Promise.prototype.throw = function(reason) {};

/**
 * @param {!Error} reason
 * @return {!Promise}
 */
Promise.prototype.thenThrow = function(reason) {};

/**
 * Convert to String.
 * @return {string}
 */
Promise.prototype.toString = function() {};

/**
 * This is implicitly called by `JSON.stringify` when serializing the object. Returns a serialized representation of the `Promise`.
 * @return {!Object}
 */
Promise.prototype.toJSON = function() {};

/**
 * @template U
 * @param {!Function} onFulfill
 * @param {function(?): (U|!PromiseLike<U>)=} onReject
 * @return {!Promise<U>}
 */
Promise.prototype.spread = function(onFulfill, onReject) {};

/**
 * @template U
 * @return {!Promise<!Array<U>>}
 */
Promise.prototype.all = function() {};

/**
 * @return {!Promise<!Object>}
 */
Promise.prototype.props = function() {};

/**
 * @template U
 * @return {!Promise<!Array<!Promise.Inspection<U>>>}
 */
Promise.prototype.settle = function() {};

/**
 * @template U
 * @return {!Promise<U>}
 */
Promise.prototype.any = function() {};

/**
 * @template U
 * @param {number} count
 * @return {!Promise<!Array<U>>}
 */
Promise.prototype.some = function(count) {};

/**
 * @template U
 * @return {!Promise<U>}
 */
Promise.prototype.race = function() {};

/**
 * @template Q, U
 * @param {function(Q, number, number): (U|!PromiseLike<U>)} mapper
 * @param {!Promise.ConcurrencyOption=} options
 * @return {!Promise<!Array<U>>}
 */
Promise.prototype.map = function(mapper, options) {};

/**
 * @template Q, U
 * @param {function(Q, number, number): (U|!PromiseLike<U>)} mapper
 * @return {!Promise<!Array<U>>}
 */
Promise.prototype.mapSeries = function(mapper) {};

/**
 * @template Q, U
 * @param {function(U, Q, number, number): (U|!PromiseLike<U>)} reducer
 * @param {U=} initialValue
 * @return {!Promise<U>}
 */
Promise.prototype.reduce = function(reducer, initialValue) {};

/**
 * @template U
 * @param {function(U, number, number): (boolean|!PromiseLike<boolean>)} filterer
 * @param {!Promise.ConcurrencyOption=} options
 * @return {!Promise<!Array<U>>}
 */
Promise.prototype.filter = function(filterer, options) {};

/**
 * Same as calling ``Promise.each(thisPromise, iterator)``. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
 * @template T, U
 * @param {function(T, number, number): (U|!PromiseLike<U>)} iterator
 * @return {!Promise<!Array<T>>}
 */
Promise.prototype.each = function(iterator) {};
/**
 * @record
 * @struct
 */
Promise.RangeError = function() {};
/**
 * @record
 * @struct
 */
Promise.CancellationError = function() {};
/**
 * @record
 * @struct
 */
Promise.TimeoutError = function() {};
/**
 * @record
 * @struct
 */
Promise.TypeError = function() {};
/**
 * @record
 * @struct
 */
Promise.RejectionError = function() {};
/**
 * @record
 * @struct
 */
Promise.OperationalError = function() {};
/**
 * @record
 * @struct
 */
Promise.ConcurrencyOption = function() {};
 /** @type {number} */
Promise.ConcurrencyOption.prototype.concurrency;
/**
 * @record
 * @struct
 */
Promise.SpreadOption = function() {};
 /** @type {boolean} */
Promise.SpreadOption.prototype.spread;
/**
 * @record
 * @struct
 */
Promise.PromisifyAllOptions = function() {};
 /** @type {string} */
Promise.PromisifyAllOptions.prototype.suffix;
 /** @type {function(string, !Function, ?, boolean): boolean} */
Promise.PromisifyAllOptions.prototype.filter;
 /** @type {function(!Function): function(): !PromiseLike<?>} */
Promise.PromisifyAllOptions.prototype.promisifier;
/**
 * @record
 * @struct
 */
Promise.Resolver = function() {};
 /** @type {!Promise<T>} */
Promise.Resolver.prototype.promise;
 /** @type {function(?, T, !Array<T>): void} */
Promise.Resolver.prototype.callback;

/**
 * Resolve the underlying promise with `value` as the resolution value. If `value` is a thenable or a promise, the underlying promise will assume its state.
 * @param {T=} value
 * @return {void}
 */
Promise.Resolver.prototype.resolve = function(value) {};

/**
 * Reject the underlying promise with `reason` as the rejection reason.
 * @param {?} reason
 * @return {void}
 */
Promise.Resolver.prototype.reject = function(reason) {};

/**
 * Progress the underlying promise with `value` as the progression value.
 * @param {?} value
 * @return {void}
 */
Promise.Resolver.prototype.progress = function(value) {};
/**
 * @record
 * @struct
 */
Promise.Inspection = function() {};

/**
 * See if the underlying promise was fulfilled at the creation time of this inspection object.
 * @return {boolean}
 */
Promise.Inspection.prototype.isFulfilled = function() {};

/**
 * See if the underlying promise was rejected at the creation time of this inspection object.
 * @return {boolean}
 */
Promise.Inspection.prototype.isRejected = function() {};

/**
 * See if the underlying promise was defer at the creation time of this inspection object.
 * @return {boolean}
 */
Promise.Inspection.prototype.isPending = function() {};

/**
 * Get the fulfillment value of the underlying promise. Throws if the promise wasn't fulfilled at the creation time of this inspection object.
 * 
 * throws `TypeError`
 * @return {T}
 */
Promise.Inspection.prototype.value = function() {};

/**
 * Get the rejection reason for the underlying promise. Throws if the promise wasn't rejected at the creation time of this inspection object.
 * 
 * throws `TypeError`
 * @return {?}
 */
Promise.Inspection.prototype.reason = function() {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "bluebird"
/** @const */
tsickle_declare_module.bluebird = {};

/* TODO: ExportAssignment in tsickle_declare_module.bluebird */
