/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/leaflet/index.d.ts:

/** @typedef {!MouseEvent} */
var NativeMouseEvent;

/** @typedef {!KeyboardEvent} */
var NativeKeyboardEvent;

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */
/** @const */
var L = {};
/**
 * @constructor
 * @struct
 */
L.Class = function() {};

/**
 * @param {?} props
 * @return {?}
 */
L.Class.extend = function(props) {};

/**
 * @param {?} props
 * @return {?}
 */
L.Class.include = function(props) {};

/**
 * @param {?} props
 * @return {?}
 */
L.Class.mergeOptions = function(props) {};

/**
 * @param {function(): void} initHookFn
 * @return {?}
 */
L.Class.addInitHook = function(initHookFn) {};

/**
 * @constructor
 * @struct
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 */
L.Transformation = function(a, b, c, d) {};

/**
 * @param {!L.Point} point
 * @param {number=} scale
 * @return {!L.Point}
 */
L.Transformation.prototype.transform = function(point, scale) {};

/**
 * @param {!L.Point} point
 * @param {number=} scale
 * @return {!L.Point}
 */
L.Transformation.prototype.untransform = function(point, scale) {};
/** @const */
L.LineUtil = {};

/**
 * @param {!Array<!L.Point>} points
 * @param {number} tolerance
 * @return {!Array<!L.Point>}
 */
L.LineUtil.simplify = function(points, tolerance) {};

/**
 * @param {!L.Point} p
 * @param {!L.Point} p1
 * @param {!L.Point} p2
 * @return {number}
 */
L.LineUtil.pointToSegmentDistance = function(p, p1, p2) {};

/**
 * @param {!L.Point} p
 * @param {!L.Point} p1
 * @param {!L.Point} p2
 * @return {!L.Point}
 */
L.LineUtil.closestPointOnSegment = function(p, p1, p2) {};
/** @const */
L.PolyUtil = {};

/**
 * @param {!Array<!L.Point>} points
 * @param {(!L.Bounds|!Array<?>)} bounds
 * @param {boolean=} round
 * @return {!Array<!L.Point>}
 */
L.PolyUtil.clipPolygon = function(points, bounds, round) {};
/** @const */
L.DomUtil = {};

/**
 * Get Element by its ID or with the given HTML-Element
 * @param {(string|!HTMLElement)} element
 * @return {!HTMLElement}
 */
L.DomUtil.get = function(element) {};

/**
 * @param {!HTMLElement} el
 * @param {string} styleAttrib
 * @return {string}
 */
L.DomUtil.getStyle = function(el, styleAttrib) {};

/**
 * @param {string} tagName
 * @param {string=} className
 * @param {!HTMLElement=} container
 * @return {!HTMLElement}
 */
L.DomUtil.create = function(tagName, className, container) {};

/**
 * @param {!HTMLElement} el
 * @return {void}
 */
L.DomUtil.remove = function(el) {};

/**
 * @param {!HTMLElement} el
 * @return {void}
 */
L.DomUtil.empty = function(el) {};

/**
 * @param {!HTMLElement} el
 * @return {void}
 */
L.DomUtil.toFront = function(el) {};

/**
 * @param {!HTMLElement} el
 * @return {void}
 */
L.DomUtil.toBack = function(el) {};

/**
 * @param {!HTMLElement} el
 * @param {string} name
 * @return {boolean}
 */
L.DomUtil.hasClass = function(el, name) {};

/**
 * @param {!HTMLElement} el
 * @param {string} name
 * @return {void}
 */
L.DomUtil.addClass = function(el, name) {};

/**
 * @param {!HTMLElement} el
 * @param {string} name
 * @return {void}
 */
L.DomUtil.removeClass = function(el, name) {};

/**
 * @param {!HTMLElement} el
 * @param {string} name
 * @return {void}
 */
L.DomUtil.setClass = function(el, name) {};

/**
 * @param {!HTMLElement} el
 * @return {string}
 */
L.DomUtil.getClass = function(el) {};

/**
 * @param {!HTMLElement} el
 * @param {number} opacity
 * @return {void}
 */
L.DomUtil.setOpacity = function(el, opacity) {};

/**
 * @param {!Array<string>} props
 * @return {(string|boolean)}
 */
L.DomUtil.testProp = function(props) {};

/**
 * @param {!HTMLElement} el
 * @param {!L.Point} offset
 * @param {number=} scale
 * @return {void}
 */
L.DomUtil.setTransform = function(el, offset, scale) {};

/**
 * @param {!HTMLElement} el
 * @param {!L.Point} position
 * @return {void}
 */
L.DomUtil.setPosition = function(el, position) {};

/**
 * @param {!HTMLElement} el
 * @return {!L.Point}
 */
L.DomUtil.getPosition = function(el) {};

/**
 * @return {void}
 */
L.DomUtil.disableTextSelection = function() {};

/**
 * @return {void}
 */
L.DomUtil.enableTextSelection = function() {};

/**
 * @return {void}
 */
L.DomUtil.disableImageDrag = function() {};

/**
 * @return {void}
 */
L.DomUtil.enableImageDrag = function() {};

/**
 * @param {!HTMLElement} el
 * @return {void}
 */
L.DomUtil.preventOutline = function(el) {};

/**
 * @return {void}
 */
L.DomUtil.restoreOutline = function() {};
 /** @type {string} */
L.DomUtil.TRANSFORM;
 /** @type {string} */
L.DomUtil.TRANSITION;
 /** @type {string} */
L.DomUtil.TRANSITION_END;
/**
 * @record
 * @struct
 */
L.CRS = function() {};
 /** @type {string} */
L.CRS.prototype.code;
 /** @type {!Array<?>} */
L.CRS.prototype.wrapLng;
 /** @type {!Array<?>} */
L.CRS.prototype.wrapLat;
 /** @type {boolean} */
L.CRS.prototype.infinite;

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {number} zoom
 * @return {!L.Point}
 */
L.CRS.prototype.latLngToPoint = function(latlng, zoom) {};

/**
 * @param {(!L.Point|!Array<?>)} point
 * @param {number} zoom
 * @return {!L.LatLng}
 */
L.CRS.prototype.pointToLatLng = function(point, zoom) {};

/**
 * @param {(!L.LatLng|!L.LatLngLiteral)} latlng
 * @return {!L.Point}
 */
L.CRS.prototype.project = function(latlng) {};

/**
 * @param {(!L.Point|!Array<?>)} point
 * @return {!L.LatLng}
 */
L.CRS.prototype.unproject = function(point) {};

/**
 * @param {number} zoom
 * @return {number}
 */
L.CRS.prototype.scale = function(zoom) {};

/**
 * @param {number} scale
 * @return {number}
 */
L.CRS.prototype.zoom = function(scale) {};

/**
 * @param {number} zoom
 * @return {!L.Bounds}
 */
L.CRS.prototype.getProjectedBounds = function(zoom) {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng1
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng2
 * @return {number}
 */
L.CRS.prototype.distance = function(latlng1, latlng2) {};

/**
 * @param {(!L.LatLng|!L.LatLngLiteral)} latlng
 * @return {!L.LatLng}
 */
L.CRS.prototype.wrapLatLng = function(latlng) {};
 /** @type {?} */
L.CRS.EPSG3395;
 /** @type {?} */
L.CRS.EPSG3857;
 /** @type {?} */
L.CRS.EPSG4326;
 /** @type {?} */
L.CRS.Earth;
 /** @type {?} */
L.CRS.Simple;
/**
 * @record
 * @struct
 */
L.Projection = function() {};
 /** @type {!L.Bounds} */
L.Projection.prototype.bounds;

/**
 * @param {(!L.LatLng|!L.LatLngLiteral)} latlng
 * @return {!L.Point}
 */
L.Projection.prototype.project = function(latlng) {};

/**
 * @param {(!L.Point|!Array<?>)} point
 * @return {!L.LatLng}
 */
L.Projection.prototype.unproject = function(point) {};
 /** @type {?} */
L.Projection.LonLat;
 /** @type {?} */
L.Projection.Mercator;
 /** @type {?} */
L.Projection.SphericalMercator;

/**
 * @constructor
 * @struct
 * @param {number} latitude
 * @param {number} longitude
 * @param {number=} altitude
 */
L.LatLng = function(latitude, longitude, altitude) {};
 /** @type {number} */
L.LatLng.prototype.lat;
 /** @type {number} */
L.LatLng.prototype.lng;
 /** @type {number} */
L.LatLng.prototype.alt;

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} otherLatLng
 * @param {number=} maxMargin
 * @return {boolean}
 */
L.LatLng.prototype.equals = function(otherLatLng, maxMargin) {};

/**
 * @return {string}
 */
L.LatLng.prototype.toString = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} otherLatLng
 * @return {number}
 */
L.LatLng.prototype.distanceTo = function(otherLatLng) {};

/**
 * @return {!L.LatLng}
 */
L.LatLng.prototype.wrap = function() {};

/**
 * @param {number} sizeInMeters
 * @return {!L.LatLngBounds}
 */
L.LatLng.prototype.toBounds = function(sizeInMeters) {};
/**
 * @record
 * @struct
 */
L.LatLngLiteral = function() {};
 /** @type {number} */
L.LatLngLiteral.prototype.lat;
 /** @type {number} */
L.LatLngLiteral.prototype.lng;

/** @typedef {!Array<?>} */
L.LatLngTuple;

/** @typedef {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} */
L.LatLngExpression;

/**
 * @param {number|(!Array<?>|!L.LatLngLiteral|{lat: number, lng: number, alt: number})} latitude_or_coords
 * @param {number=} longitude
 * @param {number=} altitude
 * @return {!L.LatLng}
 */
L.latLng = function(latitude_or_coords, longitude, altitude) {};

/**
 * @constructor
 * @struct
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)|!Array<!Array<?>>} southWest_or_latlngs
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)=} northEast
 */
L.LatLngBounds = function(southWest_or_latlngs, northEast) {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral|!L.LatLngBounds|!Array<!Array<?>>)} latlngOrBounds
 * @return {LatLngBounds}
 */
L.LatLngBounds.prototype.extend = function(latlngOrBounds) {};

/**
 * @param {number} bufferRatio
 * @return {!L.LatLngBounds}
 */
L.LatLngBounds.prototype.pad = function(bufferRatio) {};

/**
 * @return {!L.LatLng}
 */
L.LatLngBounds.prototype.getCenter = function() {};

/**
 * @return {!L.LatLng}
 */
L.LatLngBounds.prototype.getSouthWest = function() {};

/**
 * @return {!L.LatLng}
 */
L.LatLngBounds.prototype.getNorthEast = function() {};

/**
 * @return {!L.LatLng}
 */
L.LatLngBounds.prototype.getNorthWest = function() {};

/**
 * @return {!L.LatLng}
 */
L.LatLngBounds.prototype.getSouthEast = function() {};

/**
 * @return {number}
 */
L.LatLngBounds.prototype.getWest = function() {};

/**
 * @return {number}
 */
L.LatLngBounds.prototype.getSouth = function() {};

/**
 * @return {number}
 */
L.LatLngBounds.prototype.getEast = function() {};

/**
 * @return {number}
 */
L.LatLngBounds.prototype.getNorth = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral|!L.LatLngBounds|!Array<!Array<?>>)} otherBoundsOrLatLng
 * @return {boolean}
 */
L.LatLngBounds.prototype.contains = function(otherBoundsOrLatLng) {};

/**
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} otherBounds
 * @return {boolean}
 */
L.LatLngBounds.prototype.intersects = function(otherBounds) {};

/**
 * @param {(!L.Bounds|!Array<?>)} otherBounds
 * @return {boolean}
 */
L.LatLngBounds.prototype.overlaps = function(otherBounds) {};

/**
 * @return {string}
 */
L.LatLngBounds.prototype.toBBoxString = function() {};

/**
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} otherBounds
 * @return {boolean}
 */
L.LatLngBounds.prototype.equals = function(otherBounds) {};

/**
 * @return {boolean}
 */
L.LatLngBounds.prototype.isValid = function() {};

/** @typedef {!Array<!Array<?>>} */
L.LatLngBoundsLiteral;

/** @typedef {(!L.LatLngBounds|!Array<!Array<?>>)} */
L.LatLngBoundsExpression;

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)|!Array<(!Array<?>|!L.LatLng|!L.LatLngLiteral)>} southWest_or_latlngs
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)=} northEast
 * @return {!L.LatLngBounds}
 */
L.latLngBounds = function(southWest_or_latlngs, northEast) {};

/** @typedef {!Array<?>} */
L.PointTuple;

/**
 * @constructor
 * @struct
 * @param {number} x
 * @param {number} y
 * @param {boolean=} round
 */
L.Point = function(x, y, round) {};
 /** @type {number} */
L.Point.prototype.x;
 /** @type {number} */
L.Point.prototype.y;

/**
 * @return {!L.Point}
 */
L.Point.prototype.clone = function() {};

/**
 * @param {(!L.Point|!Array<?>)} otherPoint
 * @return {!L.Point}
 */
L.Point.prototype.add = function(otherPoint) {};

/**
 * @param {(!L.Point|!Array<?>)} otherPoint
 * @return {!L.Point}
 */
L.Point.prototype.subtract = function(otherPoint) {};

/**
 * @param {number} num
 * @return {!L.Point}
 */
L.Point.prototype.divideBy = function(num) {};

/**
 * @param {number} num
 * @return {!L.Point}
 */
L.Point.prototype.multiplyBy = function(num) {};

/**
 * @param {(!L.Point|!Array<?>)} scale
 * @return {!L.Point}
 */
L.Point.prototype.scaleBy = function(scale) {};

/**
 * @param {(!L.Point|!Array<?>)} scale
 * @return {!L.Point}
 */
L.Point.prototype.unscaleBy = function(scale) {};

/**
 * @return {!L.Point}
 */
L.Point.prototype.round = function() {};

/**
 * @return {!L.Point}
 */
L.Point.prototype.floor = function() {};

/**
 * @return {!L.Point}
 */
L.Point.prototype.ceil = function() {};

/**
 * @param {(!L.Point|!Array<?>)} otherPoint
 * @return {number}
 */
L.Point.prototype.distanceTo = function(otherPoint) {};

/**
 * @param {(!L.Point|!Array<?>)} otherPoint
 * @return {boolean}
 */
L.Point.prototype.equals = function(otherPoint) {};

/**
 * @param {(!L.Point|!Array<?>)} otherPoint
 * @return {boolean}
 */
L.Point.prototype.contains = function(otherPoint) {};

/**
 * @return {string}
 */
L.Point.prototype.toString = function() {};

/** @typedef {(!L.Point|!Array<?>)} */
L.PointExpression;

/**
 * @param {number|(!Array<?>|{x: number, y: number})} x_or_coords
 * @param {number=} y
 * @param {boolean=} round
 * @return {!L.Point}
 */
L.point = function(x_or_coords, y, round) {};

/** @typedef {!Array<?>} */
L.BoundsLiteral;

/**
 * @constructor
 * @struct
 * @param {(!L.Point|!Array<?>)|(!Array<!L.Point>|!Array<?>)} topLeft_or_points
 * @param {(!L.Point|!Array<?>)=} bottomRight
 */
L.Bounds = function(topLeft_or_points, bottomRight) {};
 /** @type {!L.Point} */
L.Bounds.prototype.min;
 /** @type {!L.Point} */
L.Bounds.prototype.max;

/**
 * @param {(!L.Point|!Array<?>)} point
 * @return {Bounds}
 */
L.Bounds.prototype.extend = function(point) {};

/**
 * @param {boolean=} round
 * @return {!L.Point}
 */
L.Bounds.prototype.getCenter = function(round) {};

/**
 * @return {!L.Point}
 */
L.Bounds.prototype.getBottomLeft = function() {};

/**
 * @return {!L.Point}
 */
L.Bounds.prototype.getTopRight = function() {};

/**
 * @return {!L.Point}
 */
L.Bounds.prototype.getSize = function() {};

/**
 * @param {(!L.Point|!L.Bounds|!Array<?>)} pointOrBounds
 * @return {boolean}
 */
L.Bounds.prototype.contains = function(pointOrBounds) {};

/**
 * @param {(!L.Bounds|!Array<?>)} otherBounds
 * @return {boolean}
 */
L.Bounds.prototype.intersects = function(otherBounds) {};

/**
 * @param {(!L.Bounds|!Array<?>)} otherBounds
 * @return {boolean}
 */
L.Bounds.prototype.overlaps = function(otherBounds) {};

/** @typedef {(!L.Bounds|!Array<?>)} */
L.BoundsExpression;

/**
 * @param {(!L.Point|!Array<?>)|(!Array<!L.Point>|!Array<?>)} topLeft_or_points
 * @param {(!L.Point|!Array<?>)=} bottomRight
 * @return {!L.Bounds}
 */
L.bounds = function(topLeft_or_points, bottomRight) {};

/** @typedef {function(!L.Event): void} */
L.EventHandlerFn;
/**
 * @record
 * @struct
 */
L.EventHandlerFnMap = function() {};

/* TODO: IndexSignature: L */
/**
 * @extends {L.Class}
 * @constructor
 * @struct
 */
L.Evented = function() {};

/**
 * Adds a listener function (fn) to a particular event type of the object.
 * You can optionally specify the context of the listener (object the this
 * keyword will point to). You can also pass several space-separated types
 * (e.g. 'click dblclick').
 * Adds a set of type/listener pairs, e.g. {click: onClick, mousemove: onMouseMove}
 * @param {string|!L.EventHandlerFnMap} type_or_eventMap
 * @param {function(!L.Event): void=} fn
 * @param {?=} context
 * @return {Evented}
 */
L.Evented.prototype.on = function(type_or_eventMap, fn, context) {};

/**
 * Removes a previously added listener function. If no function is specified,
 * it will remove all the listeners of that particular event from the object.
 * Note that if you passed a custom context to on, you must pass the same context
 * to off in order to remove the listener.
 * Removes a set of type/listener pairs.
 * Removes all listeners to all events on the object.
 * @param {string|!L.EventHandlerFnMap=} type_or_eventMap
 * @param {function(!L.Event): void=} fn
 * @param {?=} context
 * @return {Evented}
 */
L.Evented.prototype.off = function(type_or_eventMap, fn, context) {};

/**
 * Fires an event of the specified type. You can optionally provide a data
 * object — the first argument of the listener function will contain its properties.
 * The event might can optionally be propagated to event parents.
 * @param {string} type
 * @param {?=} data
 * @param {boolean=} propagate
 * @return {Evented}
 */
L.Evented.prototype.fire = function(type, data, propagate) {};

/**
 * Returns true if a particular event type has any listeners attached to it.
 * @param {string} type
 * @return {boolean}
 */
L.Evented.prototype.listens = function(type) {};

/**
 * Behaves as on(...), except the listener will only get fired once and then removed.
 * Behaves as on(...), except the listener will only get fired once and then removed.
 * @param {string|!L.EventHandlerFnMap} type_or_eventMap
 * @param {function(!L.Event): void=} fn
 * @param {?=} context
 * @return {Evented}
 */
L.Evented.prototype.once = function(type_or_eventMap, fn, context) {};

/**
 * Adds an event parent - an Evented that will receive propagated events
 * @param {!L.Evented} obj
 * @return {Evented}
 */
L.Evented.prototype.addEventParent = function(obj) {};

/**
 * Removes an event parent, so it will stop receiving propagated events
 * @param {!L.Evented} obj
 * @return {Evented}
 */
L.Evented.prototype.removeEventParent = function(obj) {};

/**
 * Alias for on(...)
 * 
 * Adds a listener function (fn) to a particular event type of the object.
 * You can optionally specify the context of the listener (object the this
 * keyword will point to). You can also pass several space-separated types
 * (e.g. 'click dblclick').
 * Alias for on(...)
 * 
 * Adds a set of type/listener pairs, e.g. {click: onClick, mousemove: onMouseMove}
 * @param {string|!L.EventHandlerFnMap} type_or_eventMap
 * @param {function(!L.Event): void=} fn
 * @param {?=} context
 * @return {Evented}
 */
L.Evented.prototype.addEventListener = function(type_or_eventMap, fn, context) {};

/**
 * Alias for off(...)
 * 
 * Removes a previously added listener function. If no function is specified,
 * it will remove all the listeners of that particular event from the object.
 * Note that if you passed a custom context to on, you must pass the same context
 * to off in order to remove the listener.
 * Alias for off(...)
 * 
 * Removes a set of type/listener pairs.
 * @param {string|!L.EventHandlerFnMap} type_or_eventMap
 * @param {function(!L.Event): void=} fn
 * @param {?=} context
 * @return {Evented}
 */
L.Evented.prototype.removeEventListener = function(type_or_eventMap, fn, context) {};

/**
 * Alias for off()
 * 
 * Removes all listeners to all events on the object.
 * @return {Evented}
 */
L.Evented.prototype.clearAllEventListeners = function() {};

/**
 * Alias for once(...)
 * 
 * Behaves as on(...), except the listener will only get fired once and then removed.
 * Alias for once(...)
 * 
 * Behaves as on(...), except the listener will only get fired once and then removed.
 * @param {string|!L.EventHandlerFnMap} type_or_eventMap
 * @param {function(!L.Event): void=} fn
 * @param {?=} context
 * @return {Evented}
 */
L.Evented.prototype.addOneTimeEventListener = function(type_or_eventMap, fn, context) {};

/**
 * Alias for fire(...)
 * 
 * Fires an event of the specified type. You can optionally provide a data
 * object — the first argument of the listener function will contain its properties.
 * The event might can optionally be propagated to event parents.
 * @param {string} type
 * @param {?=} data
 * @param {boolean=} propagate
 * @return {Evented}
 */
L.Evented.prototype.fireEvent = function(type, data, propagate) {};

/**
 * Alias for listens(...)
 * 
 * Returns true if a particular event type has any listeners attached to it.
 * @param {string} type
 * @return {boolean}
 */
L.Evented.prototype.hasEventListeners = function(type) {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} element
 * @param {!HTMLElement=} dragStartTarget
 * @param {boolean=} preventOutline
 */
L.Draggable = function(element, dragStartTarget, preventOutline) {};

/**
 * @return {void}
 */
L.Draggable.prototype.enable = function() {};

/**
 * @return {void}
 */
L.Draggable.prototype.disable = function() {};

/**
 * @return {void}
 */
L.Draggable.prototype.finishDrag = function() {};
/**
 * @record
 * @struct
 */
L.LayerOptions = function() {};
 /** @type {string} */
L.LayerOptions.prototype.pane;
 /** @type {string} */
L.LayerOptions.prototype.attribution;
/**
 * @extends {L.LayerOptions}
 * @record
 * @struct
 */
L.InteractiveLayerOptions = function() {};
 /** @type {boolean} */
L.InteractiveLayerOptions.prototype.interactive;

/**
 * @constructor
 * @struct
 * @param {!L.LayerOptions=} options
 */
L.Layer = function(options) {};

/**
 * @param {(!L.Map|!L.LayerGroup)} map
 * @return {Layer}
 */
L.Layer.prototype.addTo = function(map) {};

/**
 * @return {Layer}
 */
L.Layer.prototype.remove = function() {};

/**
 * @param {!L.Map} map
 * @return {Layer}
 */
L.Layer.prototype.removeFrom = function(map) {};

/**
 * @param {string=} name
 * @return {!HTMLElement}
 */
L.Layer.prototype.getPane = function(name) {};

/**
 * @param {(string|!HTMLElement|function(!L.Layer): (string|!HTMLElement)|!L.Popup)} content
 * @param {!L.PopupOptions=} options
 * @return {Layer}
 */
L.Layer.prototype.bindPopup = function(content, options) {};

/**
 * @return {Layer}
 */
L.Layer.prototype.unbindPopup = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)=} latlng
 * @return {Layer}
 */
L.Layer.prototype.openPopup = function(latlng) {};

/**
 * @return {Layer}
 */
L.Layer.prototype.closePopup = function() {};

/**
 * @return {Layer}
 */
L.Layer.prototype.togglePopup = function() {};

/**
 * @return {boolean}
 */
L.Layer.prototype.isPopupOpen = function() {};

/**
 * @param {(string|!HTMLElement|!L.Popup)} content
 * @return {Layer}
 */
L.Layer.prototype.setPopupContent = function(content) {};

/**
 * @return {!L.Popup}
 */
L.Layer.prototype.getPopup = function() {};

/**
 * @param {(string|!HTMLElement|function(!L.Layer): (string|!HTMLElement)|!L.Tooltip)} content
 * @param {!L.TooltipOptions=} options
 * @return {Layer}
 */
L.Layer.prototype.bindTooltip = function(content, options) {};

/**
 * @return {Layer}
 */
L.Layer.prototype.unbindTooltip = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)=} latlng
 * @return {Layer}
 */
L.Layer.prototype.openTooltip = function(latlng) {};

/**
 * @return {Layer}
 */
L.Layer.prototype.closeTooltip = function() {};

/**
 * @return {Layer}
 */
L.Layer.prototype.toggleTooltip = function() {};

/**
 * @return {boolean}
 */
L.Layer.prototype.isTooltipOpen = function() {};

/**
 * @param {(string|!HTMLElement|!L.Tooltip)} content
 * @return {Layer}
 */
L.Layer.prototype.setTooltipContent = function(content) {};

/**
 * @return {!L.Tooltip}
 */
L.Layer.prototype.getTooltip = function() {};

/**
 * @param {!L.Map} map
 * @return {Layer}
 */
L.Layer.prototype.onAdd = function(map) {};

/**
 * @param {!L.Map} map
 * @return {Layer}
 */
L.Layer.prototype.onRemove = function(map) {};

/**
 * @return {!Object<string,function(!L.Event): void>}
 */
L.Layer.prototype.getEvents = function() {};

/**
 * @return {string}
 */
L.Layer.prototype.getAttribution = function() {};

/**
 * @param {!L.Map} map
 * @return {Layer}
 */
L.Layer.prototype.beforeAdd = function(map) {};
/**
 * @record
 * @struct
 */
L.GridLayerOptions = function() {};
 /** @type {(number|!L.Point)} */
L.GridLayerOptions.prototype.tileSize;
 /** @type {number} */
L.GridLayerOptions.prototype.opacity;
 /** @type {boolean} */
L.GridLayerOptions.prototype.updateWhenIdle;
 /** @type {boolean} */
L.GridLayerOptions.prototype.updateWhenZooming;
 /** @type {number} */
L.GridLayerOptions.prototype.updateInterval;
 /** @type {string} */
L.GridLayerOptions.prototype.attribution;
 /** @type {number} */
L.GridLayerOptions.prototype.zIndex;
 /** @type {(!L.LatLngBounds|!Array<!Array<?>>)} */
L.GridLayerOptions.prototype.bounds;
 /** @type {number} */
L.GridLayerOptions.prototype.minZoom;
 /** @type {number} */
L.GridLayerOptions.prototype.maxZoom;
 /** @type {boolean} */
L.GridLayerOptions.prototype.noWrap;
 /** @type {string} */
L.GridLayerOptions.prototype.pane;
 /** @type {string} */
L.GridLayerOptions.prototype.className;
 /** @type {number} */
L.GridLayerOptions.prototype.keepBuffer;

/**
 * @constructor
 * @struct
 * @param {!L.GridLayerOptions=} options
 */
L.GridLayer = function(options) {};

/**
 * @return {GridLayer}
 */
L.GridLayer.prototype.bringToFront = function() {};

/**
 * @return {GridLayer}
 */
L.GridLayer.prototype.bringToBack = function() {};

/**
 * @return {!HTMLElement}
 */
L.GridLayer.prototype.getContainer = function() {};

/**
 * @param {number} opacity
 * @return {GridLayer}
 */
L.GridLayer.prototype.setOpacity = function(opacity) {};

/**
 * @param {number} zIndex
 * @return {GridLayer}
 */
L.GridLayer.prototype.setZIndex = function(zIndex) {};

/**
 * @return {boolean}
 */
L.GridLayer.prototype.isLoading = function() {};

/**
 * @return {GridLayer}
 */
L.GridLayer.prototype.redraw = function() {};

/**
 * @return {!L.Point}
 */
L.GridLayer.prototype.getTileSize = function() {};

/**
 * @param {!L.GridLayerOptions=} options
 * @return {!L.GridLayer}
 */
L.gridLayer = function(options) {};
/**
 * @extends {L.GridLayerOptions}
 * @record
 * @struct
 */
L.TileLayerOptions = function() {};
 /** @type {number} */
L.TileLayerOptions.prototype.minZoom;
 /** @type {number} */
L.TileLayerOptions.prototype.maxZoom;
 /** @type {number} */
L.TileLayerOptions.prototype.maxNativeZoom;
 /** @type {number} */
L.TileLayerOptions.prototype.minNativeZoom;
 /** @type {(string|!Array<string>)} */
L.TileLayerOptions.prototype.subdomains;
 /** @type {string} */
L.TileLayerOptions.prototype.errorTileUrl;
 /** @type {number} */
L.TileLayerOptions.prototype.zoomOffset;
 /** @type {boolean} */
L.TileLayerOptions.prototype.tms;
 /** @type {boolean} */
L.TileLayerOptions.prototype.zoomReverse;
 /** @type {boolean} */
L.TileLayerOptions.prototype.detectRetina;
 /** @type {boolean} */
L.TileLayerOptions.prototype.crossOrigin;

/* TODO: IndexSignature: L */

/**
 * @constructor
 * @struct
 * @param {string} urlTemplate
 * @param {!L.TileLayerOptions=} options
 */
L.TileLayer = function(urlTemplate, options) {};
 /** @type {!L.TileLayerOptions} */
L.TileLayer.prototype.options;

/**
 * @param {string} url
 * @param {boolean=} noRedraw
 * @return {TileLayer}
 */
L.TileLayer.prototype.setUrl = function(url, noRedraw) {};

/**
 * @param {string} urlTemplate
 * @param {!L.TileLayerOptions=} options
 * @return {!L.TileLayer}
 */
L.tileLayer = function(urlTemplate, options) {};

/**
 * @constructor
 * @struct
 * @param {string} baseUrl
 * @param {!L.WMSOptions} options
 */
L.TileLayer.WMS = function(baseUrl, options) {};
 /** @type {!L.WMSParams} */
L.TileLayer.WMS.prototype.wmsParams;
 /** @type {!L.WMSOptions} */
L.TileLayer.WMS.prototype.options;

/**
 * @param {!L.WMSParams} params
 * @param {boolean=} noRedraw
 * @return {WMS}
 */
L.TileLayer.WMS.prototype.setParams = function(params, noRedraw) {};
/**
 * @extends {L.TileLayerOptions}
 * @record
 * @struct
 */
L.WMSOptions = function() {};
 /** @type {string} */
L.WMSOptions.prototype.layers;
 /** @type {string} */
L.WMSOptions.prototype.styles;
 /** @type {string} */
L.WMSOptions.prototype.format;
 /** @type {boolean} */
L.WMSOptions.prototype.transparent;
 /** @type {string} */
L.WMSOptions.prototype.version;
 /** @type {?} */
L.WMSOptions.prototype.crs;
 /** @type {boolean} */
L.WMSOptions.prototype.uppercase;
/**
 * @record
 * @struct
 */
L.WMSParams = function() {};
 /** @type {string} */
L.WMSParams.prototype.format;
 /** @type {string} */
L.WMSParams.prototype.layers;
 /** @type {string} */
L.WMSParams.prototype.request;
 /** @type {string} */
L.WMSParams.prototype.service;
 /** @type {string} */
L.WMSParams.prototype.styles;
 /** @type {string} */
L.WMSParams.prototype.version;
 /** @type {boolean} */
L.WMSParams.prototype.transparent;
 /** @type {number} */
L.WMSParams.prototype.width;
 /** @type {number} */
L.WMSParams.prototype.height;

/**
 * @param {string} baseUrl
 * @param {!L.WMSOptions=} options
 * @return {!L.TileLayer.WMS}
 */
L.tileLayer.wms = function(baseUrl, options) {};
/**
 * @extends {L.LayerOptions}
 * @record
 * @struct
 */
L.ImageOverlayOptions = function() {};
 /** @type {number} */
L.ImageOverlayOptions.prototype.opacity;
 /** @type {string} */
L.ImageOverlayOptions.prototype.alt;
 /** @type {boolean} */
L.ImageOverlayOptions.prototype.interactive;
 /** @type {string} */
L.ImageOverlayOptions.prototype.attribution;
 /** @type {boolean} */
L.ImageOverlayOptions.prototype.crossOrigin;

/**
 * @constructor
 * @struct
 * @param {string} imageUrl
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} bounds
 * @param {!L.ImageOverlayOptions=} options
 */
L.ImageOverlay = function(imageUrl, bounds, options) {};
 /** @type {!L.ImageOverlayOptions} */
L.ImageOverlay.prototype.options;

/**
 * @param {number} opacity
 * @return {ImageOverlay}
 */
L.ImageOverlay.prototype.setOpacity = function(opacity) {};

/**
 * @return {ImageOverlay}
 */
L.ImageOverlay.prototype.bringToFront = function() {};

/**
 * @return {ImageOverlay}
 */
L.ImageOverlay.prototype.bringToBack = function() {};

/**
 * @param {string} url
 * @return {ImageOverlay}
 */
L.ImageOverlay.prototype.setUrl = function(url) {};

/**
 * Update the bounds that this ImageOverlay covers
 * @param {!L.LatLngBounds} bounds
 * @return {ImageOverlay}
 */
L.ImageOverlay.prototype.setBounds = function(bounds) {};

/**
 * Get the bounds that this ImageOverlay covers
 * @return {!L.LatLngBounds}
 */
L.ImageOverlay.prototype.getBounds = function() {};

/**
 * Get the img element that represents the ImageOverlay on the map
 * @return {!HTMLImageElement}
 */
L.ImageOverlay.prototype.getElement = function() {};

/**
 * @param {string} imageUrl
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} bounds
 * @param {!L.ImageOverlayOptions=} options
 * @return {!L.ImageOverlay}
 */
L.imageOverlay = function(imageUrl, bounds, options) {};

/** @typedef {string} */
L.LineCapShape;

/** @typedef {string} */
L.LineJoinShape;

/** @typedef {string} */
L.FillRule;
/**
 * @extends {L.InteractiveLayerOptions}
 * @record
 * @struct
 */
L.PathOptions = function() {};
 /** @type {boolean} */
L.PathOptions.prototype.stroke;
 /** @type {string} */
L.PathOptions.prototype.color;
 /** @type {number} */
L.PathOptions.prototype.weight;
 /** @type {number} */
L.PathOptions.prototype.opacity;
 /** @type {string} */
L.PathOptions.prototype.lineCap;
 /** @type {string} */
L.PathOptions.prototype.lineJoin;
 /** @type {string} */
L.PathOptions.prototype.dashArray;
 /** @type {string} */
L.PathOptions.prototype.dashOffset;
 /** @type {boolean} */
L.PathOptions.prototype.fill;
 /** @type {string} */
L.PathOptions.prototype.fillColor;
 /** @type {number} */
L.PathOptions.prototype.fillOpacity;
 /** @type {string} */
L.PathOptions.prototype.fillRule;
 /** @type {!L.Renderer} */
L.PathOptions.prototype.renderer;
 /** @type {string} */
L.PathOptions.prototype.className;
/**
 * @extends {L.Layer}
 * @constructor
 * @struct
 */
L.Path = function() {};
 /** @type {!L.PathOptions} */
L.Path.prototype.options;

/**
 * @return {Path}
 */
L.Path.prototype.redraw = function() {};

/**
 * @param {!L.PathOptions} style
 * @return {Path}
 */
L.Path.prototype.setStyle = function(style) {};

/**
 * @return {Path}
 */
L.Path.prototype.bringToFront = function() {};

/**
 * @return {Path}
 */
L.Path.prototype.bringToBack = function() {};

/**
 * @return {!Element}
 */
L.Path.prototype.getElement = function() {};
/**
 * @extends {L.PathOptions}
 * @record
 * @struct
 */
L.PolylineOptions = function() {};
 /** @type {number} */
L.PolylineOptions.prototype.smoothFactor;
 /** @type {boolean} */
L.PolylineOptions.prototype.noClip;
/**
 * @extends {L.Path}
 * @constructor
 * @struct
 */
L.InternalPolyline = function() {};
 /** @type {!L.PolylineOptions} */
L.InternalPolyline.prototype.options;

/**
 * @return {!Array<!L.LatLng>}
 */
L.InternalPolyline.prototype.getLatLngs = function() {};

/**
 * @param {!Array<(!Array<?>|!L.LatLng|!L.LatLngLiteral)>} latlngs
 * @return {InternalPolyline}
 */
L.InternalPolyline.prototype.setLatLngs = function(latlngs) {};

/**
 * @return {boolean}
 */
L.InternalPolyline.prototype.isEmpty = function() {};

/**
 * @return {!L.LatLng}
 */
L.InternalPolyline.prototype.getCenter = function() {};

/**
 * @return {!L.LatLngBounds}
 */
L.InternalPolyline.prototype.getBounds = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral|!Array<(!Array<?>|!L.LatLng|!L.LatLngLiteral)>)} latlng
 * @return {InternalPolyline}
 */
L.InternalPolyline.prototype.addLatLng = function(latlng) {};

/**
 * @constructor
 * @struct
 * @param {!Array<(!Array<?>|!L.LatLng|!L.LatLngLiteral)>} latlngs
 * @param {!L.PolylineOptions=} options
 */
L.Polyline = function(latlngs, options) {};
 /** @type {?} */
L.Polyline.prototype.feature;

/**
 * @return {?}
 */
L.Polyline.prototype.toGeoJSON = function() {};

/**
 * @param {!Array<(!Array<?>|!L.LatLng|!L.LatLngLiteral)>} latlngs
 * @param {!L.PolylineOptions=} options
 * @return {!L.Polyline}
 */
L.polyline = function(latlngs, options) {};

/**
 * @constructor
 * @struct
 * @param {(!Array<(!Array<?>|!L.LatLng|!L.LatLngLiteral)>|!Array<!Array<(!Array<?>|!L.LatLng|!L.LatLngLiteral)>>)} latlngs
 * @param {!L.PolylineOptions=} options
 */
L.Polygon = function(latlngs, options) {};
 /** @type {?} */
L.Polygon.prototype.feature;

/**
 * @return {?}
 */
L.Polygon.prototype.toGeoJSON = function() {};

/**
 * @param {(!Array<(!Array<?>|!L.LatLng|!L.LatLngLiteral)>|!Array<!Array<(!Array<?>|!L.LatLng|!L.LatLngLiteral)>>)} latlngs
 * @param {!L.PolylineOptions=} options
 * @return {!L.Polygon}
 */
L.polygon = function(latlngs, options) {};

/**
 * @constructor
 * @struct
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} latLngBounds
 * @param {!L.PolylineOptions=} options
 */
L.Rectangle = function(latLngBounds, options) {};

/**
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} latLngBounds
 * @return {Rectangle}
 */
L.Rectangle.prototype.setBounds = function(latLngBounds) {};

/**
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} latLngBounds
 * @param {!L.PolylineOptions=} options
 * @return {!L.Rectangle}
 */
L.rectangle = function(latLngBounds, options) {};
/**
 * @extends {L.PathOptions}
 * @record
 * @struct
 */
L.CircleMarkerOptions = function() {};
 /** @type {number} */
L.CircleMarkerOptions.prototype.radius;

/**
 * @constructor
 * @struct
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {!L.CircleMarkerOptions=} options
 */
L.CircleMarker = function(latlng, options) {};
 /** @type {!L.CircleMarkerOptions} */
L.CircleMarker.prototype.options;
 /** @type {?} */
L.CircleMarker.prototype.feature;

/**
 * @return {?}
 */
L.CircleMarker.prototype.toGeoJSON = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latLng
 * @return {CircleMarker}
 */
L.CircleMarker.prototype.setLatLng = function(latLng) {};

/**
 * @return {!L.LatLng}
 */
L.CircleMarker.prototype.getLatLng = function() {};

/**
 * @param {number} radius
 * @return {CircleMarker}
 */
L.CircleMarker.prototype.setRadius = function(radius) {};

/**
 * @return {number}
 */
L.CircleMarker.prototype.getRadius = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {!L.CircleMarkerOptions=} options
 * @return {!L.CircleMarker}
 */
L.circleMarker = function(latlng, options) {};

/**
 * @constructor
 * @struct
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {!L.CircleMarkerOptions|number=} options_or_radius
 * @param {!L.CircleMarkerOptions=} options
 */
L.Circle = function(latlng, options_or_radius, options) {};

/**
 * @return {!L.LatLngBounds}
 */
L.Circle.prototype.getBounds = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {!L.CircleMarkerOptions|number=} options_or_radius
 * @param {!L.CircleMarkerOptions=} options
 * @return {!L.Circle}
 */
L.circle = function(latlng, options_or_radius, options) {};
/**
 * @extends {L.LayerOptions}
 * @record
 * @struct
 */
L.RendererOptions = function() {};
 /** @type {number} */
L.RendererOptions.prototype.padding;

/**
 * @constructor
 * @struct
 * @param {!L.RendererOptions=} options
 */
L.Renderer = function(options) {};
 /** @type {!L.RendererOptions} */
L.Renderer.prototype.options;
/**
 * @extends {L.Renderer}
 * @constructor
 * @struct
 */
L.SVG = function() {};

/**
 * @param {string} name
 * @return {!SVGElement}
 */
L.SVG.create = function(name) {};

/**
 * @param {!Array<(!L.Point|!Array<?>)>} rings
 * @param {boolean} close
 * @return {string}
 */
L.SVG.pointsToPath = function(rings, close) {};

/**
 * @param {!L.RendererOptions=} options
 * @return {!L.SVG}
 */
L.svg = function(options) {};
/**
 * @extends {L.Renderer}
 * @constructor
 * @struct
 */
L.Canvas = function() {};

/**
 * @param {!L.RendererOptions=} options
 * @return {!L.Canvas}
 */
L.canvas = function(options) {};

/**
 * @constructor
 * @struct
 * @param {!Array<!L.Layer>=} layers
 */
L.LayerGroup = function(layers) {};
 /** @type {?} */
L.LayerGroup.prototype.feature;

/**
 * Returns a GeoJSON representation of the layer group (as a GeoJSON GeometryCollection, GeoJSONFeatureCollection or Multipoint).
 * @return {?}
 */
L.LayerGroup.prototype.toGeoJSON = function() {};

/**
 * Adds the given layer to the group.
 * @param {!L.Layer} layer
 * @return {LayerGroup}
 */
L.LayerGroup.prototype.addLayer = function(layer) {};

/**
 * Removes the layer with the given internal ID or the given layer from the group.
 * @param {(number|!L.Layer)} layer
 * @return {LayerGroup}
 */
L.LayerGroup.prototype.removeLayer = function(layer) {};

/**
 * Returns true if the given layer is currently added to the group.
 * @param {!L.Layer} layer
 * @return {boolean}
 */
L.LayerGroup.prototype.hasLayer = function(layer) {};

/**
 * Removes all the layers from the group.
 * @return {LayerGroup}
 */
L.LayerGroup.prototype.clearLayers = function() {};

/**
 * Calls methodName on every layer contained in this group, passing any additional parameters.
 * Has no effect if the layers contained do not implement methodName.
 * @param {string} methodName
 * @param {...?} params
 * @return {LayerGroup}
 */
L.LayerGroup.prototype.invoke = function(methodName, params) {};

/**
 * Iterates over the layers of the group,
 * optionally specifying context of the iterator function.
 * @param {function(!L.Layer): void} fn
 * @param {?=} context
 * @return {LayerGroup}
 */
L.LayerGroup.prototype.eachLayer = function(fn, context) {};

/**
 * Returns the layer with the given internal ID.
 * @param {number} id
 * @return {!L.Layer}
 */
L.LayerGroup.prototype.getLayer = function(id) {};

/**
 * Returns an array of all the layers added to the group.
 * @return {!Array<!L.Layer>}
 */
L.LayerGroup.prototype.getLayers = function() {};

/**
 * Calls setZIndex on every layer contained in this group, passing the z-index.
 * @param {number} zIndex
 * @return {LayerGroup}
 */
L.LayerGroup.prototype.setZIndex = function(zIndex) {};

/**
 * Returns the internal ID for a layer
 * @param {!L.Layer} layer
 * @return {number}
 */
L.LayerGroup.prototype.getLayerId = function(layer) {};

/**
 * Create a layer group, optionally given an initial set of layers.
 * @param {!Array<!L.Layer>} layers
 * @return {!L.LayerGroup}
 */
L.layerGroup = function(layers) {};
/**
 * @extends {L.LayerGroup}
 * @constructor
 * @struct
 */
L.FeatureGroup = function() {};

/**
 * Sets the given path options to each layer of the group that has a setStyle method.
 * @param {!L.PathOptions} style
 * @return {FeatureGroup}
 */
L.FeatureGroup.prototype.setStyle = function(style) {};

/**
 * Brings the layer group to the top of all other layers
 * @return {FeatureGroup}
 */
L.FeatureGroup.prototype.bringToFront = function() {};

/**
 * Brings the layer group to the top [sic] of all other layers
 * @return {FeatureGroup}
 */
L.FeatureGroup.prototype.bringToBack = function() {};

/**
 * Returns the LatLngBounds of the Feature Group (created from
 * bounds and coordinates of its children).
 * @return {!L.LatLngBounds}
 */
L.FeatureGroup.prototype.getBounds = function() {};

/**
 * Create a feature group, optionally given an initial set of layers.
 * @param {!Array<!L.Layer>=} layers
 * @return {!L.FeatureGroup}
 */
L.featureGroup = function(layers) {};

/** @typedef {function(?): !L.PathOptions} */
L.StyleFunction;
/**
 * @extends {L.LayerOptions}
 * @record
 * @struct
 */
L.GeoJSONOptions = function() {};
 /** @type {function(?): !L.PathOptions} */
L.GeoJSONOptions.prototype.style;

/**
 * A Function defining how GeoJSON points spawn Leaflet layers.
 * It is internally called when data is added, passing the GeoJSON point
 * feature and its LatLng.
 * 
 * The default is to spawn a default Marker:
 * 
 * ```
 * function(geoJsonPoint, latlng) {
 *     return L.marker(latlng);
 * }
 * ```
 * @param {?} geoJsonPoint
 * @param {!L.LatLng} latlng
 * @return {!L.Layer}
 */
L.GeoJSONOptions.prototype.pointToLayer = function(geoJsonPoint, latlng) {};

/**
 * A Function that will be called once for each created Feature, after it
 * has been created and styled. Useful for attaching events and popups to features.
 * 
 * The default is to do nothing with the newly created layers:
 * 
 * ```
 * function (feature, layer) {}
 * ```
 * @param {?} feature
 * @param {!L.Layer} layer
 * @return {void}
 */
L.GeoJSONOptions.prototype.onEachFeature = function(feature, layer) {};

/**
 * A Function that will be used to decide whether to show a feature or not.
 * 
 * The default is to show all features:
 * 
 * ```
 * function (geoJsonFeature) {
 *     return true;
 * }
 * ```
 * @param {?} geoJsonFeature
 * @return {boolean}
 */
L.GeoJSONOptions.prototype.filter = function(geoJsonFeature) {};

/**
 * A Function that will be used for converting GeoJSON coordinates to LatLngs.
 * The default is the coordsToLatLng static method.
 * @param {!Array<?>} coords
 * @return {!L.LatLng}
 */
L.GeoJSONOptions.prototype.coordsToLatLng = function(coords) {};

/**
 * @constructor
 * @struct
 * @param {?=} geojson
 * @param {!L.GeoJSONOptions=} options
 */
L.GeoJSON = function(geojson, options) {};
 /** @type {!L.GeoJSONOptions} */
L.GeoJSON.prototype.options;

/**
 * Creates a Layer from a given GeoJSON feature. Can use a custom pointToLayer
 * and/or coordsToLatLng functions if provided as options.
 * @param {?} featureData
 * @param {!L.GeoJSONOptions=} options
 * @return {!L.Layer}
 */
L.GeoJSON.geometryToLayer = function(featureData, options) {};

/**
 * Creates a LatLng object from an array of 2 numbers (longitude, latitude) or
 * 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
 * @param {!Array<?>} coords
 * @return {!L.LatLng}
 */
L.GeoJSON.coordsToLatLng = function(coords) {};

/**
 * Creates a multidimensional array of LatLngs from a GeoJSON coordinates array.
 * levelsDeep specifies the nesting level (0 is for an array of points, 1 for an array of
 * arrays of points, etc., 0 by default).
 * Can use a custom coordsToLatLng function.
 * @param {!Array<?>} coords
 * @param {number=} levelsDeep
 * @param {function(!Array<?>): !L.LatLng=} coordsToLatLng
 * @return {!Array<?>}
 */
L.GeoJSON.coordsToLatLngs = function(coords, levelsDeep, coordsToLatLng) {};

/**
 * Reverse of coordsToLatLng
 * @param {!L.LatLng} latlng
 * @return {!Array<?>}
 */
L.GeoJSON.latLngToCoords = function(latlng) {};

/**
 * Reverse of coordsToLatLngs closed determines whether the first point should be
 * appended to the end of the array to close the feature, only used when levelsDeep is 0.
 * False by default.
 * @param {!Array<?>} latlngs
 * @param {number=} levelsDeep
 * @param {boolean=} closed
 * @return {!Array<?>}
 */
L.GeoJSON.latLngsToCoords = function(latlngs, levelsDeep, closed) {};

/**
 * Normalize GeoJSON geometries/features into GeoJSON features.
 * @param {?} geojson
 * @return {?}
 */
L.GeoJSON.asFeature = function(geojson) {};

/**
 * Adds a GeoJSON object to the layer.
 * @param {?} data
 * @return {!L.Layer}
 */
L.GeoJSON.prototype.addData = function(data) {};

/**
 * Resets the given vector layer's style to the original GeoJSON style,
 * useful for resetting style after hover events.
 * @param {!L.Layer} layer
 * @return {!L.Layer}
 */
L.GeoJSON.prototype.resetStyle = function(layer) {};

/**
 * Changes styles of GeoJSON vector layers with the given style function.
 * @param {function(?): !L.PathOptions} style
 * @return {GeoJSON}
 */
L.GeoJSON.prototype.setStyle = function(style) {};

/**
 * Creates a GeoJSON layer.
 * 
 * Optionally accepts an object in GeoJSON format to display on the
 * map (you can alternatively add it later with addData method) and
 * an options object.
 * @param {?=} geojson
 * @param {!L.GeoJSONOptions=} options
 * @return {!L.GeoJSON}
 */
L.geoJSON = function(geojson, options) {};

/** @typedef {(boolean|string)} */
L.Zoom;
/**
 * @record
 * @struct
 */
L.MapOptions = function() {};
 /** @type {boolean} */
L.MapOptions.prototype.preferCanvas;
 /** @type {boolean} */
L.MapOptions.prototype.attributionControl;
 /** @type {boolean} */
L.MapOptions.prototype.zoomControl;
 /** @type {boolean} */
L.MapOptions.prototype.closePopupOnClick;
 /** @type {number} */
L.MapOptions.prototype.zoomSnap;
 /** @type {number} */
L.MapOptions.prototype.zoomDelta;
 /** @type {boolean} */
L.MapOptions.prototype.trackResize;
 /** @type {boolean} */
L.MapOptions.prototype.boxZoom;
 /** @type {(boolean|string)} */
L.MapOptions.prototype.doubleClickZoom;
 /** @type {boolean} */
L.MapOptions.prototype.dragging;
 /** @type {?} */
L.MapOptions.prototype.crs;
 /** @type {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} */
L.MapOptions.prototype.center;
 /** @type {number} */
L.MapOptions.prototype.zoom;
 /** @type {number} */
L.MapOptions.prototype.minZoom;
 /** @type {number} */
L.MapOptions.prototype.maxZoom;
 /** @type {!Array<!L.Layer>} */
L.MapOptions.prototype.layers;
 /** @type {(!L.LatLngBounds|!Array<!Array<?>>)} */
L.MapOptions.prototype.maxBounds;
 /** @type {!L.Renderer} */
L.MapOptions.prototype.renderer;
 /** @type {boolean} */
L.MapOptions.prototype.fadeAnimation;
 /** @type {boolean} */
L.MapOptions.prototype.markerZoomAnimation;
 /** @type {number} */
L.MapOptions.prototype.transform3DLimit;
 /** @type {boolean} */
L.MapOptions.prototype.zoomAnimation;
 /** @type {number} */
L.MapOptions.prototype.zoomAnimationThreshold;
 /** @type {boolean} */
L.MapOptions.prototype.inertia;
 /** @type {number} */
L.MapOptions.prototype.inertiaDeceleration;
 /** @type {number} */
L.MapOptions.prototype.inertiaMaxSpeed;
 /** @type {number} */
L.MapOptions.prototype.easeLinearity;
 /** @type {boolean} */
L.MapOptions.prototype.worldCopyJump;
 /** @type {number} */
L.MapOptions.prototype.maxBoundsViscosity;
 /** @type {boolean} */
L.MapOptions.prototype.keyboard;
 /** @type {number} */
L.MapOptions.prototype.keyboardPanDelta;
 /** @type {(boolean|string)} */
L.MapOptions.prototype.scrollWheelZoom;
 /** @type {number} */
L.MapOptions.prototype.wheelDebounceTime;
 /** @type {number} */
L.MapOptions.prototype.wheelPxPerZoomLevel;
 /** @type {boolean} */
L.MapOptions.prototype.tap;
 /** @type {number} */
L.MapOptions.prototype.tapTolerance;
 /** @type {(boolean|string)} */
L.MapOptions.prototype.touchZoom;
 /** @type {boolean} */
L.MapOptions.prototype.bounceAtZoomLimits;

/** @typedef {string} */
L.ControlPosition;
/**
 * @record
 * @struct
 */
L.ControlOptions = function() {};
 /** @type {string} */
L.ControlOptions.prototype.position;

/**
 * @constructor
 * @struct
 * @param {!L.ControlOptions=} options
 */
L.Control = function(options) {};
 /** @type {!L.ControlOptions} */
L.Control.prototype.options;

/**
 * @return {string}
 */
L.Control.prototype.getPosition = function() {};

/**
 * @param {string} position
 * @return {Control}
 */
L.Control.prototype.setPosition = function(position) {};

/**
 * @return {!HTMLElement}
 */
L.Control.prototype.getContainer = function() {};

/**
 * @param {!L.Map} map
 * @return {Control}
 */
L.Control.prototype.addTo = function(map) {};

/**
 * @return {Control}
 */
L.Control.prototype.remove = function() {};

/**
 * @param {!L.Map} map
 * @return {!HTMLElement}
 */
L.Control.prototype.onAdd = function(map) {};

/**
 * @param {!L.Map} map
 * @return {void}
 */
L.Control.prototype.onRemove = function(map) {};
/**
 * @extends {L.ControlOptions}
 * @record
 * @struct
 */
L.Control.ZoomOptions = function() {};
 /** @type {string} */
L.Control.ZoomOptions.prototype.zoomInText;
 /** @type {string} */
L.Control.ZoomOptions.prototype.zoomInTitle;
 /** @type {string} */
L.Control.ZoomOptions.prototype.zoomOutText;
 /** @type {string} */
L.Control.ZoomOptions.prototype.zoomOutTitle;

/**
 * @constructor
 * @struct
 * @param {!L.Control.ZoomOptions=} options
 */
L.Control.Zoom = function(options) {};
 /** @type {!L.Control.ZoomOptions} */
L.Control.Zoom.prototype.options;
/**
 * @extends {L.ControlOptions}
 * @record
 * @struct
 */
L.Control.AttributionOptions = function() {};
 /** @type {(string|boolean)} */
L.Control.AttributionOptions.prototype.prefix;

/**
 * @constructor
 * @struct
 * @param {!L.Control.AttributionOptions=} options
 */
L.Control.Attribution = function(options) {};
 /** @type {!L.Control.AttributionOptions} */
L.Control.Attribution.prototype.options;

/**
 * @param {string} prefix
 * @return {Attribution}
 */
L.Control.Attribution.prototype.setPrefix = function(prefix) {};

/**
 * @param {string} text
 * @return {Attribution}
 */
L.Control.Attribution.prototype.addAttribution = function(text) {};

/**
 * @param {string} text
 * @return {Attribution}
 */
L.Control.Attribution.prototype.removeAttribution = function(text) {};
/**
 * @extends {L.ControlOptions}
 * @record
 * @struct
 */
L.Control.LayersOptions = function() {};
 /** @type {boolean} */
L.Control.LayersOptions.prototype.collapsed;
 /** @type {boolean} */
L.Control.LayersOptions.prototype.autoZIndex;
 /** @type {boolean} */
L.Control.LayersOptions.prototype.hideSingleBase;
/**
 * @record
 * @struct
 */
L.Control.LayersObject = function() {};

/* TODO: IndexSignature: L.Control */

/**
 * @constructor
 * @struct
 * @param {!L.Control.LayersObject=} baseLayers
 * @param {!L.Control.LayersObject=} overlays
 * @param {!L.Control.LayersOptions=} options
 */
L.Control.Layers = function(baseLayers, overlays, options) {};
 /** @type {!L.Control.LayersOptions} */
L.Control.Layers.prototype.options;

/**
 * @param {!L.Layer} layer
 * @param {string} name
 * @return {Layers}
 */
L.Control.Layers.prototype.addBaseLayer = function(layer, name) {};

/**
 * @param {!L.Layer} layer
 * @param {string} name
 * @return {Layers}
 */
L.Control.Layers.prototype.addOverlay = function(layer, name) {};

/**
 * @param {!L.Layer} layer
 * @return {Layers}
 */
L.Control.Layers.prototype.removeLayer = function(layer) {};

/**
 * @return {Layers}
 */
L.Control.Layers.prototype.expand = function() {};

/**
 * @return {Layers}
 */
L.Control.Layers.prototype.collapse = function() {};
/**
 * @extends {L.ControlOptions}
 * @record
 * @struct
 */
L.Control.ScaleOptions = function() {};
 /** @type {number} */
L.Control.ScaleOptions.prototype.maxWidth;
 /** @type {boolean} */
L.Control.ScaleOptions.prototype.metric;
 /** @type {boolean} */
L.Control.ScaleOptions.prototype.imperial;
 /** @type {boolean} */
L.Control.ScaleOptions.prototype.updateWhenIdle;

/**
 * @constructor
 * @struct
 * @param {!L.Control.ScaleOptions=} options
 */
L.Control.Scale = function(options) {};
 /** @type {!L.Control.ScaleOptions} */
L.Control.Scale.prototype.options;
/** @const */
L.control = {};

/**
 * @param {!L.Control.ZoomOptions=} options
 * @return {!L.Control.Zoom}
 */
L.control.zoom = function(options) {};

/**
 * @param {!L.Control.AttributionOptions=} options
 * @return {!L.Control.Attribution}
 */
L.control.attribution = function(options) {};

/**
 * @param {!L.Control.LayersObject=} baseLayers
 * @param {!L.Control.LayersObject=} overlays
 * @param {!L.Control.LayersOptions=} options
 * @return {!L.Control.Layers}
 */
L.control.layers = function(baseLayers, overlays, options) {};

/**
 * @param {!L.Control.ScaleOptions=} options
 * @return {!L.Control.Scale}
 */
L.control.scale = function(options) {};
/**
 * @record
 * @struct
 */
L.DivOverlayOptions = function() {};
 /** @type {(!L.Point|!Array<?>)} */
L.DivOverlayOptions.prototype.offset;
 /** @type {boolean} */
L.DivOverlayOptions.prototype.zoomAnimation;
 /** @type {string} */
L.DivOverlayOptions.prototype.className;
 /** @type {string} */
L.DivOverlayOptions.prototype.pane;
/**
 * @extends {L.DivOverlayOptions}
 * @record
 * @struct
 */
L.PopupOptions = function() {};
 /** @type {number} */
L.PopupOptions.prototype.maxWidth;
 /** @type {number} */
L.PopupOptions.prototype.minWidth;
 /** @type {number} */
L.PopupOptions.prototype.maxHeight;
 /** @type {boolean} */
L.PopupOptions.prototype.autoPan;
 /** @type {(!L.Point|!Array<?>)} */
L.PopupOptions.prototype.autoPanPaddingTopLeft;
 /** @type {(!L.Point|!Array<?>)} */
L.PopupOptions.prototype.autoPanPaddingBottomRight;
 /** @type {(!L.Point|!Array<?>)} */
L.PopupOptions.prototype.autoPanPadding;
 /** @type {boolean} */
L.PopupOptions.prototype.keepInView;
 /** @type {boolean} */
L.PopupOptions.prototype.closeButton;
 /** @type {boolean} */
L.PopupOptions.prototype.autoClose;
 /** @type {boolean} */
L.PopupOptions.prototype.closeOnClick;

/** @typedef {(string|!HTMLElement)} */
L.Content;

/**
 * @constructor
 * @struct
 * @param {!L.PopupOptions=} options
 * @param {!L.Layer=} source
 */
L.Popup = function(options, source) {};
 /** @type {!L.PopupOptions} */
L.Popup.prototype.options;

/**
 * @return {!L.LatLng}
 */
L.Popup.prototype.getLatLng = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @return {Popup}
 */
L.Popup.prototype.setLatLng = function(latlng) {};

/**
 * @return {(string|!HTMLElement|function(!L.Layer): (string|!HTMLElement))}
 */
L.Popup.prototype.getContent = function() {};

/**
 * @param {(string|!HTMLElement|function(!L.Layer): (string|!HTMLElement))} htmlContent
 * @return {Popup}
 */
L.Popup.prototype.setContent = function(htmlContent) {};

/**
 * @return {!HTMLElement}
 */
L.Popup.prototype.getElement = function() {};

/**
 * @return {void}
 */
L.Popup.prototype.update = function() {};

/**
 * @return {boolean}
 */
L.Popup.prototype.isOpen = function() {};

/**
 * @return {Popup}
 */
L.Popup.prototype.bringToFront = function() {};

/**
 * @return {Popup}
 */
L.Popup.prototype.bringToBack = function() {};

/**
 * @param {!L.Map} map
 * @return {Popup}
 */
L.Popup.prototype.openOn = function(map) {};

/**
 * @param {!L.PopupOptions=} options
 * @param {!L.Layer=} source
 * @return {!L.Popup}
 */
L.popup = function(options, source) {};

/** @typedef {string} */
L.Direction;
/**
 * @extends {L.DivOverlayOptions}
 * @record
 * @struct
 */
L.TooltipOptions = function() {};
 /** @type {string} */
L.TooltipOptions.prototype.pane;
 /** @type {(!L.Point|!Array<?>)} */
L.TooltipOptions.prototype.offset;
 /** @type {string} */
L.TooltipOptions.prototype.direction;
 /** @type {boolean} */
L.TooltipOptions.prototype.permanent;
 /** @type {boolean} */
L.TooltipOptions.prototype.sticky;
 /** @type {boolean} */
L.TooltipOptions.prototype.interactive;
 /** @type {number} */
L.TooltipOptions.prototype.opacity;

/**
 * @constructor
 * @struct
 * @param {!L.TooltipOptions=} options
 * @param {!L.Layer=} source
 */
L.Tooltip = function(options, source) {};
 /** @type {!L.TooltipOptions} */
L.Tooltip.prototype.options;

/**
 * @param {number} val
 * @return {void}
 */
L.Tooltip.prototype.setOpacity = function(val) {};

/**
 * @return {!L.LatLng}
 */
L.Tooltip.prototype.getLatLng = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @return {Tooltip}
 */
L.Tooltip.prototype.setLatLng = function(latlng) {};

/**
 * @return {(string|!HTMLElement)}
 */
L.Tooltip.prototype.getContent = function() {};

/**
 * @param {(string|!HTMLElement|function(!L.Layer): (string|!HTMLElement))} htmlContent
 * @return {Tooltip}
 */
L.Tooltip.prototype.setContent = function(htmlContent) {};

/**
 * @return {!HTMLElement}
 */
L.Tooltip.prototype.getElement = function() {};

/**
 * @return {void}
 */
L.Tooltip.prototype.update = function() {};

/**
 * @return {boolean}
 */
L.Tooltip.prototype.isOpen = function() {};

/**
 * @return {Tooltip}
 */
L.Tooltip.prototype.bringToFront = function() {};

/**
 * @return {Tooltip}
 */
L.Tooltip.prototype.bringToBack = function() {};

/**
 * @param {!L.TooltipOptions=} options
 * @param {!L.Layer=} source
 * @return {!L.Tooltip}
 */
L.tooltip = function(options, source) {};
/**
 * @record
 * @struct
 */
L.ZoomOptions = function() {};
 /** @type {boolean} */
L.ZoomOptions.prototype.animate;
/**
 * @record
 * @struct
 */
L.PanOptions = function() {};
 /** @type {boolean} */
L.PanOptions.prototype.animate;
 /** @type {number} */
L.PanOptions.prototype.duration;
 /** @type {number} */
L.PanOptions.prototype.easeLinearity;
 /** @type {boolean} */
L.PanOptions.prototype.noMoveStart;
/**
 * @extends {L.ZoomOptions}
 * @extends {L.PanOptions}
 * @record
 * @struct
 */
L.ZoomPanOptions = function() {};
/**
 * @extends {L.ZoomOptions}
 * @extends {L.PanOptions}
 * @record
 * @struct
 */
L.FitBoundsOptions = function() {};
 /** @type {(!L.Point|!Array<?>)} */
L.FitBoundsOptions.prototype.paddingTopLeft;
 /** @type {(!L.Point|!Array<?>)} */
L.FitBoundsOptions.prototype.paddingBottomRight;
 /** @type {(!L.Point|!Array<?>)} */
L.FitBoundsOptions.prototype.padding;
 /** @type {number} */
L.FitBoundsOptions.prototype.maxZoom;
/**
 * @record
 * @struct
 */
L.LocateOptions = function() {};
 /** @type {boolean} */
L.LocateOptions.prototype.watch;
 /** @type {boolean} */
L.LocateOptions.prototype.setView;
 /** @type {number} */
L.LocateOptions.prototype.maxZoom;
 /** @type {number} */
L.LocateOptions.prototype.timeout;
 /** @type {number} */
L.LocateOptions.prototype.maximumAge;
 /** @type {boolean} */
L.LocateOptions.prototype.enableHighAccuracy;

/**
 * @constructor
 * @struct
 * @param {!L.Map} map
 */
L.Handler = function(map) {};

/**
 * @return {Handler}
 */
L.Handler.prototype.enable = function() {};

/**
 * @return {Handler}
 */
L.Handler.prototype.disable = function() {};

/**
 * @return {boolean}
 */
L.Handler.prototype.enabled = function() {};

/**
 * @return {void}
 */
L.Handler.prototype.addHooks = function() {};

/**
 * @return {void}
 */
L.Handler.prototype.removeHooks = function() {};
/**
 * @record
 * @struct
 */
L.Event = function() {};
 /** @type {string} */
L.Event.prototype.type;
 /** @type {?} */
L.Event.prototype.target;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.MouseEvent = function() {};
 /** @type {!L.LatLng} */
L.MouseEvent.prototype.latlng;
 /** @type {!L.Point} */
L.MouseEvent.prototype.layerPoint;
 /** @type {!L.Point} */
L.MouseEvent.prototype.containerPoint;
 /** @type {!MouseEvent} */
L.MouseEvent.prototype.originalEvent;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.KeyboardEvent = function() {};
 /** @type {!KeyboardEvent} */
L.KeyboardEvent.prototype.originalEvent;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.LocationEvent = function() {};
 /** @type {!L.LatLng} */
L.LocationEvent.prototype.latlng;
 /** @type {!L.LatLngBounds} */
L.LocationEvent.prototype.bounds;
 /** @type {number} */
L.LocationEvent.prototype.accuracy;
 /** @type {number} */
L.LocationEvent.prototype.altitude;
 /** @type {number} */
L.LocationEvent.prototype.altitudeAccuracy;
 /** @type {number} */
L.LocationEvent.prototype.heading;
 /** @type {number} */
L.LocationEvent.prototype.speed;
 /** @type {number} */
L.LocationEvent.prototype.timestamp;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.ErrorEvent = function() {};
 /** @type {string} */
L.ErrorEvent.prototype.message;
 /** @type {number} */
L.ErrorEvent.prototype.code;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.LayerEvent = function() {};
 /** @type {!L.Layer} */
L.LayerEvent.prototype.layer;
/**
 * @extends {L.LayerEvent}
 * @record
 * @struct
 */
L.LayersControlEvent = function() {};
 /** @type {string} */
L.LayersControlEvent.prototype.name;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.TileEvent = function() {};
 /** @type {!HTMLImageElement} */
L.TileEvent.prototype.tile;
 /** @type {!L.Point} */
L.TileEvent.prototype.coords;
/**
 * @extends {L.TileEvent}
 * @record
 * @struct
 */
L.TileErrorEvent = function() {};
 /** @type {!Error} */
L.TileErrorEvent.prototype.error;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.ResizeEvent = function() {};
 /** @type {!L.Point} */
L.ResizeEvent.prototype.oldSize;
 /** @type {!L.Point} */
L.ResizeEvent.prototype.newSize;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.GeoJSONEvent = function() {};
 /** @type {!L.Layer} */
L.GeoJSONEvent.prototype.layer;
 /** @type {?} */
L.GeoJSONEvent.prototype.properties;
 /** @type {string} */
L.GeoJSONEvent.prototype.geometryType;
 /** @type {string} */
L.GeoJSONEvent.prototype.id;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.PopupEvent = function() {};
 /** @type {!L.Popup} */
L.PopupEvent.prototype.popup;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.TooltipEvent = function() {};
 /** @type {!L.Tooltip} */
L.TooltipEvent.prototype.tooltip;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.DragEndEvent = function() {};
 /** @type {number} */
L.DragEndEvent.prototype.distance;
/**
 * @extends {L.Event}
 * @record
 * @struct
 */
L.ZoomAnimEvent = function() {};
 /** @type {!L.LatLng} */
L.ZoomAnimEvent.prototype.center;
 /** @type {number} */
L.ZoomAnimEvent.prototype.zoom;
 /** @type {boolean} */
L.ZoomAnimEvent.prototype.noUpdate;
/** @const */
L.DomEvent = {};

/**
 * @param {!HTMLElement} el
 * @param {string|!Object<string,function(!L.Event): void>} types_or_eventMap
 * @param {function(!L.Event): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.DomEvent.on = function(el, types_or_eventMap, fn_or_context, context) {};

/**
 * @param {!HTMLElement} el
 * @param {string|!Object<string,function(!L.Event): void>} types_or_eventMap
 * @param {function(!L.Event): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.DomEvent.off = function(el, types_or_eventMap, fn_or_context, context) {};

/**
 * @param {!L.Event} ev
 * @return {?}
 */
L.DomEvent.stopPropagation = function(ev) {};

/**
 * @param {!HTMLElement} el
 * @return {?}
 */
L.DomEvent.disableScrollPropagation = function(el) {};

/**
 * @param {!HTMLElement} el
 * @return {?}
 */
L.DomEvent.disableClickPropagation = function(el) {};

/**
 * @param {!L.Event} ev
 * @return {?}
 */
L.DomEvent.preventDefault = function(ev) {};

/**
 * @param {!L.Event} ev
 * @return {?}
 */
L.DomEvent.stop = function(ev) {};

/**
 * @param {{clientX: number, clientY: number}} ev
 * @param {!HTMLElement=} container
 * @return {!L.Point}
 */
L.DomEvent.getMousePosition = function(ev, container) {};

/**
 * @param {!L.Event} ev
 * @return {number}
 */
L.DomEvent.getWheelDelta = function(ev) {};

/**
 * @param {!HTMLElement} el
 * @param {string|!Object<string,function(!L.Event): void>} types_or_eventMap
 * @param {function(!L.Event): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.DomEvent.addListener = function(el, types_or_eventMap, fn_or_context, context) {};

/**
 * @param {!HTMLElement} el
 * @param {string|!Object<string,function(!L.Event): void>} types_or_eventMap
 * @param {function(!L.Event): void|?=} fn_or_context
 * @param {?=} context
 * @return {?}
 */
L.DomEvent.removeListener = function(el, types_or_eventMap, fn_or_context, context) {};
/**
 * @record
 * @struct
 */
L.DefaultMapPanes = function() {};
 /** @type {!HTMLElement} */
L.DefaultMapPanes.prototype.mapPane;
 /** @type {!HTMLElement} */
L.DefaultMapPanes.prototype.tilePane;
 /** @type {!HTMLElement} */
L.DefaultMapPanes.prototype.overlayPane;
 /** @type {!HTMLElement} */
L.DefaultMapPanes.prototype.shadowPane;
 /** @type {!HTMLElement} */
L.DefaultMapPanes.prototype.markerPane;
 /** @type {!HTMLElement} */
L.DefaultMapPanes.prototype.tooltipPane;
 /** @type {!HTMLElement} */
L.DefaultMapPanes.prototype.popupPane;

/**
 * @constructor
 * @struct
 * @param {(string|!HTMLElement)} element
 * @param {!L.MapOptions=} options
 */
L.Map = function(element, options) {};
 /** @type {!L.Handler} */
L.Map.prototype.boxZoom;
 /** @type {!L.Handler} */
L.Map.prototype.doubleClickZoom;
 /** @type {!L.Handler} */
L.Map.prototype.dragging;
 /** @type {!L.Handler} */
L.Map.prototype.keyboard;
 /** @type {!L.Handler} */
L.Map.prototype.scrollWheelZoom;
 /** @type {!L.Handler} */
L.Map.prototype.tap;
 /** @type {!L.Handler} */
L.Map.prototype.touchZoom;
 /** @type {!L.MapOptions} */
L.Map.prototype.options;

/**
 * @param {!L.Path} layer
 * @return {!L.Renderer}
 */
L.Map.prototype.getRenderer = function(layer) {};

/**
 * @param {!L.Control} control
 * @return {Map}
 */
L.Map.prototype.addControl = function(control) {};

/**
 * @param {!L.Control} control
 * @return {Map}
 */
L.Map.prototype.removeControl = function(control) {};

/**
 * @param {!L.Layer} layer
 * @return {Map}
 */
L.Map.prototype.addLayer = function(layer) {};

/**
 * @param {!L.Layer} layer
 * @return {Map}
 */
L.Map.prototype.removeLayer = function(layer) {};

/**
 * @param {!L.Layer} layer
 * @return {boolean}
 */
L.Map.prototype.hasLayer = function(layer) {};

/**
 * @param {function(!L.Layer): void} fn
 * @param {?=} context
 * @return {Map}
 */
L.Map.prototype.eachLayer = function(fn, context) {};

/**
 * @param {!L.Popup|(string|!HTMLElement)} popup_or_content
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)=} latlng
 * @param {!L.PopupOptions=} options
 * @return {Map}
 */
L.Map.prototype.openPopup = function(popup_or_content, latlng, options) {};

/**
 * @param {!L.Popup=} popup
 * @return {Map}
 */
L.Map.prototype.closePopup = function(popup) {};

/**
 * @param {!L.Tooltip|(string|!HTMLElement)} tooltip_or_content
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)=} latlng
 * @param {!L.TooltipOptions=} options
 * @return {Map}
 */
L.Map.prototype.openTooltip = function(tooltip_or_content, latlng, options) {};

/**
 * @param {!L.Tooltip=} tooltip
 * @return {Map}
 */
L.Map.prototype.closeTooltip = function(tooltip) {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} center
 * @param {number} zoom
 * @param {!L.ZoomPanOptions=} options
 * @return {Map}
 */
L.Map.prototype.setView = function(center, zoom, options) {};

/**
 * @param {number} zoom
 * @param {!L.ZoomPanOptions=} options
 * @return {Map}
 */
L.Map.prototype.setZoom = function(zoom, options) {};

/**
 * @param {number=} delta
 * @param {!L.ZoomOptions=} options
 * @return {Map}
 */
L.Map.prototype.zoomIn = function(delta, options) {};

/**
 * @param {number=} delta
 * @param {!L.ZoomOptions=} options
 * @return {Map}
 */
L.Map.prototype.zoomOut = function(delta, options) {};

/**
 * @param {(!L.Point|!Array<?>|!L.LatLng|!L.LatLngLiteral)} position
 * @param {number} zoom
 * @param {!L.ZoomOptions=} options
 * @return {Map}
 */
L.Map.prototype.setZoomAround = function(position, zoom, options) {};

/**
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} bounds
 * @param {!L.FitBoundsOptions=} options
 * @return {Map}
 */
L.Map.prototype.fitBounds = function(bounds, options) {};

/**
 * @param {!L.FitBoundsOptions=} options
 * @return {Map}
 */
L.Map.prototype.fitWorld = function(options) {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {!L.PanOptions=} options
 * @return {Map}
 */
L.Map.prototype.panTo = function(latlng, options) {};

/**
 * @param {(!L.Point|!Array<?>)} offset
 * @return {Map}
 */
L.Map.prototype.panBy = function(offset) {};

/**
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} bounds
 * @return {Map}
 */
L.Map.prototype.setMaxBounds = function(bounds) {};

/**
 * @param {number} zoom
 * @return {Map}
 */
L.Map.prototype.setMinZoom = function(zoom) {};

/**
 * @param {number} zoom
 * @return {Map}
 */
L.Map.prototype.setMaxZoom = function(zoom) {};

/**
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} bounds
 * @param {!L.PanOptions=} options
 * @return {Map}
 */
L.Map.prototype.panInsideBounds = function(bounds, options) {};

/**
 * Boolean for animate or advanced ZoomPanOptions
 * @param {(boolean|!L.ZoomPanOptions)=} options
 * @return {Map}
 */
L.Map.prototype.invalidateSize = function(options) {};

/**
 * @return {Map}
 */
L.Map.prototype.stop = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {number=} zoom
 * @param {!L.ZoomPanOptions=} options
 * @return {Map}
 */
L.Map.prototype.flyTo = function(latlng, zoom, options) {};

/**
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} bounds
 * @param {!L.FitBoundsOptions=} options
 * @return {Map}
 */
L.Map.prototype.flyToBounds = function(bounds, options) {};

/**
 * @param {string} name
 * @param {function(): !L.Handler} HandlerClass
 * @return {Map}
 */
L.Map.prototype.addHandler = function(name, HandlerClass) {};

/**
 * @return {Map}
 */
L.Map.prototype.remove = function() {};

/**
 * @param {string} name
 * @param {!HTMLElement=} container
 * @return {!HTMLElement}
 */
L.Map.prototype.createPane = function(name, container) {};

/**
 * Name of the pane or the pane as HTML-Element
 * @param {(string|!HTMLElement)} pane
 * @return {!HTMLElement}
 */
L.Map.prototype.getPane = function(pane) {};

/**
 * @return {?}
 */
L.Map.prototype.getPanes = function() {};

/**
 * @return {!HTMLElement}
 */
L.Map.prototype.getContainer = function() {};

/**
 * @param {function(): void} fn
 * @param {?=} context
 * @return {Map}
 */
L.Map.prototype.whenReady = function(fn, context) {};

/**
 * @return {!L.LatLng}
 */
L.Map.prototype.getCenter = function() {};

/**
 * @return {number}
 */
L.Map.prototype.getZoom = function() {};

/**
 * @return {!L.LatLngBounds}
 */
L.Map.prototype.getBounds = function() {};

/**
 * @return {number}
 */
L.Map.prototype.getMinZoom = function() {};

/**
 * @return {number}
 */
L.Map.prototype.getMaxZoom = function() {};

/**
 * @param {(!L.LatLngBounds|!Array<!Array<?>>)} bounds
 * @param {boolean=} inside
 * @return {number}
 */
L.Map.prototype.getBoundsZoom = function(bounds, inside) {};

/**
 * @return {!L.Point}
 */
L.Map.prototype.getSize = function() {};

/**
 * @return {!L.Bounds}
 */
L.Map.prototype.getPixelBounds = function() {};

/**
 * @return {!L.Point}
 */
L.Map.prototype.getPixelOrigin = function() {};

/**
 * @param {number=} zoom
 * @return {!L.Bounds}
 */
L.Map.prototype.getPixelWorldBounds = function(zoom) {};

/**
 * @param {number} toZoom
 * @param {number} fromZoom
 * @return {number}
 */
L.Map.prototype.getZoomScale = function(toZoom, fromZoom) {};

/**
 * @param {number} scale
 * @param {number} fromZoom
 * @return {number}
 */
L.Map.prototype.getScaleZoom = function(scale, fromZoom) {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {number} zoom
 * @return {!L.Point}
 */
L.Map.prototype.project = function(latlng, zoom) {};

/**
 * @param {(!L.Point|!Array<?>)} point
 * @param {number} zoom
 * @return {!L.LatLng}
 */
L.Map.prototype.unproject = function(point, zoom) {};

/**
 * @param {(!L.Point|!Array<?>)} point
 * @return {!L.LatLng}
 */
L.Map.prototype.layerPointToLatLng = function(point) {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @return {!L.Point}
 */
L.Map.prototype.latLngToLayerPoint = function(latlng) {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @return {!L.LatLng}
 */
L.Map.prototype.wrapLatLng = function(latlng) {};

/**
 * @param {!L.LatLngBounds} bounds
 * @return {!L.LatLngBounds}
 */
L.Map.prototype.wrapLatLngBounds = function(bounds) {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng1
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng2
 * @return {number}
 */
L.Map.prototype.distance = function(latlng1, latlng2) {};

/**
 * @param {(!L.Point|!Array<?>)} point
 * @return {!L.Point}
 */
L.Map.prototype.containerPointToLayerPoint = function(point) {};

/**
 * @param {(!L.Point|!Array<?>)} point
 * @return {!L.LatLng}
 */
L.Map.prototype.containerPointToLatLng = function(point) {};

/**
 * @param {(!L.Point|!Array<?>)} point
 * @return {!L.Point}
 */
L.Map.prototype.layerPointToContainerPoint = function(point) {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @return {!L.Point}
 */
L.Map.prototype.latLngToContainerPoint = function(latlng) {};

/**
 * @param {!L.MouseEvent} ev
 * @return {!L.Point}
 */
L.Map.prototype.mouseEventToContainerPoint = function(ev) {};

/**
 * @param {!L.MouseEvent} ev
 * @return {!L.Point}
 */
L.Map.prototype.mouseEventToLayerPoint = function(ev) {};

/**
 * @param {!L.MouseEvent} ev
 * @return {!L.LatLng}
 */
L.Map.prototype.mouseEventToLatLng = function(ev) {};

/**
 * @param {!L.LocateOptions=} options
 * @return {Map}
 */
L.Map.prototype.locate = function(options) {};

/**
 * @return {Map}
 */
L.Map.prototype.stopLocate = function() {};

/**
 * ID of a HTML-Element as string or the HTML-ELement itself
 * @param {(string|!HTMLElement)} element
 * @param {!L.MapOptions=} options
 * @return {!L.Map}
 */
L.map = function(element, options) {};
/**
 * @extends {L.LayerOptions}
 * @record
 * @struct
 */
L.BaseIconOptions = function() {};
 /** @type {string} */
L.BaseIconOptions.prototype.iconUrl;
 /** @type {string} */
L.BaseIconOptions.prototype.iconRetinaUrl;
 /** @type {(!L.Point|!Array<?>)} */
L.BaseIconOptions.prototype.iconSize;
 /** @type {(!L.Point|!Array<?>)} */
L.BaseIconOptions.prototype.iconAnchor;
 /** @type {(!L.Point|!Array<?>)} */
L.BaseIconOptions.prototype.popupAnchor;
 /** @type {string} */
L.BaseIconOptions.prototype.shadowUrl;
 /** @type {string} */
L.BaseIconOptions.prototype.shadowRetinaUrl;
 /** @type {(!L.Point|!Array<?>)} */
L.BaseIconOptions.prototype.shadowSize;
 /** @type {(!L.Point|!Array<?>)} */
L.BaseIconOptions.prototype.shadowAnchor;
 /** @type {string} */
L.BaseIconOptions.prototype.className;
/**
 * @extends {L.BaseIconOptions}
 * @record
 * @struct
 */
L.IconOptions = function() {};
 /** @type {string} */
L.IconOptions.prototype.iconUrl;
/**
 * @extends {L.Layer}
 * @constructor
 * @struct
 */
L.BaseIcon = function() {};
 /** @type {!L.BaseIconOptions} */
L.BaseIcon.prototype.options;

/**
 * @param {!HTMLElement=} oldIcon
 * @return {!HTMLElement}
 */
L.BaseIcon.prototype.createIcon = function(oldIcon) {};

/**
 * @param {!HTMLElement=} oldIcon
 * @return {!HTMLElement}
 */
L.BaseIcon.prototype.createShadow = function(oldIcon) {};

/**
 * @constructor
 * @struct
 * @param {!L.IconOptions} options
 */
L.Icon = function(options) {};
 /** @type {!L.IconOptions} */
L.Icon.prototype.options;
/**
 * @extends {L.BaseIconOptions}
 * @record
 * @struct
 */
L.Icon.DefaultIconOptions = function() {};
 /** @type {string} */
L.Icon.DefaultIconOptions.prototype.imagePath;

/**
 * @constructor
 * @struct
 * @param {!L.Icon.DefaultIconOptions=} options
 */
L.Icon.Default = function(options) {};
 /** @type {string} */
L.Icon.Default.imagePath;
 /** @type {!L.Icon.DefaultIconOptions} */
L.Icon.Default.prototype.options;

/**
 * @param {!L.IconOptions} options
 * @return {!L.Icon}
 */
L.icon = function(options) {};
/**
 * @extends {L.BaseIconOptions}
 * @record
 * @struct
 */
L.DivIconOptions = function() {};
 /** @type {(string|boolean)} */
L.DivIconOptions.prototype.html;
 /** @type {(!L.Point|!Array<?>)} */
L.DivIconOptions.prototype.bgPos;
 /** @type {(!L.Point|!Array<?>)} */
L.DivIconOptions.prototype.iconSize;
 /** @type {(!L.Point|!Array<?>)} */
L.DivIconOptions.prototype.iconAnchor;
 /** @type {(!L.Point|!Array<?>)} */
L.DivIconOptions.prototype.popupAnchor;
 /** @type {string} */
L.DivIconOptions.prototype.className;

/**
 * @constructor
 * @struct
 * @param {!L.DivIconOptions=} options
 */
L.DivIcon = function(options) {};
 /** @type {!L.DivIconOptions} */
L.DivIcon.prototype.options;

/**
 * @param {!L.DivIconOptions=} options
 * @return {!L.DivIcon}
 */
L.divIcon = function(options) {};
/**
 * @extends {L.InteractiveLayerOptions}
 * @record
 * @struct
 */
L.MarkerOptions = function() {};
 /** @type {(!L.Icon|!L.DivIcon)} */
L.MarkerOptions.prototype.icon;
 /** @type {boolean} */
L.MarkerOptions.prototype.clickable;
 /** @type {boolean} */
L.MarkerOptions.prototype.draggable;
 /** @type {boolean} */
L.MarkerOptions.prototype.keyboard;
 /** @type {string} */
L.MarkerOptions.prototype.title;
 /** @type {string} */
L.MarkerOptions.prototype.alt;
 /** @type {number} */
L.MarkerOptions.prototype.zIndexOffset;
 /** @type {number} */
L.MarkerOptions.prototype.opacity;
 /** @type {boolean} */
L.MarkerOptions.prototype.riseOnHover;
 /** @type {number} */
L.MarkerOptions.prototype.riseOffset;

/**
 * @constructor
 * @struct
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {!L.MarkerOptions=} options
 */
L.Marker = function(latlng, options) {};
 /** @type {!L.MarkerOptions} */
L.Marker.prototype.options;
 /** @type {!L.Handler} */
L.Marker.prototype.dragging;

/**
 * @return {!L.LatLng}
 */
L.Marker.prototype.getLatLng = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @return {Marker}
 */
L.Marker.prototype.setLatLng = function(latlng) {};

/**
 * @param {number} offset
 * @return {Marker}
 */
L.Marker.prototype.setZIndexOffset = function(offset) {};

/**
 * @param {(!L.Icon|!L.DivIcon)} icon
 * @return {Marker}
 */
L.Marker.prototype.setIcon = function(icon) {};

/**
 * @param {number} opacity
 * @return {Marker}
 */
L.Marker.prototype.setOpacity = function(opacity) {};

/**
 * @return {!HTMLElement}
 */
L.Marker.prototype.getElement = function() {};

/**
 * @param {(!Array<?>|!L.LatLng|!L.LatLngLiteral)} latlng
 * @param {!L.MarkerOptions=} options
 * @return {!L.Marker}
 */
L.marker = function(latlng, options) {};
/** @const */
L.Browser = {};
 /** @type {boolean} */
L.Browser.ie;
 /** @type {boolean} */
L.Browser.ielt9;
 /** @type {boolean} */
L.Browser.edge;
 /** @type {boolean} */
L.Browser.webkit;
 /** @type {boolean} */
L.Browser.gecko;
 /** @type {boolean} */
L.Browser.android;
 /** @type {boolean} */
L.Browser.android23;
 /** @type {boolean} */
L.Browser.chrome;
 /** @type {boolean} */
L.Browser.safari;
 /** @type {boolean} */
L.Browser.win;
 /** @type {boolean} */
L.Browser.ie3d;
 /** @type {boolean} */
L.Browser.webkit3d;
 /** @type {boolean} */
L.Browser.gecko3d;
 /** @type {boolean} */
L.Browser.opera12;
 /** @type {boolean} */
L.Browser.any3d;
 /** @type {boolean} */
L.Browser.mobile;
 /** @type {boolean} */
L.Browser.mobileWebkit;
 /** @type {boolean} */
L.Browser.mobileWebkit3d;
 /** @type {boolean} */
L.Browser.mobileOpera;
 /** @type {boolean} */
L.Browser.mobileGecko;
 /** @type {boolean} */
L.Browser.touch;
 /** @type {boolean} */
L.Browser.msPointer;
 /** @type {boolean} */
L.Browser.pointer;
 /** @type {boolean} */
L.Browser.retina;
 /** @type {boolean} */
L.Browser.canvas;
 /** @type {boolean} */
L.Browser.vml;
 /** @type {boolean} */
L.Browser.svg;
/** @const */
L.Util = {};

/**
 * @param {?} dest
 * @param {?=} src
 * @return {?}
 */
L.Util.extend = function(dest, src) {};

/**
 * @param {?} proto
 * @param {?=} properties
 * @return {?}
 */
L.Util.create = function(proto, properties) {};

/**
 * @param {function(): void} fn
 * @param {...?} obj
 * @return {function(): void}
 */
L.Util.bind = function(fn, obj) {};

/**
 * @param {?} obj
 * @return {number}
 */
L.Util.stamp = function(obj) {};

/**
 * @param {function(): void} fn
 * @param {number} time
 * @param {?} context
 * @return {function(): void}
 */
L.Util.throttle = function(fn, time, context) {};

/**
 * @param {number} num
 * @param {!Array<number>} range
 * @param {boolean=} includeMax
 * @return {number}
 */
L.Util.wrapNum = function(num, range, includeMax) {};

/**
 * @return {boolean}
 */
L.Util.falseFn = function() {};

/**
 * @param {number} num
 * @param {number=} digits
 * @return {number}
 */
L.Util.formatNum = function(num, digits) {};

/**
 * @param {string} str
 * @return {string}
 */
L.Util.trim = function(str) {};

/**
 * @param {string} str
 * @return {!Array<string>}
 */
L.Util.splitWords = function(str) {};

/**
 * @param {?} obj
 * @param {?} options
 * @return {?}
 */
L.Util.setOptions = function(obj, options) {};

/**
 * @param {?} obj
 * @param {string=} existingUrl
 * @param {boolean=} uppercase
 * @return {string}
 */
L.Util.getParamString = function(obj, existingUrl, uppercase) {};

/**
 * @param {string} str
 * @param {?} data
 * @return {string}
 */
L.Util.template = function(str, data) {};

/**
 * @param {?} obj
 * @return {boolean}
 */
L.Util.isArray = function(obj) {};

/**
 * @param {!Array<?>} array
 * @param {?} el
 * @return {number}
 */
L.Util.indexOf = function(array, el) {};

/**
 * @param {function(): void} fn
 * @param {?=} context
 * @param {boolean=} immediate
 * @return {number}
 */
L.Util.requestAnimFrame = function(fn, context, immediate) {};

/**
 * @param {number} id
 * @return {void}
 */
L.Util.cancelAnimFrame = function(id) {};
 /** @type {number} */
L.Util.lastId;
 /** @type {string} */
L.Util.emptyImageUrl;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "leaflet"
/** @const */
tsickle_declare_module.leaflet = {};

/* TODO: ExportAssignment in tsickle_declare_module.leaflet */
