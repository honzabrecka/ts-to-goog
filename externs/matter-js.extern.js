/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/matter-js/index.d.ts:

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
/** @const */
var Matter = {};
/**
 * @constructor
 * @struct
 */
Matter.Axes = function() {};

/**
 * Creates a new set of axes from the given vertices.
 * \@method fromVertices
 * @param {!Array<!Matter.Vector>} vertices
 * @return {!Array<!Matter.Vector>}
 */
Matter.Axes.fromVertices = function(vertices) {};

/**
 * Rotates a set of axes by the given angle.
 * \@method rotate
 * @param {!Array<!Matter.Vector>} axes
 * @param {number} angle
 * @return {void}
 */
Matter.Axes.rotate = function(axes, angle) {};
/**
 * @record
 * @struct
 */
Matter.IChamfer = function() {};
 /** @type {(number|!Array<number>)} */
Matter.IChamfer.prototype.radius;
 /** @type {number} */
Matter.IChamfer.prototype.quality;
 /** @type {number} */
Matter.IChamfer.prototype.qualityMin;
 /** @type {number} */
Matter.IChamfer.prototype.qualityMax;
/**
 * @extends {Matter.IBodyDefinition}
 * @record
 * @struct
 */
Matter.IChamferableBodyDefinition = function() {};
 /** @type {!Matter.IChamfer} */
Matter.IChamferableBodyDefinition.prototype.chamfer;
/**
 * @constructor
 * @struct
 */
Matter.Bodies = function() {};

/**
 * Creates a new rigid body model with a circle hull.
 * The options parameter is an object that specifies any properties you wish to override the defaults.
 * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
 * \@method circle
 * @param {number} x
 * @param {number} y
 * @param {number} radius
 * @param {!Matter.IBodyDefinition=} options
 * @param {number=} maxSides
 * @return {!Matter.Body}
 */
Matter.Bodies.circle = function(x, y, radius, options, maxSides) {};

/**
 * Creates a new rigid body model with a regular polygon hull with the given number of sides.
 * The options parameter is an object that specifies any properties you wish to override the defaults.
 * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
 * \@method polygon
 * @param {number} x
 * @param {number} y
 * @param {number} sides
 * @param {number} radius
 * @param {!Matter.IChamferableBodyDefinition=} options
 * @return {!Matter.Body}
 */
Matter.Bodies.polygon = function(x, y, sides, radius, options) {};

/**
 * Creates a new rigid body model with a rectangle hull.
 * The options parameter is an object that specifies any properties you wish to override the defaults.
 * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
 * \@method rectangle
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {!Matter.IChamferableBodyDefinition=} options
 * @return {!Matter.Body}
 */
Matter.Bodies.rectangle = function(x, y, width, height, options) {};

/**
 * Creates a new rigid body model with a trapezoid hull.
 * The options parameter is an object that specifies any properties you wish to override the defaults.
 * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
 * \@method trapezoid
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {number} slope
 * @param {!Matter.IChamferableBodyDefinition=} options
 * @return {!Matter.Body}
 */
Matter.Bodies.trapezoid = function(x, y, width, height, slope, options) {};

/**
 * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
 * If the vertices are convex, they will pass through as supplied.
 * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
 * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
 * By default the decomposition will discard collinear edges (to improve performance).
 * It can also optionally discard any parts that have an area less than `minimumArea`.
 * If the vertices can not be decomposed, the result will fall back to using the convex hull.
 * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
 * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
 * \@method fromVertices
 * @param {number} x
 * @param {number} y
 * @param {!Array<!Array<!Matter.Vector>>} vertexSets
 * @param {!Matter.IBodyDefinition=} options
 * @param {boolean=} flagInternal
 * @param {number=} removeCollinear
 * @param {number=} minimumArea
 * @return {!Matter.Body}
 */
Matter.Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {};
/**
 * @record
 * @struct
 */
Matter.IBodyDefinition = function() {};
 /** @type {number} */
Matter.IBodyDefinition.prototype.angle;
 /** @type {number} */
Matter.IBodyDefinition.prototype.angularSpeed;
 /** @type {number} */
Matter.IBodyDefinition.prototype.angularVelocity;
 /** @type {number} */
Matter.IBodyDefinition.prototype.area;
 /** @type {!Array<!Matter.Vector>} */
Matter.IBodyDefinition.prototype.axes;
 /** @type {!Matter.Bounds} */
Matter.IBodyDefinition.prototype.bounds;
 /** @type {number} */
Matter.IBodyDefinition.prototype.density;
 /** @type {!Matter.Vector} */
Matter.IBodyDefinition.prototype.force;
 /** @type {number} */
Matter.IBodyDefinition.prototype.friction;
 /** @type {number} */
Matter.IBodyDefinition.prototype.frictionAir;
 /** @type {number} */
Matter.IBodyDefinition.prototype.id;
 /** @type {number} */
Matter.IBodyDefinition.prototype.inertia;
 /** @type {number} */
Matter.IBodyDefinition.prototype.inverseInertia;
 /** @type {number} */
Matter.IBodyDefinition.prototype.inverseMass;
 /** @type {boolean} */
Matter.IBodyDefinition.prototype.isSensor;
 /** @type {boolean} */
Matter.IBodyDefinition.prototype.isSleeping;
 /** @type {boolean} */
Matter.IBodyDefinition.prototype.isStatic;
 /** @type {string} */
Matter.IBodyDefinition.prototype.label;
 /** @type {number} */
Matter.IBodyDefinition.prototype.mass;
 /** @type {number} */
Matter.IBodyDefinition.prototype.motion;
 /** @type {!Matter.Vector} */
Matter.IBodyDefinition.prototype.position;
 /** @type {!Matter.IBodyRenderOptions} */
Matter.IBodyDefinition.prototype.render;
 /** @type {number} */
Matter.IBodyDefinition.prototype.restitution;
 /** @type {number} */
Matter.IBodyDefinition.prototype.sleepThreshold;
 /** @type {number} */
Matter.IBodyDefinition.prototype.slop;
 /** @type {number} */
Matter.IBodyDefinition.prototype.speed;
 /** @type {number} */
Matter.IBodyDefinition.prototype.timeScale;
 /** @type {number} */
Matter.IBodyDefinition.prototype.torque;
 /** @type {string} */
Matter.IBodyDefinition.prototype.type;
 /** @type {!Matter.Vector} */
Matter.IBodyDefinition.prototype.velocity;
 /** @type {!Array<!Matter.Vector>} */
Matter.IBodyDefinition.prototype.vertices;
 /** @type {!Array<!Matter.Body>} */
Matter.IBodyDefinition.prototype.parts;
 /** @type {!Matter.Body} */
Matter.IBodyDefinition.prototype.parent;
 /** @type {number} */
Matter.IBodyDefinition.prototype.frictionStatic;
 /** @type {!Matter.ICollisionFilter} */
Matter.IBodyDefinition.prototype.collisionFilter;
/**
 * @record
 * @struct
 */
Matter.IBodyRenderOptions = function() {};
 /** @type {boolean} */
Matter.IBodyRenderOptions.prototype.visible;
 /** @type {!Matter.IBodyRenderOptionsSprite} */
Matter.IBodyRenderOptions.prototype.sprite;
 /** @type {string} */
Matter.IBodyRenderOptions.prototype.fillStyle;
 /** @type {number} */
Matter.IBodyRenderOptions.prototype.lineWidth;
 /** @type {string} */
Matter.IBodyRenderOptions.prototype.strokeStyle;
 /** @type {number} */
Matter.IBodyRenderOptions.prototype.opacity;
/**
 * @record
 * @struct
 */
Matter.IBodyRenderOptionsSprite = function() {};
 /** @type {string} */
Matter.IBodyRenderOptionsSprite.prototype.texture;
 /** @type {number} */
Matter.IBodyRenderOptionsSprite.prototype.xScale;
 /** @type {number} */
Matter.IBodyRenderOptionsSprite.prototype.yScale;
/**
 * @constructor
 * @struct
 */
Matter.Body = function() {};
 /** @type {number} */
Matter.Body.prototype.angle;
 /** @type {number} */
Matter.Body.prototype.angularSpeed;
 /** @type {number} */
Matter.Body.prototype.angularVelocity;
 /** @type {number} */
Matter.Body.prototype.area;
 /** @type {!Array<!Matter.Vector>} */
Matter.Body.prototype.axes;
 /** @type {!Matter.Bounds} */
Matter.Body.prototype.bounds;
 /** @type {number} */
Matter.Body.prototype.density;
 /** @type {!Matter.Vector} */
Matter.Body.prototype.force;
 /** @type {number} */
Matter.Body.prototype.friction;
 /** @type {number} */
Matter.Body.prototype.frictionAir;
 /** @type {number} */
Matter.Body.prototype.id;
 /** @type {number} */
Matter.Body.prototype.inertia;
 /** @type {number} */
Matter.Body.prototype.inverseInertia;
 /** @type {number} */
Matter.Body.prototype.inverseMass;
 /** @type {boolean} */
Matter.Body.prototype.isSleeping;
 /** @type {boolean} */
Matter.Body.prototype.isStatic;
 /** @type {string} */
Matter.Body.prototype.label;
 /** @type {number} */
Matter.Body.prototype.mass;
 /** @type {number} */
Matter.Body.prototype.motion;
 /** @type {!Matter.Vector} */
Matter.Body.prototype.position;
 /** @type {!Matter.IBodyRenderOptions} */
Matter.Body.prototype.render;
 /** @type {number} */
Matter.Body.prototype.restitution;
 /** @type {number} */
Matter.Body.prototype.sleepThreshold;
 /** @type {number} */
Matter.Body.prototype.slop;
 /** @type {number} */
Matter.Body.prototype.speed;
 /** @type {number} */
Matter.Body.prototype.timeScale;
 /** @type {number} */
Matter.Body.prototype.torque;
 /** @type {string} */
Matter.Body.prototype.type;
 /** @type {!Matter.Vector} */
Matter.Body.prototype.velocity;
 /** @type {!Array<!Matter.Vector>} */
Matter.Body.prototype.vertices;
 /** @type {!Array<!Matter.Body>} */
Matter.Body.prototype.parts;
 /** @type {!Matter.Body} */
Matter.Body.prototype.parent;
 /** @type {number} */
Matter.Body.prototype.frictionStatic;
 /** @type {!Matter.ICollisionFilter} */
Matter.Body.prototype.collisionFilter;

/**
 * Applies a force to a body from a given world-space position, including resulting torque.
 * \@method applyForce
 * @param {!Matter.Body} body
 * @param {!Matter.Vector} position
 * @param {!Matter.Vector} force
 * @return {void}
 */
Matter.Body.applyForce = function(body, position, force) {};

/**
 * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
 * All properties have default values, and many are pre-calculated automatically based on other properties.
 * See the properties section below for detailed information on what you can pass via the `options` object.
 * \@method create
 * @param {!Matter.IBodyDefinition} options
 * @return {!Matter.Body}
 */
Matter.Body.create = function(options) {};

/**
 * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
 * \@method rotate
 * @param {!Matter.Body} body
 * @param {number} rotation
 * @return {void}
 */
Matter.Body.rotate = function(body, rotation) {};

/**
 * Returns the next unique group index for which bodies will collide.
 * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
 * See `body.collisionFilter` for more information.
 * \@method nextGroup
 * @param {boolean} isNonColliding
 * @return {number}
 */
Matter.Body.nextGroup = function(isNonColliding) {};

/**
 * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
 * There are 32 available. See `body.collisionFilter` for more information.
 * \@method nextCategory
 * @return {number}
 */
Matter.Body.nextCategory = function() {};

/**
 * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
 * Prefer to use the actual setter functions in performance critical situations.
 * \@method set
 * @param {!Matter.Body} body
 * @param {?} settings
 * @param {?=} value
 * @return {void}
 */
Matter.Body.set = function(body, settings, value) {};

/**
 * Sets the mass of the body. Inverse mass and density are automatically updated to reflect the change.
 * \@method setMass
 * @param {!Matter.Body} body
 * @param {number} mass
 * @return {void}
 */
Matter.Body.setMass = function(body, mass) {};

/**
 * Sets the density of the body. Mass is automatically updated to reflect the change.
 * \@method setDensity
 * @param {!Matter.Body} body
 * @param {number} density
 * @return {void}
 */
Matter.Body.setDensity = function(body, density) {};

/**
 * Sets the moment of inertia (i.e. second moment of area) of the body of the body.
 * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
 * \@method setInertia
 * @param {!Matter.Body} body
 * @param {number} interna
 * @return {void}
 */
Matter.Body.setInertia = function(body, interna) {};

/**
 * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
 * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
 * They are then automatically translated to world space based on `body.position`.
 * 
 * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
 * Vertices must form a convex hull, concave hulls are not supported.
 * 
 * \@method setVertices
 * @param {!Matter.Body} body
 * @param {!Array<!Matter.Vector>} vertices
 * @return {void}
 */
Matter.Body.setVertices = function(body, vertices) {};

/**
 * Sets the parts of the `body` and updates mass, inertia and centroid.
 * Each part will have its parent set to `body`.
 * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
 * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
 * \@method setParts
 * @param {!Matter.Body} body
 * @param {!Array<!Matter.Body>} parts
 * @param {boolean=} autoHull
 * @return {void}
 */
Matter.Body.setParts = function(body, parts, autoHull) {};

/**
 * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
 * \@method setPosition
 * @param {!Matter.Body} body
 * @param {!Matter.Vector} position
 * @return {void}
 */
Matter.Body.setPosition = function(body, position) {};

/**
 * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
 * \@method setAngle
 * @param {!Matter.Body} body
 * @param {number} angle
 * @return {void}
 */
Matter.Body.setAngle = function(body, angle) {};

/**
 * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
 * \@method setVelocity
 * @param {!Matter.Body} body
 * @param {!Matter.Vector} velocity
 * @return {void}
 */
Matter.Body.setVelocity = function(body, velocity) {};

/**
 * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
 * \@method setAngularVelocity
 * @param {!Matter.Body} body
 * @param {number} velocity
 * @return {void}
 */
Matter.Body.setAngularVelocity = function(body, velocity) {};

/**
 * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
 * \@method setStatic
 * @param {!Matter.Body} body
 * @param {boolean} isStatic
 * @return {void}
 */
Matter.Body.setStatic = function(body, isStatic) {};

/**
 * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
 * \@method scale
 * @param {!Matter.Body} body
 * @param {number} scaleX
 * @param {number} scaleY
 * @param {!Matter.Vector=} point
 * @return {void}
 */
Matter.Body.scale = function(body, scaleX, scaleY, point) {};

/**
 * Moves a body by a given vector relative to its current position, without imparting any velocity.
 * \@method translate
 * @param {!Matter.Body} body
 * @param {!Matter.Vector} translation
 * @return {void}
 */
Matter.Body.translate = function(body, translation) {};

/**
 * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
 * \@method update
 * @param {!Matter.Body} body
 * @param {number} deltaTime
 * @param {number} timeScale
 * @param {number} correction
 * @return {void}
 */
Matter.Body.update = function(body, deltaTime, timeScale, correction) {};
/**
 * @record
 * @struct
 */
Matter.IBound = function() {};
 /** @type {{x: number, y: number}} */
Matter.IBound.prototype.min;
 /** @type {{x: number, y: number}} */
Matter.IBound.prototype.max;
/**
 * @constructor
 * @struct
 */
Matter.Bounds = function() {};

/**
 * Creates a new axis-aligned bounding box (AABB) for the given vertices.
 * \@method create
 * @param {!Matter.Vertices} vertices
 * @return {!Matter.Bounds}
 */
Matter.Bounds.create = function(vertices) {};

/**
 * Updates bounds using the given vertices and extends the bounds given a velocity.
 * \@method update
 * @param {!Matter.Bounds} bounds
 * @param {!Matter.Vertices} vertices
 * @param {!Matter.Vector} velocity
 * @return {void}
 */
Matter.Bounds.update = function(bounds, vertices, velocity) {};

/**
 * Returns true if the bounds contains the given point.
 * \@method contains
 * @param {!Matter.Bounds} bounds
 * @param {!Matter.Vector} point
 * @return {boolean}
 */
Matter.Bounds.contains = function(bounds, point) {};

/**
 * Returns true if the two bounds intersect.
 * \@method overlaps
 * @param {!Matter.Bounds} boundsA
 * @param {!Matter.Bounds} boundsB
 * @return {boolean}
 */
Matter.Bounds.overlaps = function(boundsA, boundsB) {};

/**
 * Translates the bounds by the given vector.
 * \@method translate
 * @param {!Matter.Bounds} bounds
 * @param {!Matter.Vector} vector
 * @return {void}
 */
Matter.Bounds.translate = function(bounds, vector) {};

/**
 * Shifts the bounds to the given position.
 * \@method shift
 * @param {!Matter.Bounds} bounds
 * @param {!Matter.Vector} position
 * @return {void}
 */
Matter.Bounds.shift = function(bounds, position) {};
/**
 * @record
 * @struct
 */
Matter.ICompositeDefinition = function() {};
 /** @type {!Array<!Matter.Body>} */
Matter.ICompositeDefinition.prototype.bodies;
 /** @type {!Array<!Matter.Composite>} */
Matter.ICompositeDefinition.prototype.composites;
 /** @type {!Array<!Matter.Constraint>} */
Matter.ICompositeDefinition.prototype.constraints;
 /** @type {number} */
Matter.ICompositeDefinition.prototype.id;
 /** @type {boolean} */
Matter.ICompositeDefinition.prototype.isModified;
 /** @type {string} */
Matter.ICompositeDefinition.prototype.label;
 /** @type {!Matter.Composite} */
Matter.ICompositeDefinition.prototype.parent;
 /** @type {!String} */
Matter.ICompositeDefinition.prototype.type;
/**
 * @constructor
 * @struct
 */
Matter.Composite = function() {};
 /** @type {!Array<!Matter.Body>} */
Matter.Composite.prototype.bodies;
 /** @type {!Array<!Matter.Composite>} */
Matter.Composite.prototype.composites;
 /** @type {!Array<!Matter.Constraint>} */
Matter.Composite.prototype.constraints;
 /** @type {number} */
Matter.Composite.prototype.id;
 /** @type {boolean} */
Matter.Composite.prototype.isModified;
 /** @type {string} */
Matter.Composite.prototype.label;
 /** @type {!Matter.Composite} */
Matter.Composite.prototype.parent;
 /** @type {!String} */
Matter.Composite.prototype.type;

/**
 * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
 * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
 * \@method add
 * @param {!Matter.Composite} composite
 * @param {(!Matter.Body|!Matter.Composite|!Matter.Constraint)} object
 * @return {!Matter.Composite}
 */
Matter.Composite.add = function(composite, object) {};

/**
 * Returns all bodies in the given composite, including all bodies in its children, recursively.
 * \@method allBodies
 * @param {!Matter.Composite} composite
 * @return {!Array<!Matter.Body>}
 */
Matter.Composite.allBodies = function(composite) {};

/**
 * Returns all composites in the given composite, including all composites in its children, recursively.
 * \@method allComposites
 * @param {!Matter.Composite} composite
 * @return {!Array<!Matter.Composite>}
 */
Matter.Composite.allComposites = function(composite) {};

/**
 * Returns all constraints in the given composite, including all constraints in its children, recursively.
 * \@method allConstraints
 * @param {!Matter.Composite} composite
 * @return {!Array<!Matter.Composite>}
 */
Matter.Composite.allConstraints = function(composite) {};

/**
 * Removes all bodies, constraints and composites from the given composite.
 * Optionally clearing its children recursively.
 * \@method clear
 * @param {!Matter.Composite} composite
 * @param {boolean} keepStatic
 * @param {boolean=} deep
 * @return {void}
 */
Matter.Composite.clear = function(composite, keepStatic, deep) {};

/**
 * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
 * See the properites section below for detailed information on what you can pass via the `options` object.
 * \@method create
 * @param {!Matter.ICompositeDefinition=} options
 * @return {!Matter.Composite}
 */
Matter.Composite.create = function(options) {};

/**
 * Searches the composite recursively for an object matching the type and id supplied, null if not found.
 * \@method get
 * @param {!Matter.Composite} composite
 * @param {number} id
 * @param {string} type
 * @return {(!Matter.Body|!Matter.Composite|!Matter.Constraint)}
 */
Matter.Composite.get = function(composite, id, type) {};

/**
 * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
 * \@method move
 * @param {!Matter.Composite} compositeA
 * @param {!Array<(!Matter.Body|!Matter.Composite|!Matter.Constraint)>} objects
 * @param {!Matter.Composite} compositeB
 * @return {!Matter.Composite}
 */
Matter.Composite.move = function(compositeA, objects, compositeB) {};

/**
 * Assigns new ids for all objects in the composite, recursively.
 * \@method rebase
 * @param {!Matter.Composite} composite
 * @return {!Matter.Composite}
 */
Matter.Composite.rebase = function(composite) {};

/**
 * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
 * Optionally searching its children recursively.
 * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
 * \@method remove
 * @param {!Matter.Composite} composite
 * @param {(!Matter.Body|!Matter.Composite|!Matter.Constraint)} object
 * @param {boolean=} deep
 * @return {!Matter.Composite}
 */
Matter.Composite.remove = function(composite, object, deep) {};

/**
 * Sets the composite's `isModified` flag.
 * If `updateParents` is true, all parents will be set (default: false).
 * If `updateChildren` is true, all children will be set (default: false).
 * \@method setModified
 * @param {!Matter.Composite} composite
 * @param {boolean} isModified
 * @param {boolean=} updateParents
 * @param {boolean=} updateChildren
 * @return {void}
 */
Matter.Composite.setModified = function(composite, isModified, updateParents, updateChildren) {};

/**
 * Translates all children in the composite by a given vector relative to their current positions,
 * without imparting any velocity.
 * \@method translate
 * @param {!Matter.Composite} composite
 * @param {!Matter.Vector} translation
 * @param {boolean=} recursive
 * @return {void}
 */
Matter.Composite.translate = function(composite, translation, recursive) {};

/**
 * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
 * \@method rotate
 * @param {!Matter.Composite} composite
 * @param {number} rotation
 * @param {!Matter.Vector} point
 * @param {boolean=} recursive
 * @return {void}
 */
Matter.Composite.rotate = function(composite, rotation, point, recursive) {};

/**
 * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
 * \@method scale
 * @param {!Matter.Composite} composite
 * @param {number} scaleX
 * @param {number} scaleY
 * @param {!Matter.Vector} point
 * @param {boolean=} recursive
 * @return {void}
 */
Matter.Composite.scale = function(composite, scaleX, scaleY, point, recursive) {};
/**
 * @constructor
 * @struct
 */
Matter.Composites = function() {};

/**
 * Creates a composite with simple car setup of bodies and constraints.
 * \@method car
 * @param {number} xx
 * @param {number} yy
 * @param {number} width
 * @param {number} height
 * @param {number} wheelSize
 * @return {!Matter.Composite}
 */
Matter.Composites.car = function(xx, yy, width, height, wheelSize) {};

/**
 * Chains all bodies in the given composite together using constraints.
 * \@method chain
 * @param {!Matter.Composite} composite
 * @param {number} xOffsetA
 * @param {number} yOffsetA
 * @param {number} xOffsetB
 * @param {number} yOffsetB
 * @param {?} options
 * @return {!Matter.Composite}
 */
Matter.Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {};

/**
 * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
 * \@method mesh
 * @param {!Matter.Composite} composite
 * @param {number} columns
 * @param {number} rows
 * @param {boolean} crossBrace
 * @param {?} options
 * @return {!Matter.Composite}
 */
Matter.Composites.mesh = function(composite, columns, rows, crossBrace, options) {};

/**
 * Creates a composite with a Newton's Cradle setup of bodies and constraints.
 * \@method newtonsCradle
 * @param {number} xx
 * @param {number} yy
 * @param {number} _number
 * @param {number} size
 * @param {number} length
 * @return {!Matter.Composite}
 */
Matter.Composites.prototype.newtonsCradle = function(xx, yy, _number, size, length) {};

/**
 * Create a new composite containing bodies created in the callback in a pyramid arrangement.
 * This function uses the body's bounds to prevent overlaps.
 * \@method pyramid
 * @param {number} xx
 * @param {number} yy
 * @param {number} columns
 * @param {number} rows
 * @param {number} columnGap
 * @param {number} rowGap
 * @param {!Function} callback
 * @return {!Matter.Composite}
 */
Matter.Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {};

/**
 * Creates a simple soft body like object.
 * \@method softBody
 * @param {number} xx
 * @param {number} yy
 * @param {number} columns
 * @param {number} rows
 * @param {number} columnGap
 * @param {number} rowGap
 * @param {boolean} crossBrace
 * @param {number} particleRadius
 * @param {?} particleOptions
 * @param {?} constraintOptions
 * @return {!Matter.Composite}
 */
Matter.Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {};

/**
 * Create a new composite containing bodies created in the callback in a grid arrangement.
 * This function uses the body's bounds to prevent overlaps.
 * \@method stack
 * @param {number} xx
 * @param {number} yy
 * @param {number} columns
 * @param {number} rows
 * @param {number} columnGap
 * @param {number} rowGap
 * @param {!Function} callback
 * @return {!Matter.Composite}
 */
Matter.Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {};
/**
 * @record
 * @struct
 */
Matter.IConstraintDefinition = function() {};
 /** @type {!Matter.Body} */
Matter.IConstraintDefinition.prototype.bodyA;
 /** @type {!Matter.Body} */
Matter.IConstraintDefinition.prototype.bodyB;
 /** @type {number} */
Matter.IConstraintDefinition.prototype.id;
 /** @type {string} */
Matter.IConstraintDefinition.prototype.label;
 /** @type {number} */
Matter.IConstraintDefinition.prototype.length;
 /** @type {!Matter.Vector} */
Matter.IConstraintDefinition.prototype.pointA;
 /** @type {!Matter.Vector} */
Matter.IConstraintDefinition.prototype.pointB;
 /** @type {!Matter.IConstraintRenderDefinition} */
Matter.IConstraintDefinition.prototype.render;
 /** @type {number} */
Matter.IConstraintDefinition.prototype.stiffness;
 /** @type {string} */
Matter.IConstraintDefinition.prototype.type;
/**
 * @record
 * @struct
 */
Matter.IConstraintRenderDefinition = function() {};
 /** @type {number} */
Matter.IConstraintRenderDefinition.prototype.lineWidth;
 /** @type {string} */
Matter.IConstraintRenderDefinition.prototype.strokeStyle;
 /** @type {boolean} */
Matter.IConstraintRenderDefinition.prototype.visible;
/**
 * @constructor
 * @struct
 */
Matter.Constraint = function() {};
 /** @type {!Matter.Body} */
Matter.Constraint.prototype.bodyA;
 /** @type {!Matter.Body} */
Matter.Constraint.prototype.bodyB;
 /** @type {number} */
Matter.Constraint.prototype.id;
 /** @type {string} */
Matter.Constraint.prototype.label;
 /** @type {number} */
Matter.Constraint.prototype.length;
 /** @type {!Matter.Vector} */
Matter.Constraint.prototype.pointA;
 /** @type {!Matter.Vector} */
Matter.Constraint.prototype.pointB;
 /** @type {!Matter.IConstraintRenderDefinition} */
Matter.Constraint.prototype.render;
 /** @type {number} */
Matter.Constraint.prototype.stiffness;
 /** @type {string} */
Matter.Constraint.prototype.type;

/**
 * Creates a new constraint.
 * All properties have default values, and many are pre-calculated automatically based on other properties.
 * See the properties section below for detailed information on what you can pass via the `options` object.
 * \@method create
 * @param {!Matter.IConstraintDefinition} options
 * @return {!Matter.Constraint}
 */
Matter.Constraint.create = function(options) {};
/**
 * @record
 * @struct
 */
Matter.IEngineDefinition = function() {};
 /** @type {number} */
Matter.IEngineDefinition.prototype.positionIterations;
 /** @type {number} */
Matter.IEngineDefinition.prototype.velocityIterations;
 /** @type {number} */
Matter.IEngineDefinition.prototype.constraintIterations;
 /** @type {boolean} */
Matter.IEngineDefinition.prototype.enableSleeping;
 /** @type {!Matter.IEngineTimingOptions} */
Matter.IEngineDefinition.prototype.timing;
 /** @type {!Matter.Grid} */
Matter.IEngineDefinition.prototype.grid;
 /** @type {!Matter.World} */
Matter.IEngineDefinition.prototype.world;
/**
 * @record
 * @struct
 */
Matter.IEngineTimingOptions = function() {};
 /** @type {number} */
Matter.IEngineTimingOptions.prototype.timeScale;
 /** @type {number} */
Matter.IEngineTimingOptions.prototype.timestamp;
/**
 * @constructor
 * @struct
 */
Matter.Engine = function() {};
 /** @type {!Matter.Grid} */
Matter.Engine.prototype.broadphase;
 /** @type {number} */
Matter.Engine.prototype.constraintIterations;
 /** @type {boolean} */
Matter.Engine.prototype.enabled;
 /** @type {boolean} */
Matter.Engine.prototype.enableSleeping;
 /** @type {?} */
Matter.Engine.prototype.pairs;
 /** @type {number} */
Matter.Engine.prototype.positionIterations;
 /** @type {!Matter.Render} */
Matter.Engine.prototype.render;
 /** @type {!Matter.IEngineTimingOptions} */
Matter.Engine.prototype.timing;
 /** @type {number} */
Matter.Engine.prototype.velocityIterations;
 /** @type {!Matter.World} */
Matter.Engine.prototype.world;

/**
 * Clears the engine including the world, pairs and broadphase.
 * \@method clear
 * @param {!Matter.Engine} engine
 * @return {void}
 */
Matter.Engine.clear = function(engine) {};

/**
 * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
 * All properties have default values, and many are pre-calculated automatically based on other properties.
 * See the properties section below for detailed information on what you can pass via the `options` object.
 * \@method create
 * @deprecated
 * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
 * All properties have default values, and many are pre-calculated automatically based on other properties.
 * See the properties section below for detailed information on what you can pass via the `options` object.
 * \@method create
 * @param {(!HTMLElement|!Matter.IEngineDefinition)|!Matter.IEngineDefinition=} element_or_options
 * @param {!Matter.IEngineDefinition=} options
 * @return {!Matter.Engine}
 */
Matter.Engine.create = function(element_or_options, options) {};

/**
 * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
 * \@method merge
 * @param {!Matter.Engine} engineA
 * @param {!Matter.Engine} engineB
 * @return {void}
 */
Matter.Engine.merge = function(engineA, engineB) {};

/**
 * Moves the simulation forward in time by `delta` ms.
 * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
 * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
 * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
 * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
 * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
 * 
 * Triggers `beforeUpdate` and `afterUpdate` events.
 * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
 * \@method update
 * @param {!Matter.Engine} engine
 * @param {number=} delta
 * @param {number=} correction
 * @return {!Matter.Engine}
 */
Matter.Engine.update = function(engine, delta, correction) {};

/**
 * An alias for `Runner.run`, see `Matter.Runner` for more information.
 * \@method run
 * @param {!Matter.Engine} enige
 * @return {void}
 */
Matter.Engine.run = function(enige) {};
/**
 * @record
 * @struct
 */
Matter.IGridDefinition = function() {};
/**
 * @constructor
 * @struct
 */
Matter.Grid = function() {};

/**
 * Creates a new grid.
 * \@method create
 * @param {!Matter.IGridDefinition=} options
 * @return {!Matter.Grid}
 */
Matter.Grid.create = function(options) {};

/**
 * Updates the grid.
 * \@method update
 * @param {!Matter.Grid} grid
 * @param {!Array<!Matter.Body>} bodies
 * @param {!Matter.Engine} engine
 * @param {boolean} forceUpdate
 * @return {void}
 */
Matter.Grid.update = function(grid, bodies, engine, forceUpdate) {};

/**
 * Clears the grid.
 * \@method clear
 * @param {!Matter.Grid} grid
 * @return {void}
 */
Matter.Grid.clear = function(grid) {};
/**
 * @record
 * @struct
 */
Matter.IMouseConstraintDefinition = function() {};
 /** @type {!Matter.Constraint} */
Matter.IMouseConstraintDefinition.prototype.constraint;
 /** @type {!Matter.ICollisionFilter} */
Matter.IMouseConstraintDefinition.prototype.collisionFilter;
 /** @type {!Matter.Body} */
Matter.IMouseConstraintDefinition.prototype.body;
 /** @type {!Matter.Mouse} */
Matter.IMouseConstraintDefinition.prototype.mouse;
 /** @type {string} */
Matter.IMouseConstraintDefinition.prototype.type;
/**
 * @constructor
 * @struct
 */
Matter.MouseConstraint = function() {};
 /** @type {!Matter.Constraint} */
Matter.MouseConstraint.prototype.constraint;
 /** @type {!Matter.ICollisionFilter} */
Matter.MouseConstraint.prototype.collisionFilter;
 /** @type {!Matter.Body} */
Matter.MouseConstraint.prototype.body;
 /** @type {!Matter.Mouse} */
Matter.MouseConstraint.prototype.mouse;
 /** @type {string} */
Matter.MouseConstraint.prototype.type;

/**
 * Creates a new mouse constraint.
 * All properties have default values, and many are pre-calculated automatically based on other properties.
 * See the properties section below for detailed information on what you can pass via the `options` object.
 * \@method create
 * @param {!Matter.Engine} engine
 * @param {!Matter.IMouseConstraintDefinition=} options
 * @return {!Matter.MouseConstraint}
 */
Matter.MouseConstraint.create = function(engine, options) {};
/**
 * @constructor
 * @struct
 */
Matter.Pairs = function() {};

/**
 * Clears the given pairs structure.
 * \@method clear
 * @param {?} pairs
 * @return {?}
 */
Matter.Pairs.clear = function(pairs) {};
/**
 * @record
 * @struct
 */
Matter.IPair = function() {};
 /** @type {number} */
Matter.IPair.prototype.id;
 /** @type {!Matter.Body} */
Matter.IPair.prototype.bodyA;
 /** @type {!Matter.Body} */
Matter.IPair.prototype.bodyB;
 /** @type {?} */
Matter.IPair.prototype.contacts;
 /** @type {?} */
Matter.IPair.prototype.activeContacts;
 /** @type {number} */
Matter.IPair.prototype.separation;
 /** @type {boolean} */
Matter.IPair.prototype.isActive;
 /** @type {number} */
Matter.IPair.prototype.timeCreated;
 /** @type {number} */
Matter.IPair.prototype.timeUpdated;
 /** @type {number} */
Matter.IPair.prototype.inverseMass;
 /** @type {number} */
Matter.IPair.prototype.friction;
 /** @type {number} */
Matter.IPair.prototype.frictionStatic;
 /** @type {number} */
Matter.IPair.prototype.restitution;
 /** @type {number} */
Matter.IPair.prototype.slop;
/**
 * @constructor
 * @struct
 */
Matter.Query = function() {};

/**
 * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
 * \@method ray
 * @param {!Array<!Matter.Body>} bodies
 * @param {!Matter.Vector} startPoint
 * @param {!Matter.Vector} endPoint
 * @param {number=} rayWidth
 * @return {!Array<?>}
 */
Matter.Query.ray = function(bodies, startPoint, endPoint, rayWidth) {};

/**
 * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
 * \@method region
 * @param {!Array<!Matter.Body>} bodies
 * @param {!Matter.Bounds} bounds
 * @param {boolean=} outside
 * @return {!Array<!Matter.Body>}
 */
Matter.Query.region = function(bodies, bounds, outside) {};

/**
 * Returns all bodies whose vertices contain the given point, from the given set of bodies.
 * \@method point
 * @param {!Array<!Matter.Body>} bodies
 * @param {!Matter.Vector} point
 * @return {!Array<!Matter.Body>}
 */
Matter.Query.point = function(bodies, point) {};
/**
 * @record
 * @struct
 */
Matter.IRenderDefinition = function() {};
 /** @type {?} */
Matter.IRenderDefinition.prototype.controller;
 /** @type {!Matter.Engine} */
Matter.IRenderDefinition.prototype.engine;
 /** @type {!HTMLElement} */
Matter.IRenderDefinition.prototype.element;
 /** @type {!HTMLCanvasElement} */
Matter.IRenderDefinition.prototype.canvas;
 /** @type {!Matter.IRendererOptions} */
Matter.IRenderDefinition.prototype.options;
 /** @type {!Matter.Bounds} */
Matter.IRenderDefinition.prototype.bounds;
 /** @type {!CanvasRenderingContext2D} */
Matter.IRenderDefinition.prototype.context;
 /** @type {?} */
Matter.IRenderDefinition.prototype.textures;
/**
 * @record
 * @struct
 */
Matter.IRendererOptions = function() {};
 /** @type {number} */
Matter.IRendererOptions.prototype.width;
 /** @type {number} */
Matter.IRendererOptions.prototype.height;
 /** @type {boolean} */
Matter.IRendererOptions.prototype.hasBounds;
 /** @type {boolean} */
Matter.IRendererOptions.prototype.wireframes;
/**
 * @constructor
 * @struct
 */
Matter.Render = function() {};
 /** @type {?} */
Matter.Render.prototype.controller;
 /** @type {!HTMLElement} */
Matter.Render.prototype.element;
 /** @type {!HTMLCanvasElement} */
Matter.Render.prototype.canvas;
 /** @type {!Matter.IRendererOptions} */
Matter.Render.prototype.options;
 /** @type {!Matter.Bounds} */
Matter.Render.prototype.bounds;
 /** @type {!CanvasRenderingContext2D} */
Matter.Render.prototype.context;
 /** @type {?} */
Matter.Render.prototype.textures;

/**
 * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.
 * All properties have default values, and many are pre-calculated automatically based on other properties.
 * See the properties section below for detailed information on what you can pass via the `options` object.
 * \@method create
 * @param {!Matter.IRenderDefinition} options
 * @return {!Matter.Render}
 */
Matter.Render.create = function(options) {};

/**
 * Continuously updates the render canvas on the `requestAnimationFrame` event.
 * \@method run
 * @param {!Matter.Render} render
 * @return {void}
 */
Matter.Render.run = function(render) {};

/**
 * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
 * \@method stop
 * @param {!Matter.Render} render
 * @return {void}
 */
Matter.Render.stop = function(render) {};

/**
 * Sets the pixel ratio of the renderer and updates the canvas.
 * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.
 * \@method setPixelRatio
 * @param {!Matter.Render} render
 * @param {number} pixelRatio
 * @return {void}
 */
Matter.Render.setPixelRatio = function(render, pixelRatio) {};

/**
 * Renders the given `engine`'s `Matter.World` object.
 * This is the entry point for all rendering and should be called every time the scene changes.
 * \@method world
 * @param {!Matter.Render} render
 * @return {void}
 */
Matter.Render.world = function(render) {};
/**
 * @record
 * @struct
 */
Matter.IRunnerOptions = function() {};
 /** @type {boolean} */
Matter.IRunnerOptions.prototype.isFixed;
 /** @type {number} */
Matter.IRunnerOptions.prototype.delta;
/**
 * @constructor
 * @struct
 */
Matter.Runner = function() {};
 /** @type {boolean} */
Matter.Runner.prototype.enabled;
 /** @type {boolean} */
Matter.Runner.prototype.isFixed;
 /** @type {number} */
Matter.Runner.prototype.delta;

/**
 * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
 * \@method create
 * @param {!Matter.IRunnerOptions} options
 * @return {!Matter.Runner}
 */
Matter.Runner.create = function(options) {};

/**
 * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
 * \@method run
 * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
 * \@method run
 * @param {!Matter.Runner|!Matter.Engine} runner_or_engine
 * @param {!Matter.Engine=} engine
 * @return {!Matter.Runner}
 */
Matter.Runner.run = function(runner_or_engine, engine) {};

/**
 * A game loop utility that updates the engine and renderer by one step (a 'tick').
 * Features delta smoothing, time correction and fixed or dynamic timing.
 * Triggers `beforeTick`, `tick` and `afterTick` events on the engine.
 * Consider just `Engine.update(engine, delta)` if you're using your own loop.
 * \@method tick
 * @param {!Matter.Runner} runner
 * @param {!Matter.Engine} engine
 * @param {number} time
 * @return {void}
 */
Matter.Runner.tick = function(runner, engine, time) {};

/**
 * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.
 * If you wish to only temporarily pause the engine, see `engine.enabled` instead.
 * \@method stop
 * @param {!Matter.Runner} runner
 * @return {void}
 */
Matter.Runner.stop = function(runner) {};

/**
 * Alias for `Runner.run`.
 * \@method start
 * @param {!Matter.Runner} runner
 * @param {!Matter.Engine} engine
 * @return {void}
 */
Matter.Runner.start = function(runner, engine) {};
/**
 * @constructor
 * @struct
 */
Matter.Sleeping = function() {};

/**
 * @param {!Matter.Body} body
 * @param {boolean} isSleeping
 * @return {void}
 */
Matter.Sleeping.set = function(body, isSleeping) {};
/**
 * @constructor
 * @struct
 */
Matter.Svg = function() {};

/**
 * Converts an SVG path into an array of vector points.
 * If the input path forms a concave shape, you must decompose the result into convex parts before use.
 * See `Bodies.fromVertices` which provides support for this.
 * Note that this function is not guaranteed to support complex paths (such as those with holes).
 * \@method pathToVertices
 * @param {!SVGPathElement} path
 * @param {number} sampleLength
 * @return {!Array<!Matter.Vector>}
 */
Matter.Svg.pathToVertices = function(path, sampleLength) {};
/**
 * @constructor
 * @struct
 */
Matter.Vector = function() {};
 /** @type {number} */
Matter.Vector.prototype.x;
 /** @type {number} */
Matter.Vector.prototype.y;

/**
 * Creates a new vector.
 * \@method create
 * @param {number=} x
 * @param {number=} y
 * @return {!Matter.Vector}
 */
Matter.Vector.create = function(x, y) {};

/**
 * Returns a new vector with `x` and `y` copied from the given `vector`.
 * \@method clone
 * @param {!Matter.Vector} vector
 * @return {!Matter.Vector}
 */
Matter.Vector.clone = function(vector) {};

/**
 * Returns the cross-product of three vectors.
 * \@method cross3
 * @param {!Matter.Vector} vectorA
 * @param {!Matter.Vector} vectorB
 * @param {!Matter.Vector} vectorC
 * @return {number}
 */
Matter.Vector.cross3 = function(vectorA, vectorB, vectorC) {};

/**
 * Adds the two vectors.
 * \@method add
 * @param {!Matter.Vector} vectorA
 * @param {!Matter.Vector} vectorB
 * @param {!Matter.Vector=} output
 * @return {!Matter.Vector}
 */
Matter.Vector.add = function(vectorA, vectorB, output) {};

/**
 * Returns the angle in radians between the two vectors relative to the x-axis.
 * \@method angle
 * @param {!Matter.Vector} vectorA
 * @param {!Matter.Vector} vectorB
 * @return {number}
 */
Matter.Vector.angle = function(vectorA, vectorB) {};

/**
 * Returns the cross-product of two vectors.
 * \@method cross
 * @param {!Matter.Vector} vectorA
 * @param {!Matter.Vector} vectorB
 * @return {number}
 */
Matter.Vector.cross = function(vectorA, vectorB) {};

/**
 * Divides a vector and a scalar.
 * \@method div
 * @param {!Matter.Vector} vector
 * @param {number} scalar
 * @return {!Matter.Vector}
 */
Matter.Vector.div = function(vector, scalar) {};

/**
 * Returns the dot-product of two vectors.
 * \@method dot
 * @param {!Matter.Vector} vectorA
 * @param {!Matter.Vector} vectorB
 * @return {!Number}
 */
Matter.Vector.dot = function(vectorA, vectorB) {};

/**
 * Returns the magnitude (length) of a vector.
 * \@method magnitude
 * @param {!Matter.Vector} vector
 * @return {number}
 */
Matter.Vector.magnitude = function(vector) {};

/**
 * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
 * \@method magnitudeSquared
 * @param {!Matter.Vector} vector
 * @return {number}
 */
Matter.Vector.magnitudeSquared = function(vector) {};

/**
 * Multiplies a vector and a scalar.
 * \@method mult
 * @param {!Matter.Vector} vector
 * @param {number} scalar
 * @return {!Matter.Vector}
 */
Matter.Vector.mult = function(vector, scalar) {};

/**
 * Negates both components of a vector such that it points in the opposite direction.
 * \@method neg
 * @param {!Matter.Vector} vector
 * @return {!Matter.Vector}
 */
Matter.Vector.neg = function(vector) {};

/**
 * Normalises a vector (such that its magnitude is `1`).
 * \@method normalise
 * @param {!Matter.Vector} vector
 * @return {!Matter.Vector}
 */
Matter.Vector.normalise = function(vector) {};

/**
 * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
 * \@method perp
 * @param {!Matter.Vector} vector
 * @param {boolean=} negate
 * @return {!Matter.Vector}
 */
Matter.Vector.perp = function(vector, negate) {};

/**
 * Rotates the vector about (0, 0) by specified angle.
 * \@method rotate
 * @param {!Matter.Vector} vector
 * @param {number} angle
 * @return {!Matter.Vector}
 */
Matter.Vector.rotate = function(vector, angle) {};

/**
 * Rotates the vector about a specified point by specified angle.
 * \@method rotateAbout
 * @param {!Matter.Vector} vector
 * @param {number} angle
 * @param {!Matter.Vector} point
 * @param {!Matter.Vector=} output
 * @return {!Matter.Vector}
 */
Matter.Vector.rotateAbout = function(vector, angle, point, output) {};

/**
 * Subtracts the two vectors.
 * \@method sub
 * @param {!Matter.Vector} vectorA
 * @param {!Matter.Vector} vectorB
 * @param {!Matter.Vector=} optional
 * @return {!Matter.Vector}
 */
Matter.Vector.sub = function(vectorA, vectorB, optional) {};
/**
 * @constructor
 * @struct
 */
Matter.Vertices = function() {};

/**
 * Returns the average (mean) of the set of vertices.
 * \@method mean
 * @param {!Array<!Matter.Vector>} vertices
 * @return {!Array<!Matter.Vector>}
 */
Matter.Vertices.mean = function(vertices) {};

/**
 * Sorts the input vertices into clockwise order in place.
 * \@method clockwiseSort
 * @param {!Array<!Matter.Vector>} vertices
 * @return {!Array<!Matter.Vector>}
 */
Matter.Vertices.clockwiseSort = function(vertices) {};

/**
 * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
 * \@method isConvex
 * @param {!Array<!Matter.Vector>} vertices
 * @return {boolean}
 */
Matter.Vertices.isConvex = function(vertices) {};

/**
 * Returns the convex hull of the input vertices as a new array of points.
 * \@method hull
 * @param {!Array<!Matter.Vector>} vertices
 * @return {!Array<!Matter.Vector>} [vertex] vertices
 */
Matter.Vertices.hull = function(vertices) {};

/**
 * Returns the area of the set of vertices.
 * \@method area
 * @param {!Array<!Matter.Vector>} vertices
 * @param {boolean} signed
 * @return {number}
 */
Matter.Vertices.area = function(vertices, signed) {};

/**
 * Returns the centre (centroid) of the set of vertices.
 * \@method centre
 * @param {!Array<!Matter.Vector>} vertices
 * @return {!Matter.Vector}
 */
Matter.Vertices.centre = function(vertices) {};

/**
 * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
 * The radius parameter is a single number or an array to specify the radius for each vertex.
 * \@method chamfer
 * @param {!Array<!Matter.Vector>} vertices
 * @param {(number|!Array<number>)} radius
 * @param {number} quality
 * @param {number} qualityMin
 * @param {number} qualityMax
 * @return {void}
 */
Matter.Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {};

/**
 * Returns `true` if the `point` is inside the set of `vertices`.
 * \@method contains
 * @param {!Array<!Matter.Vector>} vertices
 * @param {!Matter.Vector} point
 * @return {boolean}
 */
Matter.Vertices.contains = function(vertices, point) {};

/**
 * Creates a new set of `Matter.Body` compatible vertices.
 * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
 * 
 *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
 * 
 * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
 * but with some additional references required for efficient collision detection routines.
 * 
 * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
 * 
 * \@method create
 * @param {!Array<!Matter.Vector>} points
 * @param {!Matter.Body} body
 * @return {void}
 */
Matter.Vertices.create = function(points, body) {};

/**
 * Parses a string containing ordered x y pairs separated by spaces (and optionally commas),
 * into a `Matter.Vertices` object for the given `Matter.Body`.
 * For parsing SVG paths, see `Svg.pathToVertices`.
 * \@method fromPath
 * @param {string} path
 * @param {!Matter.Body} body
 * @return {!Array<!Matter.Vector>}
 */
Matter.Vertices.fromPath = function(path, body) {};

/**
 * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
 * \@method inertia
 * @param {!Array<!Matter.Vector>} vertices
 * @param {number} mass
 * @return {number}
 */
Matter.Vertices.inertia = function(vertices, mass) {};

/**
 * Rotates the set of vertices in-place.
 * \@method rotate
 * @param {!Array<!Matter.Vector>} vertices
 * @param {number} angle
 * @param {!Matter.Vector} point
 * @return {void}
 */
Matter.Vertices.rotate = function(vertices, angle, point) {};

/**
 * Scales the vertices from a point (default is centre) in-place.
 * \@method scale
 * @param {!Array<!Matter.Vector>} vertices
 * @param {number} scaleX
 * @param {number} scaleY
 * @param {!Matter.Vector} point
 * @return {void}
 */
Matter.Vertices.scale = function(vertices, scaleX, scaleY, point) {};

/**
 * Translates the set of vertices in-place.
 * \@method translate
 * @param {!Array<!Matter.Vector>} vertices
 * @param {!Matter.Vector} vector
 * @param {number} scalar
 * @return {void}
 */
Matter.Vertices.translate = function(vertices, vector, scalar) {};
/**
 * @extends {Matter.ICompositeDefinition}
 * @record
 * @struct
 */
Matter.IWorldDefinition = function() {};
 /** @type {!Matter.Gravity} */
Matter.IWorldDefinition.prototype.gravity;
 /** @type {!Matter.Bounds} */
Matter.IWorldDefinition.prototype.bounds;
/**
 * @record
 * @struct
 */
Matter.Gravity = function() {};
 /** @type {number} */
Matter.Gravity.prototype.scale;
/**
 * @extends {Matter.Composite}
 * @constructor
 * @struct
 */
Matter.World = function() {};
 /** @type {!Matter.Gravity} */
Matter.World.prototype.gravity;
 /** @type {!Matter.Bounds} */
Matter.World.prototype.bounds;

/**
 * Add objects or arrays of objects of types: Body, Constraint, Composite
 * @param {!Matter.World} world
 * @param {(!Matter.Body|!Array<!Matter.Body>|!Matter.Composite|!Array<!Matter.Composite>|!Matter.Constraint|!Array<!Matter.Constraint>|!Matter.MouseConstraint)} body
 * @return {!Matter.World} world
 */
Matter.World.add = function(world, body) {};

/**
 * An alias for Composite.addBody since World is also a Composite
 * \@method addBody
 * @param {!Matter.World} world
 * @param {!Matter.Body} body
 * @return {!Matter.World}
 */
Matter.World.addBody = function(world, body) {};

/**
 * An alias for Composite.add since World is also a Composite
 * \@method addComposite
 * @param {!Matter.World} world
 * @param {!Matter.Composite} composite
 * @return {!Matter.World}
 */
Matter.World.addComposite = function(world, composite) {};

/**
 * An alias for Composite.addConstraint since World is also a Composite
 * \@method addConstraint
 * @param {!Matter.World} world
 * @param {!Matter.Constraint} constraint
 * @return {!Matter.World}
 */
Matter.World.addConstraint = function(world, constraint) {};

/**
 * An alias for Composite.clear since World is also a Composite
 * \@method clear
 * @param {!Matter.World} world
 * @param {boolean} keepStatic
 * @return {void}
 */
Matter.World.clear = function(world, keepStatic) {};

/**
 * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
 * See the properties section below for detailed information on what you can pass via the `options` object.
 * \@method create
 * @param {!Matter.IWorldDefinition} options
 * @return {!Matter.World}
 */
Matter.World.create = function(options) {};
/**
 * @record
 * @struct
 */
Matter.ICollisionFilter = function() {};
 /** @type {number} */
Matter.ICollisionFilter.prototype.category;
 /** @type {number} */
Matter.ICollisionFilter.prototype.mask;
 /** @type {number} */
Matter.ICollisionFilter.prototype.group;
/**
 * @record
 * @struct
 */
Matter.IMousePoint = function() {};
 /** @type {number} */
Matter.IMousePoint.prototype.x;
 /** @type {number} */
Matter.IMousePoint.prototype.y;
/**
 * @constructor
 * @struct
 */
Matter.Mouse = function() {};
 /** @type {!HTMLElement} */
Matter.Mouse.prototype.element;
 /** @type {!Matter.IMousePoint} */
Matter.Mouse.prototype.absolute;
 /** @type {!Matter.IMousePoint} */
Matter.Mouse.prototype.position;
 /** @type {!Matter.IMousePoint} */
Matter.Mouse.prototype.mousedownPosition;
 /** @type {!Matter.IMousePoint} */
Matter.Mouse.prototype.mouseupPosition;
 /** @type {!Matter.IMousePoint} */
Matter.Mouse.prototype.offset;
 /** @type {!Matter.IMousePoint} */
Matter.Mouse.prototype.scale;
 /** @type {number} */
Matter.Mouse.prototype.wheelDelta;
 /** @type {number} */
Matter.Mouse.prototype.button;
 /** @type {number} */
Matter.Mouse.prototype.pixelRatio;

/**
 * @param {!HTMLElement} element
 * @return {!Matter.Mouse}
 */
Matter.Mouse.create = function(element) {};

/**
 * @param {!Matter.Mouse} mouse
 * @param {!HTMLElement} element
 * @return {void}
 */
Matter.Mouse.setElement = function(mouse, element) {};

/**
 * @param {!Matter.Mouse} mouse
 * @return {void}
 */
Matter.Mouse.clearSourceEvents = function(mouse) {};

/**
 * @param {!Matter.Mouse} mouse
 * @param {!Matter.Vector} offset
 * @return {void}
 */
Matter.Mouse.setOffset = function(mouse, offset) {};

/**
 * @param {!Matter.Mouse} mouse
 * @param {!Matter.Vector} scale
 * @return {void}
 */
Matter.Mouse.setScale = function(mouse, scale) {};
/**
 * @record
 * @struct
 */
Matter.IEvent = function() {};
 /** @type {string} */
Matter.IEvent.prototype.name;
 /** @type {T} */
Matter.IEvent.prototype.source;
/**
 * @extends {Matter.IEvent}
 * @record
 * @struct
 */
Matter.IEventComposite = function() {};
 /** @type {?} */
Matter.IEventComposite.prototype.object;
/**
 * @extends {Matter.IEvent}
 * @record
 * @struct
 */
Matter.IEventTimestamped = function() {};
 /** @type {number} */
Matter.IEventTimestamped.prototype.timestamp;
/**
 * @extends {Matter.IEventTimestamped}
 * @record
 * @struct
 */
Matter.IEventCollision = function() {};
 /** @type {!Array<!Matter.IPair>} */
Matter.IEventCollision.prototype.pairs;
/**
 * @constructor
 * @struct
 */
Matter.Events = function() {};

/**
 * Fired when a body starts sleeping (where `this` is the body).
 * 
 * \@event sleepStart
 * Fired when a body ends sleeping (where `this` is the body).
 * 
 * \@event sleepEnd
 * Fired when a call to `Composite.add` is made, before objects have been added.
 * 
 * \@event beforeAdd
 * Fired when a call to `Composite.add` is made, after objects have been added.
 * 
 * \@event afterAdd
 * Fired when a call to `Composite.remove` is made, before objects have been removed.
 * 
 * \@event beforeRemove
 * Fired when a call to `Composite.remove` is made, after objects have been removed.
 * 
 * \@event afterRemove
 * Fired after engine update and all collision events
 * 
 * \@event afterUpdate
 * Fired before rendering
 * 
 * \@event beforeRender
 * Fired after rendering
 * 
 * \@event afterRender
 * Fired just before an update
 * 
 * \@event beforeUpdate
 * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)
 * 
 * \@event collisionActive
 * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)
 * 
 * \@event collisionEnd
 * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)
 * 
 * \@event collisionStart
 * Fired at the start of a tick, before any updates to the engine or timing
 * 
 * \@event beforeTick
 * Fired after engine timing updated, but just before update
 * 
 * \@event tick
 * Fired at the end of a tick, after engine update and after rendering
 * 
 * \@event afterTick
 * Fired before rendering
 * 
 * \@event beforeRender
 * Fired after rendering
 * 
 * \@event afterRender
 * Fired when the mouse is down (or a touch has started) during the last step
 * Fired when the mouse has moved (or a touch moves) during the last step
 * Fired when the mouse is up (or a touch has ended) during the last step
 * @param {!Matter.Body|!Matter.Engine|!Matter.MouseConstraint|?} obj
 * @param {string} name
 * @param {function(!Matter.IEvent<!Matter.Body>): void|function(!Matter.IEventComposite<!Matter.Composite>): void|function(!Matter.IEventTimestamped<!Matter.Engine>): void|function(!Matter.IEventTimestamped<!Matter.Render>): void|function(!Matter.IEventCollision<!Matter.Engine>): void|function(!Matter.IEventTimestamped<!Matter.Runner>): void|function(?): void} callback
 * @return {void}
 */
Matter.Events.on = function(obj, name, callback) {};

/**
 * Removes the given event callback. If no callback, clears all callbacks in eventNames. If no eventNames, clears all events.
 * 
 * @param {?} obj
 * @param {string} eventName
 * @param {function(?): void} callback
 * @return {void}
 */
Matter.Events.off = function(obj, eventName, callback) {};

/**
 * Fires all the callbacks subscribed to the given object's eventName, in the order they subscribed, if any.
 * 
 * @param {?} object
 * @param {string} eventNames
 * @param {function(?): void=} event
 * @return {void}
 */
Matter.Events.trigger = function(object, eventNames, event) {};
