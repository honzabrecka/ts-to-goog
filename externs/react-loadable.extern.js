/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/react-loadable/index.d.ts:

/* TODO: ImportDeclaration in  */
/**
 * @record
 * @struct
 */
function LoadingComponentProps() {}
 /** @type {boolean} */
LoadingComponentProps.prototype.isLoading;
 /** @type {boolean} */
LoadingComponentProps.prototype.pastDelay;
 /** @type {boolean} */
LoadingComponentProps.prototype.timedOut;
 /** @type {?} */
LoadingComponentProps.prototype.error;

/** @typedef {?} */
var Options;
/**
 * @record
 * @struct
 */
function CommonOptions() {}
 /** @type {(!React.ComponentClass<?>|!React.StatelessComponent<?>|?)} */
CommonOptions.prototype.loading;
 /** @type {(number|boolean)} */
CommonOptions.prototype.delay;
 /** @type {(number|boolean)} */
CommonOptions.prototype.timeout;
/**
 * @extends {CommonOptions}
 * @record
 * @struct
 */
function OptionsWithoutRender() {}

/**
 * Function returning a promise which returns a React component displayed on success.
 * 
 * Resulting React component receives all the props passed to the generated component.
 * @return {!Promise<(!React.ComponentClass<?>|!React.StatelessComponent<?>|?)>}
 */
OptionsWithoutRender.prototype.loader = function() {};
/**
 * @extends {CommonOptions}
 * @record
 * @struct
 */
function OptionsWithRender() {}

/**
 * Function returning a promise which returns an object to be passed to `render` on success.
 * @return {!Promise<?>}
 */
OptionsWithRender.prototype.loader = function() {};

/**
 * If you want to customize what gets rendered from your loader you can also pass `render`.
 * 
 * Note: If you want to load multiple resources at once, you can also use `Loadable.Map`.
 * 
 * ```ts
 * Loadable({
 *     // ...
 *     render(loaded, props) {
 *         const Component = loaded.default;
 *         return <Component {...props} />
 *     }
 * });
 * ```
 * @param {?} loaded
 * @param {?} props
 * @return {(string|number|boolean|!Object|!React.ReactElement<?>|!Array<(string|number|boolean|!Array<?>|!React.ReactElement<?>)>)}
 */
OptionsWithRender.prototype.render = function(loaded, props) {};
/**
 * @extends {CommonOptions}
 * @record
 * @struct
 */
function OptionsWithMap() {}
 /** @type {?} */
OptionsWithMap.prototype.loader;

/**
 * If you want to customize what gets rendered from your loader you can also pass `render`.
 * 
 * Note: If you want to load multiple resources at once, you can also use `Loadable.Map`.
 * 
 * ```ts
 * Loadable({
 *     // ...
 *     render(loaded, props) {
 *         const Component = loaded.default;
 *         return <Component {...props} />
 *     }
 * });
 * ```
 * @param {?} loaded
 * @param {?} props
 * @return {(string|number|boolean|!Object|!React.ReactElement<?>|!Array<(string|number|boolean|!Array<?>|!React.ReactElement<?>)>)}
 */
OptionsWithMap.prototype.render = function(loaded, props) {};
/**
 * @record
 * @struct
 */
function LoadableComponent() {}

/**
 * The generated component has a static method preload() for calling the loader function ahead of time.
 * This is useful for scenarios where you think the user might do something next and want to load the
 * next component eagerly.
 * 
 * Note: preload() intentionally does not return a promise. You should not be depending on the timing of
 * preload(). It's meant as a performance optimization, not for creating UI logic.
 * @return {void}
 */
LoadableComponent.prototype.preload = function() {};
/**
 * @record
 * @struct
 */
function Loadable() {}

/* TODO: CallSignature:  */

/**
 * @template Props, Exports
 * @param {?} options
 * @return {?}
 */
Loadable.prototype.Map = function(options) {};
 /** @type {?} */
var LoadableExport;

/* TODO: ExportAssignment in  */
