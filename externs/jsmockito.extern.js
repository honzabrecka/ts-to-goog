/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/jsmockito/index.d.ts:
/** @const */
var JsMockito = {};
 /** @type {string} */
JsMockito.version;
/**
 * @constructor
 * @struct
 */
JsMockito.JsMockitoStubBuilder = function() {};

/**
 * Provide functions to be run in place of the mocked method.
 * 
 * @param {...function(?): ?} func Functions to be run in order of execution.
 * @return {!JsMockito.JsMockitoStubBuilder}
 */
JsMockito.JsMockitoStubBuilder.prototype.then = function(func) {};

/**
 * Provide values to be returned by the mocked function.
 * 
 * @param {...?} obj Values to be returned in order of execution.
 * @return {!JsMockito.JsMockitoStubBuilder}
 */
JsMockito.JsMockitoStubBuilder.prototype.thenReturn = function(obj) {};

/**
 * Provide exceptions to be thrown by the mocked function.
 * 
 * @param {...!Error} obj Exceptions to be thrown in order of execution.
 * @return {!JsMockito.JsMockitoStubBuilder}
 */
JsMockito.JsMockitoStubBuilder.prototype.thenThrow = function(obj) {};
/**
 * @record
 * @struct
 */
JsMockito.Verifier = function() {};

/**
 * Test if a given variable is a mock
 * 
 * @param {?} maybeMock An object
 * @return {boolean}
 */
JsMockito.isMock = function(maybeMock) {};

/**
 * Add a stub for a mock object method or mock function
 * 
 * @template T
 * @param {T} mock A mock object or mock anonymous function
 * @return {T}
 */
JsMockito.when = function(mock) {};

/**
 * Verify that a mock object method or mock function was invoked
 * 
 * @template T
 * @param {T} mock A mock object or mock anonymous function
 * @param {!JsMockito.Verifier=} verifier
 * @return {T}
 */
JsMockito.verify = function(mock, verifier) {};

/**
 * Verify that no mock object methods or the mock function were ever invoked
 * 
 * @param {...?} mock A mock object or mock anonymous function (multiple accepted)
 * @return {void}
 */
JsMockito.verifyZeroInteractions = function(mock) {};

/**
 * Verify that no mock object method or mock function invocations remain
 * unverified
 * 
 * @param {...?} mock A mock object or mock anonymous function (multiple accepted)
 * @return {void}
 */
JsMockito.verifyNoMoreInteractions = function(mock) {};

/**
 * Create a mock that proxies a real function or object.  All un-stubbed
 * invocations will be passed through to the real implementation, but can
 * still be verified.
 * 
 * @template T
 * @param {T} delegate A 'real' (concrete) object or function that the mock will delegate unstubbed invocations to
 * @return {T}
 */
JsMockito.spy = function(delegate) {};

/**
 * Create a mockable and stubbable anonymous function.
 * 
 * <p>Once created, the function can be invoked and will return undefined for
 * any interactions that do not match stub declarations.</p>
 * 
 * <pre>
 * var mockFunc = JsMockito.mockFunction();
 * JsMockito.when(mockFunc).call(anything(), 1, 5).thenReturn(6);
 * mockFunc(1, 5); // result is 6
 * JsMockito.verify(mockFunc)(1, greaterThan(2));
 * </pre>
 * 
 * @param {string=} funcName
 * @param {!Function=} delegate
 * @return {!Function}
 */
JsMockito.mockFunction = function(funcName, delegate) {};

/**
 * Create a mockable and stubbable objects.
 * 
 * <p>A mock is created with the constructor for an object as an argument.
 * Once created, the mock object will have all the same methods as the source
 * object which, when invoked, will return undefined by default.</p>
 * 
 * <p>Stub declarations may then be made for these methods to have them return
 * useful values or perform actions when invoked.</p>
 * 
 * <pre>
 * MyObject = function() {
 *   this.add = function(a, b) { return a + b }
 * };
 * 
 * var mockObj = JsMockito.mock(MyObject);
 * mockObj.add(5, 4); // result is undefined
 * 
 * JsMockito.when(mockFunc).add(1, 2).thenReturn(6);
 * mockObj.add(1, 2); // result is 6
 * 
 * JsMockito.verify(mockObj).add(1, greaterThan(2)); // ok
 * JsMockito.verify(mockObj).add(1, equalTo(2)); // ok
 * JsMockito.verify(mockObj).add(1, 4); // will throw an exception
 * </pre>
 * 
 * @template T
 * @param {function(new: (T)): ?} Obj {function} the constructor for the object to be mocked
 * @return {T}
 */
JsMockito.mock = function(Obj) {};
/** @const */
JsMockito.Verifiers = {};

/**
 * Test that a invocation never occurred. For example:
 * <pre>
 * verify(mock, never()).method();
 * </pre>
 * @see JsMockito.Verifiers.times(0)
 * @return {!JsMockito.Verifier}
 */
JsMockito.Verifiers.never = function() {};

/**
 * Test that no interaction were made on the mock.  For example:
 * <pre>
 * verify(mock, zeroInteractions());
 * </pre>
 * @see JsMockito.verifyZeroInteractions()
 * @return {!JsMockito.Verifier}
 */
JsMockito.Verifiers.zeroInteractions = function() {};

/**
 * Test that no further interactions remain unverified on the mock.  For
 * example:
 * <pre>
 * verify(mock, noMoreInteractions());
 * </pre>
 * @see JsMockito.verifyNoMoreInteractions()
 * @return {!JsMockito.Verifier}
 */
JsMockito.Verifiers.noMoreInteractions = function() {};

/**
 * Test that an invocation occurred a specific number of times. For example:
 * <pre>
 * verify(mock, times(2)).method();
 * </pre>
 * 
 * @param {number} wanted The number of desired invocations
 * @return {!JsMockito.Verifier}
 */
JsMockito.Verifiers.times = function(wanted) {};

/**
 * Test that an invocation occurred exactly once. For example:
 * <pre>
 * verify(mock, once()).method();
 * </pre>
 * This is the default verifier.
 * @see JsMockito.Verifiers.times(1)
 * @return {!JsMockito.Verifier}
 */
JsMockito.Verifiers.once = function() {};
/** @const */
JsMockito.Integration = {};

/**
 * Import the public JsMockito API into the specified object (namespace)
 * 
 * the functions from the public JsMockito API
 * @param {?} target
 * @return {void}
 */
JsMockito.Integration.importTo = function(target) {};

/**
 * Make the public JsMockito API available in Screw.Unit
 * @see JsMockito.Integration.importTo(Screw.Matchers)
 * @return {void}
 */
JsMockito.Integration.screwunit = function() {};

/**
 * Make the public JsMockito API available to JsTestDriver
 * @see JsMockito.Integration.importTo(window)
 * @return {void}
 */
JsMockito.Integration.JsTestDriver = function() {};

/**
 * Make the public JsMockito API available to JsUnitTest
 * @see JsMockito.Integration.importTo(JsUnitTest.Unit.Testcase.prototype)
 * @return {void}
 */
JsMockito.Integration.JsUnitTest = function() {};

/**
 * Make the public JsMockito API available to YUITest
 * @see JsMockito.Integration.importTo(window)
 * @return {void}
 */
JsMockito.Integration.YUITest = function() {};

/**
 * Make the public JsMockito API available to QUnit
 * @see JsMockito.Integration.importTo(window)
 * @return {void}
 */
JsMockito.Integration.QUnit = function() {};

/**
 * Make the public JsMockito API available to jsUnity
 * @see JsMockito.Integration.importTo(jsUnity.env.defaultScope)
 * @return {void}
 */
JsMockito.Integration.jsUnity = function() {};

/**
 * Make the public JsMockito API available to jSpec
 * @see JsMockito.Integration.importTo(jSpec.defaultContext)
 * @return {void}
 */
JsMockito.Integration.jSpec = function() {};

/**
 * Test if a given variable is a mock
 * 
 * @param {?} maybeMock An object
 * @return {boolean}
 */
function isMock(maybeMock) {}

/**
 * Add a stub for a mock object method or mock function
 * 
 * @template T
 * @param {T} mock A mock object or mock anonymous function
 * @return {T}
 */
function when(mock) {}

/**
 * Verify that a mock object method or mock function was invoked
 * 
 * @template T
 * @param {T} mock A mock object or mock anonymous function
 * @param {!JsMockito.Verifier=} verifier
 * @return {T}
 */
function verify(mock, verifier) {}

/**
 * Verify that no mock object methods or the mock function were ever invoked
 * 
 * @param {...?} mock A mock object or mock anonymous function (multiple accepted)
 * @return {void}
 */
function verifyZeroInteractions(mock) {}

/**
 * Verify that no mock object method or mock function invocations remain
 * unverified
 * 
 * @param {...?} mock A mock object or mock anonymous function (multiple accepted)
 * @return {void}
 */
function verifyNoMoreInteractions(mock) {}

/**
 * Create a mock that proxies a real function or object.  All un-stubbed
 * invocations will be passed through to the real implementation, but can
 * still be verified.
 * 
 * @template T
 * @param {T} delegate A 'real' (concrete) object or function that the mock will delegate unstubbed invocations to
 * @return {T}
 */
function spy(delegate) {}

/**
 * Create a mockable and stubbable anonymous function.
 * 
 * <p>Once created, the function can be invoked and will return undefined for
 * any interactions that do not match stub declarations.</p>
 * 
 * <pre>
 * var mockFunc = JsMockito.mockFunction();
 * JsMockito.when(mockFunc).call(anything(), 1, 5).thenReturn(6);
 * mockFunc(1, 5); // result is 6
 * JsMockito.verify(mockFunc)(1, greaterThan(2));
 * </pre>
 * 
 * @param {string=} funcName
 * @param {!Function=} delegate
 * @return {!Function}
 */
function mockFunction(funcName, delegate) {}

/**
 * Create a mockable and stubbable objects.
 * 
 * <p>A mock is created with the constructor for an object as an argument.
 * Once created, the mock object will have all the same methods as the source
 * object which, when invoked, will return undefined by default.</p>
 * 
 * <p>Stub declarations may then be made for these methods to have them return
 * useful values or perform actions when invoked.</p>
 * 
 * <pre>
 * MyObject = function() {
 *   this.add = function(a, b) { return a + b }
 * };
 * 
 * var mockObj = JsMockito.mock(MyObject);
 * mockObj.add(5, 4); // result is undefined
 * 
 * JsMockito.when(mockFunc).add(1, 2).thenReturn(6);
 * mockObj.add(1, 2); // result is 6
 * 
 * JsMockito.verify(mockObj).add(1, greaterThan(2)); // ok
 * JsMockito.verify(mockObj).add(1, equalTo(2)); // ok
 * JsMockito.verify(mockObj).add(1, 4); // will throw an exception
 * </pre>
 * 
 * @template T
 * @param {function(new: (T)): ?} Obj {function} the constructor for the object to be mocked
 * @return {T}
 */
function mock(Obj) {}

/**
 * Test that a invocation never occurred. For example:
 * <pre>
 * verify(mock, never()).method();
 * </pre>
 * @see JsMockito.Verifiers.times(0)
 * @return {!JsMockito.Verifier}
 */
function never() {}

/**
 * Test that no interaction were made on the mock.  For example:
 * <pre>
 * verify(mock, zeroInteractions());
 * </pre>
 * @see JsMockito.verifyZeroInteractions()
 * @return {!JsMockito.Verifier}
 */
function zeroInteractions() {}

/**
 * Test that no further interactions remain unverified on the mock.  For
 * example:
 * <pre>
 * verify(mock, noMoreInteractions());
 * </pre>
 * @see JsMockito.verifyNoMoreInteractions()
 * @return {!JsMockito.Verifier}
 */
function noMoreInteractions() {}

/**
 * Test that an invocation occurred a specific number of times. For example:
 * <pre>
 * verify(mock, times(2)).method();
 * </pre>
 * 
 * @param {number} wanted The number of desired invocations
 * @return {!JsMockito.Verifier}
 */
function times(wanted) {}

/**
 * Test that an invocation occurred exactly once. For example:
 * <pre>
 * verify(mock, once()).method();
 * </pre>
 * This is the default verifier.
 * @see JsMockito.Verifiers.times(1)
 * @return {!JsMockito.Verifier}
 */
function once() {}
