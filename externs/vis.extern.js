/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/vis/index.d.ts:

/** @typedef {(string|number)} */
var IdType;

/** @typedef {(string|number)} */
var SubgroupType;

/** @typedef {(string|number|!Date)} */
var DateType;

/** @typedef {(string|number)} */
var HeightWidthType;

/** @typedef {string} */
var TimelineTimeAxisScaleType;

/** @typedef {string} */
var TimelineEventPropertiesResultWhatType;

/** @typedef {string} */
var TimelineEvents;

/** @typedef {string} */
var Graph2dStyleType;

/** @typedef {string} */
var Graph2dBarChartAlign;

/** @typedef {string} */
var Graph2dDrawPointsStyle;

/** @typedef {string} */
var LegendPositionType;

/** @typedef {string} */
var ParametrizationInterpolationType;

/** @typedef {string} */
var TopBottomEnumType;

/** @typedef {string} */
var RightLeftEnumType;
/**
 * @record
 * @struct
 */
function LegendPositionOptions() {}
 /** @type {boolean} */
LegendPositionOptions.prototype.visible;
 /** @type {string} */
LegendPositionOptions.prototype.position;
/**
 * @record
 * @struct
 */
function LegendOptions() {}
 /** @type {boolean} */
LegendOptions.prototype.enabled;
 /** @type {boolean} */
LegendOptions.prototype.icons;
 /** @type {number} */
LegendOptions.prototype.iconSize;
 /** @type {number} */
LegendOptions.prototype.iconSpacing;
 /** @type {?} */
LegendOptions.prototype.left;
 /** @type {?} */
LegendOptions.prototype.right;
/**
 * @record
 * @struct
 */
function DataItem() {}
 /** @type {string} */
DataItem.prototype.className;
 /** @type {string} */
DataItem.prototype.content;
 /** @type {(string|number|!Date)} */
DataItem.prototype.end;
 /** @type {?} */
DataItem.prototype.group;
 /** @type {(string|number)} */
DataItem.prototype.id;
 /** @type {(string|number|!Date)} */
DataItem.prototype.start;
 /** @type {string} */
DataItem.prototype.style;
 /** @type {(string|number)} */
DataItem.prototype.subgroup;
 /** @type {string} */
DataItem.prototype.title;
 /** @type {string} */
DataItem.prototype.type;
 /** @type {boolean} */
DataItem.prototype.editable;
/**
 * @extends {DataItem}
 * @record
 * @struct
 */
function PointItem() {}
 /** @type {string} */
PointItem.prototype.x;
 /** @type {number} */
PointItem.prototype.y;
/**
 * @record
 * @struct
 */
function DataGroup() {}
 /** @type {string} */
DataGroup.prototype.className;
 /** @type {string} */
DataGroup.prototype.content;
 /** @type {(string|number)} */
DataGroup.prototype.id;
 /** @type {?} */
DataGroup.prototype.options;
 /** @type {string} */
DataGroup.prototype.style;
 /** @type {(string|?)} */
DataGroup.prototype.subgroupOrder;
 /** @type {string} */
DataGroup.prototype.title;
 /** @type {!Array<number>} */
DataGroup.prototype.nestedGroups;
/**
 * @record
 * @struct
 */
function DataGroupOptions() {}
 /** @type {?} */
DataGroupOptions.prototype.drawPoints;
 /** @type {boolean} */
DataGroupOptions.prototype.excludeFromLegend;
 /** @type {(boolean|?)} */
DataGroupOptions.prototype.interpolation;
 /** @type {?} */
DataGroupOptions.prototype.shaded;
 /** @type {string} */
DataGroupOptions.prototype.style;
 /** @type {string} */
DataGroupOptions.prototype.yAxisOrientation;
/**
 * @record
 * @struct
 */
function InterpolationOptions() {}
 /** @type {string} */
InterpolationOptions.prototype.parametrization;
/**
 * @record
 * @struct
 */
function TimelineEditableOption() {}
 /** @type {boolean} */
TimelineEditableOption.prototype.add;
 /** @type {boolean} */
TimelineEditableOption.prototype.remove;
 /** @type {boolean} */
TimelineEditableOption.prototype.updateGroup;
 /** @type {boolean} */
TimelineEditableOption.prototype.updateTime;
/**
 * @record
 * @struct
 */
function TimelineGroupEditableOption() {}
 /** @type {boolean} */
TimelineGroupEditableOption.prototype.add;
 /** @type {boolean} */
TimelineGroupEditableOption.prototype.remove;
 /** @type {boolean} */
TimelineGroupEditableOption.prototype.order;
/**
 * @record
 * @struct
 */
function TimelineMarginItem() {}
 /** @type {number} */
TimelineMarginItem.prototype.horizontal;
 /** @type {number} */
TimelineMarginItem.prototype.vertical;

/** @typedef {(number|?)} */
var TimelineMarginItemType;
/**
 * @record
 * @struct
 */
function TimelineMarginOption() {}
 /** @type {number} */
TimelineMarginOption.prototype.axis;
 /** @type {(number|?)} */
TimelineMarginOption.prototype.item;
/**
 * @record
 * @struct
 */
function TimelineOrientationOption() {}
 /** @type {string} */
TimelineOrientationOption.prototype.axis;
 /** @type {string} */
TimelineOrientationOption.prototype.item;
/**
 * @record
 * @struct
 */
function TimelineTimeAxisOption() {}
 /** @type {string} */
TimelineTimeAxisOption.prototype.scale;
 /** @type {number} */
TimelineTimeAxisOption.prototype.step;

/** @typedef {?} */
var TimelineOptionsConfigureFunction;

/** @typedef {(boolean|?)} */
var TimelineOptionsConfigureType;

/** @typedef {(string|boolean|!Array<string>)} */
var TimelineOptionsDataAttributesType;

/** @typedef {(boolean|?)} */
var TimelineOptionsEditableType;

/** @typedef {(boolean|?)} */
var TimelineOptionsGroupEditableType;

/** @typedef {(string|?)} */
var TimelineOptionsGroupOrderType;

/** @typedef {?} */
var TimelineOptionsGroupOrderSwapFunction;

/** @typedef {(number|?)} */
var TimelineOptionsMarginType;

/** @typedef {(string|?)} */
var TimelineOptionsOrientationType;

/** @typedef {?} */
var TimelineOptionsSnapFunction;
/**
 * @record
 * @struct
 */
function TimelineOptions() {}
 /** @type {string} */
TimelineOptions.prototype.align;
 /** @type {boolean} */
TimelineOptions.prototype.autoResize;
 /** @type {boolean} */
TimelineOptions.prototype.clickToUse;
 /** @type {(boolean|?)} */
TimelineOptions.prototype.configure;
 /** @type {(string|boolean|!Array<string>)} */
TimelineOptions.prototype.dataAttributes;
 /** @type {(boolean|?)} */
TimelineOptions.prototype.editable;
 /** @type {(string|number|!Date)} */
TimelineOptions.prototype.end;
 /** @type {?} */
TimelineOptions.prototype.format;
 /** @type {(boolean|?)} */
TimelineOptions.prototype.groupEditable;
 /** @type {(string|?)} */
TimelineOptions.prototype.groupOrder;
 /** @type {?} */
TimelineOptions.prototype.groupOrderSwap;
 /** @type {(string|number)} */
TimelineOptions.prototype.height;
 /** @type {?} */
TimelineOptions.prototype.hiddenDates;
 /** @type {boolean} */
TimelineOptions.prototype.horizontalScroll;
 /** @type {boolean} */
TimelineOptions.prototype.itemsAlwaysDraggable;
 /** @type {string} */
TimelineOptions.prototype.locale;
 /** @type {?} */
TimelineOptions.prototype.locales;
 /** @type {(number|?)} */
TimelineOptions.prototype.margin;
 /** @type {(string|number|!Date)} */
TimelineOptions.prototype.max;
 /** @type {(string|number)} */
TimelineOptions.prototype.maxHeight;
 /** @type {number} */
TimelineOptions.prototype.maxMinorChars;
 /** @type {(string|number|!Date)} */
TimelineOptions.prototype.min;
 /** @type {(string|number)} */
TimelineOptions.prototype.minHeight;
 /** @type {boolean} */
TimelineOptions.prototype.moveable;
 /** @type {boolean} */
TimelineOptions.prototype.multiselect;
 /** @type {boolean} */
TimelineOptions.prototype.multiselectPerGroup;
 /** @type {(string|?)} */
TimelineOptions.prototype.orientation;
 /** @type {?} */
TimelineOptions.prototype.rollingMode;
 /** @type {boolean} */
TimelineOptions.prototype.selectable;
 /** @type {boolean} */
TimelineOptions.prototype.showCurrentTime;
 /** @type {boolean} */
TimelineOptions.prototype.showMajorLabels;
 /** @type {boolean} */
TimelineOptions.prototype.showMinorLabels;
 /** @type {boolean} */
TimelineOptions.prototype.stack;
 /** @type {?} */
TimelineOptions.prototype.snap;
 /** @type {(string|number|!Date)} */
TimelineOptions.prototype.start;
 /** @type {number} */
TimelineOptions.prototype.throttleRedraw;
 /** @type {?} */
TimelineOptions.prototype.timeAxis;
 /** @type {string} */
TimelineOptions.prototype.type;
 /** @type {(boolean|?)} */
TimelineOptions.prototype.tooltipOnItemUpdateTime;
 /** @type {boolean} */
TimelineOptions.prototype.verticalScroll;
 /** @type {(string|number)} */
TimelineOptions.prototype.width;
 /** @type {boolean} */
TimelineOptions.prototype.zoomable;
 /** @type {string} */
TimelineOptions.prototype.zoomKey;
 /** @type {number} */
TimelineOptions.prototype.zoomMax;
 /** @type {number} */
TimelineOptions.prototype.zoomMin;

/**
 * @param {?=} item
 * @param {?=} element
 * @param {?=} data
 * @return {?}
 */
TimelineOptions.prototype.groupTemplate = function(item, element, data) {};

/**
 * @return {void}
 */
TimelineOptions.prototype.moment = function() {};

/**
 * @return {void}
 */
TimelineOptions.prototype.onAdd = function() {};

/**
 * @return {void}
 */
TimelineOptions.prototype.onAddGroup = function() {};

/**
 * @return {void}
 */
TimelineOptions.prototype.onUpdate = function() {};

/**
 * @return {void}
 */
TimelineOptions.prototype.onMove = function() {};

/**
 * @return {void}
 */
TimelineOptions.prototype.onMoveGroup = function() {};

/**
 * @return {void}
 */
TimelineOptions.prototype.onMoving = function() {};

/**
 * @return {void}
 */
TimelineOptions.prototype.onRemove = function() {};

/**
 * @return {void}
 */
TimelineOptions.prototype.onRemoveGroup = function() {};

/**
 * @return {void}
 */
TimelineOptions.prototype.order = function() {};

/**
 * @param {?=} item
 * @param {?=} element
 * @param {?=} data
 * @return {?}
 */
TimelineOptions.prototype.template = function(item, element, data) {};
/**
 * @record
 * @struct
 */
function TimelineFitAnimation() {}
 /** @type {number} */
TimelineFitAnimation.prototype.duration;
 /** @type {string} */
TimelineFitAnimation.prototype.easingFunction;

/** @typedef {(boolean|?)} */
var TimelineFitAnimationType;
/**
 * @record
 * @struct
 */
function TimelineFitOptions() {}
 /** @type {(boolean|?)} */
TimelineFitOptions.prototype.animation;
/**
 * @record
 * @struct
 */
function TimelineEventPropertiesResult() {}
 /** @type {number} */
TimelineEventPropertiesResult.prototype.group;
 /** @type {number} */
TimelineEventPropertiesResult.prototype.item;
 /** @type {number} */
TimelineEventPropertiesResult.prototype.pageX;
 /** @type {number} */
TimelineEventPropertiesResult.prototype.pageY;
 /** @type {number} */
TimelineEventPropertiesResult.prototype.x;
 /** @type {number} */
TimelineEventPropertiesResult.prototype.y;
 /** @type {!Date} */
TimelineEventPropertiesResult.prototype.time;
 /** @type {!Date} */
TimelineEventPropertiesResult.prototype.snappedTime;
 /** @type {string} */
TimelineEventPropertiesResult.prototype.what;
 /** @type {!Event} */
TimelineEventPropertiesResult.prototype.event;
/**
 * @extends {DataSetQueueOptions}
 * @record
 * @struct
 */
function DataSetOptions() {}
 /** @type {string} */
DataSetOptions.prototype.fieldId;
 /** @type {?} */
DataSetOptions.prototype.type;
/**
 * @record
 * @struct
 */
function DataSetQueueOptions() {}
 /** @type {?} */
DataSetQueueOptions.prototype.queue;

/**
 * @constructor
 * @struct
 * Creates an instance of DataSet.
 * 
 * 
 * \@memberOf DataSet
 * Creates an instance of DataSet.
 * 
 * 
 * \@memberOf DataSet
 * @param {?|!Array<?>=} options_or_data
 * @param {?=} options
 */
function DataSet(options_or_data, options) {}
 /** @type {number} */
DataSet.prototype.length;

/**
 * Add one or multiple items to the DataSet.
 * Adding an item will fail when there already is an item with the same id.
 * 
 * 
 * \@memberOf DataSet
 * @param {(?|!Array<?>)} data
 * @param {(string|number)=} senderId
 * @return {!Array<(string|number)>}
 */
DataSet.prototype.add = function(data, senderId) {};

/**
 * Clear all data from the DataSet.
 * 
 * 
 * \@memberOf DataSet
 * @param {(string|number)=} senderId
 * @return {!Array<(string|number)>}
 */
DataSet.prototype.clear = function(senderId) {};

/**
 * Find all distinct values of a specified field.
 * If data items do not contain the specified field are ignored.
 * 
 * 
 * \@memberOf DataSet
 * @param {string} field
 * @return {!Array<?>}
 */
DataSet.prototype.distinct = function(field) {};

/**
 * Flush queued changes.
 * Only available when the DataSet is configured with the option queue.
 * 
 * \@memberOf DataSet
 * @return {void}
 */
DataSet.prototype.flush = function() {};

/**
 * Execute a callback function for every item in the dataset.
 * 
 * 
 * \@memberOf DataSet
 * @param {?} callback
 * @param {?=} options
 * @return {void}
 */
DataSet.prototype.forEach = function(callback, options) {};

/**
 * Get all items from the DataSet.
 * 
 * and and empty Array is returned in case of multiple id's.
 * 
 * \@memberOf DataSet
 * Get a single item from the DataSet.
 * 
 * and and empty Array is returned in case of multiple id's.
 * 
 * \@memberOf DataSet
 * Get multiple items from the DataSet.
 * 
 * and and empty Array is returned in case of multiple id's.
 * 
 * \@memberOf DataSet
 * @param {?|(string|number)|!Array<(string|number)>=} options_or_id_or_ids
 * @param {?=} options
 * @return {!Array<?>|?}
 */
DataSet.prototype.get = function(options_or_id_or_ids, options) {};

/**
 * Get the DataSet itself.
 * In case of a DataView, this function does not return the DataSet
 * to which the DataView is connected.
 * 
 * 
 * \@memberOf DataSet
 * @return {?}
 */
DataSet.prototype.getDataSet = function() {};

/**
 * Get ids of all items or of a filtered set of items.
 * 
 * 
 * \@memberOf DataSet
 * @param {?=} options
 * @return {!Array<(string|number)>}
 */
DataSet.prototype.getIds = function(options) {};

/**
 * Map every item in the DataSet.
 * 
 * 
 * \@memberOf DataSet
 * @param {?} callback
 * @param {?=} options
 * @return {!Array<?>}
 */
DataSet.prototype.map = function(callback, options) {};

/**
 * Find the item with maximum value of specified field.
 * 
 * 
 * \@memberOf DataSet
 * @param {string} field
 * @return {?}
 */
DataSet.prototype.max = function(field) {};

/**
 * Find the item with minimum value of specified field.
 * 
 * 
 * \@memberOf DataSet
 * @param {string} field
 * @return {?}
 */
DataSet.prototype.min = function(field) {};

/**
 * Subscribe from an event.
 * 
 * a callback function which will be called each time the event occurs.
 * 
 * \@memberOf DataSet
 * @param {string} event
 * @param {?} callback
 * @return {void}
 */
DataSet.prototype.on = function(event, callback) {};

/**
 * Unsubscribe to an event.
 * 
 * The exact same callback that was used when calling 'on'.
 * 
 * \@memberOf DataSet
 * @param {string} event
 * @param {?} callback
 * @return {void}
 */
DataSet.prototype.off = function(event, callback) {};

/**
 * Remove one or more items by id.
 * 
 * 
 * \@memberOf DataSet
 * @param {(string|number|!Array<(string|number)>)} id
 * @param {(string|number)=} senderId
 * @return {!Array<(string|number)>}
 */
DataSet.prototype.remove = function(id, senderId) {};

/**
 * Set options for the DataSet.
 * 
 * 
 * \@memberOf DataSet
 * @param {?=} options
 * @return {void}
 */
DataSet.prototype.setOptions = function(options) {};

/**
 * Update one or multiple existing items.
 * When an item doesn't exist, it will be created.
 * 
 * 
 * \@memberOf DataSet
 * @param {(?|!Array<?>)} data
 * @param {(string|number)=} senderId
 * @return {!Array<(string|number)>}
 */
DataSet.prototype.update = function(data, senderId) {};
/**
 * @record
 * @struct
 */
function DataSelectionOptions() {}
 /** @type {?} */
DataSelectionOptions.prototype.fields;
 /** @type {?} */
DataSelectionOptions.prototype.type;
 /** @type {?} */
DataSelectionOptions.prototype.order;
 /** @type {string} */
DataSelectionOptions.prototype.returnType;

/**
 * Items can be filtered on specific properties by providing a filter function.
 * A filter function is executed for each of the items in the DataSet,
 * and is called with the item as parameter.
 * The function must return a boolean.
 * All items for which the filter function returns true will be emitted.
 * See section Data Filtering.
 * 
 * \@memberOf DataSelectionOptions
 * @param {?} item
 * @return {boolean}
 */
DataSelectionOptions.prototype.filter = function(item) {};

/**
 * @constructor
 * @struct
 * @param {!Array<?>} items
 */
function DataView(items) {}
 /** @type {number} */
DataView.prototype.length;

/** @typedef {(!Array<?>|?)} */
var DataItemCollectionType;

/** @typedef {(!Array<?>|?)} */
var DataGroupCollectionType;
/**
 * @record
 * @struct
 */
function TitleOption() {}
 /** @type {string} */
TitleOption.prototype.text;
 /** @type {string} */
TitleOption.prototype.style;
/**
 * @record
 * @struct
 */
function RangeType() {}
 /** @type {(string|number)} */
RangeType.prototype.min;
 /** @type {(string|number)} */
RangeType.prototype.max;
/**
 * @record
 * @struct
 */
function DataAxisSideOption() {}
 /** @type {?} */
DataAxisSideOption.prototype.range;
 /** @type {?} */
DataAxisSideOption.prototype.title;

/**
 * @return {string}
 */
DataAxisSideOption.prototype.format = function() {};
/**
 * @record
 * @struct
 */
function Graph2dBarChartOption() {}
 /** @type {number} */
Graph2dBarChartOption.prototype.width;
 /** @type {number} */
Graph2dBarChartOption.prototype.minWidth;
 /** @type {boolean} */
Graph2dBarChartOption.prototype.sideBySide;
 /** @type {string} */
Graph2dBarChartOption.prototype.align;
/**
 * @record
 * @struct
 */
function Graph2dDataAxisOption() {}
 /** @type {(string|?)} */
Graph2dDataAxisOption.prototype.orientation;
 /** @type {boolean} */
Graph2dDataAxisOption.prototype.showMinorLabels;
 /** @type {boolean} */
Graph2dDataAxisOption.prototype.showMajorLabels;
 /** @type {number} */
Graph2dDataAxisOption.prototype.majorLinesOffset;
 /** @type {number} */
Graph2dDataAxisOption.prototype.minorLinesOffset;
 /** @type {number} */
Graph2dDataAxisOption.prototype.labelOffsetX;
 /** @type {number} */
Graph2dDataAxisOption.prototype.labelOffsetY;
 /** @type {number} */
Graph2dDataAxisOption.prototype.iconWidth;
 /** @type {string} */
Graph2dDataAxisOption.prototype.width;
 /** @type {boolean} */
Graph2dDataAxisOption.prototype.icons;
 /** @type {boolean} */
Graph2dDataAxisOption.prototype.visible;
 /** @type {boolean} */
Graph2dDataAxisOption.prototype.alignZeros;
 /** @type {?} */
Graph2dDataAxisOption.prototype.left;
 /** @type {?} */
Graph2dDataAxisOption.prototype.right;
/**
 * @record
 * @struct
 */
function Graph2dDrawPointsOption() {}
 /** @type {boolean} */
Graph2dDrawPointsOption.prototype.enabled;
 /** @type {number} */
Graph2dDrawPointsOption.prototype.size;
 /** @type {string} */
Graph2dDrawPointsOption.prototype.style;

/**
 * @return {boolean}
 */
Graph2dDrawPointsOption.prototype.onRender = function() {};
/**
 * @record
 * @struct
 */
function Graph2dShadedOption() {}
 /** @type {string} */
Graph2dShadedOption.prototype.orientation;
 /** @type {(string|number)} */
Graph2dShadedOption.prototype.groupid;

/** @typedef {(number|?)} */
var Graph2dOptionBarChart;

/** @typedef {(boolean|?)} */
var Graph2dOptionDataAxis;

/** @typedef {(boolean|?)} */
var Graph2dOptionDrawPoints;

/** @typedef {(boolean|?)} */
var Graph2dLegendOption;
/**
 * @record
 * @struct
 */
function Graph2dOptions() {}
 /** @type {boolean} */
Graph2dOptions.prototype.autoResize;
 /** @type {(number|?)} */
Graph2dOptions.prototype.barChart;
 /** @type {boolean} */
Graph2dOptions.prototype.clickToUse;
 /** @type {(boolean|?)} */
Graph2dOptions.prototype.configure;
 /** @type {(boolean|?)} */
Graph2dOptions.prototype.dataAxis;
 /** @type {string} */
Graph2dOptions.prototype.defaultGroup;
 /** @type {(boolean|?)} */
Graph2dOptions.prototype.drawPoints;
 /** @type {(string|number|!Date)} */
Graph2dOptions.prototype.end;
 /** @type {?} */
Graph2dOptions.prototype.format;
 /** @type {(string|number)} */
Graph2dOptions.prototype.graphHeight;
 /** @type {(string|number)} */
Graph2dOptions.prototype.height;
 /** @type {?} */
Graph2dOptions.prototype.hiddenDates;
 /** @type {(boolean|?)} */
Graph2dOptions.prototype.legend;
 /** @type {string} */
Graph2dOptions.prototype.locale;
 /** @type {?} */
Graph2dOptions.prototype.locales;
 /** @type {(string|number|!Date)} */
Graph2dOptions.prototype.max;
 /** @type {(string|number)} */
Graph2dOptions.prototype.maxHeight;
 /** @type {number} */
Graph2dOptions.prototype.maxMinorChars;
 /** @type {(string|number|!Date)} */
Graph2dOptions.prototype.min;
 /** @type {(string|number)} */
Graph2dOptions.prototype.minHeight;
 /** @type {boolean} */
Graph2dOptions.prototype.moveable;
 /** @type {boolean} */
Graph2dOptions.prototype.multiselect;
 /** @type {string} */
Graph2dOptions.prototype.orientation;
 /** @type {boolean} */
Graph2dOptions.prototype.sampling;
 /** @type {boolean} */
Graph2dOptions.prototype.showCurrentTime;
 /** @type {boolean} */
Graph2dOptions.prototype.showMajorLabels;
 /** @type {boolean} */
Graph2dOptions.prototype.showMinorLabels;
 /** @type {boolean} */
Graph2dOptions.prototype.sort;
 /** @type {boolean} */
Graph2dOptions.prototype.stack;
 /** @type {(string|number|!Date)} */
Graph2dOptions.prototype.start;
 /** @type {string} */
Graph2dOptions.prototype.style;
 /** @type {number} */
Graph2dOptions.prototype.throttleRedraw;
 /** @type {?} */
Graph2dOptions.prototype.timeAxis;
 /** @type {(string|number)} */
Graph2dOptions.prototype.width;
 /** @type {string} */
Graph2dOptions.prototype.yAxisOrientation;
 /** @type {boolean} */
Graph2dOptions.prototype.zoomable;
 /** @type {string} */
Graph2dOptions.prototype.zoomKey;
 /** @type {number} */
Graph2dOptions.prototype.zoomMax;
 /** @type {number} */
Graph2dOptions.prototype.zoomMin;
 /** @type {number} */
Graph2dOptions.prototype.zIndex;

/**
 * @return {void}
 */
Graph2dOptions.prototype.moment = function() {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} container
 * @param {(!Array<?>|?)} items
 * @param {(!Array<?>|?)|?=} groups_or_options
 * @param {?=} options
 */
function Graph2d(container, items, groups_or_options, options) {}

/**
 * @param {(string|number|!Date)} time
 * @param {(string|number)=} id
 * @return {(string|number)}
 */
Graph2d.prototype.addCustomTime = function(time, id) {};

/**
 * @return {void}
 */
Graph2d.prototype.destroy = function() {};

/**
 * @param {?=} options
 * @return {void}
 */
Graph2d.prototype.fit = function(options) {};

/**
 * @param {(string|number|!Array<(string|number)>)} ids
 * @param {?=} options
 * @return {void}
 */
Graph2d.prototype.focus = function(ids, options) {};

/**
 * @return {!Date}
 */
Graph2d.prototype.getCurrentTime = function() {};

/**
 * @param {(string|number)=} id
 * @return {!Date}
 */
Graph2d.prototype.getCustomTime = function(id) {};

/**
 * @param {!Event} event
 * @return {?}
 */
Graph2d.prototype.getEventProperties = function(event) {};

/**
 * @return {?}
 */
Graph2d.prototype.getItemRange = function() {};

/**
 * @return {!Array<(string|number)>}
 */
Graph2d.prototype.getSelection = function() {};

/**
 * @return {!Array<(string|number)>}
 */
Graph2d.prototype.getVisibleItems = function() {};

/**
 * @return {?}
 */
Graph2d.prototype.getWindow = function() {};

/**
 * @param {(string|number|!Date)} time
 * @param {?=} options
 * @return {void}
 */
Graph2d.prototype.moveTo = function(time, options) {};

/**
 * @param {string} event
 * @param {?} callback
 * @return {void}
 */
Graph2d.prototype.on = function(event, callback) {};

/**
 * @param {string} event
 * @param {?} callback
 * @return {void}
 */
Graph2d.prototype.off = function(event, callback) {};

/**
 * @return {void}
 */
Graph2d.prototype.redraw = function() {};

/**
 * @param {(string|number)} id
 * @return {void}
 */
Graph2d.prototype.removeCustomTime = function(id) {};

/**
 * @param {(string|number|!Date)} time
 * @return {void}
 */
Graph2d.prototype.setCurrentTime = function(time) {};

/**
 * @param {(string|number|!Date)} time
 * @param {(string|number)=} id
 * @return {void}
 */
Graph2d.prototype.setCustomTime = function(time, id) {};

/**
 * @param {string} title
 * @param {(string|number)=} id
 * @return {void}
 */
Graph2d.prototype.setCustomTimeTitle = function(title, id) {};

/**
 * @param {?} data
 * @return {void}
 */
Graph2d.prototype.setData = function(data) {};

/**
 * @param {(!Array<?>|?)=} groups
 * @return {void}
 */
Graph2d.prototype.setGroups = function(groups) {};

/**
 * @param {(!Array<?>|?)} items
 * @return {void}
 */
Graph2d.prototype.setItems = function(items) {};

/**
 * @param {?} options
 * @return {void}
 */
Graph2d.prototype.setOptions = function(options) {};

/**
 * @param {(string|number|!Array<(string|number)>)} ids
 * @return {void}
 */
Graph2d.prototype.setSelection = function(ids) {};

/**
 * @param {(string|number|!Date)} start
 * @param {(string|number|!Date)} end
 * @param {?=} options
 * @return {void}
 */
Graph2d.prototype.setWindow = function(start, end, options) {};

/**
 * @param {!Array<?>=} groups
 * @return {void}
 */
Graph2d.prototype.setGroups = function(groups) {};

/**
 * @param {!Array<?>=} items
 * @return {void}
 */
Graph2d.prototype.setItems = function(items) {};

/**
 * @return {?}
 */
Graph2d.prototype.getLegend = function() {};

/**
 * @return {?}
 */
Graph2d.prototype.getWindow = function() {};

/**
 * @param {?} start
 * @param {?} date
 * @return {void}
 */
Graph2d.prototype.setWindow = function(start, date) {};

/**
 * @param {?} selection
 * @return {void}
 */
Graph2d.prototype.focus = function(selection) {};

/**
 * @param {string=} event
 * @param {?=} callback
 * @return {void}
 */
Graph2d.prototype.on = function(event, callback) {};

/**
 * @constructor
 * @struct
 * @param {!HTMLElement} container
 * @param {(!Array<?>|?)} items
 * @param {(!Array<?>|?)|?=} groups_or_options
 * @param {?=} options
 */
function Timeline(container, items, groups_or_options, options) {}

/**
 * @param {(string|number|!Date)} time
 * @param {(string|number)=} id
 * @return {(string|number)}
 */
Timeline.prototype.addCustomTime = function(time, id) {};

/**
 * @return {void}
 */
Timeline.prototype.destroy = function() {};

/**
 * @param {?=} options
 * @return {void}
 */
Timeline.prototype.fit = function(options) {};

/**
 * @param {(string|number|!Array<(string|number)>)} ids
 * @param {?=} options
 * @return {void}
 */
Timeline.prototype.focus = function(ids, options) {};

/**
 * @return {!Date}
 */
Timeline.prototype.getCurrentTime = function() {};

/**
 * @param {(string|number)=} id
 * @return {!Date}
 */
Timeline.prototype.getCustomTime = function(id) {};

/**
 * @param {!Event} event
 * @return {?}
 */
Timeline.prototype.getEventProperties = function(event) {};

/**
 * @return {?}
 */
Timeline.prototype.getItemRange = function() {};

/**
 * @return {!Array<(string|number)>}
 */
Timeline.prototype.getSelection = function() {};

/**
 * @return {!Array<(string|number)>}
 */
Timeline.prototype.getVisibleItems = function() {};

/**
 * @return {?}
 */
Timeline.prototype.getWindow = function() {};

/**
 * @param {(string|number|!Date)} time
 * @param {?=} options
 * @return {void}
 */
Timeline.prototype.moveTo = function(time, options) {};

/**
 * @param {string} event
 * @param {?} callback
 * @return {void}
 */
Timeline.prototype.on = function(event, callback) {};

/**
 * @param {string} event
 * @param {?} callback
 * @return {void}
 */
Timeline.prototype.off = function(event, callback) {};

/**
 * @return {void}
 */
Timeline.prototype.redraw = function() {};

/**
 * @param {(string|number)} id
 * @return {void}
 */
Timeline.prototype.removeCustomTime = function(id) {};

/**
 * @param {(string|number|!Date)} time
 * @return {void}
 */
Timeline.prototype.setCurrentTime = function(time) {};

/**
 * @param {(string|number|!Date)} time
 * @param {(string|number)=} id
 * @return {void}
 */
Timeline.prototype.setCustomTime = function(time, id) {};

/**
 * @param {string} title
 * @param {(string|number)=} id
 * @return {void}
 */
Timeline.prototype.setCustomTimeTitle = function(title, id) {};

/**
 * @param {?} data
 * @return {void}
 */
Timeline.prototype.setData = function(data) {};

/**
 * @param {(!Array<?>|?)=} groups
 * @return {void}
 */
Timeline.prototype.setGroups = function(groups) {};

/**
 * @param {(!Array<?>|?)} items
 * @return {void}
 */
Timeline.prototype.setItems = function(items) {};

/**
 * @param {?} options
 * @return {void}
 */
Timeline.prototype.setOptions = function(options) {};

/**
 * @param {(string|number|!Array<(string|number)>)} ids
 * @return {void}
 */
Timeline.prototype.setSelection = function(ids) {};

/**
 * @param {(string|number|!Date)} start
 * @param {(string|number|!Date)} end
 * @param {?=} options
 * @return {void}
 */
Timeline.prototype.setWindow = function(start, end, options) {};
/**
 * @record
 * @struct
 */
function TimelineStatic() {}

/* TODO: ConstructSignature:  */

/**
 * @param {!Array<?>=} groups
 * @return {void}
 */
Timeline.prototype.setGroups = function(groups) {};

/**
 * @param {!Array<?>=} items
 * @return {void}
 */
Timeline.prototype.setItems = function(items) {};

/**
 * @return {?}
 */
Timeline.prototype.getWindow = function() {};

/**
 * @param {?} start
 * @param {?} date
 * @return {void}
 */
Timeline.prototype.setWindow = function(start, date) {};

/**
 * @param {?} selection
 * @return {void}
 */
Timeline.prototype.focus = function(selection) {};

/**
 * @param {string=} event
 * @param {?=} callback
 * @return {void}
 */
Timeline.prototype.on = function(event, callback) {};
/**
 * @record
 * @struct
 */
function TimelineWindow() {}
 /** @type {!Date} */
TimelineWindow.prototype.start;
 /** @type {!Date} */
TimelineWindow.prototype.end;
/**
 * @record
 * @struct
 */
function TimelineItem() {}
 /** @type {number} */
TimelineItem.prototype.id;
 /** @type {string} */
TimelineItem.prototype.content;
 /** @type {number} */
TimelineItem.prototype.group;
 /** @type {number} */
TimelineItem.prototype.start;
 /** @type {number} */
TimelineItem.prototype.end;
 /** @type {boolean} */
TimelineItem.prototype.editable;
/**
 * @record
 * @struct
 */
function TimelineGroup() {}
 /** @type {number} */
TimelineGroup.prototype.id;
 /** @type {string} */
TimelineGroup.prototype.content;
 /** @type {string} */
TimelineGroup.prototype.style;
/**
 * @record
 * @struct
 */
function VisSelectProperties() {}
 /** @type {!Array<number>} */
VisSelectProperties.prototype.items;

/** @typedef {string} */
var NetworkEvents;

/**
 * @constructor
 * @struct
 * Creates an instance of Network.
 * 
 * 
 * \@memberOf Network
 * @param {!HTMLElement} container
 * @param {?} data
 * @param {?=} options
 */
function Network(container, data, options) {}

/**
 * 	Remove the network from the DOM and remove all Hammer bindings and references.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.destroy = function() {};

/**
 * Override all the data in the network.
 * If stabilization is enabled in the physics module,
 * the network will stabilize again.
 * This method is also performed when first initializing the network.
 * 
 * 
 * \@memberOf Network
 * @param {?} data
 * @return {void}
 */
Network.prototype.setData = function(data) {};

/**
 * Set the options.
 * All available options can be found in the modules above.
 * Each module requires it's own container with the module name to contain its options.
 * 
 * 
 * \@memberOf Network
 * @param {?} options
 * @return {void}
 */
Network.prototype.setOptions = function(options) {};

/**
 * Set an event listener.
 * Depending on the type of event you get different parameters for the callback function.
 * 
 * 
 * \@memberOf Network
 * @param {string} eventName
 * @param {?} callback
 * @return {void}
 */
Network.prototype.on = function(eventName, callback) {};

/**
 * Remove an event listener.
 * The function you supply has to be the exact same as the one you used in the on function.
 * If no function is supplied, all listeners will be removed.
 * 
 * 
 * \@memberOf Network
 * @param {string} eventName
 * @param {?=} callback
 * @return {void}
 */
Network.prototype.off = function(eventName, callback) {};

/**
 * Set an event listener only once.
 * After it has taken place, the event listener will be removed.
 * Depending on the type of event you get different parameters for the callback function.
 * 
 * 
 * \@memberOf Network
 * @param {string} eventName
 * @param {?} callback
 * @return {void}
 */
Network.prototype.once = function(eventName, callback) {};

/**
 * This function converts canvas coordinates to coordinates on the DOM.
 * Input and output are in the form of {x:Number, y:Number} (IPosition interface).
 * The DOM values are relative to the network container.
 * 
 * 
 * \@memberOf Network
 * @param {?} position
 * @return {?}
 */
Network.prototype.canvasToDOM = function(position) {};

/**
 * This function converts DOM coordinates to coordinates on the canvas.
 * Input and output are in the form of {x:Number,y:Number} (IPosition interface).
 * The DOM values are relative to the network container.
 * 
 * 
 * \@memberOf Network
 * @param {?} position
 * @return {?}
 */
Network.prototype.DOMtoCanvas = function(position) {};

/**
 * Redraw the network.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.redraw = function() {};

/**
 * Set the size of the canvas.
 * This is automatically done on a window resize.
 * 
 * 
 * \@memberOf Network
 * @param {string} width
 * @param {string} height
 * @return {void}
 */
Network.prototype.setSize = function(width, height) {};

/**
 * The joinCondition function is presented with all nodes.
 * 
 * 
 * \@memberOf Network
 * @param {?=} options
 * @return {void}
 */
Network.prototype.cluster = function(options) {};

/**
 * 	This method looks at the provided node and makes a cluster of it and all it's connected nodes.
 * The behaviour can be customized by proving the options object.
 * All options of this object are explained below.
 * The joinCondition is only presented with the connected nodes.
 * 
 * 
 * \@memberOf Network
 * @param {string} nodeId
 * @param {?=} options
 * @return {void}
 */
Network.prototype.clusterByConnection = function(nodeId, options) {};

/**
 * This method checks all nodes in the network and those with a equal or higher
 * amount of edges than specified with the hubsize qualify.
 * If a hubsize is not defined, the hubsize will be determined as the average
 * value plus two standard deviations.
 * For all qualifying nodes, clusterByConnection is performed on each of them.
 * The options object is described for clusterByConnection and does the same here.
 * 
 * 
 * \@memberOf Network
 * @param {number=} hubsize
 * @param {?=} options
 * @return {void}
 */
Network.prototype.clusterByHubsize = function(hubsize, options) {};

/**
 * This method will cluster all nodes with 1 edge with their respective connected node.
 * 
 * 
 * \@memberOf Network
 * @param {?=} options
 * @return {void}
 */
Network.prototype.clusterOutliers = function(options) {};

/**
 * Nodes can be in clusters.
 * Clusters can also be in clusters.
 * This function returns an array of nodeIds showing where the node is.
 * 
 * Example:
 * cluster 'A' contains cluster 'B', cluster 'B' contains cluster 'C',
 * cluster 'C' contains node 'fred'.
 * 
 * network.clustering.findNode('fred') will return ['A','B','C','fred'].
 * 
 * 
 * \@memberOf Network
 * @param {(string|number)} nodeId
 * @return {!Array<(string|number)>}
 */
Network.prototype.findNode = function(nodeId) {};

/**
 * Similar to findNode in that it returns all the edge ids that were
 * created from the provided edge during clustering.
 * 
 * @param {(string|number)} baseEdgeId
 * @return {!Array<(string|number)>}
 */
Network.prototype.getClusteredEdges = function(baseEdgeId) {};

/**
 * When a clusteredEdgeId is available, this method will return the original
 * baseEdgeId provided in data.edges ie.
 * After clustering the 'SelectEdge' event is fired but provides only the clustered edge.
 * This method can then be used to return the baseEdgeId.
 * 
 * @param {(string|number)} clusteredEdgeId
 * @return {(string|number)}
 */
Network.prototype.getBaseEdge = function(clusteredEdgeId) {};

/**
 * Visible edges between clustered nodes are not the same edge as the ones provided
 * in data.edges passed on network creation. With each layer of clustering, copies of
 * the edges between clusters are created and the previous edges are hidden,
 * until the cluster is opened. This method takes an edgeId (ie. a base edgeId from data.edges)
 * and applys the options to it and any edges that were created from it while clustering.
 * 
 * @param {(string|number)} startEdgeId
 * @param {?=} options
 * @return {void}
 */
Network.prototype.updateEdge = function(startEdgeId, options) {};

/**
 * Clustered Nodes when created are not contained in the original data.nodes
 * passed on network creation. This method updates the cluster node.
 * @param {(string|number)} clusteredNodeId
 * @param {?=} options
 * @return {void}
 */
Network.prototype.updateClusteredNode = function(clusteredNodeId, options) {};

/**
 * Returns true if the node whose ID has been supplied is a cluster.
 * 
 * 
 * \@memberOf Network
 * @param {(string|number)} nodeId
 * @return {boolean}
 */
Network.prototype.isCluster = function(nodeId) {};

/**
 * Returns an array of all nodeIds of the nodes that
 * would be released if you open the cluster.
 * 
 * 
 * \@memberOf Network
 * @param {(string|number)} clusterNodeId
 * @return {!Array<(string|number)>}
 */
Network.prototype.getNodesInCluster = function(clusterNodeId) {};

/**
 * Opens the cluster, releases the contained nodes and edges,
 * removing the cluster node and cluster edges.
 * The options object is optional and currently supports one option,
 * releaseFunction, which is a function that can be used to manually
 * position the nodes after the cluster is opened.
 * 
 * 
 * \@memberOf Network
 * @param {(string|number)} nodeId
 * @param {?=} options
 * @return {void}
 */
Network.prototype.openCluster = function(nodeId, options) {};

/**
 * If you like the layout of your network
 * and would like it to start in the same way next time,
 * ask for the seed using this method and put it in the layout.randomSeed option.
 * 
 * 
 * \@memberOf Network
 * @return {number}
 */
Network.prototype.getSeed = function() {};

/**
 * 	Programatically enable the edit mode.
 * Similar effect to pressing the edit button.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.enableEditMode = function() {};

/**
 * Programatically disable the edit mode.
 * Similar effect to pressing the close icon (small cross in the corner of the toolbar).
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.disableEditMode = function() {};

/**
 * 	Go into addNode mode. Having edit mode or manipulation enabled is not required.
 * To get out of this mode, call disableEditMode().
 * The callback functions defined in handlerFunctions still apply.
 * To use these methods without having the manipulation GUI, make sure you set enabled to false.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.addNodeMode = function() {};

/**
 * Edit the selected node.
 * The explaination from addNodeMode applies here as well.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.editNode = function() {};

/**
 * Go into addEdge mode.
 * The explaination from addNodeMode applies here as well.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.addEdgeMode = function() {};

/**
 * Go into editEdge mode.
 * The explaination from addNodeMode applies here as well.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.editEdgeMode = function() {};

/**
 * Delete selected.
 * Having edit mode or manipulation enabled is not required.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.deleteSelected = function() {};

/**
 * Returns the x y positions in canvas space of the nodes with the supplied nodeIds as an object.
 * 
 * Alternative inputs are a String containing a nodeId or nothing.
 * When a String is supplied, the position of the node corresponding to the ID is returned.
 * When nothing is supplied, the positions of all nodes are returned.
 * 
 * 
 * \@memberOf Network
 * @param {!Array<(string|number)>|(string|number)=} nodeIds_or_nodeId
 * @return {?}
 */
Network.prototype.getPositions = function(nodeIds_or_nodeId) {};

/**
 * 	When using the vis.DataSet to load your nodes into the network,
 * this method will put the X and Y positions of all nodes into that dataset.
 * If you're loading your nodes from a database and have this dynamically coupled with the DataSet,
 * you can use this to stablize your network once, then save the positions in that database
 * through the DataSet so the next time you load the nodes, stabilization will be near instantaneous.
 * 
 * If the nodes are still moving and you're using dynamic smooth edges (which is on by default),
 * you can use the option stabilization.onlyDynamicEdges in the physics module to improve initialization time.
 * 
 * This method does not support clustering.
 * At the moment it is not possible to cache positions when using clusters since
 * they cannot be correctly initialized from just the positions.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.storePositions = function() {};

/**
 * You can use this to programatically move a node.
 * The supplied x and y positions have to be in canvas space!
 * 
 * 
 * \@memberOf Network
 * @param {(string|number)} nodeId
 * @param {number} x
 * @param {number} y
 * @return {void}
 */
Network.prototype.moveNode = function(nodeId, x, y) {};

/**
 * Returns a bounding box for the node including label.
 * 
 * 
 * \@memberOf Network
 * @param {(string|number)} nodeId
 * @return {?}
 */
Network.prototype.getBoundingBox = function(nodeId) {};

/**
 * Returns an array of nodeIds of the all the nodes that are directly connected to this node.
 * If you supply an edgeId, vis will first match the id to nodes.
 * If no match is found, it will search in the edgelist and return an array: [fromId, toId].
 * 
 * 
 * \@memberOf Network
 * @param {(string|number)} nodeOrEdgeId
 * @return {(!Array<(string|number)>|!Array<?>)}
 */
Network.prototype.getConnectedNodes = function(nodeOrEdgeId) {};

/**
 * Returns an array of edgeIds of the edges connected to this node.
 * 
 * 
 * \@memberOf Network
 * @param {(string|number)} nodeId
 * @return {!Array<(string|number)>}
 */
Network.prototype.getConnectedEdges = function(nodeId) {};

/**
 * Start the physics simulation.
 * This is normally done whenever needed and is only really useful
 * if you stop the simulation yourself and wish to continue it afterwards.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.startSimulation = function() {};

/**
 * This stops the physics simulation and triggers a stabilized event.
 * Tt can be restarted by dragging a node,
 * altering the dataset or calling startSimulation().
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.stopSimulation = function() {};

/**
 * You can manually call stabilize at any time.
 * All the stabilization options above are used.
 * You can optionally supply the number of iterations it should do.
 * 
 * 
 * \@memberOf Network
 * @param {number=} iterations
 * @return {void}
 */
Network.prototype.stabilize = function(iterations) {};

/**
 * Returns an object with selected nodes and edges ids.
 * 
 * 
 * \@memberOf Network
 * @return {?}
 */
Network.prototype.getSelection = function() {};

/**
 * Returns an array of selected node ids like so:
 * [nodeId1, nodeId2, ..].
 * 
 * 
 * \@memberOf Network
 * @return {!Array<(string|number)>}
 */
Network.prototype.getSelectedNodes = function() {};

/**
 * Returns an array of selected edge ids like so:
 * [edgeId1, edgeId2, ..].
 * 
 * 
 * \@memberOf Network
 * @return {!Array<(string|number)>}
 */
Network.prototype.getSelectedEdges = function() {};

/**
 * Returns a nodeId or undefined.
 * The DOM positions are expected to be in pixels from the top left corner of the canvas.
 * 
 * 
 * \@memberOf Network
 * @param {?} position
 * @return {(string|number)}
 */
Network.prototype.getNodeAt = function(position) {};

/**
 * Returns a edgeId or undefined.
 * The DOM positions are expected to be in pixels from the top left corner of the canvas.
 * 
 * 
 * \@memberOf Network
 * @param {?} position
 * @return {(string|number)}
 */
Network.prototype.getEdgeAt = function(position) {};

/**
 * Selects the nodes corresponding to the id's in the input array.
 * If highlightEdges is true or undefined, the neighbouring edges will also be selected.
 * This method unselects all other objects before selecting its own objects. Does not fire events.
 * 
 * 
 * \@memberOf Network
 * @param {!Array<(string|number)>} nodeIds
 * @param {boolean=} highlightEdges
 * @return {void}
 */
Network.prototype.selectNodes = function(nodeIds, highlightEdges) {};

/**
 * Selects the edges corresponding to the id's in the input array.
 * This method unselects all other objects before selecting its own objects.
 * Does not fire events.
 * 
 * 
 * \@memberOf Network
 * @param {!Array<(string|number)>} edgeIds
 * @return {void}
 */
Network.prototype.selectEdges = function(edgeIds) {};

/**
 * Sets the selection.
 * You can also pass only nodes or edges in selection object.
 * 
 * 
 * \@memberOf Network
 * @param {?} selection
 * @param {?=} options
 * @return {void}
 */
Network.prototype.setSelection = function(selection, options) {};

/**
 * Unselect all objects.
 * Does not fire events.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.unselectAll = function() {};

/**
 * Returns the current scale of the network.
 * 1.0 is comparible to 100%, 0 is zoomed out infinitely.
 * 
 * 
 * \@memberOf Network
 * @return {number}
 */
Network.prototype.getScale = function() {};

/**
 * Returns the current central focus point of the view in the form: { x: {Number}, y: {Number} }
 * 
 * 
 * \@memberOf Network
 * @return {?}
 */
Network.prototype.getViewPosition = function() {};

/**
 * Zooms out so all nodes fit on the canvas.
 * 
 * 
 * \@memberOf Network
 * @param {?=} options
 * @return {void}
 */
Network.prototype.fit = function(options) {};

/**
 * You can focus on a node with this function.
 * What that means is the view will lock onto that node, if it is moving, the view will also move accordingly.
 * If the view is dragged by the user, the focus is broken. You can supply options to customize the effect.
 * 
 * 
 * \@memberOf Network
 * @param {(string|number)} nodeId
 * @param {?=} options
 * @return {void}
 */
Network.prototype.focus = function(nodeId, options) {};

/**
 * You can animate or move the camera using the moveTo method.
 * 
 * 
 * \@memberOf Network
 * @param {?} options
 * @return {void}
 */
Network.prototype.moveTo = function(options) {};

/**
 * Programatically release the focussed node.
 * 
 * \@memberOf Network
 * @return {void}
 */
Network.prototype.releaseNode = function() {};

/**
 * If you use the configurator, you can call this method to get an options object that contains
 * all differences from the default options caused by users interacting with the configurator.
 * 
 * 
 * \@memberOf Network
 * @return {?}
 */
Network.prototype.getOptionsFromConfigurator = function() {};
/**
 * @extends {ViewPortOptions}
 * @record
 * @struct
 */
function FocusOptions() {}
 /** @type {boolean} */
FocusOptions.prototype.locked;
/**
 * @record
 * @struct
 */
function ViewPortOptions() {}
 /** @type {number} */
ViewPortOptions.prototype.scale;
 /** @type {?} */
ViewPortOptions.prototype.offset;
 /** @type {(boolean|?)} */
ViewPortOptions.prototype.animation;
/**
 * @extends {ViewPortOptions}
 * @record
 * @struct
 */
function MoveToOptions() {}
 /** @type {?} */
MoveToOptions.prototype.position;
/**
 * @record
 * @struct
 */
function AnimationOptions() {}
 /** @type {number} */
AnimationOptions.prototype.duration;
 /** @type {string} */
AnimationOptions.prototype.easingFunction;
/**
 * @record
 * @struct
 */
function FitOptions() {}
 /** @type {!Array<string>} */
FitOptions.prototype.nodes;
 /** @type {(boolean|?)} */
FitOptions.prototype.animation;
/**
 * @record
 * @struct
 */
function SelectionOptions() {}
 /** @type {boolean} */
SelectionOptions.prototype.unselectAll;
 /** @type {boolean} */
SelectionOptions.prototype.highlightEdges;
/**
 * @record
 * @struct
 */
function BoundingBox() {}
 /** @type {number} */
BoundingBox.prototype.top;
 /** @type {number} */
BoundingBox.prototype.left;
 /** @type {number} */
BoundingBox.prototype.right;
 /** @type {number} */
BoundingBox.prototype.bottom;
/**
 * @record
 * @struct
 */
function ClusterOptions() {}
 /** @type {?} */
ClusterOptions.prototype.clusterNodeProperties;
 /** @type {?} */
ClusterOptions.prototype.clusterEdgeProperties;

/**
 * Optional for all but the cluster method.
 * The cluster module loops over all nodes that are selected to be in the cluster
 * and calls this function with their data as argument. If this function returns true,
 * this node will be added to the cluster. You have access to all options (including the default)
 * as well as any custom fields you may have added to the node to determine whether or not to include it in the cluster.
 * 
 * \@memberOf IClusterOptions
 * @param {?} nodeOptions
 * @return {boolean}
 */
ClusterOptions.prototype.joinCondition = function(nodeOptions) {};

/**
 * Optional.
 * Before creating the new cluster node, this (optional) function will be called with the properties
 * supplied by you (clusterNodeProperties), all contained nodes and all contained edges.
 * You can use this to update the properties of the cluster based on which items it contains.
 * The function should return the properties to create the cluster node.
 * 
 * \@memberOf IClusterOptions
 * @param {?} clusterOptions
 * @param {!Array<?>} childNodesOptions
 * @param {!Array<?>} childEdgesOptions
 * @return {?}
 */
ClusterOptions.prototype.processProperties = function(clusterOptions, childNodesOptions, childEdgesOptions) {};
/**
 * @record
 * @struct
 */
function OpenClusterOptions() {}

/**
 * A function that can be used to manually position the nodes after the cluster is opened.
 * The containedNodesPositions contain the positions of the nodes in the cluster at the
 * moment they were clustered. This function is expected to return the newPositions,
 * which can be the containedNodesPositions (altered) or a new object.
 * This has to be an object with keys equal to the nodeIds that exist in the
 * containedNodesPositions and an {x:x,y:y} position object.
 * 
 * For all nodeIds not listed in this returned object,
 * we will position them at the location of the cluster.
 * This is also the default behaviour when no releaseFunction is defined.
 * 
 * \@memberOf IOpenClusterOptions
 * @param {?} clusterPosition
 * @param {?} containedNodesPositions
 * @return {?}
 */
OpenClusterOptions.prototype.releaseFunction = function(clusterPosition, containedNodesPositions) {};
/**
 * @record
 * @struct
 */
function Position() {}
 /** @type {number} */
Position.prototype.x;
 /** @type {number} */
Position.prototype.y;
/**
 * @record
 * @struct
 */
function Properties() {}
 /** @type {!Array<string>} */
Properties.prototype.nodes;
 /** @type {!Array<string>} */
Properties.prototype.edges;
 /** @type {!Array<string>} */
Properties.prototype.event;
 /** @type {?} */
Properties.prototype.pointer;
 /** @type {?} */
Properties.prototype.previousSelection;
/**
 * @record
 * @struct
 */
function Callback() {}

/**
 * @param {?=} params
 * @return {void}
 */
Callback.prototype.callback = function(params) {};
/**
 * @record
 * @struct
 */
function Data() {}
 /** @type {(!Array<?>|?)} */
Data.prototype.nodes;
 /** @type {(!Array<?>|?)} */
Data.prototype.edges;
/**
 * @record
 * @struct
 */
function Node() {}
 /** @type {string} */
Node.prototype.group;
 /** @type {(string|number)} */
Node.prototype.id;
 /** @type {string} */
Node.prototype.label;
 /** @type {number} */
Node.prototype.x;
 /** @type {number} */
Node.prototype.y;
 /** @type {boolean} */
Node.prototype.fixed;
 /** @type {string} */
Node.prototype.image;
 /** @type {string} */
Node.prototype.shape;
/**
 * @record
 * @struct
 */
function Edge() {}
 /** @type {(string|number)} */
Edge.prototype.from;
 /** @type {(string|number)} */
Edge.prototype.to;
 /** @type {(string|number)} */
Edge.prototype.id;
/**
 * @record
 * @struct
 */
function Locales() {}

/* TODO: IndexSignature:  */
 /** @type {?} */
Locales.prototype.en;
 /** @type {?} */
Locales.prototype.de;
 /** @type {?} */
Locales.prototype.es;
 /** @type {?} */
Locales.prototype.it;
 /** @type {?} */
Locales.prototype.nl;

/* TODO: PropertySignature: 'pt-br' */
 /** @type {?} */
Locales.prototype.ru;
/**
 * @record
 * @struct
 */
function LocaleMessages() {}
 /** @type {string} */
LocaleMessages.prototype.edit;
 /** @type {string} */
LocaleMessages.prototype.del;
 /** @type {string} */
LocaleMessages.prototype.back;
 /** @type {string} */
LocaleMessages.prototype.addNode;
 /** @type {string} */
LocaleMessages.prototype.addEdge;
 /** @type {string} */
LocaleMessages.prototype.editNode;
 /** @type {string} */
LocaleMessages.prototype.editEdge;
 /** @type {string} */
LocaleMessages.prototype.addDescription;
 /** @type {string} */
LocaleMessages.prototype.edgeDescription;
 /** @type {string} */
LocaleMessages.prototype.editEdgeDescription;
 /** @type {string} */
LocaleMessages.prototype.createEdgeError;
 /** @type {string} */
LocaleMessages.prototype.deleteClusterError;
 /** @type {string} */
LocaleMessages.prototype.editClusterError;
/**
 * @record
 * @struct
 */
function Options() {}
 /** @type {boolean} */
Options.prototype.autoResize;
 /** @type {string} */
Options.prototype.width;
 /** @type {string} */
Options.prototype.height;
 /** @type {string} */
Options.prototype.locale;
 /** @type {?} */
Options.prototype.locales;
 /** @type {boolean} */
Options.prototype.clickToUse;
 /** @type {?} */
Options.prototype.configure;
 /** @type {?} */
Options.prototype.edges;
 /** @type {?} */
Options.prototype.nodes;
 /** @type {?} */
Options.prototype.groups;
 /** @type {?} */
Options.prototype.layout;
 /** @type {?} */
Options.prototype.interaction;
 /** @type {?} */
Options.prototype.manipulation;
 /** @type {?} */
Options.prototype.physics;
/**
 * @record
 * @struct
 */
function NodeOptions() {}
 /** @type {number} */
NodeOptions.prototype.borderWidth;
 /** @type {number} */
NodeOptions.prototype.borderWidthSelected;
 /** @type {string} */
NodeOptions.prototype.brokenImage;
 /** @type {?} */
NodeOptions.prototype.color;
 /** @type {(boolean|?)} */
NodeOptions.prototype.fixed;
 /** @type {(string|?)} */
NodeOptions.prototype.font;
 /** @type {string} */
NodeOptions.prototype.group;
 /** @type {boolean} */
NodeOptions.prototype.hidden;
 /** @type {?} */
NodeOptions.prototype.icon;
 /** @type {string} */
NodeOptions.prototype.id;
 /** @type {string} */
NodeOptions.prototype.image;
 /** @type {string} */
NodeOptions.prototype.label;
 /** @type {boolean} */
NodeOptions.prototype.labelHighlightBold;
 /** @type {number} */
NodeOptions.prototype.level;
 /** @type {number} */
NodeOptions.prototype.mass;
 /** @type {boolean} */
NodeOptions.prototype.physics;
 /** @type {?} */
NodeOptions.prototype.scaling;
 /** @type {(boolean|?)} */
NodeOptions.prototype.shadow;
 /** @type {string} */
NodeOptions.prototype.shape;
 /** @type {?} */
NodeOptions.prototype.shapeProperties;
 /** @type {number} */
NodeOptions.prototype.size;
 /** @type {string} */
NodeOptions.prototype.title;
 /** @type {number} */
NodeOptions.prototype.value;
 /** @type {number} */
NodeOptions.prototype.x;
 /** @type {number} */
NodeOptions.prototype.y;
/**
 * @record
 * @struct
 */
function EdgeOptions() {}
 /** @type {(string|?)} */
EdgeOptions.prototype.arrows;
 /** @type {boolean} */
EdgeOptions.prototype.arrowStrikethrough;
 /** @type {(string|?)} */
EdgeOptions.prototype.color;
 /** @type {(boolean|!Array<number>)} */
EdgeOptions.prototype.dashes;
 /** @type {(string|?)} */
EdgeOptions.prototype.font;
 /** @type {(string|number)} */
EdgeOptions.prototype.from;
 /** @type {boolean} */
EdgeOptions.prototype.hidden;
 /** @type {number} */
EdgeOptions.prototype.hoverWidth;
 /** @type {string} */
EdgeOptions.prototype.id;
 /** @type {string} */
EdgeOptions.prototype.label;
 /** @type {boolean} */
EdgeOptions.prototype.labelHighlightBold;
 /** @type {number} */
EdgeOptions.prototype.length;
 /** @type {boolean} */
EdgeOptions.prototype.physics;
 /** @type {?} */
EdgeOptions.prototype.scaling;
 /** @type {number} */
EdgeOptions.prototype.selectionWidth;
 /** @type {number} */
EdgeOptions.prototype.selfReferenceSize;
 /** @type {(boolean|?)} */
EdgeOptions.prototype.shadow;
 /** @type {(boolean|?)} */
EdgeOptions.prototype.smooth;
 /** @type {string} */
EdgeOptions.prototype.title;
 /** @type {(string|number)} */
EdgeOptions.prototype.to;
 /** @type {number} */
EdgeOptions.prototype.value;
 /** @type {number} */
EdgeOptions.prototype.width;
/**
 * @record
 * @struct
 */
function OptionsScaling() {}
 /** @type {number} */
OptionsScaling.prototype.min;
 /** @type {number} */
OptionsScaling.prototype.max;
 /** @type {(boolean|?)} */
OptionsScaling.prototype.label;

/**
 * @param {number=} min
 * @param {number=} max
 * @param {number=} total
 * @param {number=} value
 * @return {number}
 */
OptionsScaling.prototype.customScalingFunction = function(min, max, total, value) {};
/**
 * @record
 * @struct
 */
function OptionsShadow() {}
 /** @type {boolean} */
OptionsShadow.prototype.enabled;
 /** @type {string} */
OptionsShadow.prototype.color;
 /** @type {number} */
OptionsShadow.prototype.size;
 /** @type {number} */
OptionsShadow.prototype.x;
 /** @type {number} */
OptionsShadow.prototype.y;

/* TODO: NamespaceExportDeclaration in  */
