/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/meteor-roles/index.d.ts:
/** @const */
var Roles = {};
 /** @type {string} */
Roles.GLOBAL_GROUP;
 /** @type {!Subscription} */
Roles.subscription;

/**
 * Add users to roles. Will create roles as needed.
 * 
 * NOTE: Mixing grouped and non-grouped roles for the same user
 *       is not supported and will throw an error.
 * 
 * Makes 2 calls to database:
 *  1. retrieve list of all existing roles
 *  2. update users' roles
 * 
 * \@example 
 *     Roles.addUsersToRoles(userId, 'admin')
 *     Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')
 *     Roles.addUsersToRoles([user1, user2], ['user','editor'])
 *     Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')
 *     Roles.addUsersToRoles(userId, 'admin', Roles.GLOBAL_GROUP)
 * 
 * \@method addUsersToRoles
 *                         specific to that group.
 *                         Group names can not start with '$' or numbers.
 *                         Periods in names '.' are automatically converted
 *                         to underscores.
 *                         The special group Roles.GLOBAL_GROUP provides
 *                         a convenient way to assign blanket roles/permissions
 *                         across all groups.  The roles/permissions in the
 *                         Roles.GLOBAL_GROUP group will be automatically
 *                         included in checks for any group.
 * @param {(string|!Object|!Array<string>|!Array<!Object>)} user
 * @param {(string|!Array<string>)} roles
 * @param {string=} group
 * @return {void}
 */
Roles.addUsersToRoles = function(user, roles, group) {};

/**
 * Create a new role. Whitespace will be trimmed.
 * 
 * \@method createRole
 * @param {string} role
 * @return {string}
 */
Roles.createRole = function(role) {};

/**
 * Delete an existing role.  Will throw "Role in use" error if any users
 * are currently assigned to the target role.
 * 
 * \@method deleteRole
 * @param {string} role
 * @return {void}
 */
Roles.deleteRole = function(role) {};

/**
 * Retrieve set of all existing roles
 * 
 * \@method getAllRoles
 * @return {?<!Roles.Role>}
 */
Roles.getAllRoles = function() {};

/**
 * Retrieve users groups, if any
 * 
 * \@method getGroupsForUser
 * 
 * @param {(string|!Object)} user
 * @param {string=} role
 * @return {!Array<string>}
 */
Roles.getGroupsForUser = function(user, role) {};

/**
 * Retrieve users roles
 * 
 * \@method getRolesForUser
 *                         User's Roles.GLOBAL_GROUP will also be included.
 * @param {(string|!Object)} user
 * @param {string=} group
 * @return {!Array<string>}
 */
Roles.getRolesForUser = function(user, group) {};

/**
 * Retrieve all users who are in target role.
 * 
 * NOTE: This is an expensive query; it performs a full collection scan
 * on the users collection since there is no index set on the 'roles' field.
 * This is by design as most queries will specify an _id so the _id index is
 * used automatically.
 * 
 * \@method getUsersInRole
 *                            returned will have at least one of the roles
 *                            specified but need not have _all_ roles.
 *                         User's Roles.GLOBAL_GROUP will also be checked.
 *                           through to `Meteor.users.find(query, options)`
 * @param {(string|!Array<string>)} role
 * @param {string=} group
 * @param {{sort: !Mongo.SortSpecifier, skip: number, limit: number, fields: !Mongo.FieldSpecifier, reactive: boolean, transform: !Function}=} options
 * @return {?<!Meteor.User>}
 */
Roles.getUsersInRole = function(role, group, options) {};

/**
 * Remove users from roles
 * 
 * \@example 
 *     Roles.removeUsersFromRoles(users.bob, 'admin')
 *     Roles.removeUsersFromRoles([users.bob, users.joe], ['editor'])
 *     Roles.removeUsersFromRoles([users.bob, users.joe], ['editor', 'user'])
 *     Roles.removeUsersFromRoles(users.eve, ['user'], 'group1')
 * 
 * \@method removeUsersFromRoles
 *                         group will have roles removed.
 * @param {(string|!Object|!Array<string>|!Array<!Object>)} user
 * @param {!Array<string>=} roles
 * @param {string=} group
 * @return {void}
 */
Roles.removeUsersFromRoles = function(user, roles, group) {};

/**
 * Set a users roles/permissions.
 * 
 * \@example 
 *     Roles.setUserRoles(userId, 'admin')
 *     Roles.setUserRoles(userId, ['view-secrets'], 'example.com')
 *     Roles.setUserRoles([user1, user2], ['user','editor'])
 *     Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')
 *     Roles.setUserRoles(userId, 'admin', Roles.GLOBAL_GROUP)
 * 
 * \@method setUserRoles
 *                         specific to that group.
 *                         Group names can not start with '$'.
 *                         Periods in names '.' are automatically converted
 *                         to underscores.
 *                         The special group Roles.GLOBAL_GROUP provides
 *                         a convenient way to assign blanket roles/permissions
 *                         across all groups.  The roles/permissions in the
 *                         Roles.GLOBAL_GROUP group will be automatically
 *                         included in checks for any group.
 * @param {(string|!Object|!Array<string>|!Array<!Object>)} user
 * @param {(string|!Array<string>)} roles
 * @param {string=} group
 * @return {void}
 */
Roles.setUserRoles = function(user, roles, group) {};

/**
 * Check if user has specified permissions/roles
 * 
 * \@example 
 *     // non-group usage
 *     Roles.userIsInRole(user, 'admin')
 *     Roles.userIsInRole(user, ['admin','editor'])
 *     Roles.userIsInRole(userId, 'admin')
 *     Roles.userIsInRole(userId, ['admin','editor'])
 * 
 *     // per-group usage
 *     Roles.userIsInRole(user,   ['admin','editor'], 'group1')
 *     Roles.userIsInRole(userId, ['admin','editor'], 'group1')
 *     Roles.userIsInRole(userId, ['admin','editor'], Roles.GLOBAL_GROUP)
 * 
 *     // this format can also be used as short-hand for Roles.GLOBAL_GROUP
 *     Roles.userIsInRole(user, 'admin')
 * 
 * \@method userIsInRole
 *                            roles/permissions to check against.  If array,
 *                            will return true if user is in _any_ role.
 *                         to just that group.
 *                         The user's Roles.GLOBAL_GROUP will always be checked
 *                         whether group is specified or not.
 * @param {(string|!Object|!Array<string>|!Array<!Object>)} user
 * @param {(string|!Array<string>)} roles
 * @param {string=} group
 * @return {boolean}
 */
Roles.userIsInRole = function(user, roles, group) {};
/**
 * @record
 * @struct
 */
Roles.Role = function() {};
 /** @type {string} */
Roles.Role.prototype.name;
 /** @type {?<!Roles.Role>} */
Meteor.roles;
