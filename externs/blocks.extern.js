/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/blocks/index.d.ts:
/**
 * @record
 * @struct
 */
function BlocksStatic() {}

/* TODO: CallSignature:  */

/**
 * Performs a query operation on the DOM. Executes all data-query attributes
 * and renders the html result to the specified HTMLElement if not specified
 * uses document.body by default.
 * 
 * @param {?} model The model that will be used to query the DOM.
 * @param {!HTMLElement=} element Optional element on which to execute the query.
 * @return {void}
 */
BlocksStatic.prototype.query = function(model, element) {};

/**
 * Copies properties from all provided objects into the first object parameter
 * @param {!Object} obj
 * @param {...?} objects
 * @return {void}
 */
BlocksStatic.prototype.extend = function(obj, objects) {};

/**
 * Iterates over the collection
 * 
 * @param {?} collection The array or object to iterate over
 * @param {function(?, ?, ?): void} callback The callback that will be executed for each element in the collection
 * @param {?=} thisArg Optional this context for the callback
 * @return {void}
 */
BlocksStatic.prototype.each = function(collection, callback, thisArg) {};

/**
 * Iterates over the collection from end to start
 * 
 * @param {?} collection The array or object to iterate over
 * @param {function(?, ?, ?): void} callback The callback that will be executed for each element in the collection
 * @param {?=} thisArg Optional this context for the callback
 * @return {void}
 */
BlocksStatic.prototype.eachRight = function(collection, callback, thisArg) {};

/**
 * Determines if a value is an array.
 * Returns false for array like objects (for example arguments object).
 * 
 * @param {?} value The value to check if it is an array
 * @return {boolean}
 */
BlocksStatic.prototype.isArray = function(value) {};

/**
 * Represents a dummy empty function
 * @return {!Function}
 */
BlocksStatic.prototype.noop = function() {};

/**
 * Determines the true type of an object.
 * Returns the type of the value as a string.
 * 
 * @param {?} value The value for which to determine its type
 * @return {string}
 */
BlocksStatic.prototype.type = function(value) {};

/**
 * Determines if a specific value is the specified type
 * 
 * @param {?} value The value
 * @param {string} type The type
 * @return {boolean}
 */
BlocksStatic.prototype.is = function(value, type) {};

/**
 * Checks if a variable has the specified property. Uses hasOwnProperty internally
 * 
 * @param {?} obj The object to call hasOwnPrototype for
 * @param {string} key The key to check if exists in the object
 * @return {boolean}
 */
BlocksStatic.prototype.has = function(obj, key) {};

/**
 * Unwraps a jsblocks value to its raw representation.
 * Unwraps blocks.observable() and blocks() values
 * 
 * @param {?} value The value that will be unwrapped
 * @return {?}
 */
BlocksStatic.prototype.unwrap = function(value) {};

/**
 * Converts a value to an array. Arguments object is converted to array and primitive values
 * are wrapped in an array.
 * Does nothing when value is already an array
 * 
 * @param {?} value The value to be converted to an array
 * @return {!Array<?>}
 */
BlocksStatic.prototype.toArray = function(value) {};

/**
 * Converts an integer or string to a unit. If the value could not be parsed to a number it is not converted
 * 
 * @param {?} value The value to be converted to the specified unit
 * @param {string=} unit Optionally provide a unit to convert to. Default value is 'px'
 * @return {?}
 */
BlocksStatic.prototype.toUnit = function(value, unit) {};

/**
 * Clones value. If deepClone is set to true the value will be cloned recursively
 * 
 * @param {?} value Value/object to be cloned
 * @param {boolean=} deepClone By default false
 * @return {?}
 */
BlocksStatic.prototype.clone = function(value, deepClone) {};

/**
 * Determines if the specified value is a HTML elements collection.
 * Returns whether the value is elements collection.
 * 
 * @param {?} value The value to check if it is elements collection
 * @return {boolean}
 */
BlocksStatic.prototype.isElements = function(value) {};

/**
 * Determines if the specified value is a HTML element.
 * Returns whether the value is a HTML element.
 * 
 * @param {?} value The value to check if it is a HTML element
 * @return {boolean}
 */
BlocksStatic.prototype.isElement = function(value) {};

/**
 * Determines if a the specified value is a boolean.
 * Whether the value is a boolean or not.
 * 
 * @param {?} value The value to be checked if it is a boolean
 * @return {boolean}
 */
BlocksStatic.prototype.isBoolean = function(value) {};

/**
 * Determines if the specified value is an object.
 * Returns whether the value is an object.
 * 
 * @param {?} obj The value to check for if it is an object
 * @return {boolean}
 */
BlocksStatic.prototype.isObject = function(obj) {};

/**
 * Determines if a value is a object created using {} or new Object.
 * Whether the value is a plain object or not.
 * 
 * @param {?} obj The value that will be checked
 * @return {boolean}
 */
BlocksStatic.prototype.isPlainObject = function(obj) {};

/**
 * Changes the this binding to a function and optionally passes additional parameters to the function.
 * Returns the newly created function having the new this binding and optional arguments.
 * 
 * @param {!Function} func The function for which to change the this binding and optionally add arguments
 * @param {?} thisArg The new this binding context value
 * @param {...?} args Optional arguments that will be passed to the function
 * @return {!Function}
 */
BlocksStatic.prototype.bind = function(func, thisArg, args) {};

/**
 * Determines if two values are deeply equal. Set deepEqual to false to stop recusively equality checking
 * 
 * @param {?} a The first object to be campared
 * @param {?} b The second object to be compared
 * @param {boolean=} deepEqual Determines if the equality check will recursively check all child properties
 * @return {boolean}
 */
BlocksStatic.prototype.equals = function(a, b, deepEqual) {};

/**
 * Gets the context for a particular element. Searches all parents until it finds the context.
 * 
 * @param {?} element The element from which to search for a context
 * 
 * @return {?}
 */
BlocksStatic.prototype.context = function(element) {};

/**
 * Gets the associated dataItem for a particlar element. Searches all parents until it finds the context
 * 
 * @param {?} element The element from which to search for a dataItem
 * @return {?}
 */
BlocksStatic.prototype.dataItem = function(element) {};

/**
 * Determines if particular value is an blocks.observable
 * 
 * @param {?} value The value to check if the value is observable
 * @return {boolean}
 */
BlocksStatic.prototype.isObservable = function(value) {};

/**
 * Gets the raw value of an observable or returns the value if the specified object is not an observable
 * 
 * @param {?} value The value that could be any object observable or not
 * @return {?}
 */
BlocksStatic.prototype.unwrapObservable = function(value) {};

/**
 * @param {string} route
 * @return {!BlocksStatic}
 */
BlocksStatic.prototype.route = function(route) {};

/**
 * @param {string} param
 * @param {?=} defaultValue
 * @return {!BlocksStatic}
 */
BlocksStatic.prototype.optional = function(param, defaultValue) {};

/**
 * @param {number} start
 * @param {number} end
 * @return {!BlocksStatic}
 */
BlocksStatic.prototype.range = function(start, end) {};

/**
 * Creates the server which will automatically handle server-side rendering.
 * @param {!Server=} options Overrides default jsblocks options
 * @return {{express: function(): ?}}
 */
BlocksStatic.prototype.server = function(options) {};

/**
 * Make observable property. You can specify initial value in parentheses.
 * @param {!Array<?>|?=} value
 * @return {!BlocksObservable|!BlocksArray}
 */
BlocksStatic.prototype.observable = function(value) {};

/**
 * Use blocks.Application and its MVC(Model-View-Collection) structure to create better architecture and maintainability for your application.
 * @param {{history: string}=} options
 * @return {!App}
 */
BlocksStatic.prototype.Application = function(options) {};
/**
 * @extends {Extendable}
 * @record
 * @struct
 */
function BlocksObservable() {}

/* TODO: CallSignature:  */

/**
 * Updates all elements, expressions and dependencies where the observable is used
 * @return {!BlocksObservable}
 */
BlocksObservable.prototype.update = function() {};

/**
 * If event in prototype is not defined use this function instead.
 * 
 * @param {string} event Name of the event to raise
 * @param {!Function} trigger Function to be called when event is fired
 * @return {!BlocksObservable}
 */
BlocksObservable.prototype.on = function(event, trigger) {};
/**
 * @extends {BlocksObservable}
 * @record
 * @struct
 */
function BlocksArray() {}

/**
 * Updates all elements, expressions and dependencies where the observable is used
 * @return {!BlocksArray}
 */
BlocksArray.prototype.update = function() {};

/**
 * Extends the current observable with particular functionality depending on the parameters specified.
 * If the method is called without arguments and jsvalue framework is included the observable will be
 * extended with the methods available in jsvalue for the current type.
 * 
 * @param {...?|string} options_or_name Optional options / Name of the extender
 * @return {!BlocksArray}
 */
BlocksArray.prototype.extend = function(options_or_name) {};

/**
 * Removes all items from the collection and replaces them with the new value provided.
 * The value could be Array, observable array or jsvalue.Array
 * 
 * @param {!Array<?>} value The new value that will be populated
 * @return {!BlocksArray}
 */
BlocksArray.prototype.reset = function(value) {};

/**
 * Adds values to the end of the observable array
 * 
 * @param {?} value The values that will be added to the end of the array
 * @param {number=} index Optional index specifying where to insert the value
 * @return {!BlocksArray}
 */
BlocksArray.prototype.add = function(value, index) {};

/**
 * Adds the values from the provided array(s) to the end of the collection
 * 
 * @param {!Array<?>} value The array that will be added to the end of the array
 * @param {number=} index Optional position where the array of values to be inserted
 * @return {!BlocksArray}
 */
BlocksArray.prototype.addMany = function(value, index) {};

/**
 * Swaps two values in the observable array. Note: Faster than removing the items and adding them at the locations
 * 
 * @param {number} indexA The first index that points to the index in the array that will be swapped
 * @param {number} indexB The second index that points to the index in the array that will be swapped
 * @return {!BlocksArray}
 */
BlocksArray.prototype.swap = function(indexA, indexB) {};

/**
 * Moves an item from one location to another in the array. Note: Faster than removing the item and adding it at the location
 * 
 * @param {number} sourceIndex The index pointing to the item that will be moved
 * @param {number} targetIndex The index where the item will be moved to
 * @return {!BlocksArray}
 */
BlocksArray.prototype.move = function(sourceIndex, targetIndex) {};

/**
 * Removes an item from the observable array
 * 
 * @param {?} value The value that will be removed or a callback function which returns true or false to determine if the value should be removed
 * @param {!Function=} thisArg Optional this context for the callback
 * @return {!BlocksArray}
 */
BlocksArray.prototype.remove = function(value, thisArg) {};

/**
 * Removes an item at the specified index
 * 
 * @param {number} index The index location of the item that will be removed
 * @param {number=} count Optional parameter that if specified will remove the next items starting from the specified index
 * @return {!BlocksArray}
 */
BlocksArray.prototype.removeAt = function(index, count) {};

/**
 * Removes all items from the observable array and optionally filter which items to be removed by providing a callback
 * @param {!Function=} callback Optional callback function which filters which items to be removed. Returning a truthy value will remove the item and vice versa
 * @param {?=} thisArg Optional this context for the callback function
 * @return {!BlocksArray}
 */
BlocksArray.prototype.removeAll = function(callback, thisArg) {};

/**
 * The concat() method is used to join two or more arrays
 * 
 * @param {...?} arrays The arrays to be joined
 * @return {!Array<?>}
 */
BlocksArray.prototype.concat = function(arrays) {};

/**
 * The slice() method returns the selected elements in an array, as a new array object
 * 
 * @param {number} start An integer that specifies where to start the selection (The first element has an index of 0)
 * @param {number=} end An integer that specifies where to end the selection. If omitted, all elements from the start position and to the end of the array will be selected.
 *            Use negative numbers to select from the end of an array
 * @return {!Array<?>}
 */
BlocksArray.prototype.slice = function(start, end) {};

/**
 * The join() method joins the elements of an array into a string, and returns the string
 * @param {string=} seperator
 * @return {string}
 */
BlocksArray.prototype.join = function(seperator) {};

/**
 * The pop() method removes the last element of a observable array, and returns that element
 * @return {?}
 */
BlocksArray.prototype.pop = function() {};

/**
 * The push() method adds new items to the end of the observable array, and returns the new length
 * 
 * @param {...?} values The item(s) to add to the observable array
 * @return {number}
 */
BlocksArray.prototype.push = function(values) {};

/**
 * Reverses the order of the elements in the observable array
 * @return {!Array<?>}
 */
BlocksArray.prototype.reverse = function() {};

/**
 * Removes the first element of a observable array, and returns that element
 * @return {?}
 */
BlocksArray.prototype.shift = function() {};

/**
 * Sorts the elements of an array
 * @param {!Function=} sortfunction A function that defines the sort order
 * @return {!Array<?>}
 */
BlocksArray.prototype.sort = function(sortfunction) {};

/**
 * Adds and/or removes elements from the observable array
 * Returns A new array containing the removed items, if any.
 * 
 * @param {number} index An integer that specifies at what position to add/remove items. Use negative values to specify the position from the end of the array.
 * @param {number} howMany The number of items to be removed. If set to 0, no items will be removed.
 * @param {...?} items The new item(s) to be added to the array.
 * @return {!Array<?>}
 */
BlocksArray.prototype.splice = function(index, howMany, items) {};

/**
 * The unshift() method adds new items to the beginning of an array, and returns the new length.
 * 
 * @param {...?} items
 * @return {number}
 */
BlocksArray.prototype.unshift = function(items) {};
/**
 * @extends {Extendable}
 * @record
 * @struct
 */
function App() {}

/**
 * Creates an application property for a Model.
 * @param {!PropertyPrototype=} options Configuration options for property
 * @return {?}
 */
App.prototype.Property = function(options) {};

/**
 * Defines a view that will be part of the Application.
 * 
 * Defines a view that will be part of the Application.
 * 
 * @param {string} name_or_parentViewName The name of the View you are creating / Provide this parameter only if you are creating nested views. This is the name of the parent View
 * @param {!ViewPrototype|string} prototype_or_name The object that will represent the View / The name of the View you are creating
 * @param {!ViewPrototype=} prototype The object that will represent the View
 * @return {?}
 */
App.prototype.View = function(name_or_parentViewName, prototype_or_name, prototype) {};

/**
 * Creates a new Model
 * 
 * @param {!ModelPrototype} prototype The Model object properties that will be created
 * @return {!Model}
 */
App.prototype.Model = function(prototype) {};

/**
 * Creates a new Collection
 * 
 * @param {!CollectionPrototype|!Model} prototype_or_model The Collection object properties that will be created.
 * @param {!CollectionPrototype=} prototype
 * @return {!Collection}
 */
App.prototype.Collection = function(prototype_or_model, prototype) {};
/**
 * @record
 * @struct
 */
function PropertyPrototype() {}
 /** @type {?} */
PropertyPrototype.prototype.defaultValue;
 /** @type {boolean} */
PropertyPrototype.prototype.isObservable;
 /** @type {string} */
PropertyPrototype.prototype.field;
 /** @type {?} */
PropertyPrototype.prototype.value;
 /** @type {boolean} */
PropertyPrototype.prototype.validateOnChange;
 /** @type {number} */
PropertyPrototype.prototype.maxErrors;
 /** @type {boolean} */
PropertyPrototype.prototype.validateInitially;
 /** @type {!Validator} */
PropertyPrototype.prototype.required;
 /** @type {!Validator} */
PropertyPrototype.prototype.minlength;
 /** @type {!Validator} */
PropertyPrototype.prototype.maxlength;
 /** @type {!Validator} */
PropertyPrototype.prototype.min;
 /** @type {!Validator} */
PropertyPrototype.prototype.max;
 /** @type {!Validator} */
PropertyPrototype.prototype.email;
 /** @type {!Validator} */
PropertyPrototype.prototype.url;
 /** @type {!Validator} */
PropertyPrototype.prototype.date;
 /** @type {!Validator} */
PropertyPrototype.prototype.creditcard;
 /** @type {!Validator} */
PropertyPrototype.prototype.regexp;
 /** @type {!Validator} */
PropertyPrototype.prototype.number;
 /** @type {!Validator} */
PropertyPrototype.prototype.digits;
 /** @type {!Validator} */
PropertyPrototype.prototype.letters;
 /** @type {!Validator} */
PropertyPrototype.prototype.equals;
/**
 * @record
 * @struct
 */
function Validator() {}
/**
 * @record
 * @struct
 */
function ViewPrototype() {}
 /** @type {?} */
ViewPrototype.prototype.parentView;
 /** @type {!Function} */
ViewPrototype.prototype.init;
 /** @type {!Function} */
ViewPrototype.prototype.routed;
 /** @type {!Function} */
ViewPrototype.prototype.navigateTo;
 /** @type {!Function} */
ViewPrototype.prototype.ready;
 /** @type {{route: ?, url: string}} */
ViewPrototype.prototype.options;

/* TODO: IndexSignature:  */

/**
 * Routes to a specific URL and actives the appropriate views associated with the URL
 * 
 * @param {string} name Name of the route
 * @return {!ViewPrototype}
 */
ViewPrototype.prototype.route = function(name) {};

/**
 * Determines if the view is visible
 * @return {boolean}
 */
ViewPrototype.prototype.isActive = function() {};
/**
 * @record
 * @struct
 */
function Model() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/**
 * Fires a request to the server to populate the Model based on the read URL specified
 * @param {!Object=} params The parameters Object that will be used to populate the Model from the specified options.read URL. If the URL does not contain parameters
 * @return {!Model}
 */
Model.prototype.read = function(params) {};

/**
 * Synchronizes the changes with the server by sending requests to the provided URL's
 * @return {!Model}
 */
Model.prototype.sync = function() {};
/**
 * @record
 * @struct
 */
function ModelPrototype() {}
 /** @type {!Function} */
ModelPrototype.prototype.init;
 /** @type {{idAttr: string, baseUrl: string, read: {url: string}, create: {url: string}, destroy: {url: string}, update: {url: string}}} */
ModelPrototype.prototype.options;

/* TODO: IndexSignature:  */

/**
 * Validates all observable properties that have validation and returns true if all values are valid otherwise returns false
 * @return {boolean}
 */
ModelPrototype.prototype.validate = function() {};

/**
 * Extracts the raw(non observable) dataItem object values from the Model
 * @return {!Object}
 */
ModelPrototype.prototype.dataItem = function() {};

/**
 * Applies new properties to the Model by providing an Object
 * 
 * @param {!ModelPrototype} dataItem The object from which the new values will be applied
 * @return {!ModelPrototype}
 */
ModelPrototype.prototype.reset = function(dataItem) {};

/**
 * Determines whether the instance is new. If true when syncing the item will send for insertion instead of updating it.
 * The check is determined by the idAttr value specified in the options. If idAttr is not specified the item will always be considered new.
 * 
 * @return {boolean}
 */
ModelPrototype.prototype.isNew = function() {};
/**
 * @extends {Extendable}
 * @record
 * @struct
 */
function Collection() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/**
 * Fires a request to the server to populate the Model based on the read URL specified
 * @param {!Object=} params The parameters Object that will be used to populate the Collection from the specified options.read URL. If the URL does not contain parameters
 * @return {!Collection}
 */
Collection.prototype.read = function(params) {};

/**
 * Clear all changes made to the collection
 * @return {!Collection}
 */
Collection.prototype.clearChanges = function() {};

/**
 * Performs an ajax request for all create, update and delete operations in order to sync them with a database.
 * @return {!Collection}
 */
Collection.prototype.sync = function() {};

/**
 * @param {number} id
 * @param {!Object} newValues
 * @return {!Collection}
 */
Collection.prototype.update = function(id, newValues) {};
/**
 * @record
 * @struct
 */
function CollectionPrototype() {}
 /** @type {{read: {url: string}, create: {url: string}, destroy: {url: string}, update: {url: string}}} */
CollectionPrototype.prototype.options;

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function Extendable() {}

/**
 * Extends the current observable with particular functionality depending on the parameters specified.
 * If the method is called without arguments and jsvalue framework is included the observable will be
 * extended with the methods available in jsvalue for the current type.
 * 
 * @param {string|?=} name_or_arg Name of the extender
 * @param {...?} options Optional options
 * @return {T}
 */
Extendable.prototype.extend = function(name_or_arg, options) {};
/**
 * @record
 * @struct
 */
function Server() {}
 /** @type {number} */
Server.prototype.port;
 /** @type {string} */
Server.prototype.static;
 /** @type {boolean} */
Server.prototype.cache;
 /** @type {?} */
Server.prototype.use;
 /** @type {!BlocksStatic} */
var blocks;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "blocks"
/** @const */
tsickle_declare_module.blocks = {};

/* TODO: ExportAssignment in tsickle_declare_module.blocks */
