/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/promise-pool/index.d.ts:

/* TODO: ImportDeclaration in  */
/**
 * @record
 * @struct
 */
function IResult() {}
 /** @type {number} */
IResult.prototype.fulfilled;
 /** @type {number} */
IResult.prototype.rejected;
 /** @type {number} */
IResult.prototype.total;
/**
 * @record
 * @struct
 */
function IProgress() {}
 /** @type {number} */
IProgress.prototype.index;
 /** @type {boolean} */
IProgress.prototype.success;
 /** @type {?} */
IProgress.prototype.error;
 /** @type {number} */
IProgress.prototype.retries;
 /** @type {number} */
IProgress.prototype.fulfilled;
 /** @type {number} */
IProgress.prototype.rejected;
 /** @type {number} */
IProgress.prototype.pending;
 /** @type {number} */
IProgress.prototype.total;

/**
 * @constructor
 * @struct
 * initialize a task pool.
 * @param {function(T, number): !Q.IPromise<void>} processor a function takes the data and index as parameters and returns a promise.
 * @param {number} concurrency the concurrency of this task pool.
 * @param {boolean=} endless defaults to false. indicates whether this task pool is endless, if so, tasks can still be added even after all previous tasks have been fulfilled.
 * @param {!Array<T>=} tasksData an initializing array of task data.
 */
function Pool(processor, concurrency, endless, tasksData) {}
 /** @type {number} */
Pool.prototype.concurrency;
 /** @type {?} */
Pool.prototype._tasksData;
 /** @type {function(T, number): !Q.IPromise<void>} */
Pool.prototype.processor;
 /** @type {?} */
Pool.prototype._deferred;
 /** @type {?} */
Pool.prototype._pauseDeferred;
 /** @type {number} */
Pool.prototype.fulfilled;
 /** @type {number} */
Pool.prototype.rejected;
 /** @type {number} */
Pool.prototype.pending;
 /** @type {number} */
Pool.prototype.total;
 /** @type {boolean} */
Pool.prototype.endless;
 /** @type {number} */
Pool.prototype.retries;
 /** @type {number} */
Pool.prototype.retryInterval;
 /** @type {number} */
Pool.prototype.maxRetryInterval;
 /** @type {number} */
Pool.prototype.retryIntervalMultiplier;
 /** @type {?} */
Pool.prototype._index;
 /** @type {?} */
Pool.prototype._currentConcurrency;
 /** @type {function(?): void} */
Pool.prototype.onProgress;

/**
 * add a data item.
 * add data items.
 * @param {T|!Array<T>} taskData_or_tasksData task data to add.
 * @return {void}
 */
Pool.prototype.add = function(taskData_or_tasksData) {};

/**
 * start tasks, return a promise that will be fulfilled after all tasks accomplish if endless is false.
 * @param {function(?): void=} onProgress a callback that will be triggered every time when a single task is fulfilled.
 * @return {?<?>}
 */
Pool.prototype.start = function(onProgress) {};

/**
 * @return {?}
 */
Pool.prototype._start = function() {};

/**
 * @param {?} data
 * @param {?} index
 * @return {?}
 */
Pool.prototype._process = function(data, index) {};

/**
 * @param {?} index
 * @param {?} success
 * @param {?} err
 * @param {?} retries
 * @return {?}
 */
Pool.prototype._notifyProgress = function(index, success, err, retries) {};

/**
 * @return {?}
 */
Pool.prototype._next = function() {};

/**
 * pause tasks and return a promise that will be fulfilled after the running tasks accomplish. this will wait for running tasks to complete instead of aborting them.
 * @return {?<void>}
 */
Pool.prototype.pause = function() {};

/**
 * resume tasks.
 * @return {void}
 */
Pool.prototype.resume = function() {};

/**
 * pause tasks, then clear pending tasks data and reset counters. return a promise that will be fulfilled after resetting accomplish.
 * @return {?<void>}
 */
Pool.prototype.reset = function() {};
