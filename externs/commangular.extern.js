/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/commangular/index.d.ts:
 /** @type {!commangular.ICommAngularStatic} */
var commangular;
/**
 * @record
 * @struct
 */
commangular.ICommAngularStatic = function() {};

/**
 * Use this function to create and register a command with Commangular
 * 
 * @param {string} commandName It's the name of the command you are creating. It's useful to reference the command from the command provider.
 * @param {!Function} commandFunction It's the command class that will be executed when commangular runs this command.
 * 				It has to be something that implements ICommand. Same as angular syntax
 * @param {!commangular.ICommandConfig=} commandConfig It's and object with paramaters to configure the command execution.
 * @return {void}
 */
commangular.ICommAngularStatic.prototype.create = function(commandName, commandFunction, commandConfig) {};

/**
 * @param {string} commandName
 * @param {!Function} commandFunction
 * @param {!commangular.ICommandConfig=} commandConfig
 * @return {void}
 */
commangular.ICommAngularStatic.prototype.command = function(commandName, commandFunction, commandConfig) {};

/**
 * This function allows you to hijack the execution before or after and
 * execute some cross cutting functionality.
 * see http://commangular.org/docs/#command-aspects
 * @param {string} aspectDescriptor The interceptor descriptor has two parts 'Where' and 'What'.
 * 		Where do you want to intercept? you've 5 options :
 * 		- \@Before : The interceptor will be executed before the command. You will be able to
 * 				cancel the command or modify the data that will be injected in the command or do
 * 				some other operation you need before the command execution.
 * 		- \@After : The interceptor will be executed just after the command and before any other next
 * 				command. You can get the lastResult from the command, cancel execution etc etc.
 * 		- \@AfterExecution : This intercetor is executed just after the command execute method and
 * 				it can get the result from the command and update it before the onResult method is executed.
 * 		- \@AfterThrowing : This interceptor will be executed if the command or any interceptor of
 * 				the command throws an exception. You can get the error throwed injected to do what you need.
 * 		- \@Around : The interceptor is executed around a command.That means that a especial
 * 				object 'processor' will be injected in the interceptor and you can invoke the command
 * 				or the next interceptor. It will be better explained below.
 * @param {!commangular.ICommand} aspectFunction It's the command class execute function that will be run for the given aspect.
 * @param {number} order You can chain any number of interceptors to the same command, so if you need to executed
 * 		the interceptor in a specific order you can indicate it here. An order of 0 is assigned by default.
 * @return {void}
 */
commangular.ICommAngularStatic.prototype.aspect = function(aspectDescriptor, aspectFunction, order) {};

/**
 * Event aspects work the same way command aspects do, but they intercept all the command groups instead,
 * so you can run some function before the command group starts it's execution , after or when any
 * command or interceptor in the group throw an exception.
 * see http://commangular.org/docs/#event-aspects
 * @param {string} aspectDescriptor The interceptor descriptor has two parts 'Where' and 'What'.
 * 		Where do you want to intercept? you've 3 options :
 * 		- \@Before : The interceptor will be executed before the command. You will be able to
 * 				cancel the command or modify the data that will be injected in the command or do
 * 				some other operation you need before the command execution.
 * 		- \@After : The interceptor will be executed just after the command and before any other next
 * 				command. You can get the lastResult from the command, cancel execution etc etc.
 * 		- \@AfterThrowing : This interceptor will be executed if the command or any interceptor of
 * 				the command throws an exception. You can get the error throwed injected to do what you need.
 * @param {!commangular.ICommand} aspectFunction It's the command class execute function that will be run for the given aspect.
 * @param {number} order You can chain any number of interceptors to the same command, so if you need to executed
 * 		the interceptor in a specific order you can indicate it here. An order of 0 is assigned by default.
 * @return {void}
 */
commangular.ICommAngularStatic.prototype.eventAspect = function(aspectDescriptor, aspectFunction, order) {};

/**
 * TBD
 * @param {string} commandName
 * @param {!Function} resolverFunction
 * @return {void}
 */
commangular.ICommAngularStatic.prototype.resolver = function(commandName, resolverFunction) {};

/**
 * Clears all commands and aspects registered with commangular.
 * @return {void}
 */
commangular.ICommAngularStatic.prototype.reset = function() {};

/**
 * Can be used to enable/disable debug
 * @param {boolean} enableDebug
 * @return {void}
 */
commangular.ICommAngularStatic.prototype.debug = function(enableDebug) {};

/**
 * TBD
 * @return {void}
 */
commangular.ICommAngularStatic.prototype.build = function() {};
/**
 * @record
 * @struct
 */
commangular.ICommand = function() {};

/**
 * This function is what gets called when the command executes.
 * It can take parameters in as injected by angular
 * @return {?}
 */
commangular.ICommand.prototype.execute = function() {};
/**
 * @extends {commangular.ICommand}
 * @record
 * @struct
 */
commangular.IResultCommand = function() {};

/**
 * Is executed after the execute method and the interception chain and can receive
 * the result from the execute method of the same command.
 * 
 * @param {?} result Value/object returned by the execution.
 * @return {void}
 */
commangular.IResultCommand.prototype.onResult = function(result) {};

/**
 * Is executed when the executed method ends with an error. Can receive the error throw by the execute method.
 * @param {!Error} error The error that occured during execution
 * @return {void}
 */
commangular.IResultCommand.prototype.onError = function(error) {};
/**
 * @record
 * @struct
 */
commangular.ICommandResult = function() {};
 /** @type {?} */
commangular.ICommandResult.prototype.lastResult;
/**
 * @record
 * @struct
 */
commangular.ICommandConfig = function() {};
 /** @type {string} */
commangular.ICommandConfig.prototype.resultKey;
/**
 * @record
 * @struct
 */
commangular.ICommAngularProvider = function() {};

/**
 * This function lets you map a even name to a command sequence
 * @param {string} eventName An event that will be watched by commangular
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularProvider.prototype.mapTo = function(eventName) {};

/**
 * Used along with mapTo function. Creates a sequence of commands that
 * execute after one and other
 * see http://commangular.org/docs/#building-command-sequences
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularProvider.prototype.asSequence = function() {};

/**
 * Used along with mapTo function. Maps commands to be executed parallel
 * see http://commangular.org/docs/#building-parallel-commands
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularProvider.prototype.asParallel = function() {};

/**
 * A command flow is a decision point inside the command group.You can have any number
 * of flows inside a command group and nesting them how you perfer.
 * see http://commangular.org/docs/#building-command-flows
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularProvider.prototype.asFlow = function() {};

/**
 * @param {string} eventName
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularProvider.prototype.findCommand = function(eventName) {};
/**
 * @record
 * @struct
 */
commangular.ICommAngularService = function() {};

/**
 * This function executes the given command sequence.
 * see http://commangular.org/docs/#dispatching-events
 * @param {string} eventName Name of the even that will trigger a command sequence
 * @param {?=} data Data of any type that will be passed to the command.
 * @return {!angular.IPromise<?>}
 */
commangular.ICommAngularService.prototype.dispatch = function(eventName, data) {};
/**
 * @record
 * @struct
 */
commangular.ICommAngularDescriptor = function() {};

/**
 * Used along with mapTo function. Creates a sequence of commands that
 * execute after one and other
 * see http://commangular.org/docs/#building-command-sequences
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularDescriptor.prototype.asSequence = function() {};

/**
 * Used along with mapTo function. Maps commands to be executed parallel
 * see http://commangular.org/docs/#building-parallel-commands
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularDescriptor.prototype.asParallel = function() {};

/**
 * A command flow is a decision point inside the command group.You can have any number
 * of flows inside a command group and nesting them how you perfer.
 * see http://commangular.org/docs/#building-command-flows
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularDescriptor.prototype.asFlow = function() {};

/**
 * Add commands to a descriptor.
 * Add descriptor to a descriptor.
 * @param {string|!commangular.ICommAngularDescriptor} command_or_descriptor The name that was used to create the command. / Another descriptor attached to a sequnce of commands.
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularDescriptor.prototype.add = function(command_or_descriptor) {};

/**
 * This is to be used with flowing commands to attach an expression that
 * evaluates using Angular $parse.
 * see http://commangular.org/docs/#building-command-flows
 * @param {string} expression A string form expression that can make use of services to validate conditions.
 * @param {string=} services A comma seperated list of services that are used in the above expression
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularDescriptor.prototype.link = function(expression, services) {};

/**
 * Works with the <code>link</code> function to attach a command to the flow if the
 * expression becomes truthy.
 * see http://commangular.org/docs/#building-command-flows
 * @param {string} command The name that was used to create the command.
 * @return {!commangular.ICommAngularDescriptor}
 */
commangular.ICommAngularDescriptor.prototype.to = function(command) {};
/**
 * @record
 * @struct
 */
angular.IRootScopeService = function() {};

/**
 * Commangular method to execute a command.
 * @param {string} eventName Name of the even that will trigger a command sequence
 * @param {?=} data Data of any type that will be passed to the command.
 * @return {!angular.IPromise<?>}
 */
angular.IRootScopeService.prototype.dispatch = function(eventName, data) {};
