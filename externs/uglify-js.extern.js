/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/uglify-js/index.d.ts:

/* TODO: ImportDeclaration in  */
/** @const */
var UglifyJS = {};
/**
 * @record
 * @struct
 */
UglifyJS.Tokenizer = function() {};
 /** @type {string} */
UglifyJS.Tokenizer.prototype.type;
 /** @type {string} */
UglifyJS.Tokenizer.prototype.file;
 /** @type {string} */
UglifyJS.Tokenizer.prototype.value;
 /** @type {number} */
UglifyJS.Tokenizer.prototype.line;
 /** @type {number} */
UglifyJS.Tokenizer.prototype.col;
 /** @type {boolean} */
UglifyJS.Tokenizer.prototype.nlb;
 /** @type {!Array<string>} */
UglifyJS.Tokenizer.prototype.comments_before;
/**
 * @record
 * @struct
 */
UglifyJS.AST_Node = function() {};
 /** @type {!UglifyJS.AST_Node} */
UglifyJS.AST_Node.prototype.start;
 /** @type {!UglifyJS.AST_Node} */
UglifyJS.AST_Node.prototype.end;

/**
 * @param {?} tt
 * @return {!UglifyJS.AST_Toplevel}
 */
UglifyJS.AST_Node.prototype.transform = function(tt) {};
/**
 * @extends {UglifyJS.AST_Node}
 * @record
 * @struct
 */
UglifyJS.AST_Toplevel = function() {};

/**
 * @return {void}
 */
UglifyJS.AST_Toplevel.prototype.figure_out_scope = function() {};

/**
 * @return {void}
 */
UglifyJS.AST_Toplevel.prototype.compute_char_frequency = function() {};

/**
 * @return {void}
 */
UglifyJS.AST_Toplevel.prototype.mangle_names = function() {};

/**
 * @param {?} stream
 * @return {void}
 */
UglifyJS.AST_Toplevel.prototype.print = function(stream) {};

/**
 * @param {!UglifyJS.BeautifierOptions=} options
 * @return {string}
 */
UglifyJS.AST_Toplevel.prototype.print_to_string = function(options) {};
/**
 * @record
 * @struct
 */
UglifyJS.MinifyOptions = function() {};
 /** @type {boolean} */
UglifyJS.MinifyOptions.prototype.spidermonkey;
 /** @type {string} */
UglifyJS.MinifyOptions.prototype.outSourceMap;
 /** @type {string} */
UglifyJS.MinifyOptions.prototype.sourceRoot;
 /** @type {string} */
UglifyJS.MinifyOptions.prototype.inSourceMap;
 /** @type {boolean} */
UglifyJS.MinifyOptions.prototype.fromString;
 /** @type {boolean} */
UglifyJS.MinifyOptions.prototype.warnings;
 /** @type {!Object} */
UglifyJS.MinifyOptions.prototype.mangle;
 /** @type {!UglifyJS.MinifyOutput} */
UglifyJS.MinifyOptions.prototype.output;
 /** @type {!Object} */
UglifyJS.MinifyOptions.prototype.compress;
/**
 * @record
 * @struct
 */
UglifyJS.MinifyOutput = function() {};
 /** @type {string} */
UglifyJS.MinifyOutput.prototype.code;
 /** @type {string} */
UglifyJS.MinifyOutput.prototype.map;

/**
 * @param {(string|!Array<string>)} files
 * @param {!UglifyJS.MinifyOptions=} options
 * @return {!UglifyJS.MinifyOutput}
 */
UglifyJS.minify = function(files, options) {};
/**
 * @record
 * @struct
 */
UglifyJS.ParseOptions = function() {};
 /** @type {boolean} */
UglifyJS.ParseOptions.prototype.strict;
 /** @type {string} */
UglifyJS.ParseOptions.prototype.filename;
 /** @type {!UglifyJS.AST_Toplevel} */
UglifyJS.ParseOptions.prototype.toplevel;

/**
 * The parser creates a custom abstract syntax tree given a piece of JavaScript code.
 * Perhaps you should read about the AST first.
 * @param {string} code
 * @param {!UglifyJS.ParseOptions=} options
 * @return {!UglifyJS.AST_Toplevel}
 */
UglifyJS.parse = function(code, options) {};
/**
 * @record
 * @struct
 */
UglifyJS.BeautifierOptions = function() {};
 /** @type {number} */
UglifyJS.BeautifierOptions.prototype.indent_start;
 /** @type {number} */
UglifyJS.BeautifierOptions.prototype.indent_level;
 /** @type {boolean} */
UglifyJS.BeautifierOptions.prototype.quote_keys;
 /** @type {boolean} */
UglifyJS.BeautifierOptions.prototype.space_colon;
 /** @type {boolean} */
UglifyJS.BeautifierOptions.prototype.ascii_only;
 /** @type {boolean} */
UglifyJS.BeautifierOptions.prototype.inline_script;
 /** @type {number} */
UglifyJS.BeautifierOptions.prototype.width;
 /** @type {number} */
UglifyJS.BeautifierOptions.prototype.max_line_len;
 /** @type {boolean} */
UglifyJS.BeautifierOptions.prototype.ie_proof;
 /** @type {boolean} */
UglifyJS.BeautifierOptions.prototype.beautify;
 /** @type {?} */
UglifyJS.BeautifierOptions.prototype.source_map;
 /** @type {boolean} */
UglifyJS.BeautifierOptions.prototype.bracketize;
 /** @type {boolean} */
UglifyJS.BeautifierOptions.prototype.comments;
 /** @type {boolean} */
UglifyJS.BeautifierOptions.prototype.semicolons;
/**
 * @record
 * @struct
 */
UglifyJS.OutputStream = function() {};

/**
 * @return {string}
 */
UglifyJS.OutputStream.prototype.get = function() {};

/**
 * @return {string}
 */
UglifyJS.OutputStream.prototype.toString = function() {};

/**
 * @param {boolean=} half
 * @return {void}
 */
UglifyJS.OutputStream.prototype.indent = function(half) {};

/**
 * @return {number}
 */
UglifyJS.OutputStream.prototype.indentation = function() {};

/**
 * @return {number}
 */
UglifyJS.OutputStream.prototype.current_width = function() {};

/**
 * @return {boolean}
 */
UglifyJS.OutputStream.prototype.should_break = function() {};

/**
 * @return {void}
 */
UglifyJS.OutputStream.prototype.newline = function() {};

/**
 * @param {string} str
 * @return {void}
 */
UglifyJS.OutputStream.prototype.print = function(str) {};

/**
 * @return {void}
 */
UglifyJS.OutputStream.prototype.space = function() {};

/**
 * @return {void}
 */
UglifyJS.OutputStream.prototype.comma = function() {};

/**
 * @return {void}
 */
UglifyJS.OutputStream.prototype.colon = function() {};

/**
 * @return {string}
 */
UglifyJS.OutputStream.prototype.last = function() {};

/**
 * @return {void}
 */
UglifyJS.OutputStream.prototype.semicolon = function() {};

/**
 * @return {void}
 */
UglifyJS.OutputStream.prototype.force_semicolon = function() {};

/**
 * @param {string} str
 * @return {void}
 */
UglifyJS.OutputStream.prototype.to_ascii = function(str) {};

/**
 * @param {string} name
 * @return {void}
 */
UglifyJS.OutputStream.prototype.print_name = function(name) {};

/**
 * @param {string} str
 * @return {void}
 */
UglifyJS.OutputStream.prototype.print_string = function(str) {};

/**
 * @return {number}
 */
UglifyJS.OutputStream.prototype.next_indent = function() {};

/**
 * @param {number} col
 * @param {!Function} func
 * @return {void}
 */
UglifyJS.OutputStream.prototype.with_indent = function(col, func) {};

/**
 * @param {!Function} func
 * @return {void}
 */
UglifyJS.OutputStream.prototype.with_block = function(func) {};

/**
 * @param {!Function} func
 * @return {void}
 */
UglifyJS.OutputStream.prototype.with_parens = function(func) {};

/**
 * @param {!Function} func
 * @return {void}
 */
UglifyJS.OutputStream.prototype.with_square = function(func) {};

/**
 * @param {!UglifyJS.AST_Node} token
 * @param {string=} name
 * @return {void}
 */
UglifyJS.OutputStream.prototype.add_mapping = function(token, name) {};

/**
 * @param {string} name
 * @return {?}
 */
UglifyJS.OutputStream.prototype.option = function(name) {};

/**
 * @return {number}
 */
UglifyJS.OutputStream.prototype.line = function() {};

/**
 * @return {number}
 */
UglifyJS.OutputStream.prototype.col = function() {};

/**
 * @param {!UglifyJS.AST_Node} node
 * @return {void}
 */
UglifyJS.OutputStream.prototype.push_node = function(node) {};

/**
 * @return {!UglifyJS.AST_Node}
 */
UglifyJS.OutputStream.prototype.pop_node = function() {};

/**
 * @return {?}
 */
UglifyJS.OutputStream.prototype.stack = function() {};

/**
 * @param {number} n
 * @return {!UglifyJS.AST_Node}
 */
UglifyJS.OutputStream.prototype.parent = function(n) {};

/**
 * The code generator is a recursive process of getting back source code from an AST returned by the parser.
 * Every AST node has a “print” method that takes an OutputStream and dumps the code from that node into it.
 * The stream object supports a lot of options that control the output.
 * You can specify whether you'd like to get human-readable (indented) output, the indentation level, whether you'd like to quote all properties in object literals etc.
 * @param {!UglifyJS.BeautifierOptions=} options
 * @return {?}
 */
UglifyJS.OutputStream = function(options) {};
/**
 * @record
 * @struct
 */
UglifyJS.SourceMapOptions = function() {};
 /** @type {string} */
UglifyJS.SourceMapOptions.prototype.file;
 /** @type {string} */
UglifyJS.SourceMapOptions.prototype.root;
 /** @type {(!Object|!JSON)} */
UglifyJS.SourceMapOptions.prototype.orig;
/**
 * @record
 * @struct
 */
UglifyJS.SourceMap = function() {};

/**
 * @param {string} source
 * @param {number} gen_line
 * @param {number} gen_col
 * @param {number} orig_line
 * @param {number} orig_col
 * @param {string=} name
 * @return {void}
 */
UglifyJS.SourceMap.prototype.add = function(source, gen_line, gen_col, orig_line, orig_col, name) {};

/**
 * @return {?}
 */
UglifyJS.SourceMap.prototype.get = function() {};

/**
 * @return {string}
 */
UglifyJS.SourceMap.prototype.toString = function() {};

/**
 * The output stream keeps track of the current line/column in the output and can trivially generate a source mapping to the original code via Mozilla's source-map library.
 * To use this functionality, you must load this library (it's automatically require-d by UglifyJS in the NodeJS version, but in a browser you must load it yourself)
 * and make it available via the global MOZ_SourceMap variable.
 * @param {!UglifyJS.SourceMapOptions=} options
 * @return {?}
 */
UglifyJS.SourceMap = function(options) {};
/**
 * @record
 * @struct
 */
UglifyJS.CompressorOptions = function() {};
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.sequences;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.properties;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.dead_code;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.drop_debugger;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.unsafe;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.conditionals;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.comparisons;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.evaluate;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.booleans;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.loops;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.unused;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.hoist_funs;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.hoist_vars;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.if_return;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.join_vars;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.cascade;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.side_effects;
 /** @type {boolean} */
UglifyJS.CompressorOptions.prototype.warnings;
 /** @type {!Object} */
UglifyJS.CompressorOptions.prototype.global_defs;

/**
 * The compressor is a tree transformer which reduces the code size by applying various optimizations on the AST
 * @param {!UglifyJS.CompressorOptions=} options
 * @return {!UglifyJS.AST_Toplevel}
 */
UglifyJS.Compressor = function(options) {};
/**
 * @record
 * @struct
 */
UglifyJS.TreeWalker = function() {};

/** @typedef {function(!UglifyJS.AST_Node, !Function): boolean} */
UglifyJS.visitor;

/**
 * UglifyJS provides a TreeWalker object and every node has a walk method that given a walker will apply your visitor to each node in the tree.
 * Your visitor can return a non-falsy value in order to prevent descending the current node.
 * @param {function(!UglifyJS.AST_Node, !Function): boolean} visitor
 * @return {?}
 */
UglifyJS.TreeWalker = function(visitor) {};
/**
 * @record
 * @struct
 */
UglifyJS.TreeTransformer = function() {};

/**
 * The tree transformer is a special case of a tree walker.
 * In fact it even inherits from TreeWalker and you can use the same methods, but initialization and visitor protocol are a bit different.
 * @param {function(!UglifyJS.AST_Node, !Function): boolean} before
 * @param {function(!UglifyJS.AST_Node, !Function): boolean} after
 * @return {?}
 */
UglifyJS.TreeTransformer = function(before, after) {};

/* TODO: ExportAssignment in  */
