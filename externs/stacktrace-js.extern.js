/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/stacktrace-js/index.d.ts:
/** @const */
var StackTrace = {};
/**
 * @record
 * @struct
 */
StackTrace.SourceCache = function() {};

/* TODO: IndexSignature: StackTrace */
/**
 * @record
 * @struct
 */
StackTrace.StackTraceOptions = function() {};
 /** @type {function(!StackTrace.StackFrame): boolean} */
StackTrace.StackTraceOptions.prototype.filter;
 /** @type {!StackTrace.SourceCache} */
StackTrace.StackTraceOptions.prototype.sourceCache;
 /** @type {boolean} */
StackTrace.StackTraceOptions.prototype.offline;
/**
 * @record
 * @struct
 */
StackTrace.StackFrame = function() {};
 /** @type {string} */
StackTrace.StackFrame.prototype.functionName;
 /** @type {?} */
StackTrace.StackFrame.prototype.args;
 /** @type {string} */
StackTrace.StackFrame.prototype.fileName;
 /** @type {number} */
StackTrace.StackFrame.prototype.lineNumber;
 /** @type {number} */
StackTrace.StackFrame.prototype.columnNumber;
 /** @type {string} */
StackTrace.StackFrame.prototype.source;
 /** @type {boolean} */
StackTrace.StackFrame.prototype.isEval;
 /** @type {boolean} */
StackTrace.StackFrame.prototype.isNative;

/**
 * @param {string} functionName
 * @param {?} args
 * @param {string} fileName
 * @param {number} lineNumber
 * @param {number} columnNumber
 * @return {!StackTrace.StackFrame}
 */
StackTrace.StackFrame.prototype.constructor = function(functionName, args, fileName, lineNumber, columnNumber) {};

/**
 * @return {string}
 */
StackTrace.StackFrame.prototype.toString = function() {};
/**
 * @record
 * @struct
 */
StackTrace.RequestOptions = function() {};
 /** @type {!Object<string,string>} */
StackTrace.RequestOptions.prototype.headers;

/**
 * Get a backtrace from invocation point.
 * @param {!StackTrace.StackTraceOptions=} options Options Object
 * @return {!Promise<!Array<!StackTrace.StackFrame>>} Array[StackFrame]
 */
StackTrace.get = function(options) {};

/**
 * Get a backtrace from invocation point synchronously.
 * @param {!StackTrace.StackTraceOptions=} options Options Object
 * @return {!Array<!StackTrace.StackFrame>} Array[StackFrame]
 */
StackTrace.getSync = function(options) {};

/**
 * Given an error object, parse it.
 * @param {!Error} error Error object
 * @param {!StackTrace.StackTraceOptions=} options Object for options
 * @return {!Promise<!Array<!StackTrace.StackFrame>>} Array[StackFrame]
 */
StackTrace.fromError = function(error, options) {};

/**
 * Use StackGenerator to generate a backtrace.
 * @param {!StackTrace.StackTraceOptions=} options Object options
 * @return {!Promise<!Array<!StackTrace.StackFrame>>} Array[StackFrame]
 */
StackTrace.generateArtificially = function(options) {};

/**
 * Given a function, wrap it such that invocations trigger a callback that
 * is called with a stack trace.
 * 
 * @template TFunc
 * @param {TFunc} fn
 * @param {function(!Array<!StackTrace.StackFrame>): void} callback
 * @param {function(!Error): void=} errback
 * @param {?=} thisArg
 * @return {TFunc}
 */
StackTrace.instrument = function(fn, callback, errback, thisArg) {};

/**
 * Given a function that has been instrumented,
 * revert the function to it's original (non-instrumented) state.
 * 
 * @template TFunc
 * @param {TFunc} fn {Function}
 * @return {TFunc}
 */
StackTrace.deinstrument = function(fn) {};

/**
 * Given an Array of StackFrames, serialize and POST to given URL.
 * 
 * @param {!Array<!StackTrace.StackFrame>} stackframes
 * @param {string} url
 * @param {string=} message
 * @param {!StackTrace.RequestOptions=} requestOptions
 * @return {!Promise<string>}
 */
StackTrace.report = function(stackframes, url, message, requestOptions) {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "stacktrace-js"
/** @const */
tsickle_declare_module.stacktrace_js = {};

/* TODO: ExportAssignment in tsickle_declare_module.stacktrace_js */
