/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/enzyme/index.d.ts:

/* TODO: ImportDeclaration in  */

/** @typedef {?} */
var HTMLAttributes;
/**
 * @constructor
 * @struct
 */
function ElementClass() {}
/**
 * @record
 * @struct
 */
function ComponentClass() {}

/* TODO: ConstructSignature:  */

/** @typedef {?} */
var StatelessComponent;
/**
 * @record
 * @struct
 */
function EnzymePropSelector() {}

/* TODO: IndexSignature:  */

/** @typedef {(string|?)} */
var EnzymeSelector;

/** @typedef {?} */
var Intercepter;
/**
 * @record
 * @struct
 */
function CommonWrapper() {}
 /** @type {number} */
CommonWrapper.prototype.length;

/**
 * Returns a new wrapper with only the nodes of the current wrapper that, when passed into the provided predicate function, return true.
 * @param {?} predicate
 * @return {?}
 */
CommonWrapper.prototype.filterWhere = function(predicate) {};

/**
 * Returns whether or not the current wrapper has a node anywhere in it's render tree that looks like the one passed in.
 * @param {!React.ReactElement<?>} node
 * @return {boolean}
 */
CommonWrapper.prototype.contains = function(node) {};

/**
 * Returns whether or not a given react element exists in the shallow render tree.
 * @param {!React.ReactElement<?>} node
 * @return {boolean}
 */
CommonWrapper.prototype.containsMatchingElement = function(node) {};

/**
 * Returns whether or not all the given react elements exists in the shallow render tree
 * @param {!Array<!React.ReactElement<?>>} nodes
 * @return {boolean}
 */
CommonWrapper.prototype.containsAllMatchingElements = function(nodes) {};

/**
 * Returns whether or not one of the given react elements exists in the shallow render tree.
 * @param {!Array<!React.ReactElement<?>>} nodes
 * @return {boolean}
 */
CommonWrapper.prototype.containsAnyMatchingElements = function(nodes) {};

/**
 * Returns whether or not the current render tree is equal to the given node, based on the expected value.
 * @param {!React.ReactElement<?>} node
 * @return {boolean}
 */
CommonWrapper.prototype.equals = function(node) {};

/**
 * Returns whether or not a given react element matches the shallow render tree.
 * @param {!React.ReactElement<?>} node
 * @return {boolean}
 */
CommonWrapper.prototype.matchesElement = function(node) {};

/**
 * Returns whether or not the current node has a className prop including the passed in class name.
 * @param {string} className
 * @return {boolean}
 */
CommonWrapper.prototype.hasClass = function(className) {};

/**
 * Returns whether or not the current node matches a provided selector.
 * @param {(string|?)} selector
 * @return {boolean}
 */
CommonWrapper.prototype.is = function(selector) {};

/**
 * Returns whether or not the current node is empty.
 * @deprecated Use .exists() instead.
 * @return {boolean}
 */
CommonWrapper.prototype.isEmpty = function() {};

/**
 * Returns whether or not the current node exists.
 * @return {boolean}
 */
CommonWrapper.prototype.exists = function() {};

/**
 * Returns a new wrapper with only the nodes of the current wrapper that don't match the provided selector.
 * This method is effectively the negation or inverse of filter.
 * @param {(string|?)} selector
 * @return {?}
 */
CommonWrapper.prototype.not = function(selector) {};

/**
 * Returns a string of the rendered text of the current render tree. This function should be looked at with
 * skepticism if being used to test what the actual HTML output of the component will be. If that is what you
 * would like to test, use enzyme's render function instead.
 * 
 * Note: can only be called on a wrapper of a single node.
 * @return {string}
 */
CommonWrapper.prototype.text = function() {};

/**
 * Returns a string of the rendered HTML markup of the current render tree.
 * 
 * Note: can only be called on a wrapper of a single node.
 * @return {string}
 */
CommonWrapper.prototype.html = function() {};

/**
 * Returns the node at a given index of the current wrapper.
 * @param {number} index
 * @return {!React.ReactElement<?>}
 */
CommonWrapper.prototype.get = function(index) {};

/**
 * Returns the wrapper's underlying node.
 * @return {!React.ReactElement<?>}
 */
CommonWrapper.prototype.getNode = function() {};

/**
 * Returns the wrapper's underlying nodes.
 * @return {!Array<!React.ReactElement<?>>}
 */
CommonWrapper.prototype.getNodes = function() {};

/**
 * Returns the outer most DOMComponent of the current wrapper.
 * @return {!Element}
 */
CommonWrapper.prototype.getDOMNode = function() {};

/**
 * Returns a wrapper around the node at a given index of the current wrapper.
 * @param {number} index
 * @return {?}
 */
CommonWrapper.prototype.at = function(index) {};

/**
 * Reduce the set of matched nodes to the first in the set.
 * @return {?}
 */
CommonWrapper.prototype.first = function() {};

/**
 * Reduce the set of matched nodes to the last in the set.
 * @return {?}
 */
CommonWrapper.prototype.last = function() {};

/**
 * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the rules of `Array#slice`.
 * @param {number=} begin
 * @param {number=} end
 * @return {?}
 */
CommonWrapper.prototype.slice = function(begin, end) {};

/**
 * Taps into the wrapper method chain. Helpful for debugging.
 * @param {?} intercepter
 * @return {?}
 */
CommonWrapper.prototype.tap = function(intercepter) {};

/**
 * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it will return just that value.
 * @template K, T
 * @param {?|string=} key
 * @return {?}
 */
CommonWrapper.prototype.state = function(key) {};

/**
 * Returns the context hash for the root node of the wrapper. Optionally pass in a prop name and it will return just that value.
 * @template T
 * @param {string=} key
 * @return {?}
 */
CommonWrapper.prototype.context = function(key) {};

/**
 * Returns the props hash for the current node of the wrapper.
 * 
 * NOTE: can only be called on a wrapper of a single node.
 * @return {?}
 */
CommonWrapper.prototype.props = function() {};

/**
 * Returns the prop value for the node of the current wrapper with the provided key.
 * 
 * NOTE: can only be called on a wrapper of a single node.
 * @template K, T
 * @param {?|string} key
 * @return {?}
 */
CommonWrapper.prototype.prop = function(key) {};

/**
 * Returns the key value for the node of the current wrapper.
 * NOTE: can only be called on a wrapper of a single node.
 * @return {string}
 */
CommonWrapper.prototype.key = function() {};

/**
 * Simulate events.
 * Returns itself.
 * @param {string} event
 * @param {...?} args
 * @return {?}
 */
CommonWrapper.prototype.simulate = function(event, args) {};

/**
 * A method to invoke setState() on the root component instance similar to how you might in the definition of
 * the component, and re-renders. This method is useful for testing your component in hard to achieve states,
 * however should be used sparingly. If possible, you should utilize your component's external API in order to
 * get it into whatever state you want to test, in order to be as accurate of a test as possible. This is not
 * always practical, however.
 * Returns itself.
 * 
 * NOTE: can only be called on a wrapper instance that is also the root instance.
 * @template K
 * @param {?} state
 * @param {?=} callback
 * @return {?}
 */
CommonWrapper.prototype.setState = function(state, callback) {};

/**
 * A method that sets the props of the root component, and re-renders. Useful for when you are wanting to test
 * how the component behaves over time with changing props. Calling this, for instance, will call the
 * componentWillReceiveProps lifecycle method.
 * 
 * Similar to setState, this method accepts a props object and will merge it in with the already existing props.
 * Returns itself.
 * 
 * NOTE: can only be called on a wrapper instance that is also the root instance.
 * @template K
 * @param {?} props
 * @return {?}
 */
CommonWrapper.prototype.setProps = function(props) {};

/**
 * A method that sets the context of the root component, and re-renders. Useful for when you are wanting to
 * test how the component behaves over time with changing contexts.
 * Returns itself.
 * 
 * NOTE: can only be called on a wrapper instance that is also the root instance.
 * @param {?} context
 * @return {?}
 */
CommonWrapper.prototype.setContext = function(context) {};

/**
 * Gets the instance of the component being rendered as the root node passed into shallow().
 * 
 * NOTE: can only be called on a wrapper instance that is also the root instance.
 * @return {!React.Component<?, ?>}
 */
CommonWrapper.prototype.instance = function() {};

/**
 * Forces a re-render. Useful to run before checking the render output if something external may be updating
 * the state of the component somewhere.
 * Returns itself.
 * 
 * NOTE: can only be called on a wrapper instance that is also the root instance.
 * @return {?}
 */
CommonWrapper.prototype.update = function() {};

/**
 * Returns an html-like string of the wrapper for debugging purposes. Useful to print out to the console when
 * tests are not passing when you expect them to.
 * @return {string}
 */
CommonWrapper.prototype.debug = function() {};

/**
 * Returns the name of the current node of the wrapper.
 * @return {string}
 */
CommonWrapper.prototype.name = function() {};

/**
 * Iterates through each node of the current wrapper and executes the provided function with a wrapper around
 * the corresponding node passed in as the first argument.
 * 
 * Returns itself.
 * @param {?} fn A callback to be run for every node in the collection. Should expect a ShallowWrapper as the first
 *              argument, and will be run with a context of the original instance.
 * @return {?}
 */
CommonWrapper.prototype.forEach = function(fn) {};

/**
 * Maps the current array of nodes to another array. Each node is passed in as a ShallowWrapper to the map
 * function.
 * Returns an array of the returned values from the mapping function..
 * @template V
 * @param {?} fn A mapping function to be run for every node in the collection, the results of which will be mapped
 *              to the returned array. Should expect a ShallowWrapper as the first argument, and will be run
 *              with a context of the original instance.
 * @return {!Array<?>}
 */
CommonWrapper.prototype.map = function(fn) {};

/**
 * Applies the provided reducing function to every node in the wrapper to reduce to a single value. Each node
 * is passed in as a ShallowWrapper, and is processed from left to right.
 * @template R
 * @param {?} fn
 * @param {?=} initialValue
 * @return {?}
 */
CommonWrapper.prototype.reduce = function(fn, initialValue) {};

/**
 * Applies the provided reducing function to every node in the wrapper to reduce to a single value.
 * Each node is passed in as a ShallowWrapper, and is processed from right to left.
 * @template R
 * @param {?} fn
 * @param {?=} initialValue
 * @return {?}
 */
CommonWrapper.prototype.reduceRight = function(fn, initialValue) {};

/**
 * Returns whether or not any of the nodes in the wrapper match the provided selector.
 * @param {(string|?)} selector
 * @return {boolean}
 */
CommonWrapper.prototype.some = function(selector) {};

/**
 * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.
 * @param {?} fn
 * @return {boolean}
 */
CommonWrapper.prototype.someWhere = function(fn) {};

/**
 * Returns whether or not all of the nodes in the wrapper match the provided selector.
 * @param {(string|?)} selector
 * @return {boolean}
 */
CommonWrapper.prototype.every = function(selector) {};

/**
 * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.
 * @param {?} fn
 * @return {boolean}
 */
CommonWrapper.prototype.everyWhere = function(fn) {};

/**
 * Returns true if renderer returned null
 * @return {boolean}
 */
CommonWrapper.prototype.isEmptyRender = function() {};

/**
 * Renders the component to static markup and returns a Cheerio wrapper around the result.
 * @return {!Cheerio}
 */
CommonWrapper.prototype.render = function() {};

/**
 * Returns the type of the current node of this wrapper. If it's a composite component, this will be the
 * component constructor. If it's native DOM node, it will be a string of the tag name.
 * 
 * Note: can only be called on a wrapper of a single node.
 * @return {(string|?)}
 */
CommonWrapper.prototype.type = function() {};

/**
 * @constructor
 * @struct
 * @param {(!JSX.Element|!Array<!JSX.Element>)} nodes
 * @param {?=} root
 * @param {?=} options
 */
function ShallowWrapper(nodes, root, options) {}

/**
 * @param {?=} options
 * @return {?}
 */
ShallowWrapper.prototype.shallow = function(options) {};

/**
 * @return {?}
 */
ShallowWrapper.prototype.unmount = function() {};

/**
 * Find every node in the render tree that matches the provided selector.
 * @template P2
 * @param {?|string} component_or_statelessComponent_or_props_or_selector
 * @return {?}
 */
ShallowWrapper.prototype.find = function(component_or_statelessComponent_or_props_or_selector) {};

/**
 * Removes nodes in the current wrapper that do not match the provided selector.
 * @template P2
 * @param {?|(string|?)} component_or_selector
 * @return {?}
 */
ShallowWrapper.prototype.filter = function(component_or_selector) {};

/**
 * Finds every node in the render tree that returns true for the provided predicate function.
 * @param {?} predicate
 * @return {?}
 */
ShallowWrapper.prototype.findWhere = function(predicate) {};

/**
 * Returns a new wrapper with all of the children of the node(s) in the current wrapper. Optionally, a selector
 * can be provided and it will filter the children by this selector.
 * @template P2
 * @param {?|string=} component_or_statelessComponent_or_selector_or_props
 * @return {?}
 */
ShallowWrapper.prototype.children = function(component_or_statelessComponent_or_selector_or_props) {};

/**
 * Returns a new wrapper with child at the specified index.
 * @template P2, S2
 * @param {number} index
 * @return {?}
 */
ShallowWrapper.prototype.childAt = function(index) {};

/**
 * Shallow render the one non-DOM child of the current wrapper, and return a wrapper around the result.
 * NOTE: can only be called on wrapper of a single non-DOM component element node.
 * @template P2, S2
 * @param {?=} options
 * @return {?}
 */
ShallowWrapper.prototype.dive = function(options) {};

/**
 * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node in the
 * current wrapper. Optionally, a selector can be provided and it will filter the parents by this selector.
 * 
 * Note: can only be called on a wrapper of a single node.
 * @template P2
 * @param {?|string=} component_or_statelessComponent_or_selector_or_props
 * @return {?}
 */
ShallowWrapper.prototype.parents = function(component_or_statelessComponent_or_selector_or_props) {};

/**
 * Returns a wrapper of the first element that matches the selector by traversing up through the current node's
 * ancestors in the tree, starting with itself.
 * 
 * Note: can only be called on a wrapper of a single node.
 * @template P2
 * @param {?|string} component_or_statelessComponent_or_props_or_selector
 * @return {?}
 */
ShallowWrapper.prototype.closest = function(component_or_statelessComponent_or_props_or_selector) {};

/**
 * Returns a wrapper with the direct parent of the node in the current wrapper.
 * @return {?}
 */
ShallowWrapper.prototype.parent = function() {};

/**
 * @constructor
 * @struct
 * @param {(!JSX.Element|!Array<!JSX.Element>)} nodes
 * @param {?=} root
 * @param {?=} options
 */
function ReactWrapper(nodes, root, options) {}

/**
 * @return {?}
 */
ReactWrapper.prototype.unmount = function() {};

/**
 * @return {?}
 */
ReactWrapper.prototype.mount = function() {};

/**
 * Returns a wrapper of the node that matches the provided reference name.
 * 
 * NOTE: can only be called on a wrapper instance that is also the root instance.
 * @template P2, S2
 * @param {string} refName
 * @return {?}
 */
ReactWrapper.prototype.ref = function(refName) {};

/**
 * Detaches the react tree from the DOM. Runs ReactDOM.unmountComponentAtNode() under the hood.
 * 
 * This method will most commonly be used as a "cleanup" method if you decide to use the attachTo option in mount(node, options).
 * 
 * The method is intentionally not "fluent" (in that it doesn't return this) because you should not be doing anything with this wrapper after this method is called.
 * 
 * Using the attachTo is not generally recommended unless it is absolutely necessary to test something.
 * It is your responsibility to clean up after yourself at the end of the test if you do decide to use it, though.
 * @return {void}
 */
ReactWrapper.prototype.detach = function() {};

/**
 * Find every node in the render tree that matches the provided selector.
 * @template P2
 * @param {?|string} component_or_statelessComponent_or_props_or_selector
 * @return {?}
 */
ReactWrapper.prototype.find = function(component_or_statelessComponent_or_props_or_selector) {};

/**
 * Finds every node in the render tree that returns true for the provided predicate function.
 * @param {?} predicate
 * @return {?}
 */
ReactWrapper.prototype.findWhere = function(predicate) {};

/**
 * Removes nodes in the current wrapper that do not match the provided selector.
 * @template P2
 * @param {?|(string|?)} component_or_props
 * @return {?}
 */
ReactWrapper.prototype.filter = function(component_or_props) {};

/**
 * Returns a new wrapper with all of the children of the node(s) in the current wrapper. Optionally, a selector
 * can be provided and it will filter the children by this selector.
 * @template P2
 * @param {?|string=} component_or_statelessComponent_or_selector_or_props
 * @return {?}
 */
ReactWrapper.prototype.children = function(component_or_statelessComponent_or_selector_or_props) {};

/**
 * Returns a new wrapper with child at the specified index.
 * @template P2, S2
 * @param {number} index
 * @return {?}
 */
ReactWrapper.prototype.childAt = function(index) {};

/**
 * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node in the
 * current wrapper. Optionally, a selector can be provided and it will filter the parents by this selector.
 * 
 * Note: can only be called on a wrapper of a single node.
 * @template P2
 * @param {?|string=} component_or_statelessComponent_or_selector_or_props
 * @return {?}
 */
ReactWrapper.prototype.parents = function(component_or_statelessComponent_or_selector_or_props) {};

/**
 * Returns a wrapper of the first element that matches the selector by traversing up through the current node's
 * ancestors in the tree, starting with itself.
 * 
 * Note: can only be called on a wrapper of a single node.
 * @template P2
 * @param {?|string} component_or_statelessComponent_or_props_or_selector
 * @return {?}
 */
ReactWrapper.prototype.closest = function(component_or_statelessComponent_or_props_or_selector) {};

/**
 * Returns a wrapper with the direct parent of the node in the current wrapper.
 * @return {?}
 */
ReactWrapper.prototype.parent = function() {};

/**
 * A method that sets the props of the root component, and re-renders. Useful for when you are wanting to test
 * how the component behaves over time with changing props. Calling this, for instance, will call the
 * componentWillReceiveProps lifecycle method.
 * 
 * Similar to setState, this method accepts a props object and will merge it in with the already existing props.
 * Returns itself.
 * 
 * NOTE: can only be called on a wrapper instance that is also the root instance.
 * @template K
 * @param {?} props
 * @param {?=} callback
 * @return {?}
 */
ReactWrapper.prototype.setProps = function(props, callback) {};
/**
 * @record
 * @struct
 */
function ShallowRendererProps() {}
 /** @type {boolean} */
ShallowRendererProps.prototype.lifecycleExperimental;
 /** @type {!Object} */
ShallowRendererProps.prototype.context;
/**
 * @record
 * @struct
 */
function MountRendererProps() {}
 /** @type {!Object} */
MountRendererProps.prototype.context;
 /** @type {!HTMLElement} */
MountRendererProps.prototype.attachTo;
 /** @type {!Object} */
MountRendererProps.prototype.childContextTypes;

/**
 * Shallow rendering is useful to constrain yourself to testing a component as a unit, and to ensure that
 * your tests aren't indirectly asserting on behavior of child components.
 * @template P, S
 * @param {!React.ReactElement<?>} node
 * @param {?=} options
 * @return {?}
 */
function shallow(node, options) {}

/**
 * Mounts and renders a react component into the document and provides a testing wrapper around it.
 * @template P, S
 * @param {!React.ReactElement<?>} node
 * @param {?=} options
 * @return {?}
 */
function mount(node, options) {}

/**
 * Render react components to static HTML and analyze the resulting HTML structure.
 * @template P, S
 * @param {!React.ReactElement<?>} node
 * @param {?=} options
 * @return {!Cheerio}
 */
function render(node, options) {}
