/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/reflect-metadata/index.d.ts:
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "reflect-metadata"
/** @const */
tsickle_declare_module.reflect_metadata = {};

/**
 * Applies a set of decorators to a target object.
 * \@remarks Decorators are applied in reverse order of their positions in the array.
 * \@example 
 * 
 *     class C { }
 * 
 *     // constructor
 *     C = Reflect.decorate(decoratorsArray, C);
 * 
 * Applies a set of decorators to a property of a target object.
 * \@remarks Decorators are applied in reverse order.
 * \@example 
 * 
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 * 
 *         static staticMethod() { }
 *         method() { }
 *     }
 * 
 *     // property (on constructor)
 *     Reflect.decorate(decoratorsArray, C, "staticProperty");
 * 
 *     // property (on prototype)
 *     Reflect.decorate(decoratorsArray, C.prototype, "property");
 * 
 *     // method (on constructor)
 *     Object.defineProperty(C, "staticMethod",
 *         Reflect.decorate(decoratorsArray, C, "staticMethod",
 *             Object.getOwnPropertyDescriptor(C, "staticMethod")));
 * 
 *     // method (on prototype)
 *     Object.defineProperty(C.prototype, "method",
 *         Reflect.decorate(decoratorsArray, C.prototype, "method",
 *             Object.getOwnPropertyDescriptor(C.prototype, "method")));
 * 
 * @param {!Array<function(TFunction): (void|TFunction)>|!Array<(function(!Object, (string|symbol)): void|function(!Object, (string|symbol), !TypedPropertyDescriptor<T>): (void|!TypedPropertyDescriptor<T>))>} decorators An array of decorators.
 * @param {!Function|!Object} target The target object.
 * @param {(string|symbol)=} targetKey The property key to decorate.
 * @param {!PropertyDescriptor=} descriptor A property descriptor
 * @return {!Function|!PropertyDescriptor} The result of applying the provided decorators.
 */
Reflect.decorate = function(decorators, target, targetKey, descriptor) {};

/**
 * A default metadata decorator factory that can be used on a class, class member, or parameter.
 * \@remarks 
 * If `metadataKey` is already defined for the target and target key, the
 * metadataValue for that key will be overwritten.
 * \@example 
 * 
 *     // constructor
 *     \@Reflect.metadata(key, value)
 *     class C {
 *     }
 * 
 *     // property (on constructor, TypeScript only)
 *     class C {
 *         \@Reflect.metadata(key, value)
 *         static staticProperty;
 *     }
 * 
 *     // property (on prototype, TypeScript only)
 *     class C {
 *         \@Reflect.metadata(key, value)
 *         property;
 *     }
 * 
 *     // method (on constructor)
 *     class C {
 *         \@Reflect.metadata(key, value)
 *         static staticMethod() { }
 *     }
 * 
 *     // method (on prototype)
 *     class C {
 *         \@Reflect.metadata(key, value)
 *         method() { }
 *     }
 * 
 * @param {?} metadataKey The key for the metadata entry.
 * @param {?} metadataValue The value for the metadata entry.
 * @return {?} A decorator function.
 */
Reflect.metadata = function(metadataKey, metadataValue) {};

/**
 * Define a unique metadata entry on the target.
 * \@example 
 * 
 *     class C {
 *     }
 * 
 *     // constructor
 *     Reflect.defineMetadata("custom:annotation", options, C);
 * 
 *     // decorator factory as metadata-producing annotation.
 *     function MyAnnotation(options): ClassDecorator {
 *         return target => Reflect.defineMetadata("custom:annotation", options, target);
 *     }
 * 
 * Define a unique metadata entry on the target.
 * \@example 
 * 
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 * 
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 * 
 *     // property (on constructor)
 *     Reflect.defineMetadata("custom:annotation", Number, C, "staticProperty");
 * 
 *     // property (on prototype)
 *     Reflect.defineMetadata("custom:annotation", Number, C.prototype, "property");
 * 
 *     // method (on constructor)
 *     Reflect.defineMetadata("custom:annotation", Number, C, "staticMethod");
 * 
 *     // method (on prototype)
 *     Reflect.defineMetadata("custom:annotation", Number, C.prototype, "method");
 * 
 *     // decorator factory as metadata-producing annotation.
 *     function MyAnnotation(options): PropertyDecorator {
 *         return (target, key) => Reflect.defineMetadata("custom:annotation", options, target, key);
 *     }
 * 
 * @param {?} metadataKey A key used to store and retrieve metadata.
 * @param {?} metadataValue A value that contains attached metadata.
 * @param {!Object} target The target object on which to define metadata.
 * @param {(string|symbol)=} targetKey The property key for the target.
 * @return {void}
 */
Reflect.defineMetadata = function(metadataKey, metadataValue, target, targetKey) {};

/**
 * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
 * \@example 
 * 
 *     class C {
 *     }
 * 
 *     // constructor
 *     result = Reflect.hasMetadata("custom:annotation", C);
 * 
 * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
 * \@example 
 * 
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 * 
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 * 
 *     // property (on constructor)
 *     result = Reflect.hasMetadata("custom:annotation", C, "staticProperty");
 * 
 *     // property (on prototype)
 *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "property");
 * 
 *     // method (on constructor)
 *     result = Reflect.hasMetadata("custom:annotation", C, "staticMethod");
 * 
 *     // method (on prototype)
 *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "method");
 * 
 * @param {?} metadataKey A key used to store and retrieve metadata.
 * @param {!Object} target The target object on which the metadata is defined.
 * @param {(string|symbol)=} targetKey The property key for the target.
 * @return {boolean} `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
 */
Reflect.hasMetadata = function(metadataKey, target, targetKey) {};

/**
 * Gets a value indicating whether the target object has the provided metadata key defined.
 * \@example 
 * 
 *     class C {
 *     }
 * 
 *     // constructor
 *     result = Reflect.hasOwnMetadata("custom:annotation", C);
 * 
 * Gets a value indicating whether the target object has the provided metadata key defined.
 * \@example 
 * 
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 * 
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 * 
 *     // property (on constructor)
 *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticProperty");
 * 
 *     // property (on prototype)
 *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "property");
 * 
 *     // method (on constructor)
 *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticMethod");
 * 
 *     // method (on prototype)
 *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "method");
 * 
 * @param {?} metadataKey A key used to store and retrieve metadata.
 * @param {!Object} target The target object on which the metadata is defined.
 * @param {(string|symbol)=} targetKey The property key for the target.
 * @return {boolean} `true` if the metadata key was defined on the target object; otherwise, `false`.
 */
Reflect.hasOwnMetadata = function(metadataKey, target, targetKey) {};

/**
 * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
 * \@example 
 * 
 *     class C {
 *     }
 * 
 *     // constructor
 *     result = Reflect.getMetadata("custom:annotation", C);
 * 
 * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
 * \@example 
 * 
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 * 
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 * 
 *     // property (on constructor)
 *     result = Reflect.getMetadata("custom:annotation", C, "staticProperty");
 * 
 *     // property (on prototype)
 *     result = Reflect.getMetadata("custom:annotation", C.prototype, "property");
 * 
 *     // method (on constructor)
 *     result = Reflect.getMetadata("custom:annotation", C, "staticMethod");
 * 
 *     // method (on prototype)
 *     result = Reflect.getMetadata("custom:annotation", C.prototype, "method");
 * 
 * @param {?} metadataKey A key used to store and retrieve metadata.
 * @param {!Object} target The target object on which the metadata is defined.
 * @param {(string|symbol)=} targetKey The property key for the target.
 * @return {?} The metadata value for the metadata key if found; otherwise, `undefined`.
 */
Reflect.getMetadata = function(metadataKey, target, targetKey) {};

/**
 * Gets the metadata value for the provided metadata key on the target object.
 * \@example 
 * 
 *     class C {
 *     }
 * 
 *     // constructor
 *     result = Reflect.getOwnMetadata("custom:annotation", C);
 * 
 * Gets the metadata value for the provided metadata key on the target object.
 * \@example 
 * 
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 * 
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 * 
 *     // property (on constructor)
 *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticProperty");
 * 
 *     // property (on prototype)
 *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "property");
 * 
 *     // method (on constructor)
 *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticMethod");
 * 
 *     // method (on prototype)
 *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "method");
 * 
 * @param {?} metadataKey A key used to store and retrieve metadata.
 * @param {!Object} target The target object on which the metadata is defined.
 * @param {(string|symbol)=} targetKey The property key for the target.
 * @return {?} The metadata value for the metadata key if found; otherwise, `undefined`.
 */
Reflect.getOwnMetadata = function(metadataKey, target, targetKey) {};

/**
 * Gets the metadata keys defined on the target object or its prototype chain.
 * \@example 
 * 
 *     class C {
 *     }
 * 
 *     // constructor
 *     result = Reflect.getMetadataKeys(C);
 * 
 * Gets the metadata keys defined on the target object or its prototype chain.
 * \@example 
 * 
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 * 
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 * 
 *     // property (on constructor)
 *     result = Reflect.getMetadataKeys(C, "staticProperty");
 * 
 *     // property (on prototype)
 *     result = Reflect.getMetadataKeys(C.prototype, "property");
 * 
 *     // method (on constructor)
 *     result = Reflect.getMetadataKeys(C, "staticMethod");
 * 
 *     // method (on prototype)
 *     result = Reflect.getMetadataKeys(C.prototype, "method");
 * 
 * @param {!Object} target The target object on which the metadata is defined.
 * @param {(string|symbol)=} targetKey The property key for the target.
 * @return {!Array<?>} An array of unique metadata keys.
 */
Reflect.getMetadataKeys = function(target, targetKey) {};

/**
 * Gets the unique metadata keys defined on the target object.
 * \@example 
 * 
 *     class C {
 *     }
 * 
 *     // constructor
 *     result = Reflect.getOwnMetadataKeys(C);
 * 
 * Gets the unique metadata keys defined on the target object.
 * \@example 
 * 
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 * 
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 * 
 *     // property (on constructor)
 *     result = Reflect.getOwnMetadataKeys(C, "staticProperty");
 * 
 *     // property (on prototype)
 *     result = Reflect.getOwnMetadataKeys(C.prototype, "property");
 * 
 *     // method (on constructor)
 *     result = Reflect.getOwnMetadataKeys(C, "staticMethod");
 * 
 *     // method (on prototype)
 *     result = Reflect.getOwnMetadataKeys(C.prototype, "method");
 * 
 * @param {!Object} target The target object on which the metadata is defined.
 * @param {(string|symbol)=} targetKey The property key for the target.
 * @return {!Array<?>} An array of unique metadata keys.
 */
Reflect.getOwnMetadataKeys = function(target, targetKey) {};

/**
 * Deletes the metadata entry from the target object with the provided key.
 * \@example 
 * 
 *     class C {
 *     }
 * 
 *     // constructor
 *     result = Reflect.deleteMetadata("custom:annotation", C);
 * 
 * Deletes the metadata entry from the target object with the provided key.
 * \@example 
 * 
 *     class C {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 * 
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 * 
 *     // property (on constructor)
 *     result = Reflect.deleteMetadata("custom:annotation", C, "staticProperty");
 * 
 *     // property (on prototype)
 *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "property");
 * 
 *     // method (on constructor)
 *     result = Reflect.deleteMetadata("custom:annotation", C, "staticMethod");
 * 
 *     // method (on prototype)
 *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "method");
 * 
 * @param {?} metadataKey A key used to store and retrieve metadata.
 * @param {!Object} target The target object on which the metadata is defined.
 * @param {(string|symbol)=} targetKey The property key for the target.
 * @return {boolean} `true` if the metadata entry was found and deleted; otherwise, false.
 */
Reflect.deleteMetadata = function(metadataKey, target, targetKey) {};
