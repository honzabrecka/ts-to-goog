/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/q v0/index.d.ts:

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */

/**
 * If value is a Q promise, returns the promise.
 * If value is a promise from another library it is coerced into a Q promise (where possible).
 * If value is not a promise, returns a promise that is fulfilled with value.
 * Calling with nothing at all creates a void promise
 * @template T
 * @param {!Q.IPromise<T>|T=} promise_or_value
 * @return {?<T>|?<void>}
 */
function Q(promise_or_value) {}

/** @typedef {(T|!Q.IPromise<T>)} */
Q.IWhenable;
/**
 * @record
 * @struct
 */
Q.IPromise = function() {};

/**
 * @template U
 * @param {function(T): (U|!Q.IPromise<U>)=} onFulfill
 * @param {function(?): (U|!Q.IPromise<U>)=} onReject
 * @return {!Q.IPromise<U>}
 */
Q.IPromise.prototype.then = function(onFulfill, onReject) {};
/**
 * @record
 * @struct
 */
Q.Deferred = function() {};
 /** @type {?<T>} */
Q.Deferred.prototype.promise;

/**
 * @param {(T|!Q.IPromise<T>)=} value
 * @return {void}
 */
Q.Deferred.prototype.resolve = function(value) {};

/**
 * @param {?} reason
 * @return {void}
 */
Q.Deferred.prototype.reject = function(reason) {};

/**
 * @param {?} value
 * @return {void}
 */
Q.Deferred.prototype.notify = function(value) {};

/**
 * @return {function(?, T): void}
 */
Q.Deferred.prototype.makeNodeResolver = function() {};
/**
 * @record
 * @struct
 */
Q.Promise = function() {};

/**
 * Like a finally clause, allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded, like closing a database connection, shutting a server down, or deleting an unneeded key from an object.
 * finally returns a promise, which will become resolved with the same fulfillment value or rejection reason as promise. However, if callback returns a promise, the resolution of the returned promise will be delayed until the promise returned from callback is finished.
 * @param {function(): ?} finallyCallback
 * @return {?}
 */
Q.Promise.prototype.fin = function(finallyCallback) {};

/**
 * Like a finally clause, allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded, like closing a database connection, shutting a server down, or deleting an unneeded key from an object.
 * finally returns a promise, which will become resolved with the same fulfillment value or rejection reason as promise. However, if callback returns a promise, the resolution of the returned promise will be delayed until the promise returned from callback is finished.
 * @param {function(): ?} finallyCallback
 * @return {?}
 */
Q.Promise.prototype.finally = function(finallyCallback) {};

/**
 * The then method from the Promises/A+ specification, with an additional progress handler.
 * @template U
 * @param {function(T): (U|!Q.IPromise<U>)=} onFulfill
 * @param {function(?): (U|!Q.IPromise<U>)=} onReject
 * @param {!Function=} onProgress
 * @return {?<U>}
 */
Q.Promise.prototype.then = function(onFulfill, onReject, onProgress) {};

/**
 * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
 * 
 * This is especially useful in conjunction with all
 * @template U
 * @param {function(!Array<?>): (U|!Q.IPromise<U>)} onFulfill
 * @param {function(?): (U|!Q.IPromise<U>)=} onReject
 * @return {?<U>}
 */
Q.Promise.prototype.spread = function(onFulfill, onReject) {};

/**
 * @template U
 * @param {function(?): (U|!Q.IPromise<U>)} onRejected
 * @return {?<U>}
 */
Q.Promise.prototype.fail = function(onRejected) {};

/**
 * A sugar method, equivalent to promise.then(undefined, onRejected).
 * @template U
 * @param {function(?): (U|!Q.IPromise<U>)} onRejected
 * @return {?<U>}
 */
Q.Promise.prototype.catch = function(onRejected) {};

/**
 * A sugar method, equivalent to promise.then(undefined, undefined, onProgress).
 * @param {function(?): ?} onProgress
 * @return {?}
 */
Q.Promise.prototype.progress = function(onProgress) {};

/**
 * Much like then, but with different behavior around unhandled rejection. If there is an unhandled rejection, either because promise is rejected and no onRejected callback was provided, or because onFulfilled or onRejected threw an error or returned a rejected promise, the resulting rejection reason is thrown as an exception in a future turn of the event loop.
 * 
 * This method should be used to terminate chains of promises that will not be passed elsewhere. Since exceptions thrown in then callbacks are consumed and transformed into rejections, exceptions at the end of the chain are easy to accidentally, silently ignore. By arranging for the exception to be thrown in a future turn of the event loop, so that it won't be caught, it causes an onerror event on the browser window, or an uncaughtException event on Node.js's process object.
 * 
 * Exceptions thrown by done will have long stack traces, if Q.longStackSupport is set to true. If Q.onerror is set, exceptions will be delivered there instead of thrown in a future turn.
 * 
 * The Golden Rule of done vs. then usage is: either return your promise to someone else, or if the chain ends with you, call done to terminate it.
 * @param {function(T): ?=} onFulfilled
 * @param {function(?): ?=} onRejected
 * @param {function(?): ?=} onProgress
 * @return {void}
 */
Q.Promise.prototype.done = function(onFulfilled, onRejected, onProgress) {};

/**
 * If callback is a function, assumes it's a Node.js-style callback, and calls it as either callback(rejectionReason) when/if promise becomes rejected, or as callback(null, fulfillmentValue) when/if promise becomes fulfilled. If callback is not a function, simply returns promise.
 * @param {function(?, ?): void} callback
 * @return {?}
 */
Q.Promise.prototype.nodeify = function(callback) {};

/**
 * Returns a promise to get the named property of an object. Essentially equivalent to
 * 
 * promise.then(function (o) {
 *     return o[propertyName];
 * });
 * @template U
 * @param {!String} propertyName
 * @return {?<U>}
 */
Q.Promise.prototype.get = function(propertyName) {};

/**
 * @template U
 * @param {!String} propertyName
 * @param {?} value
 * @return {?<U>}
 */
Q.Promise.prototype.set = function(propertyName, value) {};

/**
 * @template U
 * @param {!String} propertyName
 * @return {?<U>}
 */
Q.Promise.prototype.delete = function(propertyName) {};

/**
 * Returns a promise for the result of calling the named method of an object with the given array of arguments. The object itself is this in the function, just like a synchronous method call. Essentially equivalent to
 * 
 * promise.then(function (o) {
 *     return o[methodName].apply(o, args);
 * });
 * @template U
 * @param {!String} methodName
 * @param {!Array<?>} args
 * @return {?<U>}
 */
Q.Promise.prototype.post = function(methodName, args) {};

/**
 * Returns a promise for the result of calling the named method of an object with the given variadic arguments. The object itself is this in the function, just like a synchronous method call.
 * @template U
 * @param {!String} methodName
 * @param {...?} args
 * @return {?<U>}
 */
Q.Promise.prototype.invoke = function(methodName, args) {};

/**
 * @template U
 * @param {!Array<?>} args
 * @return {?<U>}
 */
Q.Promise.prototype.fapply = function(args) {};

/**
 * @template U
 * @param {...?} args
 * @return {?<U>}
 */
Q.Promise.prototype.fcall = function(args) {};

/**
 * Returns a promise for an array of the property names of an object. Essentially equivalent to
 * 
 * promise.then(function (o) {
 *     return Object.keys(o);
 * });
 * @return {?<!Array<string>>}
 */
Q.Promise.prototype.keys = function() {};

/**
 * A sugar method, equivalent to promise.then(function () { return value; }).
 * @template U
 * @param {U} value
 * @return {?<U>}
 */
Q.Promise.prototype.thenResolve = function(value) {};

/**
 * A sugar method, equivalent to promise.then(function () { throw reason; }).
 * @param {?} reason
 * @return {?}
 */
Q.Promise.prototype.thenReject = function(reason) {};

/**
 * Attaches a handler that will observe the value of the promise when it becomes fulfilled, returning a promise for that same value, perhaps deferred but not replaced by the promise returned by the onFulfilled handler.
 * @param {function(T): ?} onFulfilled
 * @return {?}
 */
Q.Promise.prototype.tap = function(onFulfilled) {};

/**
 * @param {number} ms
 * @param {string=} message
 * @return {?}
 */
Q.Promise.prototype.timeout = function(ms, message) {};

/**
 * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least ms milliseconds have passed.
 * @param {number} ms
 * @return {?}
 */
Q.Promise.prototype.delay = function(ms) {};

/**
 * Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the result is always true.
 * @return {boolean}
 */
Q.Promise.prototype.isFulfilled = function() {};

/**
 * Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the result is always false.
 * @return {boolean}
 */
Q.Promise.prototype.isRejected = function() {};

/**
 * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always false.
 * @return {boolean}
 */
Q.Promise.prototype.isPending = function() {};

/**
 * @return {?}
 */
Q.Promise.prototype.valueOf = function() {};

/**
 * Returns a "state snapshot" object, which will be in one of three forms:
 * 
 * - { state: "pending" }
 * - { state: "fulfilled", value: <fulfllment value> }
 * - { state: "rejected", reason: <rejection reason> }
 * @return {!Q.PromiseState<T>}
 */
Q.Promise.prototype.inspect = function() {};

/**
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * @template A, B, C, D, E, F, T
 * @this {?<!Array<?>>|?<!Array<(T|!Q.IPromise<T>)>>}
 * @return {?<!Array<?>>|?<!Array<T>>}
 */
Q.Promise.prototype.all = function() {};
/**
 * @record
 * @struct
 */
Q.PromiseState = function() {};
 /** @type {string} */
Q.PromiseState.prototype.state;
 /** @type {T} */
Q.PromiseState.prototype.value;
 /** @type {?} */
Q.PromiseState.prototype.reason;

/**
 * @template T, U
 * @param {(T|!Q.IPromise<T>)=} value
 * @param {function(T): (U|!Q.IPromise<U>)=} onFulfilled
 * @param {function(?): (U|!Q.IPromise<U>)=} onRejected
 * @param {function(?): ?=} onProgress
 * @return {?<void>|?<T>|?<U>}
 */
Q.when = function(value, onFulfilled, onRejected, onProgress) {};

/**
 * @template T
 * @param {function(!Array<?>): (T|!Q.IPromise<T>)} method
 * @param {...?} args
 * @return {function(!Array<?>): ?<T>}
 */
Q.fbind = function(method, args) {};

/**
 * @template T
 * @param {function(!Array<?>): T} method
 * @param {...?} args
 * @return {?<T>}
 */
Q.fcall = function(method, args) {};

/**
 * @template T
 * @param {?} obj
 * @param {string} functionName
 * @param {...?} args
 * @return {?<T>}
 */
Q.send = function(obj, functionName, args) {};

/**
 * @template T
 * @param {?} obj
 * @param {string} functionName
 * @param {...?} args
 * @return {?<T>}
 */
Q.invoke = function(obj, functionName, args) {};

/**
 * @template T
 * @param {?} obj
 * @param {string} functionName
 * @param {...?} args
 * @return {?<T>}
 */
Q.mcall = function(obj, functionName, args) {};

/**
 * @template T
 * @param {!Function} nodeFunction
 * @param {...?} args
 * @return {function(!Array<?>): ?<T>}
 */
Q.denodeify = function(nodeFunction, args) {};

/**
 * @template T
 * @param {!Function} nodeFunction
 * @param {?} thisArg
 * @param {...?} args
 * @return {function(!Array<?>): ?<T>}
 */
Q.nbind = function(nodeFunction, thisArg, args) {};

/**
 * @template T
 * @param {!Function} nodeFunction
 * @param {...?} args
 * @return {function(!Array<?>): ?<T>}
 */
Q.nfbind = function(nodeFunction, args) {};

/**
 * @template T
 * @param {!Function} nodeFunction
 * @param {...?} args
 * @return {?<T>}
 */
Q.nfcall = function(nodeFunction, args) {};

/**
 * @template T
 * @param {!Function} nodeFunction
 * @param {!Array<?>} args
 * @return {?<T>}
 */
Q.nfapply = function(nodeFunction, args) {};

/**
 * @template T
 * @param {?} nodeModule
 * @param {string} functionName
 * @param {...?} args
 * @return {?<T>}
 */
Q.ninvoke = function(nodeModule, functionName, args) {};

/**
 * @template T
 * @param {?} nodeModule
 * @param {string} functionName
 * @param {!Array<?>} args
 * @return {?<T>}
 */
Q.npost = function(nodeModule, functionName, args) {};

/**
 * @template T
 * @param {?} nodeModule
 * @param {string} functionName
 * @param {...?} args
 * @return {?<T>}
 */
Q.nsend = function(nodeModule, functionName, args) {};

/**
 * @template T
 * @param {?} nodeModule
 * @param {string} functionName
 * @param {...?} args
 * @return {?<T>}
 */
Q.nmcall = function(nodeModule, functionName, args) {};

/**
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
 * @template A, B, C, D, E, F, T
 * @param {(!Array<?>|!Q.IPromise<!Array<?>>)|(!Array<(T|!Q.IPromise<T>)>|!Q.IPromise<!Array<(T|!Q.IPromise<T>)>>)} promises
 * @return {?<!Array<?>>|?<!Array<T>>}
 */
Q.all = function(promises) {};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @template T
 * @param {!Array<(T|!Q.IPromise<T>)>} promises
 * @return {?<T>}
 */
Q.race = function(promises) {};

/**
 * Returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected.
 * @template T
 * @param {(!Array<(T|!Q.IPromise<T>)>|!Q.IPromise<!Array<(T|!Q.IPromise<T>)>>)} promises
 * @return {?<!Array<!Q.PromiseState<T>>>}
 */
Q.allSettled = function(promises) {};

/**
 * @template T
 * @param {(!Array<(T|!Q.IPromise<T>)>|!Q.IPromise<!Array<(T|!Q.IPromise<T>)>>)} promises
 * @return {?<!Array<?<T>>>}
 */
Q.allResolved = function(promises) {};

/**
 * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
 * This is especially useful in conjunction with all.
 * @template T, U
 * @param {!Array<(T|!Q.IPromise<T>)>} promises
 * @param {function(!Array<T>): (U|!Q.IPromise<U>)} onFulfilled
 * @param {function(?): (U|!Q.IPromise<U>)=} onRejected
 * @return {?<U>}
 */
Q.spread = function(promises, onFulfilled, onRejected) {};

/**
 * Returns a promise that will have the same result as promise, except that if promise is not fulfilled or rejected before ms milliseconds, the returned promise will be rejected with an Error with the given message. If message is not supplied, the message will be "Timed out after " + ms + " ms".
 * @template T
 * @param {?<T>} promise
 * @param {number} ms
 * @param {string=} message
 * @return {?<T>}
 */
Q.timeout = function(promise, ms, message) {};

/**
 * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least ms milliseconds have passed.
 * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least ms milliseconds have passed.
 * Returns a promise that will be fulfilled with undefined after at least ms milliseconds have passed.
 * @template T
 * @param {?<T>|T|number} promise_or_value_or_ms
 * @param {number=} ms
 * @return {?<T>|?<void>}
 */
Q.delay = function(promise_or_value_or_ms, ms) {};

/**
 * Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the result is always true.
 * @param {?<?>} promise
 * @return {boolean}
 */
Q.isFulfilled = function(promise) {};

/**
 * Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the result is always false.
 * @param {?<?>} promise
 * @return {boolean}
 */
Q.isRejected = function(promise) {};

/**
 * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always false.
 * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always false.
 * @param {?<?>|?} promise_or_object
 * @return {boolean}
 */
Q.isPending = function(promise_or_object) {};

/**
 * Returns a "deferred" object with a:
 * promise property
 * resolve(value) method
 * reject(reason) method
 * notify(value) method
 * makeNodeResolver() method
 * @template T
 * @return {!Q.Deferred<T>}
 */
Q.defer = function() {};

/**
 * Returns a promise that is rejected with reason.
 * @template T
 * @param {?=} reason
 * @return {?<T>}
 */
Q.reject = function(reason) {};

/**
 * @template T
 * @param {function(function((T|!Q.IPromise<T>)): void, function(?): void, function(?): void): void} resolver
 * @return {?<T>}
 */
Q.Promise = function(resolver) {};

/**
 * Creates a new version of func that accepts any combination of promise and non-promise values, converting them to their fulfillment values before calling the original func. The returned version also always returns a promise: if func does a return or throw, then Q.promised(func) will return fulfilled or rejected promise, respectively.
 * 
 * This can be useful for creating functions that accept either promises or non-promise values, and for ensuring that the function always returns a promise even in the face of unintentional thrown exceptions.
 * @template T
 * @param {function(!Array<?>): T} callback
 * @return {function(!Array<?>): ?<T>}
 */
Q.promised = function(callback) {};

/**
 * Returns whether the given value is a Q promise.
 * @param {?} object
 * @return {boolean}
 */
Q.isPromise = function(object) {};

/**
 * Returns whether the given value is a promise (i.e. it's an object with a then function).
 * @param {?} object
 * @return {boolean}
 */
Q.isPromiseAlike = function(object) {};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @template T
 * @param {?<T>} promise
 * @return {T}
 */
Q.nearer = function(promise) {};

/**
 * This is an experimental tool for converting a generator function into a deferred function. This has the potential of reducing nested callbacks in engines that support yield.
 * @template T
 * @param {?} generatorFunction
 * @return {function(!Array<?>): ?<T>}
 */
Q.async = function(generatorFunction) {};

/**
 * @param {!Function} callback
 * @return {void}
 */
Q.nextTick = function(callback) {};
 /** @type {function(?): void} */
Q.onerror;
 /** @type {boolean} */
Q.longStackSupport;

/**
 * Calling resolve with a pending promise causes promise to wait on the passed promise, becoming fulfilled with its fulfillment value or rejected with its rejection reason (or staying pending forever, if the passed promise does).
 * Calling resolve with a rejected promise causes promise to be rejected with the passed promise's rejection reason.
 * Calling resolve with a fulfilled promise causes promise to be fulfilled with the passed promise's fulfillment value.
 * Calling resolve with a non-promise value causes promise to be fulfilled with that value.
 * @template T
 * @param {(T|!Q.IPromise<T>)} object
 * @return {?<T>}
 */
Q.resolve = function(object) {};

/**
 * Resets the global "Q" variable to the value it has before Q was loaded.
 * This will either be undefined if there was no version or the version of Q which was already loaded before.
 * @return {?}
 */
Q.noConflict = function() {};
