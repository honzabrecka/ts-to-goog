/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/d3-selection/index.d.ts:

/** @typedef {(!Element|?|!Document|!Window)} */
var BaseType;
/**
 * @record
 * @struct
 */
function ArrayLike() {}
 /** @type {number} */
ArrayLike.prototype.length;

/* TODO: IndexSignature:  */

/**
 * @param {number} index
 * @return {?}
 */
ArrayLike.prototype.item = function(index) {};
/**
 * @record
 * @struct
 */
function EnterElement() {}
 /** @type {!Document} */
EnterElement.prototype.ownerDocument;
 /** @type {string} */
EnterElement.prototype.namespaceURI;

/**
 * @param {!Node} newChild
 * @return {!Node}
 */
EnterElement.prototype.appendChild = function(newChild) {};

/**
 * @param {!Node} newChild
 * @param {!Node} refChild
 * @return {!Node}
 */
EnterElement.prototype.insertBefore = function(newChild, refChild) {};

/**
 * @param {string} selectors
 * @return {!Element}
 */
EnterElement.prototype.querySelector = function(selectors) {};

/**
 * @param {string} selectors
 * @return {!NodeListOf<!Element>}
 */
EnterElement.prototype.querySelectorAll = function(selectors) {};

/** @typedef {(!HTMLElement|!SVGSVGElement|!SVGGElement)} */
var ContainerElement;
/**
 * @record
 * @struct
 */
function CustomEventParameters() {}
 /** @type {boolean} */
CustomEventParameters.prototype.bubbles;
 /** @type {boolean} */
CustomEventParameters.prototype.cancelable;
 /** @type {?} */
CustomEventParameters.prototype.detail;

/** @typedef {?} */
var ValueFn;
/**
 * @record
 * @struct
 */
function TransitionLike() {}

/**
 * @return {?}
 */
TransitionLike.prototype.selection = function() {};

/**
 * @param {string} type
 * @param {null|?} listener
 * @return {?}
 */
TransitionLike.prototype.on = function(type, listener) {};

/**
 * @param {string} name
 * @param {null|?} tweenFn
 * @return {?}
 */
TransitionLike.prototype.tween = function(name, tweenFn) {};

/**
 * Select the first element that matches the specified selector string. If no elements match the selector, returns an empty selection.
 * If multiple elements match the selector, only the first matching element (in document order) will be selected.
 * 
 * The first generic  "GElement" refers to the type of element to be selected. The second generic "OldDatum" refers to the type of the
 * datum, on the selected element. This is useful when re-selecting an element with a previously set, know datum type.
 * 
 * Select the specified node element.
 * 
 * The first generic  "GElement" refers to the type of element to be selected. The second generic "OldDatum" refers to the type of the
 * datum, on the selected element. This is useful when re-selecting an element with a previously set, know datum type.
 * 
 * @template GElement, OldDatum
 * @param {string|?} selector_or_node CSS selector string / An element to be selected
 * @return {?}
 */
function select(selector_or_node) {}

/**
 * Create an empty selection.
 * Create an empty selection.
 * Create an empty selection.
 * Select all elements that match the specified selector string. The elements will be selected in document order (top-to-bottom).
 * If no elements in the document match the selector, returns an empty selection.
 * 
 * The first generic "GElement" refers to the type of element to be selected. The second generic "OldDatum" refers to the type of the
 * datum, of a selected element. This is useful when re-selecting elements with a previously set, know datum type.
 * 
 * Select the specified array of nodes.
 * 
 * The first generic "GElement" refers to the type of element to be selected. The second generic "OldDatum" refers to the type of the
 * datum, of a selected element. This is useful when re-selecting elements with a previously set, know datum type.
 * 
 * Select the specified nodes. This signature allows the selection of nodes contained in a NodeList, HTMLCollection or similar data structure.
 * 
 * The first generic "GElement" refers to the type of element to be selected. The second generic "OldDatum" refers to the type of the
 * datum, of a selected element. This is useful when re-selecting elements with a previously set, know datum type.
 * 
 * @template GElement, OldDatum
 * @param {null|undefined|string|!Array<?>|?=} selector_or_nodes CSS selector string / An Array of nodes / An Array-like collection of nodes
 * @return {?}
 */
function selectAll(selector_or_nodes) {}
/**
 * @record
 * @struct
 */
function Selection() {}

/**
 * For each selected element, select the first descendant element that matches the specified selector string.
 * If no element matches the specified selector for the current element, the element at the current index will
 * be null in the returned selection. If multiple elements match the selector, only the first matching element
 * in document order is selected. Selection.select does not affect grouping: it preserves the existing group
 * structure and indexes, and propagates data (if any) to selected children.
 * 
 * If the current element has associated data, this data is propagated to the
 * corresponding selected element.
 * 
 * The generic represents the type of the descendant element to be selected.
 * 
 * Create an empty sub-selection. Selection.select does not affect grouping: it preserves the existing group
 * structure and indexes.
 * For each selected element, select the descendant element returned by the selector function.
 * If no element is returned by the selector function for the current element, the element at the
 * current index will be null in the returned selection. Selection.select does not affect grouping:
 * it preserves the existing group structure and indexes, and propagates data (if any) to selected children.
 * 
 * If the current element has associated data, this data is propagated to the
 * corresponding selected element.
 * 
 * The generic represents the type of the descendant element to be selected.
 * 
 * @template DescElement
 * @param {string|null|?} selector CSS selector string / A selector function, which is evaluated for each selected element, in order, being passed the current datum (d),
 * the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).
 * It must return an element, or null if there is no matching element.
 * @return {?}
 */
Selection.prototype.select = function(selector) {};

/**
 * Create an empty sub-selection. Selection.selectAll does affect grouping: The elements in the returned
 * selection are grouped by their corresponding parent node in this selection, the group at the current index will be empty.
 * Create an empty sub-selection. Selection.selectAll does affect grouping: The elements in the returned
 * selection are grouped by their corresponding parent node in this selection, the group at the current index will be empty.
 * Create an empty sub-selection. Selection.selectAll does affect grouping: The elements in the returned
 * selection are grouped by their corresponding parent node in this selection, the group at the current index will be empty.
 * For each selected element, selects the descendant elements that match the specified selector string. The elements in the returned
 * selection are grouped by their corresponding parent node in this selection. If no element matches the specified selector
 * for the current element, the group at the current index will be empty. Selection.selectAll does affect grouping: each selected descendant
 * is grouped by the parent element in the originating selection.
 * 
 * The selected elements do not inherit data from this selection; use selection.data to propagate data to children.
 * 
 * The first generic "DescElement" refers to the type of descendant element to be selected. The second generic "OldDatum" refers to the type of the
 * datum, of a selected element. This is useful when re-selecting elements with a previously set, know datum type.
 * 
 * For each selected element, selects the descendant elements returned by the selector function. The elements in the returned
 * selection are grouped by their corresponding parent node in this selection. If no element matches the specified selector
 * for the current element, the group at the current index will be empty. Selection.selectAll does affect grouping: each selected descendant
 * is grouped by the parent element in the originating selection.
 * 
 * The selected elements do not inherit data from this selection; use selection.data to propagate data to children.
 * 
 * The first generic "DescElement" refers to the type of descendant element to be selected. The second generic "OldDatum" refers to the type of the
 * datum, of a selected element. This is useful when re-selecting elements with a previously set, know datum type.
 * 
 * @template DescElement, OldDatum
 * @param {null|undefined|string|?=} selector CSS selector string / A selector function which is evaluated for each selected element, in order, being passed the current datum (d),
 * the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). It must return an array of elements
 * (or a pseudo-array, such as a NodeList), or the empty array if there are no matching elements.
 * @return {?}
 */
Selection.prototype.selectAll = function(selector) {};

/**
 * Return the current value of the specified attribute for the first (non-null) element in the selection.
 * This is generally useful only if you know that the selection contains exactly one element.
 * 
 * Clear the attribute with the specified name for the selected elements and returns this selection.
 * 
 * Sets the value of the attribute with the specified name for the selected elements and returns this selection.
 * All elements are given the same attribute value.
 * 
 * Sets the value of the attribute with the specified name for the selected elements and returns this selection.
 * The value for the individual selected elements is determined by the value function.
 * 
 * @param {string} name Name of the attribute
 * @param {null|(string|number|boolean)|?=} value null,to clear the attribute / Constant value for the attribute / A value function which is evaluated for each selected element, in order, being passed the current datum (d),
 * the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).  A null value will clear the attribute.
 * @return {string|?}
 */
Selection.prototype.attr = function(name, value) {};

/**
 * Returns true if and only if the first (non-null) selected element has the specified classes.
 * This is generally useful only if you know the selection contains exactly one element.
 * 
 * Assigns or unassigns the specified CSS class names on the selected elements by setting
 * the class attribute or modifying the classList property and returns this selection.
 * If the constant value is truthy, then all elements are assigned the specified classes; otherwise, the classes are unassigned.
 * 
 * Assigns or unassigns the specified CSS class names on the selected elements by setting
 * the class attribute or modifying the classList property and returns this selection.
 * The assign/unassign status for the individual selected elements is determined by the boolean return
 * value of the value function.
 * 
 * @param {string} names A string of space-separated class names.
 * @param {boolean|?=} value A boolean flag (true = assign / false = unassign) / A value function which is evaluated for each selected element, in order,
 * being passed the current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).
 * The function’s return value is then used to assign or unassign classes on each element.
 * @return {boolean|?}
 */
Selection.prototype.classed = function(names, value) {};

/**
 * Returns the current value of the specified style property for the first (non-null) element in the selection.
 * The current value is defined as the element’s inline value, if present, and otherwise its computed value.
 * Accessing the current style value is generally useful only if you know the selection contains exactly one element.
 * 
 * Clear the style with the specified name for the selected elements and returns this selection.
 * 
 * Sets the value of the style with the specified name for the selected elements and returns this selection.
 * All elements are given the same style value.
 * 
 * Sets the value of the style with the specified name for the selected elements and returns this selection.
 * The value for the individual selected elements is determined by the value function.
 * 
 * @param {string} name Name of the style
 * @param {null|(string|number|boolean)|?=} value null,to clear the style / Constant value for the style / A value function which is evaluated for each selected element, in order, being passed the current datum (d),
 * the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).  A null value will clear the style.
 * @param {string=} priority An optional priority flag, either null or the string important (without the exclamation point)
 * @return {string|?}
 */
Selection.prototype.style = function(name, value, priority) {};

/**
 * Return the current value of the specified property for the first (non-null) element in the selection.
 * This is generally useful only if you know that the selection contains exactly one element.
 * 
 * Look up a local variable on the first node of this selection. Note that this is not equivalent to `local.get(selection.node())` in that it will not look up locals set on the parent node(s).
 * 
 * Sets the value of the property with the specified name for the selected elements and returns this selection.
 * The value for the individual selected elements is determined by the value function.
 * 
 * Some HTML elements have special properties that are not addressable using attributes or styles,
 * such as a form field’s text value and a checkbox’s checked boolean. Use this method to get or set these properties.
 * 
 * Clears the property with the specified name for the selected elements and returns this selection.
 * 
 * Sets the value of the property with the specified name for the selected elements and returns this selection.
 * All elements are given the same property value.
 * 
 * Store a value in a `d3.local` variable.
 * This is equivalent to `selection.each(function (d, i, g) { name.set(this, value.call(this, d, i, g)); })` but more concise.
 * 
 * Store a value in a `d3.local` variable for each node in the selection.
 * This is equivalent to `selection.each(function () { name.set(this, value); })` but more concise.
 * 
 * @template T
 * @param {string|?} name Name of the property / The `d3.local` variable to look up. / A `d3.local` variable
 * @param {?|null=} value A value function which is evaluated for each selected element, in order, being passed the current datum (d),
 * the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).  A null value will clear the property. / null,to clear the property / Constant value for the property / A callback that returns the value to store
 * @return {?}
 */
Selection.prototype.property = function(name, value) {};

/**
 * Returns the text content for the first (non-null) element in the selection.
 * This is generally useful only if you know the selection contains exactly one element.
 * Clear the text content of the selected elements and return the selection.
 * Sets the text content to the specified value on all selected elements, replacing any existing child elements.
 * All elements are given the same text content.
 * 
 * Sets the text content to the specified value on all selected elements, replacing any existing child elements.
 * All elements are given the same text content.
 * 
 * @param {null|(string|number|boolean)|?=} value Text content value for the elements. / A value unction which is evaluated for each selected element, in order, being passed the current datum (d),
 * the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).
 * The function’s return value is then used to set each element’s text content. A null value will clear the content.
 * @return {string|?}
 */
Selection.prototype.text = function(value) {};

/**
 * Returns a string representation of the inner HTML for the first (non-null) element in the selection.
 * This is generally useful only if you know the selection contains exactly one element.
 * Clear the html content of the selected elements and return the selection.
 * Sets the inner HTML to the specified value on all selected elements, replacing any existing child elements.
 * All elements are given the same inner HTML
 * 
 * Sets the inner HTML to the specified value on all selected elements, replacing any existing child elements.
 * The inner HTML is determined for each individual element using a value function.
 * 
 * @param {null|string|?=} value String representation of inner HTML. / A value function which is evaluated for each selected element, in order, being passed the current
 * datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).
 * The function’s return value is then used to set each element’s inner HTML. A null value will clear the content.
 * @return {string|?}
 */
Selection.prototype.html = function(value) {};

/**
 * Appends a new element of this type (tag name) as the last child of each selected element,
 * or before the next following sibling in the update selection if this is an enter selection.
 * The latter behavior for enter selections allows you to insert elements into the DOM in an order consistent with the new bound data;
 * however, note that selection.order may still be required if updating elements change order
 * (i.e., if the order of new data is inconsistent with old data).
 * 
 * This method returns a new selection containing the appended elements.
 * Each new element inherits the data of the current elements, if any.
 * 
 * The generic refers to the type of the child element to be appended.
 * 
 * Appends a new element of the type provided by the element creator functionas the last child of each selected element,
 * or before the next following sibling in the update selection if this is an enter selection.
 * The latter behavior for enter selections allows you to insert elements into the DOM in an order consistent with the new bound data;
 * however, note that selection.order may still be required if updating elements change order
 * (i.e., if the order of new data is inconsistent with old data).
 * 
 * This method returns a new selection containing the appended elements.
 * Each new element inherits the data of the current elements, if any.
 * 
 * The generic refers to the type of the child element to be appended.
 * 
 * @template ChildElement
 * @param {string|?} type A string representing the tag name. The specified name may have a namespace prefix, such as svg:text
 * to specify a text attribute in the SVG namespace. If no namespace is specified, the namespace will be inherited
 * from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used
 * (for example, svg implies svg:svg) / A creator function which is evaluated for each selected element, in order, being passed the current datum (d),
 * the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return
 * an element to be appended. (The function typically creates a new element, but it may instead return an existing element.)
 * @return {?}
 */
Selection.prototype.append = function(type) {};

/**
 * Inserts a new element of the specified type (tag name) before the first element matching the specified
 * before selector for each selected element. For example, a before selector :first-child will prepend nodes before the first child.
 * If before is not specified, it defaults to null. (To append elements in an order consistent with bound data, use selection.append.)
 * 
 * This method returns a new selection containing the appended elements.
 * Each new element inherits the data of the current elements, if any.
 * 
 * The generic refers to the type of the child element to be appended.
 * 
 * @template ChildElement
 * @param {(string|?)} type One of:
 *   * A string representing the tag name for the element type to be inserted. The specified name may have a namespace prefix,
 *     such as svg:text to specify a text attribute in the SVG namespace. If no namespace is specified, the namespace will be inherited
 *     from the parent element; or, if the name is one of the known prefixes, the corresponding namespace will be used
 *     (for example, svg implies svg:svg)
 *   * A creator function which is evaluated for each selected element, in order, being passed the current datum (d),
 *     the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return
 *     an element to be inserted. (The function typically creates a new element, but it may instead return an existing element.)
 * @param {(string|?)=} before One of:
 *   * A CSS selector string for the element before which the insertion should occur.
 *   * A child selector function which is evaluated for each selected element, in order, being passed the current datum (d),
 *     the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return the child element
 *     before which the element should be inserted.
 * @return {?}
 */
Selection.prototype.insert = function(type, before) {};

/**
 * Removes the selected elements from the document.
 * Returns this selection (the removed elements) which are now detached from the DOM.
 * @return {?}
 */
Selection.prototype.remove = function() {};

/**
 * Returns a new selection merging this selection with the specified other selection.
 * The returned selection has the same number of groups and the same parents as this selection.
 * Any missing (null) elements in this selection are filled with the corresponding element,
 * if present (not null), from the specified selection. (If the other selection has additional groups or parents,
 * they are ignored.)
 * 
 * This method is commonly used to merge the enter and update selections after a data-join.
 * After modifying the entering and updating elements separately, you can merge the two selections and
 * perform operations on both without duplicate code.
 * 
 * This method is not intended for concatenating arbitrary selections, however: if both this selection
 * and the specified other selection have (non-null) elements at the same index, this selection’s element
 * is returned in the merge and the other selection’s element is ignored.
 * 
 * @param {?} other Selection to be merged.
 * @return {?}
 */
Selection.prototype.merge = function(other) {};

/**
 * Filters the selection, returning a new selection that contains only the elements for
 * which the specified filter is true.
 * 
 * The returned filtered selection preserves the parents of this selection, but like array.filter,
 * it does not preserve indexes as some elements may be removed; use selection.select to preserve the index, if needed.
 * 
 * Filters the selection, returning a new selection that contains only the elements for
 * which the specified filter is true.
 * 
 * The returned filtered selection preserves the parents of this selection, but like array.filter,
 * it does not preserve indexes as some elements may be removed; use selection.select to preserve the index, if needed.
 * 
 * The generic refers to the type of element which will be selected after applying the filter, i.e. if the element types
 * contained in a pre-filter selection are narrowed to a subset as part of the filtering.
 * 
 * Filter the selection, returning a new selection that contains only the elements for
 * which the specified filter is true.
 * 
 * The returned filtered selection preserves the parents of this selection, but like array.filter,
 * it does not preserve indexes as some elements may be removed; use selection.select to preserve the index, if needed.
 * 
 * Filter the selection, returning a new selection that contains only the elements for
 * which the specified filter is true.
 * 
 * The returned filtered selection preserves the parents of this selection, but like array.filter,
 * it does not preserve indexes as some elements may be removed; use selection.select to preserve the index, if needed.
 * 
 * @template FilteredElement
 * @param {string|?} selector A CSS selector string to match when filtering. /  A value function which is evaluated for each selected element, in order, being passed the current datum (d),
 * the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]). This function should return true
 * for an element to be included, and false otherwise.
 * @return {?}
 */
Selection.prototype.filter = function(selector) {};

/**
 * Return a new selection that contains a copy of each group in this selection sorted according
 * to the compare function. After sorting, re-inserts elements to match the resulting order (per selection.order).
 * 
 * Note that sorting is not guaranteed to be stable; however, it is guaranteed to have the same
 * behavior as your browser’s built-in sort method on arrays.
 * 
 * @param {?=} comparator An optional comparator function, which defaults to "ascending". The function is passed
 * two elements’ data a and b to compare. It should return either a negative, positive, or zero value.
 * If negative, then a should be before b; if positive, then a should be after b; otherwise, a and b are
 * considered equal and the order is arbitrary.
 * @return {?}
 */
Selection.prototype.sort = function(comparator) {};

/**
 * Re-insert elements into the document such that the document order of each group matches the selection order.
 * This is equivalent to calling selection.sort if the data is already sorted, but much faster.
 * @return {?}
 */
Selection.prototype.order = function() {};

/**
 * Re-insert each selected element, in order, as the last child of its parent.
 * @return {?}
 */
Selection.prototype.raise = function() {};

/**
 * Re-insert each selected element, in order, as the first child of its parent.
 * @return {?}
 */
Selection.prototype.lower = function() {};

/**
 * Returns the bound datum for the first (non-null) element in the selection.
 * This is generally useful only if you know the selection contains exactly one element.
 * Delete the bound data for each element in the selection.
 * Sets the element’s bound data using the specified value function on all selected elements.
 * Unlike selection.data, this method does not compute a join and does not affect
 * indexes or the enter and exit selections.
 * 
 * The generic refers to the type of the new datum to be used for the selected elements.
 * 
 * Sets the element’s bound data to the specified value on all selected elements.
 * Unlike selection.data, this method does not compute a join and does not affect
 * indexes or the enter and exit selections.
 * 
 * The generic refers to the type of the new datum to be used for the selected elements.
 * 
 * @template NewDatum
 * @param {null|?=} value A value function which is evaluated for each selected element, in order,
 * being passed the current datum (d), the current index (i), and the current group (nodes),
 * with this as the current DOM element (nodes[i]). The function is then used to set each element’s new data.
 * A null value will delete the bound data. / A value object to be used as the datum for each element.
 * @return {?}
 */
Selection.prototype.datum = function(value) {};

/**
 * Returns the array of data for the selected elements.
 * Joins the specified array of data with the selected elements, returning a new selection that represents
 * the update selection: the elements successfully bound to data. Also defines the enter and exit selections on
 * the returned selection, which can be used to add or remove elements to correspond to the new data.
 * 
 * The data is specified for each group in the selection. If the selection has multiple groups
 * (such as d3.selectAll followed by selection.selectAll), then data should typically be specified as a function.
 * 
 * If a key function is not specified, then the first datum in data is assigned to the first selected element,
 * the second datum to the second selected element, and so on.
 * A key function may be specified to control which datum is assigned to which element, replacing the default join-by-index.
 * 
 * The update and enter selections are returned in data order, while the exit selection preserves the selection
 * order prior to the join. If a key function is specified, the order of elements in the selection may not match
 * their order in the document; use selection.order or selection.sort as needed.
 * 
 * This method cannot be used to clear bound data; use selection.datum instead.
 * 
 * For details see: {\@link https://github.com/d3/d3-selection#joining-data }
 * 
 * The generic refers to the type of the new datum to be used for the selected elements.
 * 
 * Joins the data returned by the specified value function with the selected elements, returning a new selection that it represents
 * the update selection: the elements successfully bound to data. Also defines the enter and exit selections on
 * the returned selection, which can be used to add or remove elements to correspond to the new data.
 * 
 * The data is specified for each group in the selection.
 * 
 * If a key function is not specified, then the first datum in data is assigned to the first selected element,
 * the second datum to the second selected element, and so on.
 * A key function may be specified to control which datum is assigned to which element, replacing the default join-by-index.
 * 
 * The update and enter selections are returned in data order, while the exit selection preserves the selection
 * order prior to the join. If a key function is specified, the order of elements in the selection may not match
 * their order in the document; use selection.order or selection.sort as needed.
 * 
 * This method cannot be used to clear bound data; use selection.datum instead.
 * 
 * For details see: {\@link https://github.com/d3/d3-selection#joining-data }
 * 
 * The generic refers to the type of the new datum to be used for the selected elements.
 * 
 * @template NewDatum
 * @param {!Array<?>|?=} data The specified data is an array of arbitrary values (e.g., numbers or objects). / A value function which will be evaluated for each group in order, being passed the group’s parent datum
 * (d, which may be undefined), the group index (i), and the selection’s parent nodes (nodes),
 * with this as the group’s parent element. The function returns an array of values for each group.
 * @param {?=} key An optional key function which is evaluated for each selected element, in order, being passed the
 * current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).
 * The key function is then also evaluated for each new datum in data, being passed the current datum (d),
 * the current index (i), and the group’s new data, with this as the group’s parent DOM element (nodes[i]).
 * The datum for a given key is assigned to the element with the matching key. If multiple elements have the same key,
 * the duplicate elements are put into the exit selection; if multiple data have the same key, the duplicate data are put into the enter selection. / An optional key function which is evaluated for each selected element, in order, being passed the
 * current datum (d), the current index (i), and the current group (nodes), with this as the current DOM element (nodes[i]).
 * The key function is then also evaluated for each new datum in data, being passed the current datum (d),
 * the current index (i), and the group’s new data, with this as the group’s parent DOM element.
 * The datum for a given key is assigned to the element with the matching key. If multiple elements have the same key,
 * the duplicate elements are put into the exit selection; if multiple data have the same key, the duplicate data are put into the enter selection.
 * @return {!Array<?>|?}
 */
Selection.prototype.data = function(data, key) {};

/**
 * Return the enter selection: placeholder nodes for each datum that had no corresponding DOM element
 * in the selection. The enter selection is determined by selection.data, and is empty on a selection that
 * is not joined to data.
 * @return {?}
 */
Selection.prototype.enter = function() {};

/**
 * Return the exit selection: existing DOM elements in the selection for which no new datum was found.
 * The exit selection is determined by the previous selection.data, and is thus empty until the selection is
 * joined to data. If the exit selection is retrieved more than once after a data join, subsequent calls return
 * the empty selection.
 * 
 * IMPORTANT: The generic refers to the type of the old datum associated with the exit selection elements.
 * Ensure you set the generic to the correct type, if you need to access the data on the exit selection in
 * follow-up steps, e.g. to set styles as part of an exit transition before removing them.
 * @template OldDatum
 * @return {?}
 */
Selection.prototype.exit = function() {};

/**
 * Return the currently-assigned listener for the specified event typename on the first (non-null) selected element,
 * if any, If multiple typenames are specified, the first matching listener is returned.
 * 
 * Remove a listener for the specified event type names. To remove all listeners for a given name,
 * pass null as the listener and ".foo" as the typename, where foo is the name; to remove all listeners with no name, specify "." as the typename.
 * 
 * Add an event listener for the specified event type names. If an event listener was previously registered for the same typename
 * on a selected element, the old listener is removed before the new listener is added.
 * 
 * When a specified event is dispatched on a selected node, the specified listener will be evaluated for each selected element.
 * 
 * An optional capture flag may be specified which corresponds to the W3C useCapture flag:
 * “After initiating capture, all events of the specified type will be dispatched to the registered EventListener before being
 * dispatched to any EventTargets beneath them in the tree. Events which are bubbling upward through the tree will not
 * trigger an EventListener designated to use capture.”
 * 
 * @param {string} typenames The typenames is a string event type, such as click, mouseover, or submit; any DOM event type supported by your browser may be used.
 * The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered
 * to receive events of the same type, such as click.foo and click.bar. To specify multiple typenames, separate typenames with spaces,
 * such as "input change"" or "click.foo click.bar".
 * @param {null|?=} listener null to indicate removal of listener / A listener function which will be evaluated for each selected element, being passed the current datum (d), the current index (i),
 * and the current group (nodes), with this as the current DOM element (nodes[i]). Listeners always see the latest datum for their element,
 * but the index is a property of the selection and is fixed when the listener is assigned; to update the index, re-assign the listener.
 * To access the current event within a listener, use d3.event.
 * @param {boolean=} capture An optional capture flag which corresponds to the W3C useCapture flag.
 * @return {?}
 */
Selection.prototype.on = function(typenames, listener, capture) {};

/**
 * Dispatches a custom event of the specified type to each selected element, in order.
 * An optional parameters map may be specified to set additional properties of the event.
 * 
 * Dispatches a custom event of the specified type to each selected element, in order.
 * An optional value function returning a parameters map for each element in the selection may be specified to set additional properties of the event.
 * 
 * @param {string} type Name of event to dispatch
 * @param {?=} parameters An optional value map with custom event parameters / A value function which is evaluated for each selected element, in order,
 * being passed the current datum (d), the current index (i), and the current group (nodes),
 * with this as the current DOM element (nodes[i]). It must return the parameters map for the current element.
 * @return {?}
 */
Selection.prototype.dispatch = function(type, parameters) {};

/**
 * Invoke the specified function for each selected element, passing in the current datum (d),
 * the current index (i), and the current group (nodes), with this of the current DOM element (nodes[i]).
 * This method can be used to invoke arbitrary code for each selected element, and is useful for creating a context to access parent and child data simultaneously.
 * 
 * @param {?} func A function which is invoked for each selected element,
 *             being passed the current datum (d), the current index (i), and the current group (nodes), with this of the current DOM element (nodes[i]).
 * @return {?}
 */
Selection.prototype.each = function(func) {};

/**
 * Invoke the specified function exactly once, passing in this selection along with any optional arguments.
 * Returns this selection.
 * 
 * @param {?} func A function which is passed this selection as the first argument along with any optional arguments.
 * @param {...?} args List of optional arguments to be passed to the callback function.
 * @return {?}
 */
Selection.prototype.call = function(func, args) {};

/**
 * Return true if this selection contains no (non-null) elements.
 * @return {boolean}
 */
Selection.prototype.empty = function() {};

/**
 * Return the first (non-null) element in this selection. If the selection is empty, returns null.
 * @return {?}
 */
Selection.prototype.node = function() {};

/**
 * Return an array of all (non-null) elements in this selection.
 * @return {!Array<?>}
 */
Selection.prototype.nodes = function() {};

/**
 * Returns the total number of elements in this selection.
 * @return {number}
 */
Selection.prototype.size = function() {};

/** @typedef {?} */
var SelectionFn;
 /** @type {?} */
var selection;
/**
 * @record
 * @struct
 */
function BaseEvent() {}
 /** @type {string} */
BaseEvent.prototype.type;
 /** @type {?} */
BaseEvent.prototype.sourceEvent;
 /** @type {?} */
var event;

/**
 * Invokes the specified listener, using the specified "that" as "this" context and passing the specified arguments, if any.
 * During the invocation, d3.event is set to the specified event; after the listener returns (or throws an error),
 * d3.event is restored to its previous value.
 * In addition, sets event.sourceEvent to the prior value of d3.event, allowing custom events to retain a reference to the originating native event.
 * Returns the value returned by the listener.
 * 
 * The first generic "Context" refers to the "this" context type in which the listener will be invoked.
 * The second generic "Result" specifies the return type of the listener.
 * 
 * @template Context, Result
 * @param {?} event The event to which d3.event will be set during the listener invocation.
 * @param {?} listener The event listener function to be invoked. This function will be invoked with the "this" context, provided
 * by the "that" argument of customEvent(...). It will be passed all optional arguments passed to customEvent(...). The function returns
 * a value corresponding to the type of the second generic type.
 * @param {?} that The "this"" context which will be used for the invocation of listener.
 * @param {...?} args A list of optional arguments, which will be passed to listener.
 * @return {?}
 */
function customEvent(event, listener, that, args) {}

/**
 * Get (x, y)-coordinates of the current event relative to the specified container element.
 * The container may be an HTML or SVG container element, such as a G element or an SVG element.
 * The coordinates are returned as a two-element array of numbers [x, y].
 * 
 * @param {(!HTMLElement|!SVGSVGElement|!SVGGElement)} container Container element relative to which coordinates are calculated.
 * @return {!Array<?>}
 */
function mouse(container) {}

/**
 * Returns the x and y coordinates of the touch with the specified identifier associated
 * with the current event relative to the specified container.
 * The container may be an HTML or SVG container element, such as a G element or an SVG element.
 * The coordinates are returned as a two-element array of numbers [x, y] or null if there is no touch with
 * the specified identifier in touches, returns null; this can be useful for ignoring touchmove events
 * where the only some touches have moved.
 * 
 * If touches is not specified, it defaults to the current event’s changedTouches property.
 * 
 * Return the x and y coordinates of the touch with the specified identifier associated
 * with the current event relative to the specified container.
 * The container may be an HTML or SVG container element, such as a G element or an SVG element.
 * The coordinates are returned as a two-element array of numbers [x, y] or null if there is no touch with
 * the specified identifier in touches, returns null; this can be useful for ignoring touchmove events
 * where the only some touches have moved.
 * 
 * If touches is not specified, it defaults to the current event’s changedTouches property.
 * 
 * @param {(!HTMLElement|!SVGSVGElement|!SVGGElement)} container Container element relative to which coordinates are calculated.
 * @param {number|!TouchList} identifier_or_touches Touch Identifier associated with the current event. / TouchList to be used when identifying the touch.
 * @param {number=} identifier Touch Identifier associated with the current event.
 * @return {!Array<?>}
 */
function touch(container, identifier_or_touches, identifier) {}

/**
 * Return the x and y coordinates of the touches associated with the current event relative to the specified container.
 * The container may be an HTML or SVG container element, such as a G element or an SVG element.
 * The coordinates are returned as an array of two-element arrays of numbers [[x1, y1], [x2, y2], …].
 * 
 * If touches is not specified, it defaults to the current event’s touches property.
 * 
 * @param {(!HTMLElement|!SVGSVGElement|!SVGGElement)} container Container element relative to which coordinates are calculated.
 * @param {!TouchList=} touches TouchList to be used.
 * @return {!Array<!Array<?>>}
 */
function touches(container, touches) {}

/**
 * Returns the value of the style property with the specified name for the specified node.
 * If the node has an inline style with the specified name, its value is returned; otherwise, the computed property value is returned.
 * See also selection.style.
 * 
 * @param {!Element} node A DOM node (e.g. HTMLElement, SVGElement) for which to retrieve the style property.
 * @param {string} name Style property name.
 * @return {string}
 */
function style(node, name) {}
/**
 * @record
 * @struct
 */
function Local() {}

/**
 * Retrieves a local variable stored on the node (or one of its parents).
 * 
 * @param {!Element} node A node element.
 * @return {?}
 */
Local.prototype.get = function(node) {};

/**
 * Deletes the value associated with the given node. Values stored on ancestors are not affected, meaning that child nodes will still see inherited values.
 * 
 * This function returns true if there was a value stored directly on the node, and false otherwise.
 * 
 * @param {!Element} node A node element.
 * @return {boolean}
 */
Local.prototype.remove = function(node) {};

/**
 * Store a value for this local variable. Calling `.get()` on children of this node will also retrieve the variable's value.
 * 
 * @param {!Element} node A node element.
 * @param {?} value Value to store locally
 * @return {!Element}
 */
Local.prototype.set = function(node, value) {};

/**
 * Obtain a string with the internally assigned property name for the local
 * which is used to store the value on a node
 * @return {string}
 */
Local.prototype.toString = function() {};

/**
 * Obtain a new local variable
 * 
 * The generic refers to the type of the variable to store locally.
 * @template T
 * @return {?}
 */
function local() {}
/**
 * @record
 * @struct
 */
function NamespaceLocalObject() {}
 /** @type {string} */
NamespaceLocalObject.prototype.space;
 /** @type {string} */
NamespaceLocalObject.prototype.local;

/**
 * Obtain an object with properties of fully qualified namespace string and
 * name of local by parsing a shorthand string "prefix:local". If the prefix
 * does not exist in the "namespaces" object provided by d3-selection, then
 * the local name is returned as a simple string.
 * 
 * @param {string} prefixedLocal A string composed of the namespace prefix and local
 * name separated by colon, e.g. "svg:text".
 * @return {(string|?)}
 */
function namespace(prefixedLocal) {}
/**
 * @record
 * @struct
 */
function NamespaceMap() {}

/* TODO: IndexSignature:  */
 /** @type {?} */
var namespaces;

/**
 * Returns the owner window for the specified node. If node is a node, returns the owner document’s default view;
 * if node is a document, returns its default view; otherwise returns the node.
 * 
 * @param {(!Element|!Document|!Window)} DOMNode A DOM element
 * @return {!Window}
 */
function window(DOMNode) {}

/**
 * Given the specified element name, returns a function which creates an element of the given name,
 * assuming that "this" is the parent element.
 * 
 * The generic refers to the type of the new element to be returned by the creator function.
 * 
 * @template NewGElement
 * @param {string} name Tag name of the element to be added. See "namespace" for details on supported namespace prefixes,
 * such as for SVG elements.
 * @return {?}
 */
function creator(name) {}

/**
 * Given the specified selector, returns a function which returns true if "this" element matches the specified selector.
 * 
 * @param {string} selector A CSS selector string.
 * @return {?}
 */
function matcher(selector) {}

/**
 * Given the specified selector, returns a function which returns the first descendant of "this" element
 * that matches the specified selector.
 * 
 * The generic refers to the type of the returned descendant element.
 * 
 * @template DescElement
 * @param {string} selector A CSS selector string.
 * @return {?}
 */
function selector(selector) {}

/**
 * Given the specified selector, returns a function which returns all descendants of "this" element that match the specified selector.
 * 
 * The generic refers to the type of the returned descendant element.
 * 
 * @template DescElement
 * @param {string} selector A CSS selector string.
 * @return {?}
 */
function selectorAll(selector) {}
