/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/angular/index.d.ts:
 /** @type {!angular.IAngularStatic} */
var angular;
 /** @type {!ReadonlyArray<string>} */
Function.prototype.$inject;

/* TODO: NamespaceExportDeclaration in  */

/* TODO: NamespaceExportDeclaration in  */

/* TODO: ExportAssignment in  */

/* TODO: ImportEqualsDeclaration in  */

/** @typedef {(T|!Array<(string|T)>)} */
angular.Injectable;
/**
 * @record
 * @struct
 */
angular.IServiceProviderClass = function() {};

/* TODO: ConstructSignature: angular */
/**
 * @record
 * @struct
 */
angular.IServiceProviderFactory = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IServiceProvider = function() {};
 /** @type {?} */
angular.IServiceProvider.prototype.$get;
/**
 * @record
 * @struct
 */
angular.IAngularBootstrapConfig = function() {};
 /** @type {boolean} */
angular.IAngularBootstrapConfig.prototype.strictDi;
/**
 * @record
 * @struct
 */
angular.IAngularStatic = function() {};
 /** @type {!JQueryStatic} */
angular.IAngularStatic.prototype.element;
 /** @type {{full: string, major: number, minor: number, dot: number, codeName: string}} */
angular.IAngularStatic.prototype.version;

/**
 * @param {?} context
 * @param {!Function} fn
 * @param {...?} args
 * @return {!Function}
 */
angular.IAngularStatic.prototype.bind = function(context, fn, args) {};

/**
 * Use this function to manually start up angular application.
 * 
 * @param {(string|!Element|!JQuery|!Document)} element DOM element which is the root of angular application.
 * @param {!Array<(string|!Function|!Array<?>)>=} modules An array of modules to load into the application.
 *     Each item in the array should be the name of a predefined module or a (DI annotated)
 *     function that will be invoked by the injector as a config block.
 * @param {!angular.IAngularBootstrapConfig=} config an object for defining configuration options for the application. The following keys are supported:
 *     - `strictDi`: disable automatic function annotation for the application. This is meant to assist in finding bugs which break minified code.
 * @return {!angular.auto.IInjectorService}
 */
angular.IAngularStatic.prototype.bootstrap = function(element, modules, config) {};

/**
 * Creates a deep copy of source, which should be an object or an array.
 * 
 * - If no destination is supplied, a copy of the object or array is created.
 * - If a destination is provided, all of its elements (for array) or properties (for objects) are deleted and then all elements/properties from the source are copied to it.
 * - If source is not an object or array (inc. null and undefined), source is returned.
 * - If source is identical to 'destination' an exception will be thrown.
 * 
 * @template T
 * @param {T} source The source that will be used to make a copy. Can be any type, including primitives, null, and undefined.
 * @param {T=} destination Destination into which the source is copied. If provided, must be of the same type as source.
 * @return {T}
 */
angular.IAngularStatic.prototype.copy = function(source, destination) {};

/**
 * @param {?} value1
 * @param {?} value2
 * @return {boolean}
 */
angular.IAngularStatic.prototype.equals = function(value1, value2) {};

/**
 * @param {?} destination
 * @param {...?} sources
 * @return {?}
 */
angular.IAngularStatic.prototype.extend = function(destination, sources) {};

/**
 * Invokes the iterator function once for each item in obj collection, which can be either an object or an array. The iterator function is invoked with iterator(value, key), where value is the value of an object property or an array element and key is the object property key or array element index. Specifying a context for the function is optional.
 * 
 * It is worth noting that .forEach does not iterate over inherited properties because it filters using the hasOwnProperty method.
 * 
 * Invokes the iterator function once for each item in obj collection, which can be either an object or an array. The iterator function is invoked with iterator(value, key), where value is the value of an object property or an array element and key is the object property key or array element index. Specifying a context for the function is optional.
 * 
 * It is worth noting that .forEach does not iterate over inherited properties because it filters using the hasOwnProperty method.
 * 
 * Invokes the iterator function once for each item in obj collection, which can be either an object or an array. The iterator function is invoked with iterator(value, key), where value is the value of an object property or an array element and key is the object property key or array element index. Specifying a context for the function is optional.
 * 
 * It is worth noting that .forEach does not iterate over inherited properties because it filters using the hasOwnProperty method.
 * 
 * @template T
 * @param {!Array<T>|!Object<string,T>|?} obj Object to iterate over.
 * @param {function(T, number, !Array<T>): void|function(T, string, !Object<string,T>): void|function(?, ?, ?): void} iterator Iterator function.
 * @param {?=} context Object to become context (this) for the iterator function.
 * @return {!Array<T>|!Object<string,T>|?}
 */
angular.IAngularStatic.prototype.forEach = function(obj, iterator, context) {};

/**
 * @param {string} json
 * @return {?}
 */
angular.IAngularStatic.prototype.fromJson = function(json) {};

/**
 * @template T
 * @param {T=} arg
 * @return {T}
 */
angular.IAngularStatic.prototype.identity = function(arg) {};

/**
 * @param {!Array<?>=} modules
 * @param {boolean=} strictDi
 * @return {!angular.auto.IInjectorService}
 */
angular.IAngularStatic.prototype.injector = function(modules, strictDi) {};

/**
 * @param {?} value
 * @return {boolean}
 */
angular.IAngularStatic.prototype.isArray = function(value) {};

/**
 * @param {?} value
 * @return {boolean}
 */
angular.IAngularStatic.prototype.isDate = function(value) {};

/**
 * @param {?} value
 * @return {boolean}
 */
angular.IAngularStatic.prototype.isDefined = function(value) {};

/**
 * @param {?} value
 * @return {boolean}
 */
angular.IAngularStatic.prototype.isElement = function(value) {};

/**
 * @param {?} value
 * @return {boolean}
 */
angular.IAngularStatic.prototype.isFunction = function(value) {};

/**
 * @param {?} value
 * @return {boolean}
 */
angular.IAngularStatic.prototype.isNumber = function(value) {};

/**
 * @template T
 * @param {?} value
 * @return {boolean}
 */
angular.IAngularStatic.prototype.isObject = function(value) {};

/**
 * @param {?} value
 * @return {boolean}
 */
angular.IAngularStatic.prototype.isString = function(value) {};

/**
 * @param {?} value
 * @return {boolean}
 */
angular.IAngularStatic.prototype.isUndefined = function(value) {};

/**
 * @param {string} str
 * @return {string}
 */
angular.IAngularStatic.prototype.lowercase = function(str) {};

/**
 * Deeply extends the destination object dst by copying own enumerable properties from the src object(s) to dst. You can specify multiple src objects. If you want to preserve original objects, you can do so by passing an empty object as the target: var object = angular.merge({}, object1, object2).
 * 
 * Unlike extend(), merge() recursively descends into object properties of source objects, performing a deep copy.
 * 
 * @param {?} dst Destination object.
 * @param {...?} src Source object(s).
 * @return {?}
 */
angular.IAngularStatic.prototype.merge = function(dst, src) {};

/**
 * The angular.module is a global place for creating, registering and retrieving Angular modules. All modules (angular core or 3rd party) that should be available to an application must be registered using this mechanism.
 * 
 * When passed two or more arguments, a new module is created. If passed only one argument, an existing module (the name passed as the first argument to module) is retrieved.
 * 
 * @param {string} name The name of the module to create or retrieve.
 * @param {!Array<string>=} requires The names of modules this module depends on. If specified then new module is being created. If unspecified then the module is being retrieved for further configuration.
 * @param {!Function=} configFn Optional configuration function for the module.
 * @return {!angular.IModule}
 */
angular.IAngularStatic.prototype.module = function(name, requires, configFn) {};

/**
 * @param {...?} args
 * @return {void}
 */
angular.IAngularStatic.prototype.noop = function(args) {};

/**
 * @return {void}
 */
angular.IAngularStatic.prototype.reloadWithDebugInfo = function() {};

/**
 * @param {?} obj
 * @param {(number|boolean)=} pretty
 * @return {string}
 */
angular.IAngularStatic.prototype.toJson = function(obj, pretty) {};

/**
 * @param {string} str
 * @return {string}
 */
angular.IAngularStatic.prototype.uppercase = function(str) {};

/**
 * If window.name contains prefix NG_DEFER_BOOTSTRAP! when angular.bootstrap is called, the bootstrap process will be paused until angular.resumeBootstrap() is called.
 * @param {!Array<string>=} extraModules An optional array of modules that should be added to the original list of modules that the app was about to be bootstrapped with.
 * @return {!angular.auto.IInjectorService}
 */
angular.IAngularStatic.prototype.resumeBootstrap = function(extraModules) {};
/**
 * @record
 * @struct
 */
angular.IModule = function() {};
 /** @type {string} */
angular.IModule.prototype.name;
 /** @type {!Array<string>} */
angular.IModule.prototype.requires;

/**
 * Use this method to register a component.
 * 
 * @param {string} name The name of the component.
 * @param {!angular.IComponentOptions} options A definition object passed into the component.
 * @return {!angular.IModule}
 */
angular.IModule.prototype.component = function(name, options) {};

/**
 * Use this method to register work which needs to be performed on module loading.
 * 
 * Use this method to register work which needs to be performed on module loading.
 * 
 * @param {!Function|!Array<?>|!Object} configFn_or_inlineAnnotatedFunction_or_object Execute this function on module load. Useful for service configuration.
 * @return {!angular.IModule}
 */
angular.IModule.prototype.config = function(configFn_or_inlineAnnotatedFunction_or_object) {};

/**
 * Register a constant service, such as a string, a number, an array, an object or a function, with the $injector. Unlike value it can be injected into a module configuration function (see config) and it cannot be overridden by an Angular decorator.
 * 
 * @template T
 * @param {string|!Object} name_or_object The name of the constant.
 * @param {T=} value The constant value.
 * @return {!angular.IModule}
 */
angular.IModule.prototype.constant = function(name_or_object, value) {};

/**
 * The $controller service is used by Angular to create new controllers.
 * 
 * This provider allows controller registration via the register method.
 * 
 * @param {string|!Object<string,(function(new: (!angular.IController), !Array<?>): ?|function(!Array<?>): (void|!angular.IController)|!Array<(string|?)>)>} name_or_object Controller name, or an object map of controllers where the keys are the names and the values are the constructors.
 * @param {(function(new: (!angular.IController), !Array<?>): ?|function(!Array<?>): (void|!angular.IController)|!Array<(string|?)>)=} controllerConstructor Controller constructor fn (optionally decorated with DI annotations in the array notation).
 * @return {!angular.IModule}
 */
angular.IModule.prototype.controller = function(name_or_object, controllerConstructor) {};

/**
 * Register a new directive with the compiler.
 * 
 * @param {string|!Object<string,(!angular.IDirectiveFactory|!Array<(string|!angular.IDirectiveFactory)>)>} name_or_object Name of the directive in camel-case (i.e. ngBind which will match as ng-bind)
 * @param {(!angular.IDirectiveFactory|!Array<(string|!angular.IDirectiveFactory)>)=} directiveFactory An injectable directive factory function.
 * @return {!angular.IModule}
 */
angular.IModule.prototype.directive = function(name_or_object, directiveFactory) {};

/**
 * Register a service factory, which will be called to return the service instance. This is short for registering a service where its provider consists of only a $get property, which is the given service factory function. You should use $provide.factory(getFn) if you do not need to configure your service in a provider.
 * 
 * @param {string|!Object<string,(!Function|!Array<(string|!Function)>)>} name_or_object The name of the instance.
 * @param {(!Function|!Array<(string|!Function)>)=} $getFn The $getFn for the instance creation. Internally this is a short hand for $provide.provider(name, {$get: $getFn}).
 * @return {!angular.IModule}
 */
angular.IModule.prototype.factory = function(name_or_object, $getFn) {};

/**
 * @param {string|!Object<string,(!Function|!Array<(string|!Function)>)>} name_or_object
 * @param {(!Function|!Array<(string|!Function)>)=} filterFactoryFunction
 * @return {!angular.IModule}
 */
angular.IModule.prototype.filter = function(name_or_object, filterFactoryFunction) {};

/**
 * @param {string|!Object} name_or_object
 * @param {!angular.IServiceProviderFactory|!angular.IServiceProviderClass|!Array<?>|!angular.IServiceProvider=} serviceProviderFactory_or_serviceProviderConstructor_or_inlineAnnotatedConstructor_or_providerObject
 * @return {!angular.IModule}
 */
angular.IModule.prototype.provider = function(name_or_object, serviceProviderFactory_or_serviceProviderConstructor_or_inlineAnnotatedConstructor_or_providerObject) {};

/**
 * Run blocks are the closest thing in Angular to the main method. A run block is the code which needs to run to kickstart the application. It is executed after all of the service have been configured and the injector has been created. Run blocks typically contain code which is hard to unit-test, and for this reason should be declared in isolated modules, so that they can be ignored in the unit-tests.
 * @param {(!Function|!Array<(string|!Function)>)} initializationFunction
 * @return {!angular.IModule}
 */
angular.IModule.prototype.run = function(initializationFunction) {};

/**
 * Register a service constructor, which will be invoked with new to create the service instance. This is short for registering a service where its provider's $get property is a factory function that returns an instance instantiated by the injector from the service constructor function.
 * 
 * @param {string|!Object<string,(!Function|!Array<(string|!Function)>)>} name_or_object The name of the instance.
 * @param {(!Function|!Array<(string|!Function)>)=} serviceConstructor An injectable class (constructor function) that will be instantiated.
 * @return {!angular.IModule}
 */
angular.IModule.prototype.service = function(name_or_object, serviceConstructor) {};

/**
 * Register a value service with the $injector, such as a string, a number, an array, an object or a function. This is short for registering a service where its provider's $get property is a factory function that takes no arguments and returns the value service.
 * Value services are similar to constant services, except that they cannot be injected into a module configuration function (see config) but they can be overridden by an Angular decorator.
 * 
 * @template T
 * @param {string|!Object} name_or_object The name of the instance.
 * @param {T=} value The value.
 * @return {!angular.IModule}
 */
angular.IModule.prototype.value = function(name_or_object, value) {};

/**
 * Register a service decorator with the $injector. A service decorator intercepts the creation of a service, allowing it to override or modify the behaviour of the service. The object returned by the decorator may be the original service, or a new service object which replaces or wraps and delegates to the original service.
 * @param {string} name The name of the service to decorate
 * @param {(!Function|!Array<(string|!Function)>)} decorator This function will be invoked when the service needs to be instantiated and should return the decorated service instance. The function is called using the injector.invoke method and is therefore fully injectable. Local injection arguments: $delegate - The original service instance, which can be monkey patched, configured, decorated or delegated to.
 * @return {!angular.IModule}
 */
angular.IModule.prototype.decorator = function(name, decorator) {};
/**
 * @record
 * @struct
 */
angular.IAttributes = function() {};

/* TODO: IndexSignature: angular */
 /** @type {!Object} */
angular.IAttributes.prototype.$attr;

/**
 * Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with x- or data-) to its normalized, camelCase form.
 * 
 * Also there is special case for Moz prefix starting with upper case letter.
 * 
 * For further information check out the guide on \@see https://docs.angularjs.org/guide/directive#matching-directives
 * @param {string} name
 * @return {string}
 */
angular.IAttributes.prototype.$normalize = function(name) {};

/**
 * Adds the CSS class value specified by the classVal parameter to the
 * element. If animations are enabled then an animation will be triggered
 * for the class addition.
 * @param {string} classVal
 * @return {void}
 */
angular.IAttributes.prototype.$addClass = function(classVal) {};

/**
 * Removes the CSS class value specified by the classVal parameter from the
 * element. If animations are enabled then an animation will be triggered for
 * the class removal.
 * @param {string} classVal
 * @return {void}
 */
angular.IAttributes.prototype.$removeClass = function(classVal) {};

/**
 * Adds and removes the appropriate CSS class values to the element based on the difference between
 * the new and old CSS class values (specified as newClasses and oldClasses).
 * @param {string} newClasses
 * @param {string} oldClasses
 * @return {void}
 */
angular.IAttributes.prototype.$updateClass = function(newClasses, oldClasses) {};

/**
 * Set DOM element attribute value.
 * @param {string} key
 * @param {?} value
 * @return {void}
 */
angular.IAttributes.prototype.$set = function(key, value) {};

/**
 * Observes an interpolated attribute.
 * The observer function will be invoked once during the next $digest
 * following compilation. The observer is then invoked whenever the
 * interpolated value changes.
 * @template T
 * @param {string} name
 * @param {function(T): ?} fn
 * @return {!Function}
 */
angular.IAttributes.prototype.$observe = function(name, fn) {};
/**
 * @record
 * @struct
 */
angular.IFormController = function() {};

/* TODO: IndexSignature: angular */
 /** @type {boolean} */
angular.IFormController.prototype.$pristine;
 /** @type {boolean} */
angular.IFormController.prototype.$dirty;
 /** @type {boolean} */
angular.IFormController.prototype.$valid;
 /** @type {boolean} */
angular.IFormController.prototype.$invalid;
 /** @type {boolean} */
angular.IFormController.prototype.$submitted;
 /** @type {?} */
angular.IFormController.prototype.$error;
 /** @type {string} */
angular.IFormController.prototype.$name;
 /** @type {?} */
angular.IFormController.prototype.$pending;

/**
 * @param {(!angular.INgModelController|!angular.IFormController)} control
 * @return {void}
 */
angular.IFormController.prototype.$addControl = function(control) {};

/**
 * @param {(!angular.INgModelController|!angular.IFormController)} control
 * @return {void}
 */
angular.IFormController.prototype.$removeControl = function(control) {};

/**
 * @param {string} validationErrorKey
 * @param {boolean} isValid
 * @param {(!angular.INgModelController|!angular.IFormController)} control
 * @return {void}
 */
angular.IFormController.prototype.$setValidity = function(validationErrorKey, isValid, control) {};

/**
 * @return {void}
 */
angular.IFormController.prototype.$setDirty = function() {};

/**
 * @return {void}
 */
angular.IFormController.prototype.$setPristine = function() {};

/**
 * @return {void}
 */
angular.IFormController.prototype.$commitViewValue = function() {};

/**
 * @return {void}
 */
angular.IFormController.prototype.$rollbackViewValue = function() {};

/**
 * @return {void}
 */
angular.IFormController.prototype.$setSubmitted = function() {};

/**
 * @return {void}
 */
angular.IFormController.prototype.$setUntouched = function() {};
/**
 * @record
 * @struct
 */
angular.INgModelController = function() {};
 /** @type {?} */
angular.INgModelController.prototype.$viewValue;
 /** @type {?} */
angular.INgModelController.prototype.$modelValue;
 /** @type {!Array<!angular.IModelParser>} */
angular.INgModelController.prototype.$parsers;
 /** @type {!Array<!angular.IModelFormatter>} */
angular.INgModelController.prototype.$formatters;
 /** @type {!Array<!angular.IModelViewChangeListener>} */
angular.INgModelController.prototype.$viewChangeListeners;
 /** @type {?} */
angular.INgModelController.prototype.$error;
 /** @type {string} */
angular.INgModelController.prototype.$name;
 /** @type {boolean} */
angular.INgModelController.prototype.$touched;
 /** @type {boolean} */
angular.INgModelController.prototype.$untouched;
 /** @type {!angular.IModelValidators} */
angular.INgModelController.prototype.$validators;
 /** @type {!angular.IAsyncModelValidators} */
angular.INgModelController.prototype.$asyncValidators;
 /** @type {?} */
angular.INgModelController.prototype.$pending;
 /** @type {boolean} */
angular.INgModelController.prototype.$pristine;
 /** @type {boolean} */
angular.INgModelController.prototype.$dirty;
 /** @type {boolean} */
angular.INgModelController.prototype.$valid;
 /** @type {boolean} */
angular.INgModelController.prototype.$invalid;

/**
 * @return {void}
 */
angular.INgModelController.prototype.$render = function() {};

/**
 * @param {string} validationErrorKey
 * @param {boolean} isValid
 * @return {void}
 */
angular.INgModelController.prototype.$setValidity = function(validationErrorKey, isValid) {};

/**
 * @param {?} value
 * @param {string=} trigger
 * @return {void}
 */
angular.INgModelController.prototype.$setViewValue = function(value, trigger) {};

/**
 * @return {void}
 */
angular.INgModelController.prototype.$setPristine = function() {};

/**
 * @return {void}
 */
angular.INgModelController.prototype.$setDirty = function() {};

/**
 * @return {void}
 */
angular.INgModelController.prototype.$validate = function() {};

/**
 * @return {void}
 */
angular.INgModelController.prototype.$setTouched = function() {};

/**
 * @return {void}
 */
angular.INgModelController.prototype.$setUntouched = function() {};

/**
 * @return {void}
 */
angular.INgModelController.prototype.$rollbackViewValue = function() {};

/**
 * @return {void}
 */
angular.INgModelController.prototype.$commitViewValue = function() {};

/**
 * @param {?} value
 * @return {boolean}
 */
angular.INgModelController.prototype.$isEmpty = function(value) {};
/**
 * @record
 * @struct
 */
angular.INgModelOptions = function() {};
 /** @type {string} */
angular.INgModelOptions.prototype.updateOn;
 /** @type {(number|!Object<string,number>)} */
angular.INgModelOptions.prototype.debounce;
 /** @type {boolean} */
angular.INgModelOptions.prototype.allowInvalid;
 /** @type {boolean} */
angular.INgModelOptions.prototype.getterSetter;
 /** @type {string} */
angular.INgModelOptions.prototype.timezone;
/**
 * @record
 * @struct
 */
angular.IModelValidators = function() {};

/* TODO: IndexSignature: angular */
/**
 * @record
 * @struct
 */
angular.IAsyncModelValidators = function() {};

/* TODO: IndexSignature: angular */
/**
 * @record
 * @struct
 */
angular.IModelParser = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IModelFormatter = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IModelViewChangeListener = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IRootScopeService = function() {};
 /** @type {!angular.IScope} */
angular.IRootScopeService.prototype.$parent;
 /** @type {!angular.IRootScopeService} */
angular.IRootScopeService.prototype.$root;
 /** @type {number} */
angular.IRootScopeService.prototype.$id;
 /** @type {?} */
angular.IRootScopeService.prototype.$$isolateBindings;
 /** @type {?} */
angular.IRootScopeService.prototype.$$phase;

/**
 * @param {string|function(!angular.IScope): ?=} exp
 * @return {?}
 */
angular.IRootScopeService.prototype.$apply = function(exp) {};

/**
 * @param {string|function(!angular.IScope): ?=} exp
 * @return {?}
 */
angular.IRootScopeService.prototype.$applyAsync = function(exp) {};

/**
 * Dispatches an event name downwards to all child scopes (and their children) notifying the registered $rootScope.Scope listeners.
 * 
 * The event life cycle starts at the scope on which $broadcast was called. All listeners listening for name event on this scope get notified. Afterwards, the event propagates to all direct and indirect scopes of the current scope and calls all registered listeners along the way. The event cannot be canceled.
 * 
 * Any exception emitted from the listeners will be passed onto the $exceptionHandler service.
 * 
 * @param {string} name Event name to broadcast.
 * @param {...?} args Optional one or more arguments which will be passed onto the event listeners.
 * @return {!angular.IAngularEvent}
 */
angular.IRootScopeService.prototype.$broadcast = function(name, args) {};

/**
 * @return {void}
 */
angular.IRootScopeService.prototype.$destroy = function() {};

/**
 * @return {void}
 */
angular.IRootScopeService.prototype.$digest = function() {};

/**
 * Dispatches an event name upwards through the scope hierarchy notifying the registered $rootScope.Scope listeners.
 * 
 * The event life cycle starts at the scope on which $emit was called. All listeners listening for name event on this scope get notified. Afterwards, the event traverses upwards toward the root scope and calls all registered listeners along the way. The event will stop propagating if one of the listeners cancels it.
 * 
 * Any exception emitted from the listeners will be passed onto the $exceptionHandler service.
 * 
 * @param {string} name Event name to emit.
 * @param {...?} args Optional one or more arguments which will be passed onto the event listeners.
 * @return {!angular.IAngularEvent}
 */
angular.IRootScopeService.prototype.$emit = function(name, args) {};

/**
 * @param {string|function(!angular.IScope): ?=} expression
 * @param {!Object=} locals
 * @return {?}
 */
angular.IRootScopeService.prototype.$eval = function(expression, locals) {};

/**
 * @param {string|function(!angular.IScope): void=} expression
 * @param {!Object=} locals
 * @return {void}
 */
angular.IRootScopeService.prototype.$evalAsync = function(expression, locals) {};

/**
 * @param {boolean=} isolate
 * @param {!angular.IScope=} parent
 * @return {!angular.IScope}
 */
angular.IRootScopeService.prototype.$new = function(isolate, parent) {};

/**
 * Listens on events of a given type. See $emit for discussion of event life cycle.
 * 
 * The event listener function format is: function(event, args...).
 * 
 * @param {string} name Event name to listen on.
 * @param {function(!angular.IAngularEvent, !Array<?>): ?} listener Function to call when the event is emitted.
 * @return {function(): void}
 */
angular.IRootScopeService.prototype.$on = function(name, listener) {};

/**
 * @template T
 * @param {string|function(!angular.IScope): ?|function(!angular.IScope): T} watchExpression
 * @param {string|function(T, T, !angular.IScope): ?=} listener
 * @param {boolean=} objectEquality
 * @return {function(): void}
 */
angular.IRootScopeService.prototype.$watch = function(watchExpression, listener, objectEquality) {};

/**
 * @template T
 * @param {string|function(!angular.IScope): T} watchExpression
 * @param {function(T, T, !angular.IScope): ?} listener
 * @return {function(): void}
 */
angular.IRootScopeService.prototype.$watchCollection = function(watchExpression, listener) {};

/**
 * @param {!Array<?>|!Array<function(!angular.IScope): ?>} watchExpressions
 * @param {function(?, ?, !angular.IScope): ?} listener
 * @return {function(): void}
 */
angular.IRootScopeService.prototype.$watchGroup = function(watchExpressions, listener) {};
/**
 * @extends {angular.IRootScopeService}
 * @record
 * @struct
 */
angular.IScope = function() {};
/**
 * @extends {angular.IScope}
 * @record
 * @struct
 */
angular.IRepeatScope = function() {};
 /** @type {number} */
angular.IRepeatScope.prototype.$index;
 /** @type {boolean} */
angular.IRepeatScope.prototype.$first;
 /** @type {boolean} */
angular.IRepeatScope.prototype.$middle;
 /** @type {boolean} */
angular.IRepeatScope.prototype.$last;
 /** @type {boolean} */
angular.IRepeatScope.prototype.$even;
 /** @type {boolean} */
angular.IRepeatScope.prototype.$odd;
/**
 * @record
 * @struct
 */
angular.IAngularEvent = function() {};
 /** @type {!angular.IScope} */
angular.IAngularEvent.prototype.targetScope;
 /** @type {!angular.IScope} */
angular.IAngularEvent.prototype.currentScope;
 /** @type {string} */
angular.IAngularEvent.prototype.name;
 /** @type {boolean} */
angular.IAngularEvent.prototype.defaultPrevented;

/**
 * calling stopPropagation function will cancel further event propagation (available only for events that were $emit-ed).
 * @return {void}
 */
angular.IAngularEvent.prototype.stopPropagation = function() {};

/**
 * calling preventDefault sets defaultPrevented flag to true.
 * @return {void}
 */
angular.IAngularEvent.prototype.preventDefault = function() {};
/**
 * @record
 * @struct
 */
angular.IWindowService = function() {};

/* TODO: IndexSignature: angular */
/**
 * @record
 * @struct
 */
angular.ITimeoutService = function() {};

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/**
 * @param {!angular.IPromise<?>=} promise
 * @return {boolean}
 */
angular.ITimeoutService.prototype.cancel = function(promise) {};
/**
 * @record
 * @struct
 */
angular.IIntervalService = function() {};

/* TODO: CallSignature: angular */

/**
 * @param {!angular.IPromise<?>} promise
 * @return {boolean}
 */
angular.IIntervalService.prototype.cancel = function(promise) {};
/**
 * @record
 * @struct
 */
angular.IFilterService = function() {};

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterFilter = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterFilterPatternObject = function() {};

/* TODO: IndexSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterFilterPredicateFunc = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterFilterComparatorFunc = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterOrderByItem = function() {};
 /** @type {?} */
angular.IFilterOrderByItem.prototype.value;
 /** @type {string} */
angular.IFilterOrderByItem.prototype.type;
 /** @type {?} */
angular.IFilterOrderByItem.prototype.index;
/**
 * @record
 * @struct
 */
angular.IFilterOrderByComparatorFunc = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterCurrency = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterNumber = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterDate = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterJson = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterLowercase = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterUppercase = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterLimitTo = function() {};

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IFilterOrderBy = function() {};

/* TODO: CallSignature: angular */
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.IFilterProvider = function() {};

/**
 * register(name);
 * 
 * @param {(string|!Object)} name Name of the filter function, or an object map of filters where the keys are the filter names and the values are the filter factories. Note: Filter names must be valid angular Expressions identifiers, such as uppercase or orderBy. Names with special characters, such as hyphens and dots, are not allowed. If you wish to namespace your filters, then you can use capitalization (myappSubsectionFilterx) or underscores (myapp_subsection_filterx).
 * @return {!angular.IServiceProvider}
 */
angular.IFilterProvider.prototype.register = function(name) {};
/**
 * @record
 * @struct
 */
angular.ILocaleService = function() {};
 /** @type {string} */
angular.ILocaleService.prototype.id;
 /** @type {!angular.ILocaleNumberFormatDescriptor} */
angular.ILocaleService.prototype.NUMBER_FORMATS;
 /** @type {!angular.ILocaleDateTimeFormatDescriptor} */
angular.ILocaleService.prototype.DATETIME_FORMATS;

/**
 * @param {?} num
 * @return {string}
 */
angular.ILocaleService.prototype.pluralCat = function(num) {};
/**
 * @record
 * @struct
 */
angular.ILocaleNumberFormatDescriptor = function() {};
 /** @type {string} */
angular.ILocaleNumberFormatDescriptor.prototype.DECIMAL_SEP;
 /** @type {string} */
angular.ILocaleNumberFormatDescriptor.prototype.GROUP_SEP;
 /** @type {!Array<!angular.ILocaleNumberPatternDescriptor>} */
angular.ILocaleNumberFormatDescriptor.prototype.PATTERNS;
 /** @type {string} */
angular.ILocaleNumberFormatDescriptor.prototype.CURRENCY_SYM;
/**
 * @record
 * @struct
 */
angular.ILocaleNumberPatternDescriptor = function() {};
 /** @type {number} */
angular.ILocaleNumberPatternDescriptor.prototype.minInt;
 /** @type {number} */
angular.ILocaleNumberPatternDescriptor.prototype.minFrac;
 /** @type {number} */
angular.ILocaleNumberPatternDescriptor.prototype.maxFrac;
 /** @type {string} */
angular.ILocaleNumberPatternDescriptor.prototype.posPre;
 /** @type {string} */
angular.ILocaleNumberPatternDescriptor.prototype.posSuf;
 /** @type {string} */
angular.ILocaleNumberPatternDescriptor.prototype.negPre;
 /** @type {string} */
angular.ILocaleNumberPatternDescriptor.prototype.negSuf;
 /** @type {number} */
angular.ILocaleNumberPatternDescriptor.prototype.gSize;
 /** @type {number} */
angular.ILocaleNumberPatternDescriptor.prototype.lgSize;
/**
 * @record
 * @struct
 */
angular.ILocaleDateTimeFormatDescriptor = function() {};
 /** @type {!Array<string>} */
angular.ILocaleDateTimeFormatDescriptor.prototype.MONTH;
 /** @type {!Array<string>} */
angular.ILocaleDateTimeFormatDescriptor.prototype.SHORTMONTH;
 /** @type {!Array<string>} */
angular.ILocaleDateTimeFormatDescriptor.prototype.DAY;
 /** @type {!Array<string>} */
angular.ILocaleDateTimeFormatDescriptor.prototype.SHORTDAY;
 /** @type {!Array<string>} */
angular.ILocaleDateTimeFormatDescriptor.prototype.AMPMS;
 /** @type {string} */
angular.ILocaleDateTimeFormatDescriptor.prototype.medium;
 /** @type {string} */
angular.ILocaleDateTimeFormatDescriptor.prototype.short;
 /** @type {string} */
angular.ILocaleDateTimeFormatDescriptor.prototype.fullDate;
 /** @type {string} */
angular.ILocaleDateTimeFormatDescriptor.prototype.longDate;
 /** @type {string} */
angular.ILocaleDateTimeFormatDescriptor.prototype.mediumDate;
 /** @type {string} */
angular.ILocaleDateTimeFormatDescriptor.prototype.shortDate;
 /** @type {string} */
angular.ILocaleDateTimeFormatDescriptor.prototype.mediumTime;
 /** @type {string} */
angular.ILocaleDateTimeFormatDescriptor.prototype.shortTime;
/**
 * @record
 * @struct
 */
angular.ILogService = function() {};
 /** @type {!angular.ILogCall} */
angular.ILogService.prototype.debug;
 /** @type {!angular.ILogCall} */
angular.ILogService.prototype.error;
 /** @type {!angular.ILogCall} */
angular.ILogService.prototype.info;
 /** @type {!angular.ILogCall} */
angular.ILogService.prototype.log;
 /** @type {!angular.ILogCall} */
angular.ILogService.prototype.warn;
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.ILogProvider = function() {};

/**
 * @param {boolean=} enabled
 * @return {boolean|!angular.ILogProvider}
 */
angular.ILogProvider.prototype.debugEnabled = function(enabled) {};
/**
 * @record
 * @struct
 */
angular.ILogCall = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IParseService = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IParseProvider = function() {};

/**
 * @param {boolean=} value
 * @return {boolean|!angular.IParseProvider}
 */
angular.IParseProvider.prototype.logPromiseWarnings = function(value) {};

/**
 * @param {boolean=} value
 * @return {boolean|!angular.IParseProvider}
 */
angular.IParseProvider.prototype.unwrapPromises = function(value) {};

/**
 * Configure $parse service to add literal values that will be present as literal at expressions.
 * 
 * @param {string} literalName Token for the literal value. The literal name value must be a valid literal name.
 * @param {?} literalValue Value for this literal. All literal values must be primitives or `undefined`.
 * 
 * @return {void}
 */
angular.IParseProvider.prototype.addLiteral = function(literalName, literalValue) {};

/**
 * Allows defining the set of characters that are allowed in Angular expressions. The function identifierStart will get called to know if a given character is a valid character to be the first character for an identifier. The function identifierContinue will get called to know if a given character is a valid character to be a follow-up identifier character. The functions identifierStart and identifierContinue will receive as arguments the single character to be identifier and the character code point. These arguments will be string and numeric. Keep in mind that the string parameter can be two characters long depending on the character representation. It is expected for the function to return true or false, whether that character is allowed or not.
 * Since this function will be called extensivelly, keep the implementation of these functions fast, as the performance of these functions have a direct impact on the expressions parsing speed.
 * 
 * @param {function(string, number): boolean=} identifierStart The function that will decide whether the given character is a valid identifier start character.
 * @param {function(string, number): boolean=} identifierContinue The function that will decide whether the given character is a valid identifier continue character.
 * 
 * @return {void}
 */
angular.IParseProvider.prototype.setIdentifierFns = function(identifierStart, identifierContinue) {};
/**
 * @record
 * @struct
 */
angular.ICompiledExpression = function() {};

/* TODO: CallSignature: angular */
 /** @type {boolean} */
angular.ICompiledExpression.prototype.literal;
 /** @type {boolean} */
angular.ICompiledExpression.prototype.constant;

/**
 * @param {?} context
 * @param {?} value
 * @return {?}
 */
angular.ICompiledExpression.prototype.assign = function(context, value) {};
/**
 * @record
 * @struct
 */
angular.ILocationService = function() {};

/**
 * @return {string}
 */
angular.ILocationService.prototype.absUrl = function() {};

/**
 * Returns the hash fragment
 * Changes the hash fragment and returns `$location`
 * @param {string=} newHash
 * @return {string|!angular.ILocationService}
 */
angular.ILocationService.prototype.hash = function(newHash) {};

/**
 * @return {string}
 */
angular.ILocationService.prototype.host = function() {};

/**
 * Return path of current url
 * Change path when called with parameter and return $location.
 * Note: Path should always begin with forward slash (/), this method will add the forward slash if it is missing.
 * 
 * @param {string=} path New path
 * @return {string|!angular.ILocationService}
 */
angular.ILocationService.prototype.path = function(path) {};

/**
 * @return {number}
 */
angular.ILocationService.prototype.port = function() {};

/**
 * @return {string}
 */
angular.ILocationService.prototype.protocol = function() {};

/**
 * @return {!angular.ILocationService}
 */
angular.ILocationService.prototype.replace = function() {};

/**
 * Return search part (as object) of current url
 * Change search part when called with parameter and return $location.
 * 
 * Change search part when called with parameter and return $location.
 * 
 * @param {?|string=} search When called with a single argument the method acts as a setter, setting the search component of $location to the specified value.
 * 
 * If the argument is a hash object containing an array of values, these values will be encoded as duplicate search parameters in the url. / New search params
 * @param {(string|number|boolean|!Array<string>)=} paramValue If search is a string or a Number, then paramValue will override only a single search property. If paramValue is null, the property specified via the first argument will be deleted. If paramValue is an array, it will override the property of the search component of $location specified via the first argument. If paramValue is true, the property specified via the first argument will be added with no value nor trailing equal sign.
 * @return {?|!angular.ILocationService}
 */
angular.ILocationService.prototype.search = function(search, paramValue) {};

/**
 * @param {?=} state
 * @return {?|!angular.ILocationService}
 */
angular.ILocationService.prototype.state = function(state) {};

/**
 * @param {string=} url
 * @return {string|!angular.ILocationService}
 */
angular.ILocationService.prototype.url = function(url) {};
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.ILocationProvider = function() {};

/**
 * @param {string=} prefix
 * @return {string|!angular.ILocationProvider}
 */
angular.ILocationProvider.prototype.hashPrefix = function(prefix) {};

/**
 * @param {boolean|{enabled: boolean, requireBase: boolean, rewriteLinks: boolean}=} active_or_mode
 * @return {boolean|!angular.ILocationProvider}
 */
angular.ILocationProvider.prototype.html5Mode = function(active_or_mode) {};
/**
 * @extends {JQLite}
 * @record
 * @struct
 */
angular.IDocumentService = function() {};

/* TODO: IndexSignature: angular */
/**
 * @record
 * @struct
 */
angular.IExceptionHandlerService = function() {};

/* TODO: CallSignature: angular */
/**
 * @extends {JQLite}
 * @record
 * @struct
 */
angular.IRootElementService = function() {};
/**
 * @record
 * @struct
 */
angular.IQResolveReject = function() {};

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IQService = function() {};

/* TODO: ConstructSignature: angular */

/* TODO: CallSignature: angular */

/**
 * Combines multiple promises into a single promise that is resolved when all of the input promises are resolved.
 * 
 * Returns a single promise that will be resolved with an array of values, each value corresponding to the promise at the same index in the promises array. If any of the promises is resolved with a rejection, this resulting promise will be rejected with the same rejection value.
 * 
 * Combines multiple promises into a single promise that is resolved when all of the input promises are resolved.
 * 
 * Returns a single promise that will be resolved with a hash of values, each value corresponding to the promise at the same key in the promises hash. If any of the promises is resolved with a rejection, this resulting promise will be rejected with the same rejection value.
 * 
 * @template T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TAll, T
 * @param {!Array<?>|!Array<!angular.IPromise<TAll>>|?} values_or_promises A hash of promises.
 * @return {!angular.IPromise<!Array<?>>|!angular.IPromise<!Array<TAll>>|!angular.IPromise<T>}
 */
angular.IQService.prototype.all = function(values_or_promises) {};

/**
 * Creates a Deferred object which represents a task which will finish in the future.
 * @template T
 * @return {!angular.IDeferred<T>}
 */
angular.IQService.prototype.defer = function() {};

/**
 * Returns a promise that resolves or rejects as soon as one of those promises resolves or rejects, with the value or reason from that promise.
 * 
 * @template T
 * @param {(!Array<!angular.IPromise<T>>|!Object<string,!angular.IPromise<T>>)} promises A list or hash of promises.
 * @return {!angular.IPromise<T>}
 */
angular.IQService.prototype.race = function(promises) {};

/**
 * Creates a promise that is resolved as rejected with the specified reason. This api should be used to forward rejection in a chain of promises. If you are dealing with the last promise in a promise chain, you don't need to worry about it.
 * 
 * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of reject as the throw keyword in JavaScript. This also means that if you "catch" an error via a promise error callback and you want to forward the error to the promise derived from the current promise, you have to "rethrow" the error by returning a rejection constructed via reject.
 * 
 * @param {?=} reason Constant, message, exception or an object representing the rejection reason.
 * @return {!angular.IPromise<?>}
 */
angular.IQService.prototype.reject = function(reason) {};

/**
 * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise. This is useful when you are dealing with an object that might or might not be a promise, or if the promise comes from a source that can't be trusted.
 * 
 * @deprecated Since TS 2.4, inference is stricter and no longer produces the desired type when T1 !== T2.
 * To use resolve with two different types, pass a union type to the single-type-argument overload.
 * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise. This is useful when you are dealing with an object that might or might not be a promise, or if the promise comes from a source that can't be trusted.
 * @template T, T1, T2
 * @param {(T|!angular.IPromise<T>)|(T2|!angular.IPromise<T1>)=} value Value or a promise
 * @return {!angular.IPromise<T>|!angular.IPromise<(T1|T2)>|!angular.IPromise<void>}
 */
angular.IQService.prototype.resolve = function(value) {};

/**
 * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise. This is useful when you are dealing with an object that might or might not be a promise, or if the promise comes from a source that can't be trusted.
 * 
 * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise. This is useful when you are dealing with an object that might or might not be a promise, or if the promise comes from a source that can't be trusted.
 * @template T, T1, T2, TResult, TResult2
 * @param {(T|!angular.IPromise<T>)|(T2|!angular.IPromise<T1>)|T|!angular.IPromise<T>=} value Value or a promise
 * @param {function(T): (TResult|!angular.IPromise<TResult>)=} successCallback
 * @param {function(?): ?|function(?): (TResult2|!angular.IPromise<TResult2>)=} errorCallback
 * @param {function(?): ?=} notifyCallback
 * @return {!angular.IPromise<T>|!angular.IPromise<(T1|T2)>|!angular.IPromise<TResult>|!angular.IPromise<(TResult|TResult2)>|!angular.IPromise<void>}
 */
angular.IQService.prototype.when = function(value, successCallback, errorCallback, notifyCallback) {};
/**
 * @record
 * @struct
 */
angular.IQProvider = function() {};

/**
 * Retrieves or overrides whether to generate an error when a rejected promise is not handled.
 * This feature is enabled by default.
 * 
 * Retrieves or overrides whether to generate an error when a rejected promise is not handled.
 * This feature is enabled by default.
 * 
 * @param {boolean=} value
 * @return {boolean|!angular.IQProvider}
 */
angular.IQProvider.prototype.errorOnUnhandledRejections = function(value) {};
/**
 * @record
 * @struct
 */
angular.IPromise = function() {};

/**
 * Regardless of when the promise was or will be resolved or rejected, then calls one of the success or error callbacks asynchronously as soon as the result is available. The callbacks are called with a single argument: the result or rejection reason. Additionally, the notify callback may be called zero or more times to provide a progress indication, before the promise is resolved or rejected.
 * The successCallBack may return IPromise<never> for when a $q.reject() needs to be returned
 * This method returns a new promise which is resolved or rejected via the return value of the successCallback, errorCallback. It also notifies via the return value of the notifyCallback method. The promise can not be resolved or rejected from the notifyCallback method.
 * @template TResult, TResult1, TResult2, TCatch, TCatch1, TCatch2
 * @param {function(T): (TResult|!angular.IPromise<TResult>)|function(T): (TResult2|!angular.IPromise<TResult1>)} successCallback
 * @param {null|function(?): (TCatch|!angular.IPromise<TCatch>)|function(?): (TCatch2|!angular.IPromise<TCatch1>)=} errorCallback
 * @param {function(?): ?=} notifyCallback
 * @return {!angular.IPromise<TResult>|!angular.IPromise<(TResult1|TResult2)>|!angular.IPromise<(TResult|TCatch)>|!angular.IPromise<(TResult1|TResult2|TCatch1|TCatch2)>}
 */
angular.IPromise.prototype.then = function(successCallback, errorCallback, notifyCallback) {};

/**
 * Shorthand for promise.then(null, errorCallback)
 * @template TCatch, TCatch1, TCatch2
 * @param {function(?): (TCatch|!angular.IPromise<TCatch>)|function(?): (TCatch2|!angular.IPromise<TCatch1>)} onRejected
 * @return {!angular.IPromise<(T|TCatch)>|!angular.IPromise<(T|TCatch1|TCatch2)>}
 */
angular.IPromise.prototype.catch = function(onRejected) {};

/**
 * Allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful to release resources or do some clean-up that needs to be done whether the promise was rejected or resolved. See the full specification for more information.
 * 
 * Because finally is a reserved word in JavaScript and reserved keywords are not supported as property names by ES3, you'll need to invoke the method like promise['finally'](callback) to make your code IE8 and Android 2.x compatible.
 * @param {function(): ?} finallyCallback
 * @return {!angular.IPromise}
 */
angular.IPromise.prototype.finally = function(finallyCallback) {};
/**
 * @record
 * @struct
 */
angular.IDeferred = function() {};
 /** @type {!angular.IPromise<T>} */
angular.IDeferred.prototype.promise;

/**
 * @param {(T|!angular.IPromise<T>)=} value
 * @return {void}
 */
angular.IDeferred.prototype.resolve = function(value) {};

/**
 * @param {?=} reason
 * @return {void}
 */
angular.IDeferred.prototype.reject = function(reason) {};

/**
 * @param {?=} state
 * @return {void}
 */
angular.IDeferred.prototype.notify = function(state) {};
/**
 * @record
 * @struct
 */
angular.IAnchorScrollService = function() {};

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */
 /** @type {?} */
angular.IAnchorScrollService.prototype.yOffset;
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.IAnchorScrollProvider = function() {};

/**
 * @return {void}
 */
angular.IAnchorScrollProvider.prototype.disableAutoScrolling = function() {};
/**
 * @record
 * @struct
 */
angular.ICacheFactoryService = function() {};

/* TODO: CallSignature: angular */

/**
 * Get information about all the caches that have been created.
 * @return {?} key-value map of cacheId to the result of calling cache#info
 */
angular.ICacheFactoryService.prototype.info = function() {};

/**
 * Get access to a cache object by the cacheId used when it was created.
 * 
 * @param {string} cacheId Name or id of a cache to access.
 * @return {!angular.ICacheObject}
 */
angular.ICacheFactoryService.prototype.get = function(cacheId) {};
/**
 * @record
 * @struct
 */
angular.ICacheObject = function() {};

/**
 * Retrieve information regarding a particular Cache.
 * @return {{id: string, size: number}}
 */
angular.ICacheObject.prototype.info = function() {};

/**
 * Inserts a named entry into the Cache object to be retrieved later, and incrementing the size of the cache if the key was not already present in the cache. If behaving like an LRU cache, it will also remove stale entries from the set.
 * 
 * It will not insert undefined values into the cache.
 * 
 * @template T
 * @param {string} key the key under which the cached data is stored.
 * @param {T=} value the value to store alongside the key. If it is undefined, the key will not be stored.
 * @return {T}
 */
angular.ICacheObject.prototype.put = function(key, value) {};

/**
 * Retrieves named data stored in the Cache object.
 * 
 * @template T
 * @param {string} key the key of the data to be retrieved
 * @return {T}
 */
angular.ICacheObject.prototype.get = function(key) {};

/**
 * Removes an entry from the Cache object.
 * 
 * @param {string} key the key of the entry to be removed
 * @return {void}
 */
angular.ICacheObject.prototype.remove = function(key) {};

/**
 * Clears the cache object of any entries.
 * @return {void}
 */
angular.ICacheObject.prototype.removeAll = function() {};

/**
 * Destroys the Cache object entirely, removing it from the $cacheFactory set.
 * @return {void}
 */
angular.ICacheObject.prototype.destroy = function() {};
/**
 * @record
 * @struct
 */
angular.ICompileService = function() {};

/* TODO: CallSignature: angular */
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.ICompileProvider = function() {};

/**
 * @param {string|!Object<string,(!angular.IDirectiveFactory|!Array<(string|!angular.IDirectiveFactory)>)>} name_or_object
 * @param {(!angular.IDirectiveFactory|!Array<(string|!angular.IDirectiveFactory)>)=} directiveFactory
 * @return {!angular.ICompileProvider}
 */
angular.ICompileProvider.prototype.directive = function(name_or_object, directiveFactory) {};

/**
 * @param {string} name
 * @param {!angular.IComponentOptions} options
 * @return {!angular.ICompileProvider}
 */
angular.ICompileProvider.prototype.component = function(name, options) {};

/**
 * @param {!RegExp=} regexp
 * @return {!RegExp|!angular.ICompileProvider}
 */
angular.ICompileProvider.prototype.aHrefSanitizationWhitelist = function(regexp) {};

/**
 * @param {!RegExp=} regexp
 * @return {!RegExp|!angular.ICompileProvider}
 */
angular.ICompileProvider.prototype.imgSrcSanitizationWhitelist = function(regexp) {};

/**
 * @param {boolean=} enabled
 * @return {boolean|!angular.ICompileProvider}
 */
angular.ICompileProvider.prototype.debugInfoEnabled = function(enabled) {};

/**
 * Call this method to enable/disable whether directive controllers are assigned bindings before calling the controller's constructor.
 * If enabled (true), the compiler assigns the value of each of the bindings to the properties of the controller object before the constructor of this object is called.
 * If disabled (false), the compiler calls the constructor first before assigning bindings.
 * Defaults to false.
 * See: https://docs.angularjs.org/api/ng/provider/$compileProvider#preAssignBindingsEnabled
 * @param {boolean=} enabled
 * @return {boolean|!angular.ICompileProvider}
 */
angular.ICompileProvider.prototype.preAssignBindingsEnabled = function(enabled) {};

/**
 * Sets the number of times $onChanges hooks can trigger new changes before giving up and assuming that the model is unstable.
 * Increasing the TTL could have performance implications, so you should not change it without proper justification.
 * Default: 10.
 * See: https://docs.angularjs.org/api/ng/provider/$compileProvider#onChangesTtl
 * @param {number=} limit
 * @return {number|!angular.ICompileProvider}
 */
angular.ICompileProvider.prototype.onChangesTtl = function(limit) {};

/**
 * It indicates to the compiler whether or not directives on comments should be compiled.
 * It results in a compilation performance gain since the compiler doesn't have to check comments when looking for directives.
 * Defaults to true.
 * See: https://docs.angularjs.org/api/ng/provider/$compileProvider#commentDirectivesEnabled
 * @param {boolean=} enabled
 * @return {boolean|!angular.ICompileProvider}
 */
angular.ICompileProvider.prototype.commentDirectivesEnabled = function(enabled) {};

/**
 * It indicates to the compiler whether or not directives on element classes should be compiled.
 * It results in a compilation performance gain since the compiler doesn't have to check element classes when looking for directives.
 * Defaults to true.
 * See: https://docs.angularjs.org/api/ng/provider/$compileProvider#cssClassDirectivesEnabled
 * @param {boolean=} enabled
 * @return {boolean|!angular.ICompileProvider}
 */
angular.ICompileProvider.prototype.cssClassDirectivesEnabled = function(enabled) {};
/**
 * @record
 * @struct
 */
angular.ICloneAttachFunction = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.ITemplateLinkingFunction = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.ITemplateLinkingFunctionOptions = function() {};
 /** @type {!angular.ITranscludeFunction} */
angular.ITemplateLinkingFunctionOptions.prototype.parentBoundTranscludeFn;
 /** @type {!Object<string,{instance: !angular.IController}>} */
angular.ITemplateLinkingFunctionOptions.prototype.transcludeControllers;
 /** @type {!JQuery} */
angular.ITemplateLinkingFunctionOptions.prototype.futureParentElement;
/**
 * @record
 * @struct
 */
angular.ITranscludeFunction = function() {};

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/**
 * Returns true if the specified slot contains content (i.e. one or more DOM nodes)
 * @param {string} slotName
 * @return {boolean}
 */
angular.ITranscludeFunction.prototype.isSlotFilled = function(slotName) {};
/**
 * @record
 * @struct
 */
angular.IControllerLocals = function() {};
 /** @type {!angular.IScope} */
angular.IControllerLocals.prototype.$scope;
 /** @type {!JQuery} */
angular.IControllerLocals.prototype.$element;
/**
 * @record
 * @struct
 */
angular.IControllerService = function() {};

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.IControllerProvider = function() {};

/**
 * @param {string} name
 * @param {!Function|!Array<?>} controllerConstructor_or_dependencyAnnotatedConstructor
 * @return {void}
 */
angular.IControllerProvider.prototype.register = function(name, controllerConstructor_or_dependencyAnnotatedConstructor) {};

/**
 * @return {void}
 */
angular.IControllerProvider.prototype.allowGlobals = function() {};
/**
 * @record
 * @struct
 */
angular.IXhrFactory = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IHttpService = function() {};

/* TODO: CallSignature: angular */
 /** @type {!angular.IHttpProviderDefaults} */
angular.IHttpService.prototype.defaults;
 /** @type {!Array<!angular.IRequestConfig>} */
angular.IHttpService.prototype.pendingRequests;

/**
 * Shortcut method to perform GET request.
 * 
 * @template T
 * @param {string} url Relative or absolute URL specifying the destination of the request
 * @param {!angular.IRequestShortcutConfig=} config Optional configuration object
 * @return {!angular.IHttpPromise<T>}
 */
angular.IHttpService.prototype.get = function(url, config) {};

/**
 * Shortcut method to perform DELETE request.
 * 
 * @template T
 * @param {string} url Relative or absolute URL specifying the destination of the request
 * @param {!angular.IRequestShortcutConfig=} config Optional configuration object
 * @return {!angular.IHttpPromise<T>}
 */
angular.IHttpService.prototype.delete = function(url, config) {};

/**
 * Shortcut method to perform HEAD request.
 * 
 * @template T
 * @param {string} url Relative or absolute URL specifying the destination of the request
 * @param {!angular.IRequestShortcutConfig=} config Optional configuration object
 * @return {!angular.IHttpPromise<T>}
 */
angular.IHttpService.prototype.head = function(url, config) {};

/**
 * Shortcut method to perform JSONP request.
 * 
 * @template T
 * @param {string} url Relative or absolute URL specifying the destination of the request
 * @param {!angular.IRequestShortcutConfig=} config Optional configuration object
 * @return {!angular.IHttpPromise<T>}
 */
angular.IHttpService.prototype.jsonp = function(url, config) {};

/**
 * Shortcut method to perform POST request.
 * 
 * @template T
 * @param {string} url Relative or absolute URL specifying the destination of the request
 * @param {?} data Request content
 * @param {!angular.IRequestShortcutConfig=} config Optional configuration object
 * @return {!angular.IHttpPromise<T>}
 */
angular.IHttpService.prototype.post = function(url, data, config) {};

/**
 * Shortcut method to perform PUT request.
 * 
 * @template T
 * @param {string} url Relative or absolute URL specifying the destination of the request
 * @param {?} data Request content
 * @param {!angular.IRequestShortcutConfig=} config Optional configuration object
 * @return {!angular.IHttpPromise<T>}
 */
angular.IHttpService.prototype.put = function(url, data, config) {};

/**
 * Shortcut method to perform PATCH request.
 * 
 * @template T
 * @param {string} url Relative or absolute URL specifying the destination of the request
 * @param {?} data Request content
 * @param {!angular.IRequestShortcutConfig=} config Optional configuration object
 * @return {!angular.IHttpPromise<T>}
 */
angular.IHttpService.prototype.patch = function(url, data, config) {};
/**
 * @extends {angular.IHttpProviderDefaults}
 * @record
 * @struct
 */
angular.IRequestShortcutConfig = function() {};
 /** @type {?} */
angular.IRequestShortcutConfig.prototype.params;
 /** @type {?} */
angular.IRequestShortcutConfig.prototype.data;
 /** @type {(number|!angular.IPromise<?>)} */
angular.IRequestShortcutConfig.prototype.timeout;
 /** @type {string} */
angular.IRequestShortcutConfig.prototype.responseType;
 /** @type {string} */
angular.IRequestShortcutConfig.prototype.jsonpCallbackParam;
/**
 * @extends {angular.IRequestShortcutConfig}
 * @record
 * @struct
 */
angular.IRequestConfig = function() {};
 /** @type {string} */
angular.IRequestConfig.prototype.method;
 /** @type {string} */
angular.IRequestConfig.prototype.url;
 /** @type {!Object<string,(!EventListener|!EventListenerObject)>} */
angular.IRequestConfig.prototype.eventHandlers;
 /** @type {!Object<string,(!EventListener|!EventListenerObject)>} */
angular.IRequestConfig.prototype.uploadEventHandlers;
/**
 * @record
 * @struct
 */
angular.IHttpHeadersGetter = function() {};

/* TODO: CallSignature: angular */

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IHttpPromiseCallback = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IHttpPromiseCallbackArg = function() {};
 /** @type {T} */
angular.IHttpPromiseCallbackArg.prototype.data;
 /** @type {number} */
angular.IHttpPromiseCallbackArg.prototype.status;
 /** @type {!angular.IHttpHeadersGetter} */
angular.IHttpPromiseCallbackArg.prototype.headers;
 /** @type {!angular.IRequestConfig} */
angular.IHttpPromiseCallbackArg.prototype.config;
 /** @type {string} */
angular.IHttpPromiseCallbackArg.prototype.statusText;
/**
 * @extends {angular.IPromise}
 * @record
 * @struct
 */
angular.IHttpPromise = function() {};
/**
 * @record
 * @struct
 */
angular.IHttpRequestTransformer = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IHttpResponseTransformer = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.HttpHeaderType = function() {};

/* TODO: IndexSignature: angular */
/**
 * @record
 * @struct
 */
angular.IHttpRequestConfigHeaders = function() {};

/* TODO: IndexSignature: angular */
 /** @type {?} */
angular.IHttpRequestConfigHeaders.prototype.common;
 /** @type {?} */
angular.IHttpRequestConfigHeaders.prototype.get;
 /** @type {?} */
angular.IHttpRequestConfigHeaders.prototype.post;
 /** @type {?} */
angular.IHttpRequestConfigHeaders.prototype.put;
 /** @type {?} */
angular.IHttpRequestConfigHeaders.prototype.patch;
/**
 * @record
 * @struct
 */
angular.IHttpProviderDefaults = function() {};
 /** @type {?} */
angular.IHttpProviderDefaults.prototype.cache;
 /** @type {(!angular.IHttpRequestTransformer|!Array<!angular.IHttpRequestTransformer>)} */
angular.IHttpProviderDefaults.prototype.transformRequest;
 /** @type {(!angular.IHttpResponseTransformer|!Array<!angular.IHttpResponseTransformer>)} */
angular.IHttpProviderDefaults.prototype.transformResponse;
 /** @type {!angular.IHttpRequestConfigHeaders} */
angular.IHttpProviderDefaults.prototype.headers;
 /** @type {string} */
angular.IHttpProviderDefaults.prototype.xsrfHeaderName;
 /** @type {string} */
angular.IHttpProviderDefaults.prototype.xsrfCookieName;
 /** @type {boolean} */
angular.IHttpProviderDefaults.prototype.withCredentials;
 /** @type {(string|function(?): string)} */
angular.IHttpProviderDefaults.prototype.paramSerializer;
/**
 * @record
 * @struct
 */
angular.IHttpInterceptor = function() {};

/**
 * @param {!angular.IRequestConfig} config
 * @return {(!angular.IRequestConfig|!angular.IPromise<!angular.IRequestConfig>)}
 */
angular.IHttpInterceptor.prototype.request = function(config) {};

/**
 * @param {?} rejection
 * @return {?}
 */
angular.IHttpInterceptor.prototype.requestError = function(rejection) {};

/**
 * @template T
 * @param {!angular.IHttpPromiseCallbackArg<T>} response
 * @return {(!angular.IHttpPromiseCallbackArg<T>|!angular.IPromise<!angular.IHttpPromiseCallbackArg<T>>)}
 */
angular.IHttpInterceptor.prototype.response = function(response) {};

/**
 * @param {?} rejection
 * @return {?}
 */
angular.IHttpInterceptor.prototype.responseError = function(rejection) {};
/**
 * @record
 * @struct
 */
angular.IHttpInterceptorFactory = function() {};

/* TODO: CallSignature: angular */
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.IHttpProvider = function() {};
 /** @type {!angular.IHttpProviderDefaults} */
angular.IHttpProvider.prototype.defaults;
 /** @type {!Array<(string|!angular.IHttpInterceptorFactory|!Array<(string|!angular.IHttpInterceptorFactory)>)>} */
angular.IHttpProvider.prototype.interceptors;

/**
 * @param {boolean=} value
 * @return {boolean|!angular.IHttpProvider}
 */
angular.IHttpProvider.prototype.useApplyAsync = function(value) {};

/**
 * 
 *    otherwise, returns the current configured value.
 * @param {boolean} value
 * @return {(boolean|!angular.IHttpProvider)}
 */
angular.IHttpProvider.prototype.useLegacyPromiseExtensions = function(value) {};
/**
 * @record
 * @struct
 */
angular.IHttpBackendService = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IInterpolateService = function() {};

/* TODO: CallSignature: angular */

/**
 * @return {string}
 */
angular.IInterpolateService.prototype.endSymbol = function() {};

/**
 * @return {string}
 */
angular.IInterpolateService.prototype.startSymbol = function() {};
/**
 * @record
 * @struct
 */
angular.IInterpolationFunction = function() {};

/* TODO: CallSignature: angular */
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.IInterpolateProvider = function() {};

/**
 * @param {string=} value
 * @return {string|!angular.IInterpolateProvider}
 */
angular.IInterpolateProvider.prototype.startSymbol = function(value) {};

/**
 * @param {string=} value
 * @return {string|!angular.IInterpolateProvider}
 */
angular.IInterpolateProvider.prototype.endSymbol = function(value) {};
/**
 * @extends {angular.ICacheObject}
 * @record
 * @struct
 */
angular.ITemplateCacheService = function() {};
/**
 * @record
 * @struct
 */
angular.ISCEService = function() {};

/**
 * @param {string} type
 * @param {?} mayBeTrusted
 * @return {?}
 */
angular.ISCEService.prototype.getTrusted = function(type, mayBeTrusted) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.getTrustedCss = function(value) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.getTrustedHtml = function(value) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.getTrustedJs = function(value) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.getTrustedResourceUrl = function(value) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.getTrustedUrl = function(value) {};

/**
 * @param {string} type
 * @param {string} expression
 * @return {function(?, ?): ?}
 */
angular.ISCEService.prototype.parse = function(type, expression) {};

/**
 * @param {string} expression
 * @return {function(?, ?): ?}
 */
angular.ISCEService.prototype.parseAsCss = function(expression) {};

/**
 * @param {string} expression
 * @return {function(?, ?): ?}
 */
angular.ISCEService.prototype.parseAsHtml = function(expression) {};

/**
 * @param {string} expression
 * @return {function(?, ?): ?}
 */
angular.ISCEService.prototype.parseAsJs = function(expression) {};

/**
 * @param {string} expression
 * @return {function(?, ?): ?}
 */
angular.ISCEService.prototype.parseAsResourceUrl = function(expression) {};

/**
 * @param {string} expression
 * @return {function(?, ?): ?}
 */
angular.ISCEService.prototype.parseAsUrl = function(expression) {};

/**
 * @param {string} type
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.trustAs = function(type, value) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.trustAsHtml = function(value) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.trustAsJs = function(value) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.trustAsResourceUrl = function(value) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEService.prototype.trustAsUrl = function(value) {};

/**
 * @return {boolean}
 */
angular.ISCEService.prototype.isEnabled = function() {};
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.ISCEProvider = function() {};

/**
 * @param {boolean} value
 * @return {void}
 */
angular.ISCEProvider.prototype.enabled = function(value) {};
/**
 * @record
 * @struct
 */
angular.ISCEDelegateService = function() {};

/**
 * @param {string} type
 * @param {?} mayBeTrusted
 * @return {?}
 */
angular.ISCEDelegateService.prototype.getTrusted = function(type, mayBeTrusted) {};

/**
 * @param {string} type
 * @param {?} value
 * @return {?}
 */
angular.ISCEDelegateService.prototype.trustAs = function(type, value) {};

/**
 * @param {?} value
 * @return {?}
 */
angular.ISCEDelegateService.prototype.valueOf = function(value) {};
/**
 * @extends {angular.IServiceProvider}
 * @record
 * @struct
 */
angular.ISCEDelegateProvider = function() {};

/**
 * @param {!Array<?>=} blacklist
 * @return {!Array<?>|void}
 */
angular.ISCEDelegateProvider.prototype.resourceUrlBlacklist = function(blacklist) {};

/**
 * @param {!Array<?>=} whitelist
 * @return {!Array<?>|void}
 */
angular.ISCEDelegateProvider.prototype.resourceUrlWhitelist = function(whitelist) {};
/**
 * @record
 * @struct
 */
angular.ITemplateRequestService = function() {};

/* TODO: CallSignature: angular */
 /** @type {number} */
angular.ITemplateRequestService.prototype.totalPendingRequests;
/**
 * @record
 * @struct
 */
angular.IComponentOptions = function() {};
 /** @type {(string|function(new: (!angular.IController), !Array<?>): ?|function(!Array<?>): (void|!angular.IController)|!Array<(string|?)>)} */
angular.IComponentOptions.prototype.controller;
 /** @type {string} */
angular.IComponentOptions.prototype.controllerAs;
 /** @type {(string|function(!Array<?>): string|!Array<(string|?)>)} */
angular.IComponentOptions.prototype.template;
 /** @type {(string|function(!Array<?>): string|!Array<(string|?)>)} */
angular.IComponentOptions.prototype.templateUrl;
 /** @type {!Object<string,string>} */
angular.IComponentOptions.prototype.bindings;
 /** @type {(boolean|!Object<string,string>)} */
angular.IComponentOptions.prototype.transclude;
 /** @type {!Object<string,string>} */
angular.IComponentOptions.prototype.require;

/** @typedef {(function(new: (!angular.IController), !Array<?>): ?|function(!Array<?>): (void|!angular.IController))} */
angular.IControllerConstructor;
/**
 * @record
 * @struct
 */
angular.IController = function() {};

/* TODO: IndexSignature: angular */

/**
 * Called on each controller after all the controllers on an element have been constructed and had their bindings
 * initialized (and before the pre & post linking functions for the directives on this element). This is a good
 * place to put initialization code for your controller.
 * @return {void}
 */
angular.IController.prototype.$onInit = function() {};

/**
 * Called on each turn of the digest cycle. Provides an opportunity to detect and act on changes.
 * Any actions that you wish to take in response to the changes that you detect must be invoked from this hook;
 * implementing this has no effect on when `$onChanges` is called. For example, this hook could be useful if you wish
 * to perform a deep equality check, or to check a `Dat`e object, changes to which would not be detected by Angular's
 * change detector and thus not trigger `$onChanges`. This hook is invoked with no arguments; if detecting changes,
 * you must store the previous value(s) for comparison to the current values.
 * @return {void}
 */
angular.IController.prototype.$doCheck = function() {};

/**
 * Called whenever one-way bindings are updated. The onChangesObj is a hash whose keys are the names of the bound
 * properties that have changed, and the values are an {\@link IChangesObject} object  of the form
 * { currentValue, previousValue, isFirstChange() }. Use this hook to trigger updates within a component such as
 * cloning the bound value to prevent accidental mutation of the outer value.
 * @param {!angular.IOnChangesObject} onChangesObj
 * @return {void}
 */
angular.IController.prototype.$onChanges = function(onChangesObj) {};

/**
 * Called on a controller when its containing scope is destroyed. Use this hook for releasing external resources,
 * watches and event handlers.
 * @return {void}
 */
angular.IController.prototype.$onDestroy = function() {};

/**
 * Called after this controller's element and its children have been linked. Similar to the post-link function this
 * hook can be used to set up DOM event handlers and do direct DOM manipulation. Note that child elements that contain
 * templateUrl directives will not have been compiled and linked since they are waiting for their template to load
 * asynchronously and their own compilation and linking has been suspended until that occurs. This hook can be considered
 * analogous to the ngAfterViewInit and ngAfterContentInit hooks in Angular 2. Since the compilation process is rather
 * different in Angular 1 there is no direct mapping and care should be taken when upgrading.
 * @return {void}
 */
angular.IController.prototype.$postLink = function() {};
/**
 * @record
 * @struct
 */
angular.IOnInit = function() {};

/**
 * Called on each controller after all the controllers on an element have been constructed and had their bindings
 * initialized (and before the pre & post linking functions for the directives on this element). This is a good
 * place to put initialization code for your controller.
 * @return {void}
 */
angular.IOnInit.prototype.$onInit = function() {};
/**
 * @record
 * @struct
 */
angular.IDoCheck = function() {};

/**
 * Called on each turn of the digest cycle. Provides an opportunity to detect and act on changes.
 * Any actions that you wish to take in response to the changes that you detect must be invoked from this hook;
 * implementing this has no effect on when `$onChanges` is called. For example, this hook could be useful if you wish
 * to perform a deep equality check, or to check a `Dat`e object, changes to which would not be detected by Angular's
 * change detector and thus not trigger `$onChanges`. This hook is invoked with no arguments; if detecting changes,
 * you must store the previous value(s) for comparison to the current values.
 * @return {void}
 */
angular.IDoCheck.prototype.$doCheck = function() {};
/**
 * @record
 * @struct
 */
angular.IOnChanges = function() {};

/**
 * Called whenever one-way bindings are updated. The onChangesObj is a hash whose keys are the names of the bound
 * properties that have changed, and the values are an {\@link IChangesObject} object  of the form
 * { currentValue, previousValue, isFirstChange() }. Use this hook to trigger updates within a component such as
 * cloning the bound value to prevent accidental mutation of the outer value.
 * @param {!angular.IOnChangesObject} onChangesObj
 * @return {void}
 */
angular.IOnChanges.prototype.$onChanges = function(onChangesObj) {};
/**
 * @record
 * @struct
 */
angular.IOnDestroy = function() {};

/**
 * Called on a controller when its containing scope is destroyed. Use this hook for releasing external resources,
 * watches and event handlers.
 * @return {void}
 */
angular.IOnDestroy.prototype.$onDestroy = function() {};
/**
 * @record
 * @struct
 */
angular.IPostLink = function() {};

/**
 * Called after this controller's element and its children have been linked. Similar to the post-link function this
 * hook can be used to set up DOM event handlers and do direct DOM manipulation. Note that child elements that contain
 * templateUrl directives will not have been compiled and linked since they are waiting for their template to load
 * asynchronously and their own compilation and linking has been suspended until that occurs. This hook can be considered
 * analogous to the ngAfterViewInit and ngAfterContentInit hooks in Angular 2. Since the compilation process is rather
 * different in Angular 1 there is no direct mapping and care should be taken when upgrading.
 * @return {void}
 */
angular.IPostLink.prototype.$postLink = function() {};
/**
 * @record
 * @struct
 */
angular.IOnChangesObject = function() {};

/* TODO: IndexSignature: angular */
/**
 * @record
 * @struct
 */
angular.IChangesObject = function() {};
 /** @type {T} */
angular.IChangesObject.prototype.currentValue;
 /** @type {T} */
angular.IChangesObject.prototype.previousValue;

/**
 * @return {boolean}
 */
angular.IChangesObject.prototype.isFirstChange = function() {};
/**
 * @record
 * @struct
 */
angular.IDirectiveFactory = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IDirectiveLinkFn = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IDirectivePrePost = function() {};
 /** @type {!angular.IDirectiveLinkFn} */
angular.IDirectivePrePost.prototype.pre;
 /** @type {!angular.IDirectiveLinkFn} */
angular.IDirectivePrePost.prototype.post;
/**
 * @record
 * @struct
 */
angular.IDirectiveCompileFn = function() {};

/* TODO: CallSignature: angular */
/**
 * @record
 * @struct
 */
angular.IDirective = function() {};
 /** @type {!angular.IDirectiveCompileFn} */
angular.IDirective.prototype.compile;
 /** @type {(string|function(new: (!angular.IController), !Array<?>): ?|function(!Array<?>): (void|!angular.IController)|!Array<(string|?)>)} */
angular.IDirective.prototype.controller;
 /** @type {string} */
angular.IDirective.prototype.controllerAs;
 /** @type {(boolean|!Object<string,string>)} */
angular.IDirective.prototype.bindToController;
 /** @type {(!angular.IDirectiveLinkFn|!angular.IDirectivePrePost)} */
angular.IDirective.prototype.link;
 /** @type {boolean} */
angular.IDirective.prototype.multiElement;
 /** @type {number} */
angular.IDirective.prototype.priority;
 /** @type {boolean} */
angular.IDirective.prototype.replace;
 /** @type {(string|!Array<string>|!Object<string,string>)} */
angular.IDirective.prototype.require;
 /** @type {string} */
angular.IDirective.prototype.restrict;
 /** @type {(boolean|!Object<string,string>)} */
angular.IDirective.prototype.scope;
 /** @type {(string|function(!JQLite, !angular.IAttributes): string)} */
angular.IDirective.prototype.template;
 /** @type {string} */
angular.IDirective.prototype.templateNamespace;
 /** @type {(string|function(!JQLite, !angular.IAttributes): string)} */
angular.IDirective.prototype.templateUrl;
 /** @type {boolean} */
angular.IDirective.prototype.terminal;
 /** @type {(boolean|string|!Object<string,string>)} */
angular.IDirective.prototype.transclude;
/**
 * @extends {JQueryStatic}
 * @record
 * @struct
 */
angular.IAugmentedJQueryStatic = function() {};
/**
 * @extends {JQLite}
 * @record
 * @struct
 */
angular.IAugmentedJQuery = function() {};
/**
 * @extends {angular.IController}
 * @record
 * @struct
 */
angular.IComponentController = function() {};
/** @const */
angular.auto = {};
/**
 * @record
 * @struct
 */
angular.auto.IInjectorService = function() {};
 /** @type {boolean} */
angular.auto.IInjectorService.prototype.strictDi;

/**
 * @param {!Function|!Array<?>} fn_or_inlineAnnotatedFunction
 * @param {boolean=} strictDi
 * @return {!Array<string>}
 */
angular.auto.IInjectorService.prototype.annotate = function(fn_or_inlineAnnotatedFunction, strictDi) {};

/**
 * @template T
 * @param {string} name
 * @param {string=} caller
 * @return {T|!angular.IAnchorScrollService|!angular.ICacheFactoryService|!angular.ICompileService|!angular.IControllerService|!angular.IDocumentService|!angular.IExceptionHandlerService|!angular.IFilterService|!angular.IHttpService|!angular.IHttpBackendService|!angular.IHttpParamSerializer|!angular.IInterpolateService|!angular.IIntervalService|!angular.ILocaleService|!angular.ILocationService|!angular.ILogService|!angular.IParseService|!angular.IQService|!angular.IRootElementService|!angular.IRootScopeService|!angular.ISCEService|!angular.ISCEDelegateService|!angular.ITemplateCacheService|!angular.ITemplateRequestService|!angular.ITimeoutService|!angular.IWindowService|!angular.IXhrFactory<T>}
 */
angular.auto.IInjectorService.prototype.get = function(name, caller) {};

/**
 * @param {string} name
 * @return {boolean}
 */
angular.auto.IInjectorService.prototype.has = function(name) {};

/**
 * @template T
 * @param {function(new: (T), !Array<?>): ?} typeConstructor
 * @param {?=} locals
 * @return {T}
 */
angular.auto.IInjectorService.prototype.instantiate = function(typeConstructor, locals) {};

/**
 * @template T
 * @param {!Array<?>|function(!Array<?>): T|!Function} inlineAnnotatedFunction_or_func
 * @param {?=} context
 * @param {?=} locals
 * @return {?|T}
 */
angular.auto.IInjectorService.prototype.invoke = function(inlineAnnotatedFunction_or_func, context, locals) {};
/**
 * @record
 * @struct
 */
angular.auto.IProvideService = function() {};

/**
 * Register a constant service, such as a string, a number, an array, an object or a function, with the $injector. Unlike value it can be injected into a module configuration function (see config) and it cannot be overridden by an Angular decorator.
 * 
 * @param {string} name The name of the constant.
 * @param {?} value The constant value.
 * @return {void}
 */
angular.auto.IProvideService.prototype.constant = function(name, value) {};

/**
 * Register a service decorator with the $injector. A service decorator intercepts the creation of a service, allowing it to override or modify the behaviour of the service. The object returned by the decorator may be the original service, or a new service object which replaces or wraps and delegates to the original service.
 * 
 * Register a service decorator with the $injector. A service decorator intercepts the creation of a service, allowing it to override or modify the behaviour of the service. The object returned by the decorator may be the original service, or a new service object which replaces or wraps and delegates to the original service.
 * 
 * @param {string} name The name of the service to decorate.
 * @param {!Function|!Array<?>} decorator_or_inlineAnnotatedFunction This function will be invoked when the service needs to be instantiated and should return the decorated service instance. The function is called using the injector.invoke method and is therefore fully injectable. Local injection arguments:
 * 
 * $delegate - The original service instance, which can be monkey patched, configured, decorated or delegated to.
 * @return {void}
 */
angular.auto.IProvideService.prototype.decorator = function(name, decorator_or_inlineAnnotatedFunction) {};

/**
 * @param {string} name
 * @param {!Function|!Array<?>} serviceFactoryFunction_or_inlineAnnotatedFunction
 * @return {!angular.IServiceProvider}
 */
angular.auto.IProvideService.prototype.factory = function(name, serviceFactoryFunction_or_inlineAnnotatedFunction) {};

/**
 * @param {string} name
 * @param {!angular.IServiceProvider|!Function} provider_or_serviceProviderConstructor
 * @return {!angular.IServiceProvider}
 */
angular.auto.IProvideService.prototype.provider = function(name, provider_or_serviceProviderConstructor) {};

/**
 * @param {string} name
 * @param {!Function|!Array<?>} constructor_or_inlineAnnotatedFunction
 * @return {!angular.IServiceProvider}
 */
angular.auto.IProvideService.prototype.service = function(name, constructor_or_inlineAnnotatedFunction) {};

/**
 * @param {string} name
 * @param {?} value
 * @return {!angular.IServiceProvider}
 */
angular.auto.IProvideService.prototype.value = function(name, value) {};
/**
 * @record
 * @struct
 */
angular.IHttpParamSerializer = function() {};

/* TODO: CallSignature: angular */
