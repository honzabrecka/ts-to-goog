/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/react-flip-move/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: NamespaceExportDeclaration in  */

/* TODO: ExportAssignment in  */
/**
 * @extends {Component}
 * @constructor
 * @struct
 */
function FlipMove() {}

/** @typedef {string} */
FlipMove.AnimationPreset;
/**
 * @record
 * @struct
 */
FlipMove.Animation = function() {};
 /** @type {?} */
FlipMove.Animation.prototype.from;
 /** @type {?} */
FlipMove.Animation.prototype.to;
/**
 * @record
 * @struct
 */
FlipMove.FlipMoveProps = function() {};
 /** @type {string} */
FlipMove.FlipMoveProps.prototype.className;
 /** @type {string} */
FlipMove.FlipMoveProps.prototype.easing;
 /** @type {number} */
FlipMove.FlipMoveProps.prototype.duration;
 /** @type {number} */
FlipMove.FlipMoveProps.prototype.delay;
 /** @type {number} */
FlipMove.FlipMoveProps.prototype.staggerDurationBy;
 /** @type {number} */
FlipMove.FlipMoveProps.prototype.staggerDelayBy;
 /** @type {(boolean|string|!FlipMove.Animation)} */
FlipMove.FlipMoveProps.prototype.appearAnimation;
 /** @type {(boolean|string|!FlipMove.Animation)} */
FlipMove.FlipMoveProps.prototype.enterAnimation;
 /** @type {(boolean|string|!FlipMove.Animation)} */
FlipMove.FlipMoveProps.prototype.leaveAnimation;
 /** @type {boolean} */
FlipMove.FlipMoveProps.prototype.maintainContainerHeight;
 /** @type {string} */
FlipMove.FlipMoveProps.prototype.typeName;
 /** @type {boolean} */
FlipMove.FlipMoveProps.prototype.disableAllAnimations;

/**
 * A callback to be invoked **once per child element** at the start of the animation.
 * 
 * In general, it is advisable to ignore the domNode argument and work with the childElement. The domNode is just
 * an escape hatch for doing complex things not otherwise possible.
 * 
 * @param {!React.ReactElement<?>} childElement  A reference to the React Element being animated.
 * @param {!HTMLElement} domNode       A reference to the unadulterated DOM node being animated.
 * @return {void}
 */
FlipMove.FlipMoveProps.prototype.onStart = function(childElement, domNode) {};

/**
 * A callback to be invoked **once per child element** at the end of the animation.
 * 
 * In general, it is advisable to ignore the `domNode` argument and work with the `childElement`. The `domNode` is
 * just an escape hatch for doing complex things not otherwise possible.
 * 
 * @param {!React.ReactElement<?>} childElement  A reference to the React Element being animated.
 * @param {!HTMLElement} domNode       A reference to the unadulterated DOM node being animated.
 * @return {void}
 */
FlipMove.FlipMoveProps.prototype.onFinish = function(childElement, domNode) {};

/**
 * A callback to be invoked **once per group** at the start of the animation.
 * 
 * The callback arguments are similar to the ones provided for onStart, except we provide an array of the elements
 * and nodes. The order of both arguments is guaranteed; this means you can use a zipping function like lodash's
 * .zip to get pairs of element/node, if needed.
 * 
 * In general, it is advisable to ignore the `domNodes` argument and work with the `childElements` The `domNodes`
 * 
 * are just an escape hatch for doing complex things not otherwise possible.
 * 
 * @param {!Array<!React.ReactElement<?>>} childElements An array of the references to the React Element(s) being animated.
 * @param {!Array<!HTMLElement>} domNodes      An array of the references to the unadulterated DOM node(s) being animated.
 * @return {void}
 */
FlipMove.FlipMoveProps.prototype.onStartAll = function(childElements, domNodes) {};

/**
 * A callback to be invoked **once per group** at the end of the animation.
 * 
 * The callback arguments are similar to the ones provided for onFinish, except we provide an array of the elements
 * and nodes. The order of both arguments is guaranteed; this means you can use a zipping function like lodash's
 * .zip to get pairs of element/node, if needed.
 * 
 * In general, it is advisable to ignore the `domNodes` argument and work with the `childElements` The `domNodes`
 * are just an escape hatch for doing complex things not otherwise possible.
 * 
 * @param {!Array<!React.ReactElement<?>>} childElements An array of the references to the React Element(s) being animated.
 * @param {!Array<!HTMLElement>} domNodes      An array of the references to the unadulterated DOM node(s) being animated.
 * @return {void}
 */
FlipMove.FlipMoveProps.prototype.onFinishAll = function(childElements, domNodes) {};

/**
 * This function is called with a DOM node as the only argument. It should return an object as specified by the
 * getBoundingClientRect() spec.
 * 
 * For normal usage of FlipMove you won't need this. An example of usage is when FlipMove is used in a container
 * that is scaled using CSS. You can correct the values from getBoundingClientRect by using this prop.
 * @param {!HTMLElement} node
 * @return {!ClientRect}
 */
FlipMove.FlipMoveProps.prototype.getPosition = function(node) {};
