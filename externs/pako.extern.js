/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/pako/index.d.ts:

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
/** @const */
var Pako = {};
/**
 * @record
 * @struct
 */
Pako.DeflateOptions = function() {};
 /** @type {number} */
Pako.DeflateOptions.prototype.level;
 /** @type {number} */
Pako.DeflateOptions.prototype.windowBits;
 /** @type {number} */
Pako.DeflateOptions.prototype.memLevel;
 /** @type {number} */
Pako.DeflateOptions.prototype.strategy;
 /** @type {?} */
Pako.DeflateOptions.prototype.dictionary;
 /** @type {boolean} */
Pako.DeflateOptions.prototype.raw;
 /** @type {string} */
Pako.DeflateOptions.prototype.to;
/**
 * @record
 * @struct
 */
Pako.InflateOptions = function() {};
 /** @type {number} */
Pako.InflateOptions.prototype.windowBits;
 /** @type {boolean} */
Pako.InflateOptions.prototype.raw;
 /** @type {string} */
Pako.InflateOptions.prototype.to;

/** @typedef {(string|!Uint8Array|!Array<number>)} */
Pako.Data;

/**
 * Compress data with deflate algorithm and options.
 * @param {(string|!Uint8Array|!Array<number>)} data
 * @param {?|!Pako.DeflateOptions=} options
 * @return {string|!Uint8Array}
 */
Pako.deflate = function(data, options) {};

/**
 * The same as deflate, but creates raw data, without wrapper (header and adler32 crc).
 * @param {(string|!Uint8Array|!Array<number>)} data
 * @param {?|!Pako.DeflateOptions=} options
 * @return {string|!Uint8Array}
 */
Pako.deflateRaw = function(data, options) {};

/**
 * The same as deflate, but create gzip wrapper instead of deflate one.
 * @param {(string|!Uint8Array|!Array<number>)} data
 * @param {?|!Pako.DeflateOptions=} options
 * @return {string|!Uint8Array}
 */
Pako.gzip = function(data, options) {};

/**
 * Decompress data with inflate/ungzip and options. Autodetect format via wrapper header
 * by default. That's why we don't provide separate ungzip method.
 * @param {(string|!Uint8Array|!Array<number>)} data
 * @param {?|!Pako.InflateOptions=} options
 * @return {string|!Uint8Array}
 */
Pako.inflate = function(data, options) {};

/**
 * The same as inflate, but creates raw data, without wrapper (header and adler32 crc).
 * @param {(string|!Uint8Array|!Array<number>)} data
 * @param {?|!Pako.InflateOptions=} options
 * @return {string|!Uint8Array}
 */
Pako.inflateRaw = function(data, options) {};

/**
 * Just shortcut to inflate, because it autodetects format by header.content. Done for convenience.
 * @param {(string|!Uint8Array|!Array<number>)} data
 * @param {?|!Pako.InflateOptions=} options
 * @return {string|!Uint8Array}
 */
Pako.ungzip = function(data, options) {};

/**
 * @constructor
 * @struct
 * @param {!Pako.DeflateOptions=} options
 */
Pako.Deflate = function(options) {};
 /** @type {number} */
Pako.Deflate.prototype.err;
 /** @type {string} */
Pako.Deflate.prototype.msg;
 /** @type {(!Uint8Array|!Array<number>)} */
Pako.Deflate.prototype.result;

/**
 * @param {(string|!Uint8Array|!Array<number>)} chunk
 * @return {void}
 */
Pako.Deflate.prototype.onData = function(chunk) {};

/**
 * @param {number} status
 * @return {void}
 */
Pako.Deflate.prototype.onEnd = function(status) {};

/**
 * @param {(string|!Uint8Array|!Array<number>|!ArrayBuffer)} data
 * @param {(number|boolean)=} mode
 * @return {boolean}
 */
Pako.Deflate.prototype.push = function(data, mode) {};

/**
 * @constructor
 * @struct
 * @param {!Pako.InflateOptions=} options
 */
Pako.Inflate = function(options) {};
 /** @type {number} */
Pako.Inflate.prototype.err;
 /** @type {string} */
Pako.Inflate.prototype.msg;
 /** @type {(string|!Uint8Array|!Array<number>)} */
Pako.Inflate.prototype.result;

/**
 * @param {(string|!Uint8Array|!Array<number>)} chunk
 * @return {void}
 */
Pako.Inflate.prototype.onData = function(chunk) {};

/**
 * @param {number} status
 * @return {void}
 */
Pako.Inflate.prototype.onEnd = function(status) {};

/**
 * @param {(string|!Uint8Array|!Array<number>|!ArrayBuffer)} data
 * @param {(number|boolean)=} mode
 * @return {boolean}
 */
Pako.Inflate.prototype.push = function(data, mode) {};
