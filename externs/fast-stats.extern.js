/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/fast-stats/index.d.ts:
/**
 * @record
 * @struct
 */
function StatsOpts() {}
 /** @type {number} */
StatsOpts.prototype.bucket_precision;
 /** @type {!Array<number>} */
StatsOpts.prototype.buckets;
 /** @type {number} */
StatsOpts.prototype.bucket_extension_interval;
 /** @type {boolean} */
StatsOpts.prototype.store_data;
 /** @type {boolean} */
StatsOpts.prototype.sampling;
/**
 * @record
 * @struct
 */
function Bucket() {}
 /** @type {number} */
Bucket.prototype.bucket;
 /** @type {!Array<number>} */
Bucket.prototype.range;
 /** @type {number} */
Bucket.prototype.count;

/**
 * @constructor
 * @struct
 * @param {?=} opts
 */
function Stats(opts) {}
 /** @type {number} */
Stats.prototype.length;

/**
 * Add elements to back
 * @param {...number|!Array<number>} args
 * @return {void}
 */
Stats.prototype.push = function(args) {};

/**
 * Remove element from back
 * @return {number}
 */
Stats.prototype.pop = function() {};

/**
 * Remove element from front
 * @return {number}
 */
Stats.prototype.shift = function() {};

/**
 * Add elements to front
 * @param {...number} args
 * @return {void}
 */
Stats.prototype.unshift = function(args) {};

/**
 * Clear all data
 * @return {void}
 */
Stats.prototype.reset = function() {};

/**
 * Fresh copy
 * @return {!Stats}
 */
Stats.prototype.copy = function() {};

/**
 * Arithmetic Mean
 * The arithmetic mean is calculated as the sum of all data points divided by the number of data points. This is useful for data sets that are fairly uniform, following a linear or binomial distribution. Use the amean() method or the `ï¿½()? method to get at it:
 * @return {number}
 */
Stats.prototype.amean = function() {};

/**
 * Geometric Mean
 * The geometric mean is the nth root of the product of all data points where n is the number of data points. This is useful for data sets that follow an exponential or log-normal distribution. Use the gmean() method to get at it:
 * @return {number}
 */
Stats.prototype.gmean = function() {};

/**
 * Median
 * The median is the middle point of the dataset when sorted in ascending order. This is useful if your dataset has a lot of outliers and noise that would not normally be found in a complete population. Use the median() method to get at it:
 * If your data set contains an odd number of points, the median will be the middle point. If it contains an even number of points, then the median will be the arithmetic mean of the two middle points.
 * If your Stats object is configured to use buckets and has store_data set to false, then the median will be an approximation of the actual median.
 * @return {number}
 */
Stats.prototype.median = function() {};

/**
 * Any Percentile
 * You can also get at any percentile value within the data. Use the percentile() method to get at this data. The percentile() method takes in a single argument. This is a number between 0 and 100 (both inclusive) that specifies which percentile point you want.
 * Passing in 50 as an argument will return the median, while 25 and 75 will return the first and third quartiles respectively. These three special values may be arithmetic means of two other values within the set. All other arguments will return a number from the data set.
 * If your Stats object is configured to use buckets and has store_data set to false, then the percentile value returned will be an approximation of the actual percentile based on the configured bucket_precision or buckets.
 * @param {number} n
 * @return {number}
 */
Stats.prototype.percentile = function(n) {};

/**
 * Range
 * The range() method tells you the minimum and maximum values of your data set. It returns an array of two values. The first is the lower bound and the second is the upper bound.
 * @return {!Array<number>}
 */
Stats.prototype.range = function() {};

/**
 * The distribution() method tells you how your data is distributed. You need to set the bucket_precision or buckets configuration options if you plan on using this method. It will then split your data into buckets based on the value of bucket_precision or buckets and tell you how many data points fall into each bucket. You can use this to plot a histogram of your data, or to compare it to commonly known distribution functions.
 * The return value is a sparse array of buckets with counts of datapoints per bucket. To save on memory, any empty buckets are undefined. You should treat an undefined bucket as if it had 0 datapoints.
 * @return {!Array<?>}
 */
Stats.prototype.distribution = function() {};

/**
 * Arithmetic Standard Deviation
 * Also commonly just called the Standard Deviation, with the symbol s. This tells you the spread of your data if it follows a normal (or close to normal) distribution, ie, the bell curve. fast-stats is really fast at calculating the standard deviation of a dataset
 * The arithmetic standard deviation is used in conjunction with the arithmetic mean to tell you the spread of your dataset: [amean-stddev, amean+stddev]. Note that you could also use 2 or 3 standard deviations for different spreads.
 * @return {number}
 */
Stats.prototype.stddev = function() {};

/**
 * Geometric Standard Deviation
 * The geometric standard deviation tells you the spread of your data if it follows a log-normal or exponential distribution. Use the gstddev() method to get at it.
 * @return {number}
 */
Stats.prototype.gstddev = function() {};

/**
 * 95% Confidence Margin of Error
 * The Margin of Error value tells you the range within which the real arithmetic mean of the population is likely to be with 95% confidence. Use the moe() method to get at it.
 * This value suggests that we are 95% certain that the real mean of the population is within 2.60 of the calculated arithmetic mean of 4.67. We could use this to find out the percent error in our sample. In this case there is a 55.71% error.
 * The margin of error is inversely proportional to the square root of the number of data points, so increasing the size of your sample will reduce the margin of error. It is good to strive for a margin of error of less than 5%.
 * @return {number}
 */
Stats.prototype.moe = function() {};

/**
 * Band-pass filtering
 * The band_pass() filter method returns a new Stats object with all its data points within the specified range. This method takes in three arguments. The first is the lower bound of the range, the second is the upper bound of the range. Both these arguments are required.
 * The third argument specifies whether the range is open or closed. An open range does not include the upper and lower bounds while a closed range includes them. If not specified (or set to false), the range is closed. If set to true the range is open.
 * Band pass filtering should be used if the range for your data is rigid and never changes.
 * @param {number} low
 * @param {number} high
 * @param {boolean=} open
 * @return {!Stats}
 */
Stats.prototype.band_pass = function(low, high, open) {};

/**
 * IQR Filtering
 * IQR, or Inter Quartile Range filtering filters data based on the spread of the data. It is much more adaptive to changes in data ranges. Use the iqr() method to IQR filter a dataset. The iqr() method does not accept any arguments.
 * In some cases, IQR filtering may not filter out anything. This can happen if the acceptable range is wider than the bounds of your dataset.
 * @return {!Stats}
 */
Stats.prototype.iqr = function() {};
