/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/retry/index.d.ts:
/**
 * @record
 * @struct
 */
function RetryOperation() {}

/**
 * Defines the function that is to be retried and executes it for the first time right away.
 * 
 * 
 * @param {?} callback
 * @param {?=} options
 * @return {void}
 */
RetryOperation.prototype.attempt = function(callback, options) {};

/**
 * Returns false when no error value is given, or the maximum amount of retries has been reached.
 * Otherwise it returns true, and retries the operation after the timeout for the current attempt number.
 * 
 * 
 * @param {!Error=} err
 * @return {boolean}
 */
RetryOperation.prototype.retry = function(err) {};

/**
 * The number of attempts it took to call the retrying function before it was successful.
 * 
 * @return {number}
 */
RetryOperation.prototype.attempts = function() {};

/**
 * A reference to the error object that occured most frequently.
 * Errors are compared using the error.message property.
 * 
 * @return {!Error}
 */
RetryOperation.prototype.mainError = function() {};

/**
 * Returns an array of all errors that have been passed to RetryOperation.retry() so far.
 * 
 * @return {!Array<!Error>}
 */
RetryOperation.prototype.errors = function() {};

/**
 * Stops the operation being retried. Useful for aborting the operation on a fatal error etc.
 * @return {void}
 */
RetryOperation.prototype.stop = function() {};
/**
 * @record
 * @struct
 */
function AttemptOptions() {}
 /** @type {number} */
AttemptOptions.prototype.timeout;

/**
 * @return {void}
 */
AttemptOptions.prototype.callback = function() {};

/**
 * Create a new RetryOperation object.
 * 
 * 
 * @param {?=} options
 * @return {?}
 */
function operation(options) {}
/**
 * @record
 * @struct
 */
function OperationOptions() {}
 /** @type {number} */
OperationOptions.prototype.retries;
 /** @type {number} */
OperationOptions.prototype.factor;
 /** @type {number} */
OperationOptions.prototype.minTimeout;
 /** @type {number} */
OperationOptions.prototype.maxTimeout;
 /** @type {boolean} */
OperationOptions.prototype.randomize;
 /** @type {boolean} */
OperationOptions.prototype.forever;
 /** @type {boolean} */
OperationOptions.prototype.unref;

/**
 * Get an array with timeouts and their return values in milliseconds.
 * 
 * 
 * @param {?=} options
 * @return {!Array<number>}
 */
function timeouts(options) {}
/**
 * @record
 * @struct
 */
function TimeoutsOptions() {}
 /** @type {number} */
TimeoutsOptions.prototype.retries;
 /** @type {number} */
TimeoutsOptions.prototype.factor;
 /** @type {number} */
TimeoutsOptions.prototype.minTimeout;
 /** @type {number} */
TimeoutsOptions.prototype.maxTimeout;
 /** @type {boolean} */
TimeoutsOptions.prototype.randomize;

/**
 * Create a new timeout (in milliseconds) based on the given parameters.
 * 
 * 
 * @param {number} attempt
 * @param {?=} options
 * @return {number}
 */
function createTimeout(attempt, options) {}
/**
 * @record
 * @struct
 */
function CreateTimeoutOptions() {}
 /** @type {number} */
CreateTimeoutOptions.prototype.factor;
 /** @type {number} */
CreateTimeoutOptions.prototype.minTimeout;
 /** @type {number} */
CreateTimeoutOptions.prototype.maxTimeout;
 /** @type {boolean} */
CreateTimeoutOptions.prototype.randomize;

/**
 * Wrap all functions of the object with retry.
 * 
 * 
 * @param {!Object} object
 * @param {?=} options
 * @param {!Array<string>=} methods
 * @return {void}
 */
function wrap(object, options, methods) {}
/**
 * @record
 * @struct
 */
function WrapOptions() {}
 /** @type {number} */
WrapOptions.prototype.retries;
 /** @type {number} */
WrapOptions.prototype.factor;
 /** @type {number} */
WrapOptions.prototype.minTimeout;
 /** @type {number} */
WrapOptions.prototype.maxTimeout;
 /** @type {boolean} */
WrapOptions.prototype.randomize;
 /** @type {boolean} */
WrapOptions.prototype.forever;
 /** @type {boolean} */
WrapOptions.prototype.unref;
