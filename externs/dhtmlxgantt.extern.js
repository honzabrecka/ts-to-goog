/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/dhtmlxgantt/index.d.ts:

/** @typedef {function(!Array<?>): ?} */
var GanttCallback;

/** @typedef {string} */
var GanttEventName;
/**
 * @record
 * @struct
 */
function GanttTemplates() {}

/**
 * specifies the format of dates that are set by means of API methods. Used to parse incoming dates
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
GanttTemplates.prototype.api_date = function(date) {};

/**
 * specifies the content of start date or end date columns in grid
 * @param {!Date} date the date which needs formatting
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.date_grid = function(date, task) {};

/**
 * specifies the date format of the time scale (X-Axis)
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
GanttTemplates.prototype.date_scale = function(date) {};

/**
 * specifies the text of tooltips that are displayed when the user creates a new dependency link
 * @param {(string|number)} from the id of the source task
 * @param {boolean} from_start <i>true</i>, if the link is being dragged from the start of the  source task, <i>false</i> - if <br> from the end of the task
 * @param {(string|number)} to the id of the target task( 'null' or 'undefined', if the target task isn't specified yet)
 * @param {boolean} to_start <i>true</i>, if the link is being dragged to the start of the target task, <i>false</i> - if <br> to the end of the task
 * @return {string}
 */
GanttTemplates.prototype.drag_link = function(from, from_start, to, to_start) {};

/**
 * specifies the CSS class that will be applied to the link receiver (pop-up circle near the task bar)
 * @param {(string|number)} from the id of the source task
 * @param {boolean} from_start <i>true</i>, if the link is being dragged from the start of the  source task, <i>false</i> - if <br> from the end of the task
 * @param {(string|number)} to the id of the target task( 'null' or 'undefined', if the target task isn't specified yet)
 * @param {boolean} to_start <i>true</i>, if the link is being dragged to the start of the target task, <i>false</i> - if <br> to the end of the task
 * @return {string}
 */
GanttTemplates.prototype.drag_link_class = function(from, from_start, to, to_start) {};

/**
 * specifies the custom content inserted before the labels of child items in the tree column
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.grid_blank = function(task) {};

/**
 * specifies the format of dates in the "Start time" column
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
GanttTemplates.prototype.grid_date_format = function(date) {};

/**
 * specifies the icon of child items in the tree column
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.grid_file = function(task) {};

/**
 * specifies the icon of parent items in the tree column
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.grid_folder = function(task) {};

/**
 * specifies the CSS class that will be applied to the headers of the table's columns
 * @param {string} columnName the column's name (as specified in the "name" property of the column object)
 * @param {?} column column object (as specified in the <i>gantt.config.columns</i> config)
 * @return {string}
 */
GanttTemplates.prototype.grid_header_class = function(columnName, column) {};

/**
 * specifies the indent  of the child items in a branch (in the tree column)
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.grid_indent = function(task) {};

/**
 * specifies the icon of the open/close sign in the tree column
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.grid_open = function(task) {};

/**
 * specifies the CSS class that will be applied to a grid row
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.grid_row_class = function(start, end, task) {};

/**
 * specifies the CSS class that will be applied to a link
 * @param {?} link the link object
 * @return {string}
 */
GanttTemplates.prototype.link_class = function(link) {};

/**
 * specifies the text in the header of the link's "delete" confirm window
 * @param {?} link the link object
 * @return {string}
 */
GanttTemplates.prototype.link_description = function(link) {};

/**
 * specifies the text in the completed part of the task bar
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.progress_text = function(start, end, task) {};

/**
 * specifies the CSS class that will be applied to  the pop-up edit form
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {void}
 */
GanttTemplates.prototype.quick_info_class = function(start, end, task) {};

/**
 * specifies the content of the pop-up edit form
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.quick_info_content = function(start, end, task) {};

/**
 * specifies the date of the pop-up edit form
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when  a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.quick_info_date = function(start, end, task) {};

/**
 * specifies the title of the pop-up edit form
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.quick_info_title = function(start, end, task) {};

/**
 * specifies the CSS class that will be applied to cells of the time scale of the timeline area
 * @param {!Date} date the date of a cell
 * @return {string}
 */
GanttTemplates.prototype.scale_cell_class = function(date) {};

/**
 * specifies the CSS class that will be applied to the time scale
 * @param {?} scale the scale's configuration object
 * @return {string}
 */
GanttTemplates.prototype.scale_row_class = function(scale) {};

/**
 * specifies the CSS class that will be applied to the cells of the timeline area
 * @param {!Date} item the task object assigned to the row
 * @param {!Date} date the date of a cell
 * @return {string}
 */
GanttTemplates.prototype.task_cell_class = function(item, date) {};

/**
 * specifies the CSS class that will be applied to task bars
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.task_class = function(start, end, task) {};

/**
 * specifies the date format of the label in the 'Time period' section of the lightbox
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
GanttTemplates.prototype.task_date = function(date) {};

/**
 * specifies the CSS class that will be applied to the row of the timeline area
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.task_row_class = function(start, end, task) {};

/**
 * specifies the text in the task bars and the header of the lightbox
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.task_text = function(start, end, task) {};

/**
 * specifies the date period in the header of the lightbox
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.task_time = function(start, end, task) {};

/**
 * specifies the dates of unscheduled tasks
 * @param {?} task the task object
 * @return {void}
 */
GanttTemplates.prototype.task_unscheduled_time = function(task) {};

/**
 * specifies the format of the drop-down time selector in the lightbox
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
GanttTemplates.prototype.time_picker = function(date) {};

/**
 * specifies the format of start and end dates displayed in the tooltip
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
GanttTemplates.prototype.tooltip_date_format = function(date) {};

/**
 * specifies the text of tooltips
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.tooltip_text = function(start, end, task) {};

/**
 * a string from an XML file is converted into a date object in conformity with this template
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
GanttTemplates.prototype.xml_date = function(date) {};

/**
 * a date object is converted into a string in conformity with this template. Used to send data back to the server
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
GanttTemplates.prototype.xml_format = function(date) {};

/**
 * specifies the text assigned to tasks bars on the right side
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.rightside_text = function(start, end, task) {};

/**
 * specifies the text assigned to tasks bars on the left side
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @param {?} task the task object
 * @return {string}
 */
GanttTemplates.prototype.leftside_text = function(start, end, task) {};

/**
 * specifies the lightbox's header
 * @param {!Date} start_date the date when a task is scheduled to begin
 * @param {!Date} end_date the date when a task is scheduled to be completed
 * @param {?} task the task's object
 * @return {string}
 */
GanttTemplates.prototype.lightbox_header = function(start_date, end_date, task) {};
/**
 * @record
 * @struct
 */
function GanttConfigOptions() {}
 /** @type {string} */
GanttConfigOptions.prototype.api_date;
 /** @type {boolean} */
GanttConfigOptions.prototype.auto_scheduling;
 /** @type {boolean} */
GanttConfigOptions.prototype.auto_scheduling_descendant_links;
 /** @type {boolean} */
GanttConfigOptions.prototype.auto_scheduling_initial;
 /** @type {boolean} */
GanttConfigOptions.prototype.auto_scheduling_strict;
 /** @type {boolean} */
GanttConfigOptions.prototype.autofit;
 /** @type {(string|boolean)} */
GanttConfigOptions.prototype.autosize;
 /** @type {number} */
GanttConfigOptions.prototype.autosize_min_width;
 /** @type {boolean} */
GanttConfigOptions.prototype.branch_loading;
 /** @type {!Array<?>} */
GanttConfigOptions.prototype.buttons_left;
 /** @type {!Array<?>} */
GanttConfigOptions.prototype.buttons_right;
 /** @type {!Array<?>} */
GanttConfigOptions.prototype.columns;
 /** @type {boolean} */
GanttConfigOptions.prototype.correct_work_time;
 /** @type {string} */
GanttConfigOptions.prototype.date_grid;
 /** @type {string} */
GanttConfigOptions.prototype.date_scale;
 /** @type {boolean} */
GanttConfigOptions.prototype.details_on_create;
 /** @type {boolean} */
GanttConfigOptions.prototype.details_on_dblclick;
 /** @type {boolean} */
GanttConfigOptions.prototype.drag_lightbox;
 /** @type {boolean} */
GanttConfigOptions.prototype.drag_links;
 /** @type {?} */
GanttConfigOptions.prototype.drag_mode;
 /** @type {boolean} */
GanttConfigOptions.prototype.drag_move;
 /** @type {boolean} */
GanttConfigOptions.prototype.drag_progress;
 /** @type {boolean} */
GanttConfigOptions.prototype.drag_resize;
 /** @type {number} */
GanttConfigOptions.prototype.duration_step;
 /** @type {string} */
GanttConfigOptions.prototype.duration_unit;
 /** @type {string} */
GanttConfigOptions.prototype.editable_property;
 /** @type {!Date} */
GanttConfigOptions.prototype.end_date;
 /** @type {boolean} */
GanttConfigOptions.prototype.fit_tasks;
 /** @type {boolean} */
GanttConfigOptions.prototype.grid_resize;
 /** @type {string} */
GanttConfigOptions.prototype.grid_resizer_attribute;
 /** @type {string} */
GanttConfigOptions.prototype.grid_resizer_column_attribute;
 /** @type {number} */
GanttConfigOptions.prototype.grid_width;
 /** @type {boolean} */
GanttConfigOptions.prototype.highlight_critical_path;
 /** @type {boolean} */
GanttConfigOptions.prototype.inherit_scale_class;
 /** @type {boolean} */
GanttConfigOptions.prototype.initial_scroll;
 /** @type {boolean} */
GanttConfigOptions.prototype.keep_grid_width;
 /** @type {string} */
GanttConfigOptions.prototype.layer_attribute;
 /** @type {?} */
GanttConfigOptions.prototype.lightbox;
 /** @type {number} */
GanttConfigOptions.prototype.lightbox_additional_height;
 /** @type {number} */
GanttConfigOptions.prototype.link_arrow_size;
 /** @type {string} */
GanttConfigOptions.prototype.link_attribute;
 /** @type {number} */
GanttConfigOptions.prototype.link_line_width;
 /** @type {number} */
GanttConfigOptions.prototype.link_wrapper_width;
 /** @type {?} */
GanttConfigOptions.prototype.links;
 /** @type {number} */
GanttConfigOptions.prototype.min_column_width;
 /** @type {number} */
GanttConfigOptions.prototype.min_duration;
 /** @type {number} */
GanttConfigOptions.prototype.min_grid_column_width;
 /** @type {boolean} */
GanttConfigOptions.prototype.multiselect;
 /** @type {boolean} */
GanttConfigOptions.prototype.multiselect_one_level;
 /** @type {boolean} */
GanttConfigOptions.prototype.open_tree_initially;
 /** @type {boolean} */
GanttConfigOptions.prototype.order_branch;
 /** @type {boolean} */
GanttConfigOptions.prototype.order_branch_free;
 /** @type {boolean} */
GanttConfigOptions.prototype.preserve_scroll;
 /** @type {boolean} */
GanttConfigOptions.prototype.prevent_default_scroll;
 /** @type {boolean} */
GanttConfigOptions.prototype.quick_info_detached;
 /** @type {!Array<?>} */
GanttConfigOptions.prototype.quickinfo_buttons;
 /** @type {boolean} */
GanttConfigOptions.prototype.readonly;
 /** @type {string} */
GanttConfigOptions.prototype.readonly_property;
 /** @type {boolean} */
GanttConfigOptions.prototype.redo;
 /** @type {(string|number)} */
GanttConfigOptions.prototype.root_id;
 /** @type {boolean} */
GanttConfigOptions.prototype.round_dnd_dates;
 /** @type {number} */
GanttConfigOptions.prototype.row_height;
 /** @type {number} */
GanttConfigOptions.prototype.scale_height;
 /** @type {boolean} */
GanttConfigOptions.prototype.scale_offset_minimal;
 /** @type {string} */
GanttConfigOptions.prototype.scale_unit;
 /** @type {boolean} */
GanttConfigOptions.prototype.scroll_on_click;
 /** @type {boolean} */
GanttConfigOptions.prototype.select_task;
 /** @type {boolean} */
GanttConfigOptions.prototype.server_utc;
 /** @type {boolean} */
GanttConfigOptions.prototype.show_chart;
 /** @type {boolean} */
GanttConfigOptions.prototype.show_errors;
 /** @type {boolean} */
GanttConfigOptions.prototype.show_grid;
 /** @type {boolean} */
GanttConfigOptions.prototype.show_links;
 /** @type {boolean} */
GanttConfigOptions.prototype.show_markers;
 /** @type {boolean} */
GanttConfigOptions.prototype.show_progress;
 /** @type {boolean} */
GanttConfigOptions.prototype.show_quick_info;
 /** @type {boolean} */
GanttConfigOptions.prototype.show_task_cells;
 /** @type {boolean} */
GanttConfigOptions.prototype.show_unscheduled;
 /** @type {boolean} */
GanttConfigOptions.prototype.skip_off_time;
 /** @type {boolean} */
GanttConfigOptions.prototype.smart_rendering;
 /** @type {boolean} */
GanttConfigOptions.prototype.sort;
 /** @type {!Date} */
GanttConfigOptions.prototype.start_date;
 /** @type {boolean} */
GanttConfigOptions.prototype.start_on_monday;
 /** @type {boolean} */
GanttConfigOptions.prototype.static_background;
 /** @type {number} */
GanttConfigOptions.prototype.step;
 /** @type {!Array<?>} */
GanttConfigOptions.prototype.subscales;
 /** @type {string} */
GanttConfigOptions.prototype.task_attribute;
 /** @type {string} */
GanttConfigOptions.prototype.task_date;
 /** @type {number} */
GanttConfigOptions.prototype.task_height;
 /** @type {number} */
GanttConfigOptions.prototype.task_scroll_offset;
 /** @type {string} */
GanttConfigOptions.prototype.time_picker;
 /** @type {number} */
GanttConfigOptions.prototype.time_step;
 /** @type {number} */
GanttConfigOptions.prototype.tooltip_hide_timeout;
 /** @type {number} */
GanttConfigOptions.prototype.tooltip_offset_x;
 /** @type {number} */
GanttConfigOptions.prototype.tooltip_offset_y;
 /** @type {number} */
GanttConfigOptions.prototype.tooltip_timeout;
 /** @type {(string|boolean)} */
GanttConfigOptions.prototype.touch;
 /** @type {(number|boolean)} */
GanttConfigOptions.prototype.touch_drag;
 /** @type {boolean} */
GanttConfigOptions.prototype.touch_feedback;
 /** @type {?} */
GanttConfigOptions.prototype.type_renderers;
 /** @type {?} */
GanttConfigOptions.prototype.types;
 /** @type {boolean} */
GanttConfigOptions.prototype.undo;
 /** @type {?} */
GanttConfigOptions.prototype.undo_actions;
 /** @type {number} */
GanttConfigOptions.prototype.undo_steps;
 /** @type {?} */
GanttConfigOptions.prototype.undo_types;
 /** @type {boolean} */
GanttConfigOptions.prototype.work_time;
 /** @type {string} */
GanttConfigOptions.prototype.xml_date;
/**
 * @record
 * @struct
 */
function GanttDateHelpers() {}

/**
 * @param {!Date} origin
 * @param {number} count
 * @param {string} unit
 * @return {!Date}
 */
GanttDateHelpers.prototype.add = function(origin, count, unit) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
GanttDateHelpers.prototype.copy = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
GanttDateHelpers.prototype.date_part = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
GanttDateHelpers.prototype.time_part = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
GanttDateHelpers.prototype.day_start = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
GanttDateHelpers.prototype.month_start = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
GanttDateHelpers.prototype.week_start = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
GanttDateHelpers.prototype.year_start = function(origin) {};

/**
 * @param {!Date} origin
 * @return {number}
 */
GanttDateHelpers.prototype.getISOWeek = function(origin) {};

/**
 * @param {!Date} origin
 * @return {number}
 */
GanttDateHelpers.prototype.getUTCISOWeek = function(origin) {};

/**
 * @param {string} format
 * @return {?}
 */
GanttDateHelpers.prototype.date_to_str = function(format) {};

/**
 * @param {string} format
 * @return {?}
 */
GanttDateHelpers.prototype.str_to_date = function(format) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
GanttDateHelpers.prototype.convert_to_utc = function(origin) {};

/**
 * @param {number} value
 * @return {string}
 */
GanttDateHelpers.prototype.to_fixed = function(value) {};
/**
 * @record
 * @struct
 */
function GanttHotkeys() {}
 /** @type {number} */
GanttHotkeys.prototype.edit_save;
 /** @type {number} */
GanttHotkeys.prototype.edit_cancel;
/**
 * @record
 * @struct
 */
function GanttLocaleDate() {}
 /** @type {!Array<string>} */
GanttLocaleDate.prototype.month_full;
 /** @type {!Array<string>} */
GanttLocaleDate.prototype.month_short;
 /** @type {!Array<string>} */
GanttLocaleDate.prototype.day_full;
 /** @type {!Array<string>} */
GanttLocaleDate.prototype.day_short;
/**
 * @record
 * @struct
 */
function GanttLocaleLabels() {}
 /** @type {string} */
GanttLocaleLabels.prototype.new_task;
 /** @type {string} */
GanttLocaleLabels.prototype.icon_save;
 /** @type {string} */
GanttLocaleLabels.prototype.icon_cancel;
 /** @type {string} */
GanttLocaleLabels.prototype.icon_details;
 /** @type {string} */
GanttLocaleLabels.prototype.icon_edit;
 /** @type {string} */
GanttLocaleLabels.prototype.icon_delete;
 /** @type {string} */
GanttLocaleLabels.prototype.confirm_closing;
 /** @type {string} */
GanttLocaleLabels.prototype.confirm_deleting;
 /** @type {string} */
GanttLocaleLabels.prototype.section_description;
 /** @type {string} */
GanttLocaleLabels.prototype.section_time;
 /** @type {string} */
GanttLocaleLabels.prototype.confirm_link_deleting;
 /** @type {string} */
GanttLocaleLabels.prototype.link_from;
 /** @type {string} */
GanttLocaleLabels.prototype.link_to;
 /** @type {string} */
GanttLocaleLabels.prototype.link_start;
 /** @type {string} */
GanttLocaleLabels.prototype.link_end;
 /** @type {string} */
GanttLocaleLabels.prototype.minutes;
 /** @type {string} */
GanttLocaleLabels.prototype.hours;
 /** @type {string} */
GanttLocaleLabels.prototype.days;
 /** @type {string} */
GanttLocaleLabels.prototype.weeks;
 /** @type {string} */
GanttLocaleLabels.prototype.months;
 /** @type {string} */
GanttLocaleLabels.prototype.years;
/**
 * @record
 * @struct
 */
function GanttLocale() {}
 /** @type {!GanttLocaleDate} */
GanttLocale.prototype.date;
 /** @type {!GanttLocaleLabels} */
GanttLocale.prototype.labels;
/**
 * @record
 * @struct
 */
function GanttEnterprise() {}

/**
 * Creates a new instance of Gantt
 * @return {!GanttStatic}
 */
GanttEnterprise.prototype.getGanttInstance = function() {};
/**
 * @record
 * @struct
 */
function GanttStatic() {}
 /** @type {!GanttTemplates} */
GanttStatic.prototype.templates;
 /** @type {!GanttConfigOptions} */
GanttStatic.prototype.config;
 /** @type {!GanttDateHelpers} */
GanttStatic.prototype.date;
 /** @type {!GanttHotkeys} */
GanttStatic.prototype.keys;
 /** @type {string} */
GanttStatic.prototype.skin;
 /** @type {string} */
GanttStatic.prototype.version;
 /** @type {!GanttLocale} */
GanttStatic.prototype.locale;
 /** @type {?} */
GanttStatic.prototype.$click;

/**
 * adds a new dependency link
 * @param {?} link the link object
 * @return {(string|number)}
 */
GanttStatic.prototype.addLink = function(link) {};

/**
 * displayes an additional layer with custom elements for a link in the timeline area
 * @param {?} func a render function  or a config object
 * @return {string}
 */
GanttStatic.prototype.addLinkLayer = function(func) {};

/**
 * adds a marker to the timeline area
 * @param {?} marker the marker's configuration object
 * @return {string}
 */
GanttStatic.prototype.addMarker = function(marker) {};

/**
 * adds a new task
 * @param {?} task the task object
 * @param {string} parent the parent's id
 * @param {number=} index optional, the position the task will be added into (0 or greater)
 * @return {(string|number)}
 */
GanttStatic.prototype.addTask = function(task, parent, index) {};

/**
 * displayes an additional layer with custom elements for a task in the timeline area
 * @param {?} func a render function  or a config object
 * @return {string}
 */
GanttStatic.prototype.addTaskLayer = function(func) {};

/**
 * calls an alert message box
 * @param {?} config the alert box's configuration
 * @return {void}
 */
GanttStatic.prototype.alert = function(config) {};

/**
 * if the specified expression is false, an errorMessage is shown in the red popup at the top right corner of the screen
 * @param {boolean} expression true to assert the expression, false - if assertion fails
 * @param {string} errorMessage an error message that will be shown in the red popup
 * @return {void}
 */
GanttStatic.prototype.assert = function(expression, errorMessage) {};

/**
 * attaches the handler to an inner event of dhtmlxGantt
 * @param {string} name the event's name, case-insensitive
 * @param {function(!Array<?>): ?} handler the handler function
 * @return {string}
 */
GanttStatic.prototype.attachEvent = function(name, handler) {};

/**
 * recalculates the schedule of the project
 * @return {void}
 */
GanttStatic.prototype.autoSchedule = function() {};

/**
 * updates multiple tasks/links at once
 * @param {function(!Array<?>): ?} callback the callback function
 * @return {void}
 */
GanttStatic.prototype.batchUpdate = function(callback) {};

/**
 * creates a new function that, when called, has its <i>this</i> keyword set to the provided value
 * @param {function(!Array<?>): ?} method the target function
 * @param {?} thisArg the value to be passed as the <i>this</i> parameter to the target function when the bound function is called
 * @return {function(!Array<?>): ?}
 */
GanttStatic.prototype.bind = function(method, thisArg) {};

/**
 * calculates the duration of a task
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {!Date} end the date when a task is scheduled to be completed
 * @return {number}
 */
GanttStatic.prototype.calculateDuration = function(start, end) {};

/**
 * calculates the end date of a task
 * @param {!Date} start the date when a task is scheduled to begin
 * @param {number} duration the duration of a task
 * @param {string} unit the time unit of the duration
 * @return {!Date}
 */
GanttStatic.prototype.calculateEndDate = function(start, duration, unit) {};

/**
 * calculates the level of a task
 * @param {?} task the task's object
 * @return {number}
 */
GanttStatic.prototype.calculateTaskLevel = function(task) {};

/**
 * calls an inner event
 * @param {string} name the event's name, case-insensitive
 * @param {!Array<?>} params an array of the event-related data
 * @return {boolean}
 */
GanttStatic.prototype.callEvent = function(name, params) {};

/**
 * changes the name of the lighbox's structure defined for  of the task
 * @param {(string|number)} id the task id
 * @return {void}
 */
GanttStatic.prototype.changeLightboxType = function(id) {};

/**
 * changes the link's id
 * @param {(string|number)} id the current link's id
 * @param {(string|number)} new_id the new link's id
 * @return {void}
 */
GanttStatic.prototype.changeLinkId = function(id, new_id) {};

/**
 * changes the task's id
 * @param {(string|number)} id the current task's id
 * @param {(string|number)} new_id the new task's id
 * @return {void}
 */
GanttStatic.prototype.changeTaskId = function(id, new_id) {};

/**
 * checks whether an event has some handler(s) specified
 * @param {string} name the event's name
 * @return {boolean}
 */
GanttStatic.prototype.checkEvent = function(name) {};

/**
 * removes all tasks from the Gantt chart
 * @return {void}
 */
GanttStatic.prototype.clearAll = function() {};

/**
 * closes the branch with the specified id
 * @param {(string|number)} id the branch id
 * @return {void}
 */
GanttStatic.prototype.close = function(id) {};

/**
 * collapses gantt from the full screen mode to the normal mode
 * @return {void}
 */
GanttStatic.prototype.collapse = function() {};

/**
 * calls a confirm message box
 * @param {?} config the confirm box's configuration
 * @return {void}
 */
GanttStatic.prototype.confirm = function(config) {};

/**
 * creates a deep copy of provided object
 * @param {?} task the object that needs to be copied
 * @return {?}
 */
GanttStatic.prototype.copy = function(task) {};

/**
 * recalculates the task duration in the work time
 * @param {?} task the task's object
 * @return {void}
 */
GanttStatic.prototype.correctTaskWorkTime = function(task) {};

/**
 * adds a new task and opens the lightbox to confirm
 * @param {?} task the task object
 * @param {string} parent the parent's id
 * @param {number=} index optional, the position the task will be added into (0 or greater)
 * @return {(string|number)}
 */
GanttStatic.prototype.createTask = function(task, parent, index) {};

/**
 * dataProcessor constructor
 * @param {string} url url to the data feed
 * @return {void}
 */
GanttStatic.prototype.dataProcessor = function(url) {};

/**
 * returns the date of the specified horizontal position in the chart area
 * @param {number} pos the relative horizontal position you want to know the date of
 * @return {!Date}
 */
GanttStatic.prototype.dateFromPos = function(pos) {};

/**
 * returns false if the provided argument is undefined, otherwise true
 * @param {?} task the object that should be checked
 * @return {boolean}
 */
GanttStatic.prototype.defined = function(task) {};

/**
 * deletes the specified dependency link
 * @param {(string|number)} id the dependency link's id
 * @return {void}
 */
GanttStatic.prototype.deleteLink = function(id) {};

/**
 * deletes the specified marker
 * @param {string} markerId the marker's id
 * @return {void}
 */
GanttStatic.prototype.deleteMarker = function(markerId) {};

/**
 * deletes the specified  task
 * @param {string} id the task's id
 * @return {void}
 */
GanttStatic.prototype.deleteTask = function(id) {};

/**
 * detaches all events from dhtmlxGantt (both custom and inner)
 * @return {void}
 */
GanttStatic.prototype.detachAllEvents = function() {};

/**
 * detaches a handler from an event (which was attached before by the attachEvent() method)
 * @param {string} id the event's id
 * @return {void}
 */
GanttStatic.prototype.detachEvent = function(id) {};

/**
 * iterates over all selected tasks in the Gantt chart
 * @param {function(!Array<?>): ?} code a function that will iterate over tasks. Takes a task id as a parameter
 * @return {void}
 */
GanttStatic.prototype.eachSelectedTask = function(code) {};

/**
 * iterates over specified tasks in the Gantt chart
 * @param {function(!Array<?>): ?} code a function that will iterate over tasks. Takes a task object as a parameter
 * @param {(string|number)=} parent the parent id. If specified, the function will iterate over childs of the <br> specified parent
 * @param {?=} master the object, that 'this'  will refer to
 * @return {void}
 */
GanttStatic.prototype.eachTask = function(code, parent, master) {};

/**
 * attaches an event handler to an HTML element
 * @param {(string|!HTMLElement)} node the HTML node or its id
 * @param {string} event the name of an HTML event (without the 'on' prefix)
 * @param {function(!Array<?>): ?} handler the event handler
 * @param {?=} master an object that the <i>this</i> keyword refers to
 * @return {string}
 */
GanttStatic.prototype.event = function(node, event, handler, master) {};

/**
 * removes an event handler from an HTML element
 * @param {string} id the id of an event handler
 * @return {void}
 */
GanttStatic.prototype.eventRemove = function(id) {};

/**
 * expands gantt to the full screen mode
 * @return {void}
 */
GanttStatic.prototype.expand = function() {};

/**
 * returns the 1st-level child tasks of the specified parent branch
 * @param {(string|number)} id the parent branch's id
 * @return {!Array<?>}
 */
GanttStatic.prototype.getChildren = function(id) {};

/**
 * returns the closest working time
 * @param {?} config the configuration object
 * @return {!Date}
 */
GanttStatic.prototype.getClosestWorkTime = function(config) {};

/**
 * get the index of a task in the tree
 * @param {(string|number)} id the task id
 * @return {void}
 */
GanttStatic.prototype.getGlobalTaskIndex = function(id) {};

/**
 * gets the configuration object of a column
 * @param {string} name the column's name
 * @return {?}
 */
GanttStatic.prototype.getGridColumn = function(name) {};

/**
 * gets columns of the Gantt chart
 * @return {!Array<?>}
 */
GanttStatic.prototype.getGridColumns = function() {};

/**
 * gets the label of a select control in the lightbox
 * @param {string} property the name of a data property that the control is mapped to
 * @param {(string|number)} key the option's id. This parameter is compared with the task's data property to <br> assign the select's option to the task
 * @return {void}
 */
GanttStatic.prototype.getLabel = function(property, key) {};

/**
 * returns the id of the last selected task
 * @return {(string|number)}
 */
GanttStatic.prototype.getLastSelectedTask = function() {};

/**
 * gets the lightbox's HTML object element
 * @return {!HTMLElement}
 */
GanttStatic.prototype.getLightbox = function() {};

/**
 * returns the object of the lightbox's section
 * @param {string} name the name of the section
 * @return {?}
 */
GanttStatic.prototype.getLightboxSection = function(name) {};

/**
 * returns the name of the active lighbox's structure
 * @return {string}
 */
GanttStatic.prototype.getLightboxType = function() {};

/**
 * returns values of the lightbox's sections
 * @return {?}
 */
GanttStatic.prototype.getLightboxValues = function() {};

/**
 * returns the dependency link object by the specified id
 * @param {(string|number)} id the link id
 * @return {?}
 */
GanttStatic.prototype.getLink = function(id) {};

/**
 * returns the number of all dependency links presented in the Gantt chart
 * @return {number}
 */
GanttStatic.prototype.getLinkCount = function() {};

/**
 * returns the HTML element of the specified dependency link
 * @param {(string|number)} id the link id
 * @return {!HTMLElement}
 */
GanttStatic.prototype.getLinkNode = function(id) {};

/**
 * returns all links presented in the Gantt chart
 * @return {!Array<?>}
 */
GanttStatic.prototype.getLinks = function() {};

/**
 * gets the marker's object
 * @param {string} markerId the marker's id
 * @return {?}
 */
GanttStatic.prototype.getMarker = function(markerId) {};

/**
 * returns the id of the next item (no matter what the level of nesting is: the same or different)
 * @param {(string|number)} id the task id
 * @return {(string|number)}
 */
GanttStatic.prototype.getNext = function(id) {};

/**
 * returns the id of the next task of the same level
 * @param {(string|number)} id the task id
 * @return {(string|number)}
 */
GanttStatic.prototype.getNextSibling = function(id) {};

/**
 * returns the id of the parent task
 * @param {(string|number)} id the task id
 * @return {(string|number)}
 */
GanttStatic.prototype.getParent = function(id) {};

/**
 * returns the id of the previous item (no matter what the level of nesting is: the same or different)
 * @param {(string|number)} id the task id
 * @return {(string|number)}
 */
GanttStatic.prototype.getPrev = function(id) {};

/**
 * returns the id of the previous task of the same level
 * @param {(string|number)} id the task id
 * @return {(string|number)}
 */
GanttStatic.prototype.getPrevSibling = function(id) {};

/**
 * returns the stack of stored redo commands
 * @return {!Array<?>}
 */
GanttStatic.prototype.getRedoStack = function() {};

/**
 * returns the scroll position
 * @return {?}
 */
GanttStatic.prototype.getScrollState = function() {};

/**
 * returns the id of the selected task
 * @return {(string|number)}
 */
GanttStatic.prototype.getSelectedId = function() {};

/**
 * returns an array of the currently selected tasks
 * @return {!Array<?>}
 */
GanttStatic.prototype.getSelectedTasks = function() {};

/**
 * returns siblings of the specified  task (including itself)
 * @param {(string|number)} id the task id
 * @return {!Array<?>}
 */
GanttStatic.prototype.getSiblings = function(id) {};

/**
 * checks how much time (in the current duration unit) a task has before it starts to affect other tasks
 * @param {?} task1 the object of the 1st task to check the slack for
 * @param {?} task2 the object of the 2nd task to check the slack for
 * @return {(string|number)}
 */
GanttStatic.prototype.getSlack = function(task1, task2) {};

/**
 * gets the current state of the Gantt chart
 * @return {?}
 */
GanttStatic.prototype.getState = function() {};

/**
 * calculates the combined start/end dates of tasks nested in a project or another task
 * @param {(string|number)=} task_id the task's id, api/gantt_root_id_config.md will be used if not specified
 * @return {?}
 */
GanttStatic.prototype.getSubtaskDates = function(task_id) {};

/**
 * returns the task object
 * @param {(string|number)} id the task id
 * @return {?}
 */
GanttStatic.prototype.getTask = function(id) {};

/**
 * returns a collection of tasks which occur during the specified period
 * @param {!Date=} from the start date of the period
 * @param {!Date=} to the end date of the period
 * @return {!Array<?>}
 */
GanttStatic.prototype.getTaskByTime = function(from, to) {};

/**
 * gets the number of tasks that are currently loaded in the gantt
 * @return {number}
 */
GanttStatic.prototype.getTaskCount = function() {};

/**
 * get the index of a task in the branch
 * @param {(string|number)} id the task id
 * @return {number}
 */
GanttStatic.prototype.getTaskIndex = function(id) {};

/**
 * returns the HTML element of the task bar
 * @param {(string|number)} id the task id
 * @return {!HTMLElement}
 */
GanttStatic.prototype.getTaskNode = function(id) {};

/**
 * calculates the position and size of the task's DOM element in the timeline area
 * @param {?} task the task object
 * @param {!Date} from the start date of the item
 * @param {!Date} to the end date of the item
 * @return {?}
 */
GanttStatic.prototype.getTaskPosition = function(task, from, to) {};

/**
 * returns the HTML element of the task row in the table
 * @param {(string|number)} id the task id
 * @return {!HTMLElement}
 */
GanttStatic.prototype.getTaskRowNode = function(id) {};

/**
 * gets the top position of the task's DOM element in the timeline area
 * @param {(string|number)} id the task's id
 * @return {number}
 */
GanttStatic.prototype.getTaskTop = function(id) {};

/**
 * returns the stack of stored undo commands
 * @return {!Array<?>}
 */
GanttStatic.prototype.getUndoStack = function() {};

/**
 * gets the number of tasks visible on the screen (those that are not collapsed)
 * @return {number}
 */
GanttStatic.prototype.getVisibleTaskCount = function() {};

/**
 * returns the working hours of the specified date
 * @param {!Date} date a date to check
 * @return {!Array<?>}
 */
GanttStatic.prototype.getWorkHours = function(date) {};

/**
 * groups tasks by the specified task's attribute
 * @param {?} config the grouping configuration object
 * @return {void}
 */
GanttStatic.prototype.groupBy = function(config) {};

/**
 * checks whether the specified item has child tasks
 * @param {(string|number)} id the task id
 * @return {boolean}
 */
GanttStatic.prototype.hasChild = function(id) {};

/**
 * hides the lightbox modal overlay that blocks interactions with the remaining screen
 * @param {!HTMLElement=} box an element to hide
 * @return {void}
 */
GanttStatic.prototype.hideCover = function(box) {};

/**
 * closes the lightbox if it's currently active
 * @return {void}
 */
GanttStatic.prototype.hideLightbox = function() {};

/**
 * hides the pop-up task form (if it's currently active)
 * @return {void}
 */
GanttStatic.prototype.hideQuickInfo = function() {};

/**
 * constructor. Initializes a dhtmlxGantt object
 * @param {(string|!HTMLElement)} container an HTML container ( or its id) where a dhtmlxGantt object will be initialized
 * @param {!Date=} from the start value of the time scale	(X&ndash;Axis)
 * @param {!Date=} to the end value of the time scale (X&ndash;Axis)
 * @return {void}
 */
GanttStatic.prototype.init = function(container, from, to) {};

/**
 * checks whether a task is a child of other task
 * @param {(string|number)} childId the id of a task that you want to check as a child
 * @param {(string|number)} parentId the id of a task that you want to check as a parent
 * @return {boolean}
 */
GanttStatic.prototype.isChildOf = function(childId, parentId) {};

/**
 * checks whether the specified link is critical
 * @param {?} link the link's object
 * @return {boolean}
 */
GanttStatic.prototype.isCriticalLink = function(link) {};

/**
 * checks whether the specified task is critical
 * @param {?} task the task's object
 * @return {boolean}
 */
GanttStatic.prototype.isCriticalTask = function(task) {};

/**
 * checks whether the specified link is correct
 * @param {?} link the link object
 * @return {boolean}
 */
GanttStatic.prototype.isLinkAllowed = function(link) {};

/**
 * checks whether the specified link exists
 * @param {(string|number)} id the link id
 * @return {boolean}
 */
GanttStatic.prototype.isLinkExists = function(id) {};

/**
 * checks whether the specified task is currently selected
 * @param {(string|number)} task the task's id
 * @return {boolean}
 */
GanttStatic.prototype.isSelectedTask = function(task) {};

/**
 * checks whether the specified task exists
 * @param {(string|number)} id the task id
 * @return {boolean}
 */
GanttStatic.prototype.isTaskExists = function(id) {};

/**
 * checks whether the specifies task is currently rendered in the Gantt chart
 * @param {(string|number)} id the task's id
 * @return {boolean}
 */
GanttStatic.prototype.isTaskVisible = function(id) {};

/**
 * checks if the task is unscheduled
 * @param {?} task the task's object
 * @return {boolean}
 */
GanttStatic.prototype.isUnscheduledTask = function(task) {};

/**
 * checks whether the specified date is working or not
 * @param {!Date} date a date to check
 * @param {string} timeunit a time unit: 'hour' or 'day'.<br> If not specified, the value of 'gantt.config.duration_unit'  is used
 * @return {boolean}
 */
GanttStatic.prototype.isWorkTime = function(date, timeunit) {};

/**
 * loads data to the gantt from an external data source
 * @param {string} url the server-side url (may be a static file or a server side script that outputs data)
 * @param {string=} type <i>('json', 'xml', 'oldxml')</i> the data type. The default value - <i>'json'</i>
 * @param {function(!Array<?>): ?=} callback the callback function
 * @return {void}
 */
GanttStatic.prototype.load = function(url, type, callback) {};

/**
 * gets the id of a task from the specified HTML event
 * @param {!Event} e a native event
 * @return {(string|number)}
 */
GanttStatic.prototype.locate = function(e) {};

/**
 * calls a message box of the specified type
 * @param {?} config the message box's configuration
 * @return {void}
 */
GanttStatic.prototype.message = function(config) {};

/**
 * adds properties of the 'source' object into the 'target' object
 * @param {?} target the target object
 * @param {?} source the source object
 * @param {boolean} force if true, properties of the 'source' will overwrite matching properties of the 'target', if there are any. If false, properties that already exist in the 'target' will be omitted
 * @return {void}
 */
GanttStatic.prototype.mixin = function(target, source, force) {};

/**
 * calls a modalbox
 * @param {?} config the modal box' configuration
 * @return {void}
 */
GanttStatic.prototype.modalbox = function(config) {};

/**
 * moves a task to a new position
 * @param {(string|number)} sid the id of the task to move
 * @param {number} tindex the index of the position that the task will be moved to <br> (the index within a branch)
 * @param {(string|number)=} parent the parent id. If specified, the <b>tindex</b> will  refer to the  index in the <br> <b>'parent'</b> branch
 * @return {void}
 */
GanttStatic.prototype.moveTask = function(sid, tindex, parent) {};

/**
 * opens the branch with the specified id
 * @param {(string|number)} id the branch id
 * @return {void}
 */
GanttStatic.prototype.open = function(id) {};

/**
 * loads data from a client-side resource
 * @param {?} url a string or object which represents data
 * @param {string=} type ( <i>'json', 'xml'</i> ) the data type. The default value - <i>'json'</i>
 * @return {void}
 */
GanttStatic.prototype.parse = function(url, type) {};

/**
 * gets the relative horizontal position of the specified date in the chart area
 * @param {!Date} date a date you want to know the position of
 * @return {void}
 */
GanttStatic.prototype.posFromDate = function(date) {};

/**
 * applies the reverted changes to the gantt once again
 * @return {void}
 */
GanttStatic.prototype.redo = function() {};

/**
 * refreshes data in the Gantt chart
 * @return {void}
 */
GanttStatic.prototype.refreshData = function() {};

/**
 * refreshes the specifies link
 * @param {(string|number)} id the link id
 * @return {void}
 */
GanttStatic.prototype.refreshLink = function(id) {};

/**
 * refreshes the task and its related links
 * @param {(string|number)} id the task id
 * @return {void}
 */
GanttStatic.prototype.refreshTask = function(id) {};

/**
 * removes the specified layer related to a link
 * @param {string} layerId a DOM element that will be displayed in the layer
 * @return {void}
 */
GanttStatic.prototype.removeLinkLayer = function(layerId) {};

/**
 * removes the specified layer related to a task
 * @param {string} layerId a DOM element that will be displayed in the layer
 * @return {void}
 */
GanttStatic.prototype.removeTaskLayer = function(layerId) {};

/**
 * renders the whole Gantt chart
 * @return {void}
 */
GanttStatic.prototype.render = function() {};

/**
 * updates all markers on the page
 * @return {void}
 */
GanttStatic.prototype.renderMarkers = function() {};

/**
 * removes the current lightbox's HTML object element
 * @return {void}
 */
GanttStatic.prototype.resetLightbox = function() {};

/**
 * re-calculates the duration of a project task depending on dates its childs
 * @param {?} task the task's object
 * @return {void}
 */
GanttStatic.prototype.resetProjectDates = function(task) {};

/**
 * re-calculates the skin's settings from the related attached skin CSS file
 * @return {void}
 */
GanttStatic.prototype.resetSkin = function() {};

/**
 * forces the lightbox to resize
 * @return {void}
 */
GanttStatic.prototype.resizeLightbox = function() {};

/**
 * rounds the specified date to the nearest date in the time scale
 * @param {!Date} date the Date object to round
 * @return {!Date}
 */
GanttStatic.prototype.roundDate = function(date) {};

/**
 * rounds the start and end task's dates to the nearest dates in the time scale
 * @param {?} task the task object
 * @return {void}
 */
GanttStatic.prototype.roundTaskDates = function(task) {};

/**
 * scrolls the Gantt container to the specified position
 * @param {number} x the value of the horizontal scroll or 'null' (to not display the horizontal scroll)
 * @param {number} y the value of the vertical scroll or 'null' (to not display the vertical scroll)
 * @return {void}
 */
GanttStatic.prototype.scrollTo = function(x, y) {};

/**
 * selects the specified task
 * @param {(string|number)} id the task id
 * @return {(string|number)}
 */
GanttStatic.prototype.selectTask = function(id) {};

/**
 * serializes the data into JSON or XML format
 * @param {string=} type the format that the data will be serialized into. <br> Possible values: 'json' (<i>default</i> ), 'xml'.
 * @return {void}
 */
GanttStatic.prototype.serialize = function(type) {};

/**
 * returns a list of options
 * @param {string} list_name the name of a list
 * @param {!Array<?>=} options an array of options
 * @return {void}
 */
GanttStatic.prototype.serverList = function(list_name, options) {};

/**
 * set the parent for a task
 * @param {(string|number)} task the task id
 * @param {(string|number)} pid the parent task id
 * @return {void}
 */
GanttStatic.prototype.setParent = function(task, pid) {};

/**
 * resizes the Gantt chart
 * @return {void}
 */
GanttStatic.prototype.setSizes = function() {};

/**
 * sets the working time for the Gantt chart
 * @param {?} config the configuration object of a time span
 * @return {void}
 */
GanttStatic.prototype.setWorkTime = function(config) {};

/**
 * shows the lightbox modal overlay that blocks interactions with the remaining screen
 * @param {!HTMLElement=} box an element to hide
 * @return {void}
 */
GanttStatic.prototype.showCover = function(box) {};

/**
 * scrolls the chart area to makes the specified date visible
 * @param {!Date} date the date to show in the chart
 * @return {void}
 */
GanttStatic.prototype.showDate = function(date) {};

/**
 * opens the lightbox for the specified task
 * @param {(string|number)} id the task id
 * @return {void}
 */
GanttStatic.prototype.showLightbox = function(id) {};

/**
 * displays the pop-up task form for the specified task
 * @param {(string|number)} id the task id
 * @return {void}
 */
GanttStatic.prototype.showQuickInfo = function(id) {};

/**
 * makes the specified task visible on the screen
 * @param {(string|number)} id the task id
 * @return {void}
 */
GanttStatic.prototype.showTask = function(id) {};

/**
 * sorts the tasks in the grid
 * @param {(string|function(!Array<?>): ?)} field the name of the column that the  grid will be sorted by or a custom <br> sorting function
 * @param {boolean=} desc specifies the sorting direction: <i>true</i> - descending sort and <i>false</i> - ascending<br> sort. By default, <i>false</i>
 * @param {(string|number)=} parent the id of the parent task. Specify the parameter if you want to sort tasks only in <br> the branch of the specified parent.
 * @param {boolean=} silent specifies whether rendering shall be invoked after reordering items
 * @return {void}
 */
GanttStatic.prototype.sort = function(field, desc, parent, silent) {};

/**
 * selects the specified task if it was unselected and vice versa
 * @param {(string|number)} task the task's id
 * @return {void}
 */
GanttStatic.prototype.toggleTaskSelection = function(task) {};

/**
 * returns a unique id
 * @return {number}
 */
GanttStatic.prototype.uid = function() {};

/**
 * reverts the changes made in the gantt
 * @return {void}
 */
GanttStatic.prototype.undo = function() {};

/**
 * removes selection from the selected task
 * @return {void}
 */
GanttStatic.prototype.unselectTask = function() {};

/**
 * updates the specified collection with new options
 * @param {string} collection the name of the collection to update
 * @param {!Array<?>} options the new values of the collection
 * @return {boolean}
 */
GanttStatic.prototype.updateCollection = function(collection, options) {};

/**
 * updates the specified dependency link
 * @param {string} id the task id
 * @return {void}
 */
GanttStatic.prototype.updateLink = function(id) {};

/**
 * updates the specified marker
 * @param {string} markerId the marker's id
 * @return {void}
 */
GanttStatic.prototype.updateMarker = function(markerId) {};

/**
 * updates the specified task
 * @param {string} id the task id
 * @return {void}
 */
GanttStatic.prototype.updateTask = function(id) {};
 /** @type {!GanttStatic} */
var gantt;
 /** @type {!GanttEnterprise} */
var Gantt;
