/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/jsts/index.d.ts:
/** @const */
var jsts = {};
 /** @type {string} */
jsts.version;
/** @const */
jsts.geom = {};

/**
 * @constructor
 * @struct
 * @param {number|!jsts.geom.Coordinate} x_or_c
 * @param {number=} y
 */
jsts.geom.Coordinate = function(x_or_c, y) {};
 /** @type {number} */
jsts.geom.Coordinate.prototype.x;
 /** @type {number} */
jsts.geom.Coordinate.prototype.y;
 /** @type {number} */
jsts.geom.Coordinate.prototype.z;

/**
 * Sets this <code>Coordinate</code>s (x,y,z) values to that of
 * <code>other</code>.
 * 
 *          other the <code>Coordinate</code> to copy.
 * @param {!jsts.geom.Coordinate} other
 * @return {void}
 */
jsts.geom.Coordinate.prototype.setCoordinate = function(other) {};

/**
 * Clones this instance.
 * 
 * @return {!jsts.geom.Coordinate}
 */
jsts.geom.Coordinate.prototype.clone = function() {};

/**
 * Computes the 2-dimensional Euclidean distance to another location. The
 * Z-ordinate is ignored.
 * 
 *          p a point.
 *         locations.
 * @param {!jsts.geom.Coordinate} p
 * @return {number}
 */
jsts.geom.Coordinate.prototype.distance = function(p) {};

/**
 * Returns whether the planar projections of the two <code>Coordinate</code>s
 * are equal.
 * 
 *          other a <code>Coordinate</code> with which to do the 2D
 *          comparison.
 *         equal; the z-coordinates do not have to be equal.
 * @param {!jsts.geom.Coordinate} other
 * @return {boolean}
 */
jsts.geom.Coordinate.prototype.equals2D = function(other) {};

/**
 * Returns <code>true</code> if <code>other</code> has the same values for
 * the x and y ordinates. Since Coordinates are 2.5D, this routine ignores the
 * z value when making the comparison.
 * 
 *          other a <code>Coordinate</code> with which to do the comparison.
 *         <code>Coordinate</code> with the same values for the x and y
 *         ordinates.
 * @param {!jsts.geom.Coordinate} other
 * @return {boolean}
 */
jsts.geom.Coordinate.prototype.equals = function(other) {};

/**
 * Compares this {\@link Coordinate} with the specified {\@link Coordinate} for
 * order. This method ignores the z value when making the comparison. Returns:
 * <UL>
 * <LI> -1 : this.x < other.x || ((this.x == other.x) && (this.y < other.y))
 * <LI> 0 : this.x == other.x && this.y = other.y
 * <LI> 1 : this.x > other.x || ((this.x == other.x) && (this.y > other.y))
 * 
 * </UL>
 * Note: This method assumes that ordinate values are valid numbers. NaN
 * values are not handled correctly.
 * 
 *          other the <code>Coordinate</code> with which this
 *          <code>Coordinate</code> is being compared.
 * @param {!jsts.geom.Coordinate} other
 * @return {number}
 */
jsts.geom.Coordinate.prototype.compareTo = function(other) {};

/**
 * @constructor
 * @struct
 * Creates an <code>Envelope</code> for a region defined by maximum and
 * minimum values.
 * 
 * Initialize an <code>Envelope</code> to a region defined by two Coordinates.
 * 
 * Initialize an <code>Envelope</code> to a region defined by a single
 * Coordinate.
 * 
 * Initialize an <code>Envelope</code> from an existing Envelope.
 * 
 * @param {number|!jsts.geom.Coordinate|!jsts.geom.Envelope} x1_or_p1_or_p_or_env
 * @param {number|!jsts.geom.Coordinate=} x2_or_p2
 * @param {number=} y1
 * @param {number=} y2
 */
jsts.geom.Envelope = function(x1_or_p1_or_p_or_env, x2_or_p2, y1, y2) {};
 /** @type {number} */
jsts.geom.Envelope.prototype.minx;
 /** @type {number} */
jsts.geom.Envelope.prototype.maxx;
 /** @type {number} */
jsts.geom.Envelope.prototype.miny;
 /** @type {number} */
jsts.geom.Envelope.prototype.maxy;

/**
 * Test the point q to see whether it intersects the Envelope defined by p1-p2
 * 
 * NOTE: calls intersectsEnvelope if four arguments are given to simulate
 * overloaded function
 * 
 *          p1 one extremal point of the envelope.
 *          p2 another extremal point of the envelope.
 *          q the point to test for intersection.
 * @param {!jsts.geom.Coordinate} p1
 * @param {!jsts.geom.Coordinate} p2
 * @param {!jsts.geom.Coordinate} q
 * @return {boolean}
 */
jsts.geom.Envelope.intersects = function(p1, p2, q) {};

/**
 * Test the envelope defined by p1-p2 for intersection with the envelope defined
 * by q1-q2
 * 
 *          p1 one extremal point of the envelope P.
 *          p2 another extremal point of the envelope P.
 *          q1 one extremal point of the envelope Q.
 *          q2 another extremal point of the envelope Q.
 * @param {!jsts.geom.Coordinate} p1
 * @param {!jsts.geom.Coordinate} p2
 * @param {!jsts.geom.Coordinate} q1
 * @param {!jsts.geom.Coordinate} q2
 * @return {boolean}
 */
jsts.geom.Envelope.intersectsEnvelope = function(p1, p2, q1, q2) {};

/**
 * Makes this <code>Envelope</code> a "null" envelope, that is, the envelope
 * of the empty geometry.
 * @return {void}
 */
jsts.geom.Envelope.prototype.setToNull = function() {};

/**
 * Returns <code>true</code> if this <code>Envelope</code> is a "null"
 * envelope.
 * 
 *         uninitialized or is the envelope of the empty geometry.
 * @return {boolean}
 */
jsts.geom.Envelope.prototype.isNull = function() {};

/**
 * Returns the difference between the maximum and minimum y values.
 * 
 * @return {number}
 */
jsts.geom.Envelope.prototype.getHeight = function() {};

/**
 * Returns the difference between the maximum and minimum x values.
 * 
 * @return {number}
 */
jsts.geom.Envelope.prototype.getWidth = function() {};

/**
 * Returns the <code>Envelope</code>s minimum x-value. min x > max x
 * indicates that this is a null <code>Envelope</code>.
 * 
 * @return {number}
 */
jsts.geom.Envelope.prototype.getMinX = function() {};

/**
 * Returns the <code>Envelope</code>s maximum x-value. min x > max x
 * indicates that this is a null <code>Envelope</code>.
 * 
 * @return {number}
 */
jsts.geom.Envelope.prototype.getMaxX = function() {};

/**
 * Returns the <code>Envelope</code>s minimum y-value. min y > max y
 * indicates that this is a null <code>Envelope</code>.
 * 
 * @return {number}
 */
jsts.geom.Envelope.prototype.getMinY = function() {};

/**
 * Returns the <code>Envelope</code>s maximum y-value. min y > max y
 * indicates that this is a null <code>Envelope</code>.
 * 
 * @return {number}
 */
jsts.geom.Envelope.prototype.getMaxY = function() {};

/**
 * Gets the area of this envelope.
 * 
 * @return {number}
 */
jsts.geom.Envelope.prototype.getArea = function() {};

/**
 * Enlarges this <code>Envelope</code> so that it contains the given
 * {\@link Coordinate}. Has no effect if the point is already on or within the
 * envelope.
 * 
 * Enlarges this <code>Envelope</code> so that it contains the given point.
 * Has no effect if the point is already on or within the envelope.
 * 
 * Enlarges this <code>Envelope</code> so that it contains the
 * <code>other</code> Envelope. Has no effect if <code>other</code> is
 * wholly on or within the envelope.
 * 
 * @param {!jsts.geom.Coordinate|number|!jsts.geom.Envelope} p_or_x_or_other
 * @param {number=} y
 * @return {void}
 */
jsts.geom.Envelope.prototype.expandToInclude = function(p_or_x_or_other, y) {};

/**
 * Expands this envelope by a given distance in all directions. Both positive
 * and negative distances are supported.
 * 
 * Expands this envelope by a given distance in all directions. Both positive
 * and negative distances are supported.
 * 
 *          deltaX the distance to expand the envelope along the the X axis.
 *          deltaY the distance to expand the envelope along the the Y axis.
 * @param {number} distance_or_deltaX
 * @param {number=} deltaY
 * @return {void}
 */
jsts.geom.Envelope.prototype.expandBy = function(distance_or_deltaX, deltaY) {};

/**
 * Translates this envelope by given amounts in the X and Y direction.
 * 
 *          transX the amount to translate along the X axis.
 *          transY the amount to translate along the Y axis.
 * @param {number} transX
 * @param {number} transY
 * @return {void}
 */
jsts.geom.Envelope.prototype.translate = function(transX, transY) {};

/**
 * Computes the coordinate of the centre of this envelope (as long as it is
 * non-null
 * 
 *         if the envelope is null.
 * @return {!jsts.geom.Coordinate}
 */
jsts.geom.Envelope.prototype.centre = function() {};

/**
 * Computes the intersection of two {\@link Envelopes}
 * 
 *          env the envelope to intersect with.
 *         the envelopes (this will be the null envelope if either argument is
 *         null, or they do not intersect.
 * @param {!jsts.geom.Envelope} env
 * @return {!jsts.geom.Envelope}
 */
jsts.geom.Envelope.prototype.intersection = function(env) {};

/**
 * Check if the region defined by <code>other</code> overlaps (intersects) the
 * region of this <code>Envelope</code>.
 * 
 *          other the <code>Envelope</code> which this <code>Envelope</code>
 *          is being checked for overlapping.
 *         overlap.
 * Check if the point <code>p</code> overlaps (lies inside) the region of this
 * <code>Envelope</code>.
 * 
 *          p the <code>Coordinate</code> to be tested.
 *         <code>Envelope.</code>
 * Check if the point <code>(x, y)</code> overlaps (lies inside) the region of
 * this <code>Envelope</code>.
 * 
 *          x the x-ordinate of the point.
 *          y the y-ordinate of the point.
 *         <code>Envelope.</code>
 * @param {!jsts.geom.Envelope|!jsts.geom.Coordinate|number} other_or_p_or_x
 * @param {number=} y
 * @return {boolean}
 */
jsts.geom.Envelope.prototype.intersects = function(other_or_p_or_x, y) {};

/**
 * Tests if the <code>Envelope other</code> lies wholely inside this
 * <code>Envelope</code> (inclusive of the boundary).
 * <p>
 * Note that this is <b>not</b> the same definition as the SFS
 * <tt>contains</tt>, which would exclude the envelope boundary.
 * 
 *          other the <code>Envelope</code> to check.
 *         <code>Envelope.</code>
 * 
 * @see covers(Envelope)
 * Tests if the given point lies in or on the envelope.
 * <p>
 * Note that this is <b>not</b> the same definition as the SFS
 * <tt>contains</tt>, which would exclude the envelope boundary.
 * 
 *          p the point which this <code>Envelope</code> is being checked for
 *          containing.
 *         the boundary of this <code>Envelope</code>.
 * 
 * @see covers(Coordinate)
 * Tests if the given point lies in or on the envelope.
 * <p>
 * Note that this is <b>not</b> the same definition as the SFS
 * <tt>contains</tt>, which would exclude the envelope boundary.
 * 
 *          x the x-coordinate of the point which this <code>Envelope</code>
 *          is being checked for containing.
 *          y the y-coordinate of the point which this <code>Envelope</code>
 *          is being checked for containing.
 *         interior or on the boundary of this <code>Envelope</code>.
 * 
 * @see covers(double, double)
 * @param {!jsts.geom.Envelope|!jsts.geom.Coordinate|number} other_or_p_or_x
 * @param {number=} y
 * @return {boolean}
 */
jsts.geom.Envelope.prototype.contains = function(other_or_p_or_x, y) {};

/**
 * Tests if the given point lies in or on the envelope.
 * 
 *          x the x-coordinate of the point which this <code>Envelope</code>
 *          is being checked for containing.
 *          y the y-coordinate of the point which this <code>Envelope</code>
 *          is being checked for containing.
 *         interior or on the boundary of this <code>Envelope</code>.
 * Tests if the given point lies in or on the envelope.
 * 
 *          p the point which this <code>Envelope</code> is being checked for
 *          containing.
 *         the boundary of this <code>Envelope</code>.
 * Tests if the <code>Envelope other</code> lies wholely inside this
 * <code>Envelope</code> (inclusive of the boundary).
 * 
 *          other the <code>Envelope</code> to check.
 *         <code>other.</code>
 * @param {number|!jsts.geom.Coordinate|!jsts.geom.Envelope} x_or_p_or_other
 * @param {number=} y
 * @return {boolean}
 */
jsts.geom.Envelope.prototype.covers = function(x_or_p_or_other, y) {};

/**
 * Computes the distance between this and another <code>Envelope</code>.
 * 
 *          env The <code>Envelope</code> to test this <code>Envelope</code>
 *          against.
 *         the distance is the Euclidean distance between the closest points.
 * @param {!jsts.geom.Envelope} env
 * @return {number}
 */
jsts.geom.Envelope.prototype.distance = function(env) {};

/**
 *          other the <code>Envelope</code> to check against.
 * @param {!jsts.geom.Envelope} other
 * @return {boolean}
 */
jsts.geom.Envelope.prototype.equals = function(other) {};

/**
 * @return {string}
 */
jsts.geom.Envelope.prototype.toString = function() {};

/**
 * @return {!jsts.geom.Envelope}
 */
jsts.geom.Envelope.prototype.clone = function() {};

/**
 * @constructor
 * @struct
 * Creates a new <tt>Geometry</tt> via the specified GeometryFactory.
 * @param {?=} factory
 */
jsts.geom.Geometry = function(factory) {};
 /** @type {!jsts.geom.Envelope} */
jsts.geom.Geometry.prototype.envelope;

/**
 * Gets the factory which contains the context in which this geometry was created.
 * 
 * @return {?}
 */
jsts.geom.Geometry.prototype.getFactory = function() {};

/**
 * Returns the name of this object's <code>com.vivid.jts.geom</code> interface.
 * 
 * @return {string}
 */
jsts.geom.Geometry.prototype.getGeometryType = function() {};

/**
 * Returns the number of {\@link Geometry}s in a {\@link GeometryCollection}
 * (or 1, if the geometry is not a collection).
 * 
 * @return {number}
 */
jsts.geom.Geometry.prototype.getNumGeometries = function() {};

/**
 * Returns an element {\@link Geometry} from a {\@link GeometryCollection} (or
 * <code>this</code>, if the geometry is not a collection).
 * 
 * 
 * @param {number} n
 * @return {!jsts.geom.Geometry}
 */
jsts.geom.Geometry.prototype.getGeometryN = function(n) {};

/**
 * Returns the <code>PrecisionModel</code> used by the <code>Geometry</code>.
 * 
 * <code>Geometry</code> and all other <code>Geometry</code>s.
 * @return {?}
 */
jsts.geom.Geometry.prototype.getPrecisionModel = function() {};

/**
 * Returns a vertex of this <code>Geometry</code> (usually, but not
 * necessarily, the first one). The returned coordinate should not be assumed to
 * be an actual Coordinate object used in the internal representation.
 * 
 *         <code>Geometry</code>. null if this Geometry is empty.
 * @return {!jsts.geom.Coordinate}
 */
jsts.geom.Geometry.prototype.getCoordinate = function() {};

/**
 * Returns an array containing the values of all the vertices for this geometry.
 * If the geometry is a composite, the array will contain all the vertices for
 * the components, in the order in which the components occur in the geometry.
 * <p>
 * In general, the array cannot be assumed to be the actual internal storage for
 * the vertices. Thus modifying the array may not modify the geometry itself.
 * Use the {\@link CoordinateSequence#setOrdinate} method (possibly on the
 * components) to modify the underlying data. If the coordinates are modified,
 * {\@link #geometryChanged} must be called afterwards.
 * 
 * @see geometryChanged
 * @see CoordinateSequence#setOrdinate
 * @return {!Array<!jsts.geom.Coordinate>}
 */
jsts.geom.Geometry.prototype.getCoordinates = function() {};

/**
 * Returns the count of this <code>Geometry</code>s vertices. The
 * <code>Geometry</code> s contained by composite <code>Geometry</code>s
 * must be Geometry's; that is, they must implement <code>getNumPoints</code>
 * 
 * @return {number}
 */
jsts.geom.Geometry.prototype.getNumPoints = function() {};

/**
 * Tests whether this {\@link Geometry} is simple. In general, the SFS
 * specification of simplicity follows the rule:
 * <UL>
 * <LI> A Geometry is simple iff the only self-intersections are at boundary
 * points.
 * </UL>
 * Simplicity is defined for each {\@link Geometry} subclass as follows:
 * <ul>
 * <li>Valid polygonal geometries are simple by definition, so
 * <code>isSimple</code> trivially returns true.
 * <li>Linear geometries are simple iff they do not self-intersect at points
 * other than boundary points.
 * <li>Zero-dimensional geometries (points) are simple iff they have no
 * repeated points.
 * <li>Empty <code>Geometry</code>s are always simple
 * <ul>
 * 
 *         points of self-tangency, self-intersection or other anomalous points.
 * @see #isValid
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.isSimple = function() {};

/**
 * Tests the validity of this <code>Geometry</code>. Subclasses provide their
 * own definition of "valid".
 * 
 *         valid.
 * 
 * @see IsValidOp
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.isValid = function() {};

/**
 * Returns whether or not the set of points in this <code>Geometry</code> is
 * empty.
 * 
 *         the empty geometry.
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.isEmpty = function() {};

/**
 * Returns the minimum distance between this <code>Geometry</code> and the
 * <code>Geometry</code> g
 * 
 *          g the <code>Geometry</code> from which to compute the distance.
 *         geometry is empty.
 * @throws IllegalArgumentException
 *           if g is null
 * @param {!jsts.geom.Geometry} g
 * @return {number}
 */
jsts.geom.Geometry.prototype.distance = function(g) {};

/**
 * Tests whether the distance from this <code>Geometry</code> to another is
 * less than or equal to a specified value.
 * 
 *          geom the Geometry to check the distance to.
 *          distance the distance value to compare.
 *         <code>distance</code> apart.
 * @param {!jsts.geom.Geometry} geom
 * @param {number} distance
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.isWithinDistance = function(geom, distance) {};

/**
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.isRectangle = function() {};

/**
 * Returns the area of this <code>Geometry</code>. Areal Geometries have a
 * non-zero area. They override this function to compute the area. Others return
 * 0.0
 * 
 * @return {number} the area of the Geometry.
 */
jsts.geom.Geometry.prototype.getArea = function() {};

/**
 * Returns the length of this <code>Geometry</code>. Linear geometries return
 * their length. Areal geometries return their perimeter. They override this
 * function to compute the area. Others return 0.0
 * 
 * @return {number} the length of the Geometry.
 */
jsts.geom.Geometry.prototype.getLength = function() {};

/**
 * Computes the centroid of this <code>Geometry</code>. The centroid is equal
 * to the centroid of the set of component Geometries of highest dimension
 * (since the lower-dimension geometries contribute zero "weight" to the
 * centroid)
 * 
 * @return {!jsts.geom.Point} a {\@link Point} which is the centroid of this Geometry.
 */
jsts.geom.Geometry.prototype.getCentroid = function() {};

/**
 * Computes an interior point of this <code>Geometry</code>. An interior
 * point is guaranteed to lie in the interior of the Geometry, if it possible to
 * calculate such a point exactly. Otherwise, the point may lie on the boundary
 * of the geometry.
 * 
 * @return {!jsts.geom.Point}
 */
jsts.geom.Geometry.prototype.getInteriorPoint = function() {};

/**
 * Returns the dimension of this geometry. The dimension of a geometry is is the
 * topological dimension of its embedding in the 2-D Euclidean plane. In the JTS
 * spatial model, dimension values are in the set {0,1,2}.
 * <p>
 * Note that this is a different concept to the dimension of the vertex
 * {\@link Coordinate}s. The geometry dimension can never be greater than the
 * coordinate dimension. For example, a 0-dimensional geometry (e.g. a Point)
 * may have a coordinate dimension of 3 (X,Y,Z).
 * 
 * @return {number}
 */
jsts.geom.Geometry.prototype.getDimension = function() {};

/**
 * Returns the boundary, or an empty geometry of appropriate dimension if this
 * <code>Geometry</code> is empty. (In the case of zero-dimensional
 * geometries, ' an empty GeometryCollection is returned.) For a discussion of
 * this function, see the OpenGIS Simple Features Specification. As stated in
 * SFS Section 2.1.13.1, "the boundary of a Geometry is a set of Geometries of
 * the next lower dimension."
 * 
 *         <code>Geometry.</code>
 * @return {!jsts.geom.Geometry}
 */
jsts.geom.Geometry.prototype.getBoundary = function() {};

/**
 * Returns the dimension of this <code>Geometry</code>s inherent boundary.
 * 
 *         interface, whether or not this object is the empty geometry. Returns
 *         <code>Dimension.FALSE</code> if the boundary is the empty geometry.
 * @return {number}
 */
jsts.geom.Geometry.prototype.getBoundaryDimension = function() {};

/**
 * Returns this <code>Geometry</code>s bounding box. If this
 * <code>Geometry</code> is the empty geometry, returns an empty
 * <code>Point</code>. If the <code>Geometry</code> is a point, returns a
 * non-empty <code>Point</code>. Otherwise, returns a <code>Polygon</code>
 * whose points are (minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy),
 * (minx, miny).
 * 
 *         <code>Geometry</code>s), a <code>Point</code> (for
 *         <code>Point</code>s) or a <code>Polygon</code> (in all other
 *         cases).
 * @return {!jsts.geom.Geometry}
 */
jsts.geom.Geometry.prototype.getEnvelope = function() {};

/**
 * Returns the minimum and maximum x and y values in this <code>Geometry</code>,
 * or a null <code>Envelope</code> if this <code>Geometry</code> is empty.
 * 
 *         <code>Geometry</code> is empty, <code>Envelope#isNull</code> will
 *         return <code>true.</code>
 * @return {!jsts.geom.Envelope}
 */
jsts.geom.Geometry.prototype.getEnvelopeInternal = function() {};

/**
 * Tests whether this geometry is disjoint from the specified geometry.
 * <p>
 * The <code>disjoint</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The two geometries have no point in common
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[FF*FF****]</code>
 * <li><code>! g.intersects(this)</code> (<code>disjoint</code> is the
 * inverse of <code>intersects</code>)
 * </ul>
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         are disjoint.
 * 
 * @see Geometry#intersects
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.disjoint = function(g) {};

/**
 * Tests whether this geometry touches the specified geometry.
 * <p>
 * The <code>touches</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The geometries have at least one point in common, but their interiors do
 * not intersect.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[FT*******]</code> or <code>[F**T*****]</code> or
 * <code>[F***T****]</code>
 * </ul>
 * If both geometries have dimension 0, this predicate returns
 * <code>false</code>
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         touch; Returns <code>false</code> if both <code>Geometry</code>s
 *         are points.
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.touches = function(g) {};

/**
 * Tests whether this geometry intersects the specified geometry.
 * <p>
 * The <code>intersects</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The two geometries have at least one point in common
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T********]</code> or <code>[*T*******]</code> or
 * <code>[***T*****]</code> or <code>[****T****]</code>
 * <li><code>! g.disjoint(this)</code> (<code>intersects</code> is the
 * inverse of <code>disjoint</code>)
 * </ul>
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         intersect.
 * 
 * @see Geometry#disjoint
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.intersects = function(g) {};

/**
 * Tests whether this geometry crosses the specified geometry.
 * <p>
 * The <code>crosses</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The geometries have some but not all interior points in common.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <ul>
 * <li><code>[T*T******]</code> (for P/L, P/A, and L/A situations)
 * <li><code>[T*****T**]</code> (for L/P, A/P, and A/L situations)
 * <li><code>[0********]</code> (for L/L situations)
 * </ul>
 * </ul>
 * For any other combination of dimensions this predicate returns
 * <code>false</code>.
 * <p>
 * The SFS defined this predicate only for P/L, P/A, L/L, and L/A situations.
 * JTS extends the definition to apply to L/P, A/P and A/L situations as well,
 * in order to make the relation symmetric.
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         cross.
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.crosses = function(g) {};

/**
 * Tests whether this geometry is within the specified geometry.
 * <p>
 * The <code>within</code> predicate has the following equivalent definitions:
 * <ul>
 * <li>Every point of this geometry is a point of the other geometry, and the
 * interiors of the two geometries have at least one point in common.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*F**F***]</code>
 * <li><code>g.contains(this)</code> (<code>within</code> is the converse
 * of <code>contains</code>)
 * </ul>
 * An implication of the definition is that "The boundary of a Geometry is not
 * within the Geometry". In other words, if a geometry A is a subset of the
 * points in the boundary of a geomtry B, <code>A.within(B) = false</code>
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         within <code>other.</code>
 * 
 * @see Geometry#contains
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.within = function(g) {};

/**
 * Tests whether this geometry contains the specified geometry.
 * <p>
 * The <code>contains</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>Every point of the other geometry is a point of this geometry, and the
 * interiors of the two geometries have at least one point in common.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*****FF*]</code>
 * <li><code>g.within(this)</code> (<code>contains</code> is the converse
 * of <code>within</code>)
 * </ul>
 * An implication of the definition is that "Geometries do not contain their
 * boundary". In other words, if a geometry A is a subset of the points in the
 * boundary of a geometry B, <code>B.contains(A) = false</code>
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         contains <code>g.</code>
 * 
 * @see Geometry#within
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.contains = function(g) {};

/**
 * Tests whether this geometry overlaps the specified geometry.
 * <p>
 * The <code>overlaps</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The geometries have at least one point each not shared by the other (or
 * equivalently neither covers the other), they have the same dimension, and the
 * intersection of the interiors of the two geometries has the same dimension as
 * the geometries themselves.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*T***T**]</code> (for two points or two surfaces) or
 * <code>[1*T***T**]</code> (for two curves)
 * </ul>
 * If the geometries are of different dimension this predicate returns
 * <code>false</code>.
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         overlap.
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.overlaps = function(g) {};

/**
 * Tests whether this geometry covers the specified geometry.
 * <p>
 * The <code>covers</code> predicate has the following equivalent definitions:
 * <ul>
 * <li>Every point of the other geometry is a point of this geometry.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*****FF*]</code> or <code>[*T****FF*]</code> or
 * <code>[***T**FF*]</code> or <code>[****T*FF*]</code>
 * <li><code>g.coveredBy(this)</code> (<code>covers</code> is the converse
 * of <code>coveredBy</code>)
 * </ul>
 * If either geometry is empty, the value of this predicate is <tt>false</tt>.
 * <p>
 * This predicate is similar to {\@link #contains}, but is more inclusive (i.e.
 * returns <tt>true</tt> for more cases). In particular, unlike
 * <code>contains</code> it does not distinguish between points in the
 * boundary and in the interior of geometries. For most situations,
 * <code>covers</code> should be used in preference to <code>contains</code>.
 * As an added benefit, <code>covers</code> is more amenable to optimization,
 * and hence should be more performant.
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         <code>g.</code>
 * 
 * @see Geometry#contains
 * @see Geometry#coveredBy
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.covers = function(g) {};

/**
 * Tests whether this geometry is covered by the specified geometry.
 * <p>
 * The <code>coveredBy</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>Every point of this geometry is a point of the other geometry.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*F**F***]</code> or <code>[*TF**F***]</code> or
 * <code>[**FT*F***]</code> or <code>[**F*TF***]</code>
 * <li><code>g.covers(this)</code> (<code>coveredBy</code> is the converse
 * of <code>covers</code>)
 * </ul>
 * If either geometry is empty, the value of this predicate is <tt>false</tt>.
 * <p>
 * This predicate is similar to {\@link #within}, but is more inclusive (i.e.
 * returns <tt>true</tt> for more cases).
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         covered by <code>g.</code>
 * 
 * @see Geometry#within
 * @see Geometry#covers
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.coveredBy = function(g) {};

/**
 * Tests whether the elements in the DE-9IM {\@link IntersectionMatrix} for the
 * two <code>Geometry</code>s match the elements in
 * <code>intersectionPattern</code>. The pattern is a 9-character string,
 * with symbols drawn from the following set:
 * <UL>
 * <LI> 0 (dimension 0)
 * <LI> 1 (dimension 1)
 * <LI> 2 (dimension 2)
 * <LI> T ( matches 0, 1 or 2)
 * <LI> F ( matches FALSE)
 * <LI> * ( matches any value)
 * </UL>
 * For more information on the DE-9IM, see the <i>OpenGIS Simple Features
 * Specification</i>.
 * 
 *          other the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *          intersectionPattern the pattern against which to check the
 *          intersection matrix for the two <code>Geometry</code>s.
 *         the two <code>Geometry</code>s match
 *         <code>intersectionPattern.</code>
 * @see IntersectionMatrix
 * @param {!jsts.geom.Geometry} g
 * @param {string} intersectionPattern
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.relate = function(g, intersectionPattern) {};

/**
 * Returns the DE-9IM {\@link IntersectionMatrix} for the two
 * <code>Geometry</code>s.
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         intersections of the interiors, boundaries and exteriors of the two
 *         <code>Geometry</code>s.
 * @param {!jsts.geom.Geometry} g
 * @return {?}
 */
jsts.geom.Geometry.prototype.relate2 = function(g) {};

/**
 * Tests whether this geometry is topologically equal to the argument geometry
 * as defined by the SFS <tt>equals</tt> predicate.
 * <p>
 * The SFS <code>equals</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The two geometries have at least one point in common, and no point of
 * either geometry lies in the exterior of the other geometry.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches the
 * pattern <tt>T*F**FFF*</tt>
 * <pre>
 * T*F
 * **F
 * FF*
 * </pre>
 * 
 * </ul>
 * <b>Note</b> that this method computes <b>topologically equality</b>. For
 * structural equality, see {\@link #equalsExact(Geometry)}.
 * 
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         are topologically equal.
 * 
 * @see #equalsExact(Geometry)
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.equalsTopo = function(g) {};

/**
 * Tests whether this geometry is structurally and numerically equal to a given
 * <tt>Object</tt>. If the argument <tt>Object</tt> is not a
 * <tt>Geometry</tt>, the result is <tt>false</tt>. Otherwise, the result
 * is computed using {\@link #equalsExact(Geometry)}.
 * <p>
 * This method is provided to fulfill the Java contract for value-based object
 * equality. In conjunction with {\@link #hashCode()} it provides semantics which
 * are most useful for using <tt>Geometry</tt>s as keys and values in Java
 * collections.
 * <p>
 * Note that to produce the expected result the input geometries should be in
 * normal form. It is the caller's responsibility to perform this where required
 * (using {\@link Geometry#norm() or {\@link #normalize()} as appropriate).
 * 
 *          o the Object to compare.
 * 
 * @see #equalsExact(Geometry)
 * @see #hashCode()
 * @see #norm()
 * @see #normalize()
 * @param {!Object} o
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.equals = function(o) {};

/**
 * Computes a buffer area around this geometry having the given width and with a
 * specified accuracy of approximation for circular arcs, and using a specified
 * end cap style.
 * <p>
 * Mathematically-exact buffer area boundaries can contain circular arcs. To
 * represent these arcs using linear geometry they must be approximated with
 * line segments. The <code>quadrantSegments</code> argument allows
 * controlling the accuracy of the approximation by specifying the number of
 * line segments used to represent a quadrant of a circle
 * <p>
 * The end cap style specifies the buffer geometry that will be created at the
 * ends of linestrings. The styles provided are:
 * <ul>
 * <li><tt>BufferOp.CAP_ROUND</tt> - (default) a semi-circle
 * <li><tt>BufferOp.CAP_BUTT</tt> - a straight line perpendicular to the end
 * segment
 * <li><tt>BufferOp.CAP_SQUARE</tt> - a half-square
 * </ul>
 * <p>
 * The buffer operation always returns a polygonal result. The negative or
 * zero-distance buffer of lines and points is always an empty {\@link Polygon}.
 * This is also the result for the buffers of degenerate (zero-area) polygons.
 * 
 *          distance the width of the buffer (may be positive, negative or 0).
 *          quadrantSegments the number of line segments used to represent a
 *          quadrant of a circle.
 *          endCapStyle the end cap style to use.
 *         may be empty).
 * 
 * @throws TopologyException
 *           if a robustness error occurs
 * 
 * @see #buffer(double)
 * @see #buffer(double, int)
 * @see BufferOp
 * @param {number} distance
 * @param {number} quadrantSegments
 * @param {number} endCapStyle
 * @return {!jsts.geom.Geometry}
 */
jsts.geom.Geometry.prototype.buffer = function(distance, quadrantSegments, endCapStyle) {};

/**
 * Computes the smallest convex <code>Polygon</code> that contains all the
 * points in the <code>Geometry</code>. This obviously applies only to
 * <code>Geometry</code> s which contain 3 or more points; the results for
 * degenerate cases are specified as follows: <TABLE>
 * <TR>
 * <TH> Number of <code>Point</code>s in argument <code>Geometry</code>
 * </TH>
 * <TH> <code>Geometry</code> class of result </TH>
 * </TR>
 * <TR>
 * <TD> 0 </TD>
 * <TD> empty <code>GeometryCollection</code> </TD>
 * </TR>
 * <TR>
 * <TD> 1 </TD>
 * <TD> <code>Point</code> </TD>
 * </TR>
 * <TR>
 * <TD> 2 </TD>
 * <TD> <code>LineString</code> </TD>
 * </TR>
 * <TR>
 * <TD> 3 or more </TD>
 * <TD> <code>Polygon</code> </TD>
 * </TR>
 * </TABLE>
 * 
 *         <code>Geometry</code>' s points.
 * @return {!jsts.geom.Geometry}
 */
jsts.geom.Geometry.prototype.convexHull = function() {};

/**
 * Computes a <code>Geometry</code> representing the points shared by this
 * <code>Geometry</code> and <code>other</code>. {\@link GeometryCollection}s
 * support intersection with homogeneous collection types, with the semantics
 * that the result is a {\@link GeometryCollection} of the intersection of each
 * element of the target with the argument.
 * 
 *          other the <code>Geometry</code> with which to compute the
 *          intersection.
 * @throws TopologyException
 *           if a robustness error occurs
 * @throws IllegalArgumentException
 *           if the argument is a non-empty GeometryCollection
 * @param {!jsts.geom.Geometry} other
 * @return {!jsts.geom.Geometry}
 */
jsts.geom.Geometry.prototype.intersection = function(other) {};

/**
 * Computes a <code>Geometry</code> representing all the points in this
 * <code>Geometry</code> and <code>other</code>.
 * 
 * Or without arguments:
 * 
 * Computes the union of all the elements of this geometry. Heterogeneous
 * {\@link GeometryCollection}s are fully supported.
 * 
 * The result obeys the following contract:
 * <ul>
 * <li>Unioning a set of {\@link LineString}s has the effect of fully noding
 * and dissolving the linework.
 * <li>Unioning a set of {\@link Polygon}s will always return a
 * {\@link Polygonal} geometry (unlike {link #union(Geometry)}, which may return
 * geometrys of lower dimension if a topology collapse occurred.
 * </ul>
 * 
 *          other the <code>Geometry</code> with which to compute the union.
 *         and the points of <code>other.</code>
 * @throws TopologyException
 *           if a robustness error occurs
 * @throws IllegalArgumentException
 *           if either input is a non-empty GeometryCollection
 * @param {!jsts.geom.Geometry} other
 * @return {!jsts.geom.Geometry}
 */
jsts.geom.Geometry.prototype.union = function(other) {};

/**
 * Computes a <code>Geometry</code> representing the points making up this
 * <code>Geometry</code> that do not make up <code>other</code>. This
 * method returns the closure of the resultant <code>Geometry</code>.
 * 
 *          other the <code>Geometry</code> with which to compute the
 *          difference.
 *         with <code>other.</code>
 * @throws TopologyException
 *           if a robustness error occurs
 * @throws IllegalArgumentException
 *           if either input is a non-empty GeometryCollection
 * @param {!jsts.geom.Geometry} other
 * @return {!jsts.geom.Geometry}
 */
jsts.geom.Geometry.prototype.difference = function(other) {};

/**
 * Returns a set combining the points in this <code>Geometry</code> not in
 * <code>other</code>, and the points in <code>other</code> not in this
 * <code>Geometry</code>. This method returns the closure of the resultant
 * <code>Geometry</code>.
 * 
 *          other the <code>Geometry</code> with which to compute the
 *          symmetric difference.
 *         <code>Geometry</code> with <code>other.</code>
 * @throws TopologyException
 *           if a robustness error occurs
 * @throws IllegalArgumentException
 *           if either input is a non-empty GeometryCollection
 * @param {!jsts.geom.Geometry} other
 * @return {!jsts.geom.Geometry}
 */
jsts.geom.Geometry.prototype.symDifference = function(other) {};

/**
 * Returns true if the two <code>Geometry</code>s are exactly equal, up to a
 * specified distance tolerance. Two Geometries are exactly equal within a
 * distance tolerance if and only if:
 * <ul>
 * <li>they have the same class
 * <li>they have the same values for their vertices, within the given tolerance
 * distance, in exactly the same order.
 * </ul>
 * If this and the other <code>Geometry</code>s are composites and any
 * children are not <code>Geometry</code>s, returns <code>false</code>.
 * 
 *          other the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *          tolerance distance at or below which two <code>Coordinate</code>s
 *          are considered equal.
 * @param {!jsts.geom.Geometry} other
 * @param {number} tolerance
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.equalsExact = function(other, tolerance) {};

/**
 * Tests whether two geometries are exactly equal in their normalized forms.
 * This is a convenience method which creates normalized versions of both
 * geometries before computing {\@link #equalsExact(Geometry)}. This method is
 * relatively expensive to compute. For maximum performance, the client should
 * instead perform normalization itself at an appropriate point during
 * execution.
 * 
 *          g a Geometry.
 *         normalized form.
 * @param {!jsts.geom.Geometry} g
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.equalsNorm = function(g) {};

/**
 * Performs an operation with or on this <code>Geometry</code> and its
 * subelement <code>Geometry</code>s (if any). Only GeometryCollections and
 * subclasses have subelement Geometry's.
 * 
 * @param {?} filter 
 *          the filter to apply to this <code>Geometry</code> (and its
 *          children, if it is a <code>GeometryCollection</code>).
 * @return {void}
 */
jsts.geom.Geometry.prototype.apply = function(filter) {};

/**
 * Creates and returns a full copy of this {\@link Geometry} object (including
 * all coordinates contained by it). Subclasses are responsible for overriding
 * this method and copying their internal data. Overrides should call this
 * method first.
 * 
 * @return {!jsts.geom.Geometry} a clone of this instance.
 */
jsts.geom.Geometry.prototype.clone = function() {};

/**
 * Converts this <code>Geometry</code> to <b>normal form</b> (or <b>
 * canonical form</b> ). Normal form is a unique representation for
 * <code>Geometry</code> s. It can be used to test whether two
 * <code>Geometry</code>s are equal in a way that is independent of the
 * ordering of the coordinates within them. Normal form equality is a stronger
 * condition than topological equality, but weaker than pointwise equality. The
 * definitions for normal form use the standard lexicographical ordering for
 * coordinates. "Sorted in order of coordinates" means the obvious extension of
 * this ordering to sequences of coordinates.
 * @return {void}
 */
jsts.geom.Geometry.prototype.normalize = function() {};

/**
 * Creates a new Geometry which is a normalized copy of this Geometry.
 * 
 * @see #normalize()
 * @return {!jsts.geom.Geometry} a normalized copy of this geometry.
 */
jsts.geom.Geometry.prototype.norm = function() {};

/**
 * Returns whether this <code>Geometry</code> is greater than, equal to, or
 * less than another <code>Geometry</code>.
 * <P>
 * 
 * If their classes are different, they are compared using the following
 * ordering:
 * <UL>
 * <LI> Point (lowest)
 * <LI> MultiPoint
 * <LI> LineString
 * <LI> LinearRing
 * <LI> MultiLineString
 * <LI> Polygon
 * <LI> MultiPolygon
 * <LI> GeometryCollection (highest)
 * </UL>
 * If the two <code>Geometry</code>s have the same class, their first
 * elements are compared. If those are the same, the second elements are
 * compared, etc.
 * 
 *          other a <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 *         whether this object is greater than, equal to, or less than
 *         <code>o</code>, as defined in "Normal Form For Geometry" in the
 *         JTS Technical Specifications.
 * @param {!jsts.geom.Geometry} o
 * @return {number}
 */
jsts.geom.Geometry.prototype.compareTo = function(o) {};

/**
 * Returns whether the two <code>Geometry</code>s are equal, from the point
 * of view of the <code>equalsExact</code> method. Called by
 * <code>equalsExact</code> . In general, two <code>Geometry</code> classes
 * are considered to be "equivalent" only if they are the same class. An
 * exception is <code>LineString</code> , which is considered to be equivalent
 * to its subclasses.
 * 
 *          other the <code>Geometry</code> with which to compare this
 *          <code>Geometry</code> for equality.
 *         <code>Geometry</code> s are considered to be equal by the
 *         <code>equalsExact</code> method.
 * @param {!jsts.geom.Geometry} other
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.isEquivalentClass = function(other) {};

/**
 * Throws an exception if <code>g</code>'s class is
 * <code>GeometryCollection</code> . (Its subclasses do not trigger an
 * exception).
 * 
 *          g the <code>Geometry</code> to check.
 * @throws Error
 *           if <code>g</code> is a <code>GeometryCollection</code> but not
 *           one of its subclasses
 * @param {!jsts.geom.Geometry} g
 * @return {void}
 */
jsts.geom.Geometry.prototype.checkNotGeometryCollection = function(g) {};

/**
 *
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.isGeometryCollection = function() {};

/**
 *
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.isGeometryCollectionBase = function() {};

/**
 * Returns the minimum and maximum x and y values in this <code>Geometry</code>,
 * or a null <code>Envelope</code> if this <code>Geometry</code> is empty.
 * Unlike <code>getEnvelopeInternal</code>, this method calculates the
 * <code>Envelope</code> each time it is called;
 * <code>getEnvelopeInternal</code> caches the result of this method.
 * 
 *         <code>Geometry</code> is empty, <code>Envelope#isNull</code> will
 *         return <code>true.</code>
 * @return {!jsts.geom.Envelope}
 */
jsts.geom.Geometry.prototype.computeEnvelopeInternal = function() {};

/**
 * Returns whether this <code>Geometry</code> is greater than, equal to, or
 * less than another <code>Geometry</code> having the same class.
 * 
 * @param {!jsts.geom.Geometry} o 
 *          a <code>Geometry</code> having the same class as this
 *          <code>Geometry.</code>
 * @return {number} a positive number, 0, or a negative number, depending on whether this
 *         object is greater than, equal to, or less than <code>o</code>, as
 *         defined in "Normal Form For Geometry" in the JTS Technical
 *         Specifications.
 */
jsts.geom.Geometry.prototype.compareToSameClass = function(o) {};

/**
 * Returns the first non-zero result of <code>compareTo</code> encountered as
 * the two <code>Collection</code>s are iterated over. If, by the time one of
 * the iterations is complete, no non-zero result has been encountered, returns
 * 0 if the other iteration is also complete. If <code>b</code> completes
 * before <code>a</code>, a positive number is returned; if a before b, a
 * negative number.
 * 
 *          a a <code>Collection</code> of <code>Comparable</code>s.
 *          b a <code>Collection</code> of <code>Comparable</code>s.
 *         otherwise, zero.
 * @param {!Array<?>} a
 * @param {!Array<?>} b
 * @return {number}
 */
jsts.geom.Geometry.prototype.compare = function(a, b) {};

/**
 *          a first Coordinate to compare.
 *          b second Coordinate to compare.
 *          tolerance tolerance when comparing.
 * @param {!jsts.geom.Coordinate} a
 * @param {!jsts.geom.Coordinate} b
 * @param {number} tolerance
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.equal = function(a, b, tolerance) {};

/**
 * Returns a WKT representation of this geometry.
 * @return {string}
 */
jsts.geom.Geometry.prototype.toString = function() {};
/**
 * @extends {jsts.geom.LineString}
 * @constructor
 * @struct
 */
jsts.geom.LinearRing = function() {};

/**
 * @constructor
 * @struct
 * @param {!Array<!jsts.geom.Coordinate>} points
 * @param {?=} factory
 */
jsts.geom.LineString = function(points, factory) {};

/**
 *         jsts.geom.LineString.
 *          n index.
 * @param {number} n
 * @return {!jsts.geom.Coordinate}
 */
jsts.geom.LineString.prototype.getCoordinateN = function(n) {};

/**
 *         jsts.geom.LineString.
 *          n index.
 * @param {number} n
 * @return {!jsts.geom.Point}
 */
jsts.geom.LineString.prototype.getPointN = function(n) {};

/**
 *         jsts.geom.LineString.
 * @return {!jsts.geom.Point}
 */
jsts.geom.LineString.prototype.getStartPoint = function() {};

/**
 *         jsts.geom.LineString.
 * @return {!jsts.geom.Point}
 */
jsts.geom.LineString.prototype.getEndPoint = function() {};

/**
 * @return {boolean}
 */
jsts.geom.LineString.prototype.isClosed = function() {};

/**
 * @return {boolean}
 */
jsts.geom.LineString.prototype.isRing = function() {};

/**
 * @constructor
 * @struct
 * @param {!jsts.geom.Coordinate} coordinate
 * @param {?=} factory
 */
jsts.geom.Point = function(coordinate, factory) {};

/**
 * @return {number}
 */
jsts.geom.Point.prototype.getX = function() {};

/**
 * @return {number}
 */
jsts.geom.Point.prototype.getY = function() {};

/**
 * @return {!jsts.geom.Point}
 */
jsts.geom.Point.prototype.reverse = function() {};

/**
 * @constructor
 * @struct
 * @param {!jsts.geom.LinearRing} shell
 * @param {!Array<!jsts.geom.LinearRing>=} holes
 * @param {?=} factory
 */
jsts.geom.Polygon = function(shell, holes, factory) {};

/**
 * Gets the exterior ring.
 * 
 * @return {!jsts.geom.LinearRing}
 */
jsts.geom.Polygon.prototype.getExteriorRing = function() {};

/**
 * Gets the interior ring at the specified index.
 * 
 * 
 * @param {number} n
 * @return {!jsts.geom.LinearRing}
 */
jsts.geom.Polygon.prototype.getInteriorRingN = function(n) {};

/**
 * Gets the number of interior rings.
 * 
 * @return {number}
 */
jsts.geom.Polygon.prototype.getNumInteriorRing = function() {};
/** @const */
jsts.io = {};

/**
 * @constructor
 * @struct
 */
jsts.io.GeoJSONReader = function() {};

/**
 * Converts a GeoJSON to its <code>Geometry</code> representation.
 * 
 * geometry a <code>Geometry</code> to process.
 * @param {!Object} geometry
 * @return {!jsts.geom.Geometry}
 */
jsts.io.GeoJSONReader.prototype.read = function(geometry) {};

/**
 * @constructor
 * @struct
 * Writes the GeoJSON representation of a {\@link Geometry}. The
 * The GeoJSON format is defined <A
 * HREF="http://geojson.org/geojson-spec.html">here</A>.
 * <p>
 * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 * <p>
 * 
 * @see WKTReader
 */
jsts.io.GeoJSONWriter = function() {};

/**
 * Converts a <code>Geometry</code> to its GeoJSON representation.
 * 
 *          geometry a <code>Geometry</code> to process.
 * @param {!jsts.geom.Geometry} geometry
 * @return {!Object}
 */
jsts.io.GeoJSONWriter.prototype.write = function(geometry) {};

/**
 * @constructor
 * @struct
 * @param {?=} geometryFactory
 */
jsts.io.WKTReader = function(geometryFactory) {};

/**
 * Reads a Well-Known Text representation of a {\@link Geometry}
 * 
 *          wkt a <Geometry Tagged Text> string (see the OpenGIS Simple Features
 *          Specification).
 *         <code>string.</code>
 * @param {string} wkt
 * @return {!jsts.geom.Geometry}
 */
jsts.io.WKTReader.prototype.read = function(wkt) {};

/**
 * @param {!jsts.geom.Geometry} geometry
 * @return {void}
 */
jsts.io.WKTReader.prototype.reducePrecision = function(geometry) {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "jsts"
/** @const */
tsickle_declare_module.jsts = {};

/* TODO: ExportAssignment in tsickle_declare_module.jsts */
