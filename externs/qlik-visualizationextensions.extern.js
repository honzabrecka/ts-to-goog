/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/qlik-visualizationextensions/index.d.ts:
/** @const */
var BackendAPI = {};

/** @typedef {string} */
BackendAPI.StateType;

/** @typedef {string} */
BackendAPI.SortIndicatorType;

/** @typedef {string} */
BackendAPI.DimensionType;

/** @typedef {string} */
BackendAPI.GroupingType;

/** @typedef {string} */
BackendAPI.FieldAttributesType;

/** @typedef {string} */
BackendAPI.PatchType;
/**
 * @record
 * @struct
 */
BackendAPI.ICharRange = function() {};
 /** @type {number} */
BackendAPI.ICharRange.prototype.qCharPos;
 /** @type {number} */
BackendAPI.ICharRange.prototype.qCharCount;
/**
 * @record
 * @struct
 */
BackendAPI.INxHighlightRanges = function() {};
 /** @type {!Array<!BackendAPI.ICharRange>} */
BackendAPI.INxHighlightRanges.prototype.qRanges;
/**
 * @record
 * @struct
 */
BackendAPI.INxSimpleValue = function() {};
 /** @type {string} */
BackendAPI.INxSimpleValue.prototype.qText;
 /** @type {number} */
BackendAPI.INxSimpleValue.prototype.qNum;
/**
 * @record
 * @struct
 */
BackendAPI.INxAttributeExpressionValues = function() {};
 /** @type {!Array<!BackendAPI.INxSimpleValue>} */
BackendAPI.INxAttributeExpressionValues.prototype.qValues;
/**
 * @record
 * @struct
 */
BackendAPI.INxSimpleDimValue = function() {};
 /** @type {string} */
BackendAPI.INxSimpleDimValue.prototype.qText;
 /** @type {number} */
BackendAPI.INxSimpleDimValue.prototype.qElemNo;
/**
 * @record
 * @struct
 */
BackendAPI.INxAttributeDimValues = function() {};
 /** @type {!Array<!BackendAPI.INxSimpleDimValue>} */
BackendAPI.INxAttributeDimValues.prototype.qValues;
/**
 * @record
 * @struct
 */
BackendAPI.INxCell = function() {};
 /** @type {string} */
BackendAPI.INxCell.prototype.qText;
 /** @type {number} */
BackendAPI.INxCell.prototype.qNum;
 /** @type {number} */
BackendAPI.INxCell.prototype.qElemNumber;
 /** @type {string} */
BackendAPI.INxCell.prototype.qState;
 /** @type {boolean} */
BackendAPI.INxCell.prototype.qIsEmpty;
 /** @type {boolean} */
BackendAPI.INxCell.prototype.qIsTotalCell;
 /** @type {boolean} */
BackendAPI.INxCell.prototype.qIsOtherCell;
 /** @type {string} */
BackendAPI.INxCell.prototype.qFrequency;
 /** @type {!BackendAPI.INxHighlightRanges} */
BackendAPI.INxCell.prototype.qHighlightRanges;
 /** @type {!BackendAPI.INxAttributeExpressionValues} */
BackendAPI.INxCell.prototype.qAttrExps;
 /** @type {boolean} */
BackendAPI.INxCell.prototype.qIsNull;
 /** @type {!BackendAPI.INxAttributeDimValues} */
BackendAPI.INxCell.prototype.qAttrDims;
/**
 * @record
 * @struct
 */
BackendAPI.INxPage = function() {};
 /** @type {number} */
BackendAPI.INxPage.prototype.qLeft;
 /** @type {number} */
BackendAPI.INxPage.prototype.qTop;
 /** @type {number} */
BackendAPI.INxPage.prototype.qWidth;
 /** @type {number} */
BackendAPI.INxPage.prototype.qHeight;
/**
 * @record
 * @struct
 */
BackendAPI.INxAttrDimInfo = function() {};
 /** @type {number} */
BackendAPI.INxAttrDimInfo.prototype.qCardinal;
 /** @type {number} */
BackendAPI.INxAttrDimInfo.prototype.qSize;
 /** @type {string} */
BackendAPI.INxAttrDimInfo.prototype.qFallbackTitle;
 /** @type {boolean} */
BackendAPI.INxAttrDimInfo.prototype.qLocked;
 /** @type {!BackendAPI.INxValidationError} */
BackendAPI.INxAttrDimInfo.prototype.qError;
/**
 * @record
 * @struct
 */
BackendAPI.INxDimensionInfo = function() {};
 /** @type {string} */
BackendAPI.INxDimensionInfo.prototype.qFallbackTitle;
 /** @type {number} */
BackendAPI.INxDimensionInfo.prototype.qApprMaxGlyphCount;
 /** @type {number} */
BackendAPI.INxDimensionInfo.prototype.qCardinal;
 /** @type {boolean} */
BackendAPI.INxDimensionInfo.prototype.qLocked;
 /** @type {string} */
BackendAPI.INxDimensionInfo.prototype.qSortIndicator;
 /** @type {!Array<string>} */
BackendAPI.INxDimensionInfo.prototype.qGroupFallbackTitles;
 /** @type {number} */
BackendAPI.INxDimensionInfo.prototype.qGroupPos;
 /** @type {!BackendAPI.INxStateCounts} */
BackendAPI.INxDimensionInfo.prototype.qStateCounts;
 /** @type {!Array<string>} */
BackendAPI.INxDimensionInfo.prototype.qTags;
 /** @type {!BackendAPI.INxValidationError} */
BackendAPI.INxDimensionInfo.prototype.qError;
 /** @type {string} */
BackendAPI.INxDimensionInfo.prototype.qDimensionType;
 /** @type {boolean} */
BackendAPI.INxDimensionInfo.prototype.qReverseSort;
 /** @type {string} */
BackendAPI.INxDimensionInfo.prototype.qGrouping;
 /** @type {boolean} */
BackendAPI.INxDimensionInfo.prototype.qIsSemantic;
 /** @type {string} */
BackendAPI.INxDimensionInfo.prototype.qNumFormat;
 /** @type {boolean} */
BackendAPI.INxDimensionInfo.prototype.qIsAutoFormat;
 /** @type {!Array<string>} */
BackendAPI.INxDimensionInfo.prototype.qGroupFieldDefs;
 /** @type {!BackendAPI.INxAttrExprInfo} */
BackendAPI.INxDimensionInfo.prototype.qAttrExprInfo;
 /** @type {number} */
BackendAPI.INxDimensionInfo.prototype.qMin;
 /** @type {number} */
BackendAPI.INxDimensionInfo.prototype.qMax;
 /** @type {boolean} */
BackendAPI.INxDimensionInfo.prototype.qContinuousAxes;
 /** @type {boolean} */
BackendAPI.INxDimensionInfo.prototype.qIsCyclic;
 /** @type {boolean} */
BackendAPI.INxDimensionInfo.prototype.qDerivedField;
 /** @type {!BackendAPI.INxAttrDimInfo} */
BackendAPI.INxDimensionInfo.prototype.qAttrDimInfo;
/**
 * @record
 * @struct
 */
BackendAPI.INxAttrExprInfo = function() {};
 /** @type {number} */
BackendAPI.INxAttrExprInfo.prototype.qMin;
 /** @type {number} */
BackendAPI.INxAttrExprInfo.prototype.qMax;
 /** @type {boolean} */
BackendAPI.INxAttrExprInfo.prototype.qContinuousAxes;
 /** @type {boolean} */
BackendAPI.INxAttrExprInfo.prototype.qIsCyclic;
 /** @type {string} */
BackendAPI.INxAttrExprInfo.prototype.qFallbackTitle;
/**
 * @record
 * @struct
 */
BackendAPI.INxStateCounts = function() {};
 /** @type {number} */
BackendAPI.INxStateCounts.prototype.qLocked;
 /** @type {number} */
BackendAPI.INxStateCounts.prototype.qSelected;
 /** @type {number} */
BackendAPI.INxStateCounts.prototype.qOption;
 /** @type {number} */
BackendAPI.INxStateCounts.prototype.qDeselected;
 /** @type {number} */
BackendAPI.INxStateCounts.prototype.qAlternative;
 /** @type {number} */
BackendAPI.INxStateCounts.prototype.qExcluded;
 /** @type {number} */
BackendAPI.INxStateCounts.prototype.qSelectedExcluded;
 /** @type {number} */
BackendAPI.INxStateCounts.prototype.qLockedExcluded;
/**
 * @record
 * @struct
 */
BackendAPI.INxValidationError = function() {};
 /** @type {number} */
BackendAPI.INxValidationError.prototype.qErrorCode;
 /** @type {string} */
BackendAPI.INxValidationError.prototype.qContext;
 /** @type {string} */
BackendAPI.INxValidationError.prototype.qExtendedMessage;
/**
 * @record
 * @struct
 */
BackendAPI.IFieldAttributes = function() {};
 /** @type {string} */
BackendAPI.IFieldAttributes.prototype.qType;
 /** @type {number} */
BackendAPI.IFieldAttributes.prototype.qnDec;
 /** @type {boolean} */
BackendAPI.IFieldAttributes.prototype.qUseThou;
 /** @type {string} */
BackendAPI.IFieldAttributes.prototype.qFmt;
 /** @type {string} */
BackendAPI.IFieldAttributes.prototype.qDec;
 /** @type {string} */
BackendAPI.IFieldAttributes.prototype.qThou;
 /** @type {!Array<?>} */
BackendAPI.IFieldAttributes.prototype.qSAFEARRAY;
/**
 * @record
 * @struct
 */
BackendAPI.INxMeasureInfo = function() {};
 /** @type {string} */
BackendAPI.INxMeasureInfo.prototype.qFallbackTitle;
 /** @type {number} */
BackendAPI.INxMeasureInfo.prototype.qApprMaxGlyphCount;
 /** @type {number} */
BackendAPI.INxMeasureInfo.prototype.qCardinal;
 /** @type {string} */
BackendAPI.INxMeasureInfo.prototype.qSortIndicator;
 /** @type {!BackendAPI.IFieldAttributes} */
BackendAPI.INxMeasureInfo.prototype.qNumFormat;
 /** @type {boolean} */
BackendAPI.INxMeasureInfo.prototype.qIsAutoFormat;
 /** @type {number} */
BackendAPI.INxMeasureInfo.prototype.qMin;
 /** @type {number} */
BackendAPI.INxMeasureInfo.prototype.qMax;
 /** @type {!BackendAPI.INxValidationError} */
BackendAPI.INxMeasureInfo.prototype.qError;
 /** @type {boolean} */
BackendAPI.INxMeasureInfo.prototype.qReverseSort;
 /** @type {!Array<!BackendAPI.INxAttrExprInfo>} */
BackendAPI.INxMeasureInfo.prototype.qAttrExprInfo;
 /** @type {!Array<!BackendAPI.INxMeasureInfo>} */
BackendAPI.INxMeasureInfo.prototype.qAttrDimInfo;
/**
 * @record
 * @struct
 */
BackendAPI.IRange = function() {};
 /** @type {number} */
BackendAPI.IRange.prototype.qMin;
 /** @type {number} */
BackendAPI.IRange.prototype.qMax;
 /** @type {boolean} */
BackendAPI.IRange.prototype.qMinInclEq;
 /** @type {boolean} */
BackendAPI.IRange.prototype.qMaxInclEq;
/**
 * @record
 * @struct
 */
BackendAPI.INxPatch = function() {};
 /** @type {string} */
BackendAPI.INxPatch.prototype.qOp;
 /** @type {string} */
BackendAPI.INxPatch.prototype.qPath;
 /** @type {string} */
BackendAPI.INxPatch.prototype.qValue;
/**
 * @record
 * @struct
 */
BackendAPI.IBackend = function() {};

/**
 * Aborts the result of a search in a list object. Clears the existing search and returns the
 * object to the state it was in prior to the search started.
 * @return {void}
 */
BackendAPI.IBackend.prototype.abortSearch = function() {};

/**
 * Accepts the result of a search in a list object and the search result is selected in the field.
 * @param {boolean} toggleMode
 * @return {void}
 */
BackendAPI.IBackend.prototype.acceptSearch = function(toggleMode) {};

/**
 * Updates the properties for this object.
 *        #qOp: Add/Remove/Replace
 *        #qPath: Path to property
 *        #qValue: The new value in string format. Strings need to be surrounded by \".
 * @param {!Array<?>} qPatches
 * @param {boolean} qSoftPatch
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.applyPatches = function(qPatches, qSoftPatch) {};

/**
 * Clears unconfirmed selections for this object.
 * @return {void}
 */
BackendAPI.IBackend.prototype.clearSelections = function() {};

/**
 * Clears all soft patches that has previously been applied for this object using the
 * applyPatches method.
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.clearSoftPatches = function() {};

/**
 * Collapse the left dimensions of a pivot table. Only works for hypercubes with
 * qMode = P which are not always fully expanded.
 * @param {number} qRow
 * @param {number} qCol
 * @param {boolean=} qAll
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.collapseLeft = function(qRow, qCol, qAll) {};

/**
 * Collapse the top dimensions of a pivot table. Only works for hypercubes with
 * qMode = P which are not always fully expanded.
 * @param {number} qRow
 * @param {number} qCol
 * @param {boolean=} qAll
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.collapseTop = function(qRow, qCol, qAll) {};

/**
 * Loops through data rows for this object. Only rows that are available client side will be used.
 * Parameters are row number and row data as an array of NxCell objects.
 * The loop is terminated if the function returns false.
 * @param {?} callback
 * @return {!Array<!BackendAPI.INxCell>}
 */
BackendAPI.IBackend.prototype.eachDataRow = function(callback) {};

/**
 * Expands the left dimensions of a pivot table. Only works for hypercubes with
 * qMode = P which are not always fully expanded.
 * @param {number} qRow
 * @param {number} qCol
 * @param {boolean=} qAll
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.expandLeft = function(qRow, qCol, qAll) {};

/**
 * Expands the top dimensions of a pivot table. Only works for hypercubes with
 * qMode = P which are not always fully expanded.
 * @param {number} qRow
 * @param {number} qCol
 * @param {boolean=} qAll
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.expandTop = function(qRow, qCol, qAll) {};

/**
 * Geta data from Qlik engine for this object.
 * @param {!Array<!BackendAPI.INxPage>} qPages
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.getData = function(qPages) {};

/**
 * Gets a data row for this object.
 *                    and need to be fetched with getData method.
 * @param {number} rownum
 * @return {!BackendAPI.INxCell}
 */
BackendAPI.IBackend.prototype.getDataRow = function(rownum) {};

/**
 * Gets qDimensionInfo for this object.
 * @return {!Array<!BackendAPI.INxDimensionInfo>}
 */
BackendAPI.IBackend.prototype.getDimensionInfos = function() {};

/**
 * Gets qMeasureInfo for this object.
 * @return {!BackendAPI.INxMeasureInfo}
 */
BackendAPI.IBackend.prototype.getMeasureInfos = function() {};

/**
 * Gets pivot data from the Qlik engine for this object. Only works for hypercubes with qMode = P.
 * @param {!Array<!BackendAPI.INxPage>} qPages
 * @return {!angular.IPromise<!Array<!BackendAPI.INxPage>>}
 */
BackendAPI.IBackend.prototype.getPivotData = function(qPages) {};

/**
 * Get properties for this object.
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.getProperties = function() {};

/**
 * Get reduced data from the Qlik engine for this object. This method is intended for preserving the
 * shape of the data, not for viewing the actual data points.
 * If set to -1, the Qlik engine decides of the zoom factor.
 * If qReductionMode is D1 or S, the zoom factor is 2n.
 * If the zoom factor is 5, the data are reduced by a factor 32.
 * If qReductionMode is C, the zoom factor defines the number of centroids.
 *        # N for no data reduction.
 *        # D1 to reduce a bar chart or line chart.
 *          The profile of the chart is reduced whatever the number of dimensions in the chart.
 *        # S to reduce the resolution of a scatter plot.
 *        # C to reduce the data of a scatter plot chart.
 *        # ST to reduce the data of a stacked pivot table.
 * @param {!Array<!BackendAPI.INxPage>} qPages
 * @param {number} qZoomFactor
 * @param {string} qReductionMode
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.getReducedData = function(qPages, qZoomFactor, qReductionMode) {};

/**
 * Get total number of data rows for this object.
 * @return {number}
 */
BackendAPI.IBackend.prototype.getRowCount = function() {};

/**
 * Get stacked data from the Qlik engine for this object. Only works for hypercubes with qMode = S.
 * @param {!Array<!BackendAPI.INxPage>} qPages
 * @param {number} qMaxNbrCells
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.getStackedData = function(qPages, qMaxNbrCells) {};

/**
 * Find out if there are unconfirmed selections for this object.
 * @return {boolean}
 */
BackendAPI.IBackend.prototype.hasSelections = function() {};

/**
 * Save this object.
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.save = function() {};

/**
 * Search for a term in a list object. Results in an updated layout, containing only matching records.
 * @param {string} term
 * @return {void}
 */
BackendAPI.IBackend.prototype.search = function(term) {};

/**
 * Select values in this object using ranges.
 * @param {!Array<!BackendAPI.IRange>} qRanges
 * @param {boolean} qOrMode
 * @return {void}
 */
BackendAPI.IBackend.prototype.selectRange = function(qRanges, qOrMode) {};

/**
 * Select values in this object with a Qlik engine call which triggers a repaint of the object.
 * If false, values in the field are selected while previously selected items are deselected.
 * @param {number} qDimNo
 * @param {!Array<?>} qValues
 * @param {boolean} qToggleMode
 * @return {void}
 */
BackendAPI.IBackend.prototype.selectValues = function(qDimNo, qValues, qToggleMode) {};

/**
 * Set properties for this object.
 * @param {?} props
 * @return {!angular.IPromise<?>}
 */
BackendAPI.IBackend.prototype.setProperties = function(props) {};
/** @const */
var RootAPI = {};
/**
 * @record
 * @struct
 */
RootAPI.IAppConfig = function() {};
 /** @type {string} */
RootAPI.IAppConfig.prototype.host;
 /** @type {(string|number)} */
RootAPI.IAppConfig.prototype.port;
 /** @type {string} */
RootAPI.IAppConfig.prototype.prefix;
 /** @type {boolean} */
RootAPI.IAppConfig.prototype.isSecure;
 /** @type {boolean} */
RootAPI.IAppConfig.prototype.openWithoutData;
 /** @type {string} */
RootAPI.IAppConfig.prototype.identity;
/**
 * @record
 * @struct
 */
RootAPI.IGlobalConfig = function() {};
 /** @type {string} */
RootAPI.IGlobalConfig.prototype.host;
 /** @type {string} */
RootAPI.IGlobalConfig.prototype.port;
 /** @type {string} */
RootAPI.IGlobalConfig.prototype.prefix;
 /** @type {boolean} */
RootAPI.IGlobalConfig.prototype.isSecure;
 /** @type {string} */
RootAPI.IGlobalConfig.prototype.identity;
/**
 * @record
 * @struct
 */
RootAPI.IRoot = function() {};
 /** @type {!NavigationAPI.INavigation} */
RootAPI.IRoot.prototype.navigation;

/**
 * Calls the Qlik Sense repository.
 * Refer to Qlik Sense repository documentation for the available paths.
 * @param {string} path
 * @param {string=} method
 * @param {string=} body
 * @return {!angular.IPromise<?>}
 */
RootAPI.IRoot.prototype.callRepository = function(path, method, body) {};

/**
 * currApp
 * Gets a reference to the current app. Use the currApp method in an extension to get a reference to the app currently displayed.
 * @param {?=} object
 * @return {!AppAPI.IApp}
 */
RootAPI.IRoot.prototype.currApp = function(object) {};

/**
 * Gets a list of Qlik Sense apps that you potentially can connect to and registers a callback to receive the data.
 * The getAppList method opens a WebSocket, gets the app list, and then closes the WebSocket.
 * Name | Type | Descr | Name
 * host | String | Optional. Qlik host. | host
 * port | String or integer | Port number. | port
 * prefix | String | Optional. Qlik virtual proxy. "/" if no proxy. | prefix
 * isSecure | Boolean | Optional. Use SSL. | isSecure
 * openWithoutData | Boolean | Optional. Open app without loading data. Introduced in version 1.1. | openWithoutData
 * identity | String | Optional. Unique identity for the session. If omitted, the session will be shared. | identity
 * @param {?} callback
 * @param {?=} config
 * @return {void}
 */
RootAPI.IRoot.prototype.getAppList = function(callback, config) {};

/**
 * Gets a list of extensions installed for Qlik Sense. The reply contains all extensions,
 * that is widget libraries, visualization extensions and mashups.
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
RootAPI.IRoot.prototype.getExtensionList = function(callback) {};

/**
 * Opens a WebSocekt connection to the Qlik engine for global methods.
 * Name | Type | Description
 * host | String | Qlik Sense host
 * port | String | Port number
 * prefix | String | Qlik Sense virtual proxy. / if no virtual proxy
 * isSecure | Boolean | Use SSL
 * identity | String | Unique identity for the session. If omitted, the session will be shared.
 * @param {?} config
 * @return {?}
 */
RootAPI.IRoot.prototype.getGlobal = function(config) {};

/**
 * Opens a Qlik Sense app. You can open multiple apps.
 *      Most other methods are defined on the app. Returns:  App JavaScript object with app methods.
 *     Name   |   Type   | Descr
 *     host   |   String   |   Optional. Qlik host.
 *     port   |   String or Integer   |   Port number.
 *     prefix |   String   |   Optional. Qlik virtual proxy. "/" if no proxy.
 *     isSecure   |   Boolean   |   Optional. Use SSL.
 *     openWithoutData   |   Boolean   |   Optional. Open app without loading data. Introduced in version 1.1.
 *     identity   |   String   |   Optional. Unique identity for the session. If omitted, the session will be shared.
 *     Parameter updated in version 2.2.
 * @param {string} appId
 * @param {?=} config
 * @return {?}
 */
RootAPI.IRoot.prototype.openApp = function(appId, config) {};

/**
 * Registers an extension for use in this mashup. The extension is not installed on the
 * Qlik Sense server and only available in the session where it is created.
 * As long as a JavaScript module is created in the correct format, it can be sent to
 * the registerExtension function.
 * @param {string} id
 * @param {?} impl
 * @param {?=} metadata
 * @return {void}
 */
RootAPI.IRoot.prototype.registerExtension = function(id, impl, metadata) {};

/**
 * Sends a resize event to all Qlik Sense objects.
 * @param {string=} ID
 * @return {void}
 */
RootAPI.IRoot.prototype.resize = function(ID) {};

/**
 * Sets a specific language for the Qlik Sense session.
 * Language should be defined before the app is opened meaning the setLanguage
 * method should be called before the openApp method is called.
 *       # German: short: de long: de-DE
 *       # English: short: en long: en-US
 *       # Spanish: short: es long: es-ES
 *       # French: short: fr long: fr-FR
 *       # Italian: short: it long: it-IT
 *       # Japanese: short: ja long: ja-JP
 *       # Korean: (introduced in version 3.0) short: ko long: ko-KR
 *       # Dutch: short: nl long: nl-NL
 *       # Polish: (introduced in version 3.0) short: pl long: pl-PL
 *       # Brazilian Portuguese: short: pt long: pt-BR
 *       # Russian: short: ru long: ru-RU
 *       # Swedish: short: sv long: sv-SE
 *       # Turkish: (introduced in version 3.0) short: tr long: tr-TR
 *       # Simplified Chinese: short: Do not use! long: zh-CN
 *       # Traditional Chinese: (introduced in version 3.0) short: Do not use! long: zh-TW
 * @param {string} lang
 * @return {void}
 */
RootAPI.IRoot.prototype.setLanguage = function(lang) {};

/**
 * Registers a callback for error handling. Standard Qlik Sense error
 * handling is used if this method is not called.
 * @param {?} onError
 * @param {?=} onWarning
 * @return {void}
 */
RootAPI.IRoot.prototype.setOnError = function(onError, onWarning) {};

/**
 * Create a QTable object that wraps data in your extension and provides an object oriented interface.
 * @param {?} ext
 * @param {string=} path
 * @return {!TableAPI.IQTable}
 */
RootAPI.IRoot.prototype.table = function(ext, path) {};
/** @const */
var AppAPI = {};
/**
 * @record
 * @struct
 */
AppAPI.IApp = function() {};

/**
 * Adds an alternate state in the app. Multiple states within a Qlik Sense
 * app can be created and applied to specific objects within the app.
 * Objects in a given state are not affected by user selection in the other states.
 * @param {string} qStateName
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.addAlternateState = function(qStateName) {};

/**
 * Steps back in the list of selections.
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.back = function() {};

/**
 * Clears all selections in all fields of the current Qlik Sense app.
 * @param {boolean=} lockedAlso
 * @param {string=} state
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.clearAll = function(lockedAlso, state) {};

/**
 * Closes a Qlik Sense app. Also closes the WebSocket and clears out client side data.
 * @return {void}
 */
AppAPI.IApp.prototype.close = function() {};

/**
 * Defines a hypercube and registers a callback to receive the data.
 * @param {?} qHyperCubeDef
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.createCube = function(qHyperCubeDef, callback) {};

/**
 * Creates a generic object and registers a callback to receive the data. The generic object can contain the following:
 *       # qHyperCubeDef
 *       # qListObjectDef
 *       # qStringExpression
 *       # qValueExpression
 * The callback method will be called whenever the selection state changes
 * in a way that affects the generic object.
 * The parameter will be the evaluated version of the definition.
 * @param {?=} def
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.createGenericObject = function(def, callback) {};

/**
 * Defines a list of field values and registers a callback to receive the data.
 * @param {?} qListObjectDef
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.createList = function(qListObjectDef, callback) {};

/**
 * Defines a hypercube for a table and is the entry point to the Table API.
 * It creates a table object that wraps the hypercube.
 * Should, for each entry, be a field name or a NxDimension structure.
 * Should, for each entry, be an expression or a NxMeasure structure.
 *                    empty but that eventually will contain data.
 *                    The table object will be updated when selection state changes.
 * @param {(!Array<?>|!Array<string>)} dimensions
 * @param {(!Array<?>|!Array<string>)} measures
 * @param {?=} options
 * @return {!TableAPI.IQTable}
 */
AppAPI.IApp.prototype.createTable = function(dimensions, measures, options) {};

/**
 * Destroys a Qlik Sense session object created with the createGenericObject
 * method or any of createCube, createList or getList methods.
 * Calling this method removes the object from the Qlik engine,
 * no more updates are sent to the client and all methods on the object are invalid.
 * @param {string} id
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.destroySessionObject = function(id) {};

/**
 * Reloads the data in a Qlik Sense app.
 *       # 0 = default mode.
 *       # 1 = attempt recovery on all errors.
 *       # 2 = fail on all errors.
 * @param {string=} qMode
 * @param {boolean=} qPartial
 * @param {boolean=} qDebug
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.doReload = function(qMode, qPartial, qDebug) {};

/**
 * Saves a Qlik Sense app, including all objects and data in the data model.
 * @param {string=} qFileName
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.doSave = function(qFileName) {};

/**
 * Gets a field reference with methods that can be used to manipulate the field.
 * @param {string=} field
 * @param {string=} state
 * @return {!FieldAPI.IQField}
 */
AppAPI.IApp.prototype.field = function(field, state) {};

/**
 * Step forward in list of selections.
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.forward = function() {};

/**
 * Gets a layout for this Qlik Sense app and registers a callback to receive the data.
 * Returns the dynamic properties (if any) in addition to the fixed properties.
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.getAppLayout = function(callback) {};

/**
 * Gets a list of sheets and visualizations and registers a callback to receive the data.
 *        # sheet
 *        # masterobject
 * Default is sheet.
 * @param {string=} type
 * @param {?=} callback
 * @return {void}
 */
AppAPI.IApp.prototype.getAppObjectList = function(type, callback) {};

/**
 * Gets properties for a generic object, the children of the generic object
 * and the bookmarks and/or embedded snapshots of the generic object.
 * @param {string} id
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.getFullPropertyTree = function(id) {};

/**
 * Gets a list of internal Qlik Sense objects and registers a callback to receive the data.
 *       # FieldList
 *       # MeasureList
 *       # DimensionList
 *       # BookmarkList
 *       # SelectionObject
 *       # SnapshotList (Introduced in version 1.1)
 *       # MediaList (Introduced in version 1.1)
 *       # Sheet (Introduced in version 1.1)
 *       # MasterObject (Introduced in version 1.1)
 *       # VariableList (Introduced in version 2.0)
 *       # story (Introduced in version 2.1)
 * @param {string} type
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.getList = function(type, callback) {};

/**
 * Retrieves a Qlik Sense object from the Qlik Sense application and inserts
 * it into a HTML element. The object fills the HTML object, so you can size
 * and position the element to determine how large the Qlik Sense object will be.
 * If you supply only one parameter, you get the model without displaying the object.
 * Since version 1.1 it is also possible to define a string of the HTML element id.
 * Name | Type | Description
 * noInteraction | Boolean | Set to true if you want to disable interaction,
 *                           including selections, in the visualization.
 *                           Introduced in version 1.1 and updated in version 3.0.
 * noSelections  | Boolean | Set to true if you want to disable selections in the visualization.
 *                           Introduced in version 3.0.
 * @param {string} id
 * @param {?=} elem
 * @param {?=} options
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.getObject = function(id, elem, options) {};

/**
 * Gets properties for a Qlik Sense object.
 * @param {string} id
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.getObjectProperties = function(id) {};

/**
 * Inserts a Qlik Sense snapshot into a HTML element. The snapshot fills
 * the HTML object so you can size and position the element to determine
 * how large the Qlik Sense object will be. If you only supply one parameter,
 * you will just get the model without displaying the object.
 * @param {string} id
 * @param {?=} elem
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.getSnapshot = function(id, elem) {};

/**
 * Locks all selections.
 * Default: $
 * Introduced in version 2.1.
 * @param {string=} state
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.lockAll = function(state) {};

/**
 * Removes an alternate state in the app.
 * @param {string} qStateName
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.removeAlternateState = function(qStateName) {};

/**
 * Searches for one or more terms in the values of a Qlik Sense app.
 * Name | Type | Description
 * qOffset | Number | Position from the top, starting from 0.
 * qCount | Number | Number of search results to return.
 * qMaxNbrFieldMatches | Number | Maximum number of matching values to return per search result.
 * Name | Type | Description
 * qSearchFields | Array | List of search fields.
 * qContext | | Search context. Can be one of:
 *       # Cleared: In this mode, the first step is to clear any current selections in the app.
 *                  The second step is to search for one or more terms in the values of the app.
 *       # LockedFieldsOnly: In this mode, the search applies only to the values associated
 *                           with the selections made in locked fields, ignoring selections
 *                           in any unlocked field. If no locked fields, the behavior is
 *                           identical to the Cleared context. You cannot make any new selections
 *                           in a locked field. You can get search hits for the associated values
 *                           of a locked field but you cannot get the search hits for the non associative values.
 *       # CurrentSelections:In this mode, the current selections are kept (if any). Search
 *                           for one or more terms in the values of the app. New selections
 *                           are made on top of the current selections. If no selections were
 *                           made before the search, this mode is identical to the Cleared context.
 * | | Default value is LockedFieldsOnly.
 * @param {!Array<?>} qTerms
 * @param {?} qPage
 * @param {?} qOptions
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.searchAssociations = function(qTerms, qPage, qOptions, callback) {};

/**
 * Searches for one or more terms in the values of a Qlik Sense app.
 * Name | Type | Description
 * qOffset | Number | Position from the top, starting from 0.
 * qCount | Number | Number of search results to return.
 * qGroupOptions | Array | This parameter is optional. Options of the search groups. If this property is not set, all values are returned.
 * qGroupItemOptions | Array | This parameter is optional. Options of the search group items. If this property is not set, all values are returned.
 * qOptions | Object | Optional. Search options. Properties:
 * Name | Type | Description
 * qSearchFields | Array | List of search fields.
 * qContext | | Search context. Can be one of:
 *       # Cleared: In this mode, the first step is to clear any current selections in the app.
 *                  The second step is to search for one or more terms in the values of the app.
 *       # LockedFieldsOnly: In this mode, the search applies only to the values associated
 *                           with the selections made in locked fields, ignoring selections
 *                           in any unlocked field. If no locked fields, the behavior is
 *                           identical to the Cleared context. You cannot make any new selections
 *                           in a locked field. You can get search hits for the associated values
 *                           of a locked field but you cannot get the search hits for the non associative values.
 *       # CurrentSelections:In this mode, the current selections are kept (if any). Search
 *                           for one or more terms in the values of the app. New selections
 *                           are made on top of the current selections. If no selections were
 *                           made before the search, this mode is identical to the Cleared context.
 * | | Default value is LockedFieldsOnly.
 * @param {!Array<?>} qTerms
 * @param {?} qPage
 * @param {?=} qOptions
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.searchResults = function(qTerms, qPage, qOptions, callback) {};

/**
 * Returns suggestions of words from the values entered in the search. Acts as a helper for the searchAssociations method.
 * Name | Type | Description
 * qSearchFields | Array | List of search fields.
 * @param {!Array<?>} qTerms
 * @param {?=} qOptions
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.searchSuggest = function(qTerms, qOptions, callback) {};

/**
 * Makes a selection based on searchAssociation results.
 * @param {number} qMatchIx
 * @param {!Array<?>} qTerms
 * @param {?=} qOptions
 * @param {?=} qSoftLock
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.selectAssociations = function(qMatchIx, qTerms, qOptions, qSoftLock) {};

/**
 * Creates a QSelectionState object that encapsulates the selection state. Entry point to the Selection API.
 * @param {string=} state
 * @return {!SelectionStateAPI.IQSelectionState}
 */
AppAPI.IApp.prototype.selectionState = function(state) {};

/**
 * Unlocks all selections that has previously been locked.
 * @param {string=} state
 * @return {!angular.IPromise<?>}
 */
AppAPI.IApp.prototype.unlockAll = function(state) {};
/** @const */
var BookmarkAPI = {};
/**
 * @record
 * @struct
 */
BookmarkAPI.IBookmark = function() {};

/**
 * Applies a bookmark.
 * @param {string} id
 * @return {!angular.IPromise<?>}
 */
BookmarkAPI.IBookmark.prototype.apply = function(id) {};

/**
 * Creates a bookmark based on the current selection.
 * @param {string} title
 * @param {string} description
 * @param {string=} sheetId
 * @return {!angular.IPromise<?>}
 */
BookmarkAPI.IBookmark.prototype.create = function(title, description, sheetId) {};

/**
 * Removes a bookmark.
 * @param {string} id
 * @return {!angular.IPromise<?>}
 */
BookmarkAPI.IBookmark.prototype.remove = function(id) {};
/** @const */
var FieldAPI = {};
/**
 * @record
 * @struct
 */
FieldAPI.IQField = function() {};
 /** @type {!Array<!FieldAPI.IQFieldValue>} */
FieldAPI.IQField.prototype.rows;
 /** @type {number} */
FieldAPI.IQField.prototype.rowCount;
 /** @type {?} */
FieldAPI.IQField.prototype.qStateCounts;

/**
 * Clears a field selection.
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.clear = function() {};

/**
 * Clears all fields except the selected one.
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.clearOther = function(softlock) {};

/**
 * Gets field data. The values are available as QFieldValue in array
 * field.rows and will updated when the selection state changes.
 * Notification OnData will be triggered after each update.
 * Name | Type | Description
 * rows | Number | Number of rows to fetch. Default: 200.
 * frequencyMode | String | Can be one of:
 *       # V=Absolute
 *       # P=Percent
 *       # R=Relative
 *       # N=No frequency
 *      |        | Default: V.
 * @param {boolean=} options
 * @return {!FieldAPI.IQField}
 */
FieldAPI.IQField.prototype.getData = function(options) {};

/**
 * Gets more data for your field. Notification OnData is triggered when complete.
 * @return {!FieldAPI.IQField}
 */
FieldAPI.IQField.prototype.getMoreData = function() {};

/**
 * Locks a field selection.
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.lock = function() {};

/**
 * Selects field values using indexes.
 * @param {!Array<number>} Array
 * @param {boolean=} toggle
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.select = function(Array, toggle, softlock) {};

/**
 * Selects all values in a field.
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.selectAll = function(softlock) {};

/**
 * Selects alternative values in a field.
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.selectAlternative = function(softlock) {};

/**
 * Selects excluded values in a field.
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.selectExcluded = function(softlock) {};

/**
 * Selects matching field values.
 * @param {string} match
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.selectMatch = function(match, softlock) {};

/**
 * Selects possible values in a field.
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.selectPossible = function(softlock) {};

/**
 * Selects specific values in a field.
 *                         strings or numbers also works since version 1.1.
 * For a numeric field you need to provide the numeric value.
 * @param {!Array<!FieldAPI.IQFieldValue>} array
 * @param {boolean=} toggle
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.selectValues = function(array, toggle, softlock) {};

/**
 * Toggles a field selection.
 * @param {string} match
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.toggleSelect = function(match, softlock) {};

/**
 * Unlocks field selections.
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQField.prototype.unlock = function() {};
/**
 * @record
 * @struct
 */
FieldAPI.IQFieldValue = function() {};
 /** @type {string} */
FieldAPI.IQFieldValue.prototype.qText;
 /** @type {number} */
FieldAPI.IQFieldValue.prototype.qElemNumber;
 /** @type {?} */
FieldAPI.IQFieldValue.prototype.qState;
 /** @type {number} */
FieldAPI.IQFieldValue.prototype.qNum;
 /** @type {string} */
FieldAPI.IQFieldValue.prototype.qFrequency;

/**
 * Selects a field value.
 * @param {boolean=} toggle
 * @param {boolean=} softlock
 * @return {!angular.IPromise<?>}
 */
FieldAPI.IQFieldValue.prototype.select = function(toggle, softlock) {};
/** @const */
var GlobalAPI = {};
/**
 * @record
 * @struct
 */
GlobalAPI.IGlobal = function() {};

/**
 * Cancels an ongoing reload. The reload of the app is stopped.
 * @return {!angular.IPromise<?>}
 */
GlobalAPI.IGlobal.prototype.cancelReload = function() {};

/**
 * Gets a list of Qlik Sense apps that you potentially can connect to and
 * registers a callback to receive the data. Calling the getAppList method
 * opens a WebSocket, gets the app list, and then keeps the WebSocket open
 * for you to make other calls as well.
 * @param {?} callback
 * @return {void}
 */
GlobalAPI.IGlobal.prototype.getAppList = function(callback) {};

/**
 * Gets information (user directory and user id) about the authenticated user.
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
GlobalAPI.IGlobal.prototype.getAuthenticatedUser = function(callback) {};

/**
 * Gets information about progress of doReload and doSave calls.
 * Complete information is returned if the identifier of the request is specified.
 * If qRequestId = 0, less information is returned.
 * @param {number} qRequestId
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
GlobalAPI.IGlobal.prototype.getProgress = function(qRequestId, callback) {};

/**
 * Gets the product version.
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
GlobalAPI.IGlobal.prototype.getProductVersion = function(callback) {};

/**
 * Gets the Qlik product name.
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
GlobalAPI.IGlobal.prototype.getQTProduct = function(callback) {};

/**
 * Gets the Qlik Sense version number.
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
GlobalAPI.IGlobal.prototype.getQvVersion = function(callback) {};

/**
 * Gets information if the user is working in personal mode
 * (returns true if Qlik Sense Desktop is used) or not
 * (returns false if Qlik Sense Desktop is not used).
 * @param {?=} callback
 * @return {!angular.IPromise<?>}
 */
GlobalAPI.IGlobal.prototype.isPersonalMode = function(callback) {};
/** @const */
var NavigationAPI = {};

/** @typedef {string} */
NavigationAPI.NavigationModeType;

/** @typedef {string} */
NavigationAPI.NavigationErrorType;
/**
 * @record
 * @struct
 */
NavigationAPI.NavigationResult = function() {};
 /** @type {boolean} */
NavigationAPI.NavigationResult.prototype.success;
 /** @type {string} */
NavigationAPI.NavigationResult.prototype.sheetId;
 /** @type {string} */
NavigationAPI.NavigationResult.prototype.storyId;
 /** @type {string} */
NavigationAPI.NavigationResult.prototype.mode;
 /** @type {string} */
NavigationAPI.NavigationResult.prototype.error;
 /** @type {string} */
NavigationAPI.NavigationResult.prototype.errorMsg;
/**
 * @record
 * @struct
 */
NavigationAPI.INavigation = function() {};
 /** @type {string} */
NavigationAPI.INavigation.prototype.edit;
 /** @type {string} */
NavigationAPI.INavigation.prototype.analysis;

/**
 * Gets the current sheet ID.
 * @return {!NavigationAPI.NavigationResult}
 */
NavigationAPI.INavigation.prototype.getCurrentSheetId = function() {};

/**
 * Gets the current mode.
 * @return {string}
 */
NavigationAPI.INavigation.prototype.getMode = function() {};

/**
 * Navigate to a given sheet in the current app.
 * The method will return before the actual navigation takes place.
 * @param {string} sheetId
 * @return {!NavigationAPI.NavigationResult}
 */
NavigationAPI.INavigation.prototype.gotoSheet = function(sheetId) {};

/**
 * Navigate to a given story in the current app.
 * The method will return before the actual navigation takes place.
 * @param {string} storyId
 * @return {!NavigationAPI.NavigationResult}
 */
NavigationAPI.INavigation.prototype.gotoStory = function(storyId) {};

/**
 * Checks if a given mode is allowed.
 * or one of the constants: qlik.navigation.EDIT   |   qlik.navigation.ANALYSIS
 * @param {string} mode
 * @return {boolean}
 */
NavigationAPI.INavigation.prototype.isModeAllowed = function(mode) {};

/**
 * Go to the next sheet in the current app.
 * It will do nothing if you do not have sheets in the current context.
 * The method will return before the actual navigation takes place.
 * @return {!NavigationAPI.NavigationResult}
 */
NavigationAPI.INavigation.prototype.nextSheet = function() {};

/**
 * Jumps to the previous sheet in the current app.
 * It will do nothing if you do not have sheets in the current context.
 * The method will return before the actual navigation takes place
 * @return {!NavigationAPI.NavigationResult}
 */
NavigationAPI.INavigation.prototype.prevSheet = function() {};

/**
 * Sets the current working mode of Qlik Sense.
 * or one of the constants: qlik.navigation.EDIT   |   qlik.navigation.ANALYSIS
 * @param {string} mode
 * @return {!NavigationAPI.NavigationResult}
 */
NavigationAPI.INavigation.prototype.setMode = function(mode) {};

/**
 * Switches the working mode of Qlik Sense.
 * or one of the constants: qlik.navigation.EDIT   |   qlik.navigation.ANALYSIS
 * @param {string} mode
 * @return {!NavigationAPI.NavigationResult}
 */
NavigationAPI.INavigation.prototype.switchMode = function(mode) {};
/** @const */
var SelectionStateAPI = {};
/**
 * @record
 * @struct
 */
SelectionStateAPI.IQFieldSelections = function() {};
 /** @type {string} */
SelectionStateAPI.IQFieldSelections.prototype.fieldName;
 /** @type {number} */
SelectionStateAPI.IQFieldSelections.prototype.qSortIndex;
 /** @type {!FieldAPI.IQField} */
SelectionStateAPI.IQFieldSelections.prototype.field;
 /** @type {boolean} */
SelectionStateAPI.IQFieldSelections.prototype.locked;
 /** @type {boolean} */
SelectionStateAPI.IQFieldSelections.prototype.isNumeric;
 /** @type {number} */
SelectionStateAPI.IQFieldSelections.prototype.totalCount;
 /** @type {number} */
SelectionStateAPI.IQFieldSelections.prototype.selectedCount;
 /** @type {number} */
SelectionStateAPI.IQFieldSelections.prototype.qSelectionThreshold;
 /** @type {?} */
SelectionStateAPI.IQFieldSelections.prototype.qStateCounts;
 /** @type {string} */
SelectionStateAPI.IQFieldSelections.prototype.qSelected;
 /** @type {!Array<number>} */
SelectionStateAPI.IQFieldSelections.prototype.selectedValues;
 /** @type {!Array<number>} */
SelectionStateAPI.IQFieldSelections.prototype.notSelectedValues;
/**
 * @record
 * @struct
 */
SelectionStateAPI.IQSelectionState = function() {};
 /** @type {string} */
SelectionStateAPI.IQSelectionState.prototype.stateName;
 /** @type {!SelectionStateAPI.IQFieldSelections} */
SelectionStateAPI.IQSelectionState.prototype.selections;
 /** @type {number} */
SelectionStateAPI.IQSelectionState.prototype.backCount;
 /** @type {number} */
SelectionStateAPI.IQSelectionState.prototype.forwardCount;

/**
 * Cleara all selections in this state.
 * @param {boolean} lockedAlso
 * @return {!angular.IPromise<?>}
 */
SelectionStateAPI.IQSelectionState.prototype.clearAll = function(lockedAlso) {};

/**
 * Locks all selections in this state.
 * @return {!angular.IPromise<?>}
 */
SelectionStateAPI.IQSelectionState.prototype.lockAll = function() {};

/**
 * Unlocks all selections in this state.
 * @return {!angular.IPromise<?>}
 */
SelectionStateAPI.IQSelectionState.prototype.unlockAll = function() {};
/** @const */
var TableAPI = {};
/**
 * @record
 * @struct
 */
TableAPI.IQTable = function() {};
 /** @type {!Array<!TableAPI.IQRow>} */
TableAPI.IQTable.prototype.rows;
 /** @type {!Array<!TableAPI.IQHeader>} */
TableAPI.IQTable.prototype.headers;
 /** @type {!Array<!TableAPI.IQMeasureCell>} */
TableAPI.IQTable.prototype.totals;
 /** @type {number} */
TableAPI.IQTable.prototype.rowCount;
 /** @type {number} */
TableAPI.IQTable.prototype.colCount;

/**
 * Exports data of the underlying hypercube in OOXML or CSV format.
 * Name | Type | Description
 * format | String | Data format. Can be one of:
 *       # OOXML: open XML, default
 *       # CSV_C: comma separated CSV
 *       # CSV_T: tab separated CSV
 * filename | String | Name of the exported file after download from browser.
 *                     This parameter is optional and only used in desktop.
 * state | String | Can be:
 *       # A: all values
 *       # P: possible values (default)
 * download | Boolean | Automatically start download of file (with window.open).
 * @param {?=} options
 * @param {?=} callback
 * @return {void}
 */
TableAPI.IQTable.prototype.exportData = function(options, callback) {};

/**
 * Gets the column number for a given field name.
 * @param {string} fld
 * @return {number}
 */
TableAPI.IQTable.prototype.getColByName = function(fld) {};

/**
 * Gets more data for your qHyperCube.
 * @return {?}
 */
TableAPI.IQTable.prototype.getMoreData = function() {};
/**
 * @record
 * @struct
 */
TableAPI.IQHeader = function() {};
 /** @type {string} */
TableAPI.IQHeader.prototype.qFallbackTitle;
 /** @type {string} */
TableAPI.IQHeader.prototype.qSortIndicator;
 /** @type {boolean} */
TableAPI.IQHeader.prototype.isOrderedBy;
 /** @type {boolean} */
TableAPI.IQHeader.prototype.qReverseSort;
 /** @type {number} */
TableAPI.IQHeader.prototype.col;
 /** @type {number} */
TableAPI.IQHeader.prototype.qCardinal;
 /** @type {?} */
TableAPI.IQHeader.prototype.qStateCounts;
 /** @type {?} */
TableAPI.IQHeader.prototype.field;
 /** @type {number} */
TableAPI.IQHeader.prototype.qMin;
 /** @type {number} */
TableAPI.IQHeader.prototype.qMax;
 /** @type {number} */
TableAPI.IQHeader.prototype.errorCode;
 /** @type {number} */
TableAPI.IQHeader.prototype.errorMessage;

/**
 * Sets this column to be the first in the sort order.
 * @return {void}
 */
TableAPI.IQHeader.prototype.orderBy = function() {};

/**
 * Reverses the sort order for this column.
 * @return {void}
 */
TableAPI.IQHeader.prototype.reverseOrder = function() {};

/**
 * Select a range in this measure.
 * @param {number} min
 * @param {number} max
 * @param {boolean=} inclMin
 * @param {boolean=} inclMax
 * @return {!angular.IPromise<?>}
 */
TableAPI.IQHeader.prototype.selectRange = function(min, max, inclMin, inclMax) {};
/**
 * @record
 * @struct
 */
TableAPI.IQRow = function() {};
 /** @type {!Array<!TableAPI.IQDimensionCell>} */
TableAPI.IQRow.prototype.dimensions;
 /** @type {!Array<!TableAPI.IQMeasureCell>} */
TableAPI.IQRow.prototype.measures;
 /** @type {!Array<?>} */
TableAPI.IQRow.prototype.cells;
/**
 * @extends {TableAPI.IQMeasureCell}
 * @record
 * @struct
 */
TableAPI.IQDimensionCell = function() {};
 /** @type {number} */
TableAPI.IQDimensionCell.prototype.qElemNumber;
 /** @type {string} */
TableAPI.IQDimensionCell.prototype.qState;

/**
 * Selects the value in this cell.
 * @return {void}
 */
TableAPI.IQDimensionCell.prototype.select = function() {};
/**
 * @record
 * @struct
 */
TableAPI.IQMeasureCell = function() {};
 /** @type {string} */
TableAPI.IQMeasureCell.prototype.qText;
 /** @type {number} */
TableAPI.IQMeasureCell.prototype.qNum;

/**
 * Gets the value of this cell as a percentage of the total.
 * Might be more than 100% if this is an average.
 * @return {number}
 */
TableAPI.IQMeasureCell.prototype.getPercent = function() {};

/**
 * Gets the value of this cell as a percentage of the maximum.
 * @return {number}
 */
TableAPI.IQMeasureCell.prototype.getPercentOfMax = function() {};
/** @const */
var VariableAPI = {};
/**
 * @record
 * @struct
 */
VariableAPI.IVariable = function() {};

/**
 * Creates a variable.
 * Name | Type | Description
 * qInfo.qId | String | Optional. Variable id. If the selected ID is already in use, a new ID is automatically set by the engine.
 * qName | String | Variable name. The name must be unique.
 * qComment | String | Optional. Comment related to the variable.
 * qDefinition | String | Optional. Variable definition.
 * qNumberPresentation | Object | Optional. Defines the format of the value.
 * qIncludeInBookmark | Boolean | Optional. Set to true to update the variable when applying a bookmark. The variable value will be persisted in the bookmark.
 * @param {?} qProp
 * @return {!angular.IPromise<?>}
 */
VariableAPI.IVariable.prototype.create = function(qProp) {};

/**
 * Creates a session variable, that is a temporary variable which is not
 * persisted and needs to be recreated for each new session.
 * Name | Type | Description
 * qInfo.qId | String | Optional. Variable id.
 * qName | String | Variable name.
 * qComment | String | Optional. Comment.
 * qDefinition | String | Optional. Variable definition.
 * qNumberPresentation | Object | Optional.
 * qIncludeInBookmark | Boolean | Optional. Include in bookmark flag.
 * @param {?} qProp
 * @return {!angular.IPromise<?>}
 */
VariableAPI.IVariable.prototype.createSessionVariable = function(qProp) {};

/**
 * Gets a variable by id.
 * @param {string} qId
 * @return {!angular.IPromise<?>}
 */
VariableAPI.IVariable.prototype.get = function(qId) {};

/**
 * Gets a variable by name.
 * @param {string} qName
 * @return {!angular.IPromise<?>}
 */
VariableAPI.IVariable.prototype.getByName = function(qName) {};

/**
 * Gets variable content.
 * @param {string} name
 * @param {?} callback
 * @return {!angular.IPromise<?>}
 */
VariableAPI.IVariable.prototype.getContent = function(name, callback) {};

/**
 * Sets the content of a variable.
 * @param {string} name
 * @param {string} content
 * @return {!angular.IPromise<?>}
 */
VariableAPI.IVariable.prototype.setContent = function(name, content) {};

/**
 * Sets a numeric value as a variable.
 * @param {string} qName
 * @param {number} qVal
 * @return {!angular.IPromise<?>}
 */
VariableAPI.IVariable.prototype.setNumValue = function(qName, qVal) {};

/**
 * Sets variable string value.
 * @param {string} qName
 * @param {string} qVal
 * @return {!angular.IPromise<?>}
 */
VariableAPI.IVariable.prototype.setStringValue = function(qName, qVal) {};
/** @const */
var VisualizationAPI = {};

/** @typedef {string} */
VisualizationAPI.VisualizationType;
/**
 * @record
 * @struct
 */
VisualizationAPI.IVisualization = function() {};

/**
 * Create a new visualization on the fly based on a session object
 * and will not be persisted in the app.
 *       # barchart
 *       # combochart
 *       # gauge
 *       # kpi
 *       # linechart
 *       # piechart
 *       # pivot-table
 *       # scatterplot
 *       # table
 *       # treemap
 *       # extension
 *       Each entry can be of the following structures:
 *       # String
 *       # NxDimension
 *       # NxMeasure
 *       If the NxDimension or the NxMeasure refer to a library dimension
 *       or a library measure, you also need to add qType : "measure" or "dimension".
 * @param {string} type
 * @param {!Array<?>=} cols
 * @param {?=} options
 * @return {!angular.IPromise<?>}
 */
VisualizationAPI.IVisualization.prototype.create = function(type, cols, options) {};

/**
 * Gets an existing visualization.
 * @param {string} id
 * @return {!angular.IPromise<?>}
 */
VisualizationAPI.IVisualization.prototype.get = function(id) {};
/**
 * @record
 * @struct
 */
VisualizationAPI.IQVisualization = function() {};
 /** @type {!TableAPI.IQTable} */
VisualizationAPI.IQVisualization.prototype.table;

/**
 * Closes a visualization and releases the session object.
 * @return {!angular.IPromise<?>}
 */
VisualizationAPI.IQVisualization.prototype.close = function() {};

/**
 * Tells the visualization it has been resized and should re-paint.
 * @return {void}
 */
VisualizationAPI.IQVisualization.prototype.resize = function() {};

/**
 * Sets options for a visualization.
 * @param {?=} options
 * @return {void}
 */
VisualizationAPI.IQVisualization.prototype.setOptions = function(options) {};

/**
 * Shows the visualization in an HTML element.
 * Name | Type | Description
 * noInteraction | Boolean | Set to true if you want to disable all interaction, including selections, in the visualization.
 * noSelections | Boolean | Set to true if you want to disable selections in the visualization.
 * | | Parameter introduced in version 3.0.
 * @param {?=} element
 * @param {?=} options
 * @return {void}
 */
VisualizationAPI.IQVisualization.prototype.show = function(element, options) {};
/** @const */
var ExtensionAPI = {};
/**
 * @record
 * @struct
 */
ExtensionAPI.IExtensionModel = function() {};
/**
 * @record
 * @struct
 */
ExtensionAPI.IExtensionComponent = function() {};
 /** @type {!ExtensionAPI.IExtensionModel} */
ExtensionAPI.IExtensionComponent.prototype.model;
/**
 * @extends {angular.IScope}
 * @record
 * @struct
 */
ExtensionAPI.IExtensionScope = function() {};
 /** @type {!ExtensionAPI.IExtensionComponent} */
ExtensionAPI.IExtensionScope.prototype.component;

/** @typedef {string} */
ExtensionAPI.SelectionModeType;
/**
 * @record
 * @struct
 */
ExtensionAPI.IInitialProperties = function() {};
 /** @type {?} */
ExtensionAPI.IInitialProperties.prototype.qHyperCubeDef;
 /** @type {?} */
ExtensionAPI.IInitialProperties.prototype.qListObjectDef;
 /** @type {boolean} */
ExtensionAPI.IInitialProperties.prototype.fixed;
 /** @type {number} */
ExtensionAPI.IInitialProperties.prototype.width;
 /** @type {boolean} */
ExtensionAPI.IInitialProperties.prototype.percent;
 /** @type {string} */
ExtensionAPI.IInitialProperties.prototype.selectionMode;
/**
 * @record
 * @struct
 */
ExtensionAPI.ISupport = function() {};
 /** @type {boolean} */
ExtensionAPI.ISupport.prototype.snapshot;
 /** @type {boolean} */
ExtensionAPI.ISupport.prototype.export;
 /** @type {boolean} */
ExtensionAPI.ISupport.prototype.exportData;
/**
 * @record
 * @struct
 */
ExtensionAPI.IExtension = function() {};
 /** @type {!ExtensionAPI.IDefinition} */
ExtensionAPI.IExtension.prototype.definition;
 /** @type {!ExtensionAPI.IInitialProperties} */
ExtensionAPI.IExtension.prototype.initialProperties;
 /** @type {string} */
ExtensionAPI.IExtension.prototype.template;
 /** @type {?} */
ExtensionAPI.IExtension.prototype.controller;
 /** @type {!ExtensionAPI.ISupport} */
ExtensionAPI.IExtension.prototype.support;

/**
 * @param {!HTMLElement} $element
 * @param {?=} layout
 * @return {void}
 */
ExtensionAPI.IExtension.prototype.paint = function($element, layout) {};
 /** @type {boolean} */
ExtensionAPI.ISupport.prototype.snapshot;
 /** @type {boolean} */
ExtensionAPI.ISupport.prototype.export;
 /** @type {boolean} */
ExtensionAPI.ISupport.prototype.canTakeSnapshot;

/** @typedef {string} */
ExtensionAPI.ExpressionType;

/** @typedef {function(): T} */
ExtensionAPI.func;

/** @typedef {(T|function(): T)} */
ExtensionAPI.valueOrfunc;
/**
 * @record
 * @struct
 */
ExtensionAPI.ICustomControlOption = function() {};
 /** @type {string} */
ExtensionAPI.ICustomControlOption.prototype.value;
 /** @type {string} */
ExtensionAPI.ICustomControlOption.prototype.label;
/**
 * @record
 * @struct
 */
ExtensionAPI.ICustomControl = function() {};
 /** @type {string} */
ExtensionAPI.ICustomControl.prototype.type;
 /** @type {string} */
ExtensionAPI.ICustomControl.prototype.label;
 /** @type {string} */
ExtensionAPI.ICustomControl.prototype.ref;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomString = function() {};
 /** @type {string} */
ExtensionAPI.ICustomString.prototype.defaultValue;
 /** @type {string} */
ExtensionAPI.ICustomString.prototype.expression;
 /** @type {(boolean|function(): boolean)} */
ExtensionAPI.ICustomString.prototype.show;
 /** @type {number} */
ExtensionAPI.ICustomString.prototype.maxlength;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomNumber = function() {};
 /** @type {number} */
ExtensionAPI.ICustomNumber.prototype.defaultValue;
 /** @type {number} */
ExtensionAPI.ICustomNumber.prototype.min;
 /** @type {number} */
ExtensionAPI.ICustomNumber.prototype.max;
/**
 * @extends {ExtensionAPI.ICustomNumber}
 * @record
 * @struct
 */
ExtensionAPI.ICustomInteger = function() {};
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomArray = function() {};
 /** @type {string} */
ExtensionAPI.ICustomArray.prototype.itemTitleRef;
 /** @type {string} */
ExtensionAPI.ICustomArray.prototype.addTranslation;
 /** @type {boolean} */
ExtensionAPI.ICustomArray.prototype.allowAdd;
 /** @type {boolean} */
ExtensionAPI.ICustomArray.prototype.allowMove;
 /** @type {boolean} */
ExtensionAPI.ICustomArray.prototype.allowRemove;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomButton = function() {};
 /** @type {string} */
ExtensionAPI.ICustomButton.prototype.label;
 /** @type {string} */
ExtensionAPI.ICustomButton.prototype.component;
 /** @type {(void|function(): void)} */
ExtensionAPI.ICustomButton.prototype.action;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomButtonGroup = function() {};
 /** @type {string} */
ExtensionAPI.ICustomButtonGroup.prototype.component;
 /** @type {string} */
ExtensionAPI.ICustomButtonGroup.prototype.defaultValue;
 /** @type {(!ExtensionAPI.ICustomControlOption|function(): !ExtensionAPI.ICustomControlOption)} */
ExtensionAPI.ICustomButtonGroup.prototype.options;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomCheckBox = function() {};
 /** @type {string} */
ExtensionAPI.ICustomCheckBox.prototype.component;
 /** @type {boolean} */
ExtensionAPI.ICustomCheckBox.prototype.defaultValue;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomColorPicker = function() {};
 /** @type {string} */
ExtensionAPI.ICustomColorPicker.prototype.component;
 /** @type {number} */
ExtensionAPI.ICustomColorPicker.prototype.defaultValue;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomDropDownList = function() {};
 /** @type {string} */
ExtensionAPI.ICustomDropDownList.prototype.component;
 /** @type {string} */
ExtensionAPI.ICustomDropDownList.prototype.defaultValue;
 /** @type {(!ExtensionAPI.ICustomControlOption|function(): !ExtensionAPI.ICustomControlOption)} */
ExtensionAPI.ICustomDropDownList.prototype.options;
/**
 * @record
 * @struct
 */
ExtensionAPI.ICustomLink = function() {};
 /** @type {string} */
ExtensionAPI.ICustomLink.prototype.type;
 /** @type {string} */
ExtensionAPI.ICustomLink.prototype.component;
 /** @type {string} */
ExtensionAPI.ICustomLink.prototype.label;
 /** @type {string} */
ExtensionAPI.ICustomLink.prototype.url;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomMedia = function() {};
 /** @type {string} */
ExtensionAPI.ICustomMedia.prototype.component;
 /** @type {string} */
ExtensionAPI.ICustomMedia.prototype.layoutRef;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomRadioButton = function() {};
 /** @type {string} */
ExtensionAPI.ICustomRadioButton.prototype.component;
 /** @type {string} */
ExtensionAPI.ICustomRadioButton.prototype.defaultValue;
 /** @type {(!ExtensionAPI.ICustomControlOption|function(): !ExtensionAPI.ICustomControlOption)} */
ExtensionAPI.ICustomRadioButton.prototype.options;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomSlider = function() {};
 /** @type {string} */
ExtensionAPI.ICustomSlider.prototype.component;
 /** @type {number} */
ExtensionAPI.ICustomSlider.prototype.defaultValue;
 /** @type {number} */
ExtensionAPI.ICustomSlider.prototype.min;
 /** @type {number} */
ExtensionAPI.ICustomSlider.prototype.max;
 /** @type {number} */
ExtensionAPI.ICustomSlider.prototype.step;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomRangeSlider = function() {};
 /** @type {string} */
ExtensionAPI.ICustomRangeSlider.prototype.component;
 /** @type {!Array<number>} */
ExtensionAPI.ICustomRangeSlider.prototype.defaultValue;
 /** @type {number} */
ExtensionAPI.ICustomRangeSlider.prototype.min;
 /** @type {number} */
ExtensionAPI.ICustomRangeSlider.prototype.max;
 /** @type {number} */
ExtensionAPI.ICustomRangeSlider.prototype.step;
/**
 * @record
 * @struct
 */
ExtensionAPI.ICustomSwitch = function() {};
 /** @type {string} */
ExtensionAPI.ICustomSwitch.prototype.component;
 /** @type {boolean} */
ExtensionAPI.ICustomSwitch.prototype.defaultValue;
 /** @type {(!ExtensionAPI.ICustomControlOption|function(): !ExtensionAPI.ICustomControlOption)} */
ExtensionAPI.ICustomSwitch.prototype.options;
/**
 * @record
 * @struct
 */
ExtensionAPI.ICustomText = function() {};
 /** @type {string} */
ExtensionAPI.ICustomText.prototype.type;
 /** @type {string} */
ExtensionAPI.ICustomText.prototype.component;
 /** @type {string} */
ExtensionAPI.ICustomText.prototype.label;
/**
 * @extends {ExtensionAPI.ICustomControl}
 * @record
 * @struct
 */
ExtensionAPI.ICustomTextArea = function() {};
 /** @type {string} */
ExtensionAPI.ICustomTextArea.prototype.component;
 /** @type {number} */
ExtensionAPI.ICustomTextArea.prototype.rows;
 /** @type {number} */
ExtensionAPI.ICustomTextArea.prototype.maxlength;
 /** @type {string} */
ExtensionAPI.ICustomTextArea.prototype.defaultValue;
 /** @type {(boolean|function(): boolean)} */
ExtensionAPI.ICustomTextArea.prototype.show;
/**
 * @record
 * @struct
 */
ExtensionAPI.IDefinition = function() {};
 /** @type {string} */
ExtensionAPI.IDefinition.prototype.type;
 /** @type {string} */
ExtensionAPI.IDefinition.prototype.component;
 /** @type {!ExtensionAPI.IItems} */
ExtensionAPI.IDefinition.prototype.items;
/**
 * @record
 * @struct
 */
ExtensionAPI.IItems = function() {};
 /** @type {!ExtensionAPI.IDimensions} */
ExtensionAPI.IItems.prototype.dimentions;
 /** @type {!ExtensionAPI.IMeasures} */
ExtensionAPI.IItems.prototype.measures;
 /** @type {!ExtensionAPI.IAppearance} */
ExtensionAPI.IItems.prototype.appearance;
 /** @type {!ExtensionAPI.ISorting} */
ExtensionAPI.IItems.prototype.sorting;
 /** @type {!ExtensionAPI.IAddOns} */
ExtensionAPI.IItems.prototype.AddOns;

/* TODO: IndexSignature: ExtensionAPI */
/**
 * @record
 * @struct
 */
ExtensionAPI.IAddOns = function() {};
 /** @type {string} */
ExtensionAPI.IAddOns.prototype.uses;
/**
 * @record
 * @struct
 */
ExtensionAPI.ISorting = function() {};
 /** @type {string} */
ExtensionAPI.ISorting.prototype.uses;
/**
 * @record
 * @struct
 */
ExtensionAPI.IDimensions = function() {};
 /** @type {string} */
ExtensionAPI.IDimensions.prototype.uses;
 /** @type {number} */
ExtensionAPI.IDimensions.prototype.min;
 /** @type {number} */
ExtensionAPI.IDimensions.prototype.max;
/**
 * @record
 * @struct
 */
ExtensionAPI.IAppearance = function() {};
 /** @type {string} */
ExtensionAPI.IAppearance.prototype.uses;
 /** @type {number} */
ExtensionAPI.IAppearance.prototype.min;
 /** @type {number} */
ExtensionAPI.IAppearance.prototype.max;
 /** @type {?} */
ExtensionAPI.IAppearance.prototype.items;
/**
 * @record
 * @struct
 */
ExtensionAPI.ISettings = function() {};
 /** @type {string} */
ExtensionAPI.ISettings.prototype.uses;
 /** @type {number} */
ExtensionAPI.ISettings.prototype.min;
 /** @type {number} */
ExtensionAPI.ISettings.prototype.max;
/**
 * @record
 * @struct
 */
ExtensionAPI.IMeasures = function() {};
 /** @type {string} */
ExtensionAPI.IMeasures.prototype.uses;
 /** @type {number} */
ExtensionAPI.IMeasures.prototype.min;
 /** @type {number} */
ExtensionAPI.IMeasures.prototype.max;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "qlik"
/** @const */
tsickle_declare_module.qlik = {};
 /** @type {!RootAPI.IRoot} */
tsickle_declare_module.qlik.e;

/* TODO: ExportAssignment in tsickle_declare_module.qlik */
/**
 * @record
 * @struct
 */
function IQVAngular() {}

/**
 * Register a new directive with the compiler.
 * 
 * @param {string|!Object<string,(!angular.IDirectiveFactory|!Array<(string|!angular.IDirectiveFactory)>)>} name_or_object Name of the directive in camel-case (i.e. ngBind which will match as ng-bind)
 * @param {(!angular.IDirectiveFactory|!Array<(string|!angular.IDirectiveFactory)>)=} directiveFactory An injectable directive factory function.
 * @return {void}
 */
IQVAngular.prototype.directive = function(name_or_object, directiveFactory) {};

/**
 * @param {string|!Object<string,(!Function|!Array<(string|!Function)>)>} name_or_object
 * @param {(!Function|!Array<(string|!Function)>)=} filterFactoryFunction
 * @return {void}
 */
IQVAngular.prototype.filter = function(name_or_object, filterFactoryFunction) {};

/**
 * Register a service constructor, which will be invoked with new to create
 * the service instance. This is short for registering a service where its
 * provider's $get property is a factory function that returns an instance
 * instantiated by the injector from the service constructor function.
 * @template T
 * @param {string|!Object<string,(!Function|!Array<(string|!Function)>)>} name_or_object The name of the instance.
 * @param {(!Function|!Array<(string|!Function)>)=} serviceConstructor An injectable class (constructor function) that will be instantiated.
 * @return {T} Returns the constructed singleton of the service class/function.
 */
IQVAngular.prototype.service = function(name_or_object, serviceConstructor) {};
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "qvangular"
/** @const */
tsickle_declare_module.qvangular = {};
 /** @type {!IQVAngular} */
tsickle_declare_module.qvangular.e;

/* TODO: ExportAssignment in tsickle_declare_module.qvangular */
