/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/oauth.js/index.d.ts:
/** @const */
var OAuth = {};

/** @typedef {!Array<!Array<?>>} */
OAuth.ParameterList;

/** @typedef {!Object<string,string>} */
OAuth.ParameterMap;

/** @typedef {(!Array<!Array<?>>|!Object<string,string>)} */
OAuth.ParameterListOrMap;
/**
 * @record
 * @struct
 */
OAuth.Message = function() {};
 /** @type {string} */
OAuth.Message.prototype.action;
 /** @type {string} */
OAuth.Message.prototype.method;
 /** @type {(!Array<!Array<?>>|!Object<string,string>)} */
OAuth.Message.prototype.parameters;
/**
 * @record
 * @struct
 */
OAuth.Accessor = function() {};
 /** @type {string} */
OAuth.Accessor.prototype.consumerKey;
 /** @type {string} */
OAuth.Accessor.prototype.consumerSecret;
 /** @type {string} */
OAuth.Accessor.prototype.accessorSecret;
 /** @type {string} */
OAuth.Accessor.prototype.token;
 /** @type {string} */
OAuth.Accessor.prototype.tokenSecret;

/**
 * Encode text value according to OAuth Percent Encoding.
 * @see {\@link https://tools.ietf.org/html/rfc5849#section-3.6}
 * Encode text values according to OAuth Percent Encoding.
 * Encoded values are joined with an ampersand character (&) in between them.
 * @see {\@link https://tools.ietf.org/html/rfc5849#section-3.6}
 * @param {string|!Array<string>} s Target text value. / Target text values.
 * @return {string}
 */
OAuth.percentEncode = function(s) {};

/**
 * Decode percent-encoded value.
 * @see {\@link https://tools.ietf.org/html/rfc5849#section-3.6}
 * @param {string} s Target percent-encoded value.
 * @return {string}
 */
OAuth.decodePercent = function(s) {};

/**
 * Convert the given parameters to an Array of name-value pairs.
 * Convert the given parameters to an Array of name-value pairs.
 * @param {(!Array<!Array<?>>|!Object<string,string>)|string} parameters
 * @return {!Array<!Array<?>>}
 */
OAuth.getParameterList = function(parameters) {};

/**
 * Convert the given parameters to a map from name to value.
 * Convert the given parameters to a map from name to value.
 * @param {(!Array<!Array<?>>|!Object<string,string>)|string} parameters
 * @return {!Object<string,string>}
 */
OAuth.getParameterMap = function(parameters) {};

/**
 * @param {(!Array<!Array<?>>|!Object<string,string>)|string} parameters
 * @param {string} name
 * @return {string}
 */
OAuth.getParameter = function(parameters, name) {};

/**
 * @param {(!Array<!Array<?>>|!Object<string,string>)} parameters
 * @return {string}
 */
OAuth.formEncode = function(parameters) {};

/**
 * @param {string} form
 * @return {!Array<!Array<?>>}
 */
OAuth.decodeForm = function(form) {};

/**
 * @param {!OAuth.Message} message
 * @param {string} name
 * @param {string} value
 * @return {void}
 */
OAuth.setParameter = function(message, name, value) {};

/**
 * @param {!OAuth.Message} message
 * @param {(!Array<!Array<?>>|!Object<string,string>)|string} parameters
 * @return {void}
 */
OAuth.setParameters = function(message, parameters) {};

/**
 * Fill in parameters to help construct a request message.
 * This function doesn't fill in every parameter.
 * @param {!OAuth.Message} message Target request message.
 * @param {!OAuth.Accessor} accessor Accessor object. The accessorSecret property is optional.
 * @return {void}
 */
OAuth.completeRequest = function(message, accessor) {};

/**
 * @param {!OAuth.Message} message
 * @return {void}
 */
OAuth.setTimestampAndNonce = function(message) {};

/**
 * Add specified parameters into URL as query parameters.
 * @param {string} url URL that parameters added into.
 * @param {(!Array<!Array<?>>|!Object<string,string>)} parameters Parameters added into URL.
 * @return {string} New URL string.
 */
OAuth.addToURL = function(url, parameters) {};

/**
 * Construct the value of the Authorization header for an HTTP request.
 * @param {string} realm
 * @param {(!Array<!Array<?>>|!Object<string,string>)|string} parameters
 * @return {string}
 */
OAuth.getAuthorizationHeader = function(realm, parameters) {};

/**
 * Correct the time using a parameter from the URL from which the last script was loaded.
 * @param {string=} parameterName
 * @return {void}
 */
OAuth.correctTimestampFromSrc = function(parameterName) {};

/**
 * Generate timestamps starting with the given value.
 * @param {number} timestamp
 * @return {void}
 */
OAuth.correctTimestamp = function(timestamp) {};
 /** @type {number} */
OAuth.timeCorrectionMsec;

/**
 * @return {number}
 */
OAuth.timestamp = function() {};

/**
 * @param {number} length
 * @return {string}
 */
OAuth.nonce = function(length) {};
/**
 * @record
 * @struct
 */
OAuth.Uri = function() {};
 /** @type {string} */
OAuth.Uri.prototype.source;
 /** @type {string} */
OAuth.Uri.prototype.protocol;
 /** @type {string} */
OAuth.Uri.prototype.authority;
 /** @type {string} */
OAuth.Uri.prototype.userInfo;
 /** @type {string} */
OAuth.Uri.prototype.user;
 /** @type {string} */
OAuth.Uri.prototype.password;
 /** @type {string} */
OAuth.Uri.prototype.host;
 /** @type {string} */
OAuth.Uri.prototype.port;
 /** @type {string} */
OAuth.Uri.prototype.relative;
 /** @type {string} */
OAuth.Uri.prototype.path;
 /** @type {string} */
OAuth.Uri.prototype.directory;
 /** @type {string} */
OAuth.Uri.prototype.file;
 /** @type {string} */
OAuth.Uri.prototype.query;
 /** @type {string} */
OAuth.Uri.prototype.anchor;
/**
 * @record
 * @struct
 */
OAuth.SignatureMethodStatic = function() {};
 /** @type {!Object<string,function(new: (?)): ?>} */
OAuth.SignatureMethodStatic.prototype.REGISTERED;

/**
 * @param {!OAuth.Message} message
 * @param {!OAuth.Accessor} accessor
 * @return {void}
 */
OAuth.SignatureMethodStatic.prototype.sign = function(message, accessor) {};

/**
 * Instantiate a SignatureMethod for the given method name.
 * @param {string} name
 * @param {!OAuth.Accessor} accessor
 * @return {?}
 */
OAuth.SignatureMethodStatic.prototype.newMethod = function(name, accessor) {};

/**
 * Subsequently, the given constructor will be used for the named methods.
 * The constructor will be called with no parameters.
 * The resulting object should usually implement getSignature(baseString).
 * You can easily define such a constructor by calling makeSubclass method.
 * @param {!Array<string>} names
 * @param {function(new: (?)): ?} classConstructor
 * @return {void}
 */
OAuth.SignatureMethodStatic.prototype.registerMethodClass = function(names, classConstructor) {};

/**
 * Create a subclass of OAuth.SignatureMethod, with the given getSignature function.
 * @param {function(string): string} getSignatureFunction
 * @return {function(new: (?)): ?}
 */
OAuth.SignatureMethodStatic.prototype.makeSubclass = function(getSignatureFunction) {};

/**
 * Generate a signature base string from a Message object.
 * @see {\@link https://tools.ietf.org/html/rfc5849#section-3.4.1}
 * @param {!OAuth.Message} message Source of the signature base string.
 * @return {string}
 */
OAuth.SignatureMethodStatic.prototype.getBaseString = function(message) {};

/**
 * @param {string} url
 * @return {string}
 */
OAuth.SignatureMethodStatic.prototype.normalizeUrl = function(url) {};

/**
 * @param {string} str
 * @return {!OAuth.Uri}
 */
OAuth.SignatureMethodStatic.prototype.parseUri = function(str) {};

/**
 * @param {(!Array<!Array<?>>|!Object<string,string>)} parameters
 * @return {string}
 */
OAuth.SignatureMethodStatic.prototype.normalizeParameters = function(parameters) {};
/**
 * @record
 * @struct
 */
OAuth.SignatureMethod = function() {};
 /** @type {string} */
OAuth.SignatureMethod.prototype.key;

/**
 * @param {string} baseString
 * @return {string}
 */
OAuth.SignatureMethod.prototype.getSignature = function(baseString) {};

/**
 * Add a signature to the message.
 * @param {!OAuth.Message} message
 * @return {string}
 */
OAuth.SignatureMethod.prototype.sign = function(message) {};

/**
 * Set the key string for signing.
 * @param {string} name
 * @param {!OAuth.Accessor} accessor
 * @return {void}
 */
OAuth.SignatureMethod.prototype.initialize = function(name, accessor) {};
 /** @type {!OAuth.SignatureMethodStatic} */
OAuth.SignatureMethod;
