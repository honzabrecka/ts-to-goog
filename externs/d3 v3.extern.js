/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/d3 v3/index.d.ts:

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
/** @const */
var d3 = {};
 /** @type {string} */
d3.version;

/**
 * Find the first element that matches the given selector string.
 * Create a selection from the given node reference.
 * @param {string|!EventTarget} selector_or_node
 * @return {!d3.Selection<?>}
 */
d3.select = function(selector_or_node) {};

/**
 * Find all elements that match the given selector string.
 * Create a selection from the given list of nodes.
 * @param {string|!Array<!EventTarget>} selector_or_nodes
 * @return {!d3.Selection<?>}
 */
d3.selectAll = function(selector_or_nodes) {};

/**
 * Returns the root selection (as if by d3.select(document.documentElement)). This function may be used for 'instanceof' tests, and extending its prototype will add properties to all selections.
 * @return {!d3.Selection<?>}
 */
d3.selection = function() {};
 /** @type {!d3.Selection<?>} */
d3.selection.prototype;
/**
 * @record
 * @struct
 */
d3.selection.Group = function() {};
 /** @type {!EventTarget} */
d3.selection.Group.prototype.parentNode;
/**
 * @record
 * @struct
 */
d3.selection.Update = function() {};

/* TODO: IndexSignature: d3.selection */
 /** @type {number} */
d3.selection.Update.prototype.length;

/**
 * Retrieve the value of the given attribute for the first node in the selection.
 * 
 * For all nodes, set the attribute to the specified constant value. Use null to remove.
 * 
 * Derive an attribute value for each node in the selection based on bound data.
 * 
 * Set multiple properties at once using an Object. D3 iterates over all enumerable properties and either sets or computes the attribute's value based on the corresponding entry in the Object.
 * 
 * @param {string|!Object<string,(string|number|boolean|function(Datum, number, number): (string|number|boolean))>} name_or_obj The attribute name to query. May be prefixed (see d3.ns.prefix). / The attribute name, optionally prefixed. / A key-value mapping corresponding to attributes and values. If the value is a simple string or number, it is taken as a constant. Otherwise, it is a function that derives the attribute value.
 * @param {(string|number|boolean)|function(Datum, number, number): (string|number|boolean)=} value The attribute value to use. Note that this is coerced to a string automatically. / The function of the datum (the bound data item), index (the position in the subgrouping), and outer index (overall position in nested selections) which computes the attribute value. If the function returns null, the attribute is removed.
 * @return {string|!d3.selection.Update}
 */
d3.selection.Update.prototype.attr = function(name_or_obj, value) {};

/**
 * Returns true if the first node in this selection has the given class list. If multiple classes are specified (i.e., "foo bar"), then returns true only if all classes match.
 * 
 * Adds (or removes) the given class list.
 * 
 * Determine if the given class list should be toggled for each node in the selection.
 * 
 * Set or derive classes for multiple class lists at once.
 * 
 * @param {string|!Object<string,(boolean|function(Datum, number, number): boolean)>} name_or_obj The class list to query. / The class list to toggle. Spaces separate class names: "foo bar" is a list of two classes. / The class list. Spaces separate multiple class names. / An Object mapping class lists to values that are either plain booleans or functions that return booleans.
 * @param {boolean|function(Datum, number, number): boolean=} value If true, add the classes. If false, remove them. / The function to run for each node. Should return true to add the class to the node, or false to remove it.
 * @return {boolean|!d3.selection.Update}
 */
d3.selection.Update.prototype.classed = function(name_or_obj, value) {};

/**
 * Retrieve the computed style value for the first node in the selection.
 * Set a style property for all nodes in the selection.
 * Derive a property value for each node in the selection.
 * Set a large number of CSS properties from an object.
 * 
 * @param {string|!Object<string,(string|number|boolean|function(Datum, number, number): (string|number|boolean))>} name_or_obj The CSS property name to query / the CSS property name / an Object whose keys correspond to CSS property names and values are either constants or functions that derive property values
 * @param {(string|number|boolean)|function(Datum, number, number): (string|number|boolean)|string=} value_or_priority the property value / the function to derive the value / if specified, either null or the string "important" (no exclamation mark)
 * @param {string=} priority if specified, either null or the string "important" (no exclamation mark)
 * @return {string|!d3.selection.Update}
 */
d3.selection.Update.prototype.style = function(name_or_obj, value_or_priority, priority) {};

/**
 * Retrieve an arbitrary node property such as the 'checked' property of checkboxes, or the 'value' of text boxes.
 * 
 * For each node, set the property value. Internally, this sets the node property directly (e.g., node[name] = value), so take care not to mutate special properties like __proto__.
 * 
 * For each node, derive the property value. Internally, this sets the node property directly (e.g., node[name] = value), so take care not to mutate special properties like __proto__.
 * 
 * Set multiple node properties. Caveats apply: take care not to mutate special properties like __proto__.
 * 
 * @param {string|!Object<string,?>} name_or_obj the node's property to retrieve / the property name / an Object whose keys correspond to node properties and values are either constants or functions that will compute a value.
 * @param {?|function(Datum, number, number): ?=} value the property value / the function used to derive the property's value
 * @return {?|!d3.selection.Update}
 */
d3.selection.Update.prototype.property = function(name_or_obj, value) {};

/**
 * Retrieve the textContent of the first node in the selection.
 * Set the textContent of each node in the selection.
 * Compute the textContent of each node in the selection.
 * @param {(string|number|boolean)|function(Datum, number, number): (string|number|boolean)=} value the text to use for all nodes / the function which will compute the text
 * @return {string|!d3.selection.Update}
 */
d3.selection.Update.prototype.text = function(value) {};

/**
 * Retrieve the HTML content of the first node in the selection. Uses 'innerHTML' internally and will not work with SVG or other elements without a polyfill.
 * Set the HTML content of every node in the selection. Uses 'innerHTML' internally and thus will not work with SVG or other elements without a polyfill.
 * Compute the HTML content for each node in the selection. Uses 'innerHTML' internally and thus will not work with SVG or other elements without a polyfill.
 * @param {string|function(Datum, number, number): string=} value the HTML content to use. / the function to compute HTML content
 * @return {string|!d3.Selection<Datum>}
 */
d3.selection.Update.prototype.html = function(value) {};

/**
 * Appends a new child to each node in the selection. This child will inherit the parent's data (if available). Returns a fresh selection consisting of the newly-appended children.
 * 
 * Appends a new child to each node in the selection by computing a new node. This child will inherit the parent's data (if available). Returns a fresh selection consisting of the newly-appended children.
 * 
 * @param {string|function(Datum, number, number): !EventTarget} name the element name to append. May be prefixed (see d3.ns.prefix). / the function to compute a new element
 * @return {!d3.Selection<Datum>|!d3.selection.Update}
 */
d3.selection.Update.prototype.append = function(name) {};

/**
 * Inserts a new child to each node in the selection. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
 * Inserts a new child to each node in the selection. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
 * Inserts a new child to the end of each node in the selection by computing a new node. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
 * Inserts a new child to the end of each node in the selection by computing a new node. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
 * @param {string|function(Datum, number, number): !EventTarget} name the element name to append. May be prefixed (see d3.ns.prefix). / the function to compute a new child
 * @param {string|function(Datum, number, number): !EventTarget} before the selector to determine position (e.g., ":first-child") / a function to determine the node to use as the next sibling
 * @return {!d3.selection.Update}
 */
d3.selection.Update.prototype.insert = function(name, before) {};

/**
 * Removes the elements from the DOM. They are in a detached state and may be re-added (though there is currently no dedicated API for doing so).
 * @return {!d3.selection.Update}
 */
d3.selection.Update.prototype.remove = function() {};

/**
 * Retrieves the data bound to the first group in this selection.
 * Binds data to this selection.
 * Derives data to bind to this selection.
 * @template NewDatum
 * @param {!Array<NewDatum>|function(Datum, number, number): !Array<NewDatum>=} data the array of data to bind to this selection / the function to derive data. Must return an array.
 * @param {function(NewDatum, number, number): string=} key the optional function to determine the unique key for each piece of data. When unspecified, uses the index of the element. / the optional function to determine the unique key for each data item. When unspecified, uses the index of the element.
 * @return {!Array<Datum>|!d3.selection.Update<NewDatum>}
 */
d3.selection.Update.prototype.data = function(data, key) {};

/**
 * Filters the selection, returning only those nodes that match the given CSS selector.
 * Filters the selection, returning only those nodes for which the given function returned true.
 * @param {string|function(Datum, number, number): boolean} selector the CSS selector / the filter function
 * @return {!d3.selection.Update}
 */
d3.selection.Update.prototype.filter = function(selector) {};

/**
 * Return the data item bound to the first element in the selection.
 * Derive the data item for each node in the selection. Useful for situations such as the HTML5 'dataset' attribute.
 * Set the data item for each node in the selection.
 * @template NewDatum
 * @param {function(Datum, number, number): NewDatum|NewDatum=} value the function to compute data for each node / the constant element to use for each node
 * @return {Datum|!d3.selection.Update<NewDatum>}
 */
d3.selection.Update.prototype.datum = function(value) {};

/**
 * Reorders nodes in the selection based on the given comparator. Nodes are re-inserted into the document once sorted.
 * @param {function(Datum, Datum): number=} comparator the comparison function, which defaults to d3.ascending
 * @return {!d3.selection.Update}
 */
d3.selection.Update.prototype.sort = function(comparator) {};

/**
 * Reorders nodes in the document to match the selection order. More efficient than calling sort() if the selection is already ordered.
 * @return {!d3.selection.Update}
 */
d3.selection.Update.prototype.order = function() {};

/**
 * Returns the listener (if any) for the given event.
 * Adds a listener for the specified event. If one was already registered, it is removed before the new listener is added. The return value of the listener function is ignored.
 * @param {string} type the type of event to load the listener for. May have a namespace (e.g., ".foo") at the end. / the of event to listen to. May have a namespace (e.g., ".foo") at the end.
 * @param {function(Datum, number, number): ?=} listener an event listener function, or null to unregister
 * @param {boolean=} capture sets the DOM useCapture flag
 * @return {function(Datum, number, number): ?|!d3.selection.Update}
 */
d3.selection.Update.prototype.on = function(type, listener, capture) {};

/**
 * Begins a new transition. Interrupts any active transitions of the same name.
 * @param {string=} name the transition name (defaults to "")
 * @return {!d3.Transition<Datum>}
 */
d3.selection.Update.prototype.transition = function(name) {};

/**
 * Interrupts the active transition of the provided name. Does not cancel scheduled transitions.
 * @param {string=} name the transition name (defaults to "")
 * @return {!d3.selection.Update}
 */
d3.selection.Update.prototype.interrupt = function(name) {};

/**
 * Creates a subselection by finding the first descendent matching the selector string. Bound data is inherited.
 * Creates a subselection by using a function to find descendent elements. Bound data is inherited.
 * @param {string|function(Datum, number, number): !EventTarget} selector the CSS selector to match against / the function to find matching descendants
 * @return {!d3.selection.Update}
 */
d3.selection.Update.prototype.select = function(selector) {};

/**
 * Creates a subselection by finding all descendents that match the given selector. Bound data is not inherited.
 * Creates a subselection by using a function to find descendent elements. Bound data is not inherited.
 * @param {string|function(Datum, number, number): (!Array<!EventTarget>|!NodeList)} selector the CSS selector to match against / the function to find matching descendents
 * @return {!d3.selection.Update|!d3.selection.Update<?>}
 */
d3.selection.Update.prototype.selectAll = function(selector) {};

/**
 * Invoke the given function for each element in the selection. The return value of the function is ignored.
 * @param {function(Datum, number, number): ?} func the function to invoke
 * @return {!d3.selection.Update}
 */
d3.selection.Update.prototype.each = function(func) {};

/**
 * Call a function on the selection. sel.call(foo) is equivalent to foo(sel).
 * @param {function(!d3.selection.Update, !Array<?>): ?} func the function to call on the selection
 * @param {...?} args any optional args
 * @return {!d3.selection.Update}
 */
d3.selection.Update.prototype.call = function(func, args) {};

/**
 * Returns true if the current selection is empty.
 * @return {boolean}
 */
d3.selection.Update.prototype.empty = function() {};

/**
 * Returns the first non-null element in the selection, or null otherwise.
 * @return {!Node}
 */
d3.selection.Update.prototype.node = function() {};

/**
 * Returns the total number of elements in the selection.
 * @return {number}
 */
d3.selection.Update.prototype.size = function() {};

/**
 * Returns the placeholder nodes for each data element for which no corresponding DOM element was found.
 * @return {!d3.selection.Enter<Datum>}
 */
d3.selection.Update.prototype.enter = function() {};

/**
 * Returns a selection for those DOM nodes for which no new data element was found.
 * @return {!d3.Selection<Datum>}
 */
d3.selection.Update.prototype.exit = function() {};
/**
 * @record
 * @struct
 */
d3.selection.Enter = function() {};

/**
 * @param {string|function(Datum, number, number): !EventTarget} name
 * @return {!d3.Selection<Datum>}
 */
d3.selection.Enter.prototype.append = function(name) {};

/**
 * @param {string|function(Datum, number, number): !EventTarget} name
 * @param {string|function(Datum, number, number): !EventTarget=} before
 * @return {!d3.Selection<Datum>}
 */
d3.selection.Enter.prototype.insert = function(name, before) {};

/**
 * @param {function(Datum, number, number): !EventTarget} name
 * @return {!d3.Selection<Datum>}
 */
d3.selection.Enter.prototype.select = function(name) {};

/**
 * @param {function(!d3.selection.Enter, !Array<?>): ?} func
 * @param {...?} args
 * @return {!d3.selection.Enter}
 */
d3.selection.Enter.prototype.call = function(func, args) {};

/**
 * @return {boolean}
 */
d3.selection.Enter.prototype.empty = function() {};

/**
 * @return {number}
 */
d3.selection.Enter.prototype.size = function() {};

/** @typedef {(string|number|boolean)} */
d3.Primitive;
/**
 * @record
 * @struct
 */
d3.Numeric = function() {};

/**
 * @return {number}
 */
d3.Numeric.prototype.valueOf = function() {};
/**
 * @record
 * @struct
 */
d3.Selection = function() {};

/* TODO: IndexSignature: d3 */
 /** @type {number} */
d3.Selection.prototype.length;

/**
 * Retrieve the value of the given attribute for the first node in the selection.
 * 
 * For all nodes, set the attribute to the specified constant value. Use null to remove.
 * 
 * Derive an attribute value for each node in the selection based on bound data.
 * 
 * Set multiple properties at once using an Object. D3 iterates over all enumerable properties and either sets or computes the attribute's value based on the corresponding entry in the Object.
 * 
 * @param {string|!Object<string,(string|number|boolean|function(Datum, number, number): (string|number|boolean))>} name_or_obj The attribute name to query. May be prefixed (see d3.ns.prefix). / The attribute name, optionally prefixed. / A key-value mapping corresponding to attributes and values. If the value is a simple string or number, it is taken as a constant. Otherwise, it is a function that derives the attribute value.
 * @param {(string|number|boolean)|function(Datum, number, number): (string|number|boolean)=} value The attribute value to use. Note that this is coerced to a string automatically. / The function of the datum (the bound data item), index (the position in the subgrouping), and outer index (overall position in nested selections) which computes the attribute value. If the function returns null, the attribute is removed.
 * @return {string|!d3.Selection}
 */
d3.Selection.prototype.attr = function(name_or_obj, value) {};

/**
 * Returns true if the first node in this selection has the given class list. If multiple classes are specified (i.e., "foo bar"), then returns true only if all classes match.
 * 
 * Adds (or removes) the given class list.
 * 
 * Determine if the given class list should be toggled for each node in the selection.
 * 
 * Set or derive classes for multiple class lists at once.
 * 
 * @param {string|!Object<string,(boolean|function(Datum, number, number): boolean)>} name_or_obj The class list to query. / The class list to toggle. Spaces separate class names: "foo bar" is a list of two classes. / The class list. Spaces separate multiple class names. / An Object mapping class lists to values that are either plain booleans or functions that return booleans.
 * @param {boolean|function(Datum, number, number): boolean=} value If true, add the classes. If false, remove them. / The function to run for each node. Should return true to add the class to the node, or false to remove it.
 * @return {boolean|!d3.Selection}
 */
d3.Selection.prototype.classed = function(name_or_obj, value) {};

/**
 * Retrieve the computed style value for the first node in the selection.
 * Set a style property for all nodes in the selection.
 * Derive a property value for each node in the selection.
 * Set a large number of CSS properties from an object.
 * 
 * @param {string|!Object<string,(string|number|boolean|function(Datum, number, number): (string|number|boolean))>} name_or_obj The CSS property name to query / the CSS property name / an Object whose keys correspond to CSS property names and values are either constants or functions that derive property values
 * @param {(string|number|boolean)|function(Datum, number, number): (string|number|boolean)|string=} value_or_priority the property value / the function to derive the value / if specified, either null or the string "important" (no exclamation mark)
 * @param {string=} priority if specified, either null or the string "important" (no exclamation mark)
 * @return {string|!d3.Selection}
 */
d3.Selection.prototype.style = function(name_or_obj, value_or_priority, priority) {};

/**
 * Retrieve an arbitrary node property such as the 'checked' property of checkboxes, or the 'value' of text boxes.
 * 
 * For each node, set the property value. Internally, this sets the node property directly (e.g., node[name] = value), so take care not to mutate special properties like __proto__.
 * 
 * For each node, derive the property value. Internally, this sets the node property directly (e.g., node[name] = value), so take care not to mutate special properties like __proto__.
 * 
 * Set multiple node properties. Caveats apply: take care not to mutate special properties like __proto__.
 * 
 * @param {string|!Object<string,?>} name_or_obj the node's property to retrieve / the property name / an Object whose keys correspond to node properties and values are either constants or functions that will compute a value.
 * @param {?|function(Datum, number, number): ?=} value the property value / the function used to derive the property's value
 * @return {?|!d3.Selection}
 */
d3.Selection.prototype.property = function(name_or_obj, value) {};

/**
 * Retrieve the textContent of the first node in the selection.
 * Set the textContent of each node in the selection.
 * Compute the textContent of each node in the selection.
 * @param {(string|number|boolean)|function(Datum, number, number): (string|number|boolean)=} value the text to use for all nodes / the function which will compute the text
 * @return {string|!d3.Selection}
 */
d3.Selection.prototype.text = function(value) {};

/**
 * Retrieve the HTML content of the first node in the selection. Uses 'innerHTML' internally and will not work with SVG or other elements without a polyfill.
 * Set the HTML content of every node in the selection. Uses 'innerHTML' internally and thus will not work with SVG or other elements without a polyfill.
 * Compute the HTML content for each node in the selection. Uses 'innerHTML' internally and thus will not work with SVG or other elements without a polyfill.
 * @param {string|function(Datum, number, number): string=} value the HTML content to use. / the function to compute HTML content
 * @return {string|!d3.Selection}
 */
d3.Selection.prototype.html = function(value) {};

/**
 * Appends a new child to each node in the selection. This child will inherit the parent's data (if available). Returns a fresh selection consisting of the newly-appended children.
 * 
 * Appends a new child to each node in the selection by computing a new node. This child will inherit the parent's data (if available). Returns a fresh selection consisting of the newly-appended children.
 * 
 * @param {string|function(Datum, number, number): !EventTarget} name the element name to append. May be prefixed (see d3.ns.prefix). / the function to compute a new element
 * @return {!d3.Selection}
 */
d3.Selection.prototype.append = function(name) {};

/**
 * Inserts a new child to each node in the selection. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
 * Inserts a new child to each node in the selection. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
 * Inserts a new child to the end of each node in the selection by computing a new node. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
 * Inserts a new child to the end of each node in the selection by computing a new node. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
 * @param {string|function(Datum, number, number): !EventTarget} name the element name to append. May be prefixed (see d3.ns.prefix). / the function to compute a new child
 * @param {string|function(Datum, number, number): !EventTarget} before the selector to determine position (e.g., ":first-child") / a function to determine the node to use as the next sibling
 * @return {!d3.Selection}
 */
d3.Selection.prototype.insert = function(name, before) {};

/**
 * Removes the elements from the DOM. They are in a detached state and may be re-added (though there is currently no dedicated API for doing so).
 * @return {!d3.Selection}
 */
d3.Selection.prototype.remove = function() {};

/**
 * Retrieves the data bound to the first group in this selection.
 * Binds data to this selection.
 * Derives data to bind to this selection.
 * @template NewDatum
 * @param {!Array<NewDatum>|function(Datum, number, number): !Array<NewDatum>=} data the array of data to bind to this selection / the function to derive data. Must return an array.
 * @param {function(NewDatum, number, number): string=} key the optional function to determine the unique key for each piece of data. When unspecified, uses the index of the element. / the optional function to determine the unique key for each data item. When unspecified, uses the index of the element.
 * @return {!Array<Datum>|!d3.selection.Update<NewDatum>}
 */
d3.Selection.prototype.data = function(data, key) {};

/**
 * Filters the selection, returning only those nodes that match the given CSS selector.
 * Filters the selection, returning only those nodes for which the given function returned true.
 * @param {string|function(Datum, number, number): boolean} selector the CSS selector / the filter function
 * @return {!d3.Selection}
 */
d3.Selection.prototype.filter = function(selector) {};

/**
 * Return the data item bound to the first element in the selection.
 * Derive the data item for each node in the selection. Useful for situations such as the HTML5 'dataset' attribute.
 * Set the data item for each node in the selection.
 * @template NewDatum
 * @param {function(Datum, number, number): NewDatum|NewDatum=} value the function to compute data for each node / the constant element to use for each node
 * @return {Datum|!d3.Selection<NewDatum>}
 */
d3.Selection.prototype.datum = function(value) {};

/**
 * Reorders nodes in the selection based on the given comparator. Nodes are re-inserted into the document once sorted.
 * @param {function(Datum, Datum): number=} comparator the comparison function, which defaults to d3.ascending
 * @return {!d3.Selection}
 */
d3.Selection.prototype.sort = function(comparator) {};

/**
 * Reorders nodes in the document to match the selection order. More efficient than calling sort() if the selection is already ordered.
 * @return {!d3.Selection}
 */
d3.Selection.prototype.order = function() {};

/**
 * Returns the listener (if any) for the given event.
 * Adds a listener for the specified event. If one was already registered, it is removed before the new listener is added. The return value of the listener function is ignored.
 * @param {string} type the type of event to load the listener for. May have a namespace (e.g., ".foo") at the end. / the of event to listen to. May have a namespace (e.g., ".foo") at the end.
 * @param {function(Datum, number, number): ?=} listener an event listener function, or null to unregister
 * @param {boolean=} capture sets the DOM useCapture flag
 * @return {function(Datum, number, number): ?|!d3.Selection}
 */
d3.Selection.prototype.on = function(type, listener, capture) {};

/**
 * Begins a new transition. Interrupts any active transitions of the same name.
 * @param {string=} name the transition name (defaults to "")
 * @return {!d3.Transition<Datum>}
 */
d3.Selection.prototype.transition = function(name) {};

/**
 * Interrupts the active transition of the provided name. Does not cancel scheduled transitions.
 * @param {string=} name the transition name (defaults to "")
 * @return {!d3.Selection}
 */
d3.Selection.prototype.interrupt = function(name) {};

/**
 * Creates a subselection by finding the first descendent matching the selector string. Bound data is inherited.
 * Creates a subselection by using a function to find descendent elements. Bound data is inherited.
 * @param {string|function(Datum, number, number): !EventTarget} selector the CSS selector to match against / the function to find matching descendants
 * @return {!d3.Selection}
 */
d3.Selection.prototype.select = function(selector) {};

/**
 * Creates a subselection by finding all descendents that match the given selector. Bound data is not inherited.
 * Creates a subselection by finding all descendants that match the given selector. Bound data is not inherited.
 * 
 * Use this overload when data-binding a subselection (that is, sel.selectAll('.foo').data(d => ...)). The type will carry over.
 * Creates a subselection by using a function to find descendent elements. Bound data is not inherited.
 * Creates a subselection by using a function to find descendent elements. Bound data is not inherited.
 * 
 * Use this overload when data-binding a subselection (that is, sel.selectAll('.foo').data(d => ...)). The type will carry over.
 * @template T
 * @param {string|function(Datum, number, number): (!Array<!EventTarget>|!NodeList)} selector the CSS selector to match against / the function to find matching descendents
 * @return {!d3.Selection<?>|!d3.Selection<T>}
 */
d3.Selection.prototype.selectAll = function(selector) {};

/**
 * Invoke the given function for each element in the selection. The return value of the function is ignored.
 * @param {function(Datum, number, number): ?} func the function to invoke
 * @return {!d3.Selection}
 */
d3.Selection.prototype.each = function(func) {};

/**
 * Call a function on the selection. sel.call(foo) is equivalent to foo(sel).
 * @param {function(!d3.Selection, !Array<?>): ?} func the function to call on the selection
 * @param {...?} args any optional args
 * @return {!d3.Selection}
 */
d3.Selection.prototype.call = function(func, args) {};

/**
 * Returns true if the current selection is empty.
 * @return {boolean}
 */
d3.Selection.prototype.empty = function() {};

/**
 * Returns the first non-null element in the selection, or null otherwise.
 * @return {!Node}
 */
d3.Selection.prototype.node = function() {};

/**
 * Returns the total number of elements in the selection.
 * @return {number}
 */
d3.Selection.prototype.size = function() {};

/**
 * @return {!d3.Transition<?>}
 */
d3.transition = function() {};
 /** @type {!d3.Transition<?>} */
d3.transition.prototype;
/**
 * @record
 * @struct
 */
d3.Transition = function() {};

/**
 * @return {!d3.Transition}
 */
d3.Transition.prototype.transition = function() {};

/**
 * @param {number|function(Datum, number, number): number=} delay
 * @return {number|!d3.Transition}
 */
d3.Transition.prototype.delay = function(delay) {};

/**
 * @param {number|function(Datum, number, number): number=} duration
 * @return {number|!d3.Transition}
 */
d3.Transition.prototype.duration = function(duration) {};

/**
 * @param {string|function(number): number=} value
 * @param {...?} args
 * @return {function(number): number|!d3.Transition}
 */
d3.Transition.prototype.ease = function(value, args) {};

/**
 * @param {string|!Object<string,(string|number|boolean|function(Datum, number, number): (string|number|boolean))>} name_or_obj
 * @param {(string|number|boolean)|function(Datum, number, number): (string|number|boolean)=} value
 * @return {!d3.Transition}
 */
d3.Transition.prototype.attr = function(name_or_obj, value) {};

/**
 * @param {string} name
 * @param {function(Datum, number, string): function(number): (string|number|boolean)} tween
 * @return {!d3.Transition}
 */
d3.Transition.prototype.attrTween = function(name, tween) {};

/**
 * @param {string|!Object<string,(string|number|boolean|function(Datum, number, number): (string|number|boolean))>} name_or_obj
 * @param {(string|number|boolean)|function(Datum, number, number): (string|number|boolean)|string=} value_or_priority
 * @param {string=} priority
 * @return {!d3.Transition}
 */
d3.Transition.prototype.style = function(name_or_obj, value_or_priority, priority) {};

/**
 * @param {string} name
 * @param {function(Datum, number, string): function(number): (string|number|boolean)} tween
 * @param {string=} priority
 * @return {!d3.Transition}
 */
d3.Transition.prototype.styleTween = function(name, tween, priority) {};

/**
 * @param {(string|number|boolean)|function(Datum, number, number): (string|number|boolean)} value
 * @return {!d3.Transition}
 */
d3.Transition.prototype.text = function(value) {};

/**
 * @param {string} name
 * @param {function(): function(number): ?} factory
 * @return {!d3.Transition}
 */
d3.Transition.prototype.tween = function(name, factory) {};

/**
 * @return {!d3.Transition}
 */
d3.Transition.prototype.remove = function() {};

/**
 * @param {string|function(Datum, number): !EventTarget} selector
 * @return {!d3.Transition}
 */
d3.Transition.prototype.select = function(selector) {};

/**
 * @param {string|function(Datum, number): !Array<!EventTarget>} selector
 * @return {!d3.Transition<?>}
 */
d3.Transition.prototype.selectAll = function(selector) {};

/**
 * @param {string|function(Datum, number): boolean} selector
 * @return {!d3.Transition}
 */
d3.Transition.prototype.filter = function(selector) {};

/**
 * @param {string|function(Datum, number): ?} type_or_listener
 * @param {function(Datum, number): ?=} listener
 * @return {!d3.Transition}
 */
d3.Transition.prototype.each = function(type_or_listener, listener) {};

/**
 * @param {function(!d3.Transition, !Array<?>): ?} func
 * @param {...?} args
 * @return {!d3.Transition}
 */
d3.Transition.prototype.call = function(func, args) {};

/**
 * @return {boolean}
 */
d3.Transition.prototype.empty = function() {};

/**
 * @return {!Node}
 */
d3.Transition.prototype.node = function() {};

/**
 * @return {number}
 */
d3.Transition.prototype.size = function() {};

/**
 * @param {string} type
 * @param {...number|?=} k_or_a_or_s_or_args
 * @return {function(number): number}
 */
d3.ease = function(type, k_or_a_or_s_or_args) {};

/**
 * @param {function(): ?} func
 * @param {number=} delay
 * @param {number=} time
 * @return {void}
 */
d3.timer = function(func, delay, time) {};

/**
 * @return {void}
 */
d3.timer.flush = function() {};
/**
 * @record
 * @struct
 */
d3.BaseEvent = function() {};
 /** @type {string} */
d3.BaseEvent.prototype.type;
 /** @type {!Event} */
d3.BaseEvent.prototype.sourceEvent;
/**
 * @extends {d3.BaseEvent}
 * @record
 * @struct
 */
d3.ZoomEvent = function() {};
 /** @type {number} */
d3.ZoomEvent.prototype.scale;
 /** @type {!Array<?>} */
d3.ZoomEvent.prototype.translate;
/**
 * @extends {d3.BaseEvent}
 * @record
 * @struct
 */
d3.DragEvent = function() {};
 /** @type {number} */
d3.DragEvent.prototype.x;
 /** @type {number} */
d3.DragEvent.prototype.y;
 /** @type {number} */
d3.DragEvent.prototype.dx;
 /** @type {number} */
d3.DragEvent.prototype.dy;
 /** @type {(!Event|!d3.BaseEvent)} */
d3.event;

/**
 * Returns the x and y coordinates of the mouse relative to the provided container element, using d3.event for the mouse's position on the page.
 * @param {!EventTarget} container the container element (e.g. an SVG <g> element)
 * @return {!Array<?>}
 */
d3.mouse = function(container) {};

/**
 * Given a container element and a touch identifier, determine the x and y coordinates of the touch.
 * Given a container element, a list of touches, and a touch identifier, determine the x and y coordinates of the touch.
 * @param {!EventTarget} container the container element (e.g., an SVG <svg> element)
 * @param {number|?} identifer_or_touches
 * @param {number=} identifer
 * @return {!Array<?>}
 */
d3.touch = function(container, identifer_or_touches, identifer) {};

/**
 * Given a container element and an optional list of touches, return the position of every touch relative to the container.
 * @param {!EventTarget} container the container element
 * @param {?=} touches an optional list of touches (defaults to d3.event.touches)
 * @return {!Array<!Array<?>>}
 */
d3.touches = function(container, touches) {};

/**
 * Compares two primitive values for sorting (in ascending order).
 * @param {(string|number|boolean)} a
 * @param {(string|number|boolean)} b
 * @return {number}
 */
d3.ascending = function(a, b) {};

/**
 * Compares two primitive values for sorting (in ascending order).
 * @param {(string|number|boolean)} a
 * @param {(string|number|boolean)} b
 * @return {number}
 */
d3.descending = function(a, b) {};

/**
 * Return the minimum value in the array using natural order.
 * Return the minimum value in the array using natural order.
 * Return the minimum value in the array using natural order.
 * Return the minimum value in the array using natural order.
 * Return the minimum value in the array using natural order.
 * Return the minimum value in the array using natural order.
 * @template T, U
 * @param {!Array<number>|!Array<string>|!Array<T>} array
 * @param {function(T, number): number|function(T, number): string|function(T, number): U=} accessor
 * @return {number|string|T|U}
 */
d3.min = function(array, accessor) {};

/**
 * Return the maximum value in the array of numbers using natural order.
 * Return the maximum value in the array of strings using natural order.
 * Return the maximum value in the array of numbers using natural order.
 * Return the maximum value in the array using natural order and a projection function to map values to numbers.
 * Return the maximum value in the array using natural order and a projection function to map values to strings.
 * Return the maximum value in the array using natural order and a projection function to map values to easily-sorted values.
 * @template T, U
 * @param {!Array<number>|!Array<string>|!Array<T>} array
 * @param {function(T, number): number|function(T, number): string|function(T, number): U=} accessor
 * @return {number|string|T|U}
 */
d3.max = function(array, accessor) {};

/**
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * Return the min and max simultaneously.
 * @template T, U
 * @param {!Array<number>|!Array<string>|!Array<T>|!Array<(string|number|boolean|T)>} array
 * @param {function(T, number): number|function(T, number): string|function(T, number): !Date|function(T, number): U=} accessor
 * @return {!Array<?>}
 */
d3.extent = function(array, accessor) {};

/**
 * Compute the sum of an array of numbers.
 * Compute the sum of an array, using the given accessor to convert values to numbers.
 * @template T
 * @param {!Array<number>|!Array<T>} array
 * @param {function(T, number): number=} accessor
 * @return {number}
 */
d3.sum = function(array, accessor) {};

/**
 * @template T
 * @param {!Array<number>|!Array<T>} array
 * @param {function(T, number): number=} accessor
 * @return {number}
 */
d3.mean = function(array, accessor) {};

/**
 * Compute the median of an array of numbers (the 0.5-quantile).
 * @template T
 * @param {!Array<number>|!Array<T>} array_or_datum
 * @param {function(T, number): number=} accessor
 * @return {number}
 */
d3.median = function(array_or_datum, accessor) {};

/**
 * @param {!Array<number>} array
 * @param {number} p
 * @return {number}
 */
d3.quantile = function(array, p) {};

/**
 * @template T
 * @param {!Array<number>|!Array<T>} array
 * @param {function(T, number): number=} accessor
 * @return {number}
 */
d3.variance = function(array, accessor) {};

/**
 * @template T
 * @param {!Array<number>|!Array<T>} array
 * @param {function(T, number): number=} accessor
 * @return {number}
 */
d3.deviation = function(array, accessor) {};

/**
 * @template T
 * @param {!Array<T>} array
 * @param {T} x
 * @param {number=} lo
 * @param {number=} hi
 * @return {number}
 */
d3.bisectLeft = function(array, x, lo, hi) {};
 /** @type {function(!Array<T>, T, number, number): number} */
d3.bisect;

/**
 * @template T
 * @param {!Array<T>} array
 * @param {T} x
 * @param {number=} lo
 * @param {number=} hi
 * @return {number}
 */
d3.bisectRight = function(array, x, lo, hi) {};

/**
 * @template T, U
 * @param {function(T): U|function(T, U): number} accessor_or_comparator
 * @return {{left: function(!Array<T>, U, number, number): number, right: function(!Array<T>, U, number, number): number}}
 */
d3.bisector = function(accessor_or_comparator) {};

/**
 * @template T
 * @param {!Array<T>} array
 * @param {number=} lo
 * @param {number=} hi
 * @return {!Array<T>}
 */
d3.shuffle = function(array, lo, hi) {};

/**
 * Returns the enumerable property names of the specified object.
 * @param {!Object} object a JavaScript object
 * @return {!Array<string>}
 */
d3.keys = function(object) {};

/**
 * Returns an array containing the property values of the specified object.
 * Returns an array containing the property values of the specified object.
 * Returns an array containing the property values of the specified object.
 * @template T
 * @param {!Object<string,T>|!Object<number,T>|!Object} object
 * @return {!Array<T>|!Array<?>}
 */
d3.values = function(object) {};

/**
 * Returns an array of key-value pairs containing the property values of the specified object.
 * Returns an array of key-value pairs containing the property values of the specified object.
 * Returns an array of key-value pairs containing the property values of the specified object.
 * @template T
 * @param {!Object<string,T>|!Object<number,T>|!Object} object
 * @return {!Array<{key: string, value: T}>|!Array<{key: string, value: ?}>}
 */
d3.entries = function(object) {};
/**
 * @record
 * @struct
 */
d3.Map = function() {};

/**
 * Does the map contain the given key?
 * @param {string} key
 * @return {boolean}
 */
d3.Map.prototype.has = function(key) {};

/**
 * Retrieve the value for the given key. Returns undefined if there is no value stored.
 * @param {string} key
 * @return {T}
 */
d3.Map.prototype.get = function(key) {};

/**
 * Set the value for the given key. Returns the new value.
 * @param {string} key
 * @param {T} value
 * @return {T}
 */
d3.Map.prototype.set = function(key, value) {};

/**
 * Remove the value for the given key. Returns true if there was a value and false otherwise.
 * @param {string} key
 * @return {boolean}
 */
d3.Map.prototype.remove = function(key) {};

/**
 * Returns an array of all keys in arbitrary order.
 * @return {!Array<string>}
 */
d3.Map.prototype.keys = function() {};

/**
 * Returns an array of all values in arbitrary order.
 * @return {!Array<T>}
 */
d3.Map.prototype.values = function() {};

/**
 * Returns an array of key-value objects in arbitrary order.
 * @return {!Array<{key: string, value: T}>}
 */
d3.Map.prototype.entries = function() {};

/**
 * Calls the function for each key and value pair in the map. The 'this' context is the map itself.
 * @param {function(string, T): ?} func
 * @return {void}
 */
d3.Map.prototype.forEach = function(func) {};

/**
 * Is this map empty?
 * @return {boolean}
 */
d3.Map.prototype.empty = function() {};

/**
 * Returns the number of elements stored in the map.
 * @return {number}
 */
d3.Map.prototype.size = function() {};

/**
 * Constructs an initially empty map.
 * Construct a new map by copying keys and values from the given one.
 * Construct a new map by copying enumerable properties and values from the given object.
 * Construct a new map by copying enumerable properties and values from the given object.
 * Construct a new map by copying elements from the array. The key function is used to identify each object.
 * Construct a new map by copying enumerable properties and values from the given object.
 * @template T
 * @param {!d3.Map<T>|!Object<string,T>|!Object<number,T>|!Array<T>|!Object=} object_or_array
 * @param {function(T, number): string=} key
 * @return {!d3.Map<T>|!d3.Map<?>}
 */
d3.map = function(object_or_array, key) {};
/**
 * @record
 * @struct
 */
d3.Set = function() {};

/**
 * Is the given string stored in this set?
 * @param {string} value
 * @return {boolean}
 */
d3.Set.prototype.has = function(value) {};

/**
 * Add the string to this set. Returns the value.
 * @param {string} value
 * @return {string}
 */
d3.Set.prototype.add = function(value) {};

/**
 * Remove the given value from the set. Returns true if it was stored, and false otherwise.
 * @param {string} value
 * @return {boolean}
 */
d3.Set.prototype.remove = function(value) {};

/**
 * Returns an array of the strings stored in this set.
 * @return {!Array<string>}
 */
d3.Set.prototype.values = function() {};

/**
 * Calls a given function for each value in the set. The return value of the function is ignored. The this context of the function is the set itself.
 * @param {function(string): ?} func
 * @return {void}
 */
d3.Set.prototype.forEach = function(func) {};

/**
 * Is this set empty?
 * @return {boolean}
 */
d3.Set.prototype.empty = function() {};

/**
 * Returns the number of values stored in this set.
 * @return {number}
 */
d3.Set.prototype.size = function() {};

/**
 * Creates an initially-empty set.
 * Initializes a set from the given array of strings.
 * @param {!Array<string>=} array
 * @return {!d3.Set}
 */
d3.set = function(array) {};

/**
 * Merges the specified arrays into a single array.
 * @template T
 * @param {!Array<!Array<T>>} arrays
 * @return {!Array<T>}
 */
d3.merge = function(arrays) {};

/**
 * Generates a 0-based numeric sequence. The output range does not include 'stop'.
 * Generates a numeric sequence starting from the given start and stop values. 'step' defaults to 1. The output range does not include 'stop'.
 * @param {number} stop_or_start
 * @param {number=} stop
 * @param {number=} step
 * @return {!Array<number>}
 */
d3.range = function(stop_or_start, stop, step) {};

/**
 * Given the specified array, return an array corresponding to the list of indices in 'keys'.
 * Given the specified object, return an array corresponding to the list of property names in 'keys'.
 * @template T
 * @param {!Object<number,T>|!Object<string,T>} array_or_object
 * @param {!Array<number>|!Array<string>} keys
 * @return {!Array<T>}
 */
d3.permute = function(array_or_object, keys) {};

/**
 * @template T
 * @param {...!Array<T>} arrays
 * @return {!Array<!Array<T>>}
 */
d3.zip = function(arrays) {};

/**
 * @template T
 * @param {!Array<!Array<T>>} matrix
 * @return {!Array<!Array<T>>}
 */
d3.transpose = function(matrix) {};

/**
 * For each adjacent pair of elements in the specified array, returns a new array of tuples of elements i and i - 1.
 * Returns the empty array if the input array has fewer than two elements.
 * @template T
 * @param {!Array<T>} array
 * @return {!Array<!Array<?>>}
 */
d3.pairs = function(array) {};
/**
 * @record
 * @struct
 */
d3.Nest = function() {};

/**
 * @param {function(T): string} func
 * @return {!d3.Nest}
 */
d3.Nest.prototype.key = function(func) {};

/**
 * @param {function(string, string): number} comparator
 * @return {!d3.Nest}
 */
d3.Nest.prototype.sortKeys = function(comparator) {};

/**
 * @param {function(T, T): number} comparator
 * @return {!d3.Nest}
 */
d3.Nest.prototype.sortValues = function(comparator) {};

/**
 * @template U
 * @param {function(!Array<T>): U} func
 * @return {!d3.Nest}
 */
d3.Nest.prototype.rollup = function(func) {};

/**
 * @param {!Array<T>} array
 * @param {?=} mapType
 * @return {!Object<string,?>|!d3.Map<?>}
 */
d3.Nest.prototype.map = function(array, mapType) {};

/**
 * @param {!Array<T>} array
 * @return {!Array<{key: string, values: ?}>}
 */
d3.Nest.prototype.entries = function(array) {};

/**
 * @template T
 * @return {!d3.Nest<T>}
 */
d3.nest = function() {};
/** @const */
d3.random = {};

/**
 * @param {number=} mean
 * @param {number=} deviation
 * @return {function(): number}
 */
d3.random.normal = function(mean, deviation) {};

/**
 * @param {number=} mean
 * @param {number=} deviation
 * @return {function(): number}
 */
d3.random.logNormal = function(mean, deviation) {};

/**
 * @param {number} count
 * @return {function(): number}
 */
d3.random.bates = function(count) {};

/**
 * @param {number} count
 * @return {function(): number}
 */
d3.random.irwinHall = function(count) {};
/**
 * @record
 * @struct
 */
d3.Transform = function() {};
 /** @type {number} */
d3.Transform.prototype.rotate;
 /** @type {!Array<?>} */
d3.Transform.prototype.translate;
 /** @type {number} */
d3.Transform.prototype.skew;
 /** @type {!Array<?>} */
d3.Transform.prototype.scale;

/**
 * @return {string}
 */
d3.Transform.prototype.toString = function() {};

/**
 * @param {string} transform
 * @return {!d3.Transform}
 */
d3.transform = function(transform) {};

/**
 * @param {string} specifier
 * @return {function(number): string}
 */
d3.format = function(specifier) {};
/**
 * @record
 * @struct
 */
d3.FormatPrefix = function() {};
 /** @type {string} */
d3.FormatPrefix.prototype.symbol;

/**
 * @param {number} n
 * @return {number}
 */
d3.FormatPrefix.prototype.scale = function(n) {};

/**
 * @param {number} value
 * @param {number=} precision
 * @return {!d3.FormatPrefix}
 */
d3.formatPrefix = function(value, precision) {};

/**
 * @param {number} x
 * @param {number=} n
 * @return {number}
 */
d3.round = function(x, n) {};

/**
 * @param {string} string
 * @return {string}
 */
d3.requote = function(string) {};
 /** @type {function(new: (!d3.Rgb), number, number, number): ?} */
d3.rgb;
/**
 * @extends {d3.Color}
 * @record
 * @struct
 */
d3.Rgb = function() {};
 /** @type {number} */
d3.Rgb.prototype.r;
 /** @type {number} */
d3.Rgb.prototype.g;
 /** @type {number} */
d3.Rgb.prototype.b;

/**
 * @param {number=} k
 * @return {!d3.Rgb}
 */
d3.Rgb.prototype.brighter = function(k) {};

/**
 * @param {number=} k
 * @return {!d3.Rgb}
 */
d3.Rgb.prototype.darker = function(k) {};

/**
 * @return {!d3.Hsl}
 */
d3.Rgb.prototype.hsl = function() {};

/**
 * @return {string}
 */
d3.Rgb.prototype.toString = function() {};
 /** @type {function(new: (!d3.Hsl), number, number, number): ?} */
d3.hsl;
/**
 * @extends {d3.Color}
 * @record
 * @struct
 */
d3.Hsl = function() {};
 /** @type {number} */
d3.Hsl.prototype.h;
 /** @type {number} */
d3.Hsl.prototype.s;
 /** @type {number} */
d3.Hsl.prototype.l;

/**
 * @param {number=} k
 * @return {!d3.Hsl}
 */
d3.Hsl.prototype.brighter = function(k) {};

/**
 * @param {number=} k
 * @return {!d3.Hsl}
 */
d3.Hsl.prototype.darker = function(k) {};

/**
 * @return {!d3.Rgb}
 */
d3.Hsl.prototype.rgb = function() {};

/**
 * @return {string}
 */
d3.Hsl.prototype.toString = function() {};
 /** @type {function(new: (!d3.Hcl), number, number, number): ?} */
d3.hcl;
/**
 * @extends {d3.Color}
 * @record
 * @struct
 */
d3.Hcl = function() {};
 /** @type {number} */
d3.Hcl.prototype.h;
 /** @type {number} */
d3.Hcl.prototype.c;
 /** @type {number} */
d3.Hcl.prototype.l;

/**
 * @param {number=} k
 * @return {!d3.Hcl}
 */
d3.Hcl.prototype.brighter = function(k) {};

/**
 * @param {number=} k
 * @return {!d3.Hcl}
 */
d3.Hcl.prototype.darker = function(k) {};
 /** @type {function(new: (!d3.Lab), number, number, number): ?} */
d3.lab;
/**
 * @extends {d3.Color}
 * @record
 * @struct
 */
d3.Lab = function() {};
 /** @type {number} */
d3.Lab.prototype.l;
 /** @type {number} */
d3.Lab.prototype.a;
 /** @type {number} */
d3.Lab.prototype.b;

/**
 * @param {number=} k
 * @return {!d3.Lab}
 */
d3.Lab.prototype.brighter = function(k) {};

/**
 * @param {number=} k
 * @return {!d3.Lab}
 */
d3.Lab.prototype.darker = function(k) {};

/**
 * @return {!d3.Rgb}
 */
d3.Lab.prototype.rgb = function() {};

/**
 * @return {string}
 */
d3.Lab.prototype.toString = function() {};
 /** @type {function(new: (!d3.Color)): ?} */
d3.color;
/**
 * @record
 * @struct
 */
d3.Color = function() {};

/**
 * @return {!d3.Rgb}
 */
d3.Color.prototype.rgb = function() {};
/** @const */
d3.ns = {};
/**
 * @record
 * @struct
 */
d3.ns.Qualified = function() {};
 /** @type {string} */
d3.ns.Qualified.prototype.space;
 /** @type {string} */
d3.ns.Qualified.prototype.local;
 /** @type {!Object<string,string>} */
d3.ns.prefix;

/**
 * @param {string} name
 * @return {(string|!d3.ns.Qualified)}
 */
d3.ns.qualify = function(name) {};

/**
 * @template T
 * @param {T} value
 * @return {T|function(): T}
 */
d3.functor = function(value) {};

/**
 * @param {!Object} target
 * @param {!Object} source
 * @param {...string} names
 * @return {?}
 */
d3.rebind = function(target, source, names) {};

/**
 * @param {...string} names
 * @return {!d3.Dispatch}
 */
d3.dispatch = function(names) {};
/**
 * @record
 * @struct
 */
d3.Dispatch = function() {};

/* TODO: IndexSignature: d3 */

/**
 * @param {string} type
 * @param {function(!Array<?>): ?=} listener
 * @return {function(!Array<?>): void|!d3.Dispatch}
 */
d3.Dispatch.prototype.on = function(type, listener) {};
/** @const */
d3.scale = {};

/**
 * @return {!d3.scale.Identity}
 */
d3.scale.identity = function() {};
/**
 * @record
 * @struct
 */
d3.scale.Identity = function() {};

/* TODO: CallSignature: d3.scale */

/**
 * @param {number} n
 * @return {number}
 */
d3.scale.Identity.prototype.invert = function(n) {};

/**
 * @param {!Array<number>=} numbers
 * @return {!Array<number>|!d3.scale.Identity}
 */
d3.scale.Identity.prototype.domain = function(numbers) {};

/**
 * @param {!Array<number>=} numbers
 * @return {!Array<number>|!d3.scale.Identity}
 */
d3.scale.Identity.prototype.range = function(numbers) {};

/**
 * @param {number=} count
 * @return {!Array<number>}
 */
d3.scale.Identity.prototype.ticks = function(count) {};

/**
 * @param {number=} count
 * @param {string=} format
 * @return {function(number): string}
 */
d3.scale.Identity.prototype.tickFormat = function(count, format) {};

/**
 * @return {!d3.scale.Identity}
 */
d3.scale.Identity.prototype.copy = function() {};

/**
 * @template Output, Range
 * @return {!d3.scale.Linear<number, number>|!d3.scale.Linear<Output, Output>|!d3.scale.Linear<Range, Output>}
 */
d3.scale.linear = function() {};
/**
 * @record
 * @struct
 */
d3.scale.Linear = function() {};

/* TODO: CallSignature: d3.scale */

/**
 * @param {number} y
 * @return {number}
 */
d3.scale.Linear.prototype.invert = function(y) {};

/**
 * @param {!Array<number>=} numbers
 * @return {!Array<number>|!d3.scale.Linear}
 */
d3.scale.Linear.prototype.domain = function(numbers) {};

/**
 * @param {!Array<Range>=} values
 * @return {!Array<Range>|!d3.scale.Linear}
 */
d3.scale.Linear.prototype.range = function(values) {};

/**
 * @param {!Array<number>} values
 * @return {!d3.scale.Linear<number, number>}
 */
d3.scale.Linear.prototype.rangeRound = function(values) {};

/**
 * @param {function(Range, Range): function(number): Output=} factory
 * @return {function(Range, Range): function(number): Output|!d3.scale.Linear}
 */
d3.scale.Linear.prototype.interpolate = function(factory) {};

/**
 * @param {boolean=} clamp
 * @return {boolean|!d3.scale.Linear}
 */
d3.scale.Linear.prototype.clamp = function(clamp) {};

/**
 * @param {number=} count
 * @return {!d3.scale.Linear}
 */
d3.scale.Linear.prototype.nice = function(count) {};

/**
 * @param {number=} count
 * @return {!Array<number>}
 */
d3.scale.Linear.prototype.ticks = function(count) {};

/**
 * @param {number=} count
 * @param {string=} format
 * @return {function(number): string}
 */
d3.scale.Linear.prototype.tickFormat = function(count, format) {};

/**
 * @return {!d3.scale.Linear}
 */
d3.scale.Linear.prototype.copy = function() {};

/**
 * @template Output, Range
 * @return {!d3.scale.Pow<number, number>|!d3.scale.Pow<Output, Output>|!d3.scale.Pow<Range, Output>}
 */
d3.scale.sqrt = function() {};

/**
 * @template Output, Range
 * @return {!d3.scale.Pow<number, number>|!d3.scale.Pow<Output, Output>|!d3.scale.Pow<Range, Output>}
 */
d3.scale.pow = function() {};
/**
 * @record
 * @struct
 */
d3.scale.Pow = function() {};

/* TODO: CallSignature: d3.scale */

/**
 * @param {number} y
 * @return {number}
 */
d3.scale.Pow.prototype.invert = function(y) {};

/**
 * @param {!Array<number>=} numbers
 * @return {!Array<number>|!d3.scale.Pow}
 */
d3.scale.Pow.prototype.domain = function(numbers) {};

/**
 * @param {!Array<Range>=} values
 * @return {!Array<Range>|!d3.scale.Pow}
 */
d3.scale.Pow.prototype.range = function(values) {};

/**
 * @param {!Array<number>} values
 * @return {!d3.scale.Pow<number, number>}
 */
d3.scale.Pow.prototype.rangeRound = function(values) {};

/**
 * @param {number=} k
 * @return {number|!d3.scale.Pow}
 */
d3.scale.Pow.prototype.exponent = function(k) {};

/**
 * @param {function(Range, Range): function(number): Output=} factory
 * @return {function(Range, Range): function(number): Output|!d3.scale.Pow}
 */
d3.scale.Pow.prototype.interpolate = function(factory) {};

/**
 * @param {boolean=} clamp
 * @return {boolean|!d3.scale.Pow}
 */
d3.scale.Pow.prototype.clamp = function(clamp) {};

/**
 * @param {number=} m
 * @return {!d3.scale.Pow}
 */
d3.scale.Pow.prototype.nice = function(m) {};

/**
 * @param {number=} count
 * @return {!Array<number>}
 */
d3.scale.Pow.prototype.ticks = function(count) {};

/**
 * @param {number=} count
 * @param {string=} format
 * @return {function(number): string}
 */
d3.scale.Pow.prototype.tickFormat = function(count, format) {};

/**
 * @return {!d3.scale.Pow}
 */
d3.scale.Pow.prototype.copy = function() {};

/**
 * @template Output, Range
 * @return {!d3.scale.Log<number, number>|!d3.scale.Log<Output, Output>|!d3.scale.Log<Range, Output>}
 */
d3.scale.log = function() {};
/**
 * @record
 * @struct
 */
d3.scale.Log = function() {};

/* TODO: CallSignature: d3.scale */

/**
 * @param {number} y
 * @return {number}
 */
d3.scale.Log.prototype.invert = function(y) {};

/**
 * @param {!Array<number>=} numbers
 * @return {!Array<number>|!d3.scale.Log}
 */
d3.scale.Log.prototype.domain = function(numbers) {};

/**
 * @param {!Array<Range>=} values
 * @return {!Array<Range>|!d3.scale.Log}
 */
d3.scale.Log.prototype.range = function(values) {};

/**
 * @param {!Array<number>} values
 * @return {!d3.scale.Log<number, number>}
 */
d3.scale.Log.prototype.rangeRound = function(values) {};

/**
 * @param {number=} base
 * @return {number|!d3.scale.Log}
 */
d3.scale.Log.prototype.base = function(base) {};

/**
 * @param {function(Range, Range): function(number): Output=} factory
 * @return {function(Range, Range): function(number): Output|!d3.scale.Log}
 */
d3.scale.Log.prototype.interpolate = function(factory) {};

/**
 * @param {boolean=} clamp
 * @return {boolean|!d3.scale.Log}
 */
d3.scale.Log.prototype.clamp = function(clamp) {};

/**
 * @return {!d3.scale.Log}
 */
d3.scale.Log.prototype.nice = function() {};

/**
 * @return {!Array<number>}
 */
d3.scale.Log.prototype.ticks = function() {};

/**
 * @param {number=} count
 * @param {string=} format
 * @return {function(number): string}
 */
d3.scale.Log.prototype.tickFormat = function(count, format) {};

/**
 * @return {!d3.scale.Log}
 */
d3.scale.Log.prototype.copy = function() {};

/**
 * @template T
 * @return {!d3.scale.Quantize<T>}
 */
d3.scale.quantize = function() {};
/**
 * @record
 * @struct
 */
d3.scale.Quantize = function() {};

/* TODO: CallSignature: d3.scale */

/**
 * @param {T} y
 * @return {!Array<?>}
 */
d3.scale.Quantize.prototype.invertExtent = function(y) {};

/**
 * @param {!Array<number>=} numbers
 * @return {!Array<number>|!d3.scale.Quantize}
 */
d3.scale.Quantize.prototype.domain = function(numbers) {};

/**
 * @param {!Array<T>=} values
 * @return {!Array<T>|!d3.scale.Quantize}
 */
d3.scale.Quantize.prototype.range = function(values) {};

/**
 * @return {!d3.scale.Quantize}
 */
d3.scale.Quantize.prototype.copy = function() {};

/**
 * @template T
 * @return {!d3.scale.Quantile<T>}
 */
d3.scale.quantile = function() {};
/**
 * @record
 * @struct
 */
d3.scale.Quantile = function() {};

/* TODO: CallSignature: d3.scale */

/**
 * @param {T} y
 * @return {!Array<?>}
 */
d3.scale.Quantile.prototype.invertExtent = function(y) {};

/**
 * @param {!Array<number>=} numbers
 * @return {!Array<number>|!d3.scale.Quantile}
 */
d3.scale.Quantile.prototype.domain = function(numbers) {};

/**
 * @param {!Array<T>=} values
 * @return {!Array<T>|!d3.scale.Quantile}
 */
d3.scale.Quantile.prototype.range = function(values) {};

/**
 * @return {!Array<number>}
 */
d3.scale.Quantile.prototype.quantiles = function() {};

/**
 * @return {!d3.scale.Quantile}
 */
d3.scale.Quantile.prototype.copy = function() {};

/**
 * @template Range, Domain
 * @return {!d3.scale.Threshold<number, Range>|!d3.scale.Threshold<Domain, Range>}
 */
d3.scale.threshold = function() {};
/**
 * @record
 * @struct
 */
d3.scale.Threshold = function() {};

/* TODO: CallSignature: d3.scale */

/**
 * @param {Range} y
 * @return {!Array<?>}
 */
d3.scale.Threshold.prototype.invertExtent = function(y) {};

/**
 * @param {!Array<Domain>=} domain
 * @return {!Array<Domain>|!d3.scale.Threshold}
 */
d3.scale.Threshold.prototype.domain = function(domain) {};

/**
 * @param {!Array<Range>=} values
 * @return {!Array<Range>|!d3.scale.Threshold}
 */
d3.scale.Threshold.prototype.range = function(values) {};

/**
 * @return {!d3.scale.Threshold}
 */
d3.scale.Threshold.prototype.copy = function() {};

/**
 * @template Range, Domain
 * @return {!d3.scale.Ordinal<string, Range>|!d3.scale.Ordinal<Domain, Range>}
 */
d3.scale.ordinal = function() {};

/**
 * @template Domain
 * @return {!d3.scale.Ordinal<string, string>|!d3.scale.Ordinal<Domain, string>}
 */
d3.scale.category10 = function() {};

/**
 * @template Domain
 * @return {!d3.scale.Ordinal<string, string>|!d3.scale.Ordinal<Domain, string>}
 */
d3.scale.category20 = function() {};

/**
 * @template Domain
 * @return {!d3.scale.Ordinal<string, string>|!d3.scale.Ordinal<Domain, string>}
 */
d3.scale.category20b = function() {};

/**
 * @template Domain
 * @return {!d3.scale.Ordinal<string, string>|!d3.scale.Ordinal<Domain, string>}
 */
d3.scale.category20c = function() {};
/**
 * @record
 * @struct
 */
d3.scale.Ordinal = function() {};

/* TODO: CallSignature: d3.scale */

/**
 * @param {!Array<Domain>=} values
 * @return {!Array<Domain>|!d3.scale.Ordinal}
 */
d3.scale.Ordinal.prototype.domain = function(values) {};

/**
 * @param {!Array<Range>=} values
 * @return {!Array<Range>|!d3.scale.Ordinal}
 */
d3.scale.Ordinal.prototype.range = function(values) {};

/**
 * @param {!Array<?>} interval
 * @param {number=} padding
 * @return {!d3.scale.Ordinal<Domain, number>}
 */
d3.scale.Ordinal.prototype.rangePoints = function(interval, padding) {};

/**
 * @param {!Array<?>} interval
 * @param {number=} padding
 * @return {!d3.scale.Ordinal<Domain, number>}
 */
d3.scale.Ordinal.prototype.rangeRoundPoints = function(interval, padding) {};

/**
 * @param {!Array<?>} interval
 * @param {number=} padding
 * @param {number=} outerPadding
 * @return {!d3.scale.Ordinal<Domain, number>}
 */
d3.scale.Ordinal.prototype.rangeBands = function(interval, padding, outerPadding) {};

/**
 * @param {!Array<?>} interval
 * @param {number=} padding
 * @param {number=} outerPadding
 * @return {!d3.scale.Ordinal<Domain, number>}
 */
d3.scale.Ordinal.prototype.rangeRoundBands = function(interval, padding, outerPadding) {};

/**
 * @return {number}
 */
d3.scale.Ordinal.prototype.rangeBand = function() {};

/**
 * @return {!Array<?>}
 */
d3.scale.Ordinal.prototype.rangeExtent = function() {};

/**
 * @return {!d3.scale.Ordinal}
 */
d3.scale.Ordinal.prototype.copy = function() {};

/**
 * @template Range, Output
 * @param {number|string|(string|!d3.Color)|!Array<(string|!d3.Color)>|!Array<Range>|!Object<string,(string|!d3.Color)>|!Object<string,Range>} a
 * @param {number|string|!d3.Color|!Array<!d3.Color>|!Array<Output>|!Array<Range>|!Object<string,!d3.Color>|!Object<string,Output>|!Object<string,Range>} b
 * @return {function(number): number|function(number): string|function(number): !Array<Output>|function(number): !Object<string,string>|function(number): !Object<string,Output>}
 */
d3.interpolate = function(a, b) {};

/**
 * @param {number} a
 * @param {number} b
 * @return {function(number): number}
 */
d3.interpolateNumber = function(a, b) {};

/**
 * @param {number} a
 * @param {number} b
 * @return {function(number): number}
 */
d3.interpolateRound = function(a, b) {};

/**
 * @param {string} a
 * @param {string} b
 * @return {function(number): string}
 */
d3.interpolateString = function(a, b) {};

/**
 * @param {(string|!d3.Color)} a
 * @param {(string|!d3.Color)} b
 * @return {function(number): string}
 */
d3.interpolateRgb = function(a, b) {};

/**
 * @param {(string|!d3.Color)} a
 * @param {(string|!d3.Color)} b
 * @return {function(number): string}
 */
d3.interpolateHsl = function(a, b) {};

/**
 * @param {(string|!d3.Color)} a
 * @param {(string|!d3.Color)} b
 * @return {function(number): string}
 */
d3.interpolateLab = function(a, b) {};

/**
 * @param {(string|!d3.Color)} a
 * @param {(string|!d3.Color)} b
 * @return {function(number): string}
 */
d3.interpolateHcl = function(a, b) {};

/**
 * @template Range, Output
 * @param {!Array<(string|!d3.Color)>|!Array<Range>} a
 * @param {!Array<!d3.Color>|!Array<Range>|!Array<Output>} b
 * @return {function(number): !Array<string>|function(number): !Array<Output>}
 */
d3.interpolateArray = function(a, b) {};

/**
 * @template Range, Output
 * @param {!Object<string,(string|!d3.Color)>|!Object<string,Range>} a
 * @param {!Object<string,!d3.Color>|!Object<string,Output>|!Object<string,Range>} b
 * @return {function(number): !Object<string,string>|function(number): !Object<string,Output>}
 */
d3.interpolateObject = function(a, b) {};

/**
 * @param {(string|!d3.Transform)} a
 * @param {(string|!d3.Transform)} b
 * @return {function(number): string}
 */
d3.interpolateTransform = function(a, b) {};

/**
 * @param {!Array<?>} a
 * @param {!Array<?>} b
 * @return {?}
 */
d3.interpolateZoom = function(a, b) {};
 /** @type {!Array<function(?, ?): function(number): ?>} */
d3.interpolators;
/** @const */
d3.time = {};
 /** @type {!d3.time.Interval} */
d3.time.second;
 /** @type {!d3.time.Interval} */
d3.time.minute;
 /** @type {!d3.time.Interval} */
d3.time.hour;
 /** @type {!d3.time.Interval} */
d3.time.day;
 /** @type {!d3.time.Interval} */
d3.time.week;
 /** @type {!d3.time.Interval} */
d3.time.sunday;
 /** @type {!d3.time.Interval} */
d3.time.monday;
 /** @type {!d3.time.Interval} */
d3.time.tuesday;
 /** @type {!d3.time.Interval} */
d3.time.wednesday;
 /** @type {!d3.time.Interval} */
d3.time.thursday;
 /** @type {!d3.time.Interval} */
d3.time.friday;
 /** @type {!d3.time.Interval} */
d3.time.saturday;
 /** @type {!d3.time.Interval} */
d3.time.month;
 /** @type {!d3.time.Interval} */
d3.time.year;
/**
 * @record
 * @struct
 */
d3.time.Interval = function() {};

/* TODO: CallSignature: d3.time */
 /** @type {?} */
d3.time.Interval.prototype.utc;

/**
 * @param {!Date} d
 * @return {!Date}
 */
d3.time.Interval.prototype.floor = function(d) {};

/**
 * @param {!Date} d
 * @return {!Date}
 */
d3.time.Interval.prototype.round = function(d) {};

/**
 * @param {!Date} d
 * @return {!Date}
 */
d3.time.Interval.prototype.ceil = function(d) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.Interval.prototype.range = function(start, stop, step) {};

/**
 * @param {!Date} date
 * @param {number} step
 * @return {!Date}
 */
d3.time.Interval.prototype.offset = function(date, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.seconds = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.minutes = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.hours = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.days = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.weeks = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.sundays = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.mondays = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.tuesdays = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.wednesdays = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.thursdays = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.fridays = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.saturdays = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.months = function(start, stop, step) {};

/**
 * @param {!Date} start
 * @param {!Date} stop
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.years = function(start, stop, step) {};

/**
 * @param {!Date} d
 * @return {number}
 */
d3.time.dayOfYear = function(d) {};

/**
 * @param {!Date} d
 * @return {number}
 */
d3.time.weekOfYear = function(d) {};

/**
 * @param {!Date} d
 * @return {number}
 */
d3.time.sundayOfYear = function(d) {};

/**
 * @param {!Date} d
 * @return {number}
 */
d3.time.mondayOfYear = function(d) {};

/**
 * @param {!Date} d
 * @return {number}
 */
d3.time.tuesdayOfYear = function(d) {};

/**
 * @param {!Date} d
 * @return {number}
 */
d3.time.wednesdayOfYear = function(d) {};

/**
 * @param {!Date} d
 * @return {number}
 */
d3.time.fridayOfYear = function(d) {};

/**
 * @param {!Date} d
 * @return {number}
 */
d3.time.saturdayOfYear = function(d) {};

/**
 * @param {string} specifier
 * @return {!d3.time.Format}
 */
d3.time.format = function(specifier) {};

/**
 * @param {!Array<!Array<?>>} formats
 * @return {!d3.time.Format}
 */
d3.time.format.multi = function(formats) {};

/**
 * @param {string} specifier
 * @return {!d3.time.Format}
 */
d3.time.format.utc = function(specifier) {};

/**
 * @param {!Array<!Array<?>>} formats
 * @return {!d3.time.Format}
 */
d3.time.format.utc.multi = function(formats) {};
 /** @type {!d3.time.Format} */
d3.time.format.iso;
/**
 * @record
 * @struct
 */
d3.time.Format = function() {};

/* TODO: CallSignature: d3.time */

/**
 * @param {string} input
 * @return {!Date}
 */
d3.time.Format.prototype.parse = function(input) {};

/**
 * @template Output, Range
 * @return {!d3.time.Scale<number, number>|!d3.time.Scale<Output, Output>|!d3.time.Scale<Range, Output>}
 */
d3.time.scale = function() {};

/**
 * @template Output, Range
 * @return {!d3.time.Scale<number, number>|!d3.time.Scale<Output, Output>|!d3.time.Scale<Range, Output>}
 */
d3.time.scale.utc = function() {};
/**
 * @record
 * @struct
 */
d3.time.Scale = function() {};

/* TODO: CallSignature: d3.time */

/**
 * @param {number} y
 * @return {!Date}
 */
d3.time.Scale.prototype.invert = function(y) {};

/**
 * @param {!Array<number>|!Array<!Date>=} dates
 * @return {!Array<!Date>|!d3.time.Scale}
 */
d3.time.Scale.prototype.domain = function(dates) {};

/**
 * @param {!d3.time.Interval=} interval
 * @param {number=} step
 * @return {!d3.time.Scale}
 */
d3.time.Scale.prototype.nice = function(interval, step) {};

/**
 * @param {!Array<Range>=} values
 * @return {!Array<Range>|!d3.time.Scale}
 */
d3.time.Scale.prototype.range = function(values) {};

/**
 * @param {!Array<number>} values
 * @return {!d3.time.Scale<number, number>}
 */
d3.time.Scale.prototype.rangeRound = function(values) {};

/**
 * @param {function(Range, Range): function(number): Output=} factory
 * @return {function(Range, Range): function(number): Output|!d3.time.Scale}
 */
d3.time.Scale.prototype.interpolate = function(factory) {};

/**
 * @param {boolean=} clamp
 * @return {boolean|!d3.time.Scale}
 */
d3.time.Scale.prototype.clamp = function(clamp) {};

/**
 * @param {!d3.time.Interval|number=} interval_or_count
 * @param {number=} step
 * @return {!Array<!Date>}
 */
d3.time.Scale.prototype.ticks = function(interval_or_count, step) {};

/**
 * @param {number} count
 * @return {function(!Date): string}
 */
d3.time.Scale.prototype.tickFormat = function(count) {};

/**
 * @return {!d3.time.Scale}
 */
d3.time.Scale.prototype.copy = function() {};
/** @const */
d3.behavior = {};

/**
 * @template Datum
 * @return {!d3.behavior.Drag<Datum>}
 */
d3.behavior.drag = function() {};
/**
 * @record
 * @struct
 */
d3.behavior.Drag = function() {};

/* TODO: CallSignature: d3.behavior */

/**
 * @param {string} type
 * @param {function(Datum, number): ?=} listener
 * @return {function(Datum, number): ?|!d3.behavior.Drag}
 */
d3.behavior.Drag.prototype.on = function(type, listener) {};

/**
 * @param {function(Datum, number): {x: number, y: number}=} accessor
 * @return {function(Datum, number): {x: number, y: number}|!d3.behavior.Drag}
 */
d3.behavior.Drag.prototype.origin = function(accessor) {};

/**
 * @template Datum
 * @return {!d3.behavior.Zoom<Datum>}
 */
d3.behavior.zoom = function() {};
/**
 * @record
 * @struct
 */
d3.behavior.zoom.Scale = function() {};

/**
 * @param {!Array<number>=} values
 * @return {!Array<number>|!d3.behavior.zoom.Scale}
 */
d3.behavior.zoom.Scale.prototype.domain = function(values) {};

/**
 * @param {number} y
 * @return {number}
 */
d3.behavior.zoom.Scale.prototype.invert = function(y) {};

/**
 * @param {!Array<number>=} values
 * @return {!d3.behavior.zoom.Scale|!Array<number>}
 */
d3.behavior.zoom.Scale.prototype.range = function(values) {};
/**
 * @record
 * @struct
 */
d3.behavior.Zoom = function() {};

/* TODO: CallSignature: d3.behavior */

/**
 * @param {!Array<?>=} translate
 * @return {!Array<?>|!d3.behavior.Zoom}
 */
d3.behavior.Zoom.prototype.translate = function(translate) {};

/**
 * @param {number=} scale
 * @return {number|!d3.behavior.Zoom}
 */
d3.behavior.Zoom.prototype.scale = function(scale) {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.behavior.Zoom}
 */
d3.behavior.Zoom.prototype.scaleExtent = function(extent) {};

/**
 * @param {!Array<?>=} center
 * @return {!Array<?>|!d3.behavior.Zoom}
 */
d3.behavior.Zoom.prototype.center = function(center) {};

/**
 * @param {!Array<?>=} size
 * @return {!Array<?>|!d3.behavior.Zoom}
 */
d3.behavior.Zoom.prototype.size = function(size) {};

/**
 * @param {!d3.behavior.zoom.Scale=} x
 * @return {!d3.behavior.zoom.Scale|!d3.behavior.Zoom}
 */
d3.behavior.Zoom.prototype.x = function(x) {};

/**
 * @param {!d3.behavior.zoom.Scale=} y
 * @return {!d3.behavior.zoom.Scale|!d3.behavior.Zoom}
 */
d3.behavior.Zoom.prototype.y = function(y) {};

/**
 * @param {string} type
 * @param {function(Datum, number): ?=} listener
 * @return {function(Datum, number): ?|!d3.behavior.Zoom}
 */
d3.behavior.Zoom.prototype.on = function(type, listener) {};

/**
 * @param {!d3.Selection<Datum>|!d3.Transition<Datum>} selection_or_transition
 * @return {void}
 */
d3.behavior.Zoom.prototype.event = function(selection_or_transition) {};
/** @const */
d3.geo = {};

/**
 * @return {!d3.geo.Path}
 */
d3.geo.path = function() {};
/**
 * @record
 * @struct
 */
d3.geo.Path = function() {};

/* TODO: CallSignature: d3.geo */

/**
 * @param {?} feature
 * @return {number}
 */
d3.geo.Path.prototype.area = function(feature) {};

/**
 * @param {?} feature
 * @return {!Array<?>}
 */
d3.geo.Path.prototype.centroid = function(feature) {};

/**
 * @param {?} feature
 * @return {!Array<?>}
 */
d3.geo.Path.prototype.bounds = function(feature) {};

/**
 * @param {!d3.geo.Transform|function(!Array<?>): !Array<?>=} stream_or_projection
 * @return {(!d3.geo.Transform|function(!Array<?>): !Array<?>)|!d3.geo.Path}
 */
d3.geo.Path.prototype.projection = function(stream_or_projection) {};

/**
 * @param {number|function(?, number): number=} radius
 * @return {(number|function(?, number): number)|!d3.geo.Path}
 */
d3.geo.Path.prototype.pointRadius = function(radius) {};

/**
 * @param {!CanvasRenderingContext2D=} context
 * @return {!CanvasRenderingContext2D|!d3.geo.Path}
 */
d3.geo.Path.prototype.context = function(context) {};

/**
 * @return {!d3.geo.Graticule}
 */
d3.geo.graticule = function() {};
/**
 * @record
 * @struct
 */
d3.geo.Graticule = function() {};

/* TODO: CallSignature: d3.geo */

/**
 * @return {!Array<?>}
 */
d3.geo.Graticule.prototype.lines = function() {};

/**
 * @return {?}
 */
d3.geo.Graticule.prototype.outline = function() {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.geo.Graticule}
 */
d3.geo.Graticule.prototype.extent = function(extent) {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.geo.Graticule}
 */
d3.geo.Graticule.prototype.majorExtent = function(extent) {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.geo.Graticule}
 */
d3.geo.Graticule.prototype.minorExtent = function(extent) {};

/**
 * @param {!Array<?>=} step
 * @return {!Array<?>|!d3.geo.Graticule}
 */
d3.geo.Graticule.prototype.step = function(step) {};

/**
 * @param {!Array<?>=} step
 * @return {!Array<?>|!d3.geo.Graticule}
 */
d3.geo.Graticule.prototype.majorStep = function(step) {};

/**
 * @param {!Array<?>=} step
 * @return {!Array<?>|!d3.geo.Graticule}
 */
d3.geo.Graticule.prototype.minorStep = function(step) {};

/**
 * @param {number=} precision
 * @return {number|!d3.geo.Graticule}
 */
d3.geo.Graticule.prototype.precision = function(precision) {};

/**
 * @return {!d3.geo.Circle}
 */
d3.geo.circle = function() {};
/**
 * @record
 * @struct
 */
d3.geo.Circle = function() {};

/* TODO: CallSignature: d3.geo */

/**
 * @param {!Array<?>|function(!Array<?>): !Array<?>=} origin
 * @return {(!Array<?>|function(!Array<?>): !Array<?>)|!d3.geo.Circle}
 */
d3.geo.Circle.prototype.origin = function(origin) {};

/**
 * @param {number=} angle
 * @return {number|!d3.geo.Circle}
 */
d3.geo.Circle.prototype.angle = function(angle) {};

/**
 * @param {number=} precision
 * @return {number|!d3.geo.Circle}
 */
d3.geo.Circle.prototype.precision = function(precision) {};

/**
 * @param {?} feature
 * @return {number}
 */
d3.geo.area = function(feature) {};

/**
 * @param {?} feature
 * @return {!Array<?>}
 */
d3.geo.centroid = function(feature) {};

/**
 * @param {?} feature
 * @return {!Array<?>}
 */
d3.geo.bounds = function(feature) {};

/**
 * @param {!Array<?>} a
 * @param {!Array<?>} b
 * @return {number}
 */
d3.geo.distance = function(a, b) {};

/**
 * @param {?} feature
 * @return {number}
 */
d3.geo.length = function(feature) {};

/**
 * @param {!Array<?>} a
 * @param {!Array<?>} b
 * @return {function(number): !Array<?>}
 */
d3.geo.interpolate = function(a, b) {};

/**
 * @param {!Array<?>} rotate
 * @return {!d3.geo.Rotation}
 */
d3.geo.rotation = function(rotate) {};
/**
 * @record
 * @struct
 */
d3.geo.Rotation = function() {};

/* TODO: CallSignature: d3.geo */

/**
 * @param {!Array<?>} location
 * @return {!Array<?>}
 */
d3.geo.Rotation.prototype.invert = function(location) {};

/**
 * @param {?} object
 * @param {!d3.geo.Listener} listener
 * @return {void}
 */
d3.geo.stream = function(object, listener) {};
/**
 * @record
 * @struct
 */
d3.geo.Listener = function() {};

/**
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {void}
 */
d3.geo.Listener.prototype.point = function(x, y, z) {};

/**
 * @return {void}
 */
d3.geo.Listener.prototype.lineStart = function() {};

/**
 * @return {void}
 */
d3.geo.Listener.prototype.lineEnd = function() {};

/**
 * @return {void}
 */
d3.geo.Listener.prototype.polygonStart = function() {};

/**
 * @return {void}
 */
d3.geo.Listener.prototype.polygonEnd = function() {};

/**
 * @return {void}
 */
d3.geo.Listener.prototype.sphere = function() {};

/**
 * @param {!d3.geo.TransformMethods} methods
 * @return {!d3.geo.Transform}
 */
d3.geo.transform = function(methods) {};
/**
 * @record
 * @struct
 */
d3.geo.TransformMethods = function() {};

/**
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {void}
 */
d3.geo.TransformMethods.prototype.point = function(x, y, z) {};

/**
 * @return {void}
 */
d3.geo.TransformMethods.prototype.lineStart = function() {};

/**
 * @return {void}
 */
d3.geo.TransformMethods.prototype.lineEnd = function() {};

/**
 * @return {void}
 */
d3.geo.TransformMethods.prototype.polygonStart = function() {};

/**
 * @return {void}
 */
d3.geo.TransformMethods.prototype.polygonEnd = function() {};

/**
 * @return {void}
 */
d3.geo.TransformMethods.prototype.sphere = function() {};
/**
 * @record
 * @struct
 */
d3.geo.Transform = function() {};

/**
 * @param {!d3.geo.Listener} stream
 * @return {!d3.geo.Listener}
 */
d3.geo.Transform.prototype.stream = function(stream) {};

/**
 * @return {!d3.geo.ClipExtent}
 */
d3.geo.clipExtent = function() {};
/**
 * @extends {d3.geo.Transform}
 * @record
 * @struct
 */
d3.geo.ClipExtent = function() {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.geo.ClipExtent}
 */
d3.geo.ClipExtent.prototype.extent = function(extent) {};

/**
 * @param {!d3.geo.RawInvertibleProjection|!d3.geo.RawProjection} raw
 * @return {!d3.geo.InvertibleProjection|!d3.geo.Projection}
 */
d3.geo.projection = function(raw) {};

/**
 * @param {function(!Array<?>): !d3.geo.RawInvertibleProjection|function(!Array<?>): !d3.geo.RawProjection} factory
 * @return {function(!Array<?>): !d3.geo.InvertibleProjection|function(!Array<?>): !d3.geo.Projection}
 */
d3.geo.projectionMutator = function(factory) {};

/**
 * @return {!d3.geo.ConicProjection}
 */
d3.geo.albers = function() {};

/**
 * @return {!d3.geo.ConicProjection}
 */
d3.geo.albersUsa = function() {};

/**
 * @return {!d3.geo.InvertibleProjection}
 */
d3.geo.azimuthalEqualArea = function() {};

/**
 * @param {number} lambda
 * @param {number} phi
 * @return {!Array<?>}
 */
d3.geo.azimuthalEqualArea.raw = function(lambda, phi) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!Array<?>}
 */
d3.geo.azimuthalEqualArea.raw.invert = function(x, y) {};

/**
 * @return {!d3.geo.InvertibleProjection}
 */
d3.geo.azimuthalEquidistant = function() {};

/**
 * @param {number} lambda
 * @param {number} phi
 * @return {!Array<?>}
 */
d3.geo.azimuthalEquidistant.raw = function(lambda, phi) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!Array<?>}
 */
d3.geo.azimuthalEquidistant.raw.invert = function(x, y) {};

/**
 * @return {!d3.geo.ConicProjection}
 */
d3.geo.conicConformal = function() {};

/**
 * @param {number} phi0
 * @param {number} phi1
 * @return {!d3.geo.RawInvertibleProjection}
 */
d3.geo.conicConformal.raw = function(phi0, phi1) {};

/**
 * @return {!d3.geo.ConicProjection}
 */
d3.geo.conicEqualArea = function() {};

/**
 * @param {number} phi0
 * @param {number} phi1
 * @return {!d3.geo.RawInvertibleProjection}
 */
d3.geo.conicEqualArea.raw = function(phi0, phi1) {};

/**
 * @return {!d3.geo.ConicProjection}
 */
d3.geo.conicEquidistant = function() {};

/**
 * @param {number} phi0
 * @param {number} phi1
 * @return {!d3.geo.RawInvertibleProjection}
 */
d3.geo.conicEquidistant.raw = function(phi0, phi1) {};

/**
 * @return {!d3.geo.InvertibleProjection}
 */
d3.geo.equirectangular = function() {};

/**
 * @param {number} lambda
 * @param {number} phi
 * @return {!Array<?>}
 */
d3.geo.equirectangular.raw = function(lambda, phi) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!Array<?>}
 */
d3.geo.equirectangular.raw.invert = function(x, y) {};

/**
 * @return {!d3.geo.InvertibleProjection}
 */
d3.geo.gnomonic = function() {};

/**
 * @param {number} lambda
 * @param {number} phi
 * @return {!Array<?>}
 */
d3.geo.gnomonic.raw = function(lambda, phi) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!Array<?>}
 */
d3.geo.gnomonic.raw.invert = function(x, y) {};

/**
 * @return {!d3.geo.InvertibleProjection}
 */
d3.geo.mercator = function() {};

/**
 * @param {number} lambda
 * @param {number} phi
 * @return {!Array<?>}
 */
d3.geo.mercator.raw = function(lambda, phi) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!Array<?>}
 */
d3.geo.mercator.raw.invert = function(x, y) {};

/**
 * @return {!d3.geo.InvertibleProjection}
 */
d3.geo.orthographic = function() {};

/**
 * @param {number} lambda
 * @param {number} phi
 * @return {!Array<?>}
 */
d3.geo.orthographic.raw = function(lambda, phi) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!Array<?>}
 */
d3.geo.orthographic.raw.invert = function(x, y) {};

/**
 * @return {!d3.geo.InvertibleProjection}
 */
d3.geo.stereographic = function() {};

/**
 * @param {number} lambda
 * @param {number} phi
 * @return {!Array<?>}
 */
d3.geo.stereographic.raw = function(lambda, phi) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!Array<?>}
 */
d3.geo.stereographic.raw.invert = function(x, y) {};

/**
 * @return {!d3.geo.InvertibleProjection}
 */
d3.geo.transverseMercator = function() {};

/**
 * @param {number} lambda
 * @param {number} phi
 * @return {!Array<?>}
 */
d3.geo.transverseMercator.raw = function(lambda, phi) {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!Array<?>}
 */
d3.geo.transverseMercator.raw.invert = function(x, y) {};
/**
 * @record
 * @struct
 */
d3.geo.Projection = function() {};

/* TODO: CallSignature: d3.geo */

/**
 * @param {!Array<?>=} rotation
 * @return {!Array<?>|!d3.geo.Projection}
 */
d3.geo.Projection.prototype.rotate = function(rotation) {};

/**
 * @param {!Array<?>=} location
 * @return {!Array<?>|!d3.geo.Projection}
 */
d3.geo.Projection.prototype.center = function(location) {};

/**
 * @param {!Array<?>=} point
 * @return {!Array<?>|!d3.geo.Projection}
 */
d3.geo.Projection.prototype.translate = function(point) {};

/**
 * @param {number=} scale
 * @return {number|!d3.geo.Projection}
 */
d3.geo.Projection.prototype.scale = function(scale) {};

/**
 * @param {number=} angle
 * @return {number|!d3.geo.Projection}
 */
d3.geo.Projection.prototype.clipAngle = function(angle) {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.geo.Projection}
 */
d3.geo.Projection.prototype.clipExtent = function(extent) {};

/**
 * @param {number=} precision
 * @return {number|!d3.geo.Projection}
 */
d3.geo.Projection.prototype.precision = function(precision) {};

/**
 * @param {!d3.geo.Listener} listener
 * @return {!d3.geo.Listener}
 */
d3.geo.Projection.prototype.stream = function(listener) {};
/**
 * @extends {d3.geo.Projection}
 * @record
 * @struct
 */
d3.geo.InvertibleProjection = function() {};

/**
 * @param {!Array<?>} point
 * @return {!Array<?>}
 */
d3.geo.InvertibleProjection.prototype.invert = function(point) {};
/**
 * @extends {d3.geo.InvertibleProjection}
 * @record
 * @struct
 */
d3.geo.ConicProjection = function() {};

/**
 * @param {!Array<?>=} parallels
 * @return {!Array<?>|!d3.geo.ConicProjection}
 */
d3.geo.ConicProjection.prototype.parallels = function(parallels) {};

/**
 * @param {!Array<?>=} rotation
 * @return {!Array<?>|!d3.geo.ConicProjection}
 */
d3.geo.ConicProjection.prototype.rotate = function(rotation) {};

/**
 * @param {!Array<?>=} location
 * @return {!Array<?>|!d3.geo.ConicProjection}
 */
d3.geo.ConicProjection.prototype.center = function(location) {};

/**
 * @param {!Array<?>=} point
 * @return {!Array<?>|!d3.geo.ConicProjection}
 */
d3.geo.ConicProjection.prototype.translate = function(point) {};

/**
 * @param {number=} scale
 * @return {number|!d3.geo.ConicProjection}
 */
d3.geo.ConicProjection.prototype.scale = function(scale) {};

/**
 * @param {number=} angle
 * @return {number|!d3.geo.ConicProjection}
 */
d3.geo.ConicProjection.prototype.clipAngle = function(angle) {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.geo.ConicProjection}
 */
d3.geo.ConicProjection.prototype.clipExtent = function(extent) {};

/**
 * @param {number=} precision
 * @return {number|!d3.geo.ConicProjection}
 */
d3.geo.ConicProjection.prototype.precision = function(precision) {};
/**
 * @record
 * @struct
 */
d3.geo.RawProjection = function() {};

/* TODO: CallSignature: d3.geo */
/**
 * @extends {d3.geo.RawProjection}
 * @record
 * @struct
 */
d3.geo.RawInvertibleProjection = function() {};

/**
 * @param {number} x
 * @param {number} y
 * @return {!Array<?>}
 */
d3.geo.RawInvertibleProjection.prototype.invert = function(x, y) {};
/** @const */
d3.svg = {};

/**
 * @template T
 * @return {!d3.svg.Line<!Array<?>>|!d3.svg.Line<T>}
 */
d3.svg.line = function() {};
/**
 * @record
 * @struct
 */
d3.svg.Line = function() {};

/* TODO: CallSignature: d3.svg */

/**
 * @param {number|function(T, number): number=} x
 * @return {(number|function(T, number): number)|!d3.svg.Line}
 */
d3.svg.Line.prototype.x = function(x) {};

/**
 * @param {number|function(T, number): number=} x_or_y
 * @return {(number|function(T, number): number)|!d3.svg.Line}
 */
d3.svg.Line.prototype.y = function(x_or_y) {};

/**
 * @param {string|(string|function(!Array<!Array<?>>): string)=} interpolate
 * @return {(string|function(!Array<!Array<?>>): string)|!d3.svg.Line}
 */
d3.svg.Line.prototype.interpolate = function(interpolate) {};

/**
 * @param {number=} tension
 * @return {number|!d3.svg.Line}
 */
d3.svg.Line.prototype.tension = function(tension) {};

/**
 * @param {function(T, number): boolean=} defined
 * @return {function(T, number): boolean|!d3.svg.Line}
 */
d3.svg.Line.prototype.defined = function(defined) {};

/**
 * @template T
 * @return {!d3.svg.line.Radial<!Array<?>>|!d3.svg.line.Radial<T>}
 */
d3.svg.line.radial = function() {};
/**
 * @record
 * @struct
 */
d3.svg.line.Radial = function() {};

/* TODO: CallSignature: d3.svg.line */

/**
 * @param {number|function(T, number): number=} radius
 * @return {(number|function(T, number): number)|!d3.svg.line.Radial}
 */
d3.svg.line.Radial.prototype.radius = function(radius) {};

/**
 * @param {number|function(T, number): number=} angle
 * @return {(number|function(T, number): number)|!d3.svg.line.Radial}
 */
d3.svg.line.Radial.prototype.angle = function(angle) {};

/**
 * @param {string|(string|function(!Array<!Array<?>>): string)=} interpolate
 * @return {(string|function(!Array<!Array<?>>): string)|!d3.svg.line.Radial}
 */
d3.svg.line.Radial.prototype.interpolate = function(interpolate) {};

/**
 * @param {number=} tension
 * @return {number|!d3.svg.line.Radial}
 */
d3.svg.line.Radial.prototype.tension = function(tension) {};

/**
 * @param {function(T, number): boolean=} defined
 * @return {function(T, number): boolean|!d3.svg.line.Radial}
 */
d3.svg.line.Radial.prototype.defined = function(defined) {};

/**
 * @template T
 * @return {!d3.svg.Area<!Array<?>>|!d3.svg.Area<T>}
 */
d3.svg.area = function() {};
/**
 * @record
 * @struct
 */
d3.svg.Area = function() {};

/* TODO: CallSignature: d3.svg */

/**
 * @param {number|function(T, number): number=} x
 * @return {(number|function(T, number): number)|!d3.svg.Area}
 */
d3.svg.Area.prototype.x = function(x) {};

/**
 * @param {number|function(T, number): number=} x0
 * @return {(number|function(T, number): number)|!d3.svg.Area}
 */
d3.svg.Area.prototype.x0 = function(x0) {};

/**
 * @param {number|function(T, number): number=} x1
 * @return {(number|function(T, number): number)|!d3.svg.Area}
 */
d3.svg.Area.prototype.x1 = function(x1) {};

/**
 * @param {number|function(T, number): number=} y
 * @return {(number|function(T, number): number)|!d3.svg.Area}
 */
d3.svg.Area.prototype.y = function(y) {};

/**
 * @param {number|function(T, number): number=} y0
 * @return {(number|function(T, number): number)|!d3.svg.Area}
 */
d3.svg.Area.prototype.y0 = function(y0) {};

/**
 * @param {number|function(T, number): number=} y1
 * @return {(number|function(T, number): number)|!d3.svg.Area}
 */
d3.svg.Area.prototype.y1 = function(y1) {};

/**
 * @param {string|(string|function(!Array<!Array<?>>): string)=} interpolate
 * @return {(string|function(!Array<!Array<?>>): string)|!d3.svg.Area}
 */
d3.svg.Area.prototype.interpolate = function(interpolate) {};

/**
 * @param {number=} tension
 * @return {number|!d3.svg.Area}
 */
d3.svg.Area.prototype.tension = function(tension) {};

/**
 * @param {function(T, number): boolean=} defined
 * @return {function(T, number): boolean|!d3.svg.Area}
 */
d3.svg.Area.prototype.defined = function(defined) {};

/**
 * @template T
 * @return {!d3.svg.area.Radial<!Array<?>>|!d3.svg.area.Radial<T>}
 */
d3.svg.area.radial = function() {};
/**
 * @record
 * @struct
 */
d3.svg.area.Radial = function() {};

/* TODO: CallSignature: d3.svg.area */

/**
 * @param {number|function(T, number): number=} radius
 * @return {(number|function(T, number): number)|!d3.svg.area.Radial}
 */
d3.svg.area.Radial.prototype.radius = function(radius) {};

/**
 * @param {number|function(T, number): number=} innerRadius
 * @return {(number|function(T, number): number)|!d3.svg.area.Radial}
 */
d3.svg.area.Radial.prototype.innerRadius = function(innerRadius) {};

/**
 * @param {number|function(T, number): number=} outerRadius
 * @return {(number|function(T, number): number)|!d3.svg.area.Radial}
 */
d3.svg.area.Radial.prototype.outerRadius = function(outerRadius) {};

/**
 * @param {number|function(T, number): number=} angle
 * @return {(number|function(T, number): number)|!d3.svg.area.Radial}
 */
d3.svg.area.Radial.prototype.angle = function(angle) {};

/**
 * @param {number|function(T, number): number=} startAngle
 * @return {(number|function(T, number): number)|!d3.svg.area.Radial}
 */
d3.svg.area.Radial.prototype.startAngle = function(startAngle) {};

/**
 * @param {number|function(T, number): number=} endAngle
 * @return {(number|function(T, number): number)|!d3.svg.area.Radial}
 */
d3.svg.area.Radial.prototype.endAngle = function(endAngle) {};

/**
 * @param {string|(string|function(!Array<!Array<?>>): string)=} interpolate
 * @return {(string|function(!Array<!Array<?>>): string)|!d3.svg.area.Radial}
 */
d3.svg.area.Radial.prototype.interpolate = function(interpolate) {};

/**
 * @param {number=} tension
 * @return {number|!d3.svg.area.Radial}
 */
d3.svg.area.Radial.prototype.tension = function(tension) {};

/**
 * @param {function(T, number): boolean=} defined
 * @return {function(T, number): boolean|!d3.svg.area.Radial}
 */
d3.svg.area.Radial.prototype.defined = function(defined) {};

/**
 * @template T
 * @return {!d3.svg.Arc<!d3.svg.arc.Arc>|!d3.svg.Arc<T>}
 */
d3.svg.arc = function() {};
/**
 * @record
 * @struct
 */
d3.svg.arc.Arc = function() {};
 /** @type {number} */
d3.svg.arc.Arc.prototype.innerRadius;
 /** @type {number} */
d3.svg.arc.Arc.prototype.outerRadius;
 /** @type {number} */
d3.svg.arc.Arc.prototype.startAngle;
 /** @type {number} */
d3.svg.arc.Arc.prototype.endAngle;
 /** @type {number} */
d3.svg.arc.Arc.prototype.padAngle;
/**
 * @record
 * @struct
 */
d3.svg.Arc = function() {};

/* TODO: CallSignature: d3.svg */

/**
 * @param {number|function(T, number): number=} radius
 * @return {function(T, number): number|!d3.svg.Arc}
 */
d3.svg.Arc.prototype.innerRadius = function(radius) {};

/**
 * @param {number|function(T, number): number=} radius
 * @return {function(T, number): number|!d3.svg.Arc}
 */
d3.svg.Arc.prototype.outerRadius = function(radius) {};

/**
 * @param {number|function(T, number): number=} radius
 * @return {function(T, number): number|!d3.svg.Arc}
 */
d3.svg.Arc.prototype.cornerRadius = function(radius) {};

/**
 * @param {string|function(T, number): number=} radius
 * @return {(string|function(T, number): number)|!d3.svg.Arc}
 */
d3.svg.Arc.prototype.padRadius = function(radius) {};

/**
 * @param {number|function(T, number): number=} angle
 * @return {function(T, number): number|!d3.svg.Arc}
 */
d3.svg.Arc.prototype.startAngle = function(angle) {};

/**
 * @param {number|function(T, number): number=} angle
 * @return {function(T, number): number|!d3.svg.Arc}
 */
d3.svg.Arc.prototype.endAngle = function(angle) {};

/**
 * @param {number|function(T, number): number=} angle
 * @return {function(T, number): number|!d3.svg.Arc}
 */
d3.svg.Arc.prototype.padAngle = function(angle) {};

/**
 * @param {T} d
 * @param {number=} i
 * @return {!Array<?>}
 */
d3.svg.Arc.prototype.centroid = function(d, i) {};

/**
 * @template T
 * @return {!d3.svg.Symbol<!Object>|!d3.svg.Symbol<T>}
 */
d3.svg.symbol = function() {};
/**
 * @record
 * @struct
 */
d3.svg.Symbol = function() {};

/* TODO: CallSignature: d3.svg */

/**
 * @param {string|function(T, number): string=} type
 * @return {function(T, number): string|!d3.svg.Symbol}
 */
d3.svg.Symbol.prototype.type = function(type) {};

/**
 * @param {number|function(T, number): number=} size
 * @return {function(T, string): number|!d3.svg.Symbol}
 */
d3.svg.Symbol.prototype.size = function(size) {};
 /** @type {!Array<string>} */
d3.svg.symbolTypes;

/**
 * @template Node, Link
 * @return {!d3.svg.Chord<!d3.svg.chord.Link<!d3.svg.chord.Node>, !d3.svg.chord.Node>|!d3.svg.Chord<!d3.svg.chord.Link<Node>, Node>|!d3.svg.Chord<Link, Node>}
 */
d3.svg.chord = function() {};
/**
 * @record
 * @struct
 */
d3.svg.chord.Link = function() {};
 /** @type {Node} */
d3.svg.chord.Link.prototype.source;
 /** @type {Node} */
d3.svg.chord.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.svg.chord.Node = function() {};
 /** @type {number} */
d3.svg.chord.Node.prototype.radius;
 /** @type {number} */
d3.svg.chord.Node.prototype.startAngle;
 /** @type {number} */
d3.svg.chord.Node.prototype.endAngle;
/**
 * @record
 * @struct
 */
d3.svg.Chord = function() {};

/* TODO: CallSignature: d3.svg */

/**
 * @param {Node|function(Link, number): Node=} source
 * @return {function(Link, number): Node|!d3.svg.Chord}
 */
d3.svg.Chord.prototype.source = function(source) {};

/**
 * @param {Node|function(Link, number): Node=} target
 * @return {function(Link, number): Node|!d3.svg.Chord}
 */
d3.svg.Chord.prototype.target = function(target) {};

/**
 * @param {number|function(Node, number): number=} radius
 * @return {function(Node, number): number|!d3.svg.Chord}
 */
d3.svg.Chord.prototype.radius = function(radius) {};

/**
 * @param {number|function(Node, number): number=} angle
 * @return {function(Node, number): number|!d3.svg.Chord}
 */
d3.svg.Chord.prototype.startAngle = function(angle) {};

/**
 * @param {number|function(Node, number): number=} angle
 * @return {function(Node, number): number|!d3.svg.Chord}
 */
d3.svg.Chord.prototype.endAngle = function(angle) {};

/**
 * @template Node, Link
 * @return {!d3.svg.Diagonal<!d3.svg.diagonal.Link<!d3.svg.diagonal.Node>, !d3.svg.diagonal.Node>|!d3.svg.Diagonal<!d3.svg.diagonal.Link<Node>, Node>|!d3.svg.Diagonal<Link, Node>}
 */
d3.svg.diagonal = function() {};
/**
 * @record
 * @struct
 */
d3.svg.diagonal.Link = function() {};
 /** @type {Node} */
d3.svg.diagonal.Link.prototype.source;
 /** @type {Node} */
d3.svg.diagonal.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.svg.diagonal.Node = function() {};
 /** @type {number} */
d3.svg.diagonal.Node.prototype.x;
 /** @type {number} */
d3.svg.diagonal.Node.prototype.y;
/**
 * @record
 * @struct
 */
d3.svg.Diagonal = function() {};

/* TODO: CallSignature: d3.svg */

/**
 * @param {Node|function(Link, number): {x: number, y: number}=} source
 * @return {function(Link, number): Node|!d3.svg.Diagonal}
 */
d3.svg.Diagonal.prototype.source = function(source) {};

/**
 * @param {Node|function(Link, number): {x: number, y: number}=} target
 * @return {function(Link, number): Node|!d3.svg.Diagonal}
 */
d3.svg.Diagonal.prototype.target = function(target) {};

/**
 * @param {function(Node, number): !Array<?>=} projection
 * @return {function(Node, number): !Array<?>|!d3.svg.Diagonal}
 */
d3.svg.Diagonal.prototype.projection = function(projection) {};

/**
 * @template Node, Link
 * @return {!d3.svg.diagonal.Radial<!d3.svg.diagonal.Link<!d3.svg.diagonal.Node>, !d3.svg.diagonal.Node>|!d3.svg.diagonal.Radial<!d3.svg.diagonal.Link<Node>, Node>|!d3.svg.diagonal.Radial<Link, Node>}
 */
d3.svg.diagonal.radial = function() {};
/**
 * @record
 * @struct
 */
d3.svg.diagonal.Radial = function() {};

/* TODO: CallSignature: d3.svg.diagonal */

/**
 * @param {Node|function(Link, number): Node=} source
 * @return {function(Link, number): Node|!d3.svg.diagonal.Radial}
 */
d3.svg.diagonal.Radial.prototype.source = function(source) {};

/**
 * @param {Node|function(Link, number): Node=} target
 * @return {function(Link, number): Node|!d3.svg.diagonal.Radial}
 */
d3.svg.diagonal.Radial.prototype.target = function(target) {};

/**
 * @param {function(Node, number): !Array<?>=} projection
 * @return {function(Node, number): !Array<?>|!d3.svg.diagonal.Radial}
 */
d3.svg.diagonal.Radial.prototype.projection = function(projection) {};

/**
 * @return {!d3.svg.Axis}
 */
d3.svg.axis = function() {};
/**
 * @record
 * @struct
 */
d3.svg.Axis = function() {};

/* TODO: CallSignature: d3.svg */

/* TODO: CallSignature: d3.svg */

/**
 * @param {?=} scale
 * @return {?|!d3.svg.Axis}
 */
d3.svg.Axis.prototype.scale = function(scale) {};

/**
 * @param {string=} orientation
 * @return {string|!d3.svg.Axis}
 */
d3.svg.Axis.prototype.orient = function(orientation) {};

/**
 * @param {...?} args
 * @return {!Array<?>|!d3.svg.Axis}
 */
d3.svg.Axis.prototype.ticks = function(args) {};

/**
 * @param {!Array<?>=} values
 * @return {!Array<?>|!d3.svg.Axis}
 */
d3.svg.Axis.prototype.tickValues = function(values) {};

/**
 * @param {number=} size_or_inner
 * @param {number=} outer
 * @return {number|!d3.svg.Axis}
 */
d3.svg.Axis.prototype.tickSize = function(size_or_inner, outer) {};

/**
 * @param {number=} size
 * @return {number|!d3.svg.Axis}
 */
d3.svg.Axis.prototype.innerTickSize = function(size) {};

/**
 * @param {number=} size
 * @return {number|!d3.svg.Axis}
 */
d3.svg.Axis.prototype.outerTickSize = function(size) {};

/**
 * @param {number=} padding
 * @return {number|!d3.svg.Axis}
 */
d3.svg.Axis.prototype.tickPadding = function(padding) {};

/**
 * @param {function(?): string|string=} format
 * @return {function(?): string|!d3.svg.Axis}
 */
d3.svg.Axis.prototype.tickFormat = function(format) {};

/**
 * @template T
 * @return {!d3.svg.Brush<?>|!d3.svg.Brush<T>}
 */
d3.svg.brush = function() {};
/**
 * @record
 * @struct
 */
d3.svg.brush.Scale = function() {};

/**
 * @param {!Array<number>=} domain
 * @return {!Array<number>|!d3.svg.brush.Scale}
 */
d3.svg.brush.Scale.prototype.domain = function(domain) {};

/**
 * @param {!Array<number>=} range
 * @return {!Array<number>|!d3.svg.brush.Scale}
 */
d3.svg.brush.Scale.prototype.range = function(range) {};

/**
 * @param {number} y
 * @return {number}
 */
d3.svg.brush.Scale.prototype.invert = function(y) {};
/**
 * @record
 * @struct
 */
d3.svg.Brush = function() {};

/* TODO: CallSignature: d3.svg */

/* TODO: CallSignature: d3.svg */

/**
 * @param {!d3.Selection<T>|!d3.Transition<T>} selection
 * @return {void}
 */
d3.svg.Brush.prototype.event = function(selection) {};

/**
 * @param {!d3.svg.brush.Scale=} x
 * @return {!d3.svg.brush.Scale|!d3.svg.Brush}
 */
d3.svg.Brush.prototype.x = function(x) {};

/**
 * @param {!d3.svg.brush.Scale=} y
 * @return {!d3.svg.brush.Scale|!d3.svg.Brush}
 */
d3.svg.Brush.prototype.y = function(y) {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.svg.Brush}
 */
d3.svg.Brush.prototype.extent = function(extent) {};

/**
 * @param {(boolean|!Array<?>)=} clamp
 * @return {(boolean|!Array<?>)|!d3.svg.Brush}
 */
d3.svg.Brush.prototype.clamp = function(clamp) {};

/**
 * @return {void}
 */
d3.svg.Brush.prototype.clear = function() {};

/**
 * @return {boolean}
 */
d3.svg.Brush.prototype.empty = function() {};

/**
 * @param {string} type
 * @param {function(T, number): void=} listener
 * @return {function(T, number): void|!d3.svg.Brush}
 */
d3.svg.Brush.prototype.on = function(type, listener) {};

/**
 * @param {string} url
 * @param {string|function(?, ?): void=} mimeType_or_callback
 * @param {function(?, ?): void=} callback
 * @return {!d3.Xhr}
 */
d3.xhr = function(url, mimeType_or_callback, callback) {};
/**
 * @record
 * @struct
 */
d3.Xhr = function() {};

/**
 * @param {string} name
 * @param {string=} value
 * @return {string|!d3.Xhr}
 */
d3.Xhr.prototype.header = function(name, value) {};

/**
 * @param {string=} type
 * @return {string|!d3.Xhr}
 */
d3.Xhr.prototype.mimeType = function(type) {};

/**
 * @param {string=} type
 * @return {string|!d3.Xhr}
 */
d3.Xhr.prototype.responseType = function(type) {};

/**
 * @param {function(!XMLHttpRequest): ?=} value
 * @return {function(!XMLHttpRequest): ?|!d3.Xhr}
 */
d3.Xhr.prototype.response = function(value) {};

/**
 * @param {function(?, ?): void=} callback
 * @return {!d3.Xhr}
 */
d3.Xhr.prototype.get = function(callback) {};

/**
 * @param {?|function(?, ?): void=} data_or_callback
 * @param {function(?, ?): void=} callback
 * @return {!d3.Xhr}
 */
d3.Xhr.prototype.post = function(data_or_callback, callback) {};

/**
 * @param {string} method
 * @param {?|function(?, ?): void=} data_or_callback
 * @param {function(?, ?): void=} callback
 * @return {!d3.Xhr}
 */
d3.Xhr.prototype.send = function(method, data_or_callback, callback) {};

/**
 * @return {!d3.Xhr}
 */
d3.Xhr.prototype.abort = function() {};

/**
 * @param {string} type
 * @param {function(!XMLHttpRequest): void|function(?): void|function(!Array<?>): void=} listener
 * @return {function(!XMLHttpRequest): void|function(?): void|function(!Array<?>): void|!d3.Xhr}
 */
d3.Xhr.prototype.on = function(type, listener) {};

/**
 * @param {string} url
 * @param {string|function(?, string): void=} mimeType_or_callback
 * @param {function(?, string): void=} callback
 * @return {!d3.Xhr}
 */
d3.text = function(url, mimeType_or_callback, callback) {};

/**
 * @param {string} url
 * @param {function(?, ?): void=} callback
 * @return {!d3.Xhr}
 */
d3.json = function(url, callback) {};

/**
 * @param {string} url
 * @param {string|function(?, ?): void=} mimeType_or_callback
 * @param {function(?, ?): void=} callback
 * @return {!d3.Xhr}
 */
d3.xml = function(url, mimeType_or_callback, callback) {};

/**
 * @param {string} url
 * @param {function(?, !DocumentFragment): void=} callback
 * @return {!d3.Xhr}
 */
d3.html = function(url, callback) {};
 /** @type {!d3.Dsv} */
d3.csv;
 /** @type {!d3.Dsv} */
d3.tsv;

/**
 * @param {string} delimiter
 * @param {string} mimeType
 * @return {!d3.Dsv}
 */
d3.dsv = function(delimiter, mimeType) {};
/**
 * @record
 * @struct
 */
d3.Dsv = function() {};

/* TODO: CallSignature: d3 */

/* TODO: CallSignature: d3 */

/* TODO: CallSignature: d3 */

/* TODO: CallSignature: d3 */

/* TODO: CallSignature: d3 */

/* TODO: CallSignature: d3 */

/**
 * @template T
 * @param {string} string
 * @param {function(!Object<string,string>, number): T=} accessor
 * @return {!Array<!Object<string,string>>|!Array<T>}
 */
d3.Dsv.prototype.parse = function(string, accessor) {};

/**
 * @template T
 * @param {string} string
 * @param {function(!Array<string>, number): T=} accessor
 * @return {!Array<!Array<string>>|!Array<T>}
 */
d3.Dsv.prototype.parseRows = function(string, accessor) {};

/**
 * @param {!Array<!Object>} rows
 * @return {string}
 */
d3.Dsv.prototype.format = function(rows) {};

/**
 * @param {!Array<!Array<string>>} rows
 * @return {string}
 */
d3.Dsv.prototype.formatRows = function(rows) {};
/**
 * @extends {d3.Xhr}
 * @record
 * @struct
 */
d3.DsvXhr = function() {};

/**
 * @template U
 * @param {function(!Object<string,string>): U=} accessor
 * @return {function(!Object<string,string>): T|!d3.DsvXhr<U>}
 */
d3.DsvXhr.prototype.row = function(accessor) {};

/**
 * @param {string} name
 * @param {string=} value
 * @return {string|!d3.DsvXhr}
 */
d3.DsvXhr.prototype.header = function(name, value) {};

/**
 * @param {string=} type
 * @return {string|!d3.DsvXhr}
 */
d3.DsvXhr.prototype.mimeType = function(type) {};

/**
 * @param {string=} type
 * @return {string|!d3.DsvXhr}
 */
d3.DsvXhr.prototype.responseType = function(type) {};

/**
 * @param {function(!XMLHttpRequest): ?=} value
 * @return {function(!XMLHttpRequest): ?|!d3.DsvXhr}
 */
d3.DsvXhr.prototype.response = function(value) {};

/**
 * @param {function(!XMLHttpRequest, !Array<T>): void=} callback
 * @return {!d3.DsvXhr}
 */
d3.DsvXhr.prototype.get = function(callback) {};

/**
 * @param {?|function(!XMLHttpRequest, !Array<T>): void=} data_or_callback
 * @param {function(!XMLHttpRequest, !Array<T>): void=} callback
 * @return {!d3.DsvXhr}
 */
d3.DsvXhr.prototype.post = function(data_or_callback, callback) {};

/**
 * @param {string} method
 * @param {?|function(!XMLHttpRequest, !Array<T>): void=} data_or_callback
 * @param {function(!XMLHttpRequest, !Array<T>): void=} callback
 * @return {!d3.DsvXhr}
 */
d3.DsvXhr.prototype.send = function(method, data_or_callback, callback) {};

/**
 * @return {!d3.DsvXhr}
 */
d3.DsvXhr.prototype.abort = function() {};

/**
 * @param {string} type
 * @param {function(!XMLHttpRequest): void|function(!Array<T>): void|function(?): void|function(!Array<?>): void=} listener
 * @return {function(!XMLHttpRequest): void|function(!Array<T>): void|function(?): void|function(!Array<?>): void|!d3.DsvXhr}
 */
d3.DsvXhr.prototype.on = function(type, listener) {};

/**
 * @param {!d3.LocaleDefinition} definition
 * @return {!d3.Locale}
 */
d3.locale = function(definition) {};
/**
 * @record
 * @struct
 */
d3.LocaleDefinition = function() {};
 /** @type {string} */
d3.LocaleDefinition.prototype.decimal;
 /** @type {string} */
d3.LocaleDefinition.prototype.thousands;
 /** @type {!Array<number>} */
d3.LocaleDefinition.prototype.grouping;
 /** @type {!Array<?>} */
d3.LocaleDefinition.prototype.currency;
 /** @type {string} */
d3.LocaleDefinition.prototype.dateTime;
 /** @type {string} */
d3.LocaleDefinition.prototype.date;
 /** @type {string} */
d3.LocaleDefinition.prototype.time;
 /** @type {!Array<?>} */
d3.LocaleDefinition.prototype.periods;
 /** @type {!Array<?>} */
d3.LocaleDefinition.prototype.days;
 /** @type {!Array<?>} */
d3.LocaleDefinition.prototype.shortDays;
 /** @type {!Array<?>} */
d3.LocaleDefinition.prototype.months;
 /** @type {!Array<?>} */
d3.LocaleDefinition.prototype.shortMonths;
/**
 * @record
 * @struct
 */
d3.Locale = function() {};
 /** @type {?} */
d3.Locale.prototype.timeFormat;

/**
 * @param {string} specifier
 * @return {function(number): string}
 */
d3.Locale.prototype.numberFormat = function(specifier) {};
/** @const */
d3.layout = {};

/**
 * @template T
 * @return {!d3.layout.Bundle<!d3.layout.bundle.Node>|!d3.layout.Bundle<T>}
 */
d3.layout.bundle = function() {};
/**
 * @record
 * @struct
 */
d3.layout.bundle.Node = function() {};
 /** @type {!d3.layout.bundle.Node} */
d3.layout.bundle.Node.prototype.parent;
/**
 * @record
 * @struct
 */
d3.layout.bundle.Link = function() {};
 /** @type {T} */
d3.layout.bundle.Link.prototype.source;
 /** @type {T} */
d3.layout.bundle.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.layout.Bundle = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @return {!d3.layout.Chord}
 */
d3.layout.chord = function() {};
/**
 * @record
 * @struct
 */
d3.layout.chord.Link = function() {};
 /** @type {!d3.layout.chord.Node} */
d3.layout.chord.Link.prototype.source;
 /** @type {!d3.layout.chord.Node} */
d3.layout.chord.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.layout.chord.Node = function() {};
 /** @type {number} */
d3.layout.chord.Node.prototype.index;
 /** @type {number} */
d3.layout.chord.Node.prototype.subindex;
 /** @type {number} */
d3.layout.chord.Node.prototype.startAngle;
 /** @type {number} */
d3.layout.chord.Node.prototype.endAngle;
 /** @type {number} */
d3.layout.chord.Node.prototype.value;
/**
 * @record
 * @struct
 */
d3.layout.chord.Group = function() {};
 /** @type {number} */
d3.layout.chord.Group.prototype.index;
 /** @type {number} */
d3.layout.chord.Group.prototype.startAngle;
 /** @type {number} */
d3.layout.chord.Group.prototype.endAngle;
 /** @type {number} */
d3.layout.chord.Group.prototype.value;
/**
 * @record
 * @struct
 */
d3.layout.Chord = function() {};

/**
 * @param {!Array<!Array<number>>=} matrix
 * @return {!Array<!Array<number>>|!d3.layout.Chord}
 */
d3.layout.Chord.prototype.matrix = function(matrix) {};

/**
 * @param {number=} padding
 * @return {number|!d3.layout.Chord}
 */
d3.layout.Chord.prototype.padding = function(padding) {};

/**
 * @param {function(number, number): number=} comparator
 * @return {function(number, number): number|!d3.layout.Chord}
 */
d3.layout.Chord.prototype.sortGroups = function(comparator) {};

/**
 * @param {function(number, number): number=} comparator
 * @return {function(number, number): number|!d3.layout.Chord}
 */
d3.layout.Chord.prototype.sortSubgroups = function(comparator) {};

/**
 * @param {function(number, number): number=} comparator
 * @return {function(number, number): number|!d3.layout.Chord}
 */
d3.layout.Chord.prototype.sortChords = function(comparator) {};

/**
 * @return {!Array<!d3.layout.chord.Link>}
 */
d3.layout.Chord.prototype.chords = function() {};

/**
 * @return {!Array<!d3.layout.chord.Group>}
 */
d3.layout.Chord.prototype.groups = function() {};

/**
 * @template T
 * @return {!d3.layout.Cluster<!d3.layout.cluster.Result>|!d3.layout.Cluster<T>}
 */
d3.layout.cluster = function() {};
/**
 * @record
 * @struct
 */
d3.layout.cluster.Result = function() {};
 /** @type {!d3.layout.cluster.Result} */
d3.layout.cluster.Result.prototype.parent;
 /** @type {!Array<!d3.layout.cluster.Result>} */
d3.layout.cluster.Result.prototype.children;
 /** @type {number} */
d3.layout.cluster.Result.prototype.depth;
 /** @type {number} */
d3.layout.cluster.Result.prototype.x;
 /** @type {number} */
d3.layout.cluster.Result.prototype.y;
/**
 * @record
 * @struct
 */
d3.layout.cluster.Link = function() {};
 /** @type {T} */
d3.layout.cluster.Link.prototype.source;
 /** @type {T} */
d3.layout.cluster.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.layout.Cluster = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @param {T} root
 * @return {!Array<T>}
 */
d3.layout.Cluster.prototype.nodes = function(root) {};

/**
 * @param {!Array<T>} nodes
 * @return {!Array<!d3.layout.cluster.Link<T>>}
 */
d3.layout.Cluster.prototype.links = function(nodes) {};

/**
 * @param {function(T): !Array<T>=} accessor
 * @return {function(T): !Array<T>|!d3.layout.Cluster}
 */
d3.layout.Cluster.prototype.children = function(accessor) {};

/**
 * @param {function(T, T): number=} comparator
 * @return {function(T, T): number|!d3.layout.Cluster}
 */
d3.layout.Cluster.prototype.sort = function(comparator) {};

/**
 * @param {function(T, T): number=} separation
 * @return {function(T, T): number|!d3.layout.Cluster}
 */
d3.layout.Cluster.prototype.separation = function(separation) {};

/**
 * @param {!Array<?>=} size
 * @return {!Array<?>|!d3.layout.Cluster}
 */
d3.layout.Cluster.prototype.size = function(size) {};

/**
 * @param {!Array<?>=} nodeSize
 * @return {!Array<?>|!d3.layout.Cluster}
 */
d3.layout.Cluster.prototype.nodeSize = function(nodeSize) {};

/**
 * @param {function(T): number=} value
 * @return {function(T): number|!d3.layout.Cluster}
 */
d3.layout.Cluster.prototype.value = function(value) {};

/**
 * @template Node, Link
 * @return {!d3.layout.Force<!d3.layout.force.Link<!d3.layout.force.Node>, !d3.layout.force.Node>|!d3.layout.Force<!d3.layout.force.Link<Node>, Node>|!d3.layout.Force<Link, Node>}
 */
d3.layout.force = function() {};
/**
 * @record
 * @struct
 */
d3.layout.force.Link = function() {};
 /** @type {T} */
d3.layout.force.Link.prototype.source;
 /** @type {T} */
d3.layout.force.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.layout.force.Node = function() {};
 /** @type {number} */
d3.layout.force.Node.prototype.index;
 /** @type {number} */
d3.layout.force.Node.prototype.x;
 /** @type {number} */
d3.layout.force.Node.prototype.y;
 /** @type {number} */
d3.layout.force.Node.prototype.px;
 /** @type {number} */
d3.layout.force.Node.prototype.py;
 /** @type {boolean} */
d3.layout.force.Node.prototype.fixed;
 /** @type {number} */
d3.layout.force.Node.prototype.weight;
/**
 * @record
 * @struct
 */
d3.layout.force.Event = function() {};
 /** @type {string} */
d3.layout.force.Event.prototype.type;
 /** @type {number} */
d3.layout.force.Event.prototype.alpha;
/**
 * @record
 * @struct
 */
d3.layout.Force = function() {};

/**
 * @param {!Array<?>=} size
 * @return {!Array<?>|!d3.layout.Force}
 */
d3.layout.Force.prototype.size = function(size) {};

/**
 * @param {number|function(Link, number): number=} distance
 * @return {(number|function(Link, number): number)|!d3.layout.Force}
 */
d3.layout.Force.prototype.linkDistance = function(distance) {};

/**
 * @param {number|function(Link, number): number=} strength
 * @return {(number|function(Link, number): number)|!d3.layout.Force}
 */
d3.layout.Force.prototype.linkStrength = function(strength) {};

/**
 * @param {number=} friction
 * @return {number|!d3.layout.Force}
 */
d3.layout.Force.prototype.friction = function(friction) {};

/**
 * @param {number|function(Node, number): number=} charge
 * @return {(number|function(Node, number): number)|!d3.layout.Force}
 */
d3.layout.Force.prototype.charge = function(charge) {};

/**
 * @param {number=} distance
 * @return {number|!d3.layout.Force}
 */
d3.layout.Force.prototype.chargeDistance = function(distance) {};

/**
 * @param {number=} theta
 * @return {number|!d3.layout.Force}
 */
d3.layout.Force.prototype.theta = function(theta) {};

/**
 * @param {number=} gravity
 * @return {number|!d3.layout.Force}
 */
d3.layout.Force.prototype.gravity = function(gravity) {};

/**
 * @param {!Array<Node>=} nodes
 * @return {!Array<Node>|!d3.layout.Force}
 */
d3.layout.Force.prototype.nodes = function(nodes) {};

/**
 * @param {!Array<{source: number, target: number}>|!Array<Link>=} links
 * @return {!Array<Link>|!d3.layout.Force}
 */
d3.layout.Force.prototype.links = function(links) {};

/**
 * @return {!d3.layout.Force}
 */
d3.layout.Force.prototype.start = function() {};

/**
 * @return {!d3.layout.Force}
 */
d3.layout.Force.prototype.tick = function() {};

/**
 * @param {number=} value
 * @return {number|!d3.layout.Force}
 */
d3.layout.Force.prototype.alpha = function(value) {};

/**
 * @return {!d3.layout.Force}
 */
d3.layout.Force.prototype.resume = function() {};

/**
 * @return {!d3.layout.Force}
 */
d3.layout.Force.prototype.stop = function() {};

/**
 * @param {string} type
 * @param {function(!d3.layout.force.Event): void=} listener
 * @return {function(!d3.layout.force.Event): void|!d3.layout.Force}
 */
d3.layout.Force.prototype.on = function(type, listener) {};

/**
 * @param {!d3.Selection<Node>=} selection
 * @return {!d3.behavior.Drag<Node>|void}
 */
d3.layout.Force.prototype.drag = function(selection) {};

/**
 * @template T
 * @return {!d3.layout.Hierarchy<!d3.layout.hierarchy.Result>|!d3.layout.Hierarchy<T>}
 */
d3.layout.hierarchy = function() {};
/**
 * @record
 * @struct
 */
d3.layout.hierarchy.Result = function() {};
 /** @type {!d3.layout.hierarchy.Result} */
d3.layout.hierarchy.Result.prototype.parent;
 /** @type {!Array<!d3.layout.hierarchy.Result>} */
d3.layout.hierarchy.Result.prototype.children;
 /** @type {number} */
d3.layout.hierarchy.Result.prototype.value;
 /** @type {number} */
d3.layout.hierarchy.Result.prototype.depth;
/**
 * @record
 * @struct
 */
d3.layout.Hierarchy = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @param {function(T): !Array<T>=} accessor
 * @return {function(T): !Array<T>|!d3.layout.Hierarchy}
 */
d3.layout.Hierarchy.prototype.children = function(accessor) {};

/**
 * @param {function(T, T): number=} comparator
 * @return {function(T, T): number|!d3.layout.Hierarchy}
 */
d3.layout.Hierarchy.prototype.sort = function(comparator) {};

/**
 * @param {function(T): number=} accessor
 * @return {function(T): number|!d3.layout.Hierarchy}
 */
d3.layout.Hierarchy.prototype.value = function(accessor) {};

/**
 * @param {T} root
 * @return {!Array<T>}
 */
d3.layout.Hierarchy.prototype.revalue = function(root) {};

/**
 * @template T
 * @return {!d3.layout.Histogram<number>|!d3.layout.Histogram<T>}
 */
d3.layout.histogram = function() {};
/**
 * @record
 * @struct
 */
d3.layout.histogram.Bin = function() {};
 /** @type {number} */
d3.layout.histogram.Bin.prototype.x;
 /** @type {number} */
d3.layout.histogram.Bin.prototype.dx;
 /** @type {number} */
d3.layout.histogram.Bin.prototype.y;
/**
 * @record
 * @struct
 */
d3.layout.Histogram = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @param {function(T, number): number=} value
 * @return {function(T, number): number|!d3.layout.Histogram}
 */
d3.layout.Histogram.prototype.value = function(value) {};

/**
 * @param {function(!Array<T>, number): !Array<?>|!Array<?>=} range
 * @return {function(!Array<T>, number): !Array<?>|!d3.layout.Histogram}
 */
d3.layout.Histogram.prototype.range = function(range) {};

/**
 * @param {number|!Array<number>|function(!Array<?>, !Array<T>, number): !Array<number>=} count_or_thresholds_or_func
 * @return {function(!Array<?>, !Array<T>, number): !Array<number>|!d3.layout.Histogram}
 */
d3.layout.Histogram.prototype.bins = function(count_or_thresholds_or_func) {};

/**
 * @param {boolean=} frequency
 * @return {boolean|!d3.layout.Histogram}
 */
d3.layout.Histogram.prototype.frequency = function(frequency) {};

/**
 * @template T
 * @return {!d3.layout.Pack<!d3.layout.pack.Node>|!d3.layout.Pack<T>}
 */
d3.layout.pack = function() {};
/**
 * @record
 * @struct
 */
d3.layout.pack.Node = function() {};
 /** @type {!d3.layout.pack.Node} */
d3.layout.pack.Node.prototype.parent;
 /** @type {!Array<!d3.layout.pack.Node>} */
d3.layout.pack.Node.prototype.children;
 /** @type {number} */
d3.layout.pack.Node.prototype.value;
 /** @type {number} */
d3.layout.pack.Node.prototype.depth;
 /** @type {number} */
d3.layout.pack.Node.prototype.x;
 /** @type {number} */
d3.layout.pack.Node.prototype.y;
 /** @type {number} */
d3.layout.pack.Node.prototype.r;
/**
 * @record
 * @struct
 */
d3.layout.pack.Link = function() {};
 /** @type {!d3.layout.pack.Node} */
d3.layout.pack.Link.prototype.source;
 /** @type {!d3.layout.pack.Node} */
d3.layout.pack.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.layout.Pack = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @param {T} root
 * @return {!Array<T>}
 */
d3.layout.Pack.prototype.nodes = function(root) {};

/**
 * @param {!Array<T>} nodes
 * @return {!Array<!d3.layout.pack.Link<T>>}
 */
d3.layout.Pack.prototype.links = function(nodes) {};

/**
 * @param {function(T, number): !Array<T>=} children
 * @return {function(T, number): !Array<T>|!d3.layout.Pack}
 */
d3.layout.Pack.prototype.children = function(children) {};

/**
 * @param {function(T, T): number=} comparator
 * @return {function(T, T): number|!d3.layout.Pack}
 */
d3.layout.Pack.prototype.sort = function(comparator) {};

/**
 * @param {function(T): number=} value
 * @return {function(T): number|!d3.layout.Pack}
 */
d3.layout.Pack.prototype.value = function(value) {};

/**
 * @param {!Array<?>=} size
 * @return {!Array<?>|!d3.layout.Pack}
 */
d3.layout.Pack.prototype.size = function(size) {};

/**
 * @param {number|function(T): number=} radius
 * @return {(number|function(T): number)|!d3.layout.Pack}
 */
d3.layout.Pack.prototype.radius = function(radius) {};

/**
 * @param {number=} padding
 * @return {number|!d3.layout.Pack}
 */
d3.layout.Pack.prototype.padding = function(padding) {};

/**
 * @template T
 * @return {!d3.layout.Partition<!d3.layout.partition.Node>|!d3.layout.Partition<T>}
 */
d3.layout.partition = function() {};
/**
 * @record
 * @struct
 */
d3.layout.partition.Link = function() {};
 /** @type {T} */
d3.layout.partition.Link.prototype.source;
 /** @type {T} */
d3.layout.partition.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.layout.partition.Node = function() {};
 /** @type {!d3.layout.partition.Node} */
d3.layout.partition.Node.prototype.parent;
 /** @type {number} */
d3.layout.partition.Node.prototype.children;
 /** @type {number} */
d3.layout.partition.Node.prototype.value;
 /** @type {number} */
d3.layout.partition.Node.prototype.depth;
 /** @type {number} */
d3.layout.partition.Node.prototype.x;
 /** @type {number} */
d3.layout.partition.Node.prototype.y;
 /** @type {number} */
d3.layout.partition.Node.prototype.dx;
 /** @type {number} */
d3.layout.partition.Node.prototype.dy;
/**
 * @record
 * @struct
 */
d3.layout.Partition = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @param {T} root
 * @return {!Array<T>}
 */
d3.layout.Partition.prototype.nodes = function(root) {};

/**
 * @param {!Array<T>} nodes
 * @return {!Array<!d3.layout.partition.Link<T>>}
 */
d3.layout.Partition.prototype.links = function(nodes) {};

/**
 * @param {function(T, number): !Array<T>=} children
 * @return {function(T, number): !Array<T>|!d3.layout.Partition}
 */
d3.layout.Partition.prototype.children = function(children) {};

/**
 * @param {function(T, T): number=} comparator
 * @return {function(T, T): number|!d3.layout.Partition}
 */
d3.layout.Partition.prototype.sort = function(comparator) {};

/**
 * @param {function(T): number=} value
 * @return {function(T): number|!d3.layout.Partition}
 */
d3.layout.Partition.prototype.value = function(value) {};

/**
 * @param {!Array<?>=} size
 * @return {!Array<?>|!d3.layout.Partition}
 */
d3.layout.Partition.prototype.size = function(size) {};

/**
 * @template T
 * @return {!d3.layout.Pie<number>|!d3.layout.Pie<T>}
 */
d3.layout.pie = function() {};
/**
 * @record
 * @struct
 */
d3.layout.pie.Arc = function() {};
 /** @type {number} */
d3.layout.pie.Arc.prototype.value;
 /** @type {number} */
d3.layout.pie.Arc.prototype.startAngle;
 /** @type {number} */
d3.layout.pie.Arc.prototype.endAngle;
 /** @type {number} */
d3.layout.pie.Arc.prototype.padAngle;
 /** @type {T} */
d3.layout.pie.Arc.prototype.data;
/**
 * @record
 * @struct
 */
d3.layout.Pie = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @param {function(T, number): number=} accessor
 * @return {function(T, number): number|!d3.layout.Pie}
 */
d3.layout.Pie.prototype.value = function(accessor) {};

/**
 * @param {function(T, T): number=} comparator
 * @return {function(T, T): number|!d3.layout.Pie}
 */
d3.layout.Pie.prototype.sort = function(comparator) {};

/**
 * @param {number|function(!Array<T>, number): number=} angle
 * @return {(number|function(!Array<T>, number): number)|!d3.layout.Pie}
 */
d3.layout.Pie.prototype.startAngle = function(angle) {};

/**
 * @param {number|function(!Array<T>, number): number=} angle
 * @return {(number|function(!Array<T>, number): number)|!d3.layout.Pie}
 */
d3.layout.Pie.prototype.endAngle = function(angle) {};

/**
 * @param {number|function(!Array<T>, number): number=} angle
 * @return {(number|function(!Array<T>, number): number)|!d3.layout.Pie}
 */
d3.layout.Pie.prototype.padAngle = function(angle) {};

/**
 * @template Value, Series
 * @return {!d3.layout.Stack<!Array<!d3.layout.stack.Value>, !d3.layout.stack.Value>|!d3.layout.Stack<!Array<Value>, Value>|!d3.layout.Stack<Series, Value>}
 */
d3.layout.stack = function() {};
/**
 * @record
 * @struct
 */
d3.layout.stack.Value = function() {};
 /** @type {number} */
d3.layout.stack.Value.prototype.x;
 /** @type {number} */
d3.layout.stack.Value.prototype.y;
 /** @type {number} */
d3.layout.stack.Value.prototype.y0;
/**
 * @record
 * @struct
 */
d3.layout.Stack = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @param {function(Series, number): !Array<Value>=} accessor
 * @return {function(Series, number): !Array<Value>|!d3.layout.Stack}
 */
d3.layout.Stack.prototype.values = function(accessor) {};

/**
 * @param {string|function(!Array<!Array<?>>): !Array<number>=} offset
 * @return {function(!Array<!Array<?>>): !Array<number>|!d3.layout.Stack}
 */
d3.layout.Stack.prototype.offset = function(offset) {};

/**
 * @param {string|function(!Array<!Array<?>>): !Array<number>=} order
 * @return {function(!Array<!Array<?>>): !Array<number>|!d3.layout.Stack}
 */
d3.layout.Stack.prototype.order = function(order) {};

/**
 * @param {function(Value, number): number=} accessor
 * @return {function(Value, number): number|!d3.layout.Stack}
 */
d3.layout.Stack.prototype.x = function(accessor) {};

/**
 * @param {function(Value, number): number=} accesor
 * @return {function(Value, number): number|!d3.layout.Stack}
 */
d3.layout.Stack.prototype.y = function(accesor) {};

/**
 * @param {function(Value, number, number): void=} setter
 * @return {function(Value, number, number): void|!d3.layout.Stack}
 */
d3.layout.Stack.prototype.out = function(setter) {};

/**
 * @template T
 * @return {!d3.layout.Tree<!d3.layout.tree.Node>|!d3.layout.Tree<T>}
 */
d3.layout.tree = function() {};
/**
 * @record
 * @struct
 */
d3.layout.tree.Link = function() {};
 /** @type {T} */
d3.layout.tree.Link.prototype.source;
 /** @type {T} */
d3.layout.tree.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.layout.tree.Node = function() {};
 /** @type {!d3.layout.tree.Node} */
d3.layout.tree.Node.prototype.parent;
 /** @type {!Array<!d3.layout.tree.Node>} */
d3.layout.tree.Node.prototype.children;
 /** @type {number} */
d3.layout.tree.Node.prototype.depth;
 /** @type {number} */
d3.layout.tree.Node.prototype.x;
 /** @type {number} */
d3.layout.tree.Node.prototype.y;
/**
 * @record
 * @struct
 */
d3.layout.Tree = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @param {T} root
 * @param {number=} index
 * @return {!Array<T>}
 */
d3.layout.Tree.prototype.nodes = function(root, index) {};

/**
 * @param {!Array<T>} nodes
 * @return {!Array<!d3.layout.tree.Link<T>>}
 */
d3.layout.Tree.prototype.links = function(nodes) {};

/**
 * @param {function(T, number): !Array<T>=} children
 * @return {function(T, number): !Array<T>|!d3.layout.Tree}
 */
d3.layout.Tree.prototype.children = function(children) {};

/**
 * @param {function(T, T): number=} separation
 * @return {function(T, T): number|!d3.layout.Tree}
 */
d3.layout.Tree.prototype.separation = function(separation) {};

/**
 * @param {!Array<?>=} size
 * @return {!Array<?>|!d3.layout.Tree}
 */
d3.layout.Tree.prototype.size = function(size) {};

/**
 * @param {!Array<?>=} size
 * @return {!Array<?>|!d3.layout.Tree}
 */
d3.layout.Tree.prototype.nodeSize = function(size) {};

/**
 * @param {function(T, T): number=} comparator
 * @return {function(T, T): number|!d3.layout.Tree}
 */
d3.layout.Tree.prototype.sort = function(comparator) {};

/**
 * @param {function(T, number): number=} value
 * @return {function(T, number): number|!d3.layout.Tree}
 */
d3.layout.Tree.prototype.value = function(value) {};

/**
 * @template T
 * @return {!d3.layout.Treemap<!d3.layout.treemap.Node>|!d3.layout.Treemap<T>}
 */
d3.layout.treemap = function() {};
/**
 * @record
 * @struct
 */
d3.layout.treemap.Node = function() {};
 /** @type {!d3.layout.treemap.Node} */
d3.layout.treemap.Node.prototype.parent;
 /** @type {!Array<!d3.layout.treemap.Node>} */
d3.layout.treemap.Node.prototype.children;
 /** @type {number} */
d3.layout.treemap.Node.prototype.value;
 /** @type {number} */
d3.layout.treemap.Node.prototype.depth;
 /** @type {number} */
d3.layout.treemap.Node.prototype.x;
 /** @type {number} */
d3.layout.treemap.Node.prototype.y;
 /** @type {number} */
d3.layout.treemap.Node.prototype.dx;
 /** @type {number} */
d3.layout.treemap.Node.prototype.dy;
/**
 * @record
 * @struct
 */
d3.layout.treemap.Link = function() {};
 /** @type {T} */
d3.layout.treemap.Link.prototype.source;
 /** @type {T} */
d3.layout.treemap.Link.prototype.target;

/** @typedef {(number|!Array<?>)} */
d3.layout.treemap.Padding;
/**
 * @record
 * @struct
 */
d3.layout.Treemap = function() {};

/* TODO: CallSignature: d3.layout */

/**
 * @param {T} root
 * @param {number=} index
 * @return {!Array<T>}
 */
d3.layout.Treemap.prototype.nodes = function(root, index) {};

/**
 * @param {!Array<T>} nodes
 * @return {!Array<!d3.layout.treemap.Link<T>>}
 */
d3.layout.Treemap.prototype.links = function(nodes) {};

/**
 * @param {function(T, number): !Array<T>=} children
 * @return {function(T, number): !Array<T>|!d3.layout.Treemap}
 */
d3.layout.Treemap.prototype.children = function(children) {};

/**
 * @param {function(T, T): number=} comparator
 * @return {function(T, T): number|!d3.layout.Treemap}
 */
d3.layout.Treemap.prototype.sort = function(comparator) {};

/**
 * @param {function(T, number): number=} value
 * @return {function(T, number): number|!d3.layout.Treemap}
 */
d3.layout.Treemap.prototype.value = function(value) {};

/**
 * @param {!Array<?>=} size
 * @return {!Array<?>|!d3.layout.Treemap}
 */
d3.layout.Treemap.prototype.size = function(size) {};

/**
 * @param {(number|!Array<?>)|function(T, number): (number|!Array<?>)=} padding
 * @return {function(T, number): (number|!Array<?>)|!d3.layout.Treemap}
 */
d3.layout.Treemap.prototype.padding = function(padding) {};

/**
 * @param {boolean=} round
 * @return {boolean|!d3.layout.Treemap}
 */
d3.layout.Treemap.prototype.round = function(round) {};

/**
 * @param {boolean=} sticky
 * @return {boolean}
 */
d3.layout.Treemap.prototype.sticky = function(sticky) {};

/**
 * @param {string=} mode
 * @return {string|!d3.layout.Treemap}
 */
d3.layout.Treemap.prototype.mode = function(mode) {};

/**
 * @param {number=} ratio
 * @return {number|!d3.layout.Treemap}
 */
d3.layout.Treemap.prototype.ratio = function(ratio) {};
/** @const */
d3.geom = {};

/**
 * @template T
 * @return {!d3.geom.Voronoi<!Array<?>>|!d3.geom.Voronoi<T>}
 */
d3.geom.voronoi = function() {};
/**
 * @record
 * @struct
 */
d3.geom.voronoi.Link = function() {};
 /** @type {T} */
d3.geom.voronoi.Link.prototype.source;
 /** @type {T} */
d3.geom.voronoi.Link.prototype.target;
/**
 * @record
 * @struct
 */
d3.geom.Voronoi = function() {};

/* TODO: CallSignature: d3.geom */

/**
 * @param {function(T): number=} x
 * @return {function(T): number|!d3.geom.Voronoi}
 */
d3.geom.Voronoi.prototype.x = function(x) {};

/**
 * @param {function(T): number=} y
 * @return {function(T): number|!d3.geom.Voronoi}
 */
d3.geom.Voronoi.prototype.y = function(y) {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.geom.Voronoi}
 */
d3.geom.Voronoi.prototype.clipExtent = function(extent) {};

/**
 * @param {!Array<T>} data
 * @return {!Array<!d3.geom.voronoi.Link<T>>}
 */
d3.geom.Voronoi.prototype.links = function(data) {};

/**
 * @param {!Array<T>} data
 * @return {!Array<!Array<?>>}
 */
d3.geom.Voronoi.prototype.triangles = function(data) {};

/**
 * @deprecated use d3.geom.voronoi().triangles() instead
 * @param {!Array<!Array<?>>} vertices
 * @return {!Array<!Array<?>>}
 */
d3.geom.delaunay = function(vertices) {};

/**
 * @template T
 * @param {!Array<T>=} nodes
 * @param {number=} x1
 * @param {number=} y1
 * @param {number=} x2
 * @param {number=} y2
 * @return {!d3.geom.Quadtree<!Array<?>>|!d3.geom.quadtree.Quadtree<T>}
 */
d3.geom.quadtree = function(nodes, x1, y1, x2, y2) {};
/**
 * @record
 * @struct
 */
d3.geom.quadtree.Node = function() {};
 /** @type {!Array<?>} */
d3.geom.quadtree.Node.prototype.nodes;
 /** @type {boolean} */
d3.geom.quadtree.Node.prototype.leaf;
 /** @type {T} */
d3.geom.quadtree.Node.prototype.point;
 /** @type {number} */
d3.geom.quadtree.Node.prototype.x;
 /** @type {number} */
d3.geom.quadtree.Node.prototype.y;
/**
 * @extends {d3.geom.quadtree.Node}
 * @record
 * @struct
 */
d3.geom.quadtree.Quadtree = function() {};

/**
 * @param {T} point
 * @return {void}
 */
d3.geom.quadtree.Quadtree.prototype.add = function(point) {};

/**
 * @param {function(!d3.geom.quadtree.Node<T>, number, number, number, number): (boolean|void)} callback
 * @return {void}
 */
d3.geom.quadtree.Quadtree.prototype.visit = function(callback) {};

/**
 * @param {!Array<?>} point
 * @return {T}
 */
d3.geom.quadtree.Quadtree.prototype.find = function(point) {};
/**
 * @record
 * @struct
 */
d3.geom.Quadtree = function() {};

/* TODO: CallSignature: d3.geom */

/**
 * @param {number|function(T, number): number=} x
 * @return {function(T, number): number|!d3.geom.Quadtree}
 */
d3.geom.Quadtree.prototype.x = function(x) {};

/**
 * @param {number|function(T, number): number=} y
 * @return {function(T, number): number|!d3.geom.Quadtree}
 */
d3.geom.Quadtree.prototype.y = function(y) {};

/**
 * @param {!Array<?>=} extent
 * @return {!Array<?>|!d3.geom.Quadtree}
 */
d3.geom.Quadtree.prototype.extent = function(extent) {};

/**
 * @template T
 * @param {!Array<!Array<?>>=} vertices
 * @return {!Array<!Array<?>>|!d3.geom.Hull<!Array<?>>|!d3.geom.Hull<T>}
 */
d3.geom.hull = function(vertices) {};
/**
 * @record
 * @struct
 */
d3.geom.Hull = function() {};

/* TODO: CallSignature: d3.geom */

/**
 * @param {function(T): number=} x
 * @return {function(T): number|!d3.geom.Hull}
 */
d3.geom.Hull.prototype.x = function(x) {};

/**
 * @param {function(T): number=} y
 * @return {function(T): number|!d3.geom.Hull}
 */
d3.geom.Hull.prototype.y = function(y) {};

/**
 * @param {!Array<!Array<?>>} vertices
 * @return {!d3.geom.Polygon}
 */
d3.geom.polygon = function(vertices) {};
/**
 * @record
 * @struct
 */
d3.geom.Polygon = function() {};

/**
 * @return {number}
 */
d3.geom.Polygon.prototype.area = function() {};

/**
 * @return {!Array<?>}
 */
d3.geom.Polygon.prototype.centroid = function() {};

/**
 * @param {!Array<!Array<?>>} subject
 * @return {!Array<!Array<?>>}
 */
d3.geom.Polygon.prototype.clip = function(subject) {};
/**
 * @record
 * @struct
 */
function TouchList() {}
