/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/vortex-web-client/index.d.ts:
/** @const */
var DDS = {};
/**
 * @record
 * @struct
 */
DDS.Policy = function() {};

/** @const */
DDS.HistoryKind = {};
/** @const {number} */
DDS.HistoryKind.KeepAll;
/** @const {number} */
DDS.HistoryKind.KeepLast;
/**
 * @implements {DDS.Policy}
 * @constructor
 * @struct
 */
DDS.History = function() {};
 /** @type {?} */
DDS.History.KeepAll;
 /** @type {?} */
DDS.History.KeepLast;

/** @const */
DDS.ReliabilityKind = {};
/** @const {number} */
DDS.ReliabilityKind.Reliable;
/** @const {number} */
DDS.ReliabilityKind.BestEffort;
/**
 * @implements {DDS.Policy}
 * @constructor
 * @struct
 */
DDS.Reliability = function() {};
 /** @type {?} */
DDS.Reliability.Reliable;
 /** @type {?} */
DDS.Reliability.BestEffort;

/**
 * Create new partition policy
 * 
 * \@example var qos = Partition('p1', 'p2')
 * @param {...string} policies - partition names
 * @return {!DDS.Policy}
 */
DDS.Partition = function(policies) {};

/**
 * Create new content filter policy
 * 
 * \@example var filter = ContentFilter("x>10 AND y<50")
 * @param {string} expr - filter expression
 * @return {!DDS.Policy}
 */
DDS.ContentFilter = function(expr) {};

/**
 * Create new time filter policy
 * 
 * \@example var filter = TimeFilter(100)
 * @param {number} period - time duration (unit ?)
 * @return {!DDS.Policy}
 */
DDS.TimeFilter = function(period) {};

/** @const */
DDS.DurabilityKind = {};
/** @const {number} */
DDS.DurabilityKind.Volatile;
/** @const {number} */
DDS.DurabilityKind.TransientLocal;
/** @const {number} */
DDS.DurabilityKind.Transient;
/** @const {number} */
DDS.DurabilityKind.Persistent;
/**
 * @implements {DDS.Policy}
 * @constructor
 * @struct
 */
DDS.Durability = function() {};
 /** @type {?} */
DDS.Durability.Volatile;
 /** @type {?} */
DDS.Durability.TransientLocal;
 /** @type {?} */
DDS.Durability.Transient;
 /** @type {?} */
DDS.Durability.Persistent;
/**
 * @record
 * @struct
 */
DDS.EntityQos = function() {};

/* TODO: ConstructSignature: DDS */

/**
 * Adds the given policy to this instance.
 * @param {!DDS.Policy} policy - the policy to add
 * @return {!DDS.EntityQos} A new copy of this instance with the combined policies
 */
DDS.EntityQos.prototype.add = function(policy) {};
 /** @type {!DDS.EntityQos} */
DDS.TopicQos;
 /** @type {!DDS.EntityQos} */
DDS.DataReaderQos;
 /** @type {!DDS.EntityQos} */
DDS.DataWriterQos;

/**
 * @constructor
 * @struct
 * Creates a `Topic` in the domain `did`, named `tname`, having `qos` Qos,
 * for the type `ttype` whose registered name is `tregtype`
 * @param {number} did
 * @param {string} tname
 * @param {!DDS.EntityQos} qos
 * @param {string=} ttype
 * @param {string=} tregtype
 */
DDS.Topic = function(did, tname, qos, ttype, tregtype) {};

/**
 * Called when topic gets registered in the runtime
 * @return {void}
 */
DDS.Topic.prototype.onregistered = function() {};

/**
 * Called when topic gets unregistered in the runtime
 * @return {void}
 */
DDS.Topic.prototype.onunregistered = function() {};

/**
 * @constructor
 * @struct
 * Creates a `DataReader` for a given topic and a specific in a specific DDS runtime.
 * 
 * A `DataReader` allows to read data for a given topic with a specific QoS. A `DataReader`
 * * goes through different states, it is intially disconnected and changes to the connected state
 * when the underlying transport connection is successfully established with the server. At this point
 * a `DataReader` can be explicitely closed or disconnected. A disconnection can happen as the result
 * of a network failure or server failure. Disconnection and reconnections are managed by the runtime.
 * 
 * @param {!DDS.Runtime} runtime - DDS Runtime
 * @param {!DDS.Topic} topic - DDS Topic
 * @param {!DDS.EntityQos} qos - DataReader quality of service
 */
DDS.DataReader = function(runtime, topic, qos) {};

/**
 * @return {void}
 */
DDS.DataReader.prototype.resetStats = function() {};

/**
 * Attaches the  listener `l` to this data reader and returns
 * the id associated to the listener.
 * @param {function(?): void} l - listener code
 * @return {number} listener handle
 */
DDS.DataReader.prototype.addListener = function(l) {};

/**
 * removes a listener from this data reader.
 * @param {number} idx - listener id
 * @return {void}
 */
DDS.DataReader.prototype.removeListener = function(idx) {};

/**
 * closes the DataReader
 * @return {void}
 */
DDS.DataReader.prototype.close = function() {};

/**
 * @constructor
 * @struct
 * Creates a `DataWriter` for a given topic and a specific in a specific DDS runtime
 * 
 * defines a DDS data writer. This type
 * is used to write data for a specific topic with a given QoS.
 * A `DataWriter` goes through different states, it is intially disconnected and changes to the connected
 * state when the underlying transport connection is successfully established with the server.
 * At this point a `DataWriter` can be explicitely closed or disconnected. A disconnection can happen
 * as the result of a network failure or server failure. Disconnection and reconnections are managed by the
 * runtime.
 * 
 * @param {!DDS.Runtime} runtime - DDS Runtime
 * @param {!DDS.Topic} topic - DDS Topic
 * @param {!DDS.EntityQos} qos - DataWriter quality of service
 */
DDS.DataWriter = function(runtime, topic, qos) {};

/**
 * Writes one or more samples.
 * @param {...?} ds - data sample
 * @return {void}
 */
DDS.DataWriter.prototype.write = function(ds) {};

/**
 * Closes the DataWriter
 * @return {void}
 */
DDS.DataWriter.prototype.close = function() {};

/**
 * @constructor
 * @struct
 * Constructs a `DataCache` with a given `depth`. If the `cache` parameter
 * is present, then the current cache is initialized with this parameter.
 * 
 * Provides a way of storing and flexibly accessing the
 * data received through a `DataReader`. A `DataCache` is organized as
 * a map of queues. The depth of the queues is specified at construction
 * time.
 * 
 * @param {number} depth - cache size
 * @param {?} cache - cache data structure
 */
DDS.DataCache = function(depth, cache) {};

/**
 * Register a listener to be notified whenever data which matches a predicate is written into the cache.
 * If no predicate is provided then the listeners is always notified upon data inserion.
 * 
 * @param {function(?): void} l - listener function
 * @param {function(?): boolean=} p - predicate
 * @return {void}
 */
DDS.DataCache.prototype.addListener = function(l, p) {};

/**
 * Write the element `data` with key `k` into the cache.
 * 
 * @param {?} k - data key
 * @param {?} data - data value
 * @return {?} the written data value
 */
DDS.DataCache.prototype.write = function(k, data) {};

/**
 * Same as forEach but applied, for each key, only to the first `n` samples of the cache
 * 
 * @param {function(?): ?} f - the function to be applied
 * @param {number} n - samples set size
 * @return {!Array<?>}
 */
DDS.DataCache.prototype.forEachN = function(f, n) {};

/**
 * Execute the function `f` for each element of the cache.
 * 
 * \@memberof! dds.DataCache#
 * @param {function(?): ?} f - the function to be applied
 * @return {!Array<?>} results of the function execution
 */
DDS.DataCache.prototype.forEach = function(f) {};

/**
 * Returns a cache that is the result of applying `f` to each element of the cache.
 * 
 * @param {function(?): ?} f - the function to be applied
 * @return {!DDS.DataCache} A cache holding the results of the function execution
 */
DDS.DataCache.prototype.map = function(f) {};

/**
 * Returns the list of elements in the cache that satisfy the predicate `f`.
 * 
 * @param {function(?): boolean} f - the predicate to be applied to filter the cache values
 * @return {!Array<?>} An array holding the filtered values
 */
DDS.DataCache.prototype.filter = function(f) {};

/**
 * Returns the list of elements in the cache that doesn't satisfy the predicate `f`.
 * 
 * @see DataCache#filter
 * @param {function(?): boolean} f
 * @return {!Array<?>} An array holding the filtered values
 */
DDS.DataCache.prototype.filterNot = function(f) {};

/**
 * Returns the values included in the cache as an array.
 * 
 * @return {!Array<?>} All the cache values
 */
DDS.DataCache.prototype.read = function() {};

/**
 * Returns the last value of the cache in an array.
 * 
 * @return {?} the last value of the cache
 */
DDS.DataCache.prototype.readLast = function() {};

/**
 * Returns all the values included in the cache as an array and empties the cache.
 * 
 * @return {!Array<?>} All the cache values
 */
DDS.DataCache.prototype.takeAll = function() {};

/**
 * Returns the `K`ith value of the cache as Monad, ie: `coffez.Some` if it exists, `coffez.None` if not.
 * 
 * @return {?} the 'k'th value
 */
DDS.DataCache.prototype.take = function() {};

/**
 * Takes elements from the cache up to when the predicate `f` is satisfied
 * 
 * @param {function(?): boolean} f - the predicate
 * @return {!Array<?>} taken cache values
 */
DDS.DataCache.prototype.takeWithFilter = function(f) {};

/**
 * Return `coffez.Some(v)` if there is an element in the cache corresponding to the
 * key `k` otherwise it returns `coffez.None`.
 * 
 * @param {?} k - key
 * @return {?}
 */
DDS.DataCache.prototype.get = function(k) {};

/**
 * Return `coffez.Some(v)` if there is an element in the cache corresponding to the
 * key `k` otherwise executes `f` and returns its result.
 * 
 * @param {?} k - key
 * @param {function(?): ?} f - the function to apply
 * @return {?}
 */
DDS.DataCache.prototype.getOrElse = function(k, f) {};

/**
 * folds the element of the cache using `z` as the `zero` element and
 * `f` as the binary operator.
 * 
 * @param {?} z - initial value
 * @param {function(?): ?} f
 * @return {void}
 */
DDS.DataCache.prototype.fold = function(z, f) {};

/**
 * clears the data cache
 * @return {void}
 */
DDS.DataCache.prototype.clear = function() {};
/**
 * @record
 * @struct
 */
DDS.Runtime = function() {};

/* TODO: ConstructSignature: DDS */

/**
 * Connect the runtime to the server. If the runtime is already connected an exception is thrown
 * 
 * @param {string} server
 * @param {string=} authToken - Authorization token
 * @return {void}
 */
DDS.Runtime.prototype.connect = function(server, authToken) {};

/**
 * Disconnects, withouth closing, a `Runtime`. Notice that upon re-connection all existing
 * subscriptions and publications will be re-restablished.
 * @return {void}
 */
DDS.Runtime.prototype.disconnect = function() {};

/**
 * Registers the provided Topic.
 * 
 * @param {!DDS.Topic} t - Topic to be registered
 * @return {void}
 */
DDS.Runtime.prototype.registerTopic = function(t) {};

/**
 * Function called when runtime is connected.
 * 
 * @param {?} e
 * @return {void}
 */
DDS.Runtime.prototype.onconnect = function(e) {};

/**
 * Function called when runtime is disconnected.
 * 
 * @param {?} e
 * @return {void}
 */
DDS.Runtime.prototype.ondisconnect = function(e) {};

/**
 * Closes the DDS runtime and as a consequence all the `DataReaders` and `DataWriters` that belong to this runtime.
 * 
 * @return {void}
 */
DDS.Runtime.prototype.close = function() {};

/**
 * Checks whether the Runtime is connected.
 * @return {boolean} `true` if connected, `false` if not
 */
DDS.Runtime.prototype.isConnected = function() {};

/**
 * Checks whether the Runtime is closed.
 * @return {boolean} `true` if connected, `false` if not
 */
DDS.Runtime.prototype.isClosed = function() {};
 /** @type {{Runtime: !DDS.Runtime}} */
DDS.runtime;
 /** @type {string} */
DDS.VERSION;
 /** @type {?} */
var dds;
