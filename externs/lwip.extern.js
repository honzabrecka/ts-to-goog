/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/lwip/index.d.ts:

/** @typedef {?} */
var ColorObject;

/** @typedef {(string|?|!Array<?>)} */
var Color;
/**
 * @record
 * @struct
 */
function ImageCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function BufferCallback() {}

/* TODO: CallSignature:  */

/**
 * Open an image
 * Open an image
 * Open an image
 * @param {string|?} source The path to the image on disk. / The path to the image on disk or an image buffer.
 * @param {?|string|(string|?)} callback_or_type Optional type of the image. If omitted, the type will be inferred from the file extension. Type must be a string of the image type (i.e. "jpg"). / Type of the image. If source is an encoded image buffer, type must be a string of the image type (i.e. "jpg"). If source is a raw pixels buffer type must be an object with type.width and type.height properties.
 * @param {?=} callback
 * @return {void|?}
 */
function open(source, callback_or_type, callback) {}

/**
 * Create a new image
 * Create a new image
 * @param {number} width The width of the new image.
 * @param {number} height The height of the new image.
 * @param {?|(string|?|!Array<?>)} callback_or_color Optional Color of the canvas.
 * @param {?=} callback
 * @return {void}
 */
function create(width, height, callback_or_color, callback) {}

/** @typedef {?} */
var JpegBufferParams;

/** @typedef {?} */
var PngBufferParams;

/** @typedef {?} */
var GifBufferParams;
/**
 * @record
 * @struct
 */
function Image() {}

/**
 * Resize
 * Resize
 * Resize
 * Resize
 * @param {number} width
 * @param {?|string|number} callback_or_inter_or_height
 * @param {?|string=} callback_or_inter
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.resize = function(width, callback_or_inter_or_height, callback_or_inter, callback) {};

/**
 * Scale
 * Scale
 * Scale
 * Scale
 * @param {number} wRatio Width scale ratio.
 * @param {?|string|number} callback_or_inter_or_hRatio Interpolation method. / Height scale ratio.
 * @param {?|string=} callback_or_inter Interpolation method.
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.scale = function(wRatio, callback_or_inter_or_hRatio, callback_or_inter, callback) {};

/**
 * Contain the image in a colored canvas. The image will be resized to the largest possible size such that it's fully contained inside the canvas.
 * Contain the image in a colored canvas. The image will be resized to the largest possible size such that it's fully contained inside the canvas.
 * Contain the image in a colored canvas. The image will be resized to the largest possible size such that it's fully contained inside the canvas.
 * Contain the image in a colored canvas. The image will be resized to the largest possible size such that it's fully contained inside the canvas.
 * @param {number} width Canvas' width in pixels.
 * @param {number} height Canvas' height in pixels.
 * @param {?|(string|?|!Array<?>)|string} callback_or_color_or_inter Color of the canvas. / Interpolation method.
 * @param {?|string=} callback_or_inter Interpolation method.
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.contain = function(width, height, callback_or_color_or_inter, callback_or_inter, callback) {};

/**
 * Cover a canvas with the image. The image will be resized to the smallest possible size such that both its dimensions are bigger than the canvas's dimensions. Margins of the image exceeding the canvas will be discarded.
 * Cover a canvas with the image. The image will be resized to the smallest possible size such that both its dimensions are bigger than the canvas's dimensions. Margins of the image exceeding the canvas will be discarded.
 * @param {number} width Canvas' width in pixels.
 * @param {number} height Canvas' height in pixels.
 * @param {?|string} callback_or_inter Interpolation method.
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.cover = function(width, height, callback_or_inter, callback) {};

/**
 * Rotate
 * Rotate
 * @param {number} degs Clockwise rotation degrees.
 * @param {?|(string|?|!Array<?>)} callback_or_color Color of the canvas.
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.rotate = function(degs, callback_or_color, callback) {};

/**
 * Crop with rectangle coordinates
 * Crop a rectangle from center
 * @param {number} left_or_width Width of the rectangle to crop from the center of the image.
 * @param {number} top_or_height Height of the rectangle to crop from the center of the image.
 * @param {number|?} right_or_callback
 * @param {number=} bottom
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.crop = function(left_or_width, top_or_height, right_or_callback, bottom, callback) {};

/**
 * Gaussian blur.
 * @param {number} sigma Standard deviation of the Gaussian filter.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.blur = function(sigma, callback) {};

/**
 * Inverse diffusion shapren.
 * @param {number} amplitude Sharpening amplitude.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.sharpen = function(amplitude, callback) {};

/**
 * Mirror an image along the 'x' axis, 'y' axis or both.
 * @param {string} axes 'x', 'y' or 'xy' (case sensitive).
 * @param {?} callback
 * @return {void}
 */
Image.prototype.mirror = function(axes, callback) {};

/**
 * Alias of mirror. Mirror an image along the 'x' axis, 'y' axis or both.
 * @param {string} axes 'x', 'y' or 'xy' (case sensitive).
 * @param {?} callback
 * @return {void}
 */
Image.prototype.flip = function(axes, callback) {};

/**
 * Add a colored border to the image.
 * Add a colored border to the image.
 * @param {number} width Border width in pixels.
 * @param {?|(string|?|!Array<?>)} callback_or_color Color of the border.
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.border = function(width, callback_or_color, callback) {};

/**
 * Pad image edges with colored pixels.
 * Pad image edges with colored pixels.
 * @param {number} left Number of pixels to add to left edge.
 * @param {number} top Number of pixels to add to top edge.
 * @param {number} right Number of pixels to add to right edge.
 * @param {number} bottom Number of pixels to add to bottom edge.
 * @param {?|(string|?|!Array<?>)} callback_or_color Color of the padding.
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.pad = function(left, top, right, bottom, callback_or_color, callback) {};

/**
 * Adjust image saturation.
 * 
 * Examples:
 * 1. image.saturate(0, ...) will have no effect on the image.
 * 2. image.saturate(0.5, ...) will increase the saturation by 50%.
 * 3. image.saturate(-1, ...) will decrease the saturation by 100%, effectively desaturating the image.
 * 
 * @param {number} delta By how much to increase / decrease the saturation.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.saturate = function(delta, callback) {};

/**
 * Adjust image lightness.
 * 
 * Examples:
 * 1. image.lighten(0, ...) will have no effect on the image.
 * 2. image.lighten(0.5, ...) will increase the lightness by 50%.
 * 3. image.lighten(-1, ...) will decrease the lightness by 100%, effectively making the image black.
 * 
 * @param {number} delta By how much to increase / decrease the lightness.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.lighten = function(delta, callback) {};

/**
 * Adjust image lightness. Equivalent to image.lighten(-delta, callback).
 * @param {number} delta By how much to increase / decrease the lightness.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.darken = function(delta, callback) {};

/**
 * Adjust image hue.
 * 
 * Examples:
 * 1. image.hue(0, ...) will have no effect on the image.
 * 2. image.hue(100, ...) will shift pixels' hue by 100 degrees.
 * 
 * Note: The hue is shifted in a circular manner in the range [0,360] for each pixel individually.
 * 
 * @param {number} shift By how many degrees to shift each pixel's hue.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.hue = function(shift, callback) {};

/**
 * Adjust image transperancy.
 * 
 * Examples:
 * 1. image.fade(0, ...) will have no effect on the image.
 * 2. image.fade(0.5, ...) will increase the transparency by 50%.
 * 3. image.fade(1, ...) will make the image completely transparent.
 * 
 * Note: The transparency is adjusted independently for each pixel.
 * 
 * @param {number} delta By how much to increase / decrease the transperancy.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.fade = function(delta, callback) {};

/**
 * Make image completely opaque.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.opacity = function(callback) {};

/**
 * Paste an image on top of this image.
 * 
 * Notes:
 * 1. If the pasted image exceeds the bounds of the base image, an exception is thrown.
 * 2. img is pasted in the state it was at the time image.paste( ... ) was called, eventhough callback is called asynchronously.
 * 3. For transparent images, alpha blending is done according to the equations described here.
 * 4. Extra caution is required when using this method in batch mode, as the images may change by the time this operation is called.
 * 
 * @param {number} left Coordinates of the left corner of the pasted image.
 * @param {number} top Coordinates of the top corner of the pasted image.
 * @param {?} img The image to paste.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.paste = function(left, top, img, callback) {};

/**
 * Set the color of a pixel.
 * 
 * Notes:
 * 1. If the coordinates exceed the bounds of the image, an exception is thrown.
 * 2. Extra caution is required when using this method in batch mode, as the dimensions of the image may change by the time this operation is called.
 * 
 * @param {number} left Coordinates of the pixel from the left corner of the image.
 * @param {number} top Coordinates of the pixel from the top corner of the image.
 * @param {(string|?|!Array<?>)} color Color of the pixel to set.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.setPixel = function(left, top, color, callback) {};

/**
 * Set the metadata in an image. This is currently only supported for PNG files. Sets a tEXt chunk with the key lwip_data and comment as the given string. If called with a null parameter, removes existing metadata from the image, if present.
 * @param {string} metadata A string of arbitrary length, or null.
 * @return {void}
 */
Image.prototype.setMetaData = function(metadata) {};

/**
 * Return the image's width in pixels.
 * @return {number}
 */
Image.prototype.width = function() {};

/**
 * Return the image's height in pixels.
 * @return {number}
 */
Image.prototype.height = function() {};

/**
 * Return the color of the pixel at the (left, top) coordinate.
 * @param {number} left
 * @param {number} top
 * @return {?}
 */
Image.prototype.getPixel = function(left, top) {};

/**
 * Clone the image into a new image object.
 * 
 * Note: The image is cloned to the state it was at the time image.clone( ... ) was called, eventhough callback is called asynchronously.
 * @param {?} callback
 * @return {void}
 */
Image.prototype.clone = function(callback) {};

/**
 * Copy an area of the image into a new image object.
 * 
 * Note: The sub-image is extracted from the original image in the state it was at the time image.extract( ... ) was called, eventhough callback is called asynchronously.
 * @param {number} left
 * @param {number} top
 * @param {number} right
 * @param {number} bottom
 * @param {?} callback
 * @return {void}
 */
Image.prototype.extract = function(left, top, right, bottom, callback) {};

/**
 * Get encoded binary image data as a NodeJS Buffer.
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Get encoded binary image data as a NodeJS Buffer.
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Get encoded binary image data as a NodeJS Buffer.
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Get encoded binary image data as a NodeJS Buffer.
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Get encoded binary image data as a NodeJS Buffer.
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Get encoded binary image data as a NodeJS Buffer.
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Get encoded binary image data as a NodeJS Buffer.
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Get encoded binary image data as a NodeJS Buffer.
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * @param {string} format Encoding format.
 * @param {?} callback_or_params Format-specific parameters.
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.toBuffer = function(format, callback_or_params, callback) {};

/**
 * Write encoded binary image data directly to a file.
 * 
 * Write encoded binary image data directly to a file.
 * 
 * Write encoded binary image data directly to a file.
 * 
 * Write encoded binary image data directly to a file.
 * 
 * Write encoded binary image data directly to a file.
 * 
 * Write encoded binary image data directly to a file.
 * 
 * Write encoded binary image data directly to a file.
 * 
 * Write encoded binary image data directly to a file.
 * 
 * Write encoded binary image data directly to a file.
 * 
 * Write encoded binary image data directly to a file.
 * 
 * @param {string} path Path of file to write.
 * @param {?|string} callback_or_params_or_format Format-specific parameters. / Encoding format.
 * @param {?=} callback_or_params Format-specific parameters.
 * @param {?=} callback
 * @return {void}
 */
Image.prototype.writeFile = function(path, callback_or_params_or_format, callback_or_params, callback) {};

/**
 * Get the textual metadata from an image. This is currently only supported for tEXt chunks in PNG images, and will get the first tEXt chunk found with the key lwip_data. If none is found, returns null.
 * @template T
 * @return {?}
 */
Image.prototype.getMetaData = function() {};

/**
 * Obtain a batch object from the image
 * @return {?}
 */
Image.prototype.batch = function() {};
/**
 * @record
 * @struct
 */
function Batch() {}

/**
 * Resize
 * Resize
 * Resize
 * Resize
 * @param {number} width
 * @param {string|number=} inter_or_height
 * @param {string=} inter
 * @return {?}
 */
Batch.prototype.resize = function(width, inter_or_height, inter) {};

/**
 * Scale
 * Scale
 * Scale
 * Scale
 * @param {number} wRatio Width scale ratio.
 * @param {string|number=} inter_or_hRatio Interpolation method. / Height scale ratio.
 * @param {string=} inter Interpolation method.
 * @return {?}
 */
Batch.prototype.scale = function(wRatio, inter_or_hRatio, inter) {};

/**
 * Contain the image in a colored canvas. The image will be resized to the largest possible size such that it's fully contained inside the canvas.
 * Contain the image in a colored canvas. The image will be resized to the largest possible size such that it's fully contained inside the canvas.
 * Contain the image in a colored canvas. The image will be resized to the largest possible size such that it's fully contained inside the canvas.
 * Contain the image in a colored canvas. The image will be resized to the largest possible size such that it's fully contained inside the canvas.
 * @param {number} width Canvas' width in pixels.
 * @param {number} height Canvas' height in pixels.
 * @param {(string|?|!Array<?>)|string=} color_or_inter Color of the canvas. / Interpolation method.
 * @param {string=} inter Interpolation method.
 * @return {?}
 */
Batch.prototype.contain = function(width, height, color_or_inter, inter) {};

/**
 * Cover a canvas with the image. The image will be resized to the smallest possible size such that both its dimensions are bigger than the canvas's dimensions. Margins of the image exceeding the canvas will be discarded.
 * Cover a canvas with the image. The image will be resized to the smallest possible size such that both its dimensions are bigger than the canvas's dimensions. Margins of the image exceeding the canvas will be discarded.
 * @param {number} width Canvas' width in pixels.
 * @param {number} height Canvas' height in pixels.
 * @param {string=} inter Interpolation method.
 * @return {?}
 */
Batch.prototype.cover = function(width, height, inter) {};

/**
 * Rotate
 * Rotate
 * @param {number} degs Clockwise rotation degrees.
 * @param {(string|?|!Array<?>)=} color Color of the canvas.
 * @return {?}
 */
Batch.prototype.rotate = function(degs, color) {};

/**
 * Crop with rectangle coordinates
 * Crop a rectangle from center
 * @param {number} left_or_width Width of the rectangle to crop from the center of the image.
 * @param {number} top_or_height Height of the rectangle to crop from the center of the image.
 * @param {number=} right
 * @param {number=} bottom
 * @return {?}
 */
Batch.prototype.crop = function(left_or_width, top_or_height, right, bottom) {};

/**
 * Gaussian blur.
 * @param {number} sigma Standard deviation of the Gaussian filter.
 * @return {?}
 */
Batch.prototype.blur = function(sigma) {};

/**
 * Inverse diffusion shapren.
 * @param {number} amplitude Sharpening amplitude.
 * @return {?}
 */
Batch.prototype.sharpen = function(amplitude) {};

/**
 * Mirror an image along the 'x' axis, 'y' axis or both.
 * @param {string} axes 'x', 'y' or 'xy' (case sensitive).
 * @return {?}
 */
Batch.prototype.mirror = function(axes) {};

/**
 * Alias of mirror. Mirror an image along the 'x' axis, 'y' axis or both.
 * @param {string} axes 'x', 'y' or 'xy' (case sensitive).
 * @return {?}
 */
Batch.prototype.flip = function(axes) {};

/**
 * Add a colored border to the image.
 * Add a colored border to the image.
 * @param {number} width Border width in pixels.
 * @param {(string|?|!Array<?>)=} color Color of the border.
 * @return {?}
 */
Batch.prototype.border = function(width, color) {};

/**
 * Pad image edges with colored pixels.
 * Pad image edges with colored pixels.
 * @param {number} left Number of pixels to add to left edge.
 * @param {number} top Number of pixels to add to top edge.
 * @param {number} right Number of pixels to add to right edge.
 * @param {number} bottom Number of pixels to add to bottom edge.
 * @param {(string|?|!Array<?>)=} color Color of the padding.
 * @return {?}
 */
Batch.prototype.pad = function(left, top, right, bottom, color) {};

/**
 * Adjust image saturation.
 * 
 * Examples:
 * 1. image.saturate(0, ...) will have no effect on the image.
 * 2. image.saturate(0.5, ...) will increase the saturation by 50%.
 * 3. image.saturate(-1, ...) will decrease the saturation by 100%, effectively desaturating the image.
 * 
 * @param {number} delta By how much to increase / decrease the saturation.
 * @return {?}
 */
Batch.prototype.saturate = function(delta) {};

/**
 * Adjust image lightness.
 * 
 * Examples:
 * 1. image.lighten(0, ...) will have no effect on the image.
 * 2. image.lighten(0.5, ...) will increase the lightness by 50%.
 * 3. image.lighten(-1, ...) will decrease the lightness by 100%, effectively making the image black.
 * 
 * @param {number} delta By how much to increase / decrease the lightness.
 * @return {?}
 */
Batch.prototype.lighten = function(delta) {};

/**
 * Adjust image lightness. Equivalent to image.lighten(-delta, callback).
 * @param {number} delta By how much to increase / decrease the lightness.
 * @return {?}
 */
Batch.prototype.darken = function(delta) {};

/**
 * Adjust image hue.
 * 
 * Examples:
 * 1. image.hue(0, ...) will have no effect on the image.
 * 2. image.hue(100, ...) will shift pixels' hue by 100 degrees.
 * 
 * Note: The hue is shifted in a circular manner in the range [0,360] for each pixel individually.
 * 
 * @param {number} shift By how many degrees to shift each pixel's hue.
 * @return {?}
 */
Batch.prototype.hue = function(shift) {};

/**
 * Adjust image transperancy.
 * 
 * Examples:
 * 1. image.fade(0, ...) will have no effect on the image.
 * 2. image.fade(0.5, ...) will increase the transparency by 50%.
 * 3. image.fade(1, ...) will make the image completely transparent.
 * 
 * Note: The transparency is adjusted independently for each pixel.
 * 
 * @param {number} delta By how much to increase / decrease the transperancy.
 * @return {?}
 */
Batch.prototype.fade = function(delta) {};

/**
 * Make image completely opaque.
 * @param {?} callback
 * @return {void}
 */
Batch.prototype.opacity = function(callback) {};

/**
 * Paste an image on top of this image.
 * 
 * Notes:
 * 1. If the pasted image exceeds the bounds of the base image, an exception is thrown.
 * 2. img is pasted in the state it was at the time image.paste( ... ) was called, eventhough callback is called asynchronously.
 * 3. For transparent images, alpha blending is done according to the equations described here.
 * 4. Extra caution is required when using this method in batch mode, as the images may change by the time this operation is called.
 * 
 * @param {number} left Coordinates of the left corner of the pasted image.
 * @param {number} top Coordinates of the top corner of the pasted image.
 * @param {?} img The image to paste.
 * @return {?}
 */
Batch.prototype.paste = function(left, top, img) {};

/**
 * Set the color of a pixel.
 * 
 * Notes:
 * 1. If the coordinates exceed the bounds of the image, an exception is thrown.
 * 2. Extra caution is required when using this method in batch mode, as the dimensions of the image may change by the time this operation is called.
 * 
 * @param {number} left Coordinates of the pixel from the left corner of the image.
 * @param {number} top Coordinates of the pixel from the top corner of the image.
 * @param {(string|?|!Array<?>)} color Color of the pixel to set.
 * @return {?}
 */
Batch.prototype.setPixel = function(left, top, color) {};

/**
 * Set the metadata in an image. This is currently only supported for PNG files. Sets a tEXt chunk with the key lwip_data and comment as the given string. If called with a null parameter, removes existing metadata from the image, if present.
 * @param {string} metadata A string of arbitrary length, or null.
 * @return {void}
 */
Batch.prototype.setMetaData = function(metadata) {};

/**
 * Execute batch and obtain the manipulated image object
 * @param {?} callback
 * @return {void}
 */
Batch.prototype.exec = function(callback) {};

/**
 * Execute batch and obtain a Buffer object
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Execute batch and obtain a Buffer object
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Execute batch and obtain a Buffer object
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Execute batch and obtain a Buffer object
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Execute batch and obtain a Buffer object
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Execute batch and obtain a Buffer object
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Execute batch and obtain a Buffer object
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * Execute batch and obtain a Buffer object
 * 
 * When opening an image, it is decoded and stored in memory as an uncompressed image. All manipulations are done on the uncompressed data in memory. This method allows to encode the image to one of the specified formats and get the encoded data as a NodeJS Buffer object.
 * 
 * @param {string} format Encoding format.
 * @param {?} callback_or_params Format-specific parameters.
 * @param {?=} callback
 * @return {void}
 */
Batch.prototype.toBuffer = function(format, callback_or_params, callback) {};

/**
 * Execute batch and write to file
 * 
 * Execute batch and write to file
 * 
 * Execute batch and write to file
 * 
 * Execute batch and write to file
 * 
 * Execute batch and write to file
 * 
 * Execute batch and write to file
 * 
 * Execute batch and write to file
 * 
 * Execute batch and write to file
 * 
 * Execute batch and write to file
 * 
 * Execute batch and write to file
 * 
 * @param {string} path Path of file to write.
 * @param {?|string} callback_or_params_or_format Format-specific parameters. / Encoding format.
 * @param {?=} callback_or_params Format-specific parameters.
 * @param {?=} callback
 * @return {void}
 */
Batch.prototype.writeFile = function(path, callback_or_params_or_format, callback_or_params, callback) {};
