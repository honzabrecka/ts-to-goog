/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/pino/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ExportAssignment in  */

/**
 * @param {(!P.LoggerOptions|!internal.Writable|!internal.Duplex|!internal.Transform)|!P.LoggerOptions=} optionsOrStream_or_options
 * @param {(!internal.Writable|!internal.Duplex|!internal.Transform)=} stream
 * @return {?} a new logger instance.
 */
function P(optionsOrStream_or_options, stream) {}
 /** @type {number} */
P.LOG_VERSION;
 /** @type {!P.LevelMapping} */
P.levels;
 /** @type {{req: function(!IncomingMessage): {method: string, url: string, headers: !IncomingHttpHeaders, remoteAddress: string, remotePort: number}, res: function(!ServerResponse): {statusCode: number, header: string}, err: function(!Error): ?}} */
P.stdSerializers;
 /** @type {{epochTime: function(): string, slowTime: ?, nullTime: ?}} */
P.stdTimeFunctions;

/**
 * Provides access to the CLI log prettifier as an API.
 * This can also be enabled via the constructor by setting the `prettyPrint` option to either `true` or a configuration object described in this section.
 * @param {!P.PrettyOptions=} options
 * @return {!internal.Transform} A transform stream to be used as input for the constructor.
 */
P.pretty = function(options) {};
/**
 * @record
 * @struct
 */
P.LevelMapping = function() {};
 /** @type {!Object<string,number>} */
P.LevelMapping.prototype.values;
 /** @type {!Object<number,string>} */
P.LevelMapping.prototype.labels;

/** @typedef {function(): string} */
P.TimeFn;
/**
 * @record
 * @struct
 */
P.LoggerOptions = function() {};
 /** @type {boolean} */
P.LoggerOptions.prototype.safe;
 /** @type {string} */
P.LoggerOptions.prototype.name;
 /** @type {!Object<string,function(?): ?>} */
P.LoggerOptions.prototype.serializers;
 /** @type {(boolean|function(): string)} */
P.LoggerOptions.prototype.timestamp;
 /** @type {boolean} */
P.LoggerOptions.prototype.slowtime;
 /** @type {boolean} */
P.LoggerOptions.prototype.extreme;
 /** @type {string} */
P.LoggerOptions.prototype.level;
 /** @type {number} */
P.LoggerOptions.prototype.levelVal;
 /** @type {string} */
P.LoggerOptions.prototype.messageKey;
 /** @type {(boolean|!P.PrettyOptions)} */
P.LoggerOptions.prototype.prettyPrint;
 /** @type {boolean} */
P.LoggerOptions.prototype.enabled;
 /** @type {{asObject: boolean, write: (function(!Object): void|?)}} */
P.LoggerOptions.prototype.browser;

/**
 * This function will be invoked during process shutdown when `extreme` is set to `true`. If you do not specify
 * a function, Pino will invoke `process.exit(0)` when no error has occurred, and `process.exit(1)` otherwise.
 * If you do specify a function, it is up to you to terminate the process; you must perform only synchronous
 * operations at this point. See http://getpino.io/#/docs/extreme for more detail.
 * @param {string} eventName
 * @param {?} err
 * @return {void}
 */
P.LoggerOptions.prototype.onTerminated = function(eventName, err) {};
/**
 * @record
 * @struct
 */
P.PrettyOptions = function() {};
 /** @type {boolean} */
P.PrettyOptions.prototype.timeTransOnly;
 /** @type {boolean} */
P.PrettyOptions.prototype.levelFirst;
 /** @type {string} */
P.PrettyOptions.prototype.messageKey;
 /** @type {boolean} */
P.PrettyOptions.prototype.forceColor;

/**
 * A custom function to format the line, is passed the JSON object as an argument and should return a string value.
 * @param {!P.LogDescriptor} log
 * @return {string}
 */
P.PrettyOptions.prototype.formatter = function(log) {};

/** @typedef {string} */
P.Level;

/** @typedef {string} */
P.LevelWithSilent;

/** @typedef {function(?): ?} */
P.SerializerFn;

/** @typedef {function(!Object): void} */
P.WriteFn;
/**
 * @record
 * @struct
 */
P.LogDescriptor = function() {};
 /** @type {number} */
P.LogDescriptor.prototype.pid;
 /** @type {string} */
P.LogDescriptor.prototype.hostname;
 /** @type {number} */
P.LogDescriptor.prototype.level;
 /** @type {string} */
P.LogDescriptor.prototype.time;
 /** @type {string} */
P.LogDescriptor.prototype.msg;
 /** @type {number} */
P.LogDescriptor.prototype.v;

/* TODO: IndexSignature: P */

/** @typedef {?} */
P.Logger;
/**
 * @record
 * @struct
 */
P.BaseLogger = function() {};
 /** @type {string} */
P.BaseLogger.prototype.pino;
 /** @type {number} */
P.BaseLogger.prototype.LOG_VERSION;
 /** @type {!P.LevelMapping} */
P.BaseLogger.prototype.levels;
 /** @type {string} */
P.BaseLogger.prototype.level;
 /** @type {number} */
P.BaseLogger.prototype.levelVal;
 /** @type {!P.LogFn} */
P.BaseLogger.prototype.fatal;
 /** @type {!P.LogFn} */
P.BaseLogger.prototype.error;
 /** @type {!P.LogFn} */
P.BaseLogger.prototype.warn;
 /** @type {!P.LogFn} */
P.BaseLogger.prototype.info;
 /** @type {!P.LogFn} */
P.BaseLogger.prototype.debug;
 /** @type {!P.LogFn} */
P.BaseLogger.prototype.trace;

/**
 * Defines a new level on the logger instance. Returns `true` on success and `false` if there was a conflict (level name or number already exists).
 * When using this method, the current level of the logger instance does not change. You must adjust the level with the `level` property after
 * adding your custom level.
 * 
 * @param {string} name
 * @param {number} lvl
 * @return {boolean} whether level was correctly created or not
 */
P.BaseLogger.prototype.addLevel = function(name, lvl) {};

/**
 * Registers a listener function that is triggered when the level is changed.
 * Note: When browserified, this functionality will only be available if the `events` module has been required elsewhere
 * (e.g. if you're using streams in the browser). This allows for a trade-off between bundle size and functionality.
 * 
 * @param {string} event
 * @param {function(string, number, string, number): void} listener
 * @return {BaseLogger}
 */
P.BaseLogger.prototype.on = function(event, listener) {};

/**
 * @param {string} event
 * @param {function(string, number, string, number): void} listener
 * @return {BaseLogger}
 */
P.BaseLogger.prototype.addListener = function(event, listener) {};

/**
 * @param {string} event
 * @param {function(string, number, string, number): void} listener
 * @return {BaseLogger}
 */
P.BaseLogger.prototype.once = function(event, listener) {};

/**
 * @param {string} event
 * @param {function(string, number, string, number): void} listener
 * @return {BaseLogger}
 */
P.BaseLogger.prototype.prependListener = function(event, listener) {};

/**
 * @param {string} event
 * @param {function(string, number, string, number): void} listener
 * @return {BaseLogger}
 */
P.BaseLogger.prototype.prependOnceListener = function(event, listener) {};

/**
 * @param {string} event
 * @param {function(string, number, string, number): void} listener
 * @return {BaseLogger}
 */
P.BaseLogger.prototype.removeListener = function(event, listener) {};

/**
 * Creates a child logger, setting all key-value pairs in `bindings` as properties in the log lines. All serializers will be applied to the given pair.
 * Child loggers use the same output stream as the parent and inherit the current log level of the parent at the time they are spawned.
 * From v2.x.x the log level of a child is mutable (whereas in v1.x.x it was immutable), and can be set independently of the parent.
 * If a `level` property is present in the object passed to `child` it will override the child logger level.
 * 
 * @param {?} bindings
 * @return {?} a child logger instance.
 */
P.BaseLogger.prototype.child = function(bindings) {};

/**
 * Flushes the content of the buffer in extreme mode. It has no effect if extreme mode is not enabled.
 * @return {void}
 */
P.BaseLogger.prototype.flush = function() {};

/** @typedef {function(string, number, string, number): void} */
P.LevelChangeEventListener;
/**
 * @record
 * @struct
 */
P.LogFn = function() {};

/* TODO: CallSignature: P */

/* TODO: CallSignature: P */
