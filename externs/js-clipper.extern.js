/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/js-clipper/index.d.ts:
/** @const */
var ClipperLib = {};
 /** @type {boolean} */
ClipperLib.biginteger_used;

/**
 * @param {number} a
 * @return {number}
 */
ClipperLib.Math_Abs_Int64 = function(a) {};

/**
 * @param {number} a
 * @return {number}
 */
ClipperLib.Math_Abs_Int32 = function(a) {};

/**
 * @param {number} a
 * @return {number}
 */
ClipperLib.Math_Abs_Double = function(a) {};

/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
ClipperLib.Math_Max_Int32_Int32 = function(a, b) {};

/**
 * @param {number} a
 * @return {number}
 */
ClipperLib.Cast_Int32 = function(a) {};

/**
 * @param {number} a
 * @return {number}
 */
ClipperLib.Cast_Int64 = function(a) {};

/**
 * @param {!ArrayLike<?>} a
 * @return {void}
 */
ClipperLib.Clear = function(a) {};
 /** @type {number} */
ClipperLib.MaxSteps;
 /** @type {number} */
ClipperLib.PI;
 /** @type {number} */
ClipperLib.PI2;

/**
 * @constructor
 * @struct
 * @param {!ClipperLib.IntPoint|number=} PointXY_or_x
 * @param {number=} y
 */
ClipperLib.IntPoint = function(PointXY_or_x, y) {};
 /** @type {number} */
ClipperLib.IntPoint.prototype.X;
 /** @type {number} */
ClipperLib.IntPoint.prototype.Y;

/**
 * @constructor
 * @struct
 * @param {number=} left
 * @param {number=} top
 * @param {number=} right
 * @param {number=} bottom
 */
ClipperLib.IntRect = function(left, top, right, bottom) {};
 /** @type {number} */
ClipperLib.IntRect.prototype.left;
 /** @type {number} */
ClipperLib.IntRect.prototype.top;
 /** @type {number} */
ClipperLib.IntRect.prototype.right;
 /** @type {number} */
ClipperLib.IntRect.prototype.bottom;

/**
 * @constructor
 * @struct
 * @param {!ArrayLike<!ClipperLib.IntPoint>=} poly
 */
ClipperLib.Polygon = function(poly) {};

/**
 * @constructor
 * @struct
 * @param {!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>=} polys
 */
ClipperLib.Polygons = function(polys) {};
/**
 * @constructor
 * @struct
 */
ClipperLib.ExPolygon = function() {};
 /** @type {!ArrayLike<!ClipperLib.IntPoint>} */
ClipperLib.ExPolygon.prototype.outer;
 /** @type {!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>} */
ClipperLib.ExPolygon.prototype.holes;

/** @const */
ClipperLib.ClipType = {};
/** @const {number} */
ClipperLib.ClipType.ctIntersection;
/** @const {number} */
ClipperLib.ClipType.ctUnion;
/** @const {number} */
ClipperLib.ClipType.ctDifference;
/** @const {number} */
ClipperLib.ClipType.ctXor;

/** @const */
ClipperLib.PolyType = {};
/** @const {number} */
ClipperLib.PolyType.ptSubject;
/** @const {number} */
ClipperLib.PolyType.ptClip;

/** @const */
ClipperLib.PolyFillType = {};
/** @const {number} */
ClipperLib.PolyFillType.pftEvenOdd;
/** @const {number} */
ClipperLib.PolyFillType.pftNonZero;
/** @const {number} */
ClipperLib.PolyFillType.pftPositive;
/** @const {number} */
ClipperLib.PolyFillType.pftNegative;

/** @const */
ClipperLib.JoinType = {};
/** @const {number} */
ClipperLib.JoinType.jtSquare;
/** @const {number} */
ClipperLib.JoinType.jtRound;
/** @const {number} */
ClipperLib.JoinType.jtMiter;

/** @const */
ClipperLib.EdgeSide = {};
/** @const {number} */
ClipperLib.EdgeSide.esLeft;
/** @const {number} */
ClipperLib.EdgeSide.esRight;

/** @const */
ClipperLib.Protects = {};
/** @const {number} */
ClipperLib.Protects.ipNone;
/** @const {number} */
ClipperLib.Protects.ipLeft;
/** @const {number} */
ClipperLib.Protects.ipRight;
/** @const {number} */
ClipperLib.Protects.ipBoth;

/** @const */
ClipperLib.Direction = {};
/** @const {number} */
ClipperLib.Direction.dRightToLeft;
/** @const {number} */
ClipperLib.Direction.dLeftToRight;
/**
 * @constructor
 * @struct
 */
ClipperLib.TEdge = function() {};
 /** @type {number} */
ClipperLib.TEdge.prototype.xbot;
 /** @type {number} */
ClipperLib.TEdge.prototype.ybot;
 /** @type {number} */
ClipperLib.TEdge.prototype.xcurr;
 /** @type {number} */
ClipperLib.TEdge.prototype.ycurr;
 /** @type {number} */
ClipperLib.TEdge.prototype.xtop;
 /** @type {number} */
ClipperLib.TEdge.prototype.ytop;
 /** @type {number} */
ClipperLib.TEdge.prototype.dx;
 /** @type {number} */
ClipperLib.TEdge.prototype.deltaX;
 /** @type {number} */
ClipperLib.TEdge.prototype.deltaY;
 /** @type {number} */
ClipperLib.TEdge.prototype.tmpX;
 /** @type {ClipperLib.PolyType} */
ClipperLib.TEdge.prototype.polyType;
 /** @type {ClipperLib.EdgeSide} */
ClipperLib.TEdge.prototype.side;
 /** @type {number} */
ClipperLib.TEdge.prototype.windDelta;
 /** @type {number} */
ClipperLib.TEdge.prototype.windCnt;
 /** @type {number} */
ClipperLib.TEdge.prototype.windCnt2;
 /** @type {number} */
ClipperLib.TEdge.prototype.outIdx;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.TEdge.prototype.next;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.TEdge.prototype.prev;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.TEdge.prototype.nextInLML;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.TEdge.prototype.nextInAEL;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.TEdge.prototype.prevInAEL;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.TEdge.prototype.nextInSEL;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.TEdge.prototype.prevInSEL;
/**
 * @constructor
 * @struct
 */
ClipperLib.IntersectNode = function() {};
 /** @type {!ClipperLib.TEdge} */
ClipperLib.IntersectNode.prototype.edge1;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.IntersectNode.prototype.edge2;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.IntersectNode.prototype.pt;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.IntersectNode.prototype.next;
/**
 * @constructor
 * @struct
 */
ClipperLib.LocalMinima = function() {};
 /** @type {number} */
ClipperLib.LocalMinima.prototype.Y;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.LocalMinima.prototype.leftBound;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.LocalMinima.prototype.rightBound;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.LocalMinima.prototype.next;
/**
 * @constructor
 * @struct
 */
ClipperLib.Scanbeam = function() {};
 /** @type {number} */
ClipperLib.Scanbeam.prototype.Y;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.Scanbeam.prototype.next;
/**
 * @constructor
 * @struct
 */
ClipperLib.OutRec = function() {};
 /** @type {number} */
ClipperLib.OutRec.prototype.idx;
 /** @type {boolean} */
ClipperLib.OutRec.prototype.isHole;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.OutRec.prototype.FirstLeft;
 /** @type {!ClipperLib.OutRec} */
ClipperLib.OutRec.prototype.AppendLink;
 /** @type {!ClipperLib.OutPt} */
ClipperLib.OutRec.prototype.pts;
 /** @type {!ClipperLib.OutPt} */
ClipperLib.OutRec.prototype.bottomPt;
/**
 * @constructor
 * @struct
 */
ClipperLib.OutPt = function() {};
 /** @type {number} */
ClipperLib.OutPt.prototype.idx;
 /** @type {!ClipperLib.OutPt} */
ClipperLib.OutPt.prototype.pt;
 /** @type {!ClipperLib.OutPt} */
ClipperLib.OutPt.prototype.next;
 /** @type {!ClipperLib.OutPt} */
ClipperLib.OutPt.prototype.prev;
/**
 * @constructor
 * @struct
 */
ClipperLib.JoinRec = function() {};
 /** @type {!ClipperLib.IntPoint} */
ClipperLib.JoinRec.prototype.pt1a;
 /** @type {!ClipperLib.IntPoint} */
ClipperLib.JoinRec.prototype.pt1b;
 /** @type {number} */
ClipperLib.JoinRec.prototype.poly1Idx;
 /** @type {!ClipperLib.IntPoint} */
ClipperLib.JoinRec.prototype.pt2a;
 /** @type {!ClipperLib.IntPoint} */
ClipperLib.JoinRec.prototype.pt2b;
 /** @type {number} */
ClipperLib.JoinRec.prototype.poly2Idx;
/**
 * @constructor
 * @struct
 */
ClipperLib.HorzJoinRec = function() {};
 /** @type {!ClipperLib.TEdge} */
ClipperLib.HorzJoinRec.prototype.edge;
 /** @type {number} */
ClipperLib.HorzJoinRec.prototype.savedIdx;
/**
 * @constructor
 * @struct
 */
ClipperLib.ClipperBase = function() {};
 /** @type {!ClipperLib.LocalMinima} */
ClipperLib.ClipperBase.prototype.m_MinimaList;
 /** @type {!ClipperLib.LocalMinima} */
ClipperLib.ClipperBase.prototype.m_CurrentLM;
 /** @type {!ArrayLike<!ArrayLike<!ClipperLib.TEdge>>} */
ClipperLib.ClipperBase.prototype.m_edges;
 /** @type {boolean} */
ClipperLib.ClipperBase.prototype.m_UseFullRange;
 /** @type {number} */
ClipperLib.ClipperBase.prototype.horizontal;
 /** @type {number} */
ClipperLib.ClipperBase.prototype.loRange;
 /** @type {number} */
ClipperLib.ClipperBase.prototype.hiRange;

/**
 * @param {!ClipperLib.IntPoint} pt1
 * @param {!ClipperLib.IntPoint} pt2
 * @return {boolean}
 */
ClipperLib.ClipperBase.prototype.PointsEqual = function(pt1, pt2) {};

/**
 * @param {!ClipperLib.IntPoint} pt
 * @param {!ClipperLib.JoinRec} pp
 * @return {boolean}
 */
ClipperLib.ClipperBase.prototype.PointIsVertex = function(pt, pp) {};

/**
 * @param {!ClipperLib.IntPoint} pt
 * @param {!ClipperLib.JoinRec} pp
 * @param {boolean} UseFulllongRange
 * @return {boolean}
 */
ClipperLib.ClipperBase.prototype.PointInPolygon = function(pt, pp, UseFulllongRange) {};

/**
 * @param {!ClipperLib.TEdge|!ClipperLib.IntPoint} e1_or_pt1
 * @param {!ClipperLib.TEdge|!ClipperLib.IntPoint} e2_or_pt2
 * @param {boolean|!ClipperLib.IntPoint} UseFullRange_or_pt3
 * @param {boolean|!ClipperLib.IntPoint=} UseFullRange_or_pt4
 * @param {boolean=} UseFullRange
 * @return {boolean}
 */
ClipperLib.ClipperBase.prototype.SlopesEqual = function(e1_or_pt1, e2_or_pt2, UseFullRange_or_pt3, UseFullRange_or_pt4, UseFullRange) {};

/**
 * @return {void}
 */
ClipperLib.ClipperBase.prototype.clear = function() {};

/**
 * @return {void}
 */
ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function() {};

/**
 * @param {!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>} ppg
 * @param {ClipperLib.PolyType} polyType
 * @return {(string|boolean)}
 */
ClipperLib.ClipperBase.prototype.AddPolygons = function(ppg, polyType) {};

/**
 * @param {!ArrayLike<!ClipperLib.IntPoint>} pg
 * @param {ClipperLib.PolyType} polyType
 * @param {boolean} multiple
 * @return {(string|boolean)}
 */
ClipperLib.ClipperBase.prototype.AddPolygon = function(pg, polyType, multiple) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @param {!ClipperLib.TEdge} eNext
 * @param {!ClipperLib.TEdge} ePrev
 * @param {!ClipperLib.IntPoint} pt
 * @param {ClipperLib.PolyType} polyType
 * @return {void}
 */
ClipperLib.ClipperBase.prototype.InitEdge = function(e, eNext, ePrev, pt, polyType) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @return {void}
 */
ClipperLib.ClipperBase.prototype.SetDx = function(e) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @return {!ClipperLib.TEdge}
 */
ClipperLib.ClipperBase.prototype.AddBoundsToLML = function(e) {};

/**
 * @param {!ClipperLib.LocalMinima} newLm
 * @return {void}
 */
ClipperLib.ClipperBase.prototype.InsertLocalMinima = function(newLm) {};

/**
 * @return {void}
 */
ClipperLib.ClipperBase.prototype.PopLocalMinima = function() {};

/**
 * @param {!ClipperLib.TEdge} e
 * @return {void}
 */
ClipperLib.ClipperBase.prototype.SwapX = function(e) {};

/**
 * @return {void}
 */
ClipperLib.ClipperBase.prototype.Reset = function() {};

/**
 * @return {!ClipperLib.IntRect}
 */
ClipperLib.ClipperBase.prototype.GetBounds = function() {};
/**
 * @extends {ClipperLib.ClipperBase}
 * @constructor
 * @struct
 */
ClipperLib.Clipper = function() {};
 /** @type {(!ClipperLib.TEdge|!ArrayLike<!ClipperLib.TEdge>)} */
ClipperLib.Clipper.prototype.m_PolyOuts;
 /** @type {ClipperLib.ClipType} */
ClipperLib.Clipper.prototype.m_ClipType;
 /** @type {!ClipperLib.Scanbeam} */
ClipperLib.Clipper.prototype.m_Scanbeam;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.Clipper.prototype.m_ActiveEdges;
 /** @type {!ClipperLib.TEdge} */
ClipperLib.Clipper.prototype.m_SortedEdges;
 /** @type {!ClipperLib.IntersectNode} */
ClipperLib.Clipper.prototype.m_intersectnodes;
 /** @type {boolean} */
ClipperLib.Clipper.prototype.m_ExecuteLocked;
 /** @type {ClipperLib.PolyFillType} */
ClipperLib.Clipper.prototype.m_ClipFillType;
 /** @type {ClipperLib.PolyFillType} */
ClipperLib.Clipper.prototype.m_SubjFillType;
 /** @type {!ArrayLike<!ClipperLib.JoinRec>} */
ClipperLib.Clipper.prototype.m_Joins;
 /** @type {!ArrayLike<!ClipperLib.HorzJoinRec>} */
ClipperLib.Clipper.prototype.m_HorizJoins;
 /** @type {boolean} */
ClipperLib.Clipper.prototype.m_ReverseOutput;
 /** @type {boolean} */
ClipperLib.Clipper.prototype.m_UsingExPolygons;
 /** @type {!Function} */
ClipperLib.Clipper.prototype.DoublePoint;
 /** @type {!Function} */
ClipperLib.Clipper.prototype.PolyOffsetBuilder;

/**
 * @return {void}
 */
ClipperLib.Clipper.prototype.DisposeScanbeamList = function() {};

/**
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.get_ReverseSolution = function() {};

/**
 * @param {boolean} value
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.set_ReverseSolution = function(value) {};

/**
 * @param {number} Y
 * @return {void}
 */
ClipperLib.Clipper.prototype.InsertScanbeam = function(Y) {};

/**
 * @param {ClipperLib.ClipType} clipType
 * @param {(!ArrayLike<!ClipperLib.IntPoint>|!ClipperLib.ExPolygon)} solution
 * @param {ClipperLib.PolyFillType=} subjFillType
 * @param {ClipperLib.PolyFillType=} clipFillType
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.Execute = function(clipType, solution, subjFillType, clipFillType) {};

/**
 * @param {!ClipperLib.OutRec} or1
 * @param {!ClipperLib.OutRec} or2
 * @return {number}
 */
ClipperLib.Clipper.prototype.PolySort = function(or1, or2) {};

/**
 * @param {!ClipperLib.OutRec} outRec
 * @return {!ClipperLib.OutRec}
 */
ClipperLib.Clipper.prototype.FindAppendLinkEnd = function(outRec) {};

/**
 * @param {!ClipperLib.OutRec} outRec
 * @return {void}
 */
ClipperLib.Clipper.prototype.FixHoleLinkage = function(outRec) {};

/**
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.ExecuteInternal = function() {};

/**
 * @return {number}
 */
ClipperLib.Clipper.prototype.PopScanbeam = function() {};

/**
 * @param {number} index
 * @return {void}
 */
ClipperLib.Clipper.prototype.DisposeOutRec = function(index) {};

/**
 * @param {!ClipperLib.OutPt} pp
 * @return {void}
 */
ClipperLib.Clipper.prototype.DisposeOutPts = function(pp) {};

/**
 * @param {!ClipperLib.TEdge} e1
 * @param {!ClipperLib.TEdge} e2
 * @param {number} e1OutIdx
 * @param {number} e2OutIdx
 * @return {void}
 */
ClipperLib.Clipper.prototype.AddJoin = function(e1, e2, e1OutIdx, e2OutIdx) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @param {number} idx
 * @return {void}
 */
ClipperLib.Clipper.prototype.AddHorzJoin = function(e, idx) {};

/**
 * @param {number} botY
 * @return {void}
 */
ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function(botY) {};

/**
 * @param {!ClipperLib.TEdge} edge
 * @return {void}
 */
ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function(edge) {};

/**
 * @param {!ClipperLib.TEdge} e1
 * @param {!ClipperLib.TEdge} e2
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function(e1, e2) {};

/**
 * @param {!ClipperLib.TEdge} edge
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.IsEvenOddFillType = function(edge) {};

/**
 * @param {!ClipperLib.TEdge} edge
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function(edge) {};

/**
 * @param {!ClipperLib.TEdge} edge
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.IsContributing = function(edge) {};

/**
 * @param {!ClipperLib.TEdge} edge
 * @return {void}
 */
ClipperLib.Clipper.prototype.SetWindingCount = function(edge) {};

/**
 * @param {!ClipperLib.TEdge} edge
 * @return {void}
 */
ClipperLib.Clipper.prototype.AddEdgeToSEL = function(edge) {};

/**
 * @return {void}
 */
ClipperLib.Clipper.prototype.CopyAELToSEL = function() {};

/**
 * @param {!ClipperLib.TEdge} edge1
 * @param {!ClipperLib.TEdge} edge2
 * @return {void}
 */
ClipperLib.Clipper.prototype.SwapPositionsInAEL = function(edge1, edge2) {};

/**
 * @param {!ClipperLib.TEdge} edge1
 * @param {!ClipperLib.TEdge} edge2
 * @return {void}
 */
ClipperLib.Clipper.prototype.SwapPositionsInSEL = function(edge1, edge2) {};

/**
 * @param {!ClipperLib.TEdge} e1
 * @param {!ClipperLib.TEdge} e2
 * @param {!ClipperLib.OutPt} pt
 * @return {void}
 */
ClipperLib.Clipper.prototype.AddLocalMaxPoly = function(e1, e2, pt) {};

/**
 * @param {!ClipperLib.TEdge} e1
 * @param {!ClipperLib.TEdge} e2
 * @param {!ClipperLib.OutPt} pt
 * @return {void}
 */
ClipperLib.Clipper.prototype.AddLocalMinPoly = function(e1, e2, pt) {};

/**
 * @return {!ClipperLib.OutRec}
 */
ClipperLib.Clipper.prototype.CreateOutRec = function() {};

/**
 * @param {!ClipperLib.TEdge} e
 * @param {!ClipperLib.IntPoint} pt
 * @return {void}
 */
ClipperLib.Clipper.prototype.AddOutPt = function(e, pt) {};

/**
 * @param {!ClipperLib.IntPoint} pt1
 * @param {!ClipperLib.IntPoint} pt2
 * @return {void}
 */
ClipperLib.Clipper.prototype.SwapPoints = function(pt1, pt2) {};

/**
 * @param {!ClipperLib.IntPoint} pt1a
 * @param {!ClipperLib.IntPoint} pt1b
 * @param {!ClipperLib.IntPoint} pt2a
 * @param {!ClipperLib.IntPoint} pt2b
 * @param {!ClipperLib.IntPoint} pt1
 * @param {!ClipperLib.IntPoint} pt2
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.GetOverlapSegment = function(pt1a, pt1b, pt2a, pt2b, pt1, pt2) {};

/**
 * @param {!ClipperLib.IntPoint} pp
 * @param {!ClipperLib.IntPoint} pt1
 * @param {!ClipperLib.IntPoint} pt2
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.FindSegment = function(pp, pt1, pt2) {};

/**
 * @param {boolean} pt1
 * @param {boolean} pt2
 * @param {boolean} pt3
 * @return {!ClipperLib.OutPt}
 */
ClipperLib.Clipper.prototype.Pt3IsBetweenPt1AndPt2 = function(pt1, pt2, pt3) {};

/**
 * @param {!ClipperLib.OutPt} p1
 * @param {!ClipperLib.OutPt} p2
 * @param {!ClipperLib.OutPt} pt
 * @return {!ClipperLib.OutPt}
 */
ClipperLib.Clipper.prototype.InsertPolyPtBetween = function(p1, p2, pt) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @param {!ClipperLib.OutRec} outRec
 * @return {void}
 */
ClipperLib.Clipper.prototype.SetHoleState = function(e, outRec) {};

/**
 * @param {!ClipperLib.IntPoint} pt1
 * @param {!ClipperLib.IntPoint} pt2
 * @return {number}
 */
ClipperLib.Clipper.prototype.GetDx = function(pt1, pt2) {};

/**
 * @param {!ClipperLib.OutPt} btmPt1
 * @param {!ClipperLib.OutPt} btmPt2
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.FirstIsBottomPt = function(btmPt1, btmPt2) {};

/**
 * @param {!ClipperLib.OutPt} pp
 * @return {!ClipperLib.OutPt}
 */
ClipperLib.Clipper.prototype.GetBottomPt = function(pp) {};

/**
 * @param {!ClipperLib.OutRec} outRec1
 * @param {!ClipperLib.OutRec} outRec2
 * @return {!ClipperLib.OutRec}
 */
ClipperLib.Clipper.prototype.GetLowermostRec = function(outRec1, outRec2) {};

/**
 * @param {!ClipperLib.OutRec} outRec1
 * @param {!ClipperLib.OutRec} outRec2
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.Param1RightOfParam2 = function(outRec1, outRec2) {};

/**
 * @param {!ClipperLib.TEdge} e1
 * @param {!ClipperLib.TEdge} e2
 * @return {void}
 */
ClipperLib.Clipper.prototype.AppendPolygon = function(e1, e2) {};

/**
 * @param {!ClipperLib.OutPt} pp
 * @return {void}
 */
ClipperLib.Clipper.prototype.ReversePolyPtLinks = function(pp) {};

/**
 * @param {!ClipperLib.TEdge} edge1
 * @param {!ClipperLib.TEdge} edge2
 * @return {void}
 */
ClipperLib.Clipper.prototype.SwapSides = function(edge1, edge2) {};

/**
 * @param {!ClipperLib.TEdge} edge1
 * @param {!ClipperLib.TEdge} edge2
 * @return {void}
 */
ClipperLib.Clipper.prototype.SwapPolyIndexes = function(edge1, edge2) {};

/**
 * @param {!ClipperLib.TEdge} edge1
 * @param {!ClipperLib.TEdge} edge2
 * @param {!ClipperLib.OutPt} pt
 * @return {void}
 */
ClipperLib.Clipper.prototype.DoEdge1 = function(edge1, edge2, pt) {};

/**
 * @param {!ClipperLib.TEdge} edge1
 * @param {!ClipperLib.TEdge} edge2
 * @param {!ClipperLib.OutPt} pt
 * @return {void}
 */
ClipperLib.Clipper.prototype.DoEdge2 = function(edge1, edge2, pt) {};

/**
 * @param {!ClipperLib.TEdge} edge1
 * @param {!ClipperLib.TEdge} edge2
 * @param {!ClipperLib.OutPt} pt
 * @return {void}
 */
ClipperLib.Clipper.prototype.DoBothEdges = function(edge1, edge2, pt) {};

/**
 * @param {!ClipperLib.TEdge} e1
 * @param {!ClipperLib.TEdge} e2
 * @param {!ClipperLib.OutPt} pt
 * @param {ClipperLib.Protects} protects
 * @return {void}
 */
ClipperLib.Clipper.prototype.IntersectEdges = function(e1, e2, pt, protects) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @return {void}
 */
ClipperLib.Clipper.prototype.DeleteFromAEL = function(e) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @return {void}
 */
ClipperLib.Clipper.prototype.DeleteFromSEL = function(e) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @return {void}
 */
ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function(e) {};

/**
 * @return {void}
 */
ClipperLib.Clipper.prototype.ProcessHorizontals = function() {};

/**
 * @param {!ClipperLib.TEdge} horzEdge
 * @return {void}
 */
ClipperLib.Clipper.prototype.ProcessHorizontal = function(horzEdge) {};

/**
 * @param {!ClipperLib.TEdge} horzEdge
 * @param {!ClipperLib.IntPoint} XPos
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.IsTopHorz = function(horzEdge, XPos) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @param {!ClipperLib.TEdge} Direction
 * @return {!ClipperLib.TEdge}
 */
ClipperLib.Clipper.prototype.GetNextInAEL = function(e, Direction) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.IsMinima = function(e) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @param {number} Y
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.IsMaxima = function(e, Y) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @param {number} Y
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.IsIntermediate = function(e, Y) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @return {!ClipperLib.TEdge}
 */
ClipperLib.Clipper.prototype.GetMaximaPair = function(e) {};

/**
 * @param {number} botY
 * @param {number} topY
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.ProcessIntersections = function(botY, topY) {};

/**
 * @param {number} botY
 * @param {number} topY
 * @return {void}
 */
ClipperLib.Clipper.prototype.BuildIntersectList = function(botY, topY) {};

/**
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.FixupIntersections = function() {};

/**
 * @return {void}
 */
ClipperLib.Clipper.prototype.ProcessIntersectList = function() {};

/**
 * @param {number} a
 * @return {number}
 */
ClipperLib.Clipper.prototype.Round = function(a) {};

/**
 * @param {!ClipperLib.TEdge} edge
 * @param {number} currentY
 * @return {number}
 */
ClipperLib.Clipper.prototype.TopX = function(edge, currentY) {};

/**
 * @param {!ClipperLib.TEdge} e1
 * @param {!ClipperLib.TEdge} e2
 * @param {!ClipperLib.IntPoint} pt
 * @return {void}
 */
ClipperLib.Clipper.prototype.AddIntersectNode = function(e1, e2, pt) {};

/**
 * @param {!ClipperLib.IntersectNode} node1
 * @param {!ClipperLib.IntersectNode} node2
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.ProcessParam1BeforeParam2 = function(node1, node2) {};

/**
 * @param {!ClipperLib.IntersectNode} int1
 * @param {!ClipperLib.IntersectNode} int2
 * @return {void}
 */
ClipperLib.Clipper.prototype.SwapIntersectNodes = function(int1, int2) {};

/**
 * @param {!ClipperLib.TEdge} edge1
 * @param {!ClipperLib.TEdge} edge2
 * @param {!ClipperLib.IntPoint} ip
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.IntersectPoint = function(edge1, edge2, ip) {};

/**
 * @return {void}
 */
ClipperLib.Clipper.prototype.DisposeIntersectNodes = function() {};

/**
 * @param {number} topY
 * @return {void}
 */
ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function(topY) {};

/**
 * @param {!ClipperLib.TEdge} e
 * @param {number} topY
 * @return {void}
 */
ClipperLib.Clipper.prototype.DoMaxima = function(e, topY) {};

/**
 * @param {!ClipperLib.Polygons} polys
 * @return {void}
 */
ClipperLib.Clipper.prototype.ReversePolygons = function(polys) {};

/**
 * @param {!ClipperLib.Polygon} poly
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.Orientation = function(poly) {};

/**
 * @param {!ArrayLike<!ClipperLib.OutPt>} pts
 * @return {number}
 */
ClipperLib.Clipper.prototype.PointCount = function(pts) {};

/**
 * @param {!ClipperLib.Polygon} polyg
 * @return {void}
 */
ClipperLib.Clipper.prototype.BuildResult = function(polyg) {};

/**
 * @param {!ClipperLib.ExPolygon} polyg
 * @return {void}
 */
ClipperLib.Clipper.prototype.BuildResultEx = function(polyg) {};

/**
 * @param {!ClipperLib.OutPt} outRec
 * @return {void}
 */
ClipperLib.Clipper.prototype.FixupOutPolygon = function(outRec) {};

/**
 * @param {!ClipperLib.JoinRec} j
 * @param {!ClipperLib.IntPoint} p1
 * @param {!ClipperLib.IntPoint} p2
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.JoinPoints = function(j, p1, p2) {};

/**
 * @param {!ClipperLib.JoinRec} j
 * @param {!ClipperLib.JoinRec} pt
 * @param {number} startIdx
 * @return {void}
 */
ClipperLib.Clipper.prototype.FixupJoinRecs = function(j, pt, startIdx) {};

/**
 * @return {void}
 */
ClipperLib.Clipper.prototype.JoinCommonEdges = function() {};

/**
 * @param {!ArrayLike<!ClipperLib.IntPoint>} pts
 * @return {boolean}
 */
ClipperLib.Clipper.prototype.FullRangeNeeded = function(pts) {};

/**
 * @param {!ClipperLib.Polygon|!ClipperLib.OutRec} poly_or_outRec
 * @param {boolean=} UseFull64BitRange
 * @return {number}
 */
ClipperLib.Clipper.prototype.Area = function(poly_or_outRec, UseFull64BitRange) {};

/**
 * @param {!ClipperLib.IntPoint} pt
 * @param {!ClipperLib.IntPoint} a1
 * @param {!ClipperLib.IntPoint} a2
 * @param {number} r
 * @return {!ClipperLib.Polygon}
 */
ClipperLib.Clipper.prototype.BuildArc = function(pt, a1, a2, r) {};

/**
 * @param {!ClipperLib.IntPoint} pt1
 * @param {!ClipperLib.IntPoint} pt2
 * @return {!ClipperLib.DoublePoint}
 */
ClipperLib.Clipper.prototype.GetUnitNormal = function(pt1, pt2) {};

/**
 * @param {!ClipperLib.Polygon} poly
 * @param {number} delta
 * @param {ClipperLib.JoinType} jointype
 * @param {number} MiterLimit
 * @param {boolean} AutoFix
 * @return {!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>}
 */
ClipperLib.Clipper.prototype.OffsetPolygons = function(poly, delta, jointype, MiterLimit, AutoFix) {};

/**
 * @param {!ClipperLib.Polygon} poly
 * @param {ClipperLib.PolyFillType} fillType
 * @return {!ClipperLib.Polygon}
 */
ClipperLib.Clipper.prototype.SimplifyPolygon = function(poly, fillType) {};

/**
 * @param {!ClipperLib.Polygons} polys
 * @param {ClipperLib.PolyFillType} fillType
 * @return {!ClipperLib.Polygons}
 */
ClipperLib.Clipper.prototype.SimplifyPolygons = function(polys, fillType) {};

/**
 * @constructor
 * @struct
 * @param {number} x
 * @param {number} y
 */
ClipperLib.DoublePoint = function(x, y) {};
 /** @type {number} */
ClipperLib.DoublePoint.prototype.X;
 /** @type {number} */
ClipperLib.DoublePoint.prototype.Y;

/**
 * @constructor
 * @struct
 * @param {!ClipperLib.Polygons} pts
 * @param {{value: !ClipperLib.Polygons}} solution
 * @param {number} delta
 * @param {ClipperLib.JoinType} jointype
 * @param {number} MiterLimit
 * @param {boolean} AutoFix
 */
ClipperLib.PolyOffsetBuilder = function(pts, solution, delta, jointype, MiterLimit, AutoFix) {};
 /** @type {!ClipperLib.Polygons} */
ClipperLib.PolyOffsetBuilder.prototype.pts;
 /** @type {!ClipperLib.Polygon} */
ClipperLib.PolyOffsetBuilder.prototype.currentPoly;
 /** @type {!ArrayLike<!ClipperLib.IntPoint>} */
ClipperLib.PolyOffsetBuilder.prototype.normals;
 /** @type {number} */
ClipperLib.PolyOffsetBuilder.prototype.delta;
 /** @type {number} */
ClipperLib.PolyOffsetBuilder.prototype.m_R;
 /** @type {number} */
ClipperLib.PolyOffsetBuilder.prototype.m_i;
 /** @type {number} */
ClipperLib.PolyOffsetBuilder.prototype.m_j;
 /** @type {number} */
ClipperLib.PolyOffsetBuilder.prototype.m_k;
 /** @type {!ClipperLib.PolyOffsetBuilder} */
ClipperLib.PolyOffsetBuilder.prototype.botPt;

/**
 * @param {!ClipperLib.IntPoint} pt
 * @return {boolean}
 */
ClipperLib.PolyOffsetBuilder.prototype.UpdateBotPt = function(pt) {};

/**
 * @param {!ClipperLib.IntPoint} pt
 * @return {void}
 */
ClipperLib.PolyOffsetBuilder.prototype.AddPoint = function(pt) {};

/**
 * @param {number} mul
 * @return {void}
 */
ClipperLib.PolyOffsetBuilder.prototype.DoSquare = function(mul) {};

/**
 * @return {void}
 */
ClipperLib.PolyOffsetBuilder.prototype.DoMiter = function() {};

/**
 * @return {void}
 */
ClipperLib.PolyOffsetBuilder.prototype.DoRound = function() {};

/**
 * @param {string} message
 * @return {void}
 */
ClipperLib.Error = function(message) {};

/**
 * @param {(!ArrayLike<!ClipperLib.IntPoint>|!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>)} polygon
 * @return {(!ArrayLike<!ClipperLib.IntPoint>|!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>)}
 */
ClipperLib.Clone = function(polygon) {};

/**
 * @param {(!ArrayLike<!ClipperLib.IntPoint>|!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>)} polygon
 * @param {number} delta
 * @return {(!ArrayLike<!ClipperLib.IntPoint>|!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>)}
 */
ClipperLib.Clean = function(polygon, delta) {};

/**
 * @param {(!ArrayLike<!ClipperLib.IntPoint>|!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>)} polygon
 * @param {number} tolerance
 * @return {(!ArrayLike<!ClipperLib.IntPoint>|!ArrayLike<!ArrayLike<!ClipperLib.IntPoint>>)}
 */
ClipperLib.Lighten = function(polygon, tolerance) {};
