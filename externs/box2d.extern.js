/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/box2d/index.d.ts:
/** @const */
var Box2D = {};
/** @const */
Box2D.Common = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {number} rr Red value
 * @param {number} gg Green value
 * @param {number} bb Blue value
 * 
 */
Box2D.Common.b2Color = function(rr, gg, bb) {};
 /** @type {number} */
Box2D.Common.b2Color.prototype.r;
 /** @type {number} */
Box2D.Common.b2Color.prototype.g;
 /** @type {number} */
Box2D.Common.b2Color.prototype.b;
 /** @type {number} */
Box2D.Common.b2Color.prototype.color;

/**
 * Sets the Color to new RGB values.
 * @param {number} rr Red value
 * @param {number} gg Green value
 * @param {number} bb Blue value
 * 
 * @return {void}
 */
Box2D.Common.b2Color.prototype.Set = function(rr, gg, bb) {};
/**
 * @constructor
 * @struct
 */
Box2D.Common.b2Settings = function() {};
 /** @type {number} */
Box2D.Common.b2Settings.b2_aabbExtension;
 /** @type {number} */
Box2D.Common.b2Settings.b2_aabbMultiplier;
 /** @type {number} */
Box2D.Common.b2Settings.b2_angularSleepTolerance;
 /** @type {number} */
Box2D.Common.b2Settings.b2_angularSlop;
 /** @type {number} */
Box2D.Common.b2Settings.b2_contactBaumgarte;
 /** @type {number} */
Box2D.Common.b2Settings.b2_linearSleepTolerance;
 /** @type {number} */
Box2D.Common.b2Settings.b2_linearSlop;
 /** @type {number} */
Box2D.Common.b2Settings.b2_maxAngularCorrection;
 /** @type {number} */
Box2D.Common.b2Settings.b2_maxLinearCorrection;
 /** @type {number} */
Box2D.Common.b2Settings.b2_maxManifoldPoints;
 /** @type {number} */
Box2D.Common.b2Settings.b2_maxRotation;
 /** @type {number} */
Box2D.Common.b2Settings.b2_maxRotationSquared;
 /** @type {number} */
Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland;
 /** @type {number} */
Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland;
 /** @type {number} */
Box2D.Common.b2Settings.b2_maxTranslation;
 /** @type {number} */
Box2D.Common.b2Settings.b2_maxTranslationSquared;
 /** @type {number} */
Box2D.Common.b2Settings.b2_pi;
 /** @type {number} */
Box2D.Common.b2Settings.b2_polygonRadius;
 /** @type {number} */
Box2D.Common.b2Settings.b2_timeToSleep;
 /** @type {number} */
Box2D.Common.b2Settings.b2_toiSlop;
 /** @type {number} */
Box2D.Common.b2Settings.b2_velocityThreshold;
 /** @type {number} */
Box2D.Common.b2Settings.USHRT_MAX;
 /** @type {string} */
Box2D.Common.b2Settings.VERSION;

/**
 * b2Assert is used internally to handle assertions. By default, calls are commented out to save performance, so they serve more as documentation than anything else.
 * @param {boolean} a Asset an expression is true.
 * 
 * @return {void}
 */
Box2D.Common.b2Settings.b2Assert = function(a) {};

/**
 * Friction mixing law. Feel free to customize this.
 * Friction values are usually set between 0 and 1. (0 = no friction, 1 = high friction)
 * By default this is `return Math.sqrt(friction1, friction2);`
 * @param {number} friction1 Friction 1 to mix.
 * @param {number} friction2 Friction 2 to mix.
 * @return {number} The two frictions mixed as one value.
 * 
 */
Box2D.Common.b2Settings.b2MixFriction = function(friction1, friction2) {};

/**
 * Restitution mixing law. Feel free to customize this.  Restitution is used to make objects bounce.
 * Restitution values are usually set between 0 and 1. (0 = no bounce (inelastic), 1 = perfect bounce (perfectly elastic))
 * By default this is `return Math.Max(restitution1, restitution2);`
 * @param {number} restitution1 Restitution 1 to mix.
 * @param {number} restitution2 Restitution 2 to mix.
 * @return {number} The two restitutions mixed as one value.
 * 
 */
Box2D.Common.b2Settings.b2MixRestitution = function(restitution1, restitution2) {};
/** @const */
Box2D.Common.Math = {};

/**
 * @constructor
 * @struct
 * Empty constructor
 * 
 */
Box2D.Common.Math.b2Mat22 = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Common.Math.b2Mat22.prototype.col1;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Common.Math.b2Mat22.prototype.col2;

/**
 * Sets all internal matrix values to absolute values.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat22.prototype.Abs = function() {};

/**
 * Adds the two 2x2 matricies together and stores the result in this matrix.
 * @param {!Box2D.Common.Math.b2Mat22} m 2x2 matrix to add.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat22.prototype.AddM = function(m) {};

/**
 * Creates a copy of the matrix.
 * @return {!Box2D.Common.Math.b2Mat22} Copy of this 2x2 matrix.
 * 
 */
Box2D.Common.Math.b2Mat22.prototype.Copy = function() {};

/**
 * Creates a rotation 2x2 matrix from the given angle.
 * R(theta) = [ cos(theta)  -sin(theta) ]
 *            [ sin(theta)   cos(theta) ]
 * @param {number} angle Matrix angle (theta).
 * @return {!Box2D.Common.Math.b2Mat22} 2x2 matrix.
 * 
 */
Box2D.Common.Math.b2Mat22.FromAngle = function(angle) {};

/**
 * Creates a 2x2 matrix from two columns.
 * @param {!Box2D.Common.Math.b2Vec2} c1 Column 1 vector.
 * @param {!Box2D.Common.Math.b2Vec2} c2 Column 2 vector.
 * @return {!Box2D.Common.Math.b2Mat22} 2x2 matrix.
 * 
 */
Box2D.Common.Math.b2Mat22.FromVV = function(c1, c2) {};

/**
 * Gets the rotation matrix angle.
 * R(theta) = [ cos(theta)  -sin(theta) ]
 *            [ sin(theta)   cos(theta) ]
 * @return {number} The rotation matrix angle (theta).
 * 
 */
Box2D.Common.Math.b2Mat22.prototype.GetAngle = function() {};

/**
 * Compute the inverse of this matrix, such that inv(A) A = identity.
 * @param {!Box2D.Common.Math.b2Mat22} out Inverse matrix.
 * @return {!Box2D.Common.Math.b2Mat22} Inverse matrix.
 * 
 */
Box2D.Common.Math.b2Mat22.prototype.GetInverse = function(out) {};

/**
 * Sets the 2x2 rotation matrix from the given angle.
 * R(theta) = [ cos(theta)  -sin(theta) ]
 *            [ sin(theta)   cos(theta) ]
 * @param {number} angle Matrix angle (theta).
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat22.prototype.Set = function(angle) {};

/**
 * Sets the 2x2 matrix to identity.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat22.prototype.SetIdentity = function() {};

/**
 * Sets the 2x2 matrix from a 2x2 matrix.
 * @param {!Box2D.Common.Math.b2Mat22} m 2x2 matrix values.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat22.prototype.SetM = function(m) {};

/**
 * Sets the 2x2 matrix from 2 column vectors.
 * @param {!Box2D.Common.Math.b2Vec2} c1 Column 1 vector.
 * @param {!Box2D.Common.Math.b2Vec2} c2 Column 2 vector.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat22.prototype.SetVV = function(c1, c2) {};

/**
 * Sets the 2x2 matrix to all zeros.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat22.prototype.SetZero = function() {};

/**
 * TODO, has something to do with the determinant
 * @param {!Box2D.Common.Math.b2Vec2} out Solved vector
 * @param {number} bX
 * @param {number} bY
 * @return {!Box2D.Common.Math.b2Vec2} Solved vector
 * 
 */
Box2D.Common.Math.b2Mat22.prototype.Solve = function(out, bX, bY) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!Box2D.Common.Math.b2Vec3} c1 Column 1
 * @param {!Box2D.Common.Math.b2Vec3} c2 Column 2
 * @param {!Box2D.Common.Math.b2Vec3} c3 Column 3
 * 
 */
Box2D.Common.Math.b2Mat33 = function(c1, c2, c3) {};
 /** @type {!Box2D.Common.Math.b2Vec3} */
Box2D.Common.Math.b2Mat33.prototype.col1;
 /** @type {!Box2D.Common.Math.b2Vec3} */
Box2D.Common.Math.b2Mat33.prototype.col2;
 /** @type {!Box2D.Common.Math.b2Vec3} */
Box2D.Common.Math.b2Mat33.prototype.col3;

/**
 * Adds the two 3x3 matricies together and stores the result in this matrix.
 * @param {!Box2D.Common.Math.b2Mat33} m 3x3 matrix to add.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat33.prototype.AddM = function(m) {};

/**
 * Creates a copy of the matrix.
 * @return {!Box2D.Common.Math.b2Mat33} Copy of this 3x3 matrix.
 * 
 */
Box2D.Common.Math.b2Mat33.prototype.Copy = function() {};

/**
 * Sets the 3x3 matrix to identity.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat33.prototype.SetIdentity = function() {};

/**
 * Sets the 3x3 matrix from a 3x3 matrix.
 * @param {!Box2D.Common.Math.b2Mat33} m 3x3 matrix values.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat33.prototype.SetM = function(m) {};

/**
 * Sets the 3x3 matrix from 3 column vectors.
 * @param {!Box2D.Common.Math.b2Vec3} c1 Column 1 vector.
 * @param {!Box2D.Common.Math.b2Vec3} c2 Column 2 vector.
 * @param {!Box2D.Common.Math.b2Vec3} c3 Column 2 vector.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat33.prototype.SetVVV = function(c1, c2, c3) {};

/**
 * Sets the 3x3 matrix to all zeros.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Mat33.prototype.SetZero = function() {};

/**
 * TODO, has something to do with the determinant
 * @param {!Box2D.Common.Math.b2Vec2} out Solved vector
 * @param {number} bX
 * @param {number} bY
 * @return {!Box2D.Common.Math.b2Vec2} Solved vector
 * 
 */
Box2D.Common.Math.b2Mat33.prototype.Solve22 = function(out, bX, bY) {};

/**
 * TODO, has something to do with the determinant
 * @param {!Box2D.Common.Math.b2Vec3} out Solved vector
 * @param {number} bX
 * @param {number} bY
 * @param {number} bZ
 * @return {!Box2D.Common.Math.b2Vec3} Solved vector
 * 
 */
Box2D.Common.Math.b2Mat33.prototype.Solve33 = function(out, bX, bY, bZ) {};
/**
 * @constructor
 * @struct
 */
Box2D.Common.Math.b2Math = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Common.Math.b2Math.b2Vec2_zero;
 /** @type {!Box2D.Common.Math.b2Mat22} */
Box2D.Common.Math.b2Math.b2Mat22_identity;
 /** @type {!Box2D.Common.Math.b2Transform} */
Box2D.Common.Math.b2Math.b2Transform_identity;

/**
 * Determines if a number is valid.  A number is valid if it is finite.
 * @param {number} x Number to check for validity.
 * @return {boolean} True if x is valid, otherwise false.
 * 
 */
Box2D.Common.Math.b2Math.IsValid = function(x) {};

/**
 * Dot product of two vector 2s.
 * @param {!Box2D.Common.Math.b2Vec2} a Vector 2 to use in dot product.
 * @param {!Box2D.Common.Math.b2Vec2} b Vector 2 to use in dot product.
 * @return {number} Dot product of a and b.
 * 
 */
Box2D.Common.Math.b2Math.Dot = function(a, b) {};

/**
 * Cross product of two vector 2s.
 * @param {!Box2D.Common.Math.b2Vec2} a Vector 2 to use in cross product.
 * @param {!Box2D.Common.Math.b2Vec2} b Vector 2 to use in cross product.
 * @return {number} Cross product of a and b.
 * 
 */
Box2D.Common.Math.b2Math.CrossVV = function(a, b) {};

/**
 * Cross product of vector 2 and s.
 * @param {!Box2D.Common.Math.b2Vec2} a Vector 2 to use in cross product.
 * @param {number} s s value.
 * @return {!Box2D.Common.Math.b2Vec2} Cross product of a and s.
 * 
 */
Box2D.Common.Math.b2Math.CrossVF = function(a, s) {};

/**
 * Cross product of s and vector 2.
 * @param {number} s s value.
 * @param {!Box2D.Common.Math.b2Vec2} a Vector 2 to use in cross product.
 * @return {!Box2D.Common.Math.b2Vec2} Cross product of s and a.
 * 
 */
Box2D.Common.Math.b2Math.CrossFV = function(s, a) {};

/**
 * Multiply matrix and vector.
 * @param {!Box2D.Common.Math.b2Mat22} A Matrix.
 * @param {!Box2D.Common.Math.b2Vec2} v Vector.
 * @return {!Box2D.Common.Math.b2Vec2} Result.
 * 
 */
Box2D.Common.Math.b2Math.MulMV = function(A, v) {};

/**
 *
 * @param {!Box2D.Common.Math.b2Mat22} A
 * @param {!Box2D.Common.Math.b2Vec2} v
 * @return {!Box2D.Common.Math.b2Vec2} 
 * 
 */
Box2D.Common.Math.b2Math.MulTMV = function(A, v) {};

/**
 *
 * @param {!Box2D.Common.Math.b2Transform} T
 * @param {!Box2D.Common.Math.b2Vec2} v
 * @return {!Box2D.Common.Math.b2Vec2} 
 * 
 */
Box2D.Common.Math.b2Math.MulX = function(T, v) {};

/**
 *
 * @param {!Box2D.Common.Math.b2Transform} T
 * @param {!Box2D.Common.Math.b2Vec2} v
 * @return {!Box2D.Common.Math.b2Vec2} 
 * 
 */
Box2D.Common.Math.b2Math.MulXT = function(T, v) {};

/**
 * Adds two vectors.
 * @param {!Box2D.Common.Math.b2Vec2} a First vector.
 * @param {!Box2D.Common.Math.b2Vec2} b Second vector.
 * @return {!Box2D.Common.Math.b2Vec2} a + b.
 * 
 */
Box2D.Common.Math.b2Math.AddVV = function(a, b) {};

/**
 * Subtracts two vectors.
 * @param {!Box2D.Common.Math.b2Vec2} a First vector.
 * @param {!Box2D.Common.Math.b2Vec2} b Second vector.
 * @return {!Box2D.Common.Math.b2Vec2} a - b.
 * 
 */
Box2D.Common.Math.b2Math.SubtractVV = function(a, b) {};

/**
 * Calculates the distance between two vectors.
 * @param {!Box2D.Common.Math.b2Vec2} a First vector.
 * @param {!Box2D.Common.Math.b2Vec2} b Second vector.
 * @return {number} Distance between a and b.
 * 
 */
Box2D.Common.Math.b2Math.Distance = function(a, b) {};

/**
 * Calculates the squared distance between two vectors.
 * @param {!Box2D.Common.Math.b2Vec2} a First vector.
 * @param {!Box2D.Common.Math.b2Vec2} b Second vector.
 * @return {number} dist^2 between a and b.
 * 
 */
Box2D.Common.Math.b2Math.DistanceSquared = function(a, b) {};

/**
 *
 * @param {number} s
 * @param {!Box2D.Common.Math.b2Vec2} a
 * @return {!Box2D.Common.Math.b2Vec2} 
 * 
 */
Box2D.Common.Math.b2Math.MulFV = function(s, a) {};

/**
 *
 * @param {!Box2D.Common.Math.b2Mat22} A
 * @param {!Box2D.Common.Math.b2Mat22} B
 * @return {!Box2D.Common.Math.b2Mat22} 
 * 
 */
Box2D.Common.Math.b2Math.AddMM = function(A, B) {};

/**
 *
 * @param {!Box2D.Common.Math.b2Mat22} A
 * @param {!Box2D.Common.Math.b2Mat22} B
 * @return {!Box2D.Common.Math.b2Mat22} 
 * 
 */
Box2D.Common.Math.b2Math.MulMM = function(A, B) {};

/**
 *
 * @param {!Box2D.Common.Math.b2Mat22} A
 * @param {!Box2D.Common.Math.b2Mat22} B
 * @return {!Box2D.Common.Math.b2Mat22} 
 * 
 */
Box2D.Common.Math.b2Math.MulTMM = function(A, B) {};

/**
 * Creates an ABS number.
 * @param {number} a Number to ABS.
 * @return {number} Absolute value of a.
 * 
 */
Box2D.Common.Math.b2Math.Abs = function(a) {};

/**
 * Creates an ABS vector.
 * @param {!Box2D.Common.Math.b2Vec2} a Vector to ABS all values.
 * @return {!Box2D.Common.Math.b2Vec2} Vector with all positive values.
 * 
 */
Box2D.Common.Math.b2Math.AbsV = function(a) {};

/**
 * Creates an ABS matrix.
 * @param {!Box2D.Common.Math.b2Mat22} A Matrix to ABS all values.
 * @return {!Box2D.Common.Math.b2Mat22} Matrix with all positive values.
 * 
 */
Box2D.Common.Math.b2Math.AbsM = function(A) {};

/**
 * Determines the minimum number.
 * @param {number} a First number.
 * @param {number} b Second number.
 * @return {number} a or b depending on which is the minimum.
 * 
 */
Box2D.Common.Math.b2Math.Min = function(a, b) {};

/**
 * Determines the minimum vector.
 * @param {!Box2D.Common.Math.b2Vec2} a First vector.
 * @param {!Box2D.Common.Math.b2Vec2} b Second vector.
 * @return {!Box2D.Common.Math.b2Vec2} a or b depending on which is the minimum.
 * 
 */
Box2D.Common.Math.b2Math.MinV = function(a, b) {};

/**
 * Determines the max number.
 * @param {number} a First number.
 * @param {number} b Second number.
 * @return {number} a or b depending on which is the maximum.
 * 
 */
Box2D.Common.Math.b2Math.Max = function(a, b) {};

/**
 * Determines the max vector.
 * @param {!Box2D.Common.Math.b2Vec2} a First vector.
 * @param {!Box2D.Common.Math.b2Vec2} b Second vector.
 * @return {!Box2D.Common.Math.b2Vec2} a or b depending on which is the maximum.
 * 
 */
Box2D.Common.Math.b2Math.MaxV = function(a, b) {};

/**
 * Clamp a number to the range of low to high.
 * @param {number} a Number to clamp.
 * @param {number} low Low range.
 * @param {number} high High range.
 * @return {number} Number a clamped to range of low to high.
 * 
 */
Box2D.Common.Math.b2Math.Clamp = function(a, low, high) {};

/**
 * Clamps a vector to the range of low to high.
 * @param {!Box2D.Common.Math.b2Vec2} a Vector to clamp.
 * @param {!Box2D.Common.Math.b2Vec2} low Low range.
 * @param {!Box2D.Common.Math.b2Vec2} high High range.
 * @return {!Box2D.Common.Math.b2Vec2} Vector a clamped to range of low to high.
 * 
 */
Box2D.Common.Math.b2Math.ClampV = function(a, low, high) {};

/**
 * Swaps a and b objects.
 * @param {?} a a -> b.
 * @param {?} b b -> a.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Math.Swap = function(a, b) {};

/**
 * Generates a random number.
 * @return {number}
 */
Box2D.Common.Math.b2Math.Random = function() {};

/**
 * Returns a random number between lo and hi.
 * @param {number} lo Lowest random number.
 * @param {number} hi Highest random number.
 * @return {number} Number between lo and hi.
 * 
 */
Box2D.Common.Math.b2Math.RandomRange = function(lo, hi) {};

/**
 * Calculates the next power of 2 after the given number.
 * @param {number} x Number to start search for the next power of 2.
 * @return {number} The next number that is a power of 2.
 * 
 */
Box2D.Common.Math.b2Math.NextPowerOfTwo = function(x) {};

/**
 * Check if a number is a power of 2.
 * @param {number} x Number to check if it is a power of 2.
 * @return {boolean} True if x is a power of 2, otherwise false.
 * 
 */
Box2D.Common.Math.b2Math.IsPowerOfTwo = function(x) {};
/**
 * @constructor
 * @struct
 */
Box2D.Common.Math.b2Sweep = function() {};
 /** @type {number} */
Box2D.Common.Math.b2Sweep.prototype.a;
 /** @type {number} */
Box2D.Common.Math.b2Sweep.prototype.a0;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Common.Math.b2Sweep.prototype.c;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Common.Math.b2Sweep.prototype.c0;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Common.Math.b2Sweep.prototype.localCenter;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Common.Math.b2Sweep.prototype.t0;

/**
 * Advance the sweep forward, yielding a new initial state.
 * \@t The new initial time.
 * 
 * @param {number} t
 * @return {void}
 */
Box2D.Common.Math.b2Sweep.prototype.Advance = function(t) {};

/**
 * Creates a copy of the sweep.
 * 
 * @return {!Box2D.Common.Math.b2Sweep}
 */
Box2D.Common.Math.b2Sweep.prototype.Copy = function() {};

/**
 * Get the interpolated transform at a specific time.
 * @param {!Box2D.Common.Math.b2Transform} xf Transform at specified time, this is an out parameter.
 * @param {number} alpha Is a factor in [0,1], where 0 indicates t0.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Sweep.prototype.GetTransform = function(xf, alpha) {};

/**
 * Sets the sweep from a sweep.
 * @param {!Box2D.Common.Math.b2Sweep} other Sweep values to copy from.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Sweep.prototype.Set = function(other) {};

/**
 * @constructor
 * @struct
 * The default constructor does nothing (for performance).
 * @param {!Box2D.Common.Math.b2Vec2} pos Position
 * @param {!Box2D.Common.Math.b2Mat22} r Rotation
 * 
 */
Box2D.Common.Math.b2Transform = function(pos, r) {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Common.Math.b2Transform.prototype.position;
 /** @type {!Box2D.Common.Math.b2Mat22} */
Box2D.Common.Math.b2Transform.prototype.R;

/**
 * Calculate the angle that the rotation matrix represents.
 * @return {number} Rotation matrix angle.
 * 
 */
Box2D.Common.Math.b2Transform.prototype.GetAngle = function() {};

/**
 * Initialize using a position vector and rotation matrix.
 * @param {!Box2D.Common.Math.b2Vec2} pos Position
 * @param {!Box2D.Common.Math.b2Mat22} r Rotation
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Transform.prototype.Initialize = function(pos, r) {};

/**
 * Sets the transfrom from a transfrom.
 * @param {!Box2D.Common.Math.b2Transform} x Transform to copy values from.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Transform.prototype.Set = function(x) {};

/**
 * Set this to the identity transform.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Transform.prototype.SetIdentity = function() {};

/**
 * @constructor
 * @struct
 * Creates a new vector 2.
 * @param {number=} x x value, default = 0.
 * @param {number=} y y value, default = 0.
 * 
 */
Box2D.Common.Math.b2Vec2 = function(x, y) {};
 /** @type {number} */
Box2D.Common.Math.b2Vec2.prototype.x;
 /** @type {number} */
Box2D.Common.Math.b2Vec2.prototype.y;

/**
 * Sets x and y to absolute values.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.Abs = function() {};

/**
 * Adds the vector 2 to this vector 2.  The result is stored in this vector 2.
 * @param {!Box2D.Common.Math.b2Vec2} v Vector 2 to add.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.Add = function(v) {};

/**
 * Creates a copy of the vector 2.
 * @return {!Box2D.Common.Math.b2Vec2} Copy of this vector 2.
 * 
 */
Box2D.Common.Math.b2Vec2.prototype.Copy = function() {};

/**
 * Cross F V
 * @param {number} s 
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.CrossFV = function(s) {};

/**
 * Cross V F
 * @param {number} s 
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.CrossVF = function(s) {};

/**
 * Gets the negative of this vector 2.
 * @return {!Box2D.Common.Math.b2Vec2} Negative copy of this vector 2.
 * 
 */
Box2D.Common.Math.b2Vec2.prototype.GetNegative = function() {};

/**
 * True if the vector 2 is valid, otherwise false.  A valid vector has finite values.
 * @return {boolean} True if the vector 2 is valid, otherwise false.
 * 
 */
Box2D.Common.Math.b2Vec2.prototype.IsValid = function() {};

/**
 * Calculates the length of the vector 2.
 * @return {number} The length of the vector 2.
 * 
 */
Box2D.Common.Math.b2Vec2.prototype.Length = function() {};

/**
 * Calculates the length squared of the vector2.
 * @return {number} The length squared of the vector 2.
 * 
 */
Box2D.Common.Math.b2Vec2.prototype.LengthSquared = function() {};

/**
 * Creates a new vector 2 from the given values.
 * @param {number} x x value.
 * @param {number} y y value.
 * 
 * @return {!Box2D.Common.Math.b2Vec2}
 */
Box2D.Common.Math.b2Vec2.Make = function(x, y) {};

/**
 * Calculates which vector has the maximum values and sets this vector to those values.
 * @param {!Box2D.Common.Math.b2Vec2} b Vector 2 to compare for maximum values.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.MaxV = function(b) {};

/**
 * Calculates which vector has the minimum values and sets this vector to those values.
 * @param {!Box2D.Common.Math.b2Vec2} b Vector 2 to compare for minimum values.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.MinV = function(b) {};

/**
 * Matrix multiplication.  Stores the result in this vector 2.
 * @param {!Box2D.Common.Math.b2Mat22} A Matrix to muliply by.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.MulM = function(A) {};

/**
 * Vector multiplication.  Stores the result in this vector 2.
 * @param {number} a Value to multiple the vector's values by.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.Multiply = function(a) {};

/**
 * Dot product multiplication.  Stores the result in this vector 2.
 * @param {!Box2D.Common.Math.b2Mat22} A Matrix to multiply by.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.MulTM = function(A) {};

/**
 * Sets this vector 2 to its negative.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.NegativeSelf = function() {};

/**
 * Normalizes the vector 2 [0,1].
 * @return {number} Length.
 * 
 */
Box2D.Common.Math.b2Vec2.prototype.Normalize = function() {};

/**
 * Sets the vector 2.
 * @param {number=} x x value, default is 0.
 * @param {number=} y y value, default is 0.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.Set = function(x, y) {};

/**
 * Sets the vector 2 from a vector 2.
 * @param {!Box2D.Common.Math.b2Vec2} v Vector 2 to copy values from.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.SetV = function(v) {};

/**
 * Sets the vector 2 to zero values.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.SetZero = function() {};

/**
 * Subtracts the vector 2 from this vector 2.  The result is stored in this vector 2.
 * @param {!Box2D.Common.Math.b2Vec2} v Vector 2 to subtract.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec2.prototype.Subtract = function(v) {};

/**
 * @constructor
 * @struct
 * Construct using coordinates x,y,z.
 * @param {number=} x x value, default = 0.
 * @param {number=} y y value, default = 0.
 * @param {number=} z z value, default = 0.
 * 
 */
Box2D.Common.Math.b2Vec3 = function(x, y, z) {};
 /** @type {number} */
Box2D.Common.Math.b2Vec3.prototype.x;
 /** @type {number} */
Box2D.Common.Math.b2Vec3.prototype.y;
 /** @type {number} */
Box2D.Common.Math.b2Vec3.prototype.z;

/**
 * Adds the vector 3 to this vector 3.  The result is stored in this vector 3.
 * @param {!Box2D.Common.Math.b2Vec3} v Vector 3 to add.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec3.prototype.Add = function(v) {};

/**
 * Creates a copy of the vector 3.
 * @return {!Box2D.Common.Math.b2Vec3} Copy of this vector 3.
 * 
 */
Box2D.Common.Math.b2Vec3.prototype.Copy = function() {};

/**
 * Gets the negative of this vector 3.
 * @return {!Box2D.Common.Math.b2Vec3} Negative copy of this vector 3.
 * 
 */
Box2D.Common.Math.b2Vec3.prototype.GetNegative = function() {};

/**
 * Vector multiplication.  Stores the result in this vector 3.
 * @param {number} a Value to multiple the vector's values by.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec3.prototype.Multiply = function(a) {};

/**
 * Sets this vector 3 to its negative.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec3.prototype.NegativeSelf = function() {};

/**
 * Sets the vector 3.
 * @param {number=} x x value, default is 0.
 * @param {number=} y y value, default is 0.
 * @param {number=} z z value, default is 0.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec3.prototype.Set = function(x, y, z) {};

/**
 * Sets the vector 3 from a vector 3.
 * @param {!Box2D.Common.Math.b2Vec3} v Vector 3 to copy values from.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec3.prototype.SetV = function(v) {};

/**
 * Sets the vector 3 to zero values.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec3.prototype.SetZero = function() {};

/**
 * Subtracts the vector 3 from this vector 3.  The result is stored in this vector 3.
 * @param {!Box2D.Common.Math.b2Vec3} v Vector 3 to subtract.
 * 
 * @return {void}
 */
Box2D.Common.Math.b2Vec3.prototype.Subtract = function(v) {};
/** @const */
Box2D.Collision = {};
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2AABB = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2AABB.prototype.lowerBound;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2AABB.prototype.upperBound;

/**
 * Combines two AABBs into one with max values for upper bound and min values for lower bound.
 * @param {!Box2D.Collision.b2AABB} aabb1 First AABB to combine.
 * @param {!Box2D.Collision.b2AABB} aabb2 Second AABB to combine.
 * @return {!Box2D.Collision.b2AABB} New AABB with max values from aabb1 and aabb2.
 * 
 */
Box2D.Collision.b2AABB.Combine = function(aabb1, aabb2) {};

/**
 * Combines two AABBs into one with max values for upper bound and min values for lower bound.  The result is stored in this AABB.
 * @param {!Box2D.Collision.b2AABB} aabb1 First AABB to combine.
 * @param {!Box2D.Collision.b2AABB} aabb2 Second AABB to combine.
 * 
 * @return {void}
 */
Box2D.Collision.b2AABB.prototype.Combine = function(aabb1, aabb2) {};

/**
 * Determines if an AABB is contained within this one.
 * @param {!Box2D.Collision.b2AABB} aabb AABB to see if it is contained.
 * @return {boolean} True if aabb is contained, otherwise false.
 * 
 */
Box2D.Collision.b2AABB.prototype.Contains = function(aabb) {};

/**
 * Gets the center of the AABB.
 * @return {!Box2D.Common.Math.b2Vec2} Center of this AABB.
 * 
 */
Box2D.Collision.b2AABB.prototype.GetCenter = function() {};

/**
 * Gets the extents of the AABB (half-widths).
 * @return {!Box2D.Common.Math.b2Vec2} Extents of this AABB.
 * 
 */
Box2D.Collision.b2AABB.prototype.GetExtents = function() {};

/**
 * Verify that the bounds are sorted.
 * @return {boolean} True if the bounds are sorted, otherwise false.
 * 
 */
Box2D.Collision.b2AABB.prototype.IsValid = function() {};

/**
 * Perform a precise raycast against this AABB.
 * @param {!Box2D.Collision.b2RayCastOutput} output Ray cast output values.
 * @param {!Box2D.Collision.b2RayCastInput} input Ray cast input values.
 * @return {boolean} True if the ray cast hits this AABB, otherwise false.
 * 
 */
Box2D.Collision.b2AABB.prototype.RayCast = function(output, input) {};

/**
 * Tests if another AABB overlaps this AABB.
 * @param {!Box2D.Collision.b2AABB} other Other AABB to test for overlap.
 * @return {boolean} True if other overlaps this AABB, otherwise false.
 * 
 */
Box2D.Collision.b2AABB.prototype.TestOverlap = function(other) {};

/**
 * @constructor
 * @struct
 * Creates a new Contact ID.
 * 
 */
Box2D.Collision.b2ContactID = function() {};
 /** @type {!Box2D.Collision.Features} */
Box2D.Collision.b2ContactID.prototype.features;
 /** @type {number} */
Box2D.Collision.b2ContactID.prototype.Key;

/**
 * Copies the Contact ID.
 * @return {!Box2D.Collision.b2ContactID} Copied Contact ID.
 * 
 */
Box2D.Collision.b2ContactID.prototype.Copy = function() {};

/**
 * Sets the Contact ID from a Contact ID.
 * @param {!Box2D.Collision.b2ContactID} id The Contact ID to copy values from.
 * 
 * @return {void}
 */
Box2D.Collision.b2ContactID.prototype.Set = function(id) {};
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2ContactPoint = function() {};
 /** @type {number} */
Box2D.Collision.b2ContactPoint.prototype.friction;
 /** @type {!Box2D.Collision.b2ContactID} */
Box2D.Collision.b2ContactPoint.prototype.id;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2ContactPoint.prototype.normal;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2ContactPoint.prototype.position;
 /** @type {number} */
Box2D.Collision.b2ContactPoint.prototype.restitution;
 /** @type {number} */
Box2D.Collision.b2ContactPoint.prototype.separation;
 /** @type {!Box2D.Collision.Shapes.b2Shape} */
Box2D.Collision.b2ContactPoint.prototype.shape1;
 /** @type {!Box2D.Collision.Shapes.b2Shape} */
Box2D.Collision.b2ContactPoint.prototype.shape2;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2ContactPoint.prototype.velocity;
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2DistanceInput = function() {};
 /** @type {!Box2D.Collision.b2DistanceProxy} */
Box2D.Collision.b2DistanceInput.prototype.proxyA;
 /** @type {!Box2D.Collision.b2DistanceProxy} */
Box2D.Collision.b2DistanceInput.prototype.proxyB;
 /** @type {!Box2D.Common.Math.b2Transform} */
Box2D.Collision.b2DistanceInput.prototype.transformA;
 /** @type {!Box2D.Common.Math.b2Transform} */
Box2D.Collision.b2DistanceInput.prototype.transformB;
 /** @type {boolean} */
Box2D.Collision.b2DistanceInput.prototype.useRadii;
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2DistanceOutput = function() {};
 /** @type {number} */
Box2D.Collision.b2DistanceOutput.prototype.distance;
 /** @type {number} */
Box2D.Collision.b2DistanceOutput.prototype.iterations;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2DistanceOutput.prototype.pointA;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2DistanceOutput.prototype.pointB;
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2DistanceProxy = function() {};
 /** @type {number} */
Box2D.Collision.b2DistanceProxy.prototype.m_count;
 /** @type {number} */
Box2D.Collision.b2DistanceProxy.prototype.m_radius;
 /** @type {!Array<!Box2D.Common.Math.b2Vec2>} */
Box2D.Collision.b2DistanceProxy.prototype.m_vertices;

/**
 * Get the supporting vertex index in the given direction.
 * @param {!Box2D.Common.Math.b2Vec2} d Direction to look for the supporting vertex.
 * @return {number} Supporting vertex index.
 * 
 */
Box2D.Collision.b2DistanceProxy.prototype.GetSupport = function(d) {};

/**
 * Get the supporting vertex in the given direction.
 * @param {!Box2D.Common.Math.b2Vec2} d Direction to look for the supporting vertex.
 * @return {!Box2D.Common.Math.b2Vec2} Supporting vertex.
 * 
 */
Box2D.Collision.b2DistanceProxy.prototype.GetSupportVertex = function(d) {};

/**
 * Get a vertex by index.  Used by b2Distance.
 * @param {number} index Vetex's index.
 * @return {!Box2D.Common.Math.b2Vec2} Vertex at the given index.
 * 
 */
Box2D.Collision.b2DistanceProxy.prototype.GetVertex = function(index) {};

/**
 * Get the vertex count.
 * @return {number} The number of vertices. (m_vertices.length)
 * 
 */
Box2D.Collision.b2DistanceProxy.prototype.GetVertexCount = function() {};

/**
 * Initialize the proxy using the given shape. The shape must remain in scope while the proxy is in use.
 * @param {!Box2D.Collision.Shapes.b2Shape} shape Shape to initialize the distance proxy.
 * 
 * @return {void}
 */
Box2D.Collision.b2DistanceProxy.prototype.Set = function(shape) {};

/**
 * @constructor
 * @struct
 * Constructing the tree initializes the node pool.
 * 
 */
Box2D.Collision.b2DynamicTree = function() {};

/**
 * Create a proxy. Provide a tight fitting AABB and a userData.
 * @param {!Box2D.Collision.b2AABB} aabb AABB.
 * @param {?} userData
 * @return {!Box2D.Collision.b2DynamicTreeNode} Dynamic tree node.
 * 
 */
Box2D.Collision.b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {};

/**
 * Destroy a proxy. This asserts if the id is invalid.
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy Proxy to destroy.
 * 
 * @return {void}
 */
Box2D.Collision.b2DynamicTree.prototype.DestroyProxy = function(proxy) {};

/**
 * Gets the Fat AABB for the proxy.
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy Proxy to retrieve Fat AABB.
 * @return {!Box2D.Collision.b2AABB} Fat AABB for proxy.
 * 
 */
Box2D.Collision.b2DynamicTree.prototype.GetFatAABB = function(proxy) {};

/**
 * Get user data from a proxy. Returns null if the proxy is invalid.
 * Cast to your type on return.
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy Proxy to retrieve user data from.
 * @return {?} User data for proxy or null if proxy is invalid.
 * 
 */
Box2D.Collision.b2DynamicTree.prototype.GetUserData = function(proxy) {};

/**
 * Move a proxy with a swept AABB. If the proxy has moved outside of its fattened AABB, then the proxy is removed from the tree and re-inserted. Otherwise the function returns immediately.
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy Proxy to move.
 * @param {!Box2D.Collision.b2AABB} aabb Swept AABB.
 * @param {!Box2D.Common.Math.b2Vec2} displacement Extra AABB displacement.
 * 
 * @return {boolean}
 */
Box2D.Collision.b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {};

/**
 * Query an AABB for overlapping proxies. The callback is called for each proxy that overlaps the supplied AABB. The callback should match function signature fuction callback(proxy:b2DynamicTreeNode):Boolean and should return false to trigger premature termination.
 * \@aabb Proxies are query for overlap on this AABB.
 * 
 * @param {function(!Box2D.Collision.b2DynamicTreeNode): boolean} callback Called for each proxy that overlaps the supplied AABB.
 * 	param proxy Proxy overlapping the supplied AABB.
 * @param {!Box2D.Collision.b2AABB} aabb
 * @return {void}
 */
Box2D.Collision.b2DynamicTree.prototype.Query = function(callback, aabb) {};

/**
 * Ray-cast against the proxies in the tree. This relies on the callback to perform a exact ray-cast in the case were the proxy contains a shape. The callback also performs the any collision filtering. This has performance roughly equal to k log(n), where k is the number of collisions and n is the number of proxies in the tree.
 * @param {function(!Box2D.Collision.b2RayCastInput, !Box2D.Collision.b2DynamicTreeNode): number} callback Called for each proxy that is hit by the ray.
 * 	param input Ray cast input data.
 * 	param proxy The proxy hit by the ray cast.
 * 	return Return value is the new value for maxFraction.
 * @param {!Box2D.Collision.b2RayCastInput} input Ray cast input data.  Query all proxies along this ray cast.
 * 
 * @return {void}
 */
Box2D.Collision.b2DynamicTree.prototype.RayCast = function(callback, input) {};

/**
 * Perform some iterations to re-balance the tree.
 * @param {number} iterations Number of rebalance iterations to perform.
 * 
 * @return {void}
 */
Box2D.Collision.b2DynamicTree.prototype.Rebalance = function(iterations) {};

/**
 * @constructor
 * @struct
 * Creates the dynamic tree broad phase.
 * 
 */
Box2D.Collision.b2DynamicTreeBroadPhase = function() {};

/**
 * @see IBroadPhase.CreateProxy
 * 
 * @param {!Box2D.Collision.b2AABB} aabb
 * @param {?} userData
 * @return {!Box2D.Collision.b2DynamicTreeNode}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.CreateProxy = function(aabb, userData) {};

/**
 * @see IBroadPhase.DestroyProxy
 * 
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy
 * @return {void}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.DestroyProxy = function(proxy) {};

/**
 * @see IBroadPhase.GetFatAABB
 * 
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy
 * @return {!Box2D.Collision.b2AABB}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.GetFatAABB = function(proxy) {};

/**
 * @see IBroadPhase.GetProxyCount
 * 
 * @return {number}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.GetProxyCount = function() {};

/**
 * @see IBroadPhase.GetUserData
 * 
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy
 * @return {?}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.GetUserData = function(proxy) {};

/**
 * @see IBroadPhase.MoveProxy
 * 
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy
 * @param {!Box2D.Collision.b2AABB} aabb
 * @param {!Box2D.Common.Math.b2Vec2} displacement
 * @return {void}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {};

/**
 * @see IBroadPhase.Query
 * 
 * @param {function(!Box2D.Collision.b2DynamicTreeNode): boolean} callback
 * @param {!Box2D.Collision.b2AABB} aabb
 * @return {void}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.Query = function(callback, aabb) {};

/**
 * @see IBroadPhase.RayCast
 * 
 * @param {function(!Box2D.Collision.b2RayCastInput, !Box2D.Collision.b2DynamicTreeNode): number} callback
 * @param {!Box2D.Collision.b2RayCastInput} input
 * @return {void}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.RayCast = function(callback, input) {};

/**
 * @see IBroadPhase.Rebalance
 * 
 * @param {number} iterations
 * @return {void}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.Rebalance = function(iterations) {};

/**
 * Tests if two proxies overlap.
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxyA First proxy to test.
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxyB Second proxy to test.
 * @return {boolean} True if the proxyA and proxyB overlap with Fat AABBs, otherwise false.
 * 
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {};

/**
 * Update the pairs. This results in pair callbacks. This can only add pairs.
 * @param {function(?, ?): void} callback Called for all new proxy pairs.
 * 	param userDataA Proxy A in the pair user data.
 * 	param userDataB Proxy B in the pair user data.
 * 
 * @return {void}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.UpdatePairs = function(callback) {};

/**
 * Validates the dynamic tree.
 * NOTE: this says "todo" in the current Box2DFlash code.
 * 
 * @return {void}
 */
Box2D.Collision.b2DynamicTreeBroadPhase.prototype.Validate = function() {};
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2DynamicTreeNode = function() {};

/**
 * @constructor
 * @struct
 * Creates a new manifold.
 * 
 */
Box2D.Collision.b2Manifold = function() {};
 /** @type {number} */
Box2D.Collision.b2Manifold.e_circles;
 /** @type {number} */
Box2D.Collision.b2Manifold.e_faceA;
 /** @type {number} */
Box2D.Collision.b2Manifold.e_faceB;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2Manifold.prototype.m_localPlaneNormal;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2Manifold.prototype.m_localPoint;
 /** @type {number} */
Box2D.Collision.b2Manifold.prototype.m_pointCount;
 /** @type {!Array<!Box2D.Collision.b2ManifoldPoint>} */
Box2D.Collision.b2Manifold.prototype.m_points;
 /** @type {number} */
Box2D.Collision.b2Manifold.prototype.m_type;

/**
 * Copies the manifold.
 * @return {!Box2D.Collision.b2Manifold} Copy of this manifold.
 * 
 */
Box2D.Collision.b2Manifold.prototype.Copy = function() {};

/**
 * Resets this manifold.
 * 
 * @return {void}
 */
Box2D.Collision.b2Manifold.prototype.Reset = function() {};

/**
 * Sets this manifold from another manifold.
 * @param {!Box2D.Collision.b2Manifold} m Manifold to copy values from.
 * 
 * @return {void}
 */
Box2D.Collision.b2Manifold.prototype.Set = function(m) {};

/**
 * @constructor
 * @struct
 * Creates a new manifold point.
 * 
 */
Box2D.Collision.b2ManifoldPoint = function() {};
 /** @type {!Box2D.Collision.b2ContactID} */
Box2D.Collision.b2ManifoldPoint.prototype.m_id;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2ManifoldPoint.prototype.m_localpoint;
 /** @type {number} */
Box2D.Collision.b2ManifoldPoint.prototype.m_normalImpulse;
 /** @type {number} */
Box2D.Collision.b2ManifoldPoint.prototype.m_tangentImpulse;

/**
 * Resets this manifold point.
 * 
 * @return {void}
 */
Box2D.Collision.b2ManifoldPoint.prototype.Reset = function() {};

/**
 * Sets this manifold point from a manifold point.
 * @param {!Box2D.Collision.b2ManifoldPoint} m The manifold point to copy values from.
 * 
 * @return {void}
 */
Box2D.Collision.b2ManifoldPoint.prototype.Set = function(m) {};
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2OBB = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2OBB.prototype.center;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2OBB.prototype.extents;
 /** @type {!Box2D.Common.Math.b2Mat22} */
Box2D.Collision.b2OBB.prototype.R;

/**
 * @constructor
 * @struct
 * Creates a new ray cast input.
 * @param {!Box2D.Common.Math.b2Vec2=} p1 Start point of the ray, default = null.
 * @param {!Box2D.Common.Math.b2Vec2=} p2 End point of the ray, default = null.
 * @param {number=} maxFraction Truncate the ray to reach up to this fraction from p1 to p2.
 * 
 */
Box2D.Collision.b2RayCastInput = function(p1, p2, maxFraction) {};
 /** @type {number} */
Box2D.Collision.b2RayCastInput.prototype.maxFraction;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2RayCastInput.prototype.p1;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2RayCastInput.prototype.p2;
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2RayCastOutput = function() {};
 /** @type {number} */
Box2D.Collision.b2RayCastOutput.prototype.fraction;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2RayCastOutput.prototype.normal;
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2Segment = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2Segment.prototype.p1;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2Segment.prototype.p2;

/**
 * Extends or clips the segment so that it's ends lie on the boundary of the AABB.
 * @param {!Box2D.Collision.b2AABB} aabb AABB to extend/clip the segement.
 * 
 * @return {void}
 */
Box2D.Collision.b2Segment.prototype.Extend = function(aabb) {};

/**
 * See Extend, this works on the ending point.
 * @param {!Box2D.Collision.b2AABB} aabb AABB to extend/clip the ending point.
 * 
 * @return {void}
 */
Box2D.Collision.b2Segment.prototype.ExtendBackward = function(aabb) {};

/**
 * See Extend, this works on the starting point.
 * @param {!Box2D.Collision.b2AABB} aabb AABB to extend/clip the starting point.
 * 
 * @return {void}
 */
Box2D.Collision.b2Segment.prototype.ExtendForward = function(aabb) {};

/**
 * Ray cast against this segment with another segment.
 * @param {!Array<number>} lambda returns the hit fraction. You can use this to compute the contact point * p = (1 - lambda) * segment.p1 + lambda * segment.p2 * \@normal Normal at the contact point.  If there is no intersection, the normal is not set.
 * @param {!Box2D.Common.Math.b2Vec2} normal
 * @param {!Box2D.Collision.b2Segment} segment Defines the begining and end point of the ray cast.
 * @param {number} maxLambda a number typically in the range [0,1].
 * @return {boolean} True if there is an intersection, otherwise false.
 * 
 */
Box2D.Collision.b2Segment.prototype.TestSegment = function(lambda, normal, segment, maxLambda) {};
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2SimplexCache = function() {};
 /** @type {number} */
Box2D.Collision.b2SimplexCache.prototype.count;
 /** @type {!Array<number>} */
Box2D.Collision.b2SimplexCache.prototype.indexA;
 /** @type {!Array<number>} */
Box2D.Collision.b2SimplexCache.prototype.indexB;
 /** @type {number} */
Box2D.Collision.b2SimplexCache.prototype.metric;
/**
 * @constructor
 * @struct
 */
Box2D.Collision.b2TOIInput = function() {};
 /** @type {!Box2D.Collision.b2DistanceProxy} */
Box2D.Collision.b2TOIInput.prototype.proxyA;
 /** @type {!Box2D.Collision.b2DistanceProxy} */
Box2D.Collision.b2TOIInput.prototype.proxyB;
 /** @type {!Box2D.Common.Math.b2Sweep} */
Box2D.Collision.b2TOIInput.prototype.sweepA;
 /** @type {!Box2D.Common.Math.b2Sweep} */
Box2D.Collision.b2TOIInput.prototype.sweepB;
 /** @type {number} */
Box2D.Collision.b2TOIInput.prototype.tolerance;

/**
 * @constructor
 * @struct
 * Creates a new b2WorldManifold.
 * 
 */
Box2D.Collision.b2WorldManifold = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.b2WorldManifold.prototype.m_normal;
 /** @type {!Array<!Box2D.Common.Math.b2Vec2>} */
Box2D.Collision.b2WorldManifold.prototype.m_points;

/**
 * Evaluate the manifold with supplied transforms. This assumes modest motion from the original state. This does not change the point count, impulses, etc. The radii must come from the shapes that generated the manifold.
 * @param {!Box2D.Collision.b2Manifold} manifold Manifold to evaluate.
 * @param {!Box2D.Common.Math.b2Transform} xfA A transform.
 * @param {number} radiusA A radius.
 * @param {!Box2D.Common.Math.b2Transform} xfB B transform.
 * @param {number} radiusB B radius.
 * 
 * @return {void}
 */
Box2D.Collision.b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {};
/**
 * @constructor
 * @struct
 */
Box2D.Collision.Features = function() {};
 /** @type {number} */
Box2D.Collision.Features.prototype.flip;
 /** @type {number} */
Box2D.Collision.Features.prototype.incidentEdge;
 /** @type {number} */
Box2D.Collision.Features.prototype.incidentVertex;
 /** @type {number} */
Box2D.Collision.Features.prototype.referenceEdge;
/**
 * @record
 * @struct
 */
Box2D.Collision.IBroadPhase = function() {};

/**
 * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs is called.
 * @param {!Box2D.Collision.b2AABB} aabb Proxy Fat AABB.
 * @param {?} userData User defined data.
 * @return {!Box2D.Collision.b2DynamicTreeNode} Proxy created from aabb and userData.
 * 
 */
Box2D.Collision.IBroadPhase.prototype.CreateProxy = function(aabb, userData) {};

/**
 * Destroy a proxy. It is up to the client to remove any pairs.
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy Proxy to destroy.
 * 
 * @return {void}
 */
Box2D.Collision.IBroadPhase.prototype.DestroyProxy = function(proxy) {};

/**
 * Get the Fat AABB for a proxy.
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy Proxy to retrieve the Fat AABB.
 * 
 * @return {!Box2D.Collision.b2AABB}
 */
Box2D.Collision.IBroadPhase.prototype.GetFatAABB = function(proxy) {};

/**
 * Get the number of proxies.
 * @return {number} Number of proxies.
 * 
 */
Box2D.Collision.IBroadPhase.prototype.GetProxyCount = function() {};

/**
 * Get user data from a proxy. Returns null if the proxy is invalid.
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy Proxy to retrieve user data from.
 * @return {?} Gets the user data from proxy, or null if the proxy is invalid.
 * 
 */
Box2D.Collision.IBroadPhase.prototype.GetUserData = function(proxy) {};

/**
 * Call MoveProxy as many times as you like, then when you are done call UpdatePairs to finalized the proxy pairs (for your time step).
 * @param {!Box2D.Collision.b2DynamicTreeNode} proxy Proxy to move.
 * @param {!Box2D.Collision.b2AABB} aabb Swept AABB.
 * @param {!Box2D.Common.Math.b2Vec2} displacement Extra AABB displacement.
 * 
 * @return {void}
 */
Box2D.Collision.IBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {};

/**
 * Query an AABB for overlapping proxies. The callback is called for each proxy that overlaps the supplied AABB. The callback should match function signature fuction callback(proxy:b2DynamicTreeNode):Boolean and should return false to trigger premature termination.
 * @param {function(!Box2D.Collision.b2DynamicTreeNode): boolean} callback Called for each proxy that overlaps the supplied AABB.
 * 	param proxy Proxy overlapping the supplied AABB.
 * @param {!Box2D.Collision.b2AABB} aabb Proxies are query for overlap on this AABB.
 * 
 * @return {void}
 */
Box2D.Collision.IBroadPhase.prototype.Query = function(callback, aabb) {};

/**
 * Ray-cast against the proxies in the tree. This relies on the callback to perform a exact ray-cast in the case were the proxy contains a shape. The callback also performs the any collision filtering. This has performance roughly equal to k log(n), where k is the number of collisions and n is the number of proxies in the tree.
 * @param {function(!Box2D.Collision.b2RayCastInput, !Box2D.Collision.b2DynamicTreeNode): number} callback Called for each proxy that is hit by the ray.
 * 	param input Ray cast input data.
 * 	param proxy The proxy hit by the ray cast.
 * 	param return Return value is the new value for maxFraction.
 * @param {!Box2D.Collision.b2RayCastInput} input Ray cast input data.  Query all proxies along this ray cast.
 * 
 * @return {void}
 */
Box2D.Collision.IBroadPhase.prototype.RayCast = function(callback, input) {};

/**
 * Perform some iterations to re-balance the tree.
 * @param {number} iterations Number of rebalance iterations to perform.
 * 
 * @return {void}
 */
Box2D.Collision.IBroadPhase.prototype.Rebalance = function(iterations) {};
/** @const */
Box2D.Collision.Shapes = {};

/**
 * @constructor
 * @struct
 * Creates a new circle shape.
 * @param {number=} radius Circle radius.
 * 
 */
Box2D.Collision.Shapes.b2CircleShape = function(radius) {};

/**
 * Given a transform, compute the associated axis aligned bounding box for this shape.
 * @param {!Box2D.Collision.b2AABB} aabb Calculated AABB, this argument is `out`.
 * @param {!Box2D.Common.Math.b2Transform} xf Transform to calculate the AABB.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.ComputeAABB = function(aabb, xf) {};

/**
 * Compute the mass properties of this shape using its dimensions and density. The inertia tensor is computed about the local origin, not the centroid.
 * @param {!Box2D.Collision.Shapes.b2MassData} massData Calculate the mass, this argument is `out`.
 * @param {number} density 
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.ComputeMass = function(massData, density) {};

/**
 * Compute the volume and centroid of this shape intersected with a half plane
 * @param {!Box2D.Common.Math.b2Vec2} normal The surface normal.
 * @param {number} offset The surface offset along the normal.
 * @param {!Box2D.Common.Math.b2Transform} xf The shape transform.
 * @param {!Box2D.Common.Math.b2Vec2} c The centroid, this argument is `out`.
 * 
 * @return {number}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {};

/**
 * Copies the circle shape.
 * @return {!Box2D.Collision.Shapes.b2CircleShape} Copy of this circle shape.
 * 
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.Copy = function() {};

/**
 * Get the local position of this circle in its parent body.
 * @return {!Box2D.Common.Math.b2Vec2} This circle's local position.
 * 
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.GetLocalPosition = function() {};

/**
 * Get the radius of the circle.
 * @return {number} This circle's radius.
 * 
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.GetRadius = function() {};

/**
 * Cast a ray against this shape.
 * @param {!Box2D.Collision.b2RayCastOutput} output Ray cast results, this argument is `out`.
 * @param {!Box2D.Collision.b2RayCastInput} input Ray cast input parameters.
 * @param {!Box2D.Common.Math.b2Transform} transform The transform to be applied to the shape.
 * @return {boolean} True if the ray hits the shape, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.RayCast = function(output, input, transform) {};

/**
 * Set the circle shape values from another shape.
 * @param {!Box2D.Collision.Shapes.b2CircleShape} other The other circle shape to copy values from.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.Set = function(other) {};

/**
 * Set the local position of this circle in its parent body.
 * @param {!Box2D.Common.Math.b2Vec2} position The new local position of this circle.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.SetLocalPosition = function(position) {};

/**
 * Set the radius of the circle.
 * @param {number} radius The new radius of the circle.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.SetRadius = function(radius) {};

/**
 * Test a point for containment in this shape. This only works for convex shapes.
 * @param {!Box2D.Common.Math.b2Transform} xf Shape world transform.
 * @param {!Box2D.Common.Math.b2Vec2} p Point to test against, in world coordinates.
 * @return {boolean} True if the point is in this shape, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.TestPoint = function(xf, p) {};

/**
 * @constructor
 * @struct
 * Creates a new edge chain def.
 * 
 */
Box2D.Collision.Shapes.b2EdgeChainDef = function() {};
 /** @type {boolean} */
Box2D.Collision.Shapes.b2EdgeChainDef.prototype.isALoop;
 /** @type {number} */
Box2D.Collision.Shapes.b2EdgeChainDef.prototype.vertexCount;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.Shapes.b2EdgeChainDef.prototype.vertices;

/**
 * @constructor
 * @struct
 * Creates a new edge shape.
 * @param {!Box2D.Common.Math.b2Vec2} v1 First vertex
 * @param {!Box2D.Common.Math.b2Vec2} v2 Second vertex
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape = function(v1, v2) {};

/**
 * Given a transform, compute the associated axis aligned bounding box for this shape.
 * @param {!Box2D.Collision.b2AABB} aabb Calculated AABB, this argument is `out`.
 * @param {!Box2D.Common.Math.b2Transform} xf Transform to calculate the AABB.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.ComputeAABB = function(aabb, xf) {};

/**
 * Compute the mass properties of this shape using its dimensions and density. The inertia tensor is computed about the local origin, not the centroid.
 * @param {!Box2D.Collision.Shapes.b2MassData} massData Calculate the mass, this argument is `out`.
 * 
 * @param {number} density
 * @return {void}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.ComputeMass = function(massData, density) {};

/**
 * Compute the volume and centroid of this shape intersected with a half plane
 * @param {!Box2D.Common.Math.b2Vec2} normal The surface normal.
 * @param {number} offset The surface offset along the normal.
 * @param {!Box2D.Common.Math.b2Transform} xf The shape transform.
 * @param {!Box2D.Common.Math.b2Vec2} c The centroid, this argument is `out`.
 * 
 * @return {number}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {};

/**
 * Get the distance from vertex1 to vertex2.
 * @return {number} Distance from vertex1 to vertex2.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetLength = function() {};

/**
 * Get the local position of vertex1 in the parent body.
 * @return {!Box2D.Common.Math.b2Vec2} Local position of vertex1 in the parent body.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetVertex1 = function() {};

/**
 * Get the local position of vertex2 in the parent body.
 * @return {!Box2D.Common.Math.b2Vec2} Local position of vertex2 in the parent body.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetVertex2 = function() {};

/**
 * Get a core vertex 1 in local coordinates.  These vertices represent a smaller edge that is used for time of impact.
 * @return {!Box2D.Common.Math.b2Vec2} core vertex 1 in local coordinates.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetCoreVertex1 = function() {};

/**
 * Get a core vertex 2 in local coordinates.  These vertices represent a smaller edge that is used for time of impact.
 * @return {!Box2D.Common.Math.b2Vec2} core vertex 2 in local coordinates.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetCoreVertex2 = function() {};

/**
 * Get a perpendicular unit vector, pointing from the solid side to the empty side.
 * @return {!Box2D.Common.Math.b2Vec2} Normal vector.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetNormalVector = function() {};

/**
 * Get a parallel unit vector, pointing from vertex 1 to vertex 2.
 * @return {!Box2D.Common.Math.b2Vec2} Vertex 1 to vertex 2 directional vector.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetDirectionVector = function() {};

/**
 * Returns a unit vector halfway between direction and previous direction.
 * @return {!Box2D.Common.Math.b2Vec2} Halfway unit vector between direction and previous direction.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetCorner1Vector = function() {};

/**
 * Returns a unit vector halfway between direction and previous direction.
 * @return {!Box2D.Common.Math.b2Vec2} Halfway unit vector between direction and previous direction.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetCorner2Vector = function() {};

/**
 * Determines if the first corner of this edge bends towards the solid side.
 * @return {boolean} True if convex, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.Corner1IsConvex = function() {};

/**
 * Determines if the second corner of this edge bends towards the solid side.
 * @return {boolean} True if convex, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.Corner2IsConvex = function() {};

/**
 * Get the first vertex and apply the supplied transform.
 * @param {!Box2D.Common.Math.b2Transform} xf Transform to apply.
 * @return {!Box2D.Common.Math.b2Vec2} First vertex with xf transform applied.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetFirstVertex = function(xf) {};

/**
 * Get the next edge in the chain.
 * @return {!Box2D.Collision.Shapes.b2EdgeShape} Next edge shape or null if there is no next edge shape.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetNextEdge = function() {};

/**
 * Get the previous edge in the chain.
 * @return {!Box2D.Collision.Shapes.b2EdgeShape} Previous edge shape or null if there is no previous edge shape.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetPrevEdge = function() {};

/**
 * Get the support point in the given world direction with the supplied transform.
 * @param {!Box2D.Common.Math.b2Transform} xf Transform to apply.
 * @param {number} dX X world direction.
 * @param {number} dY Y world direction.
 * @return {!Box2D.Common.Math.b2Vec2} Support point.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.Support = function(xf, dX, dY) {};

/**
 * Cast a ray against this shape.
 * @param {!Box2D.Collision.b2RayCastOutput} output Ray cast results, this argument is `out`.
 * @param {!Box2D.Collision.b2RayCastInput} input Ray cast input parameters.
 * @param {!Box2D.Common.Math.b2Transform} transform The transform to be applied to the shape.
 * @return {boolean} True if the ray hits the shape, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.RayCast = function(output, input, transform) {};

/**
 * Test a point for containment in this shape. This only works for convex shapes.
 * @param {!Box2D.Common.Math.b2Transform} xf Shape world transform.
 * @param {!Box2D.Common.Math.b2Vec2} p Point to test against, in world coordinates.
 * @return {boolean} True if the point is in this shape, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.TestPoint = function(xf, p) {};
/**
 * @constructor
 * @struct
 */
Box2D.Collision.Shapes.b2MassData = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Collision.Shapes.b2MassData.prototype.center;
 /** @type {number} */
Box2D.Collision.Shapes.b2MassData.prototype.I;
 /** @type {number} */
Box2D.Collision.Shapes.b2MassData.prototype.mass;
/**
 * @extends {Box2D.Collision.Shapes.b2Shape}
 * @constructor
 * @struct
 */
Box2D.Collision.Shapes.b2PolygonShape = function() {};

/**
 * Creates a b2PolygonShape from a vertices list. This assumes the vertices define a convex polygon.  It is assumed that the exterior is the the right of each edge.
 * @param {!Array<!Box2D.Common.Math.b2Vec2>} vertices List of vertices to create the polygon shape from.
 * @param {number=} vertexCount Number of vertices in the shape, default value is 0 and in the box2dweb.js code it is ignored.
 * @return {!Box2D.Collision.Shapes.b2PolygonShape} Convex polygon shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.AsArray = function(vertices, vertexCount) {};

/**
 * Build vertices to represent an axis-aligned box.
 * @param {number} hx The half-width.
 * @param {number} hy The half-height.
 * @return {!Box2D.Collision.Shapes.b2PolygonShape} Box polygon shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.AsBox = function(hx, hy) {};

/**
 * Creates a single edge from two vertices.
 * @param {!Box2D.Common.Math.b2Vec2} v1 First vertex.
 * @param {!Box2D.Common.Math.b2Vec2} b2
 * @return {!Box2D.Collision.Shapes.b2PolygonShape} Edge polygon shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.AsEdge = function(v1, b2) {};

/**
 * Build vertices to represent an oriented box.
 * @param {number} hx The half-width.
 * @param {number} hy The half-height.
 * @param {!Box2D.Common.Math.b2Vec2=} center The center of the box in local coordinates, default is null (no center?)
 * @param {number=} angle The rotation of the box in local coordinates, default is 0.0.
 * @return {!Box2D.Collision.Shapes.b2PolygonShape} Oriented box shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.AsOrientedBox = function(hx, hy, center, angle) {};

/**
 * This assumes the vertices define a convex polygon.  It is assumed that the exterior is the the right of each edge.
 * @param {!Array<!Box2D.Common.Math.b2Vec2>} vertices List of vertices to create the polygon shape from.
 * @param {number=} vertexCount The number of vertices, default is 0 and in the box2dweb.js code it is ignored.
 * @return {!Box2D.Collision.Shapes.b2PolygonShape} Convex polygon shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.AsVector = function(vertices, vertexCount) {};

/**
 * Given a transform, compute the associated axis aligned bounding box for this shape.
 * @param {!Box2D.Collision.b2AABB} aabb Calculated AABB, this argument is `out`.
 * @param {!Box2D.Common.Math.b2Transform} xf Transform to calculate the AABB.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ComputeAABB = function(aabb, xf) {};

/**
 * Compute the mass properties of this shape using its dimensions and density. The inertia tensor is computed about the local origin, not the centroid.
 * @param {!Box2D.Collision.Shapes.b2MassData} massData Calculate the mass, this argument is `out`.
 * 
 * @param {number} density
 * @return {void}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ComputeMass = function(massData, density) {};

/**
 * Compute the volume and centroid of this shape intersected with a half plane
 * @param {!Box2D.Common.Math.b2Vec2} normal The surface normal.
 * @param {number} offset The surface offset along the normal.
 * @param {!Box2D.Common.Math.b2Transform} xf The shape transform.
 * @param {!Box2D.Common.Math.b2Vec2} c The centroid, this argument is `out`.
 * 
 * @return {number}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {};

/**
 * Clone the shape.
 * 
 * @return {!Box2D.Collision.Shapes.b2PolygonShape}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.Copy = function() {};

/**
 * Get the edge normal vectors. There is one for each vertex.
 * @return {!Array<!Box2D.Common.Math.b2Vec2>} List of edge normal vectors for each vertex.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetNormals = function() {};

/**
 * Get the supporting vertex index in the given direction.
 * @param {!Box2D.Common.Math.b2Vec2} d Direction to look.
 * @return {number} Vertex index supporting the direction.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetSupport = function(d) {};

/**
 * Get the supporting vertex in the given direction.
 * @param {!Box2D.Common.Math.b2Vec2} d Direciton to look.
 * @return {!Box2D.Common.Math.b2Vec2} Vertex supporting the direction.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetSupportVertex = function(d) {};

/**
 * Get the vertex count.
 * @return {number} Vertex count.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetVertexCount = function() {};

/**
 * Get the vertices in local coordinates.
 * @return {!Array<!Box2D.Common.Math.b2Vec2>} List of the vertices in local coordinates.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetVertices = function() {};

/**
 * Cast a ray against this shape.
 * @param {!Box2D.Collision.b2RayCastOutput} output Ray cast results, this argument is `out`.
 * @param {!Box2D.Collision.b2RayCastInput} input Ray cast input parameters.
 * @param {!Box2D.Common.Math.b2Transform} transform The transform to be applied to the shape.
 * @return {boolean} True if the ray hits the shape, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.RayCast = function(output, input, transform) {};

/**
 * Set the shape values from another shape.
 * @param {!Box2D.Collision.Shapes.b2Shape} other The other shape to copy values from.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.Set = function(other) {};

/**
 * Copy vertices. This assumes the vertices define a convex polygon.  It is assumed that the exterior is the the right of each edge.
 * @param {!Array<!Box2D.Common.Math.b2Vec2>} vertices List of vertices to create the polygon shape from.
 * @param {number=} vertexCount Number of vertices in the shape, default value is 0 and in the box2dweb.js code it is ignored.
 * @return {void} Convex polygon shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsArray = function(vertices, vertexCount) {};

/**
 * Build vertices to represent an axis-aligned box.
 * @param {number} hx The half-width.
 * @param {number} hy The half-height.
 * @return {void} Box polygon shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsBox = function(hx, hy) {};

/**
 * Creates a single edge from two vertices.
 * @param {!Box2D.Common.Math.b2Vec2} v1 First vertex.
 * @param {!Box2D.Common.Math.b2Vec2} b2
 * @return {void} Edge polygon shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsEdge = function(v1, b2) {};

/**
 * Build vertices to represent an oriented box.
 * @param {number} hx The half-width.
 * @param {number} hy The half-height.
 * @param {!Box2D.Common.Math.b2Vec2=} center The center of the box in local coordinates, default is null (no center?)
 * @param {number=} angle The rotation of the box in local coordinates, default is 0.0.
 * @return {void} Oriented box shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsOrientedBox = function(hx, hy, center, angle) {};

/**
 * This assumes the vertices define a convex polygon.  It is assumed that the exterior is the the right of each edge.
 * @param {!Array<?>} vertices List of vertices to create the polygon shape from.
 * @param {number=} vertexCount The number of vertices, default is 0 and in the box2dweb.js code it is ignored.
 * @return {void} Convex polygon shape.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsVector = function(vertices, vertexCount) {};

/**
 * Test a point for containment in this shape. This only works for convex shapes.
 * @param {!Box2D.Common.Math.b2Transform} xf Shape world transform.
 * @param {!Box2D.Common.Math.b2Vec2} p Point to test against, in world coordinates.
 * @return {boolean} True if the point is in this shape, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.TestPoint = function(xf, p) {};

/**
 * @constructor
 * @struct
 * Creates a new b2Shape.
 * 
 */
Box2D.Collision.Shapes.b2Shape = function() {};
 /** @type {number} */
Box2D.Collision.Shapes.b2Shape.e_hitCollide;
 /** @type {number} */
Box2D.Collision.Shapes.b2Shape.e_missCollide;
 /** @type {number} */
Box2D.Collision.Shapes.b2Shape.startsInsideCollide;
 /** @type {number} */
Box2D.Collision.Shapes.b2Shape.e_unknownShape;
 /** @type {number} */
Box2D.Collision.Shapes.b2Shape.e_circleShape;
 /** @type {number} */
Box2D.Collision.Shapes.b2Shape.e_polygonShape;
 /** @type {number} */
Box2D.Collision.Shapes.b2Shape.e_edgeShape;
 /** @type {number} */
Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount;

/**
 * Given a transform, compute the associated axis aligned bounding box for this shape.
 * @param {!Box2D.Collision.b2AABB} aabb Calculated AABB, this argument is `out`.
 * @param {!Box2D.Common.Math.b2Transform} xf Transform to calculate the AABB.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2Shape.prototype.ComputeAABB = function(aabb, xf) {};

/**
 * Compute the mass properties of this shape using its dimensions and density. The inertia tensor is computed about the local origin, not the centroid.
 * @param {!Box2D.Collision.Shapes.b2MassData} massData Calculate the mass, this argument is `out`.
 * @param {number} density Density.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2Shape.prototype.ComputeMass = function(massData, density) {};

/**
 * Compute the volume and centroid of this shape intersected with a half plane
 * @param {!Box2D.Common.Math.b2Vec2} normal The surface normal.
 * @param {number} offset The surface offset along the normal.
 * @param {!Box2D.Common.Math.b2Transform} xf The shape transform.
 * @param {!Box2D.Common.Math.b2Vec2} c The centroid, this argument is `out`.
 * 
 * @return {number}
 */
Box2D.Collision.Shapes.b2Shape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {};

/**
 * Clone the shape.
 * 
 * @return {!Box2D.Collision.Shapes.b2Shape}
 */
Box2D.Collision.Shapes.b2Shape.prototype.Copy = function() {};

/**
 * Get the type of this shape. You can use this to down cast to the concrete shape.
 * 
 * @return {number}
 */
Box2D.Collision.Shapes.b2Shape.prototype.GetType = function() {};

/**
 * Cast a ray against this shape.
 * @param {!Box2D.Collision.b2RayCastOutput} output Ray cast results, this argument is `out`.
 * @param {!Box2D.Collision.b2RayCastInput} input Ray cast input parameters.
 * @param {!Box2D.Common.Math.b2Transform} transform The transform to be applied to the shape.
 * @return {boolean}
 */
Box2D.Collision.Shapes.b2Shape.prototype.RayCast = function(output, input, transform) {};

/**
 * Set the shape values from another shape.
 * @param {!Box2D.Collision.Shapes.b2Shape} other The other shape to copy values from.
 * 
 * @return {void}
 */
Box2D.Collision.Shapes.b2Shape.prototype.Set = function(other) {};

/**
 * Test if two shapes overlap with the applied transforms.
 * @param {!Box2D.Collision.Shapes.b2Shape} shape1 shape to test for overlap with shape2.
 * @param {!Box2D.Common.Math.b2Transform} transform1 shape1 transform to apply.
 * @param {!Box2D.Collision.Shapes.b2Shape} shape2 shape to test for overlap with shape1.
 * @param {!Box2D.Common.Math.b2Transform} transform2 shape2 transform to apply.
 * @return {boolean} True if shape1 and shape2 overlap, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2Shape.TestOverlap = function(shape1, transform1, shape2, transform2) {};

/**
 * Test a point for containment in this shape. This only works for convex shapes.
 * @param {!Box2D.Common.Math.b2Transform} xf Shape world transform.
 * @param {!Box2D.Common.Math.b2Vec2} p Point to test against, in world coordinates.
 * @return {boolean} True if the point is in this shape, otherwise false.
 * 
 */
Box2D.Collision.Shapes.b2Shape.prototype.TestPoint = function(xf, p) {};
/** @const */
Box2D.Dynamics = {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.b2Body = function() {};
 /** @type {number} */
Box2D.Dynamics.b2Body.b2_dynamicBody;
 /** @type {number} */
Box2D.Dynamics.b2Body.b2_kinematicBody;
 /** @type {number} */
Box2D.Dynamics.b2Body.b2_staticBody;

/**
 * Apply a force at a world point. If the force is not applied at the center of mass, it will generate a torque and affect the angular velocity. This wakes up the body.
 * @param {!Box2D.Common.Math.b2Vec2} force The world force vector, usually in Newtons (N).
 * @param {!Box2D.Common.Math.b2Vec2} point The world position of the point of application.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.ApplyForce = function(force, point) {};

/**
 * Apply an impulse at a point. This immediately modifies the velocity. It also modifies the angular velocity if the point of application is not at the center of mass. This wakes up the body.
 * @param {!Box2D.Common.Math.b2Vec2} impulse
 * @param {!Box2D.Common.Math.b2Vec2} point The world position of the point of application.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.ApplyImpulse = function(impulse, point) {};

/**
 * Apply a torque. This affects the angular velocity without affecting the linear velocity of the center of mass. This wakes up the body.
 * @param {number} torque Force applied about the z-axis (out of the screen), usually in N-m.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.ApplyTorque = function(torque) {};

/**
 * Creates a fixture and attach it to this body. Use this function if you need to set some fixture parameters, like friction. Otherwise you can create the fixture directly from a shape. If the density is non-zero, this function automatically updates the mass of the body. Contacts are not created until the next time step.
 * \@warning This function is locked during callbacks.
 * @param {!Box2D.Dynamics.b2FixtureDef} def The fixture definition;
 * @return {!Box2D.Dynamics.b2Fixture} The created fixture.
 * 
 */
Box2D.Dynamics.b2Body.prototype.CreateFixture = function(def) {};

/**
 * Creates a fixture from a shape and attach it to this body. This is a convenience function. Use b2FixtureDef if you need to set parameters like friction, restitution, user data, or filtering. This function automatically updates the mass of the body.
 * \@warning This function is locked during callbacks.
 * @param {!Box2D.Collision.Shapes.b2Shape} shape The shaped of the fixture (to be cloned).
 * @param {number=} density The shape density, default is 0.0, set to zero for static bodies.
 * @return {!Box2D.Dynamics.b2Fixture} The created fixture.
 * 
 */
Box2D.Dynamics.b2Body.prototype.CreateFixture2 = function(shape, density) {};

/**
 * Destroy a fixture. This removes the fixture from the broad-phase and destroys all contacts associated with this fixture. This will automatically adjust the mass of the body if the body is dynamic and the fixture has positive density. All fixtures attached to a body are implicitly destroyed when the body is destroyed.
 * \@warning This function is locked during callbacks.
 * @param {!Box2D.Dynamics.b2Fixture} fixture The fixed to be removed.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.DestroyFixture = function(fixture) {};

/**
 * Get the angle in radians.
 * @return {number} The current world rotation angle in radians
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetAngle = function() {};

/**
 * Get the angular damping of the body.
 * @return {number} Angular damping of the body.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetAngularDamping = function() {};

/**
 * Get the angular velocity.
 * @return {number} The angular velocity in radians/second.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetAngularVelocity = function() {};

/**
 * Get the list of all contacts attached to this body.
 * @return {!Box2D.Dynamics.Contacts.b2ContactEdge} List of all contacts attached to this body.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetContactList = function() {};

/**
 * Get the list of all controllers attached to this body.
 * @return {!Box2D.Dynamics.Controllers.b2ControllerEdge} List of all controllers attached to this body.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetControllerList = function() {};

/**
 * Get the definition containing the body properties.
 * \@note This provides a feature specific to this port.
 * @return {!Box2D.Dynamics.b2BodyDef} The body's definition.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetDefinition = function() {};

/**
 * Get the list of all fixtures attached to this body.
 * @return {!Box2D.Dynamics.b2Fixture} List of all fixtures attached to this body.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetFixtureList = function() {};

/**
 * Get the central rotational inertia of the body.
 * @return {number} The rotational inertia, usually in kg-m^2.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetInertia = function() {};

/**
 * Get the list of all joints attached to this body.
 * @return {!Box2D.Dynamics.Joints.b2JointEdge} List of all joints attached to this body.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetJointList = function() {};

/**
 * Get the linear damping of the body.
 * @return {number} The linear damping of the body.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetLinearDamping = function() {};

/**
 * Get the linear velocity of the center of mass.
 * @return {!Box2D.Common.Math.b2Vec2} The linear velocity of the center of mass.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetLinearVelocity = function() {};

/**
 * Get the world velocity of a local point.
 * @param {!Box2D.Common.Math.b2Vec2} localPoint Point in local coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} The world velocity of the point.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint) {};

/**
 * Get the world linear velocity of a world point attached to this body.
 * @param {!Box2D.Common.Math.b2Vec2} worldPoint Point in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} The world velocity of the point.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint) {};

/**
 * Get the local position of the center of mass.
 * @return {!Box2D.Common.Math.b2Vec2} Local position of the center of mass.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetLocalCenter = function() {};

/**
 * Gets a local point relative to the body's origin given a world point.
 * @param {!Box2D.Common.Math.b2Vec2} worldPoint Pointin world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} The corresponding local point relative to the body's origin.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetLocalPoint = function(worldPoint) {};

/**
 * Gets a local vector given a world vector.
 * @param {!Box2D.Common.Math.b2Vec2} worldVector World vector.
 * @return {!Box2D.Common.Math.b2Vec2} The corresponding local vector.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetLocalVector = function(worldVector) {};

/**
 * Get the total mass of the body.
 * @return {number} The body's mass, usually in kilograms (kg).
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetMass = function() {};

/**
 * Get the mass data of the body. The rotational inertial is relative to the center of mass.
 * @param {!Box2D.Collision.Shapes.b2MassData} data Body's mass data, this argument is `out`.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.GetMassData = function(data) {};

/**
 * Get the next body in the world's body list.
 * @return {!Box2D.Dynamics.b2Body} Next body in the world's body list.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetNext = function() {};

/**
 * Get the world body origin position.
 * @return {!Box2D.Common.Math.b2Vec2} World position of the body's origin.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetPosition = function() {};

/**
 * Get the body transform for the body's origin.
 * @return {!Box2D.Common.Math.b2Transform} World transform of the body's origin.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetTransform = function() {};

/**
 * Get the type of this body.
 * @return {number} Body type as uint.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetType = function() {};

/**
 * Get the user data pointer that was provided in the body definition.
 * @return {?} User's data, cast to the correct type.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetUserData = function() {};

/**
 * Get the parent world of this body.
 * @return {!Box2D.Dynamics.b2World} Body's world.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetWorld = function() {};

/**
 * Get the world position of the center of mass.
 * @return {!Box2D.Common.Math.b2Vec2} World position of the center of mass.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetWorldCenter = function() {};

/**
 * Get the world coordinates of a point given the local coordinates.
 * @param {!Box2D.Common.Math.b2Vec2} localPoint Point on the body measured relative to the body's origin.
 * @return {!Box2D.Common.Math.b2Vec2} localPoint expressed in world coordinates.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetWorldPoint = function(localPoint) {};

/**
 * Get the world coordinates of a vector given the local coordinates.
 * @param {!Box2D.Common.Math.b2Vec2} localVector Vector fixed in the body.
 * @return {!Box2D.Common.Math.b2Vec2} localVector expressed in world coordinates.
 * 
 */
Box2D.Dynamics.b2Body.prototype.GetWorldVector = function(localVector) {};

/**
 * Get the active state of the body.
 * @return {boolean} True if the body is active, otherwise false.
 * 
 */
Box2D.Dynamics.b2Body.prototype.IsActive = function() {};

/**
 * Get the sleeping state of this body.
 * @return {boolean} True if the body is awake, otherwise false.
 * 
 */
Box2D.Dynamics.b2Body.prototype.IsAwake = function() {};

/**
 * Is the body treated like a bullet for continuous collision detection?
 * @return {boolean} True if the body is treated like a bullet, otherwise false.
 * 
 */
Box2D.Dynamics.b2Body.prototype.IsBullet = function() {};

/**
 * Does this body have fixed rotation?
 * @return {boolean} True for fixed, otherwise false.
 * 
 */
Box2D.Dynamics.b2Body.prototype.IsFixedRotation = function() {};

/**
 * Is this body allowed to sleep?
 * @return {boolean} True if the body can sleep, otherwise false.
 * 
 */
Box2D.Dynamics.b2Body.prototype.IsSleepingAllowed = function() {};

/**
 * Merges another body into this. Only fixtures, mass and velocity are effected, Other properties are ignored.
 * \@note This provides a feature specific to this port.
 * 
 * @param {!Box2D.Dynamics.b2Body} other
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.Merge = function(other) {};

/**
 * This resets the mass properties to the sum of the mass properties of the fixtures. This normally does not need to be called unless you called SetMassData to override the mass and later you want to reset the mass.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.ResetMassData = function() {};

/**
 * Set the active state of the body. An inactive body is not simulated and cannot be collided with or woken up. If you pass a flag of true, all fixtures will be added to the broad-phase. If you pass a flag of false, all fixtures will be removed from the broad-phase and all contacts will be destroyed. Fixtures and joints are otherwise unaffected. You may continue to create/destroy fixtures and joints on inactive bodies. Fixtures on an inactive body are implicitly inactive and will not participate in collisions, ray-casts, or queries. Joints connected to an inactive body are implicitly inactive. An inactive body is still owned by a b2World object and remains in the body list.
 * @param {boolean} flag True to activate, false to deactivate.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetActive = function(flag) {};

/**
 * Set the world body angle
 * @param {number} angle New angle of the body.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetAngle = function(angle) {};

/**
 * Set the angular damping of the body.
 * @param {number} angularDamping New angular damping value.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetAngularDamping = function(angularDamping) {};

/**
 * Set the angular velocity.
 * @param {number} omega New angular velocity in radians/second.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetAngularVelocity = function(omega) {};

/**
 * Set the sleep state of the body. A sleeping body has vety low CPU cost.
 * @param {boolean} flag True to set the body to awake, false to put it to sleep.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetAwake = function(flag) {};

/**
 * Should this body be treated like a bullet for continuous collision detection?
 * @param {boolean} flag True for bullet, false for normal.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetBullet = function(flag) {};

/**
 * Set this body to have fixed rotation. This causes the mass to be reset.
 * @param {boolean} fixed True for no rotation, false to allow for rotation.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetFixedRotation = function(fixed) {};

/**
 * Set the linear damping of the body.
 * @param {number} linearDamping The new linear damping for this body.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetLinearDamping = function(linearDamping) {};

/**
 * Set the linear velocity of the center of mass.
 * @param {!Box2D.Common.Math.b2Vec2} v New linear velocity of the center of mass.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetLinearVelocity = function(v) {};

/**
 * Set the mass properties to override the mass properties of the fixtures Note that this changes the center of mass position. Note that creating or destroying fixtures can also alter the mass. This function has no effect if the body isn't dynamic.
 * \@warning The supplied rotational inertia should be relative to the center of mass.
 * @param {!Box2D.Collision.Shapes.b2MassData} massData New mass data properties.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetMassData = function(massData) {};

/**
 * Set the world body origin position.
 * @param {!Box2D.Common.Math.b2Vec2} position New world body origin position.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetPosition = function(position) {};

/**
 * Set the position of the body's origin and rotation (radians). This breaks any contacts and wakes the other bodies.
 * @param {!Box2D.Common.Math.b2Vec2} position New world body origin position.
 * @param {number} angle New world rotation angle of the body in radians.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetPositionAndAngle = function(position, angle) {};

/**
 * Is this body allowed to sleep
 * @param {boolean} flag True if the body can sleep, false if not.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetSleepingAllowed = function(flag) {};

/**
 * Set the position of the body's origin and rotation (radians). This breaks any contacts and wakes the other bodies. Note this is less efficient than the other overload - you should use that if the angle is available.
 * @param {!Box2D.Common.Math.b2Transform} xf Body's origin and rotation (radians).
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetTransform = function(xf) {};

/**
 * Set the type of this body. This may alter the mass and velocity
 * @param {number} type Type enum.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetType = function(type) {};

/**
 * Set the user data. Use this to store your application specific data.
 * @param {?} data The user data for this body.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Body.prototype.SetUserData = function(data) {};

/**
 * Splits a body into two, preserving dynamic properties
 * \@note This provides a feature specific to this port.
 * @param {function(!Box2D.Dynamics.b2Fixture): boolean} callback
 * @return {!Box2D.Dynamics.b2Body} The newly created bodies from the split.
 * 
 */
Box2D.Dynamics.b2Body.prototype.Split = function(callback) {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.b2BodyDef = function() {};
 /** @type {boolean} */
Box2D.Dynamics.b2BodyDef.prototype.active;
 /** @type {boolean} */
Box2D.Dynamics.b2BodyDef.prototype.allowSleep;
 /** @type {number} */
Box2D.Dynamics.b2BodyDef.prototype.angle;
 /** @type {number} */
Box2D.Dynamics.b2BodyDef.prototype.angularDamping;
 /** @type {number} */
Box2D.Dynamics.b2BodyDef.prototype.angularVelocity;
 /** @type {boolean} */
Box2D.Dynamics.b2BodyDef.prototype.awake;
 /** @type {boolean} */
Box2D.Dynamics.b2BodyDef.prototype.bullet;
 /** @type {boolean} */
Box2D.Dynamics.b2BodyDef.prototype.fixedRotation;
 /** @type {number} */
Box2D.Dynamics.b2BodyDef.prototype.inertiaScale;
 /** @type {number} */
Box2D.Dynamics.b2BodyDef.prototype.linearDamping;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.b2BodyDef.prototype.linearVelocity;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.b2BodyDef.prototype.position;
 /** @type {number} */
Box2D.Dynamics.b2BodyDef.prototype.type;
 /** @type {?} */
Box2D.Dynamics.b2BodyDef.prototype.userData;
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.b2ContactFilter = function() {};

/**
 * Return true if the given fixture should be considered for ray intersection. By default, userData is cast as a b2Fixture and collision is resolved according to ShouldCollide.
 * \@note This function is not in the box2dweb.as code -- might not work.
 * @see b2World.Raycast()
 * @see b2ContactFilter.ShouldCollide()
 * @param {?} userData User provided data.  Comments indicate that this might be a b2Fixture.
 * @return {boolean} True if the fixture should be considered for ray intersection, otherwise false.
 * 
 */
Box2D.Dynamics.b2ContactFilter.prototype.RayCollide = function(userData) {};

/**
 * Return true if contact calculations should be performed between these two fixtures.
 * \@warning For performance reasons this is only called when the AABBs begin to overlap.
 * @param {!Box2D.Dynamics.b2Fixture} fixtureA b2Fixture potentially colliding with fixtureB.
 * @param {!Box2D.Dynamics.b2Fixture} fixtureB b2Fixture potentially colliding with fixtureA.
 * @return {boolean} True if fixtureA and fixtureB probably collide requiring more calculations, otherwise false.
 * 
 */
Box2D.Dynamics.b2ContactFilter.prototype.ShouldCollide = function(fixtureA, fixtureB) {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.b2ContactImpulse = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.b2ContactImpulse.prototype.normalImpulses;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.b2ContactImpulse.prototype.tangentImpulses;
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.b2ContactListener = function() {};

/**
 * Called when two fixtures begin to touch.
 * @param {!Box2D.Dynamics.Contacts.b2Contact} contact Contact point.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2ContactListener.prototype.BeginContact = function(contact) {};

/**
 * Called when two fixtures cease to touch.
 * @param {!Box2D.Dynamics.Contacts.b2Contact} contact Contact point.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2ContactListener.prototype.EndContact = function(contact) {};

/**
 * This lets you inspect a contact after the solver is finished. This is useful for inspecting impulses. Note: the contact manifold does not include time of impact impulses, which can be arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly in a separate data structure. Note: this is only called for contacts that are touching, solid, and awake.
 * @param {!Box2D.Dynamics.Contacts.b2Contact} contact Contact point.
 * @param {!Box2D.Dynamics.b2ContactImpulse} impulse Contact impulse.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2ContactListener.prototype.PostSolve = function(contact, impulse) {};

/**
 * This is called after a contact is updated. This allows you to inspect a contact before it goes to the solver. If you are careful, you can modify the contact manifold (e.g. disable contact). A copy of the old manifold is provided so that you can detect changes. Note: this is called only for awake bodies. Note: this is called even when the number of contact points is zero. Note: this is not called for sensors. Note: if you set the number of contact points to zero, you will not get an EndContact callback. However, you may get a BeginContact callback the next step.
 * @param {!Box2D.Dynamics.Contacts.b2Contact} contact Contact point.
 * @param {!Box2D.Collision.b2Manifold} oldManifold Old manifold.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2ContactListener.prototype.PreSolve = function(contact, oldManifold) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.b2DebugDraw = function() {};
 /** @type {number} */
Box2D.Dynamics.b2DebugDraw.e_aabbBit;
 /** @type {number} */
Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit;
 /** @type {number} */
Box2D.Dynamics.b2DebugDraw.e_controllerBit;
 /** @type {number} */
Box2D.Dynamics.b2DebugDraw.e_jointBit;
 /** @type {number} */
Box2D.Dynamics.b2DebugDraw.e_pairBit;
 /** @type {number} */
Box2D.Dynamics.b2DebugDraw.e_shapeBit;

/**
 * Append flags to the current flags.
 * @param {number} flags Flags to add.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.AppendFlags = function(flags) {};

/**
 * Clear flags from the current flags.
 * @param {number} flags flags to clear.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.ClearFlags = function(flags) {};

/**
 * Draw a circle.
 * @param {!Box2D.Common.Math.b2Vec2} center Circle center point.
 * @param {number} radius Circle radius.
 * @param {!Box2D.Common.b2Color} color Circle draw color.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.DrawCircle = function(center, radius, color) {};

/**
 * Draw a closed polygon provided in CCW order.
 * @param {!Array<!Box2D.Common.Math.b2Vec2>} vertices Polygon verticies.
 * @param {number} vertexCount Number of vertices in the polygon, usually vertices.length.
 * @param {!Box2D.Common.b2Color} color Polygon draw color.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {};

/**
 * Draw a line segment.
 * @param {!Box2D.Common.Math.b2Vec2} p1 Line beginpoint.
 * @param {!Box2D.Common.Math.b2Vec2} p2 Line endpoint.
 * @param {!Box2D.Common.b2Color} color Line color.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.DrawSegment = function(p1, p2, color) {};

/**
 * Draw a solid circle.
 * @param {!Box2D.Common.Math.b2Vec2} center Circle center point.
 * @param {number} radius Circle radius.
 * @param {!Box2D.Common.Math.b2Vec2} axis Circle axis.
 * @param {!Box2D.Common.b2Color} color Circle color.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {};

/**
 * Draw a solid closed polygon provided in CCW order.
 * @param {!Array<!Box2D.Common.Math.b2Vec2>} vertices Polygon verticies.
 * @param {number} vertexCount Number of vertices in the polygon, usually vertices.length.
 * @param {!Box2D.Common.b2Color} color Polygon draw color.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {};

/**
 * Draw a transform. Choose your own length scale.
 * @param {!Box2D.Common.Math.b2Transform} xf Transform to draw.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.DrawTransform = function(xf) {};

/**
 * Get the alpha value used for lines.
 * @return {number} Alpha value used for drawing lines.
 * 
 */
Box2D.Dynamics.b2DebugDraw.prototype.GetAlpha = function() {};

/**
 * Get the draw scale.
 * @return {number} Draw scale ratio.
 * 
 */
Box2D.Dynamics.b2DebugDraw.prototype.GetDrawScale = function() {};

/**
 * Get the alpha value used for fills.
 * @return {number} Alpha value used for drawing fills.
 * 
 */
Box2D.Dynamics.b2DebugDraw.prototype.GetFillAlpha = function() {};

/**
 * Get the drawing flags.
 * @return {number} Drawing flags.
 * 
 */
Box2D.Dynamics.b2DebugDraw.prototype.GetFlags = function() {};

/**
 * Get the line thickness.
 * @return {number} Line thickness.
 * 
 */
Box2D.Dynamics.b2DebugDraw.prototype.GetLineThickness = function() {};

/**
 * Get the HTML Canvas Element for drawing.
 * \@note box2dflash uses Sprite object, box2dweb uses CanvasRenderingContext2D, that is why this function is called GetSprite().
 * @return {!CanvasRenderingContext2D} The HTML Canvas Element used for debug drawing.
 * 
 */
Box2D.Dynamics.b2DebugDraw.prototype.GetSprite = function() {};

/**
 * Get the scale used for drawing XForms.
 * @return {number} Scale for drawing transforms.
 * 
 */
Box2D.Dynamics.b2DebugDraw.prototype.GetXFormScale = function() {};

/**
 * Set the alpha value used for lines.
 * @param {number} alpha Alpha value for drawing lines.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.SetAlpha = function(alpha) {};

/**
 * Set the draw scale.
 * @param {number} drawScale Draw scale ratio.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.SetDrawScale = function(drawScale) {};

/**
 * Set the alpha value used for fills.
 * @param {number} alpha Alpha value for drawing fills.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.SetFillAlpha = function(alpha) {};

/**
 * Set the drawing flags.
 * @param {number} flags Sets the drawing flags.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.SetFlags = function(flags) {};

/**
 * Set the line thickness.
 * @param {number} lineThickness The new line thickness.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.SetLineThickness = function(lineThickness) {};

/**
 * Set the HTML Canvas Element for drawing.
 * \@note box2dflash uses Sprite object, box2dweb uses CanvasRenderingContext2D, that is why this function is called SetSprite().
 * @param {!CanvasRenderingContext2D} canvas HTML Canvas Element to draw debug information to.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.SetSprite = function(canvas) {};

/**
 * Set the scale used for drawing XForms.
 * @param {number} xformScale The transform scale.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DebugDraw.prototype.SetXFormScale = function(xformScale) {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.b2DestructionListener = function() {};

/**
 * Called when any fixture is about to be destroyed due to the destruction of its parent body.
 * @param {!Box2D.Dynamics.b2Fixture} fixture b2Fixture being destroyed.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DestructionListener.prototype.SayGoodbyeFixture = function(fixture) {};

/**
 * Called when any joint is about to be destroyed due to the destruction of one of its attached bodies.
 * @param {!Box2D.Dynamics.Joints.b2Joint} joint b2Joint being destroyed.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2DestructionListener.prototype.SayGoodbyeJoint = function(joint) {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.b2FilterData = function() {};
 /** @type {number} */
Box2D.Dynamics.b2FilterData.prototype.categoryBits;
 /** @type {number} */
Box2D.Dynamics.b2FilterData.prototype.groupIndex;
 /** @type {number} */
Box2D.Dynamics.b2FilterData.prototype.maskBits;

/**
 * Creates a copy of the filter data.
 * @return {!Box2D.Dynamics.b2FilterData} Copy of this filter data.
 * 
 */
Box2D.Dynamics.b2FilterData.prototype.Copy = function() {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.b2Fixture = function() {};

/**
 * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a more accurate AABB, compute it using the shape and the body transform.
 * @return {!Box2D.Collision.b2AABB} Fiture's AABB.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetAABB = function() {};

/**
 * Get the parent body of this fixture. This is NULL if the fixture is not attached.
 * @return {!Box2D.Dynamics.b2Body} The parent body.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetBody = function() {};

/**
 * Get the density of this fixture.
 * @return {number} Density
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetDensity = function() {};

/**
 * Get the contact filtering data.
 * @return {!Box2D.Dynamics.b2FilterData} Filter data.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetFilterData = function() {};

/**
 * Get the coefficient of friction.
 * @return {number} Friction.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetFriction = function() {};

/**
 * Get the mass data for this fixture. The mass data is based on the density and the shape. The rotational inertia is about the shape's origin. This operation may be expensive.
 * @param {!Box2D.Collision.Shapes.b2MassData=} massData This is a reference to a valid b2MassData, if it is null a new b2MassData is allocated and then returned.  Default = null.
 * @return {!Box2D.Collision.Shapes.b2MassData} Mass data.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetMassData = function(massData) {};

/**
 * Get the next fixture in the parent body's fixture list.
 * @return {!Box2D.Dynamics.b2Fixture} Next fixture.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetNext = function() {};

/**
 * Get the coefficient of restitution.
 * @return {number} Restitution.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetRestitution = function() {};

/**
 * Get the child shape. You can modify the child shape, however you should not change the number of vertices because this will crash some collision caching mechanisms.
 * @return {!Box2D.Collision.Shapes.b2Shape} Fixture shape.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetShape = function() {};

/**
 * Get the type of the child shape. You can use this to down cast to the concrete shape.
 * @return {number} Shape type enum.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetType = function() {};

/**
 * Get the user data that was assigned in the fixture definition. Use this to store your application specific data.
 * @return {?} User provided data.  Cast to your object type.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.GetUserData = function() {};

/**
 * Is this fixture a sensor (non-solid)?
 * @return {boolean} True if the shape is a sensor, otherwise false.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.IsSensor = function() {};

/**
 * Perform a ray cast against this shape.
 * @param {!Box2D.Collision.b2RayCastOutput} output Ray cast results.  This argument is out.
 * @param {!Box2D.Collision.b2RayCastInput} input Ray cast input parameters.
 * @return {boolean} True if the ray hits the shape, otherwise false.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.RayCast = function(output, input) {};

/**
 * Set the density of this fixture. This will _not_ automatically adjust the mass of the body. You must call b2Body::ResetMassData to update the body's mass.
 * @param {number} density The new density.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Fixture.prototype.SetDensity = function(density) {};

/**
 * Set the contact filtering data. This will not update contacts until the next time step when either parent body is active and awake.
 * @param {?} filter The new filter data.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Fixture.prototype.SetFilterData = function(filter) {};

/**
 * Set the coefficient of friction.
 * @param {number} friction The new friction coefficient.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Fixture.prototype.SetFriction = function(friction) {};

/**
 * Get the coefficient of restitution.
 * @param {number} restitution
 * @return {void}
 */
Box2D.Dynamics.b2Fixture.prototype.SetRestitution = function(restitution) {};

/**
 * Set if this fixture is a sensor.
 * @param {boolean} sensor True to set as a sensor, false to not be a sensor.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Fixture.prototype.SetSensor = function(sensor) {};

/**
 * Set the user data. Use this to store your application specific data.
 * @param {?} data User provided data.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2Fixture.prototype.SetUserData = function(data) {};

/**
 * Test a point for containment in this fixture.
 * @param {!Box2D.Common.Math.b2Vec2} p Point to test against, in world coordinates.
 * @return {boolean} True if the point is in this shape, otherwise false.
 * 
 */
Box2D.Dynamics.b2Fixture.prototype.TestPoint = function(p) {};

/**
 * @constructor
 * @struct
 * The constructor sets the default fixture definition values.
 * 
 */
Box2D.Dynamics.b2FixtureDef = function() {};
 /** @type {number} */
Box2D.Dynamics.b2FixtureDef.prototype.density;
 /** @type {!Box2D.Dynamics.b2FilterData} */
Box2D.Dynamics.b2FixtureDef.prototype.filter;
 /** @type {number} */
Box2D.Dynamics.b2FixtureDef.prototype.friction;
 /** @type {boolean} */
Box2D.Dynamics.b2FixtureDef.prototype.isSensor;
 /** @type {number} */
Box2D.Dynamics.b2FixtureDef.prototype.restitution;
 /** @type {!Box2D.Collision.Shapes.b2Shape} */
Box2D.Dynamics.b2FixtureDef.prototype.shape;
 /** @type {?} */
Box2D.Dynamics.b2FixtureDef.prototype.userData;

/**
 * @constructor
 * @struct
 * Creates a new world.
 * @param {!Box2D.Common.Math.b2Vec2} gravity The world gravity vector.
 * @param {boolean} doSleep Improvie performance by not simulating inactive bodies.
 * 
 */
Box2D.Dynamics.b2World = function(gravity, doSleep) {};
 /** @type {number} */
Box2D.Dynamics.b2World.e_locked;
 /** @type {number} */
Box2D.Dynamics.b2World.e_newFixture;

/**
 * Add a controller to the world list.
 * @param {!Box2D.Dynamics.Controllers.b2Controller} c Controller to add.
 * @return {!Box2D.Dynamics.Controllers.b2Controller} Controller that was added to the world.
 * 
 */
Box2D.Dynamics.b2World.prototype.AddController = function(c) {};

/**
 * Call this after you are done with time steps to clear the forces. You normally call this after each call to Step, unless you are performing sub-steps.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.ClearForces = function() {};

/**
 * Create a rigid body given a definition. No reference to the definition is retained.
 * @param {!Box2D.Dynamics.b2BodyDef} def Body's definition.
 * @return {!Box2D.Dynamics.b2Body} Created rigid body.
 * 
 */
Box2D.Dynamics.b2World.prototype.CreateBody = function(def) {};

/**
 * Creates a new controller.
 * @param {!Box2D.Dynamics.Controllers.b2Controller} controller New controller.
 * @return {!Box2D.Dynamics.Controllers.b2Controller} New controller.
 * 
 */
Box2D.Dynamics.b2World.prototype.CreateController = function(controller) {};

/**
 * Create a joint to constrain bodies together. No reference to the definition is retained. This may cause the connected bodies to cease colliding.
 * \@warning This function is locked during callbacks.
 * @param {!Box2D.Dynamics.Joints.b2JointDef} def Joint definition.
 * @return {!Box2D.Dynamics.Joints.b2Joint} New created joint.
 * 
 */
Box2D.Dynamics.b2World.prototype.CreateJoint = function(def) {};

/**
 * Destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during callbacks.
 * \@warning This function is locked during callbacks.
 * 
 * @param {!Box2D.Dynamics.b2Body} b Body to destroy.
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.DestroyBody = function(b) {};

/**
 * Destroy a controller given the controller instance.
 * \@warning This function is locked during callbacks.
 * @param {!Box2D.Dynamics.Controllers.b2Controller} controller Controller to destroy.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.DestroyController = function(controller) {};

/**
 * Destroy a joint. This may cause the connected bodies to begin colliding.
 * @param {!Box2D.Dynamics.Joints.b2Joint} j Joint to destroy.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.DestroyJoint = function(j) {};

/**
 * Call this to draw shapes and other debug draw data.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.DrawDebugData = function() {};

/**
 * Get the number of bodies.
 * @return {number} Number of bodies in this world.
 * 
 */
Box2D.Dynamics.b2World.prototype.GetBodyCount = function() {};

/**
 * Get the world body list. With the returned body, use b2Body::GetNext to get the next body in the world list. A NULL body indicates the end of the list.
 * @return {!Box2D.Dynamics.b2Body} The head of the world body list.
 * 
 */
Box2D.Dynamics.b2World.prototype.GetBodyList = function() {};

/**
 * Get the number of contacts (each may have 0 or more contact points).
 * @return {number} Number of contacts.
 * 
 */
Box2D.Dynamics.b2World.prototype.GetContactCount = function() {};

/**
 * Get the world contact list. With the returned contact, use b2Contact::GetNext to get the next contact in the world list. A NULL contact indicates the end of the list.
 * @return {!Box2D.Dynamics.Contacts.b2Contact} The head of the world contact list.
 * 
 */
Box2D.Dynamics.b2World.prototype.GetContactList = function() {};

/**
 * Get the global gravity vector.
 * @return {!Box2D.Common.Math.b2Vec2} Global gravity vector.
 * 
 */
Box2D.Dynamics.b2World.prototype.GetGravity = function() {};

/**
 * The world provides a single static ground body with no collision shapes. You can use this to simplify the creation of joints and static shapes.
 * @return {!Box2D.Dynamics.b2Body} The ground body.
 * 
 */
Box2D.Dynamics.b2World.prototype.GetGroundBody = function() {};

/**
 * Get the number of joints.
 * @return {number} The number of joints in the world.
 * 
 */
Box2D.Dynamics.b2World.prototype.GetJointCount = function() {};

/**
 * Get the world joint list. With the returned joint, use b2Joint::GetNext to get the next joint in the world list. A NULL joint indicates the end of the list.
 * @return {!Box2D.Dynamics.Joints.b2Joint} The head of the world joint list.
 * 
 */
Box2D.Dynamics.b2World.prototype.GetJointList = function() {};

/**
 * Get the number of broad-phase proxies.
 * @return {number} Number of borad-phase proxies.
 * 
 */
Box2D.Dynamics.b2World.prototype.GetProxyCount = function() {};

/**
 * Is the world locked (in the middle of a time step).
 * @return {boolean} True if the world is locked and in the middle of a time step, otherwise false.
 * 
 */
Box2D.Dynamics.b2World.prototype.IsLocked = function() {};

/**
 * Query the world for all fixtures that potentially overlap the provided AABB.
 * @param {function(!Box2D.Dynamics.b2Fixture): boolean} callback  A user implemented callback class. It should match signature function Callback(fixture:b2Fixture):Boolean.  Return true to continue to the next fixture.
 * @param {!Box2D.Collision.b2AABB} aabb The query bounding box.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.QueryAABB = function(callback, aabb) {};

/**
 * Query the world for all fixtures that contain a point.
 * \@note This provides a feature specific to this port.
 * @param {function(!Box2D.Dynamics.b2Fixture): boolean} callback A user implemented callback class.  It should match signature function Callback(fixture:b2Fixture):Boolean.  Return true to continue to the next fixture.
 * @param {!Box2D.Common.Math.b2Vec2} p The query point.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.QueryPoint = function(callback, p) {};

/**
 * Query the world for all fixtures that precisely overlap the provided transformed shape.
 * \@note This provides a feature specific to this port.
 * @param {function(!Box2D.Dynamics.b2Fixture): boolean} callback A user implemented callback class.  It should match signature function Callback(fixture:b2Fixture):Boolean.  Return true to continue to the next fixture.
 * @param {!Box2D.Collision.Shapes.b2Shape} shape The query shape.
 * @param {!Box2D.Common.Math.b2Transform=} transform Optional transform, default = null.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.QueryShape = function(callback, shape, transform) {};

/**
 * Ray-cast the world for all fixtures in the path of the ray. Your callback Controls whether you get the closest point, any point, or n-points The ray-cast ignores shapes that contain the starting point.
 * @param {function(!Box2D.Dynamics.b2Fixture, !Box2D.Common.Math.b2Vec2, !Box2D.Common.Math.b2Vec2, number): number} callback A callback function which must be of signature:
 * 	function Callback(
 * 		fixture:b2Fixture,	// The fixture hit by the ray
 * 		point:b2Vec2,		// The point of initial intersection
 * 		normal:b2Vec2,		// The normal vector at the point of intersection
 * 		fraction:Number		// The fractional length along the ray of the intersection
 * 	 ):Number
 * 	 Callback should return the new length of the ray as a fraction of the original length. By returning 0, you immediately terminate. By returning 1, you continue wiht the original ray. By returning the current fraction, you proceed to find the closest point.
 * @param {!Box2D.Common.Math.b2Vec2} point1 The ray starting point.
 * @param {!Box2D.Common.Math.b2Vec2} point2 The ray ending point.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.RayCast = function(callback, point1, point2) {};

/**
 * Ray-cast the world for all fixture in the path of the ray.
 * @param {!Box2D.Common.Math.b2Vec2} point1 The ray starting point.
 * @param {!Box2D.Common.Math.b2Vec2} point2 The ray ending point.
 * @return {!Array<!Box2D.Dynamics.b2Fixture>} Array of all the fixtures intersected by the ray.
 * 
 */
Box2D.Dynamics.b2World.prototype.RayCastAll = function(point1, point2) {};

/**
 * Ray-cast the world for the first fixture in the path of the ray.
 * @param {!Box2D.Common.Math.b2Vec2} point1 The ray starting point.
 * @param {!Box2D.Common.Math.b2Vec2} point2 The ray ending point.
 * @return {!Box2D.Dynamics.b2Fixture} First fixture intersected by the ray.
 * 
 */
Box2D.Dynamics.b2World.prototype.RayCastOne = function(point1, point2) {};

/**
 * Removes the controller from the world.
 * @param {!Box2D.Dynamics.Controllers.b2Controller} c Controller to remove.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.RemoveController = function(c) {};

/**
 * Use the given object as a broadphase. The old broadphase will not be cleanly emptied.
 * \@warning This function is locked during callbacks.
 * @param {!Box2D.Collision.IBroadPhase} broadPhase
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.SetBroadPhase = function(broadPhase) {};

/**
 * Register a contact filter to provide specific control over collision. Otherwise the default filter is used (b2_defaultFilter).
 * @param {!Box2D.Dynamics.b2ContactFilter} filter Contact filter'er.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.SetContactFilter = function(filter) {};

/**
 * Register a contact event listener.
 * @param {!Box2D.Dynamics.b2ContactListener} listener Contact event listener.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.SetContactListener = function(listener) {};

/**
 * Enable/disable continuous physics. For testing.
 * @param {boolean} flag True for continuous physics, otherwise false.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.SetContinuousPhysics = function(flag) {};

/**
 * Register a routine for debug drawing. The debug draw functions are called inside the b2World::Step method, so make sure your renderer is ready to consume draw commands when you call Step().
 * @param {!Box2D.Dynamics.b2DebugDraw} debugDraw Debug drawing instance.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.SetDebugDraw = function(debugDraw) {};

/**
 * Destruct the world. All physics entities are destroyed and all heap memory is released.
 * @param {!Box2D.Dynamics.b2DestructionListener} listener Destruction listener instance.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.SetDestructionListener = function(listener) {};

/**
 * Change the global gravity vector.
 * @param {!Box2D.Common.Math.b2Vec2} gravity New global gravity vector.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.SetGravity = function(gravity) {};

/**
 * Enable/disable warm starting. For testing.
 * @param {boolean} flag True for warm starting, otherwise false.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.SetWarmStarting = function(flag) {};

/**
 * Take a time step. This performs collision detection, integration, and constraint solution.
 * @param {number} dt The amout of time to simulate, this should not vary.
 * @param {number} velocityIterations For the velocity constraint solver.
 * @param {number} positionIterations For the position constraint solver.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.Step = function(dt, velocityIterations, positionIterations) {};

/**
 * Perform validation of internal data structures.
 * 
 * @return {void}
 */
Box2D.Dynamics.b2World.prototype.Validate = function() {};
/** @const */
Box2D.Dynamics.Contacts = {};

/**
 * @constructor
 * @struct
 * Constructor
 * 
 */
Box2D.Dynamics.Contacts.b2Contact = function() {};

/**
 * Flag this contact for filtering. Filtering will occur the next time step.
 * 
 * @return {void}
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.FlagForFiltering = function() {};

/**
 * Get the first fixture in this contact.
 * @return {!Box2D.Dynamics.b2Fixture} First fixture in this contact.
 * 
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.GetFixtureA = function() {};

/**
 * Get the second fixture in this contact.
 * @return {!Box2D.Dynamics.b2Fixture} Second fixture in this contact.
 * 
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.GetFixtureB = function() {};

/**
 * Get the contact manifold. Do not modify the manifold unless you understand the internals of Box2D.
 * @return {!Box2D.Collision.b2Manifold} Contact manifold.
 * 
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.GetManifold = function() {};

/**
 * Get the next contact in the world's contact list.
 * @return {!Box2D.Dynamics.Contacts.b2Contact} Next contact in the world's contact list.
 * 
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.GetNext = function() {};

/**
 * Get the world manifold.
 * @param {!Box2D.Collision.b2WorldManifold} worldManifold World manifold out.
 * @return {void} World manifold.
 * 
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.GetWorldManifold = function(worldManifold) {};

/**
 * Does this contact generate TOI events for continuous simulation.
 * @return {boolean} True for continous, otherwise false.
 * 
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.IsContinuous = function() {};

/**
 * Has this contact been disabled?
 * @return {boolean} True if disabled, otherwise false.
 * 
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.IsEnabled = function() {};

/**
 * Is this contact a sensor?
 * @return {boolean} True if sensor, otherwise false.
 * 
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.IsSensor = function() {};

/**
 * Is this contact touching.
 * @return {boolean} True if contact is touching, otherwise false.
 * 
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.IsTouching = function() {};

/**
 * Enable/disable this contact. This can be used inside the pre-solve contact listener. The contact is only disabled for the current time step (or sub-step in continuous collision).
 * @param {boolean} flag True to enable, false to disable.
 * 
 * @return {void}
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.SetEnabled = function(flag) {};

/**
 * Change this to be a sensor or-non-sensor contact.
 * @param {boolean} sensor True to be sensor, false to not be a sensor.
 * 
 * @return {void}
 */
Box2D.Dynamics.Contacts.b2Contact.prototype.SetSensor = function(sensor) {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.Contacts.b2ContactEdge = function() {};
 /** @type {!Box2D.Dynamics.Contacts.b2Contact} */
Box2D.Dynamics.Contacts.b2ContactEdge.prototype.contact;
 /** @type {!Box2D.Dynamics.Contacts.b2ContactEdge} */
Box2D.Dynamics.Contacts.b2ContactEdge.prototype.next;
 /** @type {!Box2D.Dynamics.b2Body} */
Box2D.Dynamics.Contacts.b2ContactEdge.prototype.other;
 /** @type {!Box2D.Dynamics.Contacts.b2ContactEdge} */
Box2D.Dynamics.Contacts.b2ContactEdge.prototype.prev;
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.Contacts.b2ContactResult = function() {};
 /** @type {!Box2D.Collision.b2ContactID} */
Box2D.Dynamics.Contacts.b2ContactResult.prototype.id;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Contacts.b2ContactResult.prototype.normal;
 /** @type {number} */
Box2D.Dynamics.Contacts.b2ContactResult.prototype.normalImpulse;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Contacts.b2ContactResult.prototype.position;
 /** @type {!Box2D.Collision.Shapes.b2Shape} */
Box2D.Dynamics.Contacts.b2ContactResult.prototype.shape1;
 /** @type {!Box2D.Collision.Shapes.b2Shape} */
Box2D.Dynamics.Contacts.b2ContactResult.prototype.shape2;
 /** @type {number} */
Box2D.Dynamics.Contacts.b2ContactResult.prototype.tangentImpulse;
/** @const */
Box2D.Dynamics.Controllers = {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.Controllers.b2Controller = function() {};
 /** @type {number} */
Box2D.Dynamics.Controllers.b2Controller.prototype.m_bodyCount;
 /** @type {!Box2D.Dynamics.Controllers.b2ControllerEdge} */
Box2D.Dynamics.Controllers.b2Controller.prototype.m_bodyList;

/**
 * Adds a body to the controller.
 * @param {!Box2D.Dynamics.b2Body} body Body to add.
 * 
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2Controller.prototype.AddBody = function(body) {};

/**
 * Removes all bodies from the controller.
 * 
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2Controller.prototype.Clear = function() {};

/**
 * Debug drawing.
 * @param {!Box2D.Dynamics.b2DebugDraw} debugDraw Handle to drawer.
 * 
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2Controller.prototype.Draw = function(debugDraw) {};

/**
 * Gets the body list.
 * @return {!Box2D.Dynamics.Controllers.b2ControllerEdge} Body list.
 * 
 */
Box2D.Dynamics.Controllers.b2Controller.prototype.GetBodyList = function() {};

/**
 * Gets the next controller.
 * @return {!Box2D.Dynamics.Controllers.b2Controller} Next controller.
 * 
 */
Box2D.Dynamics.Controllers.b2Controller.prototype.GetNext = function() {};

/**
 * Gets the world.
 * @return {!Box2D.Dynamics.b2World} World.
 * 
 */
Box2D.Dynamics.Controllers.b2Controller.prototype.GetWorld = function() {};

/**
 * Removes a body from the controller.
 * @param {!Box2D.Dynamics.b2Body} body Body to remove from this controller.
 * 
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2Controller.prototype.RemoveBody = function(body) {};

/**
 * Step
 * @param {?} step b2TimeStep -> Private internal class.  Not sure why this is exposed.
 * 
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2Controller.prototype.Step = function(step) {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.Controllers.b2ControllerEdge = function() {};
 /** @type {!Box2D.Dynamics.b2Body} */
Box2D.Dynamics.Controllers.b2ControllerEdge.prototype.body;
 /** @type {!Box2D.Dynamics.Controllers.b2Controller} */
Box2D.Dynamics.Controllers.b2ControllerEdge.prototype.controller;
 /** @type {!Box2D.Dynamics.Controllers.b2ControllerEdge} */
Box2D.Dynamics.Controllers.b2ControllerEdge.prototype.nextBody;
 /** @type {!Box2D.Dynamics.Controllers.b2ControllerEdge} */
Box2D.Dynamics.Controllers.b2ControllerEdge.prototype.nextController;
 /** @type {!Box2D.Dynamics.Controllers.b2ControllerEdge} */
Box2D.Dynamics.Controllers.b2ControllerEdge.prototype.prevBody;
 /** @type {!Box2D.Dynamics.Controllers.b2ControllerEdge} */
Box2D.Dynamics.Controllers.b2ControllerEdge.prototype.prevController;
/**
 * @extends {Box2D.Dynamics.Controllers.b2Controller}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Controllers.b2BuoyancyController = function() {};
 /** @type {number} */
Box2D.Dynamics.Controllers.b2BuoyancyController.prototype.angularDrag;
 /** @type {number} */
Box2D.Dynamics.Controllers.b2BuoyancyController.prototype.density;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Controllers.b2BuoyancyController.prototype.gravity;
 /** @type {number} */
Box2D.Dynamics.Controllers.b2BuoyancyController.prototype.linearDrag;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Controllers.b2BuoyancyController.prototype.normal;
 /** @type {number} */
Box2D.Dynamics.Controllers.b2BuoyancyController.prototype.offset;
 /** @type {boolean} */
Box2D.Dynamics.Controllers.b2BuoyancyController.prototype.useDensity;
 /** @type {boolean} */
Box2D.Dynamics.Controllers.b2BuoyancyController.prototype.useWorldGravity;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Controllers.b2BuoyancyController.prototype.velocity;
/**
 * @extends {Box2D.Dynamics.Controllers.b2Controller}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Controllers.b2ConstantAccelController = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Controllers.b2ConstantAccelController.prototype.A;

/**
 * @see b2Controller.Step
 * 
 * @param {?} step
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2ConstantAccelController.prototype.Step = function(step) {};
/**
 * @extends {Box2D.Dynamics.Controllers.b2Controller}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Controllers.b2ConstantForceController = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Controllers.b2ConstantForceController.prototype.A;

/**
 * @see b2Controller.Step
 * 
 * @param {?} step
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2ConstantForceController.prototype.Step = function(step) {};
/**
 * @extends {Box2D.Dynamics.Controllers.b2Controller}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Controllers.b2GravityController = function() {};
 /** @type {number} */
Box2D.Dynamics.Controllers.b2GravityController.prototype.G;
 /** @type {boolean} */
Box2D.Dynamics.Controllers.b2GravityController.prototype.invSqr;

/**
 * @see b2Controller.Step
 * 
 * @param {?} step
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2GravityController.prototype.Step = function(step) {};
/**
 * @extends {Box2D.Dynamics.Controllers.b2Controller}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Controllers.b2TensorDampingController = function() {};
 /** @type {number} */
Box2D.Dynamics.Controllers.b2TensorDampingController.prototype.maxTimeStep;
 /** @type {!Box2D.Common.Math.b2Mat22} */
Box2D.Dynamics.Controllers.b2TensorDampingController.prototype.T;

/**
 * Helper function to set T in a common case.
 * @param {number} xDamping x
 * @param {number} yDamping y
 * 
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2TensorDampingController.prototype.SetAxisAligned = function(xDamping, yDamping) {};

/**
 * @see b2Controller.Step
 * 
 * @param {?} step
 * @return {void}
 */
Box2D.Dynamics.Controllers.b2TensorDampingController.prototype.Step = function(step) {};
/** @const */
Box2D.Dynamics.Joints = {};
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2Joint = function() {};

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Anchor A point.
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Anchor B point.
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.GetAnchorB = function() {};

/**
 * Get the first body attached to this joint.
 * @return {!Box2D.Dynamics.b2Body} Body A.
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.GetBodyA = function() {};

/**
 * Get the second body attached to this joint.
 * @return {!Box2D.Dynamics.b2Body} Body B.
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.GetBodyB = function() {};

/**
 * Get the next joint the world joint list.
 * @return {!Box2D.Dynamics.Joints.b2Joint} Next joint.
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.GetNext = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in Newtons.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force (N)
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque (N).
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * Get the type of the concrete joint.
 * @return {number} Joint type.
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.GetType = function() {};

/**
 * Get the user data pointer.
 * @return {?} User data.  Cast to your data type.
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.GetUserData = function() {};

/**
 * Short-cut function to determine if either body is inactive.
 * @return {boolean} True if active, otherwise false.
 * 
 */
Box2D.Dynamics.Joints.b2Joint.prototype.IsActive = function() {};

/**
 * Set the user data pointer.
 * @param {?} data Your custom data.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2Joint.prototype.SetUserData = function(data) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2JointDef = function() {};
 /** @type {!Box2D.Dynamics.b2Body} */
Box2D.Dynamics.Joints.b2JointDef.prototype.bodyA;
 /** @type {!Box2D.Dynamics.b2Body} */
Box2D.Dynamics.Joints.b2JointDef.prototype.bodyB;
 /** @type {boolean} */
Box2D.Dynamics.Joints.b2JointDef.prototype.collideConnected;
 /** @type {number} */
Box2D.Dynamics.Joints.b2JointDef.prototype.type;
 /** @type {?} */
Box2D.Dynamics.Joints.b2JointDef.prototype.userData;
/**
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2JointEdge = function() {};
 /** @type {!Box2D.Dynamics.Joints.b2Joint} */
Box2D.Dynamics.Joints.b2JointEdge.prototype.joint;
 /** @type {!Box2D.Dynamics.Joints.b2JointEdge} */
Box2D.Dynamics.Joints.b2JointEdge.prototype.next;
 /** @type {!Box2D.Dynamics.b2Body} */
Box2D.Dynamics.Joints.b2JointEdge.prototype.other;
 /** @type {!Box2D.Dynamics.Joints.b2JointEdge} */
Box2D.Dynamics.Joints.b2JointEdge.prototype.prev;
/**
 * @extends {Box2D.Dynamics.Joints.b2Joint}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2DistanceJoint = function() {};

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body A anchor.
 * 
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body B anchor.
 * 
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.GetAnchorB = function() {};

/**
 * Gets the damping ratio.
 * @return {number} Damping ratio.
 * 
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.GetDampingRatio = function() {};

/**
 * Gets the frequency.
 * @return {number} Frequency.
 * 
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.GetFrequency = function() {};

/**
 * Gets the length of distance between the two bodies.
 * @return {number} Length.
 * 
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.GetLength = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in N.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force in N.
 * 
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body 2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque in N.
 * 
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * Sets the damping ratio.
 * @param {number} ratio New damping ratio.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.SetDampingRatio = function(ratio) {};

/**
 * Sets the frequency.
 * @param {number} hz New frequency (hertz).
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.SetFrequency = function(hz) {};

/**
 * Sets the length of distance between the two bodies.
 * @param {number} length New length.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2DistanceJoint.prototype.SetLength = function(length) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2DistanceJointDef = function() {};
 /** @type {number} */
Box2D.Dynamics.Joints.b2DistanceJointDef.prototype.dampingRatio;
 /** @type {number} */
Box2D.Dynamics.Joints.b2DistanceJointDef.prototype.frequencyHz;
 /** @type {number} */
Box2D.Dynamics.Joints.b2DistanceJointDef.prototype.length;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2DistanceJointDef.prototype.localAnchorA;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2DistanceJointDef.prototype.localAnchorB;

/**
 * Initialize the bodies, anchors, and length using the world anchors.
 * @param {!Box2D.Dynamics.b2Body} bA Body A.
 * @param {!Box2D.Dynamics.b2Body} bB Body B.
 * @param {!Box2D.Common.Math.b2Vec2} anchorA Anchor A.
 * @param {!Box2D.Common.Math.b2Vec2} anchorB Anchor B.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2DistanceJointDef.prototype.Initialize = function(bA, bB, anchorA, anchorB) {};
/**
 * @extends {Box2D.Dynamics.Joints.b2Joint}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2FrictionJoint = function() {};
 /** @type {number} */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.m_angularMass;
 /** @type {!Box2D.Common.Math.b2Mat22} */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.m_linearMass;

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body A anchor.
 * 
 */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body B anchor.
 * 
 */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.GetAnchorB = function() {};

/**
 * Gets the max force.
 * @return {number} Max force.
 * 
 */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.GetMaxForce = function() {};

/**
 * Gets the max torque.
 * @return {number} Max torque.
 * 
 */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.GetMaxTorque = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in N.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force in N.
 * 
 */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body 2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque in N.
 * 
 */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * Sets the max force.
 * @param {number} force New max force.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.SetMaxForce = function(force) {};

/**
 * Sets the max torque.
 * @param {number} torque New max torque.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2FrictionJoint.prototype.SetMaxTorque = function(torque) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2FrictionJointDef = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2FrictionJointDef.prototype.localAnchorA;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2FrictionJointDef.prototype.localAnchorB;
 /** @type {number} */
Box2D.Dynamics.Joints.b2FrictionJointDef.prototype.maxForce;
 /** @type {number} */
Box2D.Dynamics.Joints.b2FrictionJointDef.prototype.maxTorque;

/**
 * Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
 * @param {!Box2D.Dynamics.b2Body} bA Body A.
 * @param {!Box2D.Dynamics.b2Body} bB Body B.
 * @param {!Box2D.Common.Math.b2Vec2} anchor World anchor.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2FrictionJointDef.prototype.Initialize = function(bA, bB, anchor) {};
/**
 * @extends {Box2D.Dynamics.Joints.b2Joint}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2GearJoint = function() {};

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body A anchor.
 * 
 */
Box2D.Dynamics.Joints.b2GearJoint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body B anchor.
 * 
 */
Box2D.Dynamics.Joints.b2GearJoint.prototype.GetAnchorB = function() {};

/**
 * Get the gear ratio.
 * @return {number} Gear ratio.
 * 
 */
Box2D.Dynamics.Joints.b2GearJoint.prototype.GetRatio = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in N.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force in N.
 * 
 */
Box2D.Dynamics.Joints.b2GearJoint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body 2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque in N.
 * 
 */
Box2D.Dynamics.Joints.b2GearJoint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * Set the gear ratio.
 * @param {number} ratio
 * @return {void}
 */
Box2D.Dynamics.Joints.b2GearJoint.prototype.SetRatio = function(ratio) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2GearJointDef = function() {};
 /** @type {!Box2D.Dynamics.Joints.b2Joint} */
Box2D.Dynamics.Joints.b2GearJointDef.prototype.joint1;
 /** @type {!Box2D.Dynamics.Joints.b2Joint} */
Box2D.Dynamics.Joints.b2GearJointDef.prototype.joint2;
 /** @type {number} */
Box2D.Dynamics.Joints.b2GearJointDef.prototype.ratio;
/**
 * @extends {Box2D.Dynamics.Joints.b2Joint}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2LineJoint = function() {};

/**
 * Enable/disable the joint limit.
 * @param {boolean} flag True to enable, false to disable limits
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.EnableLimit = function(flag) {};

/**
 * Enable/disable the joint motor.
 * @param {boolean} flag True to enable, false to disable the motor.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.EnableMotor = function(flag) {};

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body A anchor.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body B anchor.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetAnchorB = function() {};

/**
 * Get the current joint translation speed, usually in meters per second.
 * @return {number} Joint speed.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetJointSpeed = function() {};

/**
 * Get the current joint translation, usually in meters.
 * @return {number} Joint translation.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetJointTranslation = function() {};

/**
 * Get the lower joint limit, usually in meters.
 * @return {number} Lower limit.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetLowerLimit = function() {};

/**
 * Get the maximum motor force, usually in N.
 * @return {number} Max motor force.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetMaxMotorForce = function() {};

/**
 * Get the current motor force, usually in N.
 * @return {number} Motor force.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetMotorForce = function() {};

/**
 * Get the motor speed, usually in meters per second.
 * @return {number} Motor speed.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetMotorSpeed = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in N.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force in N.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body 2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque in N.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * Get the upper joint limit, usually in meters.
 * @return {number} Upper limit.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.GetUpperLimit = function() {};

/**
 * Is the joint limit enabled?
 * @return {boolean} True if enabled otherwise false.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.IsLimitEnabled = function() {};

/**
 * Is the joint motor enabled?
 * @return {boolean} True if enabled, otherwise false.
 * 
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.IsMotorEnabled = function() {};

/**
 * Set the joint limits, usually in meters.
 * @param {number} lower Lower limit.
 * @param {number} upper Upper limit.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.SetLimits = function(lower, upper) {};

/**
 * Set the maximum motor force, usually in N.
 * @param {number} force New max motor force.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.SetMaxMotorForce = function(force) {};

/**
 * Set the motor speed, usually in meters per second.
 * @param {number} speed New motor speed.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2LineJoint.prototype.SetMotorSpeed = function(speed) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2LineJointDef = function() {};
 /** @type {boolean} */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.enableLimit;
 /** @type {boolean} */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.enableMotor;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.localAnchorA;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.localAnchorB;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.localAxisA;
 /** @type {number} */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.lowerTranslation;
 /** @type {number} */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.maxMotorForce;
 /** @type {number} */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.motorSpeed;
 /** @type {number} */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.upperTranslation;

/**
 * Initialize the bodies, anchors, and length using the world anchors.
 * @param {!Box2D.Dynamics.b2Body} bA Body A.
 * @param {!Box2D.Dynamics.b2Body} bB Body B.
 * @param {!Box2D.Common.Math.b2Vec2} anchor Anchor.
 * @param {!Box2D.Common.Math.b2Vec2} axis Axis.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2LineJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {};
/**
 * @extends {Box2D.Dynamics.Joints.b2Joint}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2MouseJoint = function() {};

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body A anchor.
 * 
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body B anchor.
 * 
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.GetAnchorB = function() {};

/**
 * Gets the damping ratio.
 * @return {number} Damping ratio.
 * 
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.GetDampingRatio = function() {};

/**
 * Gets the frequency.
 * @return {number} Frequency.
 * 
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.GetFrequency = function() {};

/**
 * Gets the max force.
 * @return {number} Max force.
 * 
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.GetMaxForce = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in N.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force in N.
 * 
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body 2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque in N.
 * 
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * Gets the target.
 * @return {!Box2D.Common.Math.b2Vec2} Target.
 * 
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.GetTarget = function() {};

/**
 * Sets the damping ratio.
 * @param {number} ratio New damping ratio.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.SetDampingRatio = function(ratio) {};

/**
 * Sets the frequency.
 * @param {number} hz New frequency (hertz).
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.SetFrequency = function(hz) {};

/**
 * Sets the max force.
 * @param {number} maxForce New max force.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.SetMaxForce = function(maxForce) {};

/**
 * Use this to update the target point.
 * @param {!Box2D.Common.Math.b2Vec2} target New target.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2MouseJoint.prototype.SetTarget = function(target) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2MouseJointDef = function() {};
 /** @type {number} */
Box2D.Dynamics.Joints.b2MouseJointDef.prototype.dampingRatio;
 /** @type {number} */
Box2D.Dynamics.Joints.b2MouseJointDef.prototype.frequencyHz;
 /** @type {number} */
Box2D.Dynamics.Joints.b2MouseJointDef.prototype.maxForce;
/**
 * @extends {Box2D.Dynamics.Joints.b2Joint}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2PrismaticJoint = function() {};

/**
 * Enable/disable the joint limit.
 * @param {boolean} flag True to enable, false to disable.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.EnableLimit = function(flag) {};

/**
 * Enable/disable the joint motor.
 * @param {boolean} flag True to enable, false to disable.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.EnableMotor = function(flag) {};

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body A anchor.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body B anchor.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetAnchorB = function() {};

/**
 * Get the current joint translation speed, usually in meters per second.
 * @return {number} Joint speed.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetJointSpeed = function() {};

/**
 * Get the current joint translation, usually in meters.
 * @return {number} Joint translation.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetJointTranslation = function() {};

/**
 * Get the lower joint limit, usually in meters.
 * @return {number} Lower limit.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetLowerLimit = function() {};

/**
 * Get the current motor force, usually in N.
 * @return {number} Motor force.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetMotorForce = function() {};

/**
 * Get the motor speed, usually in meters per second.
 * @return {number} Motor speed.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetMotorSpeed = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in N.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force in N.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body 2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque in N.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * Get the upper joint limit, usually in meters.
 * @return {number} Upper limit.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetUpperLimit = function() {};

/**
 * Is the joint limit enabled?
 * @return {boolean} True if enabled otherwise false.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.IsLimitEnabled = function() {};

/**
 * Is the joint motor enabled?
 * @return {boolean} True if enabled, otherwise false.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.IsMotorEnabled = function() {};

/**
 * Set the joint limits, usually in meters.
 * @param {number} lower Lower limit.
 * @param {number} upper Upper limit.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.SetLimits = function(lower, upper) {};

/**
 * Set the maximum motor force, usually in N.
 * @param {number} force New max force.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.SetMaxMotorForce = function(force) {};

/**
 * Set the motor speed, usually in meters per second.
 * @param {number} speed New motor speed.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2PrismaticJoint.prototype.SetMotorSpeed = function(speed) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2PrismaticJointDef = function() {};
 /** @type {boolean} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.enableLimit;
 /** @type {boolean} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.enableMotor;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.localAnchorA;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.localAnchorB;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.localAxisA;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.lowerTranslation;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.maxMotorForce;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.motorSpeed;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.referenceAngle;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.upperTranslation;

/**
 * Initialize the joint.
 * @param {!Box2D.Dynamics.b2Body} bA Body A.
 * @param {!Box2D.Dynamics.b2Body} bB Body B.
 * @param {!Box2D.Common.Math.b2Vec2} anchor Anchor.
 * @param {!Box2D.Common.Math.b2Vec2} axis Axis.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2PrismaticJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {};
/**
 * @extends {Box2D.Dynamics.Joints.b2Joint}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2PullyJoint = function() {};

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body A anchor.
 * 
 */
Box2D.Dynamics.Joints.b2PullyJoint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body B anchor.
 * 
 */
Box2D.Dynamics.Joints.b2PullyJoint.prototype.GetAnchorB = function() {};

/**
 * Get the first ground anchor.
 * 
 * @return {!Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.Joints.b2PullyJoint.prototype.GetGroundAnchorA = function() {};

/**
 * Get the second ground anchor.
 * 
 * @return {!Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.Joints.b2PullyJoint.prototype.GetGroundAnchorB = function() {};

/**
 * Get the current length of the segment attached to body1.
 * 
 * @return {number}
 */
Box2D.Dynamics.Joints.b2PullyJoint.prototype.GetLength1 = function() {};

/**
 * Get the current length of the segment attached to body2.
 * 
 * @return {number}
 */
Box2D.Dynamics.Joints.b2PullyJoint.prototype.GetLength2 = function() {};

/**
 * Get the pulley ratio.
 * 
 * @return {number}
 */
Box2D.Dynamics.Joints.b2PullyJoint.prototype.GetRatio = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in N.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force in N.
 * 
 */
Box2D.Dynamics.Joints.b2PullyJoint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body 2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque in N.
 * 
 */
Box2D.Dynamics.Joints.b2PullyJoint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2PullyJointDef = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.groundAnchorA;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.groundAnchorB;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.lengthA;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.lengthB;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.localAnchorA;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.localAnchorB;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.maxLengthA;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.maxLengthB;
 /** @type {number} */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.ratio;

/**
 * Initialize the bodies, anchors, and length using the world anchors.
 * @param {!Box2D.Dynamics.b2Body} bA Body A.
 * @param {!Box2D.Dynamics.b2Body} bB Body B.
 * @param {!Box2D.Common.Math.b2Vec2} gaA Ground anchor A.
 * @param {!Box2D.Common.Math.b2Vec2} gaB Ground anchor B.
 * @param {!Box2D.Common.Math.b2Vec2} anchorA Anchor A.
 * @param {!Box2D.Common.Math.b2Vec2} anchorB Anchor B.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2PullyJointDef.prototype.Initialize = function(bA, bB, gaA, gaB, anchorA, anchorB) {};
/**
 * @extends {Box2D.Dynamics.Joints.b2Joint}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2RevoluteJoint = function() {};

/**
 * Enable/disable the joint limit.
 * @param {boolean} flag True to enable, false to disable.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.EnableLimit = function(flag) {};

/**
 * Enable/disable the joint motor.
 * @param {boolean} flag True to enable, false to diasable.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.EnableMotor = function(flag) {};

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body A anchor.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body B anchor.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetAnchorB = function() {};

/**
 * Get the current joint angle in radians.
 * @return {number} Joint angle.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetJointAngle = function() {};

/**
 * Get the current joint angle speed in radians per second.
 * @return {number} Joint speed.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetJointSpeed = function() {};

/**
 * Get the lower joint limit in radians.
 * @return {number} Lower limit.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetLowerLimit = function() {};

/**
 * Get the motor speed in radians per second.
 * @return {number} Motor speed.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetMotorSpeed = function() {};

/**
 * Get the current motor torque, usually in N-m.
 * @return {number} Motor torque.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetMotorTorque = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in N.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force in N.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body 2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque in N.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * Get the upper joint limit in radians.
 * @return {number} Upper limit.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetUpperLimit = function() {};

/**
 * Is the joint limit enabled?
 * @return {boolean} True if enabled, false if disabled.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.IsLimitEnabled = function() {};

/**
 * Is the joint motor enabled?
 * @return {boolean} True if enabled, false if disabled.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.IsMotorEnabled = function() {};

/**
 * Set the joint limits in radians.
 * @param {number} lower New lower limit.
 * @param {number} upper New upper limit.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.SetLimits = function(lower, upper) {};

/**
 * Set the maximum motor torque, usually in N-m.
 * @param {number} torque New max torque.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.SetMaxMotorTorque = function(torque) {};

/**
 * Set the motor speed in radians per second.
 * @param {number} speed New motor speed.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2RevoluteJoint.prototype.SetMotorSpeed = function(speed) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2RevoluteJointDef = function() {};
 /** @type {boolean} */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.enableLimit;
 /** @type {boolean} */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.enableMotor;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.localAnchorA;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.localAnchorB;
 /** @type {number} */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.lowerAngle;
 /** @type {number} */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.maxMotorTorque;
 /** @type {number} */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.motorSpeed;
 /** @type {number} */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.referenceAngle;
 /** @type {number} */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.upperAngle;

/**
 * Initialize the bodies, achors, and reference angle using the world anchor.
 * @param {!Box2D.Dynamics.b2Body} bA Body A.
 * @param {!Box2D.Dynamics.b2Body} bB Body B.
 * @param {!Box2D.Common.Math.b2Vec2} anchor Anchor.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2RevoluteJointDef.prototype.Initialize = function(bA, bB, anchor) {};
/**
 * @extends {Box2D.Dynamics.Joints.b2Joint}
 * @constructor
 * @struct
 */
Box2D.Dynamics.Joints.b2WeldJoint = function() {};

/**
 * Get the anchor point on bodyA in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body A anchor.
 * 
 */
Box2D.Dynamics.Joints.b2WeldJoint.prototype.GetAnchorA = function() {};

/**
 * Get the anchor point on bodyB in world coordinates.
 * @return {!Box2D.Common.Math.b2Vec2} Body B anchor.
 * 
 */
Box2D.Dynamics.Joints.b2WeldJoint.prototype.GetAnchorB = function() {};

/**
 * Get the reaction force on body2 at the joint anchor in N.
 * @param {number} inv_dt
 * @return {!Box2D.Common.Math.b2Vec2} Reaction force in N.
 * 
 */
Box2D.Dynamics.Joints.b2WeldJoint.prototype.GetReactionForce = function(inv_dt) {};

/**
 * Get the reaction torque on body 2 in N.
 * @param {number} inv_dt
 * @return {number} Reaction torque in N.
 * 
 */
Box2D.Dynamics.Joints.b2WeldJoint.prototype.GetReactionTorque = function(inv_dt) {};

/**
 * @constructor
 * @struct
 * Constructor.
 * 
 */
Box2D.Dynamics.Joints.b2WeldJointDef = function() {};
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2WeldJointDef.prototype.localAnchorA;
 /** @type {!Box2D.Common.Math.b2Vec2} */
Box2D.Dynamics.Joints.b2WeldJointDef.prototype.localAnchorB;
 /** @type {number} */
Box2D.Dynamics.Joints.b2WeldJointDef.prototype.referenceAngle;

/**
 * Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
 * @param {!Box2D.Dynamics.b2Body} bA Body A.
 * @param {!Box2D.Dynamics.b2Body} bB Body B.
 * @param {!Box2D.Common.Math.b2Vec2} anchor Anchor.
 * 
 * @return {void}
 */
Box2D.Dynamics.Joints.b2WeldJointDef.prototype.Initialize = function(bA, bB, anchor) {};
