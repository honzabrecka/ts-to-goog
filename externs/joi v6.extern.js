/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/joi v6/index.d.ts:
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "joi"
/** @const */
tsickle_declare_module.joi = {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.ValidationOptions = function() {};
 /** @type {boolean} */
tsickle_declare_module.joi.ValidationOptions.prototype.abortEarly;
 /** @type {boolean} */
tsickle_declare_module.joi.ValidationOptions.prototype.convert;
 /** @type {boolean} */
tsickle_declare_module.joi.ValidationOptions.prototype.allowUnknown;
 /** @type {boolean} */
tsickle_declare_module.joi.ValidationOptions.prototype.skipFunctions;
 /** @type {boolean} */
tsickle_declare_module.joi.ValidationOptions.prototype.stripUnknown;
 /** @type {!Object} */
tsickle_declare_module.joi.ValidationOptions.prototype.language;
 /** @type {string} */
tsickle_declare_module.joi.ValidationOptions.prototype.presence;
 /** @type {!Object} */
tsickle_declare_module.joi.ValidationOptions.prototype.context;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.RenameOptions = function() {};
 /** @type {boolean} */
tsickle_declare_module.joi.RenameOptions.prototype.alias;
 /** @type {boolean} */
tsickle_declare_module.joi.RenameOptions.prototype.multiple;
 /** @type {boolean} */
tsickle_declare_module.joi.RenameOptions.prototype.override;
 /** @type {boolean} */
tsickle_declare_module.joi.RenameOptions.prototype.ignoreUndefined;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.EmailOptions = function() {};
 /** @type {(number|boolean)} */
tsickle_declare_module.joi.EmailOptions.prototype.errorLevel;
 /** @type {(!Object|!Array<string>)} */
tsickle_declare_module.joi.EmailOptions.prototype.tldWhitelist;
 /** @type {number} */
tsickle_declare_module.joi.EmailOptions.prototype.minDomainAtoms;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.IpOptions = function() {};
 /** @type {(string|!Array<string>)} */
tsickle_declare_module.joi.IpOptions.prototype.version;
 /** @type {string} */
tsickle_declare_module.joi.IpOptions.prototype.cidr;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.UriOptions = function() {};
 /** @type {(string|!RegExp|!Array<(string|!RegExp)>)} */
tsickle_declare_module.joi.UriOptions.prototype.scheme;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.WhenOptions = function() {};
 /** @type {T} */
tsickle_declare_module.joi.WhenOptions.prototype.is;
 /** @type {!Schema} */
tsickle_declare_module.joi.WhenOptions.prototype.then;
 /** @type {!Schema} */
tsickle_declare_module.joi.WhenOptions.prototype.otherwise;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.ReferenceOptions = function() {};
 /** @type {string} */
tsickle_declare_module.joi.ReferenceOptions.prototype.separator;
 /** @type {string} */
tsickle_declare_module.joi.ReferenceOptions.prototype.contextPrefix;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.IPOptions = function() {};
 /** @type {!Array<string>} */
tsickle_declare_module.joi.IPOptions.prototype.version;
 /** @type {string} */
tsickle_declare_module.joi.IPOptions.prototype.cidr;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.ValidationError = function() {};
 /** @type {string} */
tsickle_declare_module.joi.ValidationError.prototype.message;
 /** @type {!Array<!ValidationErrorItem>} */
tsickle_declare_module.joi.ValidationError.prototype.details;

/**
 * @return {string}
 */
tsickle_declare_module.joi.ValidationError.prototype.simple = function() {};

/**
 * @return {string}
 */
tsickle_declare_module.joi.ValidationError.prototype.annotated = function() {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.ValidationErrorItem = function() {};
 /** @type {string} */
tsickle_declare_module.joi.ValidationErrorItem.prototype.message;
 /** @type {string} */
tsickle_declare_module.joi.ValidationErrorItem.prototype.type;
 /** @type {string} */
tsickle_declare_module.joi.ValidationErrorItem.prototype.path;
 /** @type {!ValidationOptions} */
tsickle_declare_module.joi.ValidationErrorItem.prototype.options;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.ValidationResult = function() {};
 /** @type {!ValidationError} */
tsickle_declare_module.joi.ValidationResult.prototype.error;
 /** @type {T} */
tsickle_declare_module.joi.ValidationResult.prototype.value;
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.SchemaMap = function() {};

/* TODO: IndexSignature: tsickle_declare_module.joi */
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.Schema = function() {};
/**
 * @extends {Schema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.Reference = function() {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.joi.AnySchema = function() {};

/**
 * Whitelists a value
 * @param {?|!Array<?>} value_or_values
 * @param {...?} values
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.allow = function(value_or_values, values) {};

/**
 * Adds the provided values into the allowed whitelist and marks them as the only valid values allowed.
 * @param {?|!Array<?>} value_or_values
 * @param {...?} values
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.valid = function(value_or_values, values) {};

/**
 * @param {?|!Array<?>} value_or_values
 * @param {...?} values
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.only = function(value_or_values, values) {};

/**
 * @param {?|!Array<?>} value_or_values
 * @param {...?} values
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.equal = function(value_or_values, values) {};

/**
 * Blacklists a value
 * @param {?|!Array<?>} value_or_values
 * @param {...?} values
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.invalid = function(value_or_values, values) {};

/**
 * @param {?|!Array<?>} value_or_values
 * @param {...?} values
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.disallow = function(value_or_values, values) {};

/**
 * @param {?|!Array<?>} value_or_values
 * @param {...?} values
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.not = function(value_or_values, values) {};

/**
 * Marks a key as required which will not allow undefined as value. All keys are optional by default.
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.required = function() {};

/**
 * Marks a key as optional which will allow undefined as values. Used to annotate the schema for readability as all keys are optional by default.
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.optional = function() {};

/**
 * Marks a key as forbidden which will not allow any value except undefined. Used to explicitly forbid keys.
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.forbidden = function() {};

/**
 * Marks a key to be removed from a resulting object or array after validation. Used to sanitize output.
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.strip = function() {};

/**
 * Annotates the key
 * @param {string} desc
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.description = function(desc) {};

/**
 * Annotates the key
 * @param {string|!Array<string>} notes
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.notes = function(notes) {};

/**
 * Annotates the key
 * @param {string|!Array<string>} notes
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.tags = function(notes) {};

/**
 * Attaches metadata to the key.
 * @param {!Object} meta
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.meta = function(meta) {};

/**
 * Annotates the key with an example value, must be valid.
 * @param {?} value
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.example = function(value) {};

/**
 * Annotates the key with an unit name.
 * @param {string} name
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.unit = function(name) {};

/**
 * Overrides the global validate() options for the current key and any sub-key.
 * @param {!ValidationOptions} options
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.options = function(options) {};

/**
 * Sets the options.convert options to false which prevent type casting for the current key and any child keys.
 * @param {boolean=} isStrict
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.strict = function(isStrict) {};

/**
 * Sets a default value if the original value is undefined.
 * @param {?=} value - the value.
 *   value supports references.
 *   value may also be a function which returns the default value.
 *   If value is specified as a function that accepts a single parameter, that parameter will be a context
 *    object that can be used to derive the resulting value. This clones the object however, which incurs some
 *    overhead so if you don't need access to the context define your method so that it does not accept any
 *    parameters.
 *   Without any value, default has no effect, except for object that will then create nested defaults
 *    (applying inner defaults of that object).
 * 
 * Note that if value is an object, any changes to the object after default() is called will change the
 *  reference and any future assignment.
 * 
 * Additionally, when specifying a method you must either have a description property on your method or the
 *  second parameter is required.
 * @param {string=} description
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.default = function(value, description) {};

/**
 * Returns a new type that is the result of adding the rules of one type to another.
 * @param {T} schema
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.concat = function(schema) {};

/**
 * Converts the type into an alternatives type where the conditions are merged into the type definition where:
 * @template U
 * @param {string|!Reference} ref
 * @param {!WhenOptions<U>} options
 * @return {!AlternativesSchema}
 */
tsickle_declare_module.joi.AnySchema.prototype.when = function(ref, options) {};

/**
 * Overrides the key name in error messages.
 * @param {string} name
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.label = function(name) {};

/**
 * Outputs the original untouched value instead of the casted value.
 * @param {boolean=} isRaw
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.raw = function(isRaw) {};

/**
 * Considers anything that matches the schema to be empty (undefined).
 * @param {?=} schema - any object or joi schema to match. An undefined schema unsets that rule.
 * @return {T}
 */
tsickle_declare_module.joi.AnySchema.prototype.empty = function(schema) {};
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.BooleanSchema = function() {};
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.NumberSchema = function() {};

/**
 * Specifies the minimum value.
 * It can also be a reference to another field.
 * @param {number|!Reference} limit
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.NumberSchema.prototype.min = function(limit) {};

/**
 * Specifies the maximum value.
 * It can also be a reference to another field.
 * @param {number|!Reference} limit
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.NumberSchema.prototype.max = function(limit) {};

/**
 * Specifies that the value must be greater than limit.
 * It can also be a reference to another field.
 * @param {number|!Reference} limit
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.NumberSchema.prototype.greater = function(limit) {};

/**
 * Specifies that the value must be less than limit.
 * It can also be a reference to another field.
 * @param {number|!Reference} limit
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.NumberSchema.prototype.less = function(limit) {};

/**
 * Requires the number to be an integer (no floating point).
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.NumberSchema.prototype.integer = function() {};

/**
 * Specifies the maximum number of decimal places where:
 *  limit - the maximum number of decimal places allowed.
 * @param {number} limit
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.NumberSchema.prototype.precision = function(limit) {};

/**
 * Specifies that the value must be a multiple of base.
 * @param {number} base
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.NumberSchema.prototype.multiple = function(base) {};

/**
 * Requires the number to be positive.
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.NumberSchema.prototype.positive = function() {};

/**
 * Requires the number to be negative.
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.NumberSchema.prototype.negative = function() {};
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.StringSchema = function() {};

/**
 * Allows the value to match any whitelist of blacklist item in a case insensitive comparison.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.insensitive = function() {};

/**
 * Specifies the minimum number string characters.
 * @param {number|!Reference} limit - the minimum number of string characters required. It can also be a reference to another field.
 * @param {string=} encoding - if specified, the string length is calculated in bytes using the provided encoding.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.min = function(limit, encoding) {};

/**
 * Specifies the maximum number of string characters.
 * @param {number|!Reference} limit - the maximum number of string characters allowed. It can also be a reference to another field.
 * @param {string=} encoding - if specified, the string length is calculated in bytes using the provided encoding.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.max = function(limit, encoding) {};

/**
 * Requires the number to be a credit card number (Using Lunh Algorithm).
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.creditCard = function() {};

/**
 * Specifies the exact string length required
 * @param {number|!Reference} limit - the required string length. It can also be a reference to another field.
 * @param {string=} encoding - if specified, the string length is calculated in bytes using the provided encoding.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.length = function(limit, encoding) {};

/**
 * Defines a regular expression rule.
 * @param {!RegExp} pattern - a regular expression object the string value must match against.
 * @param {string=} name - optional name for patterns (useful with multiple patterns). Defaults to 'required'.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.regex = function(pattern, name) {};

/**
 * Replace characters matching the given pattern with the specified replacement string where:
 * @param {!RegExp|string} pattern - a regular expression object to match against, or a string of which all occurrences will be replaced.
 * @param {string} replacement - the string that will replace the pattern.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.replace = function(pattern, replacement) {};

/**
 * Requires the string value to only contain a-z, A-Z, and 0-9.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.alphanum = function() {};

/**
 * Requires the string value to only contain a-z, A-Z, 0-9, and underscore _.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.token = function() {};

/**
 * Requires the string value to be a valid email address.
 * @param {!EmailOptions=} options
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.email = function(options) {};

/**
 * Requires the string value to be a valid ip address.
 * @param {!IpOptions=} options
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.ip = function(options) {};

/**
 * Requires the string value to be a valid RFC 3986 URI.
 * @param {!UriOptions=} options
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.uri = function(options) {};

/**
 * Requires the string value to be a valid GUID.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.guid = function() {};

/**
 * Requires the string value to be a valid hexadecimal string.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.hex = function() {};

/**
 * Requires the string value to be a valid hostname as per RFC1123.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.hostname = function() {};

/**
 * Requires the string value to be in valid ISO 8601 date format.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.isoDate = function() {};

/**
 * Requires the string value to be all lowercase. If the validation convert option is on (enabled by default), the string will be forced to lowercase.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.lowercase = function() {};

/**
 * Requires the string value to be all uppercase. If the validation convert option is on (enabled by default), the string will be forced to uppercase.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.uppercase = function() {};

/**
 * Requires the string value to contain no whitespace before or after. If the validation convert option is on (enabled by default), the string will be trimmed.
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.StringSchema.prototype.trim = function() {};
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.ArraySchema = function() {};

/**
 * Allow this array to be sparse.
 * enabled can be used with a falsy value to go back to the default behavior.
 * @param {?=} enabled
 * @return {!ArraySchema}
 */
tsickle_declare_module.joi.ArraySchema.prototype.sparse = function(enabled) {};

/**
 * Allow single values to be checked against rules as if it were provided as an array.
 * enabled can be used with a falsy value to go back to the default behavior.
 * @param {?=} enabled
 * @return {!ArraySchema}
 */
tsickle_declare_module.joi.ArraySchema.prototype.single = function(enabled) {};

/**
 * List the types allowed for the array values.
 * type can be an array of values, or multiple values can be passed as individual arguments.
 * If a given type is .required() then there must be a matching item in the array.
 * If a type is .forbidden() then it cannot appear in the array.
 * Required items can be added multiple times to signify that multiple items must be found.
 * Errors will contain the number of items that didn't match.
 * Any unmatched item having a label will be mentioned explicitly.
 * 
 * @param {!Schema|!Array<!Schema>} type_or_types - a joi schema object to validate each array item against.
 * @param {...!Schema} types
 * @return {!ArraySchema}
 */
tsickle_declare_module.joi.ArraySchema.prototype.items = function(type_or_types, types) {};

/**
 * Specifies the minimum number of items in the array.
 * @param {number} limit
 * @return {!ArraySchema}
 */
tsickle_declare_module.joi.ArraySchema.prototype.min = function(limit) {};

/**
 * Specifies the maximum number of items in the array.
 * @param {number} limit
 * @return {!ArraySchema}
 */
tsickle_declare_module.joi.ArraySchema.prototype.max = function(limit) {};

/**
 * Specifies the exact number of items in the array.
 * @param {number} limit
 * @return {!ArraySchema}
 */
tsickle_declare_module.joi.ArraySchema.prototype.length = function(limit) {};

/**
 * Requires the array values to be unique.
 * Be aware that a deep equality is performed on elements of the array having a type of object,
 * a performance penalty is to be expected for this kind of operation.
 * @return {!ArraySchema}
 */
tsickle_declare_module.joi.ArraySchema.prototype.unique = function() {};
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.ObjectSchema = function() {};

/**
 * Sets the allowed object keys.
 * @param {!SchemaMap=} schema
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.keys = function(schema) {};

/**
 * Specifies the minimum number of keys in the object.
 * @param {number} limit
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.min = function(limit) {};

/**
 * Specifies the maximum number of keys in the object.
 * @param {number} limit
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.max = function(limit) {};

/**
 * Specifies the exact number of keys in the object.
 * @param {number} limit
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.length = function(limit) {};

/**
 * Specify validation rules for unknown keys matching a pattern.
 * @param {!RegExp} regex
 * @param {!Schema} schema
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.pattern = function(regex, schema) {};

/**
 * Defines an all-or-nothing relationship between keys where if one of the peers is present, all of them are required as well.
 * @param {string|!Array<string>} peer1_or_peers
 * @param {...string} peers - the key names of which if one present, all are required. peers can be a single string value,
 * an array of string values, or each peer provided as an argument.
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.and = function(peer1_or_peers, peers) {};

/**
 * Defines a relationship between keys where not all peers can be present at the same time.
 * @param {string|!Array<string>} peer1_or_peers
 * @param {...string} peers - the key names of which if one present, the others may not all be present.
 * peers can be a single string value, an array of string values, or each peer provided as an argument.
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.nand = function(peer1_or_peers, peers) {};

/**
 * Defines a relationship between keys where one of the peers is required (and more than one is allowed).
 * @param {string|!Array<string>} peer1_or_peers
 * @param {...string} peers
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.or = function(peer1_or_peers, peers) {};

/**
 * Defines an exclusive relationship between a set of keys. one of them is required but not at the same time where:
 * @param {string|!Array<string>} peer1_or_peers
 * @param {...string} peers
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.xor = function(peer1_or_peers, peers) {};

/**
 * Requires the presence of other keys whenever the specified key is present.
 * @param {string} key
 * @param {string|!Array<string>} peers
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.with = function(key, peers) {};

/**
 * Forbids the presence of other keys whenever the specified is present.
 * @param {string} key
 * @param {string|!Array<string>} peers
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.without = function(key, peers) {};

/**
 * Renames a key to another name (deletes the renamed key).
 * @param {string} from
 * @param {string} to
 * @param {!RenameOptions=} options
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.rename = function(from, to, options) {};

/**
 * Verifies an assertion where.
 * @param {string|!Reference} ref
 * @param {!Schema} schema
 * @param {string=} message
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.assert = function(ref, schema, message) {};

/**
 * Overrides the handling of unknown keys for the scope of the current object only (does not apply to children).
 * @param {boolean=} allow
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.unknown = function(allow) {};

/**
 * Requires the object to be an instance of a given constructor.
 * 
 * @param {!Function} constructor - the constructor function that the object must be an instance of.
 * @param {string=} name - an alternate name to use in validation errors. This is useful when the constructor function does not have a name.
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.type = function(constructor, name) {};

/**
 * Sets the specified children to required.
 * 
 * @param {string|!Array<string>} children_or_child - can be a single string value, an array of string values, or each child provided as an argument.
 * 
 *   var schema = Joi.object().keys({ a: { b: Joi.number() }, c: { d: Joi.string() } });
 *   var requiredSchema = schema.requiredKeys('', 'a.b', 'c', 'c.d');
 * 
 * Note that in this example '' means the current object, a is not required but b is, as well as c and d.
 * @param {...string} children
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.requiredKeys = function(children_or_child, children) {};

/**
 * Sets the specified children to optional.
 * 
 * @param {string|!Array<string>} children_or_child - can be a single string value, an array of string values, or each child provided as an argument.
 * 
 * The behavior is exactly the same as requiredKeys.
 * @param {...string} children
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.ObjectSchema.prototype.optionalKeys = function(children_or_child, children) {};
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.BinarySchema = function() {};

/**
 * Sets the string encoding format if a string input is converted to a buffer.
 * @param {string} encoding
 * @return {!BinarySchema}
 */
tsickle_declare_module.joi.BinarySchema.prototype.encoding = function(encoding) {};

/**
 * Specifies the minimum length of the buffer.
 * @param {number} limit
 * @return {!BinarySchema}
 */
tsickle_declare_module.joi.BinarySchema.prototype.min = function(limit) {};

/**
 * Specifies the maximum length of the buffer.
 * @param {number} limit
 * @return {!BinarySchema}
 */
tsickle_declare_module.joi.BinarySchema.prototype.max = function(limit) {};

/**
 * Specifies the exact length of the buffer:
 * @param {number} limit
 * @return {!BinarySchema}
 */
tsickle_declare_module.joi.BinarySchema.prototype.length = function(limit) {};
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.DateSchema = function() {};

/**
 * Specifies the oldest date allowed.
 * Notes: 'now' can be passed in lieu of date so as to always compare relatively to the current date,
 * allowing to explicitly ensure a date is either in the past or in the future.
 * It can also be a reference to another field.
 * @param {!Date|number|string|!Reference} date
 * @return {!DateSchema}
 */
tsickle_declare_module.joi.DateSchema.prototype.min = function(date) {};

/**
 * Specifies the latest date allowed.
 * Notes: 'now' can be passed in lieu of date so as to always compare relatively to the current date,
 * allowing to explicitly ensure a date is either in the past or in the future.
 * It can also be a reference to another field.
 * @param {!Date|number|string|!Reference} date
 * @return {!DateSchema}
 */
tsickle_declare_module.joi.DateSchema.prototype.max = function(date) {};

/**
 * Specifies the allowed date format:
 * @param {string|!Array<string>} format - string or array of strings that follow the moment.js format.
 * @return {!DateSchema}
 */
tsickle_declare_module.joi.DateSchema.prototype.format = function(format) {};

/**
 * Requires the string value to be in valid ISO 8601 date format.
 * @return {!DateSchema}
 */
tsickle_declare_module.joi.DateSchema.prototype.iso = function() {};
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.FunctionSchema = function() {};
/**
 * @extends {AnySchema}
 * @record
 * @struct
 */
tsickle_declare_module.joi.AlternativesSchema = function() {};

/**
 * @param {!Array<!Schema>} schemas
 * @return {!AlternativesSchema}
 */
tsickle_declare_module.joi.AlternativesSchema.prototype.try = function(schemas) {};

/**
 * @template T
 * @param {string|!Reference} ref
 * @param {!WhenOptions<T>} options
 * @return {!AlternativesSchema}
 */
tsickle_declare_module.joi.AlternativesSchema.prototype.when = function(ref, options) {};

/**
 * Generates a schema object that matches any data type.
 * @return {!Schema}
 */
tsickle_declare_module.joi.any = function() {};

/**
 * Generates a schema object that matches an array data type.
 * @return {!ArraySchema}
 */
tsickle_declare_module.joi.array = function() {};

/**
 * Generates a schema object that matches a boolean data type (as well as the strings 'true', 'false', 'yes', and 'no'). Can also be called via bool().
 * @return {!BooleanSchema}
 */
tsickle_declare_module.joi.bool = function() {};

/**
 * @return {!BooleanSchema}
 */
tsickle_declare_module.joi.boolean = function() {};

/**
 * Generates a schema object that matches a Buffer data type (as well as the strings which will be converted to Buffers).
 * @return {!BinarySchema}
 */
tsickle_declare_module.joi.binary = function() {};

/**
 * Generates a schema object that matches a date type (as well as a JavaScript date string or number of milliseconds).
 * @return {!DateSchema}
 */
tsickle_declare_module.joi.date = function() {};

/**
 * Generates a schema object that matches a function type.
 * @return {!FunctionSchema}
 */
tsickle_declare_module.joi.func = function() {};

/**
 * Generates a schema object that matches a number data type (as well as strings that can be converted to numbers).
 * @return {!NumberSchema}
 */
tsickle_declare_module.joi.number = function() {};

/**
 * Generates a schema object that matches an object data type (as well as JSON strings that parsed into objects).
 * @param {!SchemaMap=} schema
 * @return {!ObjectSchema}
 */
tsickle_declare_module.joi.object = function(schema) {};

/**
 * Generates a schema object that matches a string data type. Note that empty strings are not allowed by default and must be enabled with allow('').
 * @return {!StringSchema}
 */
tsickle_declare_module.joi.string = function() {};

/**
 * Generates a type that will match one of the provided alternative schemas
 * @param {!Array<!Schema>|!Schema} types_or_type1
 * @param {!Schema=} type2
 * @param {...!Schema} types
 * @return {!Schema}
 */
tsickle_declare_module.joi.alternatives = function(types_or_type1, type2, types) {};

/**
 * Validates a value using the given schema and options.
 * @template T
 * @param {T} value
 * @param {!Schema|!Object} schema
 * @param {function(!ValidationError, T): void|!ValidationOptions=} callback_or_options
 * @param {function(!ValidationError, T): void=} callback
 * @return {void|!ValidationResult<T>}
 */
tsickle_declare_module.joi.validate = function(value, schema, callback_or_options, callback) {};

/**
 * Converts literal schema definition to joi schema object (or returns the same back if already a joi schema object).
 * @param {!Object} schema
 * @return {!Schema}
 */
tsickle_declare_module.joi.compile = function(schema) {};

/**
 * Validates a value against a schema and throws if validation fails.
 * 
 * @param {?} value - the value to validate.
 * @param {!Schema} schema - the schema object.
 * @param {(string|!Error)=} message - optional message string prefix added in front of the error message. may also be an Error object.
 * @return {void}
 */
tsickle_declare_module.joi.assert = function(value, schema, message) {};

/**
 * Generates a reference to the value of the named key.
 * @param {string} key
 * @param {!ReferenceOptions=} options
 * @return {!Reference}
 */
tsickle_declare_module.joi.ref = function(key, options) {};
