/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/paper/index.d.ts:

/** @typedef {!MouseEvent} */
var NativeMouseEvent;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "paper"
/** @const */
tsickle_declare_module.paper = {};
 /** @type {string} */
tsickle_declare_module.paper.version;
 /** @type {{applyMatrix: boolean, handleSize: number, hitTolerance: number}} */
tsickle_declare_module.paper.settings;
 /** @type {!Project} */
tsickle_declare_module.paper.project;
 /** @type {!Array<!Project>} */
tsickle_declare_module.paper.projects;
 /** @type {!View} */
tsickle_declare_module.paper.view;
 /** @type {!Tool} */
tsickle_declare_module.paper.tool;
 /** @type {!Array<!Tool>} */
tsickle_declare_module.paper.tools;

/**
 * Injects the paper scope into any other given scope. Can be used for examle to inject the currently active PaperScope into the window's global scope, to emulate PaperScript-style globally accessible Paper classes and objects
 * Please note: Using this method may override native constructors (e.g. Path, RGBColor). This may cause problems when using Paper.js in conjunction with other libraries that rely on these constructors. Keep the library scoped if you encounter issues caused by this.
 * @param {?} scope -
 * @return {void}
 */
tsickle_declare_module.paper.install = function(scope) {};

/**
 * Sets up an empty project for us. If a canvas is provided, it also creates a View for it, both linked to this scope.
 * @param {(string|!HTMLCanvasElement)} canvas
 * @return {void}
 */
tsickle_declare_module.paper.setup = function(canvas) {};

/**
 * Activates this PaperScope, so all newly created items will be placed in its active project.
 * @return {void}
 */
tsickle_declare_module.paper.activate = function() {};

/**
 * @constructor
 * @struct
 * Creates a 2D affine transform.
 * @param {number} a - the a property of the transform
 * @param {number} c - the c property of the transform
 * @param {number} b - the b property of the transform
 * @param {number} d - the d property of the transform
 * @param {number} tx - the tx property of the transform
 * @param {number} ty - the ty property of the transform
 */
tsickle_declare_module.paper.Matrix = function(a, c, b, d, tx, ty) {};
 /** @type {number} */
tsickle_declare_module.paper.Matrix.prototype.a;
 /** @type {number} */
tsickle_declare_module.paper.Matrix.prototype.c;
 /** @type {number} */
tsickle_declare_module.paper.Matrix.prototype.b;
 /** @type {number} */
tsickle_declare_module.paper.Matrix.prototype.d;
 /** @type {number} */
tsickle_declare_module.paper.Matrix.prototype.tx;
 /** @type {number} */
tsickle_declare_module.paper.Matrix.prototype.ty;
 /** @type {number} */
tsickle_declare_module.paper.Matrix.prototype.values;
 /** @type {!Point} */
tsickle_declare_module.paper.Matrix.prototype.translation;
 /** @type {!Point} */
tsickle_declare_module.paper.Matrix.prototype.scaling;
 /** @type {number} */
tsickle_declare_module.paper.Matrix.prototype.rotation;

/**
 * Sets this transform to the matrix specified by the 6 values.
 * @param {number} a - the a property of the transform
 * @param {number} c - the c property of the transform
 * @param {number} b - the b property of the transform
 * @param {number} d - the d property of the transform
 * @param {number} tx - the tx property of the transform
 * @param {number} ty - the ty property of the transform
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.set = function(a, c, b, d, tx, ty) {};

/**
 * Returns a copy of this transform
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.clone = function() {};

/**
 * Checks whether the two matrices describe the same transformation.
 * @param {!Matrix} matrix - the matrix to compare this matrix to
 * @return {boolean}
 */
tsickle_declare_module.paper.Matrix.prototype.equals = function(matrix) {};

/**
 * returns a string representation of this transform
 * @return {string}
 */
tsickle_declare_module.paper.Matrix.prototype.toString = function() {};

/**
 * Resets the matrix by setting its values to the ones of the identity matrix that results in no transformation.
 * @return {void}
 */
tsickle_declare_module.paper.Matrix.prototype.reset = function() {};

/**
 * Attempts to apply the matrix to the content of item that it belongs to, meaning its transformation is baked into the item's content or children.
 * @return {boolean}
 */
tsickle_declare_module.paper.Matrix.prototype.apply = function() {};

/**
 * Concatenates this transform with a translate transformation.
 * Concatenates this transform with a translate transformation.
 * @param {!Point|number} point_or_dx - the vector to translate by / - the distance to translate in the x direction
 * @param {number=} dy - the distance to translate in the y direction
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.translate = function(point_or_dx, dy) {};

/**
 * Concatenates this transform with a scaling transformation.
 * Concatenates this transform with a scaling transformation.
 * @param {number} scale_or_hor - the scaling factor / - the horizontal scaling factor
 * @param {!Point|number=} center_or_ver [optional] - the center for the scaling transformation / - the vertical scaling factor
 * @param {!Point=} center [optional] - the center for the scaling transformation
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.scale = function(scale_or_hor, center_or_ver, center) {};

/**
 * Concatenates this transform with a rotation transformation around an anchor point.
 * Concatenates this transform with a rotation transformation around an anchor point.
 * @param {number} angle - the angle of rotation measured in degrees
 * @param {!Point|number} center_or_x - the anchor point to rotate around / - the x coordinate of the anchor point
 * @param {number=} y - the y coordinate of the anchor point
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.rotate = function(angle, center_or_x, y) {};

/**
 * Concatenates this transform with a shear transformation.
 * Concatenates this transform with a shear transformation.
 * @param {!Point|number} shear_or_hor - the shear factor in x and y direction / - the horizontal shear factor
 * @param {!Point|number=} center_or_ver [optional] - the center for the shear transformation / - the vertical shear factor
 * @param {!Point=} center [optional] - the center for the shear transformation
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.shear = function(shear_or_hor, center_or_ver, center) {};

/**
 * Concatenates this transform with a skew transformation.
 * Concatenates this transform with a skew transformation.
 * @param {!Point|number} skew_or_hor - the skew angles in x and y direction in degrees / - the horizontal skew angle in degrees
 * @param {!Point|number=} center_or_ver [optional] - the center for the skew transformation / - the vertical skew angle in degrees
 * @param {!Point=} center [optional] - the center for the skew transformation
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.skew = function(skew_or_hor, center_or_ver, center) {};

/**
 * Concatenates the given affine transform to this transform.
 * @param {!Matrix} mx - the transform to concatenate
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.concatenate = function(mx) {};

/**
 * Pre-concatenates the given affine transform to this transform.
 * @param {!Matrix} mx - the transform to preconcatenate
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.preConcatenate = function(mx) {};

/**
 * Returns a new instance of the result of the concatenation of the given affine transform with this transform.
 * @param {!Matrix} mx - the transform to concatenate
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.chain = function(mx) {};

/**
 * Returns whether this transform is the identity transform
 * @return {boolean}
 */
tsickle_declare_module.paper.Matrix.prototype.isIdentity = function() {};

/**
 * Returns whether the transform is invertible. A transform is not invertible if the determinant is 0 or any value is non-finite or NaN.
 * @return {boolean}
 */
tsickle_declare_module.paper.Matrix.prototype.isInvertible = function() {};

/**
 * Checks whether the matrix is singular or not. Singular matrices cannot be inverted.
 * @return {boolean}
 */
tsickle_declare_module.paper.Matrix.prototype.isSingular = function() {};

/**
 * Transforms a point and returns the result.
 * Transforms an array of coordinates by this matrix and stores the results into the destination array, which is also returned.
 * @param {!Point|!Array<number>} point_or_src - the point to be transformed / - the array containing the source points as x, y value pairs
 * @param {!Array<number>=} dst - the array into which to store the transformed point pairs
 * @param {number=} count - the number of points to transform
 * @return {!Matrix|!Array<number>}
 */
tsickle_declare_module.paper.Matrix.prototype.transform = function(point_or_src, dst, count) {};

/**
 * Inverse transforms a point and returns the result.
 * @param {!Point} point - the point to be transformed
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.inverseTransform = function(point) {};

/**
 * Attempts to decompose the affine transformation described by this matrix into scaling, rotation and shearing, and returns an object with these properties if it succeeded, null otherwise.
 * @return {?}
 */
tsickle_declare_module.paper.Matrix.prototype.decompose = function() {};

/**
 * Creates the inversion of the transformation of the matrix and returns it as a new insteance. If the matrix is not invertible (in which case isSingular() returns true), null is returned.
 * @return {!Matrix}
 */
tsickle_declare_module.paper.Matrix.prototype.inverted = function() {};

/**
 * Applies this matrix to the specified Canvas Context.
 * @param {!CanvasRenderingContext2D} ctx -
 * @return {void}
 */
tsickle_declare_module.paper.Matrix.prototype.applyToContext = function(ctx) {};

/**
 * @constructor
 * @struct
 * Creates a Point object with the given x and y coordinates.
 * Creates a Point object using the numbers in the given array as coordinates.
 * Creates a Point object using the properties in the given object.
 * Creates a Point object using the width and height values of the given Size object.
 * Creates a Point object using the coordinates of the given Point object.
 * @param {number|!Array<number>|?|!Size|!Point} x_or_values_or_object_or_size_or_point - the x coordinate / - the object describing the point's properties / - the size width and height to use / - the point to copy
 * @param {number=} y - the y coordinate
 */
tsickle_declare_module.paper.Point = function(x_or_values_or_object_or_size_or_point, y) {};
 /** @type {number} */
tsickle_declare_module.paper.Point.prototype.x;
 /** @type {number} */
tsickle_declare_module.paper.Point.prototype.y;
 /** @type {number} */
tsickle_declare_module.paper.Point.prototype.length;
 /** @type {number} */
tsickle_declare_module.paper.Point.prototype.angle;
 /** @type {number} */
tsickle_declare_module.paper.Point.prototype.angleInRadians;
 /** @type {number} */
tsickle_declare_module.paper.Point.prototype.quadrant;
 /** @type {boolean} */
tsickle_declare_module.paper.Point.prototype.selected;

/**
 * Returns a new point object with the smallest x and y of the supplied points.
 * @param {!Point} point1 -
 * @param {!Point} point2 -
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.min = function(point1, point2) {};

/**
 * Returns a new point object with the largest x and y of the supplied points.
 * @param {!Point} point1 -
 * @param {!Point} point2 -
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.max = function(point1, point2) {};

/**
 * Returns a point object with random x and y values between 0 and 1.
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.random = function() {};

/**
 * Checks whether the coordinates of the point are equal to that of the supplied point.
 * @param {!Point} point - the point to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Point.prototype.equals = function(point) {};

/**
 * Returns a copy of the point.
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.clone = function() {};

/**
 * a string representation of the point
 * @return {string}
 */
tsickle_declare_module.paper.Point.prototype.toString = function() {};

/**
 * Returns the smaller angle between two vectors. The angle is unsigned, no information about rotational direction is given.
 * @param {!Point} Point
 * @return {number}
 */
tsickle_declare_module.paper.Point.prototype.getAngle = function(Point) {};

/**
 * Returns the smaller angle between two vectors in radians. The angle is unsigned, no information about rotational direction is given.
 * @param {!Point} point
 * @return {number}
 */
tsickle_declare_module.paper.Point.prototype.getAngleInRadians = function(point) {};

/**
 * Returns the angle between two vectors. The angle is directional and signed, giving information about the rotational direction.
 * Read more about angle units and orientation in the description of the angle property.
 * @param {!Point} point -
 * @return {number}
 */
tsickle_declare_module.paper.Point.prototype.getDirectedAngle = function(point) {};

/**
 * Returns the distance between the point and another point.
 * @param {!Point} point -
 * @param {boolean=} squared [optional] - Controls whether the distance should remain squared, or its square root should be calculated. default: false
 * @return {number}
 */
tsickle_declare_module.paper.Point.prototype.getDistance = function(point, squared) {};

/**
 * Normalize modifies the length of the vector to 1 without changing its angle and returns it as a new point. The optional length parameter defines the length to normalize to.
 * The object itself is not modified!
 * @param {number=} length [optional] - The length of the normalized vector, default: 1
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.normalize = function(length) {};

/**
 * Rotates the point by the given angle around an optional center point.
 * The object itself is not modified.
 * Read more about angle units and orientation in the description of the angle property.
 * @param {number} angle - the rotation angle
 * @param {!Point=} center - the center point of the rotation
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.rotate = function(angle, center) {};

/**
 * Transforms the point by the matrix as a new point. The object itself is not modified!
 * @param {!Matrix} matrix -
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.transform = function(matrix) {};

/**
 * Checks whether the point is inside the boundaries of the rectangle.
 * @param {!Rectangle} rect - the rectangle to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Point.prototype.isInside = function(rect) {};

/**
 * Checks if the point is within a given distance of another point.
 * @param {!Point} point - the point to check against
 * @param {number} tolerance - the maximum distance allowed
 * @return {boolean}
 */
tsickle_declare_module.paper.Point.prototype.isClose = function(point, tolerance) {};

/**
 * Checks if the vector represented by this point is colinear (parallel) to another vector.
 * @param {!Point} point - the vector to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Point.prototype.isColinear = function(point) {};

/**
 * Checks if the vector represented by this point is orthogonal (perpendicular) to another vector.
 * @param {!Point} point - the vector to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Point.prototype.isOrthogonal = function(point) {};

/**
 * Checks if this point has both the x and y coordinate set to 0.
 * @return {boolean}
 */
tsickle_declare_module.paper.Point.prototype.isZero = function() {};

/**
 * Checks if this point has an undefined value for at least one of its coordinates.
 * @return {boolean}
 */
tsickle_declare_module.paper.Point.prototype.isNan = function() {};

/**
 * Returns the dot product of the point and another point.
 * @param {!Point} point -
 * @return {number}
 */
tsickle_declare_module.paper.Point.prototype.dot = function(point) {};

/**
 * Returns the cross product of the point and another point.
 * @param {!Point} point -
 * @return {number}
 */
tsickle_declare_module.paper.Point.prototype.cross = function(point) {};

/**
 * Returns the projection of the point on another point.
 * Both points are interpreted as vectors.
 * @param {!Point} point -
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.project = function(point) {};

/**
 * Returns a new point with rounded x and y values. The object itself is not modified!
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.round = function() {};

/**
 * Returns a new point with the nearest greater non-fractional values to the specified x and y values. The object itself is not modified!
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.ceil = function() {};

/**
 * Returns a new point with the nearest smaller non-fractional values to the specified x and y values. The object itself is not modified!
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.floor = function() {};

/**
 * Returns a new point with the absolute values of the specified x and y values. The object itself is not modified!
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.abs = function() {};

/**
 * @param {!Point|!Array<number>} point
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.add = function(point) {};

/**
 * @param {!Point|!Array<number>} point
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.subtract = function(point) {};

/**
 * @param {!Point|!Array<number>|number} point
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.multiply = function(point) {};

/**
 * @param {!Point|!Array<number>|number} point
 * @return {!Point}
 */
tsickle_declare_module.paper.Point.prototype.divide = function(point) {};

/**
 * @constructor
 * @struct
 * Creates a Rectangle object.
 * Creates a rectangle object.
 * Creates a Rectangle object.
 * Creates a rectangle object from the passed points. These do not necessarily need to be the top left and bottom right corners, the constructor figures out how to fit a rectangle between them.
 * Creates a new rectangle object from the passed rectangle object.
 * @param {!Point|number|?|!Rectangle} point_or_x_or_object_or_from_or_rt - the top-left point of the rectangle / - the left coordinate / - an object containing properties to be set on the rectangle. / - The first point defining the rectangle / - the rectangle to copy from
 * @param {!Size|number|!Point=} size_or_y_or_to - the size of the rectangle / - the top coordinate / - The second point defining the rectangle
 * @param {number=} width - the width
 * @param {number=} height - the height
 */
tsickle_declare_module.paper.Rectangle = function(point_or_x_or_object_or_from_or_rt, size_or_y_or_to, width, height) {};
 /** @type {number} */
tsickle_declare_module.paper.Rectangle.prototype.x;
 /** @type {number} */
tsickle_declare_module.paper.Rectangle.prototype.y;
 /** @type {number} */
tsickle_declare_module.paper.Rectangle.prototype.width;
 /** @type {number} */
tsickle_declare_module.paper.Rectangle.prototype.height;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.point;
 /** @type {!Size} */
tsickle_declare_module.paper.Rectangle.prototype.size;
 /** @type {number} */
tsickle_declare_module.paper.Rectangle.prototype.left;
 /** @type {number} */
tsickle_declare_module.paper.Rectangle.prototype.top;
 /** @type {number} */
tsickle_declare_module.paper.Rectangle.prototype.right;
 /** @type {number} */
tsickle_declare_module.paper.Rectangle.prototype.bottom;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.center;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.topLeft;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.topRight;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.bottomLeft;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.bottomRight;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.leftCenter;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.topCenter;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.rightCenter;
 /** @type {!Point} */
tsickle_declare_module.paper.Rectangle.prototype.bottomCenter;
 /** @type {number} */
tsickle_declare_module.paper.Rectangle.prototype.area;
 /** @type {boolean} */
tsickle_declare_module.paper.Rectangle.prototype.selected;

/**
 * Returns a copy of the rectangle.
 * @return {!Rectangle}
 */
tsickle_declare_module.paper.Rectangle.prototype.clone = function() {};

/**
 * Checks whether the coordinates and size of the rectangle are equal to that of the supplied rectangle.
 * @param {!Rectangle} rect - the rectangle to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Rectangle.prototype.equals = function(rect) {};

/**
 * a string representation of this rectangle
 * @return {string}
 */
tsickle_declare_module.paper.Rectangle.prototype.toString = function() {};

/**
 * Returns true if the rectangle is empty, false otherwise
 * @return {boolean}
 */
tsickle_declare_module.paper.Rectangle.prototype.isEmpty = function() {};

/**
 * Tests if the specified point is inside the boundary of the rectangle.
 * Tests if the interior of the rectangle entirely contains the specified rectangle.
 * @param {!Point|!Rectangle} point_or_rect - the specified point / - The specified rectangle
 * @return {boolean}
 */
tsickle_declare_module.paper.Rectangle.prototype.contains = function(point_or_rect) {};

/**
 * Tests if the interior of this rectangle intersects the interior of another rectangle. Rectangles just touching each other are considered as non-intersecting.
 * @param {!Rectangle} rect - the specified rectangle
 * @return {boolean}
 */
tsickle_declare_module.paper.Rectangle.prototype.intersects = function(rect) {};

/**
 * Returns a new rectangle representing the intersection of this rectangle with the specified rectangle.
 * @param {!Rectangle} rect - The rectangle to be intersected with this rectangle
 * @return {!Rectangle}
 */
tsickle_declare_module.paper.Rectangle.prototype.intersect = function(rect) {};

/**
 * Returns a new rectangle representing the union of this rectangle with the specified rectangle.
 * @param {!Rectangle} rect - the rectangle to be combined with this rectangle
 * @return {!Rectangle}
 */
tsickle_declare_module.paper.Rectangle.prototype.unite = function(rect) {};

/**
 * Adds a point to this rectangle. The resulting rectangle is the smallest rectangle that contains both the original rectangle and the specified point.
 * After adding a point, a call to contains(point) with the added point as an argument does not necessarily return true.
 * The rectangle.contains(point) method does not return true for points on the right or bottom edges of a rectangle. Therefore, if the added point falls on the left or bottom edge of the enlarged rectangle, rectangle.contains(point) returns false for that point.
 * @param {!Point} point - the point to add to the rectangle
 * @return {!Rectangle}
 */
tsickle_declare_module.paper.Rectangle.prototype.include = function(point) {};

/**
 * Expands the rectangle by the specified amount in horizontal and vertical directions.
 * Expands the rectangle by the specified amounts in horizontal and vertical directions.
 * @param {(number|!Point|!Size)|number} amount_or_hor - the amount to expand the rectangle in both directions / - the amount to expand the rectangle in horizontal direction
 * @param {number=} ver - the amount to expand the rectangle in vertical direction
 * @return {!Rectangle}
 */
tsickle_declare_module.paper.Rectangle.prototype.expand = function(amount_or_hor, ver) {};

/**
 * Scales the rectangle by the specified amount from its center.
 * Scales the rectangle in horizontal direction by the specified hor amount and in vertical direction by the specified ver amount from its center.
 * @param {number} amount_or_hor - the amount to scale by / - the amount to scale the rectangle in horizontal direction
 * @param {number=} ver - the amount to scale the rectangle in vertical direction
 * @return {!Rectangle}
 */
tsickle_declare_module.paper.Rectangle.prototype.scale = function(amount_or_hor, ver) {};

/**
 * @constructor
 * @struct
 * Creates a Size object with the given width and height values.
 * Creates a Size object using the numbers in the given array as dimensions.
 * Creates a Size object using the properties in the given object.
 * Creates a Size object using the coordinates of the given Size object.
 * Creates a Size object using the point.x and point.y values of the given Point object.
 * @param {number|!Array<number>|?|!Size|!Point} width_or_array_or_object_or_size_or_point - the width / - an array of numbers / - the object literal containing properies (width:10, height:10 etc) / - the size to duplicate from / - the point from which to create a size
 * @param {number=} height - the height
 */
tsickle_declare_module.paper.Size = function(width_or_array_or_object_or_size_or_point, height) {};
 /** @type {number} */
tsickle_declare_module.paper.Size.prototype.width;
 /** @type {number} */
tsickle_declare_module.paper.Size.prototype.height;

/**
 * Returns a new size object with the smallest width and height of the supplied sizes.
 * @param {!Size} size1 - the first size
 * @param {!Size} size2 - the second size
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.min = function(size1, size2) {};

/**
 * Returns a new size object with the largest width and height of the supplied sizes.
 * @param {!Size} size1 - the first size
 * @param {!Size} size2 - the second size
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.max = function(size1, size2) {};

/**
 * Returns a size object with random width and height values between 0 and 1.
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.random = function() {};

/**
 * WARNING - This seems undocumented/incorrect
 * @return {boolean}
 */
tsickle_declare_module.paper.Size.prototype.equals = function() {};

/**
 * Returns a copy of the size.
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.prototype.clone = function() {};

/**
 * a string representation of the size
 * @return {string}
 */
tsickle_declare_module.paper.Size.prototype.toString = function() {};

/**
 * Checks if this size has both the width and height set to 0.
 * @return {boolean}
 */
tsickle_declare_module.paper.Size.prototype.isZero = function() {};

/**
 * Checks if the width or the height of the size are NaN.
 * @return {boolean}
 */
tsickle_declare_module.paper.Size.prototype.isNan = function() {};

/**
 * Returns a new size with rounded width and height values. The object itself is not modified!
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.prototype.round = function() {};

/**
 * Returns a new size with the nearest greater non-fractional values to the specified width and height values. The object itself is not modified!
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.prototype.ceil = function() {};

/**
 * Returns a new size with the nearest smaller non-fractional values to the specified width and height values. The object itself is not modified!
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.prototype.floor = function() {};

/**
 * Returns a new size with the absolute values of the specified width and height values. The object itself is not modified!
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.prototype.abs = function() {};

/**
 * @param {!Size|!Array<number>|number} point
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.prototype.multiply = function(point) {};

/**
 * @param {!Size|!Array<number>|number} point
 * @return {!Size}
 */
tsickle_declare_module.paper.Size.prototype.divide = function(point) {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.paper.IFrameEvent = function() {};
 /** @type {number} */
tsickle_declare_module.paper.IFrameEvent.prototype.count;
 /** @type {number} */
tsickle_declare_module.paper.IFrameEvent.prototype.time;
 /** @type {number} */
tsickle_declare_module.paper.IFrameEvent.prototype.delta;
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.PaperScope = function() {};
 /** @type {string} */
tsickle_declare_module.paper.PaperScope.prototype.version;
 /** @type {{applyMatrix: boolean, handleSize: number, hitTolerance: number}} */
tsickle_declare_module.paper.PaperScope.prototype.settings;
 /** @type {!Project} */
tsickle_declare_module.paper.PaperScope.prototype.project;
 /** @type {!Array<!Project>} */
tsickle_declare_module.paper.PaperScope.prototype.projects;
 /** @type {!View} */
tsickle_declare_module.paper.PaperScope.prototype.view;
 /** @type {!Tool} */
tsickle_declare_module.paper.PaperScope.prototype.tool;
 /** @type {!Array<!Tool>} */
tsickle_declare_module.paper.PaperScope.prototype.tools;

/**
 * Injects the paper scope into any other given scope. Can be used for examle to inject the currently active PaperScope into the window's global scope, to emulate PaperScript-style globally accessible Paper classes and objects
 * Please note: Using this method may override native constructors (e.g. Path, RGBColor). This may cause problems when using Paper.js in conjunction with other libraries that rely on these constructors. Keep the library scoped if you encounter issues caused by this.
 * @param {?} scope -
 * @return {void}
 */
tsickle_declare_module.paper.PaperScope.prototype.install = function(scope) {};

/**
 * Sets up an empty project for us. If a canvas is provided, it also creates a View for it, both linked to this scope.
 * @param {(string|!HTMLCanvasElement)} canvas
 * @return {void}
 */
tsickle_declare_module.paper.PaperScope.prototype.setup = function(canvas) {};

/**
 * Activates this PaperScope, so all newly created items will be placed in its active project.
 * @return {void}
 */
tsickle_declare_module.paper.PaperScope.prototype.activate = function() {};

/**
 * Retrieves a PaperScope object with the given scope id.
 * @param {string} id -
 * @return {!PaperScope}
 */
tsickle_declare_module.paper.PaperScope.get = function(id) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.Item = function() {};
 /** @type {!Point} */
tsickle_declare_module.paper.Item.prototype.tangent;
 /** @type {!Point} */
tsickle_declare_module.paper.Item.prototype.normal;
 /** @type {number} */
tsickle_declare_module.paper.Item.prototype.curvature;
 /** @type {number} */
tsickle_declare_module.paper.Item.prototype.id;
 /** @type {string} */
tsickle_declare_module.paper.Item.prototype.className;
 /** @type {string} */
tsickle_declare_module.paper.Item.prototype.name;
 /** @type {!Style} */
tsickle_declare_module.paper.Item.prototype.style;
 /** @type {boolean} */
tsickle_declare_module.paper.Item.prototype.visible;
 /** @type {string} */
tsickle_declare_module.paper.Item.prototype.blendMode;
 /** @type {number} */
tsickle_declare_module.paper.Item.prototype.opacity;
 /** @type {boolean} */
tsickle_declare_module.paper.Item.prototype.selected;
 /** @type {boolean} */
tsickle_declare_module.paper.Item.prototype.clipMask;
 /** @type {?} */
tsickle_declare_module.paper.Item.prototype.data;
 /** @type {!Point} */
tsickle_declare_module.paper.Item.prototype.position;
 /** @type {!Point} */
tsickle_declare_module.paper.Item.prototype.pivot;
 /** @type {!Rectangle} */
tsickle_declare_module.paper.Item.prototype.bounds;
 /** @type {!Rectangle} */
tsickle_declare_module.paper.Item.prototype.strokeBounds;
 /** @type {!Rectangle} */
tsickle_declare_module.paper.Item.prototype.handleBounds;
 /** @type {number} */
tsickle_declare_module.paper.Item.prototype.rotation;
 /** @type {!Point} */
tsickle_declare_module.paper.Item.prototype.scaling;
 /** @type {!Matrix} */
tsickle_declare_module.paper.Item.prototype.matrix;
 /** @type {!Matrix} */
tsickle_declare_module.paper.Item.prototype.globalMatrix;
 /** @type {boolean} */
tsickle_declare_module.paper.Item.prototype.applyMatrix;
 /** @type {!Project} */
tsickle_declare_module.paper.Item.prototype.project;
 /** @type {!View} */
tsickle_declare_module.paper.Item.prototype.view;
 /** @type {!Layer} */
tsickle_declare_module.paper.Item.prototype.layer;
 /** @type {!Item} */
tsickle_declare_module.paper.Item.prototype.parent;
 /** @type {!Array<!Item>} */
tsickle_declare_module.paper.Item.prototype.children;
 /** @type {!Item} */
tsickle_declare_module.paper.Item.prototype.firstChild;
 /** @type {!Item} */
tsickle_declare_module.paper.Item.prototype.lastChild;
 /** @type {!Item} */
tsickle_declare_module.paper.Item.prototype.nextSibling;
 /** @type {!Item} */
tsickle_declare_module.paper.Item.prototype.previousSibling;
 /** @type {number} */
tsickle_declare_module.paper.Item.prototype.index;
 /** @type {(string|!Color)} */
tsickle_declare_module.paper.Item.prototype.strokeColor;
 /** @type {number} */
tsickle_declare_module.paper.Item.prototype.strokeWidth;
 /** @type {string} */
tsickle_declare_module.paper.Item.prototype.strokeCap;
 /** @type {string} */
tsickle_declare_module.paper.Item.prototype.strokeJoin;
 /** @type {number} */
tsickle_declare_module.paper.Item.prototype.dashOffset;
 /** @type {boolean} */
tsickle_declare_module.paper.Item.prototype.strokeScaling;
 /** @type {!Array<number>} */
tsickle_declare_module.paper.Item.prototype.dashArray;
 /** @type {number} */
tsickle_declare_module.paper.Item.prototype.miterLimit;
 /** @type {string} */
tsickle_declare_module.paper.Item.prototype.windingRule;
 /** @type {(string|!Color)} */
tsickle_declare_module.paper.Item.prototype.fillColor;
 /** @type {string} */
tsickle_declare_module.paper.Item.prototype.fillRule;
 /** @type {(string|!Color)} */
tsickle_declare_module.paper.Item.prototype.selectedColor;
 /** @type {function(!IFrameEvent): void} */
tsickle_declare_module.paper.Item.prototype.onFrame;
 /** @type {function(!MouseEvent): void} */
tsickle_declare_module.paper.Item.prototype.onMouseDown;
 /** @type {function(!MouseEvent): void} */
tsickle_declare_module.paper.Item.prototype.onMouseUp;
 /** @type {function(!MouseEvent): void} */
tsickle_declare_module.paper.Item.prototype.onClick;
 /** @type {function(!MouseEvent): void} */
tsickle_declare_module.paper.Item.prototype.onDoubleClick;
 /** @type {function(!MouseEvent): void} */
tsickle_declare_module.paper.Item.prototype.onMouseMove;
 /** @type {function(!MouseEvent): void} */
tsickle_declare_module.paper.Item.prototype.onMouseEnter;
 /** @type {function(!MouseEvent): void} */
tsickle_declare_module.paper.Item.prototype.onMouseLeave;

/**
 * Sets those properties of the passed object literal on this item to the values defined in the object literal, if the item has property of the given name (or a setter defined for it).
 * @param {?} props
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.set = function(props) {};

/**
 * Clones the item within the same project and places the copy above the item.
 * @param {boolean=} insert [optional] - specifies whether the copy should be inserted into the DOM. When set to true, it is inserted above the original. default: true
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.clone = function(insert) {};

/**
 * When passed a project, copies the item to the project, or duplicates it within the same project. When passed an item, copies the item into the specified item.
 * @param {!Item} item - the item or project to copy the item to
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.copyTo = function(item) {};

/**
 * Rasterizes the item into a newly created Raster object. The item itself is not removed after rasterization.
 * @param {number} resolution [optional] - the resolution of the raster in pixels per inch (DPI). If not specified, the value of view.resolution is used. default: view.resolution
 * @return {!Raster}
 */
tsickle_declare_module.paper.Item.prototype.rasterize = function(resolution) {};

/**
 * Checks whether the item's geometry contains the given point.
 * @param {!Point} point - The point to check for.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.contains = function(point) {};

/**
 *
 * @param {!Rectangle} rect - the rectangle to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isInside = function(rect) {};

/**
 *
 * @param {!Item} item - the item to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.intersects = function(item) {};

/**
 * Perform a hit-test on the items contained within the project at the location of the specified point.
 * The options object allows you to control the specifics of the hit-test and may contain a combination of the following values:
 * @param {!Point} point - the point where the hit-test should be performed
 * @param {{tolerance: number, class: string, fill: boolean, stroke: boolean, segments: boolean, curves: boolean, handles: boolean, ends: boolean, bounds: boolean, center: boolean, guides: boolean, selected: boolean, match: function(!HitResult): boolean}=} options
 * @return {!HitResult}
 */
tsickle_declare_module.paper.Item.prototype.hitTest = function(point, options) {};

/**
 * Checks whether the item matches the criteria described by the given object, by iterating over all of its properties and matching against their values through matches(name, compare).
 * See project.getItems(match) for a selection of illustrated examples.
 * Checks whether the item matches the given criteria. Extended matching is possible by providing a compare function or a regular expression.
 * Matching points, colors only work as a comparison of the full object, not partial matching (e.g. only providing the x-coordinate to match all points with that x-value). Partial matching does work for item.data.
 * @param {?|string} match_or_name - the criteria to match against. / - the name of the state to match against.
 * @param {?=} compare - the value, function or regular expression to compare against.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.matches = function(match_or_name, compare) {};

/**
 * Fetch the descendants (children or children of children) of this item that match the properties in the specified object.
 * Extended matching is possible by providing a compare function or regular expression. Matching points, colors only work as a comparison of the full object, not partial matching (e.g. only providing the x- coordinate to match all points with that x-value). Partial matching does work for item.data.
 * Matching items against a rectangular area is also possible, by setting either match.inside or match.overlapping to a rectangle describing the area in which the items either have to be fully or partly contained.
 * @param {?} match
 * @return {!Array<!Item>}
 */
tsickle_declare_module.paper.Item.prototype.getItems = function(match) {};

/**
 * Fetch the first descendant (child or child of child) of this item that matches the properties in the specified object.
 * Extended matching is possible by providing a compare function or regular expression. Matching points, colors only work as a comparison of the full object, not partial matching (e.g. only providing the x- coordinate to match all points with that x-value). Partial matching does work for item.data.
 * @param {?} match - the criteria to match against
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.getItem = function(match) {};

/**
 * Exports (serializes) the project with all its layers and child items to a JSON data string.
 * @param {{asString: boolean, precision: number}=} options [optional] - default {asString: true, precision: 5}
 * @return {string}
 */
tsickle_declare_module.paper.Item.prototype.exportJSON = function(options) {};

/**
 * Imports (deserializes) the stored JSON data into the project.
 * Note that the project is not cleared first. You can call project.clear() to do so.
 * @param {string} json
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.importJSON = function(json) {};

/**
 * Exports the project with all its layers and child items as an SVG DOM, all contained in one top level SVG group node.
 * @param {{asString: boolean, precision: number, matchShapes: boolean}=} options [optional] the export options, default: { asString: false, precision: 5, matchShapes: false }
 * @return {!SVGElement}
 */
tsickle_declare_module.paper.Item.prototype.exportSVG = function(options) {};

/**
 * Converts the provided SVG content into Paper.js items and adds them to the active layer of this project.
 * Note that the project is not cleared first. You can call project.clear() to do so.
 * @param {(string|!SVGElement)} svg - the SVG content to import
 * @param {?=} options [optional] - the import options, default: { expandShapes: false }
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.importSVG = function(svg, options) {};

/**
 * Adds the specified item as a child of this item at the end of the its children list. You can use this function for groups, compound paths and layers.
 * @param {!Item} item - the item to add as a child
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.addChild = function(item) {};

/**
 * Inserts the specified item as a child of this item at the specified index in its children list. You can use this function for groups, compound paths and layers.
 * @param {number} index - the index
 * @param {!Item} item - the item to be inserted as a child
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.insertChild = function(index, item) {};

/**
 * Adds the specified items as children of this item at the end of the its children list. You can use this function for groups, compound paths and layers.
 * @param {!Array<!Item>} items - The items to be added as children
 * @return {!Array<!Item>}
 */
tsickle_declare_module.paper.Item.prototype.addChildren = function(items) {};

/**
 * Inserts the specified items as children of this item at the specified index in its children list. You can use this function for groups, compound paths and layers.
 * @param {number} index -
 * @param {!Array<!Item>} items - The items to be appended as children
 * @return {!Array<!Item>}
 */
tsickle_declare_module.paper.Item.prototype.insertChildren = function(index, items) {};

/**
 * Inserts this item above the specified item.
 * @param {!Item} item - the item above which it should be inserted
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.insertAbove = function(item) {};

/**
 * Inserts this item below the specified item.
 * @param {!Item} item - the item below which it should be inserted
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.insertBelow = function(item) {};

/**
 * Moves this item above the specified item. Returns true if the item
 * was moved.
 * @param {!Item} item - the item above which it should be moved
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.moveAbove = function(item) {};

/**
 * Moves this item below the specified item. Returns true if the item
 * was moved.
 * @param {!Item} item - the item below which it should be moved
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.moveBelow = function(item) {};

/**
 * Sends this item to the back of all other items within the same parent.
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.sendToBack = function() {};

/**
 * Brings this item to the front of all other items within the same parent.
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.bringToFront = function() {};

/**
 * If this is a group, layer or compound-path with only one child-item, the child-item is moved outside and the parent is erased. Otherwise, the item itself is returned unmodified.
 * @return {!Item}
 */
tsickle_declare_module.paper.Item.prototype.reduce = function() {};

/**
 * Removes the item and all its children from the project. The item is not destroyed and can be inserted again after removal.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.remove = function() {};

/**
 * Replaces this item with the provided new item which will takes its place in the project hierarchy instead.
 * @param {!Item} item - the item to replace this one with
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.replaceWith = function(item) {};

/**
 * Removes all of the item's children (if any).
 * Removes the children from the specified from index to the to index from the parent's children array.
 * @param {number=} from - the beginning index, inclusive
 * @param {number=} to [optional] - the ending index, exclusive, default: children.length
 * @return {!Array<!Item>}
 */
tsickle_declare_module.paper.Item.prototype.removeChildren = function(from, to) {};

/**
 * Reverses the order of the item's children
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.reverseChildren = function() {};

/**
 * Specifies whether the item has any content or not. The meaning of what content is differs from type to type. For example, a Group with no children, a TextItem with no text content and a Path with no segments all are considered empty.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isEmpty = function() {};

/**
 * Checks whether the item has a fill.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.hasFill = function() {};

/**
 * Checks whether the item has a stroke.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.hasStroke = function() {};

/**
 * Checks whether the item has a shadow.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.hasShadow = function() {};

/**
 * Checks if the item contains any children items.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.hasChildren = function() {};

/**
 * Checks whether the item and all its parents are inserted into the DOM or not.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isInserted = function() {};

/**
 * Checks if this item is above the specified item in the stacking order of the project.
 * @param {!Item} item - The item to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isAbove = function(item) {};

/**
 * Checks if the item is below the specified item in the stacking order of the project.
 * @param {!Item} item - The item to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isBelow = function(item) {};

/**
 * Checks whether the specified item is the parent of the item.
 * @param {!Item} item - The item to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isParent = function(item) {};

/**
 * Checks whether the specified item is a child of the item.
 * @param {!Item} item - The item to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isChild = function(item) {};

/**
 * Checks if the item is contained within the specified item.
 * @param {!Item} item - The item to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isDescendant = function(item) {};

/**
 * Checks if the item is an ancestor of the specified item.
 * @param {!Item} item - the item to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isAncestor = function(item) {};

/**
 * Checks whether the item is grouped with the specified item.
 * @param {!Item} item -
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.isGroupedWith = function(item) {};

/**
 * Translates (moves) the item by the given offset point.
 * @param {!Point} delta - the offset to translate the item by
 * @return {!Point}
 */
tsickle_declare_module.paper.Item.prototype.translate = function(delta) {};

/**
 * Rotates the item by a given angle around the given point.
 * Angles are oriented clockwise and measured in degrees.
 * @param {number} angle - the rotation angle
 * @param {!Point=} center [optional] - default: item.position
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.rotate = function(angle, center) {};

/**
 * Gets the current rotation of the item.
 * @return {number}
 */
tsickle_declare_module.paper.Item.prototype.getRotation = function() {};

/**
 * Scales the item by the given value from its center point, or optionally from a supplied point.
 * Scales the item by the given values from its center point, or optionally from a supplied point.
 * @param {number} scale_or_hor - the scale factor / - the horizontal scale factor
 * @param {!Point|number=} center_or_ver [optional] - default: item.position / - the vertical scale factor
 * @param {!Point=} center [optional] - default: item.position
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.scale = function(scale_or_hor, center_or_ver, center) {};

/**
 * Shears the item by the given value from its center point, or optionally by a supplied point.
 * Shears the item by the given values from its center point, or optionally by a supplied point.
 * @param {number} shear_or_hor - the horziontal and vertical shear factors as a point / - the horizontal shear factor
 * @param {!Point|number=} center_or_ver [optional] - default: item.position / - the vertical shear factor
 * @param {!Point=} center [optional] - default: item.position
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.shear = function(shear_or_hor, center_or_ver, center) {};

/**
 * Skews the item by the given angles from its center point, or optionally by a supplied point.
 * Skews the item by the given angles from its center point, or optionally by a supplied point.
 * @param {!Point|number} skew_or_hor - the horziontal and vertical skew angles in degrees / - the horizontal skew angle in degrees
 * @param {!Point|number=} center_or_ver [optional] - default: item.position / - the vertical sskew angle in degrees
 * @param {!Point=} center [optional] - default: item.position
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.skew = function(skew_or_hor, center_or_ver, center) {};

/**
 * Transform the item.
 * @param {!Matrix} matrix - the matrix by which the item shall be transformed.
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.transform = function(matrix) {};

/**
 * Converts the specified point from global project coordinate space to the item's own local coordinate space.
 * @param {!Point} point - the point to be transformed
 * @return {!Point}
 */
tsickle_declare_module.paper.Item.prototype.globalToLocal = function(point) {};

/**
 * Converts the specified point from the item's own local coordinate space to the global project coordinate space.
 * @param {!Point} point - the point to be transformed
 * @return {!Point}
 */
tsickle_declare_module.paper.Item.prototype.localToGlobal = function(point) {};

/**
 * Converts the specified point from the parent's coordinate space to item's own local coordinate space.
 * @param {!Point} point - the point to be transformed
 * @return {!Point}
 */
tsickle_declare_module.paper.Item.prototype.parentToLocal = function(point) {};

/**
 * Converts the specified point from the item's own local coordinate space to the parent's coordinate space.
 * @param {!Point} point - the point to be transformed
 * @return {!Point}
 */
tsickle_declare_module.paper.Item.prototype.localToParent = function(point) {};

/**
 * Transform the item so that its bounds fit within the specified rectangle, without changing its aspect ratio.
 * @param {!Rectangle} rectangle -
 * @param {boolean=} fill [optiona;] - default = false
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.fitBounds = function(rectangle, fill) {};

/**
 * Attach an event handler to the tool.
 * Attach one or more event handlers to the tool.
 * Attaches an event handler to the item.
 * Attaches one or more event handlers to the item.
 * @param {string|?} type_or_param - String('mousedown'|'mouseup'|'mousedrag'|'mousemove'|'keydown'|'keyup') the event type / - an object literal containing one or more of the following properties: mousedown, mouseup, mousedrag, mousemove, keydown, keyup
 * @param {function(!ToolEvent): void|function(): void=} callback
 * @return {!Tool|!Item}
 */
tsickle_declare_module.paper.Item.prototype.on = function(type_or_param, callback) {};

/**
 * Detach an event handler from the tool.
 * Detach one or more event handlers from the tool.
 * Detach an event handler from the item.
 * Detach one or more event handlers to the item.
 * @param {string|?} type_or_param - String('mousedown'|'mouseup'|'mousedrag'|'mousemove'|'keydown'|'keyup') the event type / -  an object literal containing one or more of the following properties: mousedown, mouseup, mousedrag, mousemove, keydown, keyup
 * @param {function(!ToolEvent): void=} callback
 * @return {!Tool|!Item}
 */
tsickle_declare_module.paper.Item.prototype.off = function(type_or_param, callback) {};

/**
 * Emit an event on the tool.
 * Emit an event on the item.
 * @param {string} type - String('mousedown'|'mouseup'|'mousedrag'|'mousemove'|'keydown'|'keyup') the event type
 * @param {?} event - an object literal containing properties describing the event.
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.emit = function(type, event) {};

/**
 * Check if the tool has one or more event handlers of the specified type.
 * Check if the item has one or more event handlers of the specified type..
 * @param {string} type - String('mousedown'|'mouseup'|'mousedrag'|'mousemove'|'keydown'|'keyup') the event type
 * @return {boolean}
 */
tsickle_declare_module.paper.Item.prototype.responds = function(type) {};

/**
 * Removes the item when the events specified in the passed object literal occur.
 * @param {{move: boolean, drag: boolean, down: boolean, up: boolean}} object - The object literal can contain the following values
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.removeOn = function(object) {};

/**
 * Removes the item when the next tool.onMouseMove event is fired.
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.removeOnMove = function() {};

/**
 * Removes the item when the next tool.onMouseDown event is fired.
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.removeOnDown = function() {};

/**
 * Removes the item when the next tool.onMouseDrag event is fired.
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.removeOnDrag = function() {};

/**
 * Removes the item when the next tool.onMouseUp event is fired.
 * @return {void}
 */
tsickle_declare_module.paper.Item.prototype.removeOnUp = function() {};

/**
 * @constructor
 * @struct
 * Creates a new Group item and places it at the top of the active layer.
 * Creates a new Group item and places it at the top of the active layer.
 * @param {!Array<!Item>|?=} children_or_object [optional] - An array of Item Objects children that will be added to the newly created group. / [optional] - an object literal containing the properties to be set on the group.
 */
tsickle_declare_module.paper.Group = function(children_or_object) {};
 /** @type {boolean} */
tsickle_declare_module.paper.Group.prototype.clipped;

/**
 * @constructor
 * @struct
 * Creates a new Layer item and places it at the end of the project.layers array. The newly created layer will be activated, so all newly created items will be placed within it.
 * Creates a new Layer item and places it at the end of the project.layers array. The newly created layer will be activated, so all newly created items will be placed within it.
 * @param {!Array<!Item>|?=} children_or_object [optional] - An array of Items that will be added to the newly created layer. / [optional] - an object literal containing the properties to be set on the layer.
 */
tsickle_declare_module.paper.Layer = function(children_or_object) {};

/**
 * Activates the layer.
 * @return {void}
 */
tsickle_declare_module.paper.Layer.prototype.activate = function() {};
/**
 * @extends {Item}
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.Shape = function() {};
 /** @type {string} */
tsickle_declare_module.paper.Shape.prototype.type;
 /** @type {!Size} */
tsickle_declare_module.paper.Shape.prototype.size;
 /** @type {(number|!Size)} */
tsickle_declare_module.paper.Shape.prototype.radius;

/**
 * Creates a circular shape item.
 * Creates a circular shape item from the properties described by an object literal.
 * @param {!Point|?} center_or_object - the center point of the circle / - an object literal containing properties descriving the shapes attributes
 * @param {number=} radius - the radius of the circle
 * @return {!Shape}
 */
tsickle_declare_module.paper.Shape.Circle = function(center_or_object, radius) {};

/**
 * Creates a rectangular shape item, with optionally rounded corners.
 * Creates a rectangular shape item from a point and a size object.
 * Creates a rectangular shape item from the passed points. These do not necessarily need to be the top left and bottom right corners, the constructor figures out how to fit a rectangle between them.
 * Creates a rectangular shape item from the properties described by an object literal.
 * @param {!Rectangle|!Point|?} rectangle_or_point_or_from_or_object - the rectangle object describing the geometry of the rectangular shape to be created. / - the rectangle's top-left corner / - the first point defining the rectangle / - an object literal containing properties describing the shape's attributes
 * @param {number|!Size|!Point=} radius_or_size_or_to [optional] - the size of the rounded corners, default: null / - the rectangle's size. / - the second point defining the rectangle
 * @return {!Shape}
 */
tsickle_declare_module.paper.Shape.Rectangle = function(rectangle_or_point_or_from_or_object, radius_or_size_or_to) {};

/**
 * Creates an elliptical shape item.
 * Creates an elliptical shape item from the properties described by an object literal.
 * @param {!Rectangle|?} rectangle_or_object - the rectangle circumscribing the ellipse / - an object literal containing properties describing the shape's attributes
 * @return {!Shape}
 */
tsickle_declare_module.paper.Shape.Ellipse = function(rectangle_or_object) {};

/**
 * @constructor
 * @struct
 * Creates a new raster item from the passed argument, and places it in the active layer. object can either be a DOM Image, a Canvas, or a string describing the URL to load the image from, or the ID of a DOM element to get the image from (either a DOM Image or a Canvas).
 * @param {(string|!HTMLCanvasElement|!HTMLImageElement)|?=} source_or_config [optional] - the source of the raster
 * @param {!Point=} position [optional] - the center position at which the raster item is placed
 */
tsickle_declare_module.paper.Raster = function(source_or_config, position) {};
 /** @type {!Size} */
tsickle_declare_module.paper.Raster.prototype.size;
 /** @type {number} */
tsickle_declare_module.paper.Raster.prototype.width;
 /** @type {number} */
tsickle_declare_module.paper.Raster.prototype.height;
 /** @type {!Size} */
tsickle_declare_module.paper.Raster.prototype.resolution;
 /** @type {(!HTMLCanvasElement|!HTMLImageElement)} */
tsickle_declare_module.paper.Raster.prototype.image;
 /** @type {!HTMLCanvasElement} */
tsickle_declare_module.paper.Raster.prototype.canvas;
 /** @type {!CanvasRenderingContext2D} */
tsickle_declare_module.paper.Raster.prototype.context;
 /** @type {(string|!HTMLCanvasElement|!HTMLImageElement)} */
tsickle_declare_module.paper.Raster.prototype.source;

/**
 * Extracts a part of the Raster's content as a sub image, and returns it as a Canvas object.
 * @param {!Rectangle} rect - the boundaries of the sub image in pixel coordinates
 * @return {!HTMLCanvasElement}
 */
tsickle_declare_module.paper.Raster.prototype.getSubCanvas = function(rect) {};

/**
 * Extracts a part of the raster item's content as a new raster item, placed in exactly the same place as the original content.
 * @param {!Rectangle} rect - the boundaries of the sub raster in pixel coordinates
 * @return {!Raster}
 */
tsickle_declare_module.paper.Raster.prototype.getSubRaster = function(rect) {};

/**
 * Returns a Base 64 encoded data: URL representation of the raster.
 * @return {string}
 */
tsickle_declare_module.paper.Raster.prototype.toDataURL = function() {};

/**
 * Draws an image on the raster.
 * @param {(!HTMLCanvasElement|!HTMLImageElement)} image - the image to draw
 * @param {!Point} point - the offset of the image as a point in pixel coordinates
 * @return {void}
 */
tsickle_declare_module.paper.Raster.prototype.drawImage = function(image, point) {};

/**
 * Calculates the average color of the image within the given path, rectangle or point. This can be used for creating raster image effects.
 * @param {(!Point|!Rectangle|!Path)} object - the path, rectangle or point to get the average image color from
 * @return {!Color}
 */
tsickle_declare_module.paper.Raster.prototype.getAverageColor = function(object) {};

/**
 * Gets the color of a pixel in the raster.
 * Gets the color of a pixel in the raster.
 * @param {number|!Point} x_or_point - the x offset of the pixel in pixel coordinates / - the offset of the pixel as a point in pixel coordinates
 * @param {number=} y - the y offset of the pixel in pixel coordinates
 * @return {!Color}
 */
tsickle_declare_module.paper.Raster.prototype.getPixel = function(x_or_point, y) {};

/**
 * Sets the color of the specified pixel to the specified color
 * Sets the color of the specified pixel to the specified color.
 * @param {number|!Point} x_or_point - the x offset of the pixel in pixel coordinates / - the offset of the pixel as a point in pixel coordinates
 * @param {number|!Color} y_or_color - the y offset of the pixel in pixel coordinates / - the color that the pixel will be set to
 * @param {!Color=} color - the color that the pixel will be set to
 * @return {void}
 */
tsickle_declare_module.paper.Raster.prototype.setPixel = function(x_or_point, y_or_color, color) {};

/**
 *
 * @param {!Size} size
 * @return {!ImageData}
 */
tsickle_declare_module.paper.Raster.prototype.createImageData = function(size) {};

/**
 *
 * 
 * 
 * @param {!Rectangle|!ImageData} rect_or_data
 * @param {!Point=} point
 * @return {!ImageData|void}
 */
tsickle_declare_module.paper.Raster.prototype.getImageData = function(rect_or_data, point) {};

/**
 * @constructor
 * @struct
 * Creates a new PlacedSymbol Item.
 * @param {!Symbol} symbol - the symbol to place
 * @param {!Point=} point [optional] - the center point of the placed symbol
 */
tsickle_declare_module.paper.PlacedSymbol = function(symbol, point) {};
 /** @type {!Symbol} */
tsickle_declare_module.paper.PlacedSymbol.prototype.symbol;
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.HitResult = function() {};
 /** @type {string} */
tsickle_declare_module.paper.HitResult.prototype.type;
 /** @type {string} */
tsickle_declare_module.paper.HitResult.prototype.name;
 /** @type {!Item} */
tsickle_declare_module.paper.HitResult.prototype.item;
 /** @type {!CurveLocation} */
tsickle_declare_module.paper.HitResult.prototype.location;
 /** @type {!Color} */
tsickle_declare_module.paper.HitResult.prototype.color;
 /** @type {!Segment} */
tsickle_declare_module.paper.HitResult.prototype.segment;
 /** @type {!Point} */
tsickle_declare_module.paper.HitResult.prototype.point;
/**
 * @extends {Item}
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.PathItem = function() {};
 /** @type {string} */
tsickle_declare_module.paper.PathItem.prototype.pathData;

/**
 * Returns all intersections between two PathItem items as an array of CurveLocation objects. CompoundPath items are also supported.
 * @param {!PathItem} path - the other item to find the intersections with
 * @param {boolean=} sorted [optional] - specifies whether the returned CurveLocation objects should be sorted by path and offset, default: false
 * @return {!Array<!CurveLocation>}
 */
tsickle_declare_module.paper.PathItem.prototype.getIntersections = function(path, sorted) {};

/**
 * Smooth bezier curves without changing the amount of segments or their points, by only smoothing and adjusting their handle points, for both open ended and closed paths.
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.smooth = function() {};

/**
 * On a normal empty Path, the point is simply added as the path's first segment. If called on a CompoundPath, a new Path is created as a child and the point is added as its first segment.
 * @param {!Point} point - the path's first segment
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.moveTo = function(point) {};

/**
 * Draw a line from the current point to the given point
 * @param {!Point} point - the end point of the line
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.lineTo = function(point) {};

/**
 * Adds a cubic bezier curve to the path, defined by two handles and a to point.
 * @param {!Point} handle1 - The first control point handle for the curve
 * @param {!Point} handle2 - The second control point handle for the curve
 * @param {!Point} to - The end control point of the curve
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.cubicCurveTo = function(handle1, handle2, to) {};

/**
 * Adds a quadratic bezier curve to the path, defined by a handle and a to point.
 * @param {!Point} handle - The control point for the curve
 * @param {!Point} to - The end control point of the curve
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.quadraticCurveTo = function(handle, to) {};

/**
 * Draws a curve from the position of the last segment point in the path that goes through the specified through point, to the specified to point by adding one segment to the path.
 * @param {!Point} through - the point through which the curve should go
 * @param {!Point} to - the point where the curve should end
 * @param {number=} parameter [optional] - default: 0.5
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.curveTo = function(through, to, parameter) {};

/**
 * Draws an arc from the position of the last segment point in the path that goes through the specified through point, to the specified to point by adding one or more segments to the path.
 * Draws an arc from the position of the last segment point in the path to the specified point by adding one or more segments to the path.
 * @param {!Point} through_or_to - the point where the arc should pass through / - the point where the arc should end
 * @param {!Point|boolean=} to_or_clockwise - the point where the arc should end
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.arcTo = function(through_or_to, to_or_clockwise) {};

/**
 * Closes the path. When closed, Paper.js connects the first and last segment of the path with an additional curve.
 * @param {boolean} join - controls whether the method should attempt to merge the first segment with the last if they lie in the same location.
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.closePath = function(join) {};

/**
 * If called on a CompoundPath, a new Path is created as a child and a point is added as its first segment relative to the position of the last segment of the current path.
 * @param {!Point} to -
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.moveBy = function(to) {};

/**
 * Adds a segment relative to the last segment point of the path.
 * @param {!Point} to - the vector which is added to the position of the last segment of the path, to get to the position of the new segment.
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.lineBy = function(to) {};

/**
 *
 * @param {!Point} through -
 * @param {!Point} to -
 * @param {number=} parameter [optional] - default 0.5
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.curveBy = function(through, to, parameter) {};

/**
 *
 * @param {!Point} handle1 -
 * @param {!Point} handle2 -
 * @param {!Point} to -
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.cubicCurveBy = function(handle1, handle2, to) {};

/**
 *
 * @param {!Point} handle -
 * @param {!Point} to -
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.quadraticCurveBy = function(handle, to) {};

/**
 *
 *
 * @param {!Point} through_or_to -
 * @param {!Point|boolean=} to_or_clockwise - / [optional] - default: true
 * @return {void}
 */
tsickle_declare_module.paper.PathItem.prototype.arcBy = function(through_or_to, to_or_clockwise) {};

/**
 * Merges the geometry of the specified path from this path's geometry and returns the result as a new path item.
 * @param {!PathItem} path - the path to unite with
 * @return {!PathItem}
 */
tsickle_declare_module.paper.PathItem.prototype.unite = function(path) {};

/**
 * Intersects the geometry of the specified path with this path's geometry and returns the result as a new path item.
 * @param {!PathItem} path - the path to intersect with
 * @return {!PathItem}
 */
tsickle_declare_module.paper.PathItem.prototype.intersect = function(path) {};

/**
 * Subtracts the geometry of the specified path from this path's geometry and returns the result as a new path item.
 * @param {!PathItem} path
 * @return {!PathItem}
 */
tsickle_declare_module.paper.PathItem.prototype.subtract = function(path) {};

/**
 * Excludes the intersection of the geometry of the specified path with this path's geometry and returns the result as a new group item.
 * @param {!PathItem} path
 * @return {!PathItem}
 */
tsickle_declare_module.paper.PathItem.prototype.exclude = function(path) {};

/**
 * Splits the geometry of this path along the geometry of the specified path returns the result as a new group item.
 * @param {!PathItem} path
 * @return {!PathItem}
 */
tsickle_declare_module.paper.PathItem.prototype.divide = function(path) {};

/**
 * @constructor
 * @struct
 * Creates a new path item and places it at the top of the active layer.
 * Creates a new path item from an object description and places it at the top of the active layer.
 * Creates a new path item from SVG path-data and places it at the top of the active layer.
 * @param {(!Array<!Segment>|!Array<!Point>)|?|string=} segments_or_object_or_pathData [optional] - An array of segments (or points to be converted to segments) that will be added to the path / - an object literal containing properties describing the path's attributes / - the SVG path-data that describes the geometry of this path.
 */
tsickle_declare_module.paper.Path = function(segments_or_object_or_pathData) {};
 /** @type {!Array<!Segment>} */
tsickle_declare_module.paper.Path.prototype.segments;
 /** @type {!Segment} */
tsickle_declare_module.paper.Path.prototype.firstSegment;
 /** @type {!Segment} */
tsickle_declare_module.paper.Path.prototype.lastSegment;
 /** @type {!Array<!Curve>} */
tsickle_declare_module.paper.Path.prototype.curves;
 /** @type {!Curve} */
tsickle_declare_module.paper.Path.prototype.firstCurve;
 /** @type {!Curve} */
tsickle_declare_module.paper.Path.prototype.lastCurve;
 /** @type {boolean} */
tsickle_declare_module.paper.Path.prototype.closed;
 /** @type {number} */
tsickle_declare_module.paper.Path.prototype.length;
 /** @type {number} */
tsickle_declare_module.paper.Path.prototype.area;
 /** @type {boolean} */
tsickle_declare_module.paper.Path.prototype.fullySelected;
 /** @type {boolean} */
tsickle_declare_module.paper.Path.prototype.clockwise;
 /** @type {!Point} */
tsickle_declare_module.paper.Path.prototype.interiorPoint;

/**
 * Adds one or more segments to the end of the segments array of this path.
 * @param {(!Point|!Segment)} segment - the segment or point to be added.
 * Returns the added segment. This is not necessarily the same object, e.g. if the segment to be added already belongs to another path.
 * @return {!Segment}
 */
tsickle_declare_module.paper.Path.prototype.add = function(segment) {};

/**
 * Inserts one or more segments at a given index in the list of this path's segments.
 * @param {number} index - the index at which to insert the segment.
 * @param {(!Point|!Segment)} segment - the segment or point to be inserted.
 * Returns the added segment. This is not necessarily the same object, e.g. if the segment to be added already belongs to another path.
 * @return {!Segment}
 */
tsickle_declare_module.paper.Path.prototype.insert = function(index, segment) {};

/**
 * Adds an array of segments (or types that can be converted to segments) to the end of the segments array.
 * @param {!Array<!Segment>} segments - Array of Segment objects
 * Returns an array of the added segments. These segments are not necessarily the same objects, e.g. if the segment to be added already belongs to another path.
 * @return {!Array<!Segment>}
 */
tsickle_declare_module.paper.Path.prototype.addSegments = function(segments) {};

/**
 * Inserts an array of segments at a given index in the path's segments array.
 * @param {number} index - the index at which to insert the segments.
 * @param {!Array<!Segment>} segments - the segments to be inserted.
 * Returns an array of the added segments. These segments are not necessarily the same objects, e.g. if the segment to be added already belongs to another path.
 * @return {!Array<!Segment>}
 */
tsickle_declare_module.paper.Path.prototype.insertSegments = function(index, segments) {};

/**
 * Removes the segment at the specified index of the path's segments array.
 * @param {number} index - the index of the segment to be removed
 * Returns the removed segment
 * @return {!Segment}
 */
tsickle_declare_module.paper.Path.prototype.removeSegment = function(index) {};

/**
 * Removes all segments from the path's segments array.
 * Returns an array containing the removed segments
 * Removes the segments from the specified from index to the to index from the path's segments array.
 * @param {number=} from - the beginning index, inclusive
 * @param {number=} to [optional = segments.length] - the ending index
 * Returns an array containing the removed segments
 * @return {!Array<!Segment>}
 */
tsickle_declare_module.paper.Path.prototype.removeSegments = function(from, to) {};

/**
 * Converts the curves in a path to straight lines with an even distribution of points. The distance between the produced segments is as close as possible to the value specified by the maxDistance parameter.
 * @param {number} maxDistance - the maximum distance between the points
 * @return {void}
 */
tsickle_declare_module.paper.Path.prototype.flatten = function(maxDistance) {};

/**
 * Smooths a path by simplifying it. The path.segments array is analyzed and replaced by a more optimal set of segments, reducing memory usage and speeding up drawing.
 * @param {number=} tolerance [optional = 2.5] -
 * @return {void}
 */
tsickle_declare_module.paper.Path.prototype.simplify = function(tolerance) {};

/**
 * Splits the path at the given offset. After splitting, the path will be open. If the path was open already, splitting will result in two paths.
 * Splits the path at the given curve location. After splitting, the path will be open. If the path was open already, splitting will result in two paths.
 * Splits the path at the given curve index and parameter. After splitting, the path will be open. If the path was open already, splitting will result in two paths.
 * @param {number|!CurveLocation} offset_or_location_or_index - the offset at which to split the path as a number between 0 and path.length
 * Returns the newly created path after splitting, if any / - the curve location at which to split the path
 * Returns the newly created path after splitting, if any / - the index of the curve in the path.curves array at which to split
 * @param {number=} parameter - the parameter at which the curve will be split
 * Returns the newly created path after splitting, if any
 * @return {!Path}
 */
tsickle_declare_module.paper.Path.prototype.split = function(offset_or_location_or_index, parameter) {};

/**
 * Reverses the orientation of the path, by reversing all its segments.
 * @return {void}
 */
tsickle_declare_module.paper.Path.prototype.reverse = function() {};

/**
 * Joins the path with the specified path, which will be removed in the process.
 * @param {!Path} path - the path to join this path with
 * Returns the joined path
 * @return {!Path}
 */
tsickle_declare_module.paper.Path.prototype.join = function(path) {};

/**
 * Returns the curve location of the specified point if it lies on the path, null otherwise.
 * @param {!Point} point - the point on the path.
 * @return {!CurveLocation}
 */
tsickle_declare_module.paper.Path.prototype.getLocationOf = function(point) {};

/**
 * Returns the length of the path from its beginning up to up to the specified point if it lies on the path, null otherwise.
 * @param {!Point} point - the point on the path.
 * @return {number}
 */
tsickle_declare_module.paper.Path.prototype.getOffsetOf = function(point) {};

/**
 * Returns the curve location of the specified offset on the path.
 * @param {number} offset - the offset on the path, where 0 is at the beginning of the path and path.length at the end.
 * @param {boolean=} isParameter [optional=false] -
 * @return {!CurveLocation}
 */
tsickle_declare_module.paper.Path.prototype.getLocationAt = function(offset, isParameter) {};

/**
 * Calculates the point on the path at the given offset. Returns the point at the given offset
 * @param {number} offset - the offset on the path, where 0 is at the beginning of the path and path.length at the end.
 * @param {boolean=} isPatameter
 * @return {!Point}
 */
tsickle_declare_module.paper.Path.prototype.getPointAt = function(offset, isPatameter) {};

/**
 * Calculates the tangent vector of the path at the given offset. Returns the tangent vector at the given offset
 * @param {number} offset - the offset on the path, where 0 is at the beginning of the path and path.length at the end.
 * @param {boolean=} isPatameter
 * @return {!Point}
 */
tsickle_declare_module.paper.Path.prototype.getTangentAt = function(offset, isPatameter) {};

/**
 * Calculates the normal vector of the path at the given offset. Returns the normal vector at the given offset
 * @param {number} offset - the offset on the path, where 0 is at the beginning of the path and path.length at the end.
 * @param {boolean=} isParameter [optional=false] -
 * @return {!Point}
 */
tsickle_declare_module.paper.Path.prototype.getNormalAt = function(offset, isParameter) {};

/**
 * Calculates the curvature of the path at the given offset. Curvatures indicate how sharply a path changes direction. A straight line has zero curvature, where as a circle has a constant curvature. The path's radius at the given offset is the reciprocal value of its curvature.
 * @param {number} offset - the offset on the path, where 0 is at the beginning of the path and path.length at the end.
 * @param {boolean=} isParameter [optional=false] -
 * @param {!Point=} point - the point for which we search the nearest location
 * @return {number}
 */
tsickle_declare_module.paper.Path.prototype.getCurvatureAt = function(offset, isParameter, point) {};

/**
 * Returns the nearest point on the path to the specified point.
 * @param {!Point} point - the point for which we search the nearest point
 * @return {!Point}
 */
tsickle_declare_module.paper.Path.prototype.getNearestPoint = function(point) {};

/**
 * @constructor
 * @struct
 * Creates a linear path item from two points describing a line.
 * Creates a linear path item from the properties described by an object literal.
 * @param {!Point|?} from_or_object - the line's starting point / - an object literal containing properties describing the path's attributes
 * @param {!Point=} to - the line's ending point
 */
tsickle_declare_module.paper.Path.Line = function(from_or_object, to) {};

/**
 * @constructor
 * @struct
 * Creates a circular path item.
 * Creates a circular path item from the properties described by an object literal.
 * @param {!Point|?} center_or_object - the center point of the circle / - an object literal containing properties describing the path's attributes
 * @param {number=} radius - the radius of the circle
 */
tsickle_declare_module.paper.Path.Circle = function(center_or_object, radius) {};

/**
 * @constructor
 * @struct
 * Creates a rectangular path item, with optionally rounded corners.
 * Creates a rectangular path item from a point and a size object.
 * Creates a rectangular path item from the passed points. These do not necessarily need to be the top left and bottom right corners, the constructor figures out how to fit a rectangle between them.
 * Creates a rectangular path item from the properties described by an object literal.
 * @param {!Path.Rectangle|!Point|?} rectangle_or_point_or_from_or_object - the rectangle object describing the geometry of the rectangular path to be created. / - the rectangle's top-left corner. / - the first point defining the rectangle / - an object literal containing properties describing the path's attributes
 * @param {number|!Size|!Point=} radius_or_size_or_to [optional] - the size of the rounded corners default: null / - the rectangle's size. / - the second point defining the rectangle
 */
tsickle_declare_module.paper.Path.Rectangle = function(rectangle_or_point_or_from_or_object, radius_or_size_or_to) {};

/**
 * @constructor
 * @struct
 * Creates an elliptical path item.
 * Creates an elliptical path item from the properties described by an object literal.
 * @param {!Path.Rectangle|?} rectangle_or_object - the rectangle circumscribing the ellipse / - an object literal containing properties describing the path's attributes
 */
tsickle_declare_module.paper.Path.Ellipse = function(rectangle_or_object) {};

/**
 * @constructor
 * @struct
 * Creates a circular arc path item
 * Creates an circular arc path item from the properties described by an object literal.
 * @param {!Point|?} from_or_object - the starting point of the circular arc / - an object literal containing properties describing the path's attributes
 * @param {!Point=} through - the point the arc passes through
 * @param {!Point=} to - the end point of the arc
 */
tsickle_declare_module.paper.Path.Arc = function(from_or_object, through, to) {};

/**
 * @constructor
 * @struct
 * Creates a regular polygon shaped path item.
 * Creates a regular polygon shaped path item from the properties described by an object literal.
 * @param {!Point|?} center_or_object - the center point of the polygon / - an object literal containing properties describing the path's attributes
 * @param {number=} sides - the number of sides of the polygon
 * @param {number=} radius - the radius of the polygon
 */
tsickle_declare_module.paper.Path.RegularPolygon = function(center_or_object, sides, radius) {};

/**
 * @constructor
 * @struct
 * Creates a star shaped path item. The largest of radius1 and radius2 will be the outer radius of the star. The smallest of radius1 and radius2 will be the inner radius.
 * Creates a star shaped path item from the properties described by an object literal.
 * @param {!Point|?} center_or_object - the center point of the star / - an object literal containing properties describing the path's attributes
 * @param {number=} points - the number of points of the star
 * @param {number=} radius1
 * @param {number=} radius2
 */
tsickle_declare_module.paper.Path.Star = function(center_or_object, points, radius1, radius2) {};

/**
 * @constructor
 * @struct
 * Creates a new compound path item from an object description and places it at the top of the active layer.
 * Creates a new compound path item from SVG path-data and places it at the top of the active layer.
 * @param {?|string} object_or_pathData - an object literal containing properties to be set on the path / - the SVG path-data that describes the geometry of this path.
 */
tsickle_declare_module.paper.CompoundPath = function(object_or_pathData) {};
 /** @type {boolean} */
tsickle_declare_module.paper.CompoundPath.prototype.clockwise;
 /** @type {!Segment} */
tsickle_declare_module.paper.CompoundPath.prototype.firstSegment;
 /** @type {!Segment} */
tsickle_declare_module.paper.CompoundPath.prototype.lastSegment;
 /** @type {!Array<!Curve>} */
tsickle_declare_module.paper.CompoundPath.prototype.curves;
 /** @type {!Curve} */
tsickle_declare_module.paper.CompoundPath.prototype.firstCurve;
 /** @type {!Curve} */
tsickle_declare_module.paper.CompoundPath.prototype.lastCurve;
 /** @type {number} */
tsickle_declare_module.paper.CompoundPath.prototype.area;

/**
 * Reverses the orientation of all nested paths.
 * @return {void}
 */
tsickle_declare_module.paper.CompoundPath.prototype.reverse = function() {};

/**
 * @constructor
 * @struct
 * Creates a new Segment object.
 * Creates a new Segment object.
 * @param {!Point|?=} point_or_object [optional] - the anchor point of the segment default: {x: 0, y: 0} / - an object literal containing properties to be set on the segment.
 * @param {!Point=} handleIn [optional] - the handle point relative to the anchor point of the segment that describes the in tangent of the segment default: {x: 0, y: 0}
 * @param {!Point=} handleOut [optional] - the handle point relative to the anchor point of the segment that describes the out tangent of the segment default: {x: 0, y: 0}
 */
tsickle_declare_module.paper.Segment = function(point_or_object, handleIn, handleOut) {};
 /** @type {!Point} */
tsickle_declare_module.paper.Segment.prototype.point;
 /** @type {!Point} */
tsickle_declare_module.paper.Segment.prototype.handleIn;
 /** @type {!Point} */
tsickle_declare_module.paper.Segment.prototype.handleOut;
 /** @type {boolean} */
tsickle_declare_module.paper.Segment.prototype.linear;
 /** @type {boolean} */
tsickle_declare_module.paper.Segment.prototype.selected;
 /** @type {number} */
tsickle_declare_module.paper.Segment.prototype.index;
 /** @type {!Path} */
tsickle_declare_module.paper.Segment.prototype.path;
 /** @type {!Curve} */
tsickle_declare_module.paper.Segment.prototype.curve;
 /** @type {!CurveLocation} */
tsickle_declare_module.paper.Segment.prototype.location;
 /** @type {!Segment} */
tsickle_declare_module.paper.Segment.prototype.next;
 /** @type {!Segment} */
tsickle_declare_module.paper.Segment.prototype.previous;

/**
 * Returns true if the the two segments are the beginning of two lines and if these two lines are running parallel.
 * @param {!Segment} segment
 * @return {boolean}
 */
tsickle_declare_module.paper.Segment.prototype.isColinear = function(segment) {};

/**
 * Returns true if the segment at the given index is the beginning of an orthogonal arc segment. The code looks at the length of the handles and their relation to the distance to the imaginary corner point. If the relation is kappa, then it's an arc.
 * @return {boolean}
 */
tsickle_declare_module.paper.Segment.prototype.isArc = function() {};

/**
 * Returns the reversed the segment, without modifying the segment itself.
 * @return {!Segment}
 */
tsickle_declare_module.paper.Segment.prototype.reverse = function() {};

/**
 * Removes the segment from the path that it belongs to.
 * @return {boolean}
 */
tsickle_declare_module.paper.Segment.prototype.remove = function() {};

/**
 * A string representation of the segment
 * @return {string}
 */
tsickle_declare_module.paper.Segment.prototype.toString = function() {};

/**
 * Transform the segment by the specified matrix.
 * @param {!Matrix} matrix - the matrix to transform the segment by
 * @return {void}
 */
tsickle_declare_module.paper.Segment.prototype.transform = function(matrix) {};

/**
 * @constructor
 * @struct
 * Creates a new curve object.
 * Creates a new curve object.
 * @param {!Segment|!Point} segment1_or_point1 -
 * @param {!Segment|!Point} segment2_or_handle1 -
 * @param {!Point=} handle2
 * @param {!Point=} point2
 */
tsickle_declare_module.paper.Curve = function(segment1_or_point1, segment2_or_handle1, handle2, point2) {};
 /** @type {!Point} */
tsickle_declare_module.paper.Curve.prototype.point1;
 /** @type {!Point} */
tsickle_declare_module.paper.Curve.prototype.point2;
 /** @type {!Point} */
tsickle_declare_module.paper.Curve.prototype.handle1;
 /** @type {!Point} */
tsickle_declare_module.paper.Curve.prototype.handle2;
 /** @type {!Segment} */
tsickle_declare_module.paper.Curve.prototype.segment1;
 /** @type {!Segment} */
tsickle_declare_module.paper.Curve.prototype.segment2;
 /** @type {!Path} */
tsickle_declare_module.paper.Curve.prototype.path;
 /** @type {number} */
tsickle_declare_module.paper.Curve.prototype.index;
 /** @type {!Curve} */
tsickle_declare_module.paper.Curve.prototype.next;
 /** @type {!Curve} */
tsickle_declare_module.paper.Curve.prototype.previous;
 /** @type {boolean} */
tsickle_declare_module.paper.Curve.prototype.selected;
 /** @type {number} */
tsickle_declare_module.paper.Curve.prototype.length;
 /** @type {!Rectangle} */
tsickle_declare_module.paper.Curve.prototype.bounds;
 /** @type {!Rectangle} */
tsickle_declare_module.paper.Curve.prototype.strokeBounds;
 /** @type {!Rectangle} */
tsickle_declare_module.paper.Curve.prototype.handleBounds;

/**
 * Checks if this curve is linear, meaning it does not define any curve handle.
 * @return {boolean}
 */
tsickle_declare_module.paper.Curve.prototype.isLinear = function() {};

/**
 * Divides the curve into two curves at the given offset. The curve itself is modified and becomes the first part, the second part is returned as a new curve. If the modified curve belongs to a path item, the second part is also added to the path.
 * @param {number=} offset [optional] - the offset on the curve at which to split, or the curve time parameter if isParameter is true  default: 0.5
 * @param {boolean=} isParameter [optional] - pass true if offset is a curve time parameter. default: false
 * @return {!Curve}
 */
tsickle_declare_module.paper.Curve.prototype.divide = function(offset, isParameter) {};

/**
 * Splits the path this curve belongs to at the given offset. After splitting, the path will be open. If the path was open already, splitting will result in two paths.
 * @param {number=} offset [optional] - the offset on the curve at which to split, or the curve time parameter if isParameter is true default: 0.5
 * @param {boolean=} isParameter [optional] - pass true if offset is a curve time parameter. default: false
 * @return {!Path}
 */
tsickle_declare_module.paper.Curve.prototype.split = function(offset, isParameter) {};

/**
 * Returns a reversed version of the curve, without modifying the curve itself.
 * @return {!Curve}
 */
tsickle_declare_module.paper.Curve.prototype.reverse = function() {};

/**
 * Removes the curve from the path that it belongs to, by merging its two path segments.
 * returns true if the curve was removed, false otherwise
 * @return {boolean}
 */
tsickle_declare_module.paper.Curve.prototype.remove = function() {};

/**
 * Returns a copy of the curve.
 * @return {!Curve}
 */
tsickle_declare_module.paper.Curve.prototype.clone = function() {};

/**
 * returns a string representation of the curve
 * @return {string}
 */
tsickle_declare_module.paper.Curve.prototype.toString = function() {};

/**
 * Calculates the curve time parameter of the specified offset on the path, relative to the provided start parameter. If offset is a negative value, the parameter is searched to the left of the start parameter. If no start parameter is provided, a default of 0 for positive values of offset and 1 for negative values of offset.
 * @param {!Point} offset -
 * @param {number=} start [optional] -
 * @return {number}
 */
tsickle_declare_module.paper.Curve.prototype.getParameterAt = function(offset, start) {};

/**
 * Returns the curve time parameter of the specified point if it lies on the curve, null otherwise.
 * @param {!Point} point - the point on the curve.
 * @return {number}
 */
tsickle_declare_module.paper.Curve.prototype.getParameterOf = function(point) {};

/**
 * Calculates the curve location at the specified offset or curve time parameter.
 * @param {!Point} offset - the offset on the curve, or the curve time parameter if isParameter is true
 * @param {boolean=} isParameter [optional] - pass true if offset is a curve time parameter.  default: false
 * @return {!CurveLocation}
 */
tsickle_declare_module.paper.Curve.prototype.getLocationAt = function(offset, isParameter) {};

/**
 * Returns the curve location of the specified point if it lies on the curve, null otherwise.
 * @param {!Point} point - the point on the curve
 * @return {!CurveLocation}
 */
tsickle_declare_module.paper.Curve.prototype.getLocationOf = function(point) {};

/**
 * Returns the length of the path from its beginning up to up to the specified point if it lies on the path, null otherwise.
 * @param {!Point} point - the point on the path.
 * @return {number}
 */
tsickle_declare_module.paper.Curve.prototype.getOffsetOf = function(point) {};

/**
 * Calculates the point on the curve at the given offset.
 * @param {number} offset - the offset on the curve, or the curve time parameter if isParameter is true
 * @param {boolean=} isParameter [optional] - pass true if offset is a curve time parameter. default: false
 * @return {!Point}
 */
tsickle_declare_module.paper.Curve.prototype.getPointAt = function(offset, isParameter) {};

/**
 * Calculates the tangent vector of the curve at the given offset.
 * @param {number} offset - the offset on the curve, or the curve time parameter if isParameter is true
 * @param {boolean=} isParameter [optional] - pass true if offset is a curve time parameter. default: false
 * @return {!Point}
 */
tsickle_declare_module.paper.Curve.prototype.getTangentAt = function(offset, isParameter) {};

/**
 * Calculates the normal vector of the curve at the given offset.
 * @param {number} offset - the offset on the curve, or the curve time parameter if isParameter is true
 * @param {boolean=} isParameter [optional] - pass true if offset is a curve time parameter. default: false
 * @return {!Point}
 */
tsickle_declare_module.paper.Curve.prototype.getNormalAt = function(offset, isParameter) {};

/**
 * Calculates the curvature of the curve at the given offset. Curvatures indicate how sharply a curve changes direction. A straight line has zero curvature, where as a circle has a constant curvature. The curve's radius at the given offset is the reciprocal value of its curvature.
 * @param {number} offset - the offset on the curve, or the curve time parameter if isParameter is true
 * @param {boolean=} isParameter - pass true if offset is a curve time parameter. default: false
 * @return {!Point}
 */
tsickle_declare_module.paper.Curve.prototype.getCurvatureAt = function(offset, isParameter) {};

/**
 * @constructor
 * @struct
 * Creates a new CurveLocation object.
 * @param {!Curve} curve -
 * @param {number} parameter -
 * @param {!Point} point -
 */
tsickle_declare_module.paper.CurveLocation = function(curve, parameter, point) {};
 /** @type {!Segment} */
tsickle_declare_module.paper.CurveLocation.prototype.segment;
 /** @type {!Curve} */
tsickle_declare_module.paper.CurveLocation.prototype.curve;
 /** @type {!CurveLocation} */
tsickle_declare_module.paper.CurveLocation.prototype.intersection;
 /** @type {!Path} */
tsickle_declare_module.paper.CurveLocation.prototype.path;
 /** @type {number} */
tsickle_declare_module.paper.CurveLocation.prototype.index;
 /** @type {number} */
tsickle_declare_module.paper.CurveLocation.prototype.offset;
 /** @type {number} */
tsickle_declare_module.paper.CurveLocation.prototype.curveOffset;
 /** @type {number} */
tsickle_declare_module.paper.CurveLocation.prototype.parameter;
 /** @type {!Point} */
tsickle_declare_module.paper.CurveLocation.prototype.point;
 /** @type {number} */
tsickle_declare_module.paper.CurveLocation.prototype.distance;

/**
 * Checks whether tow CurveLocation objects are describing the same location on a path, by applying the same tolerances as elsewhere when dealing with curve time parameters.
 * @param {!CurveLocation} location CurveLocation
 * @return {boolean}
 */
tsickle_declare_module.paper.CurveLocation.prototype.equals = function(location) {};

/**
 * Returns a string representation of the curve location
 * @return {string}
 */
tsickle_declare_module.paper.CurveLocation.prototype.toString = function() {};

/**
 * @constructor
 * @struct
 * Creates a Paper.js project containing one empty Layer, referenced by project.activeLayer.
 * @param {(string|!HTMLCanvasElement)} element - the HTML canvas element that should be used as the element for the view, or an ID string by which to find the element.
 */
tsickle_declare_module.paper.Project = function(element) {};
 /** @type {!View} */
tsickle_declare_module.paper.Project.prototype.view;
 /** @type {!Style} */
tsickle_declare_module.paper.Project.prototype.currentStyle;
 /** @type {number} */
tsickle_declare_module.paper.Project.prototype.index;
 /** @type {!Array<!Layer>} */
tsickle_declare_module.paper.Project.prototype.layers;
 /** @type {!Layer} */
tsickle_declare_module.paper.Project.prototype.activeLayer;
 /** @type {!Array<!Symbol>} */
tsickle_declare_module.paper.Project.prototype.symbols;

/**
 * Activates this project, so all newly created items will be placed in it.
 * @return {void}
 */
tsickle_declare_module.paper.Project.prototype.activate = function() {};

/**
 * Clears the project by removing all project.layers and project.symbols.
 * @return {void}
 */
tsickle_declare_module.paper.Project.prototype.clear = function() {};

/**
 * Checks whether the project has any content or not.
 * @return {boolean}
 */
tsickle_declare_module.paper.Project.prototype.isEmpty = function() {};

/**
 * Removes this project from the paperScope.projects list, and also removes its view, if one was defined.
 * @return {void}
 */
tsickle_declare_module.paper.Project.prototype.remove = function() {};

/**
 * Selects all items in the project.
 * @return {void}
 */
tsickle_declare_module.paper.Project.prototype.selectAll = function() {};

/**
 * Deselects all selected items in the project.
 * @return {void}
 */
tsickle_declare_module.paper.Project.prototype.deselectAll = function() {};

/**
 * Perform a hit-test on the items contained within the project at the location of the specified point.
 * The options object allows you to control the specifics of the hit-test and may contain a combination of the following values:
 * @param {!Point} point - the point where the hit-test should be performed
 * @param {{tolerance: number, class: string, fill: boolean, stroke: boolean, segments: boolean, curves: boolean, handles: boolean, ends: boolean, bounds: boolean, center: boolean, guides: boolean, selected: boolean}=} options
 * @return {!HitResult}
 */
tsickle_declare_module.paper.Project.prototype.hitTest = function(point, options) {};

/**
 * Fetch items contained within the project whose properties match the criteria in the specified object.
 * Extended matching is possible by providing a compare function or regular expression. Matching points, colors only work as a comparison of the full object, not partial matching (e.g. only providing the x- coordinate to match all points with that x-value). Partial matching does work for item.data.
 * Matching items against a rectangular area is also possible, by setting either match.inside or match.overlapping to a rectangle describing the area in which the items either have to be fully or partly contained.
 * @param {?} match
 * @return {!Array<!Item>}
 */
tsickle_declare_module.paper.Project.prototype.getItems = function(match) {};

/**
 * Fetch the first item contained within the project whose properties match the criteria in the specified object.
 * Extended matching is possible by providing a compare function or regular expression. Matching points, colors only work as a comparison of the full object, not partial matching (e.g. only providing the x- coordinate to match all points with that x-value). Partial matching does work for item.data.
 * @param {?} match
 * @return {!Item}
 */
tsickle_declare_module.paper.Project.prototype.getItem = function(match) {};

/**
 * Exports (serializes) the project with all its layers and child items to a JSON data string.
 * @param {{asString: boolean, precision: number}=} options [optional] - default {asString: true, precision: 5}
 * @return {string}
 */
tsickle_declare_module.paper.Project.prototype.exportJSON = function(options) {};

/**
 * Imports (deserializes) the stored JSON data into the project.
 * Note that the project is not cleared first. You can call project.clear() to do so.
 * @param {string} json
 * @return {void}
 */
tsickle_declare_module.paper.Project.prototype.importJSON = function(json) {};

/**
 * Exports the project with all its layers and child items as an SVG DOM, all contained in one top level SVG group node.
 * @param {{asString: boolean, precision: number, matchShapes: boolean}=} options [optional] the export options, default: { asString: false, precision: 5, matchShapes: false }
 * @return {!SVGElement}
 */
tsickle_declare_module.paper.Project.prototype.exportSVG = function(options) {};

/**
 * Converts the provided SVG content into Paper.js items and adds them to the active layer of this project.
 * Note that the project is not cleared first. You can call project.clear() to do so.
 * @param {(string|!SVGElement)} svg - the SVG content to import
 * @param {?=} options [optional] - the import options, default: { expandShapes: false }
 * @return {!Item}
 */
tsickle_declare_module.paper.Project.prototype.importSVG = function(svg, options) {};

/**
 * @constructor
 * @struct
 * Creates a Symbol item.
 * @param {!Item} item - the source item which is copied as the definition of the symbol
 * @param {boolean=} dontCenter [optional] - default: false
 */
tsickle_declare_module.paper.Symbol = function(item, dontCenter) {};
 /** @type {!Project} */
tsickle_declare_module.paper.Symbol.prototype.project;
 /** @type {!Item} */
tsickle_declare_module.paper.Symbol.prototype.definition;

/**
 * Places in instance of the symbol in the project.
 * @param {!Point=} position [optional] - The position of the placed symbol.
 * @return {!PlacedSymbol}
 */
tsickle_declare_module.paper.Symbol.prototype.place = function(position) {};

/**
 * Returns a copy of the symbol.
 * @return {!Symbol}
 */
tsickle_declare_module.paper.Symbol.prototype.clone = function() {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.Style = function() {};
 /** @type {!View} */
tsickle_declare_module.paper.Style.prototype.view;
 /** @type {(string|!Color)} */
tsickle_declare_module.paper.Style.prototype.strokeColor;
 /** @type {number} */
tsickle_declare_module.paper.Style.prototype.strokeWidth;
 /** @type {string} */
tsickle_declare_module.paper.Style.prototype.strokeCap;
 /** @type {string} */
tsickle_declare_module.paper.Style.prototype.strokeJoin;
 /** @type {boolean} */
tsickle_declare_module.paper.Style.prototype.strokeScaling;
 /** @type {number} */
tsickle_declare_module.paper.Style.prototype.dashOffset;
 /** @type {!Array<number>} */
tsickle_declare_module.paper.Style.prototype.dashArray;
 /** @type {number} */
tsickle_declare_module.paper.Style.prototype.miterLimit;
 /** @type {(string|!Color)} */
tsickle_declare_module.paper.Style.prototype.fillColor;
 /** @type {(string|!Color)} */
tsickle_declare_module.paper.Style.prototype.shadowColor;
 /** @type {number} */
tsickle_declare_module.paper.Style.prototype.shadowBlur;
 /** @type {!Point} */
tsickle_declare_module.paper.Style.prototype.shadowOffset;
 /** @type {(string|!Color)} */
tsickle_declare_module.paper.Style.prototype.selectedColor;
 /** @type {string} */
tsickle_declare_module.paper.Style.prototype.fontFamily;
 /** @type {(string|number)} */
tsickle_declare_module.paper.Style.prototype.fontWeight;
 /** @type {(string|number)} */
tsickle_declare_module.paper.Style.prototype.fontSize;
 /** @type {(string|number)} */
tsickle_declare_module.paper.Style.prototype.leading;
 /** @type {string} */
tsickle_declare_module.paper.Style.prototype.justification;
/**
 * @record
 * @struct
 */
tsickle_declare_module.paper.IHSBColor = function() {};
 /** @type {number} */
tsickle_declare_module.paper.IHSBColor.prototype.hue;
 /** @type {number} */
tsickle_declare_module.paper.IHSBColor.prototype.saturation;
 /** @type {number} */
tsickle_declare_module.paper.IHSBColor.prototype.brightness;
 /** @type {number} */
tsickle_declare_module.paper.IHSBColor.prototype.alpha;
/**
 * @record
 * @struct
 */
tsickle_declare_module.paper.IHSLColor = function() {};
 /** @type {number} */
tsickle_declare_module.paper.IHSLColor.prototype.hue;
 /** @type {number} */
tsickle_declare_module.paper.IHSLColor.prototype.saturation;
 /** @type {number} */
tsickle_declare_module.paper.IHSLColor.prototype.lightness;
 /** @type {number} */
tsickle_declare_module.paper.IHSLColor.prototype.alpha;
/**
 * @record
 * @struct
 */
tsickle_declare_module.paper.IGradientColor = function() {};
 /** @type {!Gradient} */
tsickle_declare_module.paper.IGradientColor.prototype.gradient;
 /** @type {!Point} */
tsickle_declare_module.paper.IGradientColor.prototype.origin;
 /** @type {!Point} */
tsickle_declare_module.paper.IGradientColor.prototype.destination;
 /** @type {boolean} */
tsickle_declare_module.paper.IGradientColor.prototype.radial;

/**
 * @constructor
 * @struct
 * Creates a RGB Color object.
 * Creates a gray Color object.
 * Creates a HSB, HSL or gradient Color object from the properties of the provided object:
 * Creates a gradient Color object.
 * Creates a RGB Color object.
 * @param {number|(!IHSBColor|!IHSLColor|!IGradientColor)|!Gradient|string} red_or_gray_or_object_or_color_or_hex - the amount of red in the color as a value between 0 and 1 / - the amount of gray in the color as a value between 0 and 1 / - an object describing the components and properties of the color. / - the RGB color in hex, i.e. #000000
 * @param {number|!Point=} green_or_alpha_or_origin - the amount of green in the color as a value between 0 and 1 / [optional] - the alpha of the color as a value between 0 and 1 / -
 * @param {number|!Point=} blue_or_destination - the amount of blue in the color as a value between 0 and 1 / -
 * @param {number|!Point=} alpha_or_highlight [optional] - the alpha of the color as a value between 0 and 1 / [optional] -
 */
tsickle_declare_module.paper.Color = function(red_or_gray_or_object_or_color_or_hex, green_or_alpha_or_origin, blue_or_destination, alpha_or_highlight) {};
 /** @type {string} */
tsickle_declare_module.paper.Color.prototype.type;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.components;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.alpha;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.red;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.green;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.blue;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.gray;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.hue;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.saturation;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.brightness;
 /** @type {number} */
tsickle_declare_module.paper.Color.prototype.lightness;
 /** @type {!Gradient} */
tsickle_declare_module.paper.Color.prototype.gradient;
 /** @type {!Point} */
tsickle_declare_module.paper.Color.prototype.highlight;

/**
 * Converts the color another type.
 * @param {string} type - String('rgb'|'gray'|'hsb'|'hsl') the color type to convert to.
 * @return {!Color}
 */
tsickle_declare_module.paper.Color.prototype.convert = function(type) {};

/**
 * Checks if the color has an alpha value.
 * @return {boolean}
 */
tsickle_declare_module.paper.Color.prototype.hasAlpha = function() {};

/**
 * Checks if the component color values of the color are the same as those of the supplied one.
 * @param {!Color} color - the color to compare with
 * @return {boolean}
 */
tsickle_declare_module.paper.Color.prototype.equals = function(color) {};

/**
 * a copy of the color object
 * @return {!Color}
 */
tsickle_declare_module.paper.Color.prototype.clone = function() {};

/**
 * a string representation of the color
 * @return {string}
 */
tsickle_declare_module.paper.Color.prototype.toString = function() {};

/**
 * Returns the color as a CSS string.
 * @param {boolean} hex - whether to return the color in hexadecial representation or as a CSS RGB / RGBA string.
 * @return {string}
 */
tsickle_declare_module.paper.Color.prototype.toCSS = function(hex) {};

/**
 * Transform the gradient color by the specified matrix.
 * @param {!Matrix} matrix - the matrix to transform the gradient color by
 * @return {void}
 */
tsickle_declare_module.paper.Color.prototype.transform = function(matrix) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.Gradient = function() {};
 /** @type {!Array<!GradientStop>} */
tsickle_declare_module.paper.Gradient.prototype.stops;
 /** @type {boolean} */
tsickle_declare_module.paper.Gradient.prototype.radial;

/**
 * a copy of the gradient
 * @return {!Gradient}
 */
tsickle_declare_module.paper.Gradient.prototype.clone = function() {};

/**
 * Checks whether the gradient is equal to the supplied gradient.
 * @param {!Gradient} gradient - the gradient to check against
 * @return {boolean}
 */
tsickle_declare_module.paper.Gradient.prototype.equals = function(gradient) {};

/**
 * @constructor
 * @struct
 * Creates a GradientStop object.
 * @param {!Color=} color [optional] - the color of the stop, default: new Color(0, 0, 0)
 * @param {number=} rampPoint [optional] - the position of the stop on the gradient ramp as a value between 0 and 1, default: 0
 */
tsickle_declare_module.paper.GradientStop = function(color, rampPoint) {};
 /** @type {number} */
tsickle_declare_module.paper.GradientStop.prototype.rampPoint;
 /** @type {!Color} */
tsickle_declare_module.paper.GradientStop.prototype.color;

/**
 * Returns a copy of the gradient-stop
 * @return {!GradientStop}
 */
tsickle_declare_module.paper.GradientStop.prototype.clone = function() {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.View = function() {};
 /** @type {!HTMLCanvasElement} */
tsickle_declare_module.paper.View.prototype.element;
 /** @type {number} */
tsickle_declare_module.paper.View.prototype.pixelRatio;
 /** @type {number} */
tsickle_declare_module.paper.View.prototype.resolution;
 /** @type {!Size} */
tsickle_declare_module.paper.View.prototype.viewSize;
 /** @type {!Rectangle} */
tsickle_declare_module.paper.View.prototype.bounds;
 /** @type {!Size} */
tsickle_declare_module.paper.View.prototype.size;
 /** @type {!Point} */
tsickle_declare_module.paper.View.prototype.center;
 /** @type {number} */
tsickle_declare_module.paper.View.prototype.zoom;
 /** @type {function(!IFrameEvent): void} */
tsickle_declare_module.paper.View.prototype.onFrame;
 /** @type {function(!Event): void} */
tsickle_declare_module.paper.View.prototype.onResize;

/**
 * Removes this view from the project and frees the associated element.
 * @return {void}
 */
tsickle_declare_module.paper.View.prototype.remove = function() {};

/**
 * Checks whether the view is currently visible within the current browser viewport.
 * @return {boolean}
 */
tsickle_declare_module.paper.View.prototype.isVisible = function() {};

/**
 * Scrolls the view by the given vector.
 * @param {!Point} point - the vector to scroll by
 * @return {void}
 */
tsickle_declare_module.paper.View.prototype.scrollBy = function(point) {};

/**
 * Makes all animation play by adding the view to the request animation loop.
 * @return {void}
 */
tsickle_declare_module.paper.View.prototype.play = function() {};

/**
 * Makes all animation pause by removing the view to the request animation loop.
 * @return {void}
 */
tsickle_declare_module.paper.View.prototype.pause = function() {};

/**
 * Updates the view if there are changes. Note that when using built-in event hanlders for interaction, animation and load events, this method is invoked for you automatically at the end.
 * @return {void}
 */
tsickle_declare_module.paper.View.prototype.update = function() {};

/**
 *
 * @param {!Point} point -
 * @return {!Point}
 */
tsickle_declare_module.paper.View.prototype.projectToView = function(point) {};

/**
 *
 * @param {!Point} point -
 * @return {!Point}
 */
tsickle_declare_module.paper.View.prototype.viewToProject = function(point) {};

/**
 * Attach an event handler to the view.
 * Attach one or more event handlers to the view.
 * @param {string|?} type_or_param - String('frame'|'resize') the event type
 * @param {function(!Event): void=} callback
 * @return {!Item}
 */
tsickle_declare_module.paper.View.prototype.on = function(type_or_param, callback) {};

/**
 * Detach an event handler from the view.
 * Detach one or more event handlers from the view.
 * @param {string|?} type_or_param - String('frame'|'resize') the event type / -  an object literal containing one or more of the following properties: frame, resize
 * @param {function(!Event): void=} callback
 * @return {!Item}
 */
tsickle_declare_module.paper.View.prototype.off = function(type_or_param, callback) {};

/**
 * Emit an event on the view.
 * @param {string} type - String('frame'|'resize') the event type
 * @param {?} event - an object literal containing properties describing the event.
 * @return {boolean}
 */
tsickle_declare_module.paper.View.prototype.emit = function(type, event) {};

/**
 * Check if the view has one or more event handlers of the specified type.
 * @param {string} type - String('frame'|'resize') the event type
 * @return {boolean}
 */
tsickle_declare_module.paper.View.prototype.responds = function(type) {};

/**
 * Draws the view when using paper.js directly in JavaScript
 * @return {void}
 */
tsickle_declare_module.paper.View.prototype.draw = function() {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.Tool = function() {};
 /** @type {number} */
tsickle_declare_module.paper.Tool.prototype.minDistance;
 /** @type {number} */
tsickle_declare_module.paper.Tool.prototype.maxDistance;
 /** @type {number} */
tsickle_declare_module.paper.Tool.prototype.fixedDistance;
 /** @type {function(!ToolEvent): void} */
tsickle_declare_module.paper.Tool.prototype.onMouseDown;
 /** @type {function(!ToolEvent): void} */
tsickle_declare_module.paper.Tool.prototype.onMouseDrag;
 /** @type {function(!ToolEvent): void} */
tsickle_declare_module.paper.Tool.prototype.onMouseMove;
 /** @type {function(!ToolEvent): void} */
tsickle_declare_module.paper.Tool.prototype.onMouseUp;
 /** @type {function(!KeyEvent): void} */
tsickle_declare_module.paper.Tool.prototype.onKeyDown;
 /** @type {function(!KeyEvent): void} */
tsickle_declare_module.paper.Tool.prototype.onKeyUp;

/**
 * Activates this tool, meaning paperScope.tool will point to it and it will be the one that recieves mouse events.
 * @return {void}
 */
tsickle_declare_module.paper.Tool.prototype.activate = function() {};

/**
 * Removes this tool from the paperScope.tools list.
 * @return {void}
 */
tsickle_declare_module.paper.Tool.prototype.remove = function() {};

/**
 * Attach an event handler to the tool.
 * Attach one or more event handlers to the tool.
 * @param {string|?} type_or_param - String('mousedown'|'mouseup'|'mousedrag'|'mousemove'|'keydown'|'keyup') the event type / - an object literal containing one or more of the following properties: mousedown, mouseup, mousedrag, mousemove, keydown, keyup
 * @param {function(!ToolEvent): void=} callback
 * @return {!Tool}
 */
tsickle_declare_module.paper.Tool.prototype.on = function(type_or_param, callback) {};

/**
 * Detach an event handler from the tool.
 * Detach one or more event handlers from the tool.
 * @param {string|?} type_or_param - String('mousedown'|'mouseup'|'mousedrag'|'mousemove'|'keydown'|'keyup') the event type / -  an object literal containing one or more of the following properties: mousedown, mouseup, mousedrag, mousemove, keydown, keyup
 * @param {function(!ToolEvent): void=} callback
 * @return {!Tool}
 */
tsickle_declare_module.paper.Tool.prototype.off = function(type_or_param, callback) {};

/**
 * Emit an event on the tool.
 * @param {string} type - String('mousedown'|'mouseup'|'mousedrag'|'mousemove'|'keydown'|'keyup') the event type
 * @param {?} event - an object literal containing properties describing the event.
 * @return {boolean}
 */
tsickle_declare_module.paper.Tool.prototype.emit = function(type, event) {};

/**
 * Check if the tool has one or more event handlers of the specified type.
 * @param {string} type - String('mousedown'|'mouseup'|'mousedrag'|'mousemove'|'keydown'|'keyup') the event type
 * @return {boolean}
 */
tsickle_declare_module.paper.Tool.prototype.responds = function(type) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.Event = function() {};
 /** @type {?} */
tsickle_declare_module.paper.Event.prototype.modifiers;
/**
 * @extends {Event}
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.ToolEvent = function() {};
 /** @type {string} */
tsickle_declare_module.paper.ToolEvent.prototype.type;
 /** @type {!Point} */
tsickle_declare_module.paper.ToolEvent.prototype.point;
 /** @type {!Point} */
tsickle_declare_module.paper.ToolEvent.prototype.lastPoint;
 /** @type {!Point} */
tsickle_declare_module.paper.ToolEvent.prototype.downPoint;
 /** @type {!Point} */
tsickle_declare_module.paper.ToolEvent.prototype.middlePoint;
 /** @type {!Point} */
tsickle_declare_module.paper.ToolEvent.prototype.delta;
 /** @type {number} */
tsickle_declare_module.paper.ToolEvent.prototype.count;
 /** @type {!Item} */
tsickle_declare_module.paper.ToolEvent.prototype.item;

/**
 * a string representation of the tool event
 * @return {string}
 */
tsickle_declare_module.paper.ToolEvent.prototype.toString = function() {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.Key = function() {};

/**
 * Checks whether the specified key is pressed.
 * @param {string} key - One of: 'backspace', 'enter', 'shift', 'control', 'option', 'pause', 'caps-lock', 'escape', 'space', 'end', 'home', 'left', 'up', 'right', 'down', 'delete', 'command'
 * @return {boolean}
 */
tsickle_declare_module.paper.Key.isDown = function(key) {};
/**
 * @extends {Event}
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.KeyEvent = function() {};
 /** @type {string} */
tsickle_declare_module.paper.KeyEvent.prototype.type;
 /** @type {string} */
tsickle_declare_module.paper.KeyEvent.prototype.character;
 /** @type {string} */
tsickle_declare_module.paper.KeyEvent.prototype.key;

/**
 * a string representation of the key event
 * @return {string}
 */
tsickle_declare_module.paper.KeyEvent.prototype.toString = function() {};
/**
 * @extends {Item}
 * @constructor
 * @struct
 */
tsickle_declare_module.paper.TextItem = function() {};
 /** @type {string} */
tsickle_declare_module.paper.TextItem.prototype.content;
 /** @type {string} */
tsickle_declare_module.paper.TextItem.prototype.fontFamily;
 /** @type {(string|number)} */
tsickle_declare_module.paper.TextItem.prototype.fontWeight;
 /** @type {(string|number)} */
tsickle_declare_module.paper.TextItem.prototype.fontSize;
 /** @type {(string|number)} */
tsickle_declare_module.paper.TextItem.prototype.leading;
 /** @type {string} */
tsickle_declare_module.paper.TextItem.prototype.justification;

/**
 * @constructor
 * @struct
 * Creates a point text item
 * Creates a point text item from the properties described by an object literal.
 * @param {!Point|?} point_or_object - the position where the text will start / - an object literal containing properties describing the path's attributes
 */
tsickle_declare_module.paper.PointText = function(point_or_object) {};
 /** @type {!Point} */
tsickle_declare_module.paper.PointText.prototype.point;

/**
 * @constructor
 * @struct
 * @param {string} type
 * @param {!MouseEvent} event
 * @param {!Point} point
 * @param {!Item} target
 * @param {!Point} delta
 */
tsickle_declare_module.paper.MouseEvent = function(type, event, point, target, delta) {};
 /** @type {!MouseEvent} */
tsickle_declare_module.paper.MouseEvent.prototype.event;
 /** @type {!Point} */
tsickle_declare_module.paper.MouseEvent.prototype.point;
 /** @type {!Point} */
tsickle_declare_module.paper.MouseEvent.prototype.lastPoint;
 /** @type {!Point} */
tsickle_declare_module.paper.MouseEvent.prototype.delta;
 /** @type {!Item} */
tsickle_declare_module.paper.MouseEvent.prototype.target;
 /** @type {!Item} */
tsickle_declare_module.paper.MouseEvent.prototype.currentTarget;
 /** @type {string} */
tsickle_declare_module.paper.MouseEvent.prototype.type;

/**
 * The time at which the event was created, in milliseconds since the
 * epoch.
 * @return {number}
 */
tsickle_declare_module.paper.MouseEvent.prototype.timeStamp = function() {};

/**
 * Cancels the event if it is cancelable, without stopping further
 * propagation of the event.
 * @return {void}
 */
tsickle_declare_module.paper.MouseEvent.prototype.preventDefault = function() {};

/**
 * Prevents further propagation of the current event.
 * @return {void}
 */
tsickle_declare_module.paper.MouseEvent.prototype.stopPropagation = function() {};

/**
 * Cancels the event if it is cancelable, and stops stopping further
 * propagation of the event. This is has the same effect as calling
 * both stopPropagation() and preventDefault().
 * 
 * Any handler can also return false to indicate that stop() should be
 * called right after.
 * @return {void}
 */
tsickle_declare_module.paper.MouseEvent.prototype.stop = function() {};
