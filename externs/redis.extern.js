/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/redis/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */
/**
 * @record
 * @struct
 */
function RetryStrategyOptions() {}
 /** @type {!Error} */
RetryStrategyOptions.prototype.error;
 /** @type {number} */
RetryStrategyOptions.prototype.total_retry_time;
 /** @type {number} */
RetryStrategyOptions.prototype.times_connected;
 /** @type {number} */
RetryStrategyOptions.prototype.attempt;
/**
 * @record
 * @struct
 */
function RetryStrategy() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ClientOpts() {}
 /** @type {string} */
ClientOpts.prototype.host;
 /** @type {number} */
ClientOpts.prototype.port;
 /** @type {string} */
ClientOpts.prototype.path;
 /** @type {string} */
ClientOpts.prototype.url;
 /** @type {string} */
ClientOpts.prototype.parser;
 /** @type {boolean} */
ClientOpts.prototype.string_numbers;
 /** @type {boolean} */
ClientOpts.prototype.return_buffers;
 /** @type {boolean} */
ClientOpts.prototype.detect_buffers;
 /** @type {boolean} */
ClientOpts.prototype.socket_keepalive;
 /** @type {boolean} */
ClientOpts.prototype.no_ready_check;
 /** @type {boolean} */
ClientOpts.prototype.enable_offline_queue;
 /** @type {number} */
ClientOpts.prototype.retry_max_delay;
 /** @type {number} */
ClientOpts.prototype.connect_timeout;
 /** @type {number} */
ClientOpts.prototype.max_attempts;
 /** @type {boolean} */
ClientOpts.prototype.retry_unfulfilled_commands;
 /** @type {string} */
ClientOpts.prototype.auth_pass;
 /** @type {string} */
ClientOpts.prototype.password;
 /** @type {string} */
ClientOpts.prototype.db;
 /** @type {string} */
ClientOpts.prototype.family;
 /** @type {?} */
ClientOpts.prototype.rename_commands;
 /** @type {?} */
ClientOpts.prototype.tls;
 /** @type {string} */
ClientOpts.prototype.prefix;
 /** @type {?} */
ClientOpts.prototype.retry_strategy;
/**
 * @record
 * @struct
 */
function Callback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ServerInfo() {}
 /** @type {string} */
ServerInfo.prototype.redis_version;
 /** @type {!Array<number>} */
ServerInfo.prototype.versions;
/**
 * @record
 * @struct
 */
function OverloadedCommand() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function OverloadedKeyCommand() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function OverloadedListCommand() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function OverloadedSetCommand() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function OverloadedLastCommand() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function Commands() {}
 /** @type {?} */
Commands.prototype.client;
 /** @type {?} */
Commands.prototype.CLIENT;
 /** @type {?} */
Commands.prototype.hmset;
 /** @type {?} */
Commands.prototype.HMSET;
 /** @type {?} */
Commands.prototype.subscribe;
 /** @type {?} */
Commands.prototype.SUBSCRIBE;
 /** @type {?} */
Commands.prototype.unsubscribe;
 /** @type {?} */
Commands.prototype.UNSUBSCRIBE;
 /** @type {?} */
Commands.prototype.psubscribe;
 /** @type {?} */
Commands.prototype.PSUBSCRIBE;
 /** @type {?} */
Commands.prototype.punsubscribe;
 /** @type {?} */
Commands.prototype.PUNSUBSCRIBE;
 /** @type {?} */
Commands.prototype.bitfield;
 /** @type {?} */
Commands.prototype.BITFIELD;
 /** @type {?} */
Commands.prototype.blpop;
 /** @type {?} */
Commands.prototype.BLPOP;
 /** @type {?} */
Commands.prototype.brpop;
 /** @type {?} */
Commands.prototype.BRPOP;
 /** @type {?} */
Commands.prototype.cluster;
 /** @type {?} */
Commands.prototype.CLUSTER;
 /** @type {?} */
Commands.prototype.config;
 /** @type {?} */
Commands.prototype.CONFIG;
 /** @type {?} */
Commands.prototype.debug;
 /** @type {?} */
Commands.prototype.DEBUG;
 /** @type {?} */
Commands.prototype.del;
 /** @type {?} */
Commands.prototype.DEL;
 /** @type {?} */
Commands.prototype.eval;
 /** @type {?} */
Commands.prototype.EVAL;
 /** @type {?} */
Commands.prototype.evalsha;
 /** @type {?} */
Commands.prototype.EVALSHA;
 /** @type {?} */
Commands.prototype.exists;
 /** @type {?} */
Commands.prototype.EXISTS;
 /** @type {?} */
Commands.prototype.geoadd;
 /** @type {?} */
Commands.prototype.GEOADD;
 /** @type {?} */
Commands.prototype.geohash;
 /** @type {?} */
Commands.prototype.GEOHASH;
 /** @type {?} */
Commands.prototype.geopos;
 /** @type {?} */
Commands.prototype.GEOPOS;
 /** @type {?} */
Commands.prototype.geodist;
 /** @type {?} */
Commands.prototype.GEODIST;
 /** @type {?} */
Commands.prototype.georadius;
 /** @type {?} */
Commands.prototype.GEORADIUS;
 /** @type {?} */
Commands.prototype.georadiusbymember;
 /** @type {?} */
Commands.prototype.GEORADIUSBYMEMBER;
 /** @type {?} */
Commands.prototype.hdel;
 /** @type {?} */
Commands.prototype.HDEL;
 /** @type {?} */
Commands.prototype.hmget;
 /** @type {?} */
Commands.prototype.HMGET;
 /** @type {?} */
Commands.prototype.lpush;
 /** @type {?} */
Commands.prototype.LPUSH;
 /** @type {?} */
Commands.prototype.mget;
 /** @type {?} */
Commands.prototype.MGET;
 /** @type {?} */
Commands.prototype.migrate;
 /** @type {?} */
Commands.prototype.MIGRATE;
 /** @type {?} */
Commands.prototype.mset;
 /** @type {?} */
Commands.prototype.MSET;
 /** @type {?} */
Commands.prototype.msetnx;
 /** @type {?} */
Commands.prototype.MSETNX;
 /** @type {?} */
Commands.prototype.object;
 /** @type {?} */
Commands.prototype.OBJECT;
 /** @type {?} */
Commands.prototype.pfadd;
 /** @type {?} */
Commands.prototype.PFADD;
 /** @type {?} */
Commands.prototype.pfcount;
 /** @type {?} */
Commands.prototype.PFCOUNT;
 /** @type {?} */
Commands.prototype.pfmerge;
 /** @type {?} */
Commands.prototype.PFMERGE;
 /** @type {?} */
Commands.prototype.pubsub;
 /** @type {?} */
Commands.prototype.PUBSUB;
 /** @type {?} */
Commands.prototype.rpush;
 /** @type {?} */
Commands.prototype.RPUSH;
 /** @type {?} */
Commands.prototype.sadd;
 /** @type {?} */
Commands.prototype.SADD;
 /** @type {?} */
Commands.prototype.script;
 /** @type {?} */
Commands.prototype.SCRIPT;
 /** @type {?} */
Commands.prototype.sdiff;
 /** @type {?} */
Commands.prototype.SDIFF;
 /** @type {?} */
Commands.prototype.sdiffstore;
 /** @type {?} */
Commands.prototype.SDIFFSTORE;
 /** @type {?} */
Commands.prototype.shutdown;
 /** @type {?} */
Commands.prototype.SHUTDOWN;
 /** @type {?} */
Commands.prototype.sinter;
 /** @type {?} */
Commands.prototype.SINTER;
 /** @type {?} */
Commands.prototype.sinterstore;
 /** @type {?} */
Commands.prototype.SINTERSTORE;
 /** @type {?} */
Commands.prototype.slowlog;
 /** @type {?} */
Commands.prototype.SLOWLOG;
 /** @type {?} */
Commands.prototype.sort;
 /** @type {?} */
Commands.prototype.SORT;
 /** @type {?} */
Commands.prototype.srem;
 /** @type {?} */
Commands.prototype.SREM;
 /** @type {?} */
Commands.prototype.sunion;
 /** @type {?} */
Commands.prototype.SUNION;
 /** @type {?} */
Commands.prototype.sunionstore;
 /** @type {?} */
Commands.prototype.SUNIONSTORE;
 /** @type {?} */
Commands.prototype.watch;
 /** @type {?} */
Commands.prototype.WATCH;
 /** @type {?} */
Commands.prototype.zadd;
 /** @type {?} */
Commands.prototype.ZADD;
 /** @type {?} */
Commands.prototype.zinterstore;
 /** @type {?} */
Commands.prototype.ZINTERSTORE;
 /** @type {?} */
Commands.prototype.zrem;
 /** @type {?} */
Commands.prototype.ZREM;
 /** @type {?} */
Commands.prototype.zunionstore;
 /** @type {?} */
Commands.prototype.ZUNIONSTORE;
 /** @type {?} */
Commands.prototype.scan;
 /** @type {?} */
Commands.prototype.SCAN;
 /** @type {?} */
Commands.prototype.sscan;
 /** @type {?} */
Commands.prototype.SSCAN;
 /** @type {?} */
Commands.prototype.hscan;
 /** @type {?} */
Commands.prototype.HSCAN;
 /** @type {?} */
Commands.prototype.zscan;
 /** @type {?} */
Commands.prototype.ZSCAN;

/**
 * Listen for all requests received by the server in real time.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.monitor = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.MONITOR = function(cb) {};

/**
 * Get information and statistics about the server.
 * @param {?|(string|!Array<string>)=} cb_or_section
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.info = function(cb_or_section, cb) {};

/**
 * @param {?|(string|!Array<string>)=} cb_or_section
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.INFO = function(cb_or_section, cb) {};

/**
 * Ping the server.
 * @param {?|string=} callback_or_message
 * @param {?=} callback
 * @return {?}
 */
Commands.prototype.ping = function(callback_or_message, callback) {};

/**
 * Post a message to a channel.
 * @param {string} channel
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.publish = function(channel, value, cb) {};

/**
 * Authenticate to the server.
 * @param {string} password
 * @param {?=} callback
 * @return {?}
 */
Commands.prototype.auth = function(password, callback) {};

/**
 * @param {string} password
 * @param {?=} callback
 * @return {?}
 */
Commands.prototype.AUTH = function(password, callback) {};

/**
 * Append a value to a key.
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.append = function(key, value, cb) {};

/**
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.APPEND = function(key, value, cb) {};

/**
 * Asynchronously rewrite the append-only file.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.bgrewriteaof = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.BGREWRITEAOF = function(cb) {};

/**
 * Asynchronously save the dataset to disk.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.bgsave = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.BGSAVE = function(cb) {};

/**
 * Count set bits in a string.
 * @param {string} key
 * @param {?|number=} cb_or_start
 * @param {number=} end
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.bitcount = function(key, cb_or_start, end, cb) {};

/**
 * @param {string} key
 * @param {?|number=} cb_or_start
 * @param {number=} end
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.BITCOUNT = function(key, cb_or_start, end, cb) {};

/**
 * Perform bitwise operations between strings.
 * @param {string} operation
 * @param {string} destkey
 * @param {...string|(string|?)} key1_or_key_or_args
 * @return {?}
 */
Commands.prototype.bitop = function(operation, destkey, key1_or_key_or_args) {};

/**
 * @param {string} operation
 * @param {string} destkey
 * @param {...string|(string|?)} key1_or_key_or_args
 * @return {?}
 */
Commands.prototype.BITOP = function(operation, destkey, key1_or_key_or_args) {};

/**
 * Find first bit set or clear in a string.
 * @param {string} key
 * @param {number} bit
 * @param {number|?=} start_or_cb
 * @param {number|?=} end_or_cb
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.bitpos = function(key, bit, start_or_cb, end_or_cb, cb) {};

/**
 * @param {string} key
 * @param {number} bit
 * @param {number|?=} start_or_cb
 * @param {number|?=} end_or_cb
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.BITPOS = function(key, bit, start_or_cb, end_or_cb, cb) {};

/**
 * Pop a value from a list, push it to another list and return it; or block until one is available.
 * @param {string} source
 * @param {string} destination
 * @param {number} timeout
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.brpoplpush = function(source, destination, timeout, cb) {};

/**
 * @param {string} source
 * @param {string} destination
 * @param {number} timeout
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.BRPOPLPUSH = function(source, destination, timeout, cb) {};

/**
 * Get array of Redis command details.
 * 
 * COUNT - Get total number of Redis commands.
 * GETKEYS - Extract keys given a full Redis command.
 * INFO - Get array of specific REdis command details.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.command = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.COMMAND = function(cb) {};

/**
 * Return the number of keys in the selected database.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.dbsize = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.DBSIZE = function(cb) {};

/**
 * Decrement the integer value of a key by one.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.decr = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.DECR = function(key, cb) {};

/**
 * Decrement the integer value of a key by the given number.
 * @param {string} key
 * @param {number} decrement
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.decrby = function(key, decrement, cb) {};

/**
 * @param {string} key
 * @param {number} decrement
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.DECRBY = function(key, decrement, cb) {};

/**
 * Discard all commands issued after MULTI.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.discard = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.DISCARD = function(cb) {};

/**
 * Return a serialized version of the value stored at the specified key.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.dump = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.DUMP = function(key, cb) {};

/**
 * Echo the given string.
 * @template T
 * @param {?} message
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.echo = function(message, cb) {};

/**
 * @template T
 * @param {?} message
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ECHO = function(message, cb) {};

/**
 * Set a key's time to live in seconds.
 * @param {string} key
 * @param {number} seconds
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.expire = function(key, seconds, cb) {};

/**
 * @param {string} key
 * @param {number} seconds
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.EXPIRE = function(key, seconds, cb) {};

/**
 * Set the expiration for a key as a UNIX timestamp.
 * @param {string} key
 * @param {number} timestamp
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.expireat = function(key, timestamp, cb) {};

/**
 * @param {string} key
 * @param {number} timestamp
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.EXPIREAT = function(key, timestamp, cb) {};

/**
 * Remove all keys from all databases.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.flushall = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.FLUSHALL = function(cb) {};

/**
 * Remove all keys from the current database.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.flushdb = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.FLUSHDB = function(cb) {};

/**
 * Get the value of a key.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.get = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.GET = function(key, cb) {};

/**
 * Returns the bit value at offset in the string value stored at key.
 * @param {string} key
 * @param {number} offset
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.getbit = function(key, offset, cb) {};

/**
 * @param {string} key
 * @param {number} offset
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.GETBIT = function(key, offset, cb) {};

/**
 * Get a substring of the string stored at a key.
 * @param {string} key
 * @param {number} start
 * @param {number} end
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.getrange = function(key, start, end, cb) {};

/**
 * @param {string} key
 * @param {number} start
 * @param {number} end
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.GETRANGE = function(key, start, end, cb) {};

/**
 * Set the string value of a key and return its old value.
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.getset = function(key, value, cb) {};

/**
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.GETSET = function(key, value, cb) {};

/**
 * Determine if a hash field exists.
 * @param {string} key
 * @param {string} field
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hexists = function(key, field, cb) {};

/**
 * @param {string} key
 * @param {string} field
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HEXISTS = function(key, field, cb) {};

/**
 * Get the value of a hash field.
 * @param {string} key
 * @param {string} field
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hget = function(key, field, cb) {};

/**
 * @param {string} key
 * @param {string} field
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HGET = function(key, field, cb) {};

/**
 * Get all fields and values in a hash.
 * @param {string} key
 * @param {?} cb
 * @return {?}
 */
Commands.prototype.hgetall = function(key, cb) {};

/**
 * @param {string} key
 * @param {?} cb
 * @return {?}
 */
Commands.prototype.HGETALL = function(key, cb) {};

/**
 * Increment the integer value of a hash field by the given number.
 * @param {string} key
 * @param {string} field
 * @param {number} increment
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hincrby = function(key, field, increment, cb) {};

/**
 * @param {string} key
 * @param {string} field
 * @param {number} increment
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HINCRBY = function(key, field, increment, cb) {};

/**
 * Increment the float value of a hash field by the given amount.
 * @param {string} key
 * @param {string} field
 * @param {number} increment
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hincrbyfloat = function(key, field, increment, cb) {};

/**
 * @param {string} key
 * @param {string} field
 * @param {number} increment
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HINCRBYFLOAT = function(key, field, increment, cb) {};

/**
 * Get all the fields of a hash.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hkeys = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HKEYS = function(key, cb) {};

/**
 * Get the number of fields in a hash.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hlen = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HLEN = function(key, cb) {};

/**
 * Set the string value of a hash field.
 * @param {string} key
 * @param {string} field
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hset = function(key, field, value, cb) {};

/**
 * @param {string} key
 * @param {string} field
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HSET = function(key, field, value, cb) {};

/**
 * Set the value of a hash field, only if the field does not exist.
 * @param {string} key
 * @param {string} field
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hsetnx = function(key, field, value, cb) {};

/**
 * @param {string} key
 * @param {string} field
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HSETNX = function(key, field, value, cb) {};

/**
 * Get the length of the value of a hash field.
 * @param {string} key
 * @param {string} field
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hstrlen = function(key, field, cb) {};

/**
 * @param {string} key
 * @param {string} field
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HSTRLEN = function(key, field, cb) {};

/**
 * Get all the values of a hash.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.hvals = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.HVALS = function(key, cb) {};

/**
 * Increment the integer value of a key by one.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.incr = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.INCR = function(key, cb) {};

/**
 * Increment the integer value of a key by the given amount.
 * @param {string} key
 * @param {number} increment
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.incrby = function(key, increment, cb) {};

/**
 * @param {string} key
 * @param {number} increment
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.INCRBY = function(key, increment, cb) {};

/**
 * Increment the float value of a key by the given amount.
 * @param {string} key
 * @param {number} increment
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.incrbyfloat = function(key, increment, cb) {};

/**
 * @param {string} key
 * @param {number} increment
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.INCRBYFLOAT = function(key, increment, cb) {};

/**
 * Find all keys matching the given pattern.
 * @param {string} pattern
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.keys = function(pattern, cb) {};

/**
 * @param {string} pattern
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.KEYS = function(pattern, cb) {};

/**
 * Get the UNIX time stamp of the last successful save to disk.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.lastsave = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LASTSAVE = function(cb) {};

/**
 * Get an element from a list by its index.
 * @param {string} key
 * @param {number} index
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.lindex = function(key, index, cb) {};

/**
 * @param {string} key
 * @param {number} index
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LINDEX = function(key, index, cb) {};

/**
 * Insert an element before or after another element in a list.
 * @param {string} key
 * @param {string} dir
 * @param {string} pivot
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.linsert = function(key, dir, pivot, value, cb) {};

/**
 * @param {string} key
 * @param {string} dir
 * @param {string} pivot
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LINSERT = function(key, dir, pivot, value, cb) {};

/**
 * Get the length of a list.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.llen = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LLEN = function(key, cb) {};

/**
 * Remove and get the first element in a list.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.lpop = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LPOP = function(key, cb) {};

/**
 * Prepend a value to a list, only if the list exists.
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.lpushx = function(key, value, cb) {};

/**
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LPUSHX = function(key, value, cb) {};

/**
 * Get a range of elements from a list.
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.lrange = function(key, start, stop, cb) {};

/**
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LRANGE = function(key, start, stop, cb) {};

/**
 * Remove elements from a list.
 * @param {string} key
 * @param {number} count
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.lrem = function(key, count, value, cb) {};

/**
 * @param {string} key
 * @param {number} count
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LREM = function(key, count, value, cb) {};

/**
 * Set the value of an element in a list by its index.
 * @param {string} key
 * @param {number} index
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.lset = function(key, index, value, cb) {};

/**
 * @param {string} key
 * @param {number} index
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LSET = function(key, index, value, cb) {};

/**
 * Trim a list to the specified range.
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ltrim = function(key, start, stop, cb) {};

/**
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.LTRIM = function(key, start, stop, cb) {};

/**
 * Move a key to another database.
 * @param {string} key
 * @param {(string|number)} db
 * @return {?}
 */
Commands.prototype.move = function(key, db) {};

/**
 * @param {string} key
 * @param {(string|number)} db
 * @return {?}
 */
Commands.prototype.MOVE = function(key, db) {};

/**
 * Remove the expiration from a key.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.persist = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.PERSIST = function(key, cb) {};

/**
 * Remove a key's time to live in milliseconds.
 * @param {string} key
 * @param {number} milliseconds
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.pexpire = function(key, milliseconds, cb) {};

/**
 * @param {string} key
 * @param {number} milliseconds
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.PEXPIRE = function(key, milliseconds, cb) {};

/**
 * Set the expiration for a key as a UNIX timestamp specified in milliseconds.
 * @param {string} key
 * @param {number} millisecondsTimestamp
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.pexpireat = function(key, millisecondsTimestamp, cb) {};

/**
 * @param {string} key
 * @param {number} millisecondsTimestamp
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.PEXPIREAT = function(key, millisecondsTimestamp, cb) {};

/**
 * Set the value and expiration in milliseconds of a key.
 * @param {string} key
 * @param {number} milliseconds
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.psetex = function(key, milliseconds, value, cb) {};

/**
 * @param {string} key
 * @param {number} milliseconds
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.PSETEX = function(key, milliseconds, value, cb) {};

/**
 * Get the time to live for a key in milliseconds.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.pttl = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.PTTL = function(key, cb) {};

/**
 * Close the connection.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.quit = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.QUIT = function(cb) {};

/**
 * Return a random key from the keyspace.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.randomkey = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.RANDOMKEY = function(cb) {};

/**
 * Enables read queries for a connection to a cluster slave node.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.readonly = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.READONLY = function(cb) {};

/**
 * Disables read queries for a connection to cluster slave node.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.readwrite = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.READWRITE = function(cb) {};

/**
 * Rename a key.
 * @param {string} key
 * @param {string} newkey
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.rename = function(key, newkey, cb) {};

/**
 * @param {string} key
 * @param {string} newkey
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.RENAME = function(key, newkey, cb) {};

/**
 * Rename a key, only if the new key does not exist.
 * @param {string} key
 * @param {string} newkey
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.renamenx = function(key, newkey, cb) {};

/**
 * @param {string} key
 * @param {string} newkey
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.RENAMENX = function(key, newkey, cb) {};

/**
 * Create a key using the provided serialized value, previously obtained using DUMP.
 * @param {string} key
 * @param {number} ttl
 * @param {string} serializedValue
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.restore = function(key, ttl, serializedValue, cb) {};

/**
 * @param {string} key
 * @param {number} ttl
 * @param {string} serializedValue
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.RESTORE = function(key, ttl, serializedValue, cb) {};

/**
 * Return the role of the instance in the context of replication.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.role = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ROLE = function(cb) {};

/**
 * Remove and get the last element in a list.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.rpop = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.RPOP = function(key, cb) {};

/**
 * Remove the last element in a list, prepend it to another list and return it.
 * @param {string} source
 * @param {string} destination
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.rpoplpush = function(source, destination, cb) {};

/**
 * @param {string} source
 * @param {string} destination
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.RPOPLPUSH = function(source, destination, cb) {};

/**
 * Append a value to a list, only if the list exists.
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.rpushx = function(key, value, cb) {};

/**
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.RPUSHX = function(key, value, cb) {};

/**
 * Synchronously save the dataset to disk.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.save = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SAVE = function(cb) {};

/**
 * Get the number of members in a set.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.scard = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SCARD = function(key, cb) {};

/**
 * Change the selected database for the current connection.
 * @param {(string|number)} index
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.select = function(index, cb) {};

/**
 * @param {(string|number)} index
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SELECT = function(index, cb) {};

/**
 * Set the string value of a key.
 * @param {string} key
 * @param {string} value
 * @param {?|string=} cb_or_flag_or_mode
 * @param {?|number=} cb_or_duration
 * @param {?|string=} cb_or_flag
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.set = function(key, value, cb_or_flag_or_mode, cb_or_duration, cb_or_flag, cb) {};

/**
 * @param {string} key
 * @param {string} value
 * @param {?|string=} cb_or_flag_or_mode
 * @param {?|number=} cb_or_duration
 * @param {?|string=} cb_or_flag
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SET = function(key, value, cb_or_flag_or_mode, cb_or_duration, cb_or_flag, cb) {};

/**
 * Sets or clears the bit at offset in the string value stored at key.
 * @param {string} key
 * @param {number} offset
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.setbit = function(key, offset, value, cb) {};

/**
 * @param {string} key
 * @param {number} offset
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SETBIT = function(key, offset, value, cb) {};

/**
 * Set the value and expiration of a key.
 * @param {string} key
 * @param {number} seconds
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.setex = function(key, seconds, value, cb) {};

/**
 * @param {string} key
 * @param {number} seconds
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SETEX = function(key, seconds, value, cb) {};

/**
 * Set the value of a key, only if the key does not exist.
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.setnx = function(key, value, cb) {};

/**
 * @param {string} key
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SETNX = function(key, value, cb) {};

/**
 * Overwrite part of a string at key starting at the specified offset.
 * @param {string} key
 * @param {number} offset
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.setrange = function(key, offset, value, cb) {};

/**
 * @param {string} key
 * @param {number} offset
 * @param {string} value
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SETRANGE = function(key, offset, value, cb) {};

/**
 * Determine if a given value is a member of a set.
 * @param {string} key
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.sismember = function(key, member, cb) {};

/**
 * @param {string} key
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SISMEMBER = function(key, member, cb) {};

/**
 * Make the server a slave of another instance, or promote it as master.
 * @param {string} host
 * @param {(string|number)} port
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.slaveof = function(host, port, cb) {};

/**
 * @param {string} host
 * @param {(string|number)} port
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SLAVEOF = function(host, port, cb) {};

/**
 * Get all the members in a set.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.smembers = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SMEMBERS = function(key, cb) {};

/**
 * Move a member from one set to another.
 * @param {string} source
 * @param {string} destination
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.smove = function(source, destination, member, cb) {};

/**
 * @param {string} source
 * @param {string} destination
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SMOVE = function(source, destination, member, cb) {};

/**
 * Remove and return one or multiple random members from a set.
 * @param {string} key
 * @param {?|number=} cb_or_count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.spop = function(key, cb_or_count, cb) {};

/**
 * @param {string} key
 * @param {?|number=} cb_or_count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SPOP = function(key, cb_or_count, cb) {};

/**
 * Get one or multiple random members from a set.
 * @param {string} key
 * @param {?|number=} cb_or_count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.srandmember = function(key, cb_or_count, cb) {};

/**
 * @param {string} key
 * @param {?|number=} cb_or_count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SRANDMEMBER = function(key, cb_or_count, cb) {};

/**
 * Get the length of the value stored in a key.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.strlen = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.STRLEN = function(key, cb) {};

/**
 * Internal command used for replication.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.sync = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.SYNC = function(cb) {};

/**
 * Return the current server time.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.time = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.TIME = function(cb) {};

/**
 * Get the time to live for a key.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ttl = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.TTL = function(key, cb) {};

/**
 * Determine the type stored at key.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.type = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.TYPE = function(key, cb) {};

/**
 * Forget about all watched keys.
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.unwatch = function(cb) {};

/**
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.UNWATCH = function(cb) {};

/**
 * Wait for the synchronous replication of all the write commands sent in the context of the current connection.
 * @param {number} numslaves
 * @param {number} timeout
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.wait = function(numslaves, timeout, cb) {};

/**
 * @param {number} numslaves
 * @param {number} timeout
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.WAIT = function(numslaves, timeout, cb) {};

/**
 * Get the number of members in a sorted set.
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zcard = function(key, cb) {};

/**
 * @param {string} key
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZCARD = function(key, cb) {};

/**
 * Count the members in a sorted set with scores between the given values.
 * @param {string} key
 * @param {(string|number)} min
 * @param {(string|number)} max
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zcount = function(key, min, max, cb) {};

/**
 * @param {string} key
 * @param {(string|number)} min
 * @param {(string|number)} max
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZCOUNT = function(key, min, max, cb) {};

/**
 * Increment the score of a member in a sorted set.
 * @param {string} key
 * @param {number} increment
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zincrby = function(key, increment, member, cb) {};

/**
 * @param {string} key
 * @param {number} increment
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZINCRBY = function(key, increment, member, cb) {};

/**
 * Count the number of members in a sorted set between a given lexicographic range.
 * @param {string} key
 * @param {string} min
 * @param {string} max
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zlexcount = function(key, min, max, cb) {};

/**
 * @param {string} key
 * @param {string} min
 * @param {string} max
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZLEXCOUNT = function(key, min, max, cb) {};

/**
 * Return a range of members in a sorted set, by index.
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?|string=} cb_or_withscores
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zrange = function(key, start, stop, cb_or_withscores, cb) {};

/**
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?|string=} cb_or_withscores
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZRANGE = function(key, start, stop, cb_or_withscores, cb) {};

/**
 * Return a range of members in a sorted set, by lexicographical range.
 * @param {string} key
 * @param {string} min
 * @param {string} max
 * @param {?|string=} cb_or_limit
 * @param {number=} offset
 * @param {number=} count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zrangebylex = function(key, min, max, cb_or_limit, offset, count, cb) {};

/**
 * @param {string} key
 * @param {string} min
 * @param {string} max
 * @param {?|string=} cb_or_limit
 * @param {number=} offset
 * @param {number=} count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZRANGEBYLEX = function(key, min, max, cb_or_limit, offset, count, cb) {};

/**
 * Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.
 * @param {string} key
 * @param {string} min
 * @param {string} max
 * @param {?|string=} cb_or_limit
 * @param {number=} offset
 * @param {number=} count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zrevrangebylex = function(key, min, max, cb_or_limit, offset, count, cb) {};

/**
 * @param {string} key
 * @param {string} min
 * @param {string} max
 * @param {?|string=} cb_or_limit
 * @param {number=} offset
 * @param {number=} count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZREVRANGEBYLEX = function(key, min, max, cb_or_limit, offset, count, cb) {};

/**
 * Return a range of members in a sorted set, by score.
 * @param {string} key
 * @param {(string|number)} min
 * @param {(string|number)} max
 * @param {?|string=} cb_or_withscores_or_limit
 * @param {?|number|string=} cb_or_offset_or_limit
 * @param {number=} count_or_offset
 * @param {?|number=} cb_or_count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zrangebyscore = function(key, min, max, cb_or_withscores_or_limit, cb_or_offset_or_limit, count_or_offset, cb_or_count, cb) {};

/**
 * @param {string} key
 * @param {(string|number)} min
 * @param {(string|number)} max
 * @param {?|string=} cb_or_withscores_or_limit
 * @param {?|number|string=} cb_or_offset_or_limit
 * @param {number=} count_or_offset
 * @param {?|number=} cb_or_count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZRANGEBYSCORE = function(key, min, max, cb_or_withscores_or_limit, cb_or_offset_or_limit, count_or_offset, cb_or_count, cb) {};

/**
 * Determine the index of a member in a sorted set.
 * @param {string} key
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zrank = function(key, member, cb) {};

/**
 * @param {string} key
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZRANK = function(key, member, cb) {};

/**
 * Remove all members in a sorted set between the given lexicographical range.
 * @param {string} key
 * @param {string} min
 * @param {string} max
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zremrangebylex = function(key, min, max, cb) {};

/**
 * @param {string} key
 * @param {string} min
 * @param {string} max
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZREMRANGEBYLEX = function(key, min, max, cb) {};

/**
 * Remove all members in a sorted set within the given indexes.
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zremrangebyrank = function(key, start, stop, cb) {};

/**
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZREMRANGEBYRANK = function(key, start, stop, cb) {};

/**
 * Remove all members in a sorted set within the given indexes.
 * @param {string} key
 * @param {(string|number)} min
 * @param {(string|number)} max
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zremrangebyscore = function(key, min, max, cb) {};

/**
 * @param {string} key
 * @param {(string|number)} min
 * @param {(string|number)} max
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZREMRANGEBYSCORE = function(key, min, max, cb) {};

/**
 * Return a range of members in a sorted set, by index, with scores ordered from high to low.
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?|string=} cb_or_withscores
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zrevrange = function(key, start, stop, cb_or_withscores, cb) {};

/**
 * @param {string} key
 * @param {number} start
 * @param {number} stop
 * @param {?|string=} cb_or_withscores
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZREVRANGE = function(key, start, stop, cb_or_withscores, cb) {};

/**
 * Return a range of members in a sorted set, by score, with scores ordered from high to low.
 * @param {string} key
 * @param {(string|number)} min
 * @param {(string|number)} max
 * @param {?|string=} cb_or_withscores_or_limit
 * @param {?|number|string=} cb_or_offset_or_limit
 * @param {number=} count_or_offset
 * @param {?|number=} cb_or_count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zrevrangebyscore = function(key, min, max, cb_or_withscores_or_limit, cb_or_offset_or_limit, count_or_offset, cb_or_count, cb) {};

/**
 * @param {string} key
 * @param {(string|number)} min
 * @param {(string|number)} max
 * @param {?|string=} cb_or_withscores_or_limit
 * @param {?|number|string=} cb_or_offset_or_limit
 * @param {number=} count_or_offset
 * @param {?|number=} cb_or_count
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZREVRANGEBYSCORE = function(key, min, max, cb_or_withscores_or_limit, cb_or_offset_or_limit, count_or_offset, cb_or_count, cb) {};

/**
 * Determine the index of a member in a sorted set, with scores ordered from high to low.
 * @param {string} key
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zrevrank = function(key, member, cb) {};

/**
 * @param {string} key
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZREVRANK = function(key, member, cb) {};

/**
 * Get the score associated with the given member in a sorted set.
 * @param {string} key
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.zscore = function(key, member, cb) {};

/**
 * @param {string} key
 * @param {string} member
 * @param {?=} cb
 * @return {?}
 */
Commands.prototype.ZSCORE = function(key, member, cb) {};
 /** @type {?} */
var RedisClient;
 /** @type {boolean} */
RedisClient.prototype.connected;
 /** @type {number} */
RedisClient.prototype.command_queue_length;
 /** @type {number} */
RedisClient.prototype.offline_queue_length;
 /** @type {number} */
RedisClient.prototype.retry_delay;
 /** @type {number} */
RedisClient.prototype.retry_backoff;
 /** @type {!Array<?>} */
RedisClient.prototype.command_queue;
 /** @type {!Array<?>} */
RedisClient.prototype.offline_queue;
 /** @type {number} */
RedisClient.prototype.connection_id;
 /** @type {?} */
RedisClient.prototype.server_info;
 /** @type {!internal.Duplex} */
RedisClient.prototype.stream;

/**
 * @param {string} event
 * @param {?} listener
 * @return {?}
 */
RedisClient.prototype.on = function(event, listener) {};

/**
 * Client methods.
 * @param {boolean=} flush
 * @return {void}
 */
RedisClient.prototype.end = function(flush) {};

/**
 * @return {void}
 */
RedisClient.prototype.unref = function() {};

/**
 * @return {void}
 */
RedisClient.prototype.cork = function() {};

/**
 * @return {void}
 */
RedisClient.prototype.uncork = function() {};

/**
 * @param {?=} options
 * @param {?=} cb
 * @return {?}
 */
RedisClient.prototype.duplicate = function(options, cb) {};

/**
 * @param {string} command
 * @param {?|!Array<?>=} cb_or_args
 * @param {?=} cb
 * @return {boolean}
 */
RedisClient.prototype.sendCommand = function(command, cb_or_args, cb) {};

/**
 * @param {string} command
 * @param {?|!Array<?>=} cb_or_args
 * @param {?=} cb
 * @return {boolean}
 */
RedisClient.prototype.send_command = function(command, cb_or_args, cb) {};

/**
 * Mark the start of a transaction block.
 * @param {!Array<!Array<(string|number|?)>>=} args
 * @return {?}
 */
RedisClient.prototype.multi = function(args) {};

/**
 * @param {!Array<!Array<(string|number|?)>>=} args
 * @return {?}
 */
RedisClient.prototype.MULTI = function(args) {};

/**
 * @param {!Array<!Array<(string|number|?)>>=} args
 * @return {?}
 */
RedisClient.prototype.batch = function(args) {};

/**
 * @param {!Array<!Array<(string|number|?)>>=} args
 * @return {?}
 */
RedisClient.prototype.BATCH = function(args) {};
 /** @type {?} */
var Multi;

/**
 * @param {?=} cb
 * @return {boolean}
 */
Multi.prototype.exec = function(cb) {};

/**
 * @param {?=} cb
 * @return {boolean}
 */
Multi.prototype.EXEC = function(cb) {};

/**
 * @param {?=} cb
 * @return {boolean}
 */
Multi.prototype.exec_atomic = function(cb) {};

/**
 * @param {?=} cb
 * @return {boolean}
 */
Multi.prototype.EXEC_ATOMIC = function(cb) {};
 /** @type {boolean} */
var debug_mode;

/**
 * @param {number|string|?=} port_or_unix_socket_or_redis_url_or_options
 * @param {string|?=} host_or_options
 * @param {?=} options
 * @return {?}
 */
function createClient(port_or_unix_socket_or_redis_url_or_options, host_or_options, options) {}

/**
 * @param {(void|!Error)} err
 * @param {?} reply
 * @return {void}
 */
function print(err, reply) {}
