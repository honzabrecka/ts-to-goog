/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/jasmine/index.d.ts:

/**
 * Create a group of specs (often called a suite).
 * @param {string} description Textual description of the group
 * @param {function(): void} specDefinitions Function for Jasmine to invoke that will define inner suites a specs
 * @return {void}
 */
function describe(description, specDefinitions) {}

/**
 * @param {string} description
 * @param {function(): void} specDefinitions
 * @return {void}
 */
function fdescribe(description, specDefinitions) {}

/**
 * @param {string} description
 * @param {function(): void} specDefinitions
 * @return {void}
 */
function xdescribe(description, specDefinitions) {}

/**
 * Define a single spec. A spec should contain one or more expectations that test the state of the code.
 * A spec whose expectations all succeed will be passing and a spec with any failures will fail.
 * @param {string} expectation Textual description of what this spec is checking
 * @param {function(!DoneFn): void=} assertion Function that contains the code of your test. If not provided the test will be pending.
 * @param {number=} timeout Custom timeout for an async spec.
 * @return {void}
 */
function it(expectation, assertion, timeout) {}

/**
 * A focused it
 * If suites or specs are focused, only those that are focused will be executed.
 * @param {string} expectation
 * @param {function(!DoneFn): void=} assertion
 * @param {number=} timeout
 * @return {void}
 */
function fit(expectation, assertion, timeout) {}

/**
 * @param {string} expectation
 * @param {function(!DoneFn): void=} assertion
 * @param {number=} timeout
 * @return {void}
 */
function xit(expectation, assertion, timeout) {}

/**
 * Mark a spec as pending, expectation results will be ignored.
 * If you call the function pending anywhere in the spec body, no matter the expectations, the spec will be marked pending.
 * @param {string=} reason
 * @return {void}
 */
function pending(reason) {}

/**
 * Run some shared setup before each of the specs in the describe in which it is called.
 * @param {function(!DoneFn): void} action Function that contains the code to setup your specs.
 * @param {number=} timeout Custom timeout for an async beforeEach.
 * @return {void}
 */
function beforeEach(action, timeout) {}

/**
 * Run some shared teardown after each of the specs in the describe in which it is called.
 * @param {function(!DoneFn): void} action Function that contains the code to teardown your specs.
 * @param {number=} timeout Custom timeout for an async afterEach.
 * @return {void}
 */
function afterEach(action, timeout) {}

/**
 * Run some shared setup once before all of the specs in the describe are run.
 * Note: Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
 * @param {function(!DoneFn): void} action Function that contains the code to setup your specs.
 * @param {number=} timeout Custom timeout for an async beforeAll.
 * @return {void}
 */
function beforeAll(action, timeout) {}

/**
 * Run some shared teardown once before all of the specs in the describe are run.
 * Note: Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
 * @param {function(!DoneFn): void} action Function that contains the code to teardown your specs.
 * @param {number=} timeout Custom timeout for an async afterAll
 * @return {void}
 */
function afterAll(action, timeout) {}

/**
 * Create an expectation for a spec.
 * Create an expectation for a spec.
 * Create an expectation for a spec.
 * @template T
 * @param {!Function|!ArrayLike<T>|T} spy_or_actual Actual computed value to test expectations against.
 * @return {!jasmine.Matchers<?>|!jasmine.ArrayLikeMatchers<T>|!jasmine.Matchers<T>}
 */
function expect(spy_or_actual) {}

/**
 * Explicitly mark a spec as failed.
 * @param {?=} e
 * @return {void}
 */
function fail(e) {}
/**
 * @record
 * @struct
 */
function DoneFn() {}

/* TODO: CallSignature:  */
 /** @type {function((string|!Error)): void} */
DoneFn.prototype.fail;

/**
 * Install a spy onto an existing object.
 * @template T
 * @param {T} object The object upon which to install the Spy
 * @param {?} method The name of the method to replace with a Spy.
 * @return {!jasmine.Spy}
 */
function spyOn(object, method) {}

/**
 * Install a spy on a property onto an existing object.
 * @template T
 * @param {T} object The object upon which to install the Spy
 * @param {?} property The name of the property to replace with a Spy
 * @param {string} accessType The access type (get|set) of the property to Spy on.
 * @return {!jasmine.Spy}
 */
function spyOnProperty(object, property, accessType) {}

/**
 * @param {!Function} asyncMethod
 * @return {void}
 */
function runs(asyncMethod) {}

/**
 * @param {function(): boolean} latchMethod
 * @param {string=} failureMessage
 * @param {number=} timeout
 * @return {void}
 */
function waitsFor(latchMethod, failureMessage, timeout) {}

/**
 * @param {number=} timeout
 * @return {void}
 */
function waits(timeout) {}
/** @const */
var jasmine = {};

/** @typedef {(!jasmine.Spy|T|!jasmine.ObjectContaining<T>|!jasmine.Any)} */
jasmine.Expected;
 /** @type {function(): !jasmine.Clock} */
jasmine.clock;

/**
 * @param {?} aclass
 * @return {!jasmine.Any}
 */
jasmine.any = function(aclass) {};

/**
 * @return {!jasmine.Any}
 */
jasmine.anything = function() {};

/**
 * @param {!Array<?>} sample
 * @return {!jasmine.ArrayContaining}
 */
jasmine.arrayContaining = function(sample) {};

/**
 * @template T
 * @param {?} sample
 * @return {!jasmine.ObjectContaining<T>}
 */
jasmine.objectContaining = function(sample) {};

/**
 * @param {string} name
 * @param {!Function=} originalFn
 * @return {!jasmine.Spy}
 */
jasmine.createSpy = function(name, originalFn) {};

/**
 * @template T
 * @param {string|!Array<?>|?} baseName_or_methodNames
 * @param {(!Array<?>|!Object<string,?>)|?=} methodNames
 * @return {?}
 */
jasmine.createSpyObj = function(baseName_or_methodNames, methodNames) {};

/**
 * @param {?} value
 * @return {string}
 */
jasmine.pp = function(value) {};

/**
 * @return {!jasmine.Env}
 */
jasmine.getEnv = function() {};

/**
 * @param {function(?, ?): (boolean|void)} equalityTester
 * @return {void}
 */
jasmine.addCustomEqualityTester = function(equalityTester) {};

/**
 * @param {!jasmine.CustomMatcherFactories} matchers
 * @return {void}
 */
jasmine.addMatchers = function(matchers) {};

/**
 * @param {string|!RegExp} str
 * @return {!jasmine.Any}
 */
jasmine.stringMatching = function(str) {};

/**
 * @param {string} domain
 * @param {string} usage
 * @return {function(string): string}
 */
jasmine.formatErrorMsg = function(domain, usage) {};
/**
 * @record
 * @struct
 */
jasmine.Any = function() {};

/* TODO: CallSignature: jasmine */

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} other
 * @return {boolean}
 */
jasmine.Any.prototype.jasmineMatches = function(other) {};

/**
 * @return {string}
 */
jasmine.Any.prototype.jasmineToString = function() {};
/**
 * @record
 * @struct
 */
jasmine.ArrayLike = function() {};
 /** @type {number} */
jasmine.ArrayLike.prototype.length;

/* TODO: IndexSignature: jasmine */
/**
 * @record
 * @struct
 */
jasmine.ArrayContaining = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} other
 * @return {boolean}
 */
jasmine.ArrayContaining.prototype.asymmetricMatch = function(other) {};

/**
 * @return {string}
 */
jasmine.ArrayContaining.prototype.jasmineToString = function() {};
/**
 * @record
 * @struct
 */
jasmine.ObjectContaining = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} other
 * @param {!Array<?>} mismatchKeys
 * @param {!Array<?>} mismatchValues
 * @return {boolean}
 */
jasmine.ObjectContaining.prototype.jasmineMatches = function(other, mismatchKeys, mismatchValues) {};

/**
 * @return {string}
 */
jasmine.ObjectContaining.prototype.jasmineToString = function() {};
/**
 * @record
 * @struct
 */
jasmine.Block = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {function(): void} onComplete
 * @return {void}
 */
jasmine.Block.prototype.execute = function(onComplete) {};
/**
 * @extends {jasmine.Block}
 * @record
 * @struct
 */
jasmine.WaitsBlock = function() {};

/* TODO: ConstructSignature: jasmine */
/**
 * @extends {jasmine.Block}
 * @record
 * @struct
 */
jasmine.WaitsForBlock = function() {};

/* TODO: ConstructSignature: jasmine */
/**
 * @record
 * @struct
 */
jasmine.Clock = function() {};

/**
 * @return {void}
 */
jasmine.Clock.prototype.install = function() {};

/**
 * @return {void}
 */
jasmine.Clock.prototype.uninstall = function() {};

/**
 * Calls to any registered callback are triggered when the clock is ticked forward via the jasmine.clock().tick function, which takes a number of milliseconds.
 * @param {number} ms
 * @return {void}
 */
jasmine.Clock.prototype.tick = function(ms) {};

/**
 * @param {!Date=} date
 * @return {void}
 */
jasmine.Clock.prototype.mockDate = function(date) {};

/**
 * @param {function(): void} func
 * @return {void}
 */
jasmine.Clock.prototype.withMock = function(func) {};

/** @typedef {function(?, ?): (boolean|void)} */
jasmine.CustomEqualityTester;
/**
 * @record
 * @struct
 */
jasmine.CustomMatcher = function() {};

/**
 * @template T
 * @param {T|?} actual
 * @param {T|?} expected
 * @return {!jasmine.CustomMatcherResult}
 */
jasmine.CustomMatcher.prototype.compare = function(actual, expected) {};

/** @typedef {function(!jasmine.MatchersUtil, !Array<function(?, ?): (boolean|void)>): !jasmine.CustomMatcher} */
jasmine.CustomMatcherFactory;
/**
 * @record
 * @struct
 */
jasmine.CustomMatcherFactories = function() {};

/* TODO: IndexSignature: jasmine */
/**
 * @record
 * @struct
 */
jasmine.CustomMatcherResult = function() {};
 /** @type {boolean} */
jasmine.CustomMatcherResult.prototype.pass;
 /** @type {string} */
jasmine.CustomMatcherResult.prototype.message;
/**
 * @record
 * @struct
 */
jasmine.MatchersUtil = function() {};

/**
 * @param {?} a
 * @param {?} b
 * @param {!Array<function(?, ?): (boolean|void)>=} customTesters
 * @return {boolean}
 */
jasmine.MatchersUtil.prototype.equals = function(a, b, customTesters) {};

/**
 * @template T
 * @param {(string|!jasmine.ArrayLike<T>)} haystack
 * @param {?} needle
 * @param {!Array<function(?, ?): (boolean|void)>=} customTesters
 * @return {boolean}
 */
jasmine.MatchersUtil.prototype.contains = function(haystack, needle, customTesters) {};

/**
 * @param {string} matcherName
 * @param {boolean} isNot
 * @param {?} actual
 * @param {...?} expected
 * @return {string}
 */
jasmine.MatchersUtil.prototype.buildFailureMessage = function(matcherName, isNot, actual, expected) {};
/**
 * @record
 * @struct
 */
jasmine.Env = function() {};
 /** @type {?} */
jasmine.Env.prototype.setTimeout;
 /** @type {void} */
jasmine.Env.prototype.clearTimeout;
 /** @type {?} */
jasmine.Env.prototype.setInterval;
 /** @type {void} */
jasmine.Env.prototype.clearInterval;
 /** @type {number} */
jasmine.Env.prototype.updateInterval;
 /** @type {!jasmine.Spec} */
jasmine.Env.prototype.currentSpec;
 /** @type {!jasmine.Matchers<?>} */
jasmine.Env.prototype.matchersClass;

/**
 * @return {?}
 */
jasmine.Env.prototype.version = function() {};

/**
 * @return {string}
 */
jasmine.Env.prototype.versionString = function() {};

/**
 * @return {number}
 */
jasmine.Env.prototype.nextSpecId = function() {};

/**
 * @param {!jasmine.Reporter|!jasmine.CustomReporter} reporter
 * @return {void}
 */
jasmine.Env.prototype.addReporter = function(reporter) {};

/**
 * @return {void}
 */
jasmine.Env.prototype.execute = function() {};

/**
 * @param {string} description
 * @param {function(): void} specDefinitions
 * @return {!jasmine.Suite}
 */
jasmine.Env.prototype.describe = function(description, specDefinitions) {};

/**
 * @param {function(): void} beforeEachFunction
 * @return {void}
 */
jasmine.Env.prototype.beforeEach = function(beforeEachFunction) {};

/**
 * @param {function(): void} beforeAllFunction
 * @return {void}
 */
jasmine.Env.prototype.beforeAll = function(beforeAllFunction) {};

/**
 * @return {!jasmine.Runner}
 */
jasmine.Env.prototype.currentRunner = function() {};

/**
 * @param {function(): void} afterEachFunction
 * @return {void}
 */
jasmine.Env.prototype.afterEach = function(afterEachFunction) {};

/**
 * @param {function(): void} afterAllFunction
 * @return {void}
 */
jasmine.Env.prototype.afterAll = function(afterAllFunction) {};

/**
 * @param {string} desc
 * @param {function(): void} specDefinitions
 * @return {!jasmine.XSuite}
 */
jasmine.Env.prototype.xdescribe = function(desc, specDefinitions) {};

/**
 * @param {string} description
 * @param {function(): void} func
 * @return {!jasmine.Spec}
 */
jasmine.Env.prototype.it = function(description, func) {};

/**
 * @param {string} desc
 * @param {function(): void} func
 * @return {!jasmine.XSpec}
 */
jasmine.Env.prototype.xit = function(desc, func) {};

/**
 * @param {!RegExp} a
 * @param {!RegExp} b
 * @param {!Array<string>} mismatchKeys
 * @param {!Array<string>} mismatchValues
 * @return {boolean}
 */
jasmine.Env.prototype.compareRegExps_ = function(a, b, mismatchKeys, mismatchValues) {};

/**
 * @param {?} a
 * @param {?} b
 * @param {!Array<string>} mismatchKeys
 * @param {!Array<string>} mismatchValues
 * @return {boolean}
 */
jasmine.Env.prototype.compareObjects_ = function(a, b, mismatchKeys, mismatchValues) {};

/**
 * @param {?} a
 * @param {?} b
 * @param {!Array<string>} mismatchKeys
 * @param {!Array<string>} mismatchValues
 * @return {boolean}
 */
jasmine.Env.prototype.equals_ = function(a, b, mismatchKeys, mismatchValues) {};

/**
 * @param {?} haystack
 * @param {?} needle
 * @return {boolean}
 */
jasmine.Env.prototype.contains_ = function(haystack, needle) {};

/**
 * @param {function(?, ?): (boolean|void)} equalityTester
 * @return {void}
 */
jasmine.Env.prototype.addCustomEqualityTester = function(equalityTester) {};

/**
 * @param {!jasmine.CustomMatcherFactories} matchers
 * @return {void}
 */
jasmine.Env.prototype.addMatchers = function(matchers) {};

/**
 * @param {!jasmine.Spec} spec
 * @return {boolean}
 */
jasmine.Env.prototype.specFilter = function(spec) {};

/**
 * @param {boolean} value
 * @return {void}
 */
jasmine.Env.prototype.throwOnExpectationFailure = function(value) {};

/**
 * @param {(string|number)} seed
 * @return {(string|number)}
 */
jasmine.Env.prototype.seed = function(seed) {};

/**
 * @param {!jasmine.Reporter} reporter
 * @return {void}
 */
jasmine.Env.prototype.provideFallbackReporter = function(reporter) {};

/**
 * @return {boolean}
 */
jasmine.Env.prototype.throwingExpectationFailures = function() {};

/**
 * @param {boolean} allow
 * @return {void}
 */
jasmine.Env.prototype.allowRespy = function(allow) {};

/**
 * @return {boolean}
 */
jasmine.Env.prototype.randomTests = function() {};

/**
 * @param {boolean} b
 * @return {void}
 */
jasmine.Env.prototype.randomizeTests = function(b) {};

/**
 * @return {void}
 */
jasmine.Env.prototype.clearReporters = function() {};
/**
 * @record
 * @struct
 */
jasmine.FakeTimer = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @return {void}
 */
jasmine.FakeTimer.prototype.reset = function() {};

/**
 * @param {number} millis
 * @return {void}
 */
jasmine.FakeTimer.prototype.tick = function(millis) {};

/**
 * @param {number} oldMillis
 * @param {number} nowMillis
 * @return {void}
 */
jasmine.FakeTimer.prototype.runFunctionsWithinRange = function(oldMillis, nowMillis) {};

/**
 * @param {?} timeoutKey
 * @param {function(): void} funcToCall
 * @param {number} millis
 * @param {boolean} recurring
 * @return {void}
 */
jasmine.FakeTimer.prototype.scheduleFunction = function(timeoutKey, funcToCall, millis, recurring) {};
/**
 * @record
 * @struct
 */
jasmine.HtmlReporter = function() {};

/* TODO: ConstructSignature: jasmine */
/**
 * @record
 * @struct
 */
jasmine.HtmlSpecFilter = function() {};

/* TODO: ConstructSignature: jasmine */
/**
 * @record
 * @struct
 */
jasmine.Result = function() {};
 /** @type {string} */
jasmine.Result.prototype.type;
/**
 * @extends {jasmine.Result}
 * @record
 * @struct
 */
jasmine.NestedResults = function() {};
 /** @type {string} */
jasmine.NestedResults.prototype.description;
 /** @type {number} */
jasmine.NestedResults.prototype.totalCount;
 /** @type {number} */
jasmine.NestedResults.prototype.passedCount;
 /** @type {number} */
jasmine.NestedResults.prototype.failedCount;
 /** @type {boolean} */
jasmine.NestedResults.prototype.skipped;

/**
 * @param {!jasmine.NestedResults} result
 * @return {void}
 */
jasmine.NestedResults.prototype.rollupCounts = function(result) {};

/**
 * @param {?} values
 * @return {void}
 */
jasmine.NestedResults.prototype.log = function(values) {};

/**
 * @return {!Array<!jasmine.Result>}
 */
jasmine.NestedResults.prototype.getItems = function() {};

/**
 * @param {!jasmine.Result} result
 * @return {void}
 */
jasmine.NestedResults.prototype.addResult = function(result) {};

/**
 * @return {boolean}
 */
jasmine.NestedResults.prototype.passed = function() {};
/**
 * @extends {jasmine.Result}
 * @record
 * @struct
 */
jasmine.MessageResult = function() {};
 /** @type {?} */
jasmine.MessageResult.prototype.values;
 /** @type {!jasmine.Trace} */
jasmine.MessageResult.prototype.trace;
/**
 * @extends {jasmine.Result}
 * @record
 * @struct
 */
jasmine.ExpectationResult = function() {};
 /** @type {string} */
jasmine.ExpectationResult.prototype.matcherName;
 /** @type {?} */
jasmine.ExpectationResult.prototype.expected;
 /** @type {?} */
jasmine.ExpectationResult.prototype.actual;
 /** @type {string} */
jasmine.ExpectationResult.prototype.message;
 /** @type {!jasmine.Trace} */
jasmine.ExpectationResult.prototype.trace;

/**
 * @return {boolean}
 */
jasmine.ExpectationResult.prototype.passed = function() {};
/**
 * @record
 * @struct
 */
jasmine.Order = function() {};

/* TODO: ConstructSignature: jasmine */
 /** @type {boolean} */
jasmine.Order.prototype.random;
 /** @type {string} */
jasmine.Order.prototype.seed;

/**
 * @template T
 * @param {!Array<T>} items
 * @return {!Array<T>}
 */
jasmine.Order.prototype.sort = function(items) {};
/** @const */
jasmine.errors = {};

/**
 * @constructor
 * @struct
 */
jasmine.errors.ExpectationFailed = function() {};
 /** @type {?} */
jasmine.errors.ExpectationFailed.prototype.stack;
/**
 * @record
 * @struct
 */
jasmine.TreeProcessor = function() {};

/* TODO: ConstructSignature: jasmine */
 /** @type {function(!Function): void} */
jasmine.TreeProcessor.prototype.execute;

/**
 * @return {?}
 */
jasmine.TreeProcessor.prototype.processTree = function() {};
/**
 * @record
 * @struct
 */
jasmine.Trace = function() {};
 /** @type {string} */
jasmine.Trace.prototype.name;
 /** @type {string} */
jasmine.Trace.prototype.message;
 /** @type {?} */
jasmine.Trace.prototype.stack;
/**
 * @record
 * @struct
 */
jasmine.PrettyPrinter = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @param {?} value
 * @return {void}
 */
jasmine.PrettyPrinter.prototype.format = function(value) {};

/**
 * @param {?} obj
 * @param {function(string, boolean): void} fn
 * @return {void}
 */
jasmine.PrettyPrinter.prototype.iterateObject = function(obj, fn) {};

/**
 * @param {?} value
 * @return {void}
 */
jasmine.PrettyPrinter.prototype.emitScalar = function(value) {};

/**
 * @param {string} value
 * @return {void}
 */
jasmine.PrettyPrinter.prototype.emitString = function(value) {};

/**
 * @param {!Array<?>} array
 * @return {void}
 */
jasmine.PrettyPrinter.prototype.emitArray = function(array) {};

/**
 * @param {?} obj
 * @return {void}
 */
jasmine.PrettyPrinter.prototype.emitObject = function(obj) {};

/**
 * @param {?} value
 * @return {void}
 */
jasmine.PrettyPrinter.prototype.append = function(value) {};
/**
 * @extends {jasmine.PrettyPrinter}
 * @record
 * @struct
 */
jasmine.StringPrettyPrinter = function() {};
/**
 * @record
 * @struct
 */
jasmine.Queue = function() {};

/* TODO: ConstructSignature: jasmine */
 /** @type {!jasmine.Env} */
jasmine.Queue.prototype.env;
 /** @type {!Array<boolean>} */
jasmine.Queue.prototype.ensured;
 /** @type {!Array<!jasmine.Block>} */
jasmine.Queue.prototype.blocks;
 /** @type {boolean} */
jasmine.Queue.prototype.running;
 /** @type {number} */
jasmine.Queue.prototype.index;
 /** @type {number} */
jasmine.Queue.prototype.offset;
 /** @type {boolean} */
jasmine.Queue.prototype.abort;

/**
 * @param {!jasmine.Block} block
 * @param {boolean=} ensure
 * @return {void}
 */
jasmine.Queue.prototype.addBefore = function(block, ensure) {};

/**
 * @param {?} block
 * @param {boolean=} ensure
 * @return {void}
 */
jasmine.Queue.prototype.add = function(block, ensure) {};

/**
 * @param {?} block
 * @param {boolean=} ensure
 * @return {void}
 */
jasmine.Queue.prototype.insertNext = function(block, ensure) {};

/**
 * @param {function(): void=} onComplete
 * @return {void}
 */
jasmine.Queue.prototype.start = function(onComplete) {};

/**
 * @return {boolean}
 */
jasmine.Queue.prototype.isRunning = function() {};

/**
 * @return {void}
 */
jasmine.Queue.prototype.next_ = function() {};

/**
 * @return {!jasmine.NestedResults}
 */
jasmine.Queue.prototype.results = function() {};
/**
 * @record
 * @struct
 */
jasmine.Matchers = function() {};

/* TODO: ConstructSignature: jasmine */
 /** @type {!jasmine.Env} */
jasmine.Matchers.prototype.env;
 /** @type {T} */
jasmine.Matchers.prototype.actual;
 /** @type {!jasmine.Env} */
jasmine.Matchers.prototype.spec;
 /** @type {boolean} */
jasmine.Matchers.prototype.isNot;
 /** @type {!jasmine.Matchers} */
jasmine.Matchers.prototype.not;
 /** @type {!jasmine.Any} */
jasmine.Matchers.prototype.Any;

/**
 * @return {?}
 */
jasmine.Matchers.prototype.message = function() {};

/**
 *
 * @param {(T|!jasmine.Spy|!jasmine.Any|!jasmine.ObjectContaining<T>)} expected the actual value to be === to the expected value.
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBe = function(expected, expectationFailOutput) {};

/**
 *  
 * @param {(T|!jasmine.Spy|!jasmine.Any|!jasmine.ObjectContaining<T>)} expected the actual value to be equal to the expected, using deep equality comparison.
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toEqual = function(expected, expectationFailOutput) {};

/**
 * @param {(string|!RegExp)} expected
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toMatch = function(expected, expectationFailOutput) {};

/**
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeDefined = function(expectationFailOutput) {};

/**
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeUndefined = function(expectationFailOutput) {};

/**
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeNull = function(expectationFailOutput) {};

/**
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeNaN = function() {};

/**
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeTruthy = function(expectationFailOutput) {};

/**
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeFalsy = function(expectationFailOutput) {};

/**
 * @return {boolean}
 */
jasmine.Matchers.prototype.toHaveBeenCalled = function() {};

/**
 * @param {...?} params
 * @return {boolean}
 */
jasmine.Matchers.prototype.toHaveBeenCalledWith = function(params) {};

/**
 * @param {number} expected
 * @return {boolean}
 */
jasmine.Matchers.prototype.toHaveBeenCalledTimes = function(expected) {};

/**
 * @param {?} expected
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toContain = function(expected, expectationFailOutput) {};

/**
 * @param {number} expected
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeLessThan = function(expected, expectationFailOutput) {};

/**
 * @param {number} expected
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeLessThanOrEqual = function(expected, expectationFailOutput) {};

/**
 * @param {number} expected
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeGreaterThan = function(expected, expectationFailOutput) {};

/**
 * @param {number} expected
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeGreaterThanOrEqual = function(expected, expectationFailOutput) {};

/**
 * @param {number} expected
 * @param {?=} precision
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.Matchers.prototype.toBeCloseTo = function(expected, precision, expectationFailOutput) {};

/**
 * @param {?=} expected
 * @return {boolean}
 */
jasmine.Matchers.prototype.toThrow = function(expected) {};

/**
 * @param {(string|!RegExp)|function(new: (!Error), !Array<?>): ?=} message_or_expected
 * @param {(string|!RegExp)=} message
 * @return {boolean}
 */
jasmine.Matchers.prototype.toThrowError = function(message_or_expected, message) {};
/**
 * @extends {jasmine.Matchers}
 * @record
 * @struct
 */
jasmine.ArrayLikeMatchers = function() {};
 /** @type {!jasmine.ArrayLikeMatchers} */
jasmine.ArrayLikeMatchers.prototype.not;

/**
 * @param {(!jasmine.Spy|!jasmine.Any|!jasmine.ArrayLike<T>|!jasmine.ObjectContaining<!jasmine.ArrayLike<T>>)} expected
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.ArrayLikeMatchers.prototype.toBe = function(expected, expectationFailOutput) {};

/**
 * @param {(!jasmine.Spy|!jasmine.Any|!jasmine.ArrayLike<T>|!jasmine.ObjectContaining<!jasmine.ArrayLike<T>>)} expected
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.ArrayLikeMatchers.prototype.toEqual = function(expected, expectationFailOutput) {};

/**
 * @param {(T|!jasmine.Spy|!jasmine.Any|!jasmine.ObjectContaining<T>)} expected
 * @param {?=} expectationFailOutput
 * @return {boolean}
 */
jasmine.ArrayLikeMatchers.prototype.toContain = function(expected, expectationFailOutput) {};
/**
 * @record
 * @struct
 */
jasmine.Reporter = function() {};

/**
 * @param {!jasmine.Runner} runner
 * @return {void}
 */
jasmine.Reporter.prototype.reportRunnerStarting = function(runner) {};

/**
 * @param {!jasmine.Runner} runner
 * @return {void}
 */
jasmine.Reporter.prototype.reportRunnerResults = function(runner) {};

/**
 * @param {!jasmine.Suite} suite
 * @return {void}
 */
jasmine.Reporter.prototype.reportSuiteResults = function(suite) {};

/**
 * @param {!jasmine.Spec} spec
 * @return {void}
 */
jasmine.Reporter.prototype.reportSpecStarting = function(spec) {};

/**
 * @param {!jasmine.Spec} spec
 * @return {void}
 */
jasmine.Reporter.prototype.reportSpecResults = function(spec) {};

/**
 * @param {string} str
 * @return {void}
 */
jasmine.Reporter.prototype.log = function(str) {};
/**
 * @extends {jasmine.Reporter}
 * @record
 * @struct
 */
jasmine.MultiReporter = function() {};

/**
 * @param {!jasmine.Reporter} reporter
 * @return {void}
 */
jasmine.MultiReporter.prototype.addReporter = function(reporter) {};
/**
 * @record
 * @struct
 */
jasmine.SuiteInfo = function() {};
 /** @type {number} */
jasmine.SuiteInfo.prototype.totalSpecsDefined;
/**
 * @record
 * @struct
 */
jasmine.CustomReportExpectation = function() {};
 /** @type {string} */
jasmine.CustomReportExpectation.prototype.matcherName;
 /** @type {string} */
jasmine.CustomReportExpectation.prototype.message;
 /** @type {boolean} */
jasmine.CustomReportExpectation.prototype.passed;
 /** @type {string} */
jasmine.CustomReportExpectation.prototype.stack;
/**
 * @extends {jasmine.CustomReportExpectation}
 * @record
 * @struct
 */
jasmine.FailedExpectation = function() {};
 /** @type {string} */
jasmine.FailedExpectation.prototype.actual;
 /** @type {string} */
jasmine.FailedExpectation.prototype.expected;
/**
 * @extends {jasmine.CustomReportExpectation}
 * @record
 * @struct
 */
jasmine.PassedExpectation = function() {};
/**
 * @record
 * @struct
 */
jasmine.CustomReporterResult = function() {};
 /** @type {string} */
jasmine.CustomReporterResult.prototype.description;
 /** @type {!Array<!jasmine.FailedExpectation>} */
jasmine.CustomReporterResult.prototype.failedExpectations;
 /** @type {string} */
jasmine.CustomReporterResult.prototype.fullName;
 /** @type {string} */
jasmine.CustomReporterResult.prototype.id;
 /** @type {!Array<!jasmine.PassedExpectation>} */
jasmine.CustomReporterResult.prototype.passedExpectations;
 /** @type {string} */
jasmine.CustomReporterResult.prototype.pendingReason;
 /** @type {string} */
jasmine.CustomReporterResult.prototype.status;
/**
 * @record
 * @struct
 */
jasmine.RunDetails = function() {};
 /** @type {!Array<!jasmine.ExpectationResult>} */
jasmine.RunDetails.prototype.failedExpectations;
 /** @type {!jasmine.Order} */
jasmine.RunDetails.prototype.order;
/**
 * @record
 * @struct
 */
jasmine.CustomReporter = function() {};

/**
 * @param {!jasmine.SuiteInfo} suiteInfo
 * @return {void}
 */
jasmine.CustomReporter.prototype.jasmineStarted = function(suiteInfo) {};

/**
 * @param {!jasmine.CustomReporterResult} result
 * @return {void}
 */
jasmine.CustomReporter.prototype.suiteStarted = function(result) {};

/**
 * @param {!jasmine.CustomReporterResult} result
 * @return {void}
 */
jasmine.CustomReporter.prototype.specStarted = function(result) {};

/**
 * @param {!jasmine.CustomReporterResult} result
 * @return {void}
 */
jasmine.CustomReporter.prototype.specDone = function(result) {};

/**
 * @param {!jasmine.CustomReporterResult} result
 * @return {void}
 */
jasmine.CustomReporter.prototype.suiteDone = function(result) {};

/**
 * @param {!jasmine.RunDetails} runDetails
 * @return {void}
 */
jasmine.CustomReporter.prototype.jasmineDone = function(runDetails) {};
/**
 * @record
 * @struct
 */
jasmine.Runner = function() {};

/* TODO: ConstructSignature: jasmine */

/**
 * @return {void}
 */
jasmine.Runner.prototype.execute = function() {};

/**
 * @param {function(!jasmine.Spec): void} beforeEachFunction
 * @return {void}
 */
jasmine.Runner.prototype.beforeEach = function(beforeEachFunction) {};

/**
 * @param {function(!jasmine.Spec): void} afterEachFunction
 * @return {void}
 */
jasmine.Runner.prototype.afterEach = function(afterEachFunction) {};

/**
 * @param {function(!jasmine.Spec): void} beforeAllFunction
 * @return {void}
 */
jasmine.Runner.prototype.beforeAll = function(beforeAllFunction) {};

/**
 * @param {function(!jasmine.Spec): void} afterAllFunction
 * @return {void}
 */
jasmine.Runner.prototype.afterAll = function(afterAllFunction) {};

/**
 * @return {void}
 */
jasmine.Runner.prototype.finishCallback = function() {};

/**
 * @param {!jasmine.Suite} suite
 * @return {void}
 */
jasmine.Runner.prototype.addSuite = function(suite) {};

/**
 * @param {!jasmine.Block} block
 * @return {void}
 */
jasmine.Runner.prototype.add = function(block) {};

/**
 * @return {!Array<!jasmine.Spec>}
 */
jasmine.Runner.prototype.specs = function() {};

/**
 * @return {!Array<!jasmine.Suite>}
 */
jasmine.Runner.prototype.suites = function() {};

/**
 * @return {!Array<!jasmine.Suite>}
 */
jasmine.Runner.prototype.topLevelSuites = function() {};

/**
 * @return {!jasmine.NestedResults}
 */
jasmine.Runner.prototype.results = function() {};

/** @typedef {function(!jasmine.Spec): void} */
jasmine.SpecFunction;
/**
 * @record
 * @struct
 */
jasmine.SuiteOrSpec = function() {};
 /** @type {number} */
jasmine.SuiteOrSpec.prototype.id;
 /** @type {!jasmine.Env} */
jasmine.SuiteOrSpec.prototype.env;
 /** @type {string} */
jasmine.SuiteOrSpec.prototype.description;
 /** @type {!jasmine.Queue} */
jasmine.SuiteOrSpec.prototype.queue;
/**
 * @extends {jasmine.SuiteOrSpec}
 * @record
 * @struct
 */
jasmine.Spec = function() {};

/* TODO: ConstructSignature: jasmine */
 /** @type {!jasmine.Suite} */
jasmine.Spec.prototype.suite;
 /** @type {!Array<function(!jasmine.Spec): void>} */
jasmine.Spec.prototype.afterCallbacks;
 /** @type {!Array<!jasmine.Spy>} */
jasmine.Spec.prototype.spies_;
 /** @type {!jasmine.NestedResults} */
jasmine.Spec.prototype.results_;
 /** @type {!jasmine.Matchers<?>} */
jasmine.Spec.prototype.matchersClass;
 /** @type {boolean} */
jasmine.Spec.prototype.throwOnExpectationFailure;

/**
 * @return {string}
 */
jasmine.Spec.prototype.getFullName = function() {};

/**
 * @return {!jasmine.NestedResults}
 */
jasmine.Spec.prototype.results = function() {};

/**
 * @param {?} tsickle_arguments
 * @return {?}
 */
jasmine.Spec.prototype.log = function(tsickle_arguments) {};

/**
 * @param {function(!jasmine.Spec): void} func
 * @return {!jasmine.Spec}
 */
jasmine.Spec.prototype.runs = function(func) {};

/**
 * @param {!jasmine.Block} block
 * @return {void}
 */
jasmine.Spec.prototype.addToQueue = function(block) {};

/**
 * @param {!jasmine.Result} result
 * @return {void}
 */
jasmine.Spec.prototype.addMatcherResult = function(result) {};

/**
 * @return {?}
 */
jasmine.Spec.prototype.getResult = function() {};

/**
 * @param {?} actual
 * @return {?}
 */
jasmine.Spec.prototype.expect = function(actual) {};

/**
 * @param {number} timeout
 * @return {!jasmine.Spec}
 */
jasmine.Spec.prototype.waits = function(timeout) {};

/**
 * @param {function(!jasmine.Spec): void} latchFunction
 * @param {string=} timeoutMessage
 * @param {number=} timeout
 * @return {!jasmine.Spec}
 */
jasmine.Spec.prototype.waitsFor = function(latchFunction, timeoutMessage, timeout) {};

/**
 * @param {?=} e
 * @return {void}
 */
jasmine.Spec.prototype.fail = function(e) {};

/**
 * @return {!jasmine.Matchers<?>}
 */
jasmine.Spec.prototype.getMatchersClass_ = function() {};

/**
 * @param {!jasmine.CustomMatcherFactories} matchersPrototype
 * @return {void}
 */
jasmine.Spec.prototype.addMatchers = function(matchersPrototype) {};

/**
 * @return {void}
 */
jasmine.Spec.prototype.finishCallback = function() {};

/**
 * @param {function(): void=} onComplete
 * @return {void}
 */
jasmine.Spec.prototype.finish = function(onComplete) {};

/**
 * @param {function(!jasmine.Spec): void} doAfter
 * @return {void}
 */
jasmine.Spec.prototype.after = function(doAfter) {};

/**
 * @param {function(): void=} onComplete
 * @param {boolean=} enabled
 * @return {?}
 */
jasmine.Spec.prototype.execute = function(onComplete, enabled) {};

/**
 * @return {void}
 */
jasmine.Spec.prototype.addBeforesAndAftersToQueue = function() {};

/**
 * @return {void}
 */
jasmine.Spec.prototype.explodes = function() {};

/**
 * @param {?} obj
 * @param {string} methodName
 * @param {boolean} ignoreMethodDoesntExist
 * @return {!jasmine.Spy}
 */
jasmine.Spec.prototype.spyOn = function(obj, methodName, ignoreMethodDoesntExist) {};

/**
 * @param {?} object
 * @param {string} property
 * @param {string} accessType
 * @return {!jasmine.Spy}
 */
jasmine.Spec.prototype.spyOnProperty = function(object, property, accessType) {};

/**
 * @return {void}
 */
jasmine.Spec.prototype.removeAllSpies = function() {};
/**
 * @record
 * @struct
 */
jasmine.XSpec = function() {};
 /** @type {number} */
jasmine.XSpec.prototype.id;

/**
 * @return {void}
 */
jasmine.XSpec.prototype.runs = function() {};
/**
 * @extends {jasmine.SuiteOrSpec}
 * @record
 * @struct
 */
jasmine.Suite = function() {};

/* TODO: ConstructSignature: jasmine */
 /** @type {!jasmine.Suite} */
jasmine.Suite.prototype.parentSuite;

/**
 * @return {string}
 */
jasmine.Suite.prototype.getFullName = function() {};

/**
 * @param {function(): void=} onComplete
 * @return {void}
 */
jasmine.Suite.prototype.finish = function(onComplete) {};

/**
 * @param {function(!jasmine.Spec): void} beforeEachFunction
 * @return {void}
 */
jasmine.Suite.prototype.beforeEach = function(beforeEachFunction) {};

/**
 * @param {function(!jasmine.Spec): void} afterEachFunction
 * @return {void}
 */
jasmine.Suite.prototype.afterEach = function(afterEachFunction) {};

/**
 * @param {function(!jasmine.Spec): void} beforeAllFunction
 * @return {void}
 */
jasmine.Suite.prototype.beforeAll = function(beforeAllFunction) {};

/**
 * @param {function(!jasmine.Spec): void} afterAllFunction
 * @return {void}
 */
jasmine.Suite.prototype.afterAll = function(afterAllFunction) {};

/**
 * @return {!jasmine.NestedResults}
 */
jasmine.Suite.prototype.results = function() {};

/**
 * @param {!jasmine.SuiteOrSpec} suiteOrSpec
 * @return {void}
 */
jasmine.Suite.prototype.add = function(suiteOrSpec) {};

/**
 * @return {!Array<!jasmine.Spec>}
 */
jasmine.Suite.prototype.specs = function() {};

/**
 * @return {!Array<!jasmine.Suite>}
 */
jasmine.Suite.prototype.suites = function() {};

/**
 * @return {!Array<?>}
 */
jasmine.Suite.prototype.children = function() {};

/**
 * @param {function(): void=} onComplete
 * @return {void}
 */
jasmine.Suite.prototype.execute = function(onComplete) {};
/**
 * @record
 * @struct
 */
jasmine.XSuite = function() {};

/**
 * @return {void}
 */
jasmine.XSuite.prototype.execute = function() {};
/**
 * @record
 * @struct
 */
jasmine.Spy = function() {};

/* TODO: CallSignature: jasmine */
 /** @type {string} */
jasmine.Spy.prototype.identity;
 /** @type {!jasmine.SpyAnd} */
jasmine.Spy.prototype.and;
 /** @type {!jasmine.Calls} */
jasmine.Spy.prototype.calls;
 /** @type {{args: !Array<?>}} */
jasmine.Spy.prototype.mostRecentCall;
 /** @type {!Array<?>} */
jasmine.Spy.prototype.argsForCall;

/** @typedef {?} */
jasmine.SpyObj;
/**
 * @record
 * @struct
 */
jasmine.SpyAnd = function() {};

/**
 * By chaining the spy with and.callThrough, the spy will still track all calls to it but in addition it will delegate to the actual implementation.
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.callThrough = function() {};

/**
 * By chaining the spy with and.returnValue, all calls to the function will return a specific value.
 * @param {?} val
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.returnValue = function(val) {};

/**
 * By chaining the spy with and.returnValues, all calls to the function will return specific values in order until it reaches the end of the return values list.
 * @param {...?} values
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.returnValues = function(values) {};

/**
 * By chaining the spy with and.callFake, all calls to the spy will delegate to the supplied function.
 * @param {!Function} fn
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.callFake = function(fn) {};

/**
 * By chaining the spy with and.throwError, all calls to the spy will throw the specified value.
 * @param {string} msg
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.throwError = function(msg) {};

/**
 * When a calling strategy is used for a spy, the original stubbing behavior can be returned at any time with and.stub.
 * @return {!jasmine.Spy}
 */
jasmine.SpyAnd.prototype.stub = function() {};
/**
 * @record
 * @struct
 */
jasmine.Calls = function() {};

/**
 * By chaining the spy with calls.any(), will return false if the spy has not been called at all, and then true once at least one call happens. *
 * @return {boolean}
 */
jasmine.Calls.prototype.any = function() {};

/**
 * By chaining the spy with calls.count(), will return the number of times the spy was called *
 * @return {number}
 */
jasmine.Calls.prototype.count = function() {};

/**
 * By chaining the spy with calls.argsFor(), will return the arguments passed to call number index *
 * @param {number} index
 * @return {!Array<?>}
 */
jasmine.Calls.prototype.argsFor = function(index) {};

/**
 * By chaining the spy with calls.allArgs(), will return the arguments to all calls *
 * @return {!Array<?>}
 */
jasmine.Calls.prototype.allArgs = function() {};

/**
 * By chaining the spy with calls.all(), will return the context (the this) and arguments passed all calls *
 * @return {!Array<!jasmine.CallInfo>}
 */
jasmine.Calls.prototype.all = function() {};

/**
 * By chaining the spy with calls.mostRecent(), will return the context (the this) and arguments for the most recent call *
 * @return {!jasmine.CallInfo}
 */
jasmine.Calls.prototype.mostRecent = function() {};

/**
 * By chaining the spy with calls.first(), will return the context (the this) and arguments for the first call *
 * @return {!jasmine.CallInfo}
 */
jasmine.Calls.prototype.first = function() {};

/**
 * By chaining the spy with calls.reset(), will clears all tracking for a spy *
 * @return {void}
 */
jasmine.Calls.prototype.reset = function() {};
/**
 * @record
 * @struct
 */
jasmine.CallInfo = function() {};
 /** @type {?} */
jasmine.CallInfo.prototype.object;
 /** @type {!Array<?>} */
jasmine.CallInfo.prototype.args;
 /** @type {?} */
jasmine.CallInfo.prototype.returnValue;
/**
 * @record
 * @struct
 */
jasmine.Util = function() {};

/**
 * @param {!Function} childClass
 * @param {!Function} parentClass
 * @return {?}
 */
jasmine.Util.prototype.inherit = function(childClass, parentClass) {};

/**
 * @param {?} e
 * @return {?}
 */
jasmine.Util.prototype.formatException = function(e) {};

/**
 * @param {string} str
 * @return {string}
 */
jasmine.Util.prototype.htmlEscape = function(str) {};

/**
 * @param {?} args
 * @return {?}
 */
jasmine.Util.prototype.argsToArray = function(args) {};

/**
 * @param {?} destination
 * @param {?} source
 * @return {?}
 */
jasmine.Util.prototype.extend = function(destination, source) {};
/**
 * @extends {jasmine.Reporter}
 * @record
 * @struct
 */
jasmine.JsApiReporter = function() {};
 /** @type {boolean} */
jasmine.JsApiReporter.prototype.started;
 /** @type {boolean} */
jasmine.JsApiReporter.prototype.finished;
 /** @type {?} */
jasmine.JsApiReporter.prototype.result;
 /** @type {?} */
jasmine.JsApiReporter.prototype.messages;
 /** @type {!jasmine.RunDetails} */
jasmine.JsApiReporter.prototype.runDetails;

/* TODO: ConstructSignature: jasmine */

/**
 * @return {!Array<!jasmine.Suite>}
 */
jasmine.JsApiReporter.prototype.suites = function() {};

/**
 * @param {!jasmine.SuiteOrSpec} suiteOrSpec
 * @return {?}
 */
jasmine.JsApiReporter.prototype.summarize_ = function(suiteOrSpec) {};

/**
 * @return {?}
 */
jasmine.JsApiReporter.prototype.results = function() {};

/**
 * @param {?} specId
 * @return {?}
 */
jasmine.JsApiReporter.prototype.resultsForSpec = function(specId) {};

/**
 * @param {?} str
 * @return {?}
 */
jasmine.JsApiReporter.prototype.log = function(str) {};

/**
 * @param {?} specIds
 * @return {?}
 */
jasmine.JsApiReporter.prototype.resultsForSpecs = function(specIds) {};

/**
 * @param {?} result
 * @return {?}
 */
jasmine.JsApiReporter.prototype.summarizeResult_ = function(result) {};
/**
 * @record
 * @struct
 */
jasmine.Jasmine = function() {};
 /** @type {!jasmine.Spec} */
jasmine.Jasmine.prototype.Spec;
 /** @type {!jasmine.Clock} */
jasmine.Jasmine.prototype.clock;
 /** @type {!jasmine.Util} */
jasmine.Jasmine.prototype.util;
 /** @type {?} */
jasmine.HtmlReporter;
 /** @type {?} */
jasmine.HtmlSpecFilter;
 /** @type {number} */
jasmine.DEFAULT_TIMEOUT_INTERVAL;
 /** @type {number} */
jasmine.MAX_PRETTY_PRINT_DEPTH;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "jasmine"
/** @const */
tsickle_declare_module.jasmine = {};

/**
 * @constructor
 * @struct
 * @param {?} options
 */
tsickle_declare_module.jasmine.jasmine = function(options) {};
 /** @type {!jasmine.Jasmine} */
tsickle_declare_module.jasmine.jasmine.prototype.jasmine;
 /** @type {!jasmine.Env} */
tsickle_declare_module.jasmine.jasmine.prototype.env;
 /** @type {number} */
tsickle_declare_module.jasmine.jasmine.prototype.reportersCount;
 /** @type {!jasmine.CustomReporter} */
tsickle_declare_module.jasmine.jasmine.prototype.completionReporter;
 /** @type {!jasmine.CustomReporter} */
tsickle_declare_module.jasmine.jasmine.prototype.reporter;
 /** @type {boolean} */
tsickle_declare_module.jasmine.jasmine.prototype.showingColors;
 /** @type {string} */
tsickle_declare_module.jasmine.jasmine.prototype.projectBaseDir;
 /** @type {!Array<string>} */
tsickle_declare_module.jasmine.jasmine.prototype.specFiles;
 /** @type {!Array<string>} */
tsickle_declare_module.jasmine.jasmine.prototype.helperFiles;

/**
 * @param {!jasmine.CustomMatcherFactories} matchers
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.addMatchers = function(matchers) {};

/**
 * @param {!jasmine.Reporter} reporter
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.addReporter = function(reporter) {};

/**
 * @param {string} filePath
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.addSpecFile = function(filePath) {};

/**
 * @param {!Array<string>} files
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.addSpecFiles = function(files) {};

/**
 * @param {?} options
 * @param {...?} args
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.configureDefaultReporter = function(options, args) {};

/**
 * @param {?} files
 * @param {?} filterString
 * @return {?}
 */
tsickle_declare_module.jasmine.jasmine.prototype.execute = function(files, filterString) {};

/**
 * @param {?} passed
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.exitCodeCompletion = function(passed) {};

/**
 * @param {?} config
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.loadConfig = function(config) {};

/**
 * @param {?} configFilePath
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.loadConfigFile = function(configFilePath) {};

/**
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.loadHelpers = function() {};

/**
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.loadSpecs = function() {};

/**
 * @param {function(): void} onCompleteCallback
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.onComplete = function(onCompleteCallback) {};

/**
 * @param {!jasmine.Reporter} reporter
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.provideFallbackReporter = function(reporter) {};

/**
 * @param {?=} value
 * @return {boolean}
 */
tsickle_declare_module.jasmine.jasmine.prototype.randomizeTests = function(value) {};

/**
 * @param {?} value
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.seed = function(value) {};

/**
 * @param {?} value
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.showColors = function(value) {};

/**
 * @param {?} value
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.stopSpecOnExpectationFailure = function(value) {};

/**
 * @return {?}
 */
tsickle_declare_module.jasmine.jasmine.ConsoleReporter = function() {};

/**
 * @return {string}
 */
tsickle_declare_module.jasmine.jasmine.prototype.coreVersion = function() {};

/**
 * @return {void}
 */
tsickle_declare_module.jasmine.jasmine.prototype.printDeprecation = function() {};

/* TODO: ExportAssignment in tsickle_declare_module.jasmine */
