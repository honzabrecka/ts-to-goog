/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/inquirer/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */
/** @const */
var inquirer = {};

/** @typedef {!Object<string,!inquirer.PromptModule>} */
inquirer.Prompts;

/** @typedef {(string|!inquirer.objects.ChoiceOption|!inquirer.objects.Separator)} */
inquirer.ChoiceType;

/** @typedef {(!inquirer.Question|!Array<!inquirer.Question>|?<!inquirer.Question>)} */
inquirer.Questions;
/**
 * @record
 * @struct
 */
inquirer.Inquirer = function() {};
 /** @type {!Object<string,!inquirer.PromptModule>} */
inquirer.Inquirer.prototype.prompts;
 /** @type {!inquirer.objects.SeparatorStatic} */
inquirer.Inquirer.prototype.Separator;
 /** @type {{BottomBar: !inquirer.ui.BottomBar, Prompt: !inquirer.ui.Prompt}} */
inquirer.Inquirer.prototype.ui;

/**
 * @return {void}
 */
inquirer.Inquirer.prototype.restoreDefaultPrompts = function() {};

/**
 * Expose helper functions on the top level for easiest usage by common users
 * @param {string} name
 * @param {!inquirer.PromptModule} prompt
 * @return {void}
 */
inquirer.Inquirer.prototype.registerPrompt = function(name, prompt) {};

/**
 * Create a new self-contained prompt module.
 * @return {!inquirer.PromptModule}
 */
inquirer.Inquirer.prototype.createPromptModule = function() {};

/**
 * Public CLI helper interface
 * @param {(!inquirer.Question|!Array<!inquirer.Question>|?<!inquirer.Question>)} questions Questions settings array
 * @param {function(!inquirer.Answers): ?=} cb Callback being passed the user answers
 * @return {!inquirer.ui.Prompt|!Promise<!inquirer.Answers>}
 */
inquirer.Inquirer.prototype.prompt = function(questions, cb) {};
/**
 * @record
 * @struct
 */
inquirer.PromptModule = function() {};

/* TODO: CallSignature: inquirer */

/* TODO: CallSignature: inquirer */

/**
 * Register a prompt type
 * @param {string} name Prompt type name
 * @param {!inquirer.PromptModule} prompt Prompt constructor
 * @return {!inquirer.ui.Prompt}
 */
inquirer.PromptModule.prototype.registerPrompt = function(name, prompt) {};

/**
 * Register the defaults provider prompts
 * @return {void}
 */
inquirer.PromptModule.prototype.restoreDefaultPrompts = function() {};
/**
 * @record
 * @struct
 */
inquirer.Question = function() {};
 /** @type {string} */
inquirer.Question.prototype.type;
 /** @type {string} */
inquirer.Question.prototype.name;
 /** @type {(string|function(!inquirer.Answers): string)} */
inquirer.Question.prototype.message;
 /** @type {?} */
inquirer.Question.prototype.default;
 /** @type {(!Array<(string|!inquirer.objects.ChoiceOption|!inquirer.objects.Separator)>|function(!inquirer.Answers): !Array<(string|!inquirer.objects.ChoiceOption|!inquirer.objects.Separator)>)} */
inquirer.Question.prototype.choices;
 /** @type {(boolean|function(!inquirer.Answers): boolean)} */
inquirer.Question.prototype.when;
 /** @type {boolean} */
inquirer.Question.prototype.paginated;
 /** @type {number} */
inquirer.Question.prototype.pageSize;
 /** @type {string} */
inquirer.Question.prototype.mask;

/**
 * Receive the user input and should return true if the value is valid, and an error message (String)
 * otherwise. If false is returned, a default error message is provided.
 * @param {string} input
 * @param {!inquirer.Answers=} answers
 * @return {(string|boolean)}
 */
inquirer.Question.prototype.validate = function(input, answers) {};

/**
 * Receive the user input and return the filtered value to be used inside the program.
 * The value returned will be added to the Answers hash.
 * @param {string} input
 * @return {string}
 */
inquirer.Question.prototype.filter = function(input) {};
/**
 * @record
 * @struct
 */
inquirer.Answers = function() {};

/* TODO: IndexSignature: inquirer */
/** @const */
inquirer.ui = {};
/**
 * @extends {inquirer.ui.BaseUI}
 * @record
 * @struct
 */
inquirer.ui.Prompt = function() {};

/* TODO: ConstructSignature: inquirer.ui */

/**
 * Once all prompt are over
 * @return {void}
 */
inquirer.ui.Prompt.prototype.onCompletion = function() {};

/**
 * @param {!inquirer.Question} question
 * @return {?}
 */
inquirer.ui.Prompt.prototype.processQuestion = function(question) {};

/**
 * @param {!inquirer.Question} question
 * @return {?}
 */
inquirer.ui.Prompt.prototype.fetchAnswer = function(question) {};

/**
 * @param {!inquirer.Question} question
 * @return {?}
 */
inquirer.ui.Prompt.prototype.setDefaultType = function(question) {};

/**
 * @param {!inquirer.Question} question
 * @return {?}
 */
inquirer.ui.Prompt.prototype.filterIfRunnable = function(question) {};
/**
 * @extends {inquirer.ui.BaseUI}
 * @record
 * @struct
 */
inquirer.ui.BottomBar = function() {};

/* TODO: ConstructSignature: inquirer.ui */
 /** @type {!through.ThroughStream} */
inquirer.ui.BottomBar.prototype.log;

/**
 * Render the prompt to screen
 * @return {!inquirer.ui.BottomBar} self
 */
inquirer.ui.BottomBar.prototype.render = function() {};

/**
 * Update the bottom bar content and rerender
 * @param {string} bottomBar Bottom bar content
 * @return {!inquirer.ui.BottomBar} self
 */
inquirer.ui.BottomBar.prototype.updateBottomBar = function(bottomBar) {};

/**
 * Rerender the prompt
 * @param {?} data
 * @return {!inquirer.ui.BottomBar} self
 */
inquirer.ui.BottomBar.prototype.writeLog = function(data) {};

/**
 * Make sure line end on a line feed
 * @param {string} str Input string
 * @return {string} The input string with a final line feed
 */
inquirer.ui.BottomBar.prototype.enforceLF = function(str) {};

/**
 * Helper for writing message in Prompt
 * @param {string} message The message to be output
 * @return {void}
 */
inquirer.ui.BottomBar.prototype.write = function(message) {};
/**
 * @record
 * @struct
 */
inquirer.ui.BottomBarOption = function() {};
 /** @type {string} */
inquirer.ui.BottomBarOption.prototype.bottomBar;
/**
 * @record
 * @struct
 */
inquirer.ui.BaseUI = function() {};

/* TODO: ConstructSignature: inquirer.ui */

/**
 * Handle the ^C exit
 * @return {void}
 */
inquirer.ui.BaseUI.prototype.onForceClose = function() {};

/**
 * Close the interface and cleanup listeners
 * @return {void}
 */
inquirer.ui.BaseUI.prototype.close = function() {};

/**
 * Handle and propagate keypress events
 * @param {string} s
 * @param {!inquirer.ui.Key} key
 * @return {void}
 */
inquirer.ui.BaseUI.prototype.onKeypress = function(s, key) {};
/**
 * @record
 * @struct
 */
inquirer.ui.Key = function() {};
 /** @type {string} */
inquirer.ui.Key.prototype.sequence;
 /** @type {string} */
inquirer.ui.Key.prototype.name;
 /** @type {boolean} */
inquirer.ui.Key.prototype.meta;
 /** @type {boolean} */
inquirer.ui.Key.prototype.shift;
 /** @type {boolean} */
inquirer.ui.Key.prototype.ctrl;
/** @const */
inquirer.objects = {};
/**
 * @record
 * @struct
 */
inquirer.objects.Choice = function() {};

/* TODO: ConstructSignature: inquirer.objects */

/* TODO: ConstructSignature: inquirer.objects */

/* TODO: ConstructSignature: inquirer.objects */
/**
 * @record
 * @struct
 */
inquirer.objects.ChoiceOption = function() {};
 /** @type {string} */
inquirer.objects.ChoiceOption.prototype.name;
 /** @type {string} */
inquirer.objects.ChoiceOption.prototype.value;
 /** @type {string} */
inquirer.objects.ChoiceOption.prototype.type;
 /** @type {?} */
inquirer.objects.ChoiceOption.prototype.extra;
 /** @type {string} */
inquirer.objects.ChoiceOption.prototype.key;
 /** @type {boolean} */
inquirer.objects.ChoiceOption.prototype.checked;
 /** @type {(string|function(!inquirer.Answers): ?)} */
inquirer.objects.ChoiceOption.prototype.disabled;
/**
 * @record
 * @struct
 */
inquirer.objects.Choices = function() {};

/* TODO: ConstructSignature: inquirer.objects */
 /** @type {!Array<!inquirer.objects.Choice>} */
inquirer.objects.Choices.prototype.choices;
 /** @type {!Array<!inquirer.objects.Choice>} */
inquirer.objects.Choices.prototype.realChoices;
 /** @type {number} */
inquirer.objects.Choices.prototype.length;
 /** @type {number} */
inquirer.objects.Choices.prototype.realLength;

/**
 * Get a valid choice from the collection
 * @param {number} selector The selected choice index
 * @return {!inquirer.objects.Choice} Return the matched choice or undefined
 */
inquirer.objects.Choices.prototype.getChoice = function(selector) {};

/**
 * Get a raw element from the collection
 * @param {number} selector The selected index value
 * @return {!inquirer.objects.Choice} Return the matched choice or undefined
 */
inquirer.objects.Choices.prototype.get = function(selector) {};

/**
 * Match the valid choices against a where clause
 * @template U
 * @param {U} whereClause Lodash `where` clause
 * @return {!Array<!inquirer.objects.Choice>} Matching choices or empty array
 */
inquirer.objects.Choices.prototype.where = function(whereClause) {};

/**
 * Pluck a particular key from the choices
 * @param {string} propertyName Property name to select
 * @return {!Array<?>} Selected properties
 */
inquirer.objects.Choices.prototype.pluck = function(propertyName) {};

/**
 * @template T
 * @param {function(!inquirer.objects.Choice): T} application
 * @return {!Array<T>}
 */
inquirer.objects.Choices.prototype.forEach = function(application) {};
/**
 * @record
 * @struct
 */
inquirer.objects.SeparatorStatic = function() {};

/* TODO: ConstructSignature: inquirer.objects */

/**
 * Helper function returning false if object is a separator
 * @param {?} obj object to test against
 * @return {boolean} `false` if object is a separator
 */
inquirer.objects.SeparatorStatic.prototype.exclude = function(obj) {};
/**
 * @record
 * @struct
 */
inquirer.objects.Separator = function() {};
 /** @type {string} */
inquirer.objects.Separator.prototype.type;
 /** @type {string} */
inquirer.objects.Separator.prototype.line;

/**
 * Stringify separator
 * @return {string}
 */
inquirer.objects.Separator.prototype.toString = function() {};
 /** @type {!inquirer.Inquirer} */
var inquirer;

/* TODO: ExportAssignment in  */
