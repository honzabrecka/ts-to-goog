/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bitcoinjs-lib/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */
/**
 * @record
 * @struct
 */
function Output() {}
 /** @type {?} */
Output.prototype.script;
 /** @type {number} */
Output.prototype.value;
/**
 * @record
 * @struct
 */
function Input() {}
 /** @type {?} */
Input.prototype.script;
 /** @type {?} */
Input.prototype.hash;
 /** @type {number} */
Input.prototype.index;
 /** @type {number} */
Input.prototype.sequence;
/**
 * @record
 * @struct
 */
function Network() {}
 /** @type {?} */
Network.prototype.bip32;
 /** @type {string} */
Network.prototype.messagePrefix;
 /** @type {number} */
Network.prototype.pubKeyHash;
 /** @type {number} */
Network.prototype.scriptHash;
 /** @type {number} */
Network.prototype.wif;

/**
 * @constructor
 * @struct
 */
function Block() {}

/**
 * @param {boolean=} headersOnly
 * @return {number}
 */
Block.prototype.byteLength = function(headersOnly) {};

/**
 * @return {?}
 */
Block.prototype.checkMerkleRoot = function() {};

/**
 * @return {?}
 */
Block.prototype.checkProofOfWork = function() {};

/**
 * @return {?}
 */
Block.prototype.getHash = function() {};

/**
 * @return {string}
 */
Block.prototype.getId = function() {};

/**
 * @return {?}
 */
Block.prototype.getUTCDate = function() {};

/**
 * @param {boolean=} headersOnly
 * @return {?}
 */
Block.prototype.toBuffer = function(headersOnly) {};

/**
 * @param {boolean=} headersOnly
 * @return {string}
 */
Block.prototype.toHex = function(headersOnly) {};

/**
 * @param {!Array<?>} transactions
 * @return {?}
 */
Block.calculateMerkleRoot = function(transactions) {};

/**
 * @param {number} bits
 * @return {?}
 */
Block.calculateTarget = function(bits) {};

/**
 * @param {?} buffer
 * @return {?}
 */
Block.fromBuffer = function(buffer) {};

/**
 * @param {string} hex
 * @return {?}
 */
Block.fromHex = function(hex) {};

/**
 * @constructor
 * @struct
 * @param {!bigi|null} d
 * @param {null|?=} Q
 * @param {?=} options
 */
function ECPair(d, Q, options) {}

/**
 * @return {string}
 */
ECPair.prototype.getAddress = function() {};

/**
 * @return {?}
 */
ECPair.prototype.getNetwork = function() {};

/**
 * @return {?}
 */
ECPair.prototype.getPublicKeyBuffer = function() {};

/**
 * @param {?} hash
 * @return {?}
 */
ECPair.prototype.sign = function(hash) {};

/**
 * @return {string}
 */
ECPair.prototype.toWIF = function() {};

/**
 * @param {?} hash
 * @param {?} signature
 * @return {boolean}
 */
ECPair.prototype.verify = function(hash, signature) {};

/**
 * @param {?} buffer
 * @param {?} network
 * @return {?}
 */
ECPair.fromPublicKeyBuffer = function(buffer, network) {};

/**
 * @param {string} string
 * @param {?} network
 * @return {?}
 */
ECPair.fromWIF = function(string, network) {};

/**
 * @param {?=} options
 * @return {?}
 */
ECPair.makeRandom = function(options) {};

/** @typedef {?} */
var Rng;

/**
 * @constructor
 * @struct
 * @param {!bigi} r
 * @param {!bigi} s
 */
function ECSignature(r, s) {}

/**
 * @param {number} i
 * @param {boolean} compressed
 * @return {?}
 */
ECSignature.prototype.toCompact = function(i, compressed) {};

/**
 * @return {?}
 */
ECSignature.prototype.toDER = function() {};

/**
 * @param {number} hashType
 * @return {?}
 */
ECSignature.prototype.toScriptSignature = function(hashType) {};

/**
 * @param {?} buffer
 * @return {?}
 */
ECSignature.fromDER = function(buffer) {};

/**
 * @param {?} buffer
 * @return {?}
 */
ECSignature.parseCompact = function(buffer) {};

/**
 * @param {?} buffer
 * @return {?}
 */
ECSignature.parseScriptSignature = function(buffer) {};

/**
 * @constructor
 * @struct
 * @param {?} keyPair
 * @param {?} chainCode
 */
function HDNode(keyPair, chainCode) {}
 /** @type {?} */
HDNode.prototype.keyPair;
 /** @type {number} */
HDNode.HIGHEST_BIT;
 /** @type {number} */
HDNode.LENGTH;
 /** @type {?} */
HDNode.MASTER_SECRET;

/**
 * @param {number} index
 * @return {?}
 */
HDNode.prototype.derive = function(index) {};

/**
 * @param {number} index
 * @return {?}
 */
HDNode.prototype.deriveHardened = function(index) {};

/**
 * @param {string} path
 * @return {?}
 */
HDNode.prototype.derivePath = function(path) {};

/**
 * @return {string}
 */
HDNode.prototype.getAddress = function() {};

/**
 * @return {?}
 */
HDNode.prototype.getFingerprint = function() {};

/**
 * @return {?}
 */
HDNode.prototype.getIdentifier = function() {};

/**
 * @return {?}
 */
HDNode.prototype.getNetwork = function() {};

/**
 * @return {?}
 */
HDNode.prototype.getPublicKeyBuffer = function() {};

/**
 * @return {boolean}
 */
HDNode.prototype.isNeutered = function() {};

/**
 * @return {?}
 */
HDNode.prototype.neutered = function() {};

/**
 * @param {?} hash
 * @return {?}
 */
HDNode.prototype.sign = function(hash) {};

/**
 * @return {string}
 */
HDNode.prototype.toBase58 = function() {};

/**
 * @param {?} hash
 * @param {?} signature
 * @return {?}
 */
HDNode.prototype.verify = function(hash, signature) {};

/**
 * @param {string} string
 * @param {(?|!Array<?>)=} networks
 * @return {?}
 */
HDNode.fromBase58 = function(string, networks) {};

/**
 * @param {?} seed
 * @param {?=} network
 * @return {?}
 */
HDNode.fromSeedBuffer = function(seed, network) {};

/**
 * @param {string} hex
 * @param {?=} network
 * @return {?}
 */
HDNode.fromSeedHex = function(hex, network) {};

/**
 * @constructor
 * @struct
 */
function Transaction() {}
 /** @type {number} */
Transaction.prototype.version;
 /** @type {number} */
Transaction.prototype.locktime;
 /** @type {!Array<?>} */
Transaction.prototype.ins;
 /** @type {!Array<?>} */
Transaction.prototype.outs;
 /** @type {number} */
Transaction.ADVANCED_TRANSACTION_FLAG;
 /** @type {number} */
Transaction.ADVANCED_TRANSACTION_MARKER;
 /** @type {number} */
Transaction.DEFAULT_SEQUENCE;
 /** @type {number} */
Transaction.SIGHASH_ALL;
 /** @type {number} */
Transaction.SIGHASH_ANYONECANPAY;
 /** @type {number} */
Transaction.SIGHASH_NONE;
 /** @type {number} */
Transaction.SIGHASH_SINGLE;

/**
 * @param {?} hash
 * @param {number} index
 * @param {number=} sequence
 * @param {?=} scriptSig
 * @return {number}
 */
Transaction.prototype.addInput = function(hash, index, sequence, scriptSig) {};

/**
 * @param {(string|?)} scriptPubKey
 * @param {number} value
 * @return {number}
 */
Transaction.prototype.addOutput = function(scriptPubKey, value) {};

/**
 * @return {number}
 */
Transaction.prototype.byteLength = function() {};

/**
 * @return {?}
 */
Transaction.prototype.clone = function() {};

/**
 * @return {?}
 */
Transaction.prototype.getHash = function() {};

/**
 * @return {string}
 */
Transaction.prototype.getId = function() {};

/**
 * @return {boolean}
 */
Transaction.prototype.hasWitnesses = function() {};

/**
 * @param {number} inIndex
 * @param {?} prevOutScript
 * @param {number} hashType
 * @return {?}
 */
Transaction.prototype.hashForSignature = function(inIndex, prevOutScript, hashType) {};

/**
 * @param {number} inIndex
 * @param {?} prevOutScript
 * @param {number} value
 * @param {number} hashType
 * @return {?}
 */
Transaction.prototype.hashForWitnessV0 = function(inIndex, prevOutScript, value, hashType) {};

/**
 * @return {boolean}
 */
Transaction.prototype.isCoinbase = function() {};

/**
 * @param {number} index
 * @param {?} scriptSig
 * @return {void}
 */
Transaction.prototype.setInputScript = function(index, scriptSig) {};

/**
 * @param {number} index
 * @param {?} witness
 * @param {...?} args
 * @return {void}
 */
Transaction.prototype.setWitness = function(index, witness, args) {};

/**
 * @param {?=} buffer
 * @param {number=} initialOffset
 * @return {?}
 */
Transaction.prototype.toBuffer = function(buffer, initialOffset) {};

/**
 * @return {string}
 */
Transaction.prototype.toHex = function() {};

/**
 * @param {?} buffer
 * @param {boolean=} __noStrict
 * @return {?}
 */
Transaction.fromBuffer = function(buffer, __noStrict) {};

/**
 * @param {string} hex
 * @return {?}
 */
Transaction.fromHex = function(hex) {};

/**
 * @param {?} buffer
 * @return {boolean}
 */
Transaction.isCoinbaseHash = function(buffer) {};

/**
 * @constructor
 * @struct
 * @param {?=} network
 * @param {number=} maximumFeeRate
 */
function TransactionBuilder(network, maximumFeeRate) {}

/**
 * @param {(string|?)} txhash
 * @param {number} vout
 * @param {number=} sequence
 * @param {?=} prevOutScript
 * @return {number}
 */
TransactionBuilder.prototype.addInput = function(txhash, vout, sequence, prevOutScript) {};

/**
 * @param {(string|?)} scriptPubKey
 * @param {number} value
 * @return {number}
 */
TransactionBuilder.prototype.addOutput = function(scriptPubKey, value) {};

/**
 * @return {?}
 */
TransactionBuilder.prototype.build = function() {};

/**
 * @return {?}
 */
TransactionBuilder.prototype.buildIncomplete = function() {};

/**
 * @param {number} locktime
 * @return {void}
 */
TransactionBuilder.prototype.setLockTime = function(locktime) {};

/**
 * @param {number} version
 * @return {void}
 */
TransactionBuilder.prototype.setVersion = function(version) {};

/**
 * @param {number} vin
 * @param {?} keyPair
 * @param {?=} redeemScript
 * @param {number=} hashType
 * @param {number=} witnessValue
 * @param {?=} witnessScript
 * @return {void}
 */
TransactionBuilder.prototype.sign = function(vin, keyPair, redeemScript, hashType, witnessValue, witnessScript) {};

/**
 * @param {?} transaction
 * @param {?} network
 * @return {?}
 */
TransactionBuilder.fromTransaction = function(transaction, network) {};
 /** @type {?} */
var networks;
 /** @type {?} */
var opcodes;
/** @const */
var address = {};

/**
 * @param {string} address
 * @return {?}
 */
address.fromBase58Check = function(address) {};

/**
 * @param {?} outputScript
 * @param {?=} network
 * @return {?}
 */
address.fromOutputScript = function(outputScript, network) {};

/**
 * @param {?} hash
 * @param {number} version
 * @return {string}
 */
address.toBase58Check = function(hash, version) {};

/**
 * @param {string} address
 * @param {?=} network
 * @return {string}
 */
address.toOutputScript = function(address, network) {};
/** @const */
var bufferutils = {};

/**
 * @param {number} i
 * @return {number}
 */
bufferutils.pushDataSize = function(i) {};

/**
 * @param {?} buffer
 * @param {number} offset
 * @return {?}
 */
bufferutils.readPushDataInt = function(buffer, offset) {};

/**
 * @param {?} buffer
 * @param {number} offset
 * @return {number}
 */
bufferutils.readUInt64LE = function(buffer, offset) {};

/**
 * @param {?} buffer
 * @param {number} offset
 * @return {?}
 */
bufferutils.readVarInt = function(buffer, offset) {};

/**
 * @param {number} number
 * @param {?} buffer
 * @param {number} offset
 * @return {?}
 */
bufferutils.varIntBuffer = function(number, buffer, offset) {};

/**
 * @param {number} number
 * @return {number}
 */
bufferutils.varIntSize = function(number) {};

/**
 * @param {?} buffer
 * @param {number} number
 * @param {number} offset
 * @return {number}
 */
bufferutils.writePushDataInt = function(buffer, number, offset) {};

/**
 * @param {?} buffer
 * @param {number} value
 * @param {number} offset
 * @return {number}
 */
bufferutils.writeUInt64LE = function(buffer, value, offset) {};

/**
 * @param {?} buffer
 * @param {number} number
 * @param {number} offset
 * @return {number}
 */
bufferutils.writeVarInt = function(buffer, number, offset) {};
/** @const */
var crypto = {};

/**
 * @param {?} buffer
 * @return {?}
 */
crypto.hash160 = function(buffer) {};

/**
 * @param {?} buffer
 * @return {?}
 */
crypto.hash256 = function(buffer) {};

/**
 * @param {?} buffer
 * @return {?}
 */
crypto.ripemd160 = function(buffer) {};

/**
 * @param {?} buffer
 * @return {?}
 */
crypto.sha1 = function(buffer) {};

/**
 * @param {?} buffer
 * @return {?}
 */
crypto.sha256 = function(buffer) {};
/** @const */
var script = {};

/**
 * @param {(?|!Array<(number|?)>)} script
 * @param {boolean=} allowIncomplete
 * @return {string}
 */
script.classifyInput = function(script, allowIncomplete) {};

/**
 * @param {(?|!Array<(number|?)>)} script
 * @return {string}
 */
script.classifyOutput = function(script) {};

/**
 * @param {(?|!Array<(number|?)>)} script
 * @param {boolean} allowIncomplete
 * @return {string}
 */
script.classifyWitness = function(script, allowIncomplete) {};

/**
 * @param {!Array<(number|?)>} chunks
 * @return {?}
 */
script.compile = function(chunks) {};

/**
 * @param {?} buffer
 * @return {!Array<(number|?)>}
 */
script.decompile = function(buffer) {};

/**
 * @param {string} asm
 * @return {?}
 */
script.fromASM = function(asm) {};

/**
 * @param {?} buffer
 * @return {boolean}
 */
script.isCanonicalPubKey = function(buffer) {};

/**
 * @param {?} buffer
 * @return {boolean}
 */
script.isCanonicalSignature = function(buffer) {};

/**
 * @param {?} hashType
 * @return {boolean}
 */
script.isDefinedHashType = function(hashType) {};

/**
 * @param {?} value
 * @return {boolean}
 */
script.isPushOnly = function(value) {};

/**
 * @param {(?|!Array<(number|?)>)} chunks
 * @return {string}
 */
script.toASM = function(chunks) {};

/**
 * @param {(?|!Array<(number|?)>)} chunks
 * @return {!Array<?>}
 */
script.toStack = function(chunks) {};
/** @const */
script.number = {};

/**
 * @param {?} buffer
 * @param {number} maxLength
 * @param {boolean} minimal
 * @return {number}
 */
script.number.decode = function(buffer, maxLength, minimal) {};

/**
 * @param {number} number
 * @return {?}
 */
script.number.encode = function(number) {};
 /** @type {?} */
script.multisig;
 /** @type {?} */
script.pubKey;
 /** @type {?} */
script.pubKeyHash;
 /** @type {?} */
script.scriptHash;
 /** @type {?} */
script.witnessCommitment;
 /** @type {?} */
script.witnessPubKeyHash;
 /** @type {?} */
script.witnessScriptHash;
 /** @type {?} */
script.nullData;
