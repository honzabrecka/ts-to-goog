/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/observe-js/index.d.ts:
/** @const */
var observejs = {};
/**
 * @record
 * @struct
 */
observejs.Observable = function() {};

/**
 * Begins observation.
 * @param {function(?, ?): ?} onChange the function that gets invoked if a change is detected
 * @param {?=} receiver
 * @return {void}
 */
observejs.Observable.prototype.open = function(onChange, receiver) {};

/**
 * Report any changes now (does nothing if there are no changes to report).
 * @return {void}
 */
observejs.Observable.prototype.deliver = function() {};

/**
 * If there are changes to report, ignore them. Returns the current value of the observation.
 * @return {void}
 */
observejs.Observable.prototype.discardChanges = function() {};

/**
 * Ends observation. Frees resources and drops references to observed objects.
 * @return {void}
 */
observejs.Observable.prototype.close = function() {};
/**
 * @record
 * @struct
 */
observejs.PathObserver_static = function() {};

/* TODO: ConstructSignature: observejs */
/**
 * @extends {observejs.Observable}
 * @record
 * @struct
 */
observejs.PathObserver_instance = function() {};

/**
 * sets the observed value without notifying about the change.
 * @param {?} value the value to set
 * @return {void}
 */
observejs.PathObserver_instance.prototype.setValue = function(value) {};
 /** @type {!observejs.PathObserver_static} */
observejs.PathObserver;
/**
 * @record
 * @struct
 */
observejs.splice = function() {};
 /** @type {number} */
observejs.splice.prototype.index;
 /** @type {!Array<?>} */
observejs.splice.prototype.removed;
 /** @type {number} */
observejs.splice.prototype.addedCount;
/**
 * @record
 * @struct
 */
observejs.ArrayObserver_static = function() {};

/* TODO: ConstructSignature: observejs */

/**
 * transforms a copy of an old state of an array into a copy of its current state.
 * @param {!Array<?>} previous array of old state
 * @param {!Array<?>} current array of current state
 * @param {!Array<!observejs.splice>} splices  splices to apply
 * @return {void}
 */
observejs.ArrayObserver_static.prototype.applySplices = function(previous, current, splices) {};
/**
 * @extends {observejs.Observable}
 * @record
 * @struct
 */
observejs.ArrayObserver_instance = function() {};

/**
 * @param {function(!Array<!observejs.splice>, !Array<!observejs.splice>): ?} onChange
 * @return {void}
 */
observejs.ArrayObserver_instance.prototype.open = function(onChange) {};
 /** @type {!observejs.ArrayObserver_static} */
observejs.ArrayObserver;
/**
 * @record
 * @struct
 */
observejs.Properties = function() {};

/* TODO: IndexSignature: observejs */
/**
 * @record
 * @struct
 */
observejs.ObjectObserver_static = function() {};

/* TODO: ConstructSignature: observejs */
/**
 * @extends {observejs.Observable}
 * @record
 * @struct
 */
observejs.ObjectObserver_instance = function() {};

/**
 * @param {function(!observejs.Properties, !observejs.Properties, !observejs.Properties, function(string): ?): ?} onChange
 * @return {void}
 */
observejs.ObjectObserver_instance.prototype.open = function(onChange) {};
 /** @type {!observejs.ObjectObserver_static} */
observejs.ObjectObserver;
/**
 * @record
 * @struct
 */
observejs.CompoundObserver_static = function() {};

/* TODO: ConstructSignature: observejs */
/**
 * @extends {observejs.Observable}
 * @record
 * @struct
 */
observejs.CompoundObserver_instance = function() {};

/**
 * @param {function(!Array<?>, !Array<?>): ?} onChange
 * @return {void}
 */
observejs.CompoundObserver_instance.prototype.open = function(onChange) {};

/**
 * Adds the receivers property at the specified path to the list of observables.
 * @param {?} receiver the target for observation
 * @param {string} path specifies the paht to observe. If path === '' the receiver itself gets observed.
 * @return {void}
 */
observejs.CompoundObserver_instance.prototype.addPath = function(receiver, path) {};

/**
 * Adds an Observer to the list of observables.
 * @param {!observejs.Observable} observer
 * @return {void}
 */
observejs.CompoundObserver_instance.prototype.addObserver = function(observer) {};
 /** @type {!observejs.CompoundObserver_static} */
observejs.CompoundObserver;
/**
 * @record
 * @struct
 */
observejs.ObserverTransform_static = function() {};

/* TODO: ConstructSignature: observejs */

/* TODO: ConstructSignature: observejs */
/**
 * @extends {observejs.Observable}
 * @record
 * @struct
 */
observejs.ObserverTransform_instance = function() {};

/**
 * sets the observed value without notifying about the change.
 * @param {?} value the value to set
 * @return {void}
 */
observejs.ObserverTransform_instance.prototype.setValue = function(value) {};
 /** @type {!observejs.ObserverTransform_static} */
observejs.ObserverTransform;
/**
 * @record
 * @struct
 */
observejs.Path = function() {};

/**
 * Returns the current value of the path from the provided object. If eval() is available,
 * a compiled getter will be used for better performance. Like PathObserver above, undefined
 * is returned unless you provide an overriding defaultValue.
 * Attempts to set the value of the path from the provided object. Returns true IFF the path
 * was reachable and set.
 * @param {?} object
 * @param {?} defaultValue_or_newValue
 * @return {?}
 */
observejs.Path.prototype.getValueFrom = function(object, defaultValue_or_newValue) {};
 /** @type {!observejs.PathObserver_static} */
var PathObserver;
 /** @type {!observejs.ArrayObserver_static} */
var ArrayObserver;
 /** @type {!observejs.ObjectObserver_static} */
var ObjectObserver;
 /** @type {!observejs.CompoundObserver_static} */
var CompoundObserver;
 /** @type {!observejs.ObserverTransform_static} */
var ObserverTransform;
 /** @type {!observejs.Path} */
var Path;

/* TODO: ExportDeclaration in  */
