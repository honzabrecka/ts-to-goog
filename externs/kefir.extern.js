/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/kefir/index.d.ts:
/**
 * @record
 * @struct
 */
function Subscription() {}
 /** @type {boolean} */
Subscription.prototype.closed;

/**
 * @return {void}
 */
Subscription.prototype.unsubscribe = function() {};
/**
 * @record
 * @struct
 */
function Observer() {}
 /** @type {?} */
Observer.prototype.value;
 /** @type {?} */
Observer.prototype.error;
 /** @type {?} */
Observer.prototype.end;
 /** @type {boolean} */
Subscription.prototype.closed;

/**
 * @return {void}
 */
Subscription.prototype.unsubscribe = function() {};
 /** @type {?} */
Observer.prototype.value;
 /** @type {?} */
Observer.prototype.error;
 /** @type {?} */
Observer.prototype.end;
/**
 * @record
 * @struct
 */
function Observable() {}

/**
 * @param {?} callback
 * @return {void}
 */
Observable.prototype.onValue = function(callback) {};

/**
 * @param {?} callback
 * @return {void}
 */
Observable.prototype.offValue = function(callback) {};

/**
 * @param {?} callback
 * @return {void}
 */
Observable.prototype.onError = function(callback) {};

/**
 * @param {?} callback
 * @return {void}
 */
Observable.prototype.offError = function(callback) {};

/**
 * @param {?} callback
 * @return {void}
 */
Observable.prototype.onEnd = function(callback) {};

/**
 * @param {?} callback
 * @return {void}
 */
Observable.prototype.offEnd = function(callback) {};

/**
 * @param {?} callback
 * @return {void}
 */
Observable.prototype.onAny = function(callback) {};

/**
 * @param {?} callback
 * @return {void}
 */
Observable.prototype.offAny = function(callback) {};

/**
 * @param {string=} name
 * @return {void}
 */
Observable.prototype.log = function(name) {};

/**
 * @param {string=} name
 * @return {void}
 */
Observable.prototype.offLog = function(name) {};

/**
 * @template U
 * @param {?=} transformer
 * @return {?}
 */
Observable.prototype.flatten = function(transformer) {};

/**
 * @param {?=} PromiseConstructor
 * @return {?}
 */
Observable.prototype.toPromise = function(PromiseConstructor) {};

/**
 * @return {?}
 */
Observable.prototype.toESObservable = function() {};

/**
 * @param {?=} params_or_onValue
 * @param {?=} onError
 * @param {?=} onEnd
 * @return {?}
 */
Observable.prototype.observe = function(params_or_onValue, onError, onEnd) {};
/**
 * @extends {Observable}
 * @record
 * @struct
 */
function Stream() {}

/**
 * @param {?=} getCurrent
 * @return {?}
 */
Stream.prototype.toProperty = function(getCurrent) {};

/**
 * @template U
 * @param {?} fn
 * @return {?}
 */
Stream.prototype.map = function(fn) {};

/**
 * @param {?=} predicate
 * @return {?}
 */
Stream.prototype.filter = function(predicate) {};

/**
 * @param {number} n
 * @return {?}
 */
Stream.prototype.take = function(n) {};

/**
 * @param {?=} predicate
 * @return {?}
 */
Stream.prototype.takeWhile = function(predicate) {};

/**
 * @return {?}
 */
Stream.prototype.last = function() {};

/**
 * @param {number} n
 * @return {?}
 */
Stream.prototype.skip = function(n) {};

/**
 * @param {?=} predicate
 * @return {?}
 */
Stream.prototype.skipWhile = function(predicate) {};

/**
 * @param {?=} comparator
 * @return {?}
 */
Stream.prototype.skipDuplicates = function(comparator) {};

/**
 * @param {?=} fn
 * @param {?=} seed
 * @return {?}
 */
Stream.prototype.diff = function(fn, seed) {};

/**
 * @param {?} fn
 * @param {?=} seed
 * @return {?}
 */
Stream.prototype.scan = function(fn, seed) {};

/**
 * @param {number} wait
 * @return {?}
 */
Stream.prototype.delay = function(wait) {};

/**
 * @param {number} wait
 * @param {?=} options
 * @return {?}
 */
Stream.prototype.throttle = function(wait, options) {};

/**
 * @param {number} wait
 * @param {?=} options
 * @return {?}
 */
Stream.prototype.debounce = function(wait, options) {};

/**
 * @template U
 * @param {?=} handler
 * @return {?}
 */
Stream.prototype.valuesToErrors = function(handler) {};

/**
 * @template U
 * @param {?=} handler
 * @return {?}
 */
Stream.prototype.errorsToValues = function(handler) {};

/**
 * @template U
 * @param {?} fn
 * @return {?}
 */
Stream.prototype.mapErrors = function(fn) {};

/**
 * @param {?=} predicate
 * @return {?}
 */
Stream.prototype.filterErrors = function(predicate) {};

/**
 * @return {?}
 */
Stream.prototype.endOnError = function() {};

/**
 * @param {number} n
 * @return {?}
 */
Stream.prototype.takeErrors = function(n) {};

/**
 * @return {?}
 */
Stream.prototype.ignoreValues = function() {};

/**
 * @return {?}
 */
Stream.prototype.ignoreErrors = function() {};

/**
 * @return {?}
 */
Stream.prototype.ignoreEnd = function() {};

/**
 * @template U
 * @param {?} fn
 * @return {?}
 */
Stream.prototype.beforeEnd = function(fn) {};

/**
 * @param {number} max
 * @param {number=} mix
 * @return {?}
 */
Stream.prototype.slidingWindow = function(max, mix) {};

/**
 * @param {?} predicate
 * @return {?}
 */
Stream.prototype.bufferWhile = function(predicate) {};

/**
 * @param {number} count
 * @param {?=} options
 * @return {?}
 */
Stream.prototype.bufferWithCount = function(count, options) {};

/**
 * @param {number} interval
 * @param {number} count
 * @param {?=} options
 * @return {?}
 */
Stream.prototype.bufferWithTimeOrCount = function(interval, count, options) {};

/**
 * @template U
 * @param {?} transducer
 * @return {?}
 */
Stream.prototype.transduce = function(transducer) {};

/**
 * @template U, V
 * @param {?} handler
 * @return {?}
 */
Stream.prototype.withHandler = function(handler) {};

/**
 * @template U, V, W
 * @param {?} otherObs
 * @param {?=} combinator
 * @return {?}
 */
Stream.prototype.combine = function(otherObs, combinator) {};

/**
 * @template U, V, W
 * @param {?} otherObs
 * @param {?=} combinator
 * @return {?}
 */
Stream.prototype.zip = function(otherObs, combinator) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Stream.prototype.merge = function(otherObs) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Stream.prototype.concat = function(otherObs) {};

/**
 * @template U, V
 * @param {?} transform
 * @return {?}
 */
Stream.prototype.flatMap = function(transform) {};

/**
 * @template U, V
 * @param {?} fn
 * @return {?}
 */
Stream.prototype.flatMapLatest = function(fn) {};

/**
 * @template U, V
 * @param {?} fn
 * @return {?}
 */
Stream.prototype.flatMapFirst = function(fn) {};

/**
 * @template U, V
 * @param {?} fn
 * @return {?}
 */
Stream.prototype.flatMapConcat = function(fn) {};

/**
 * @template U, V
 * @param {?} fn
 * @param {number} limit
 * @return {?}
 */
Stream.prototype.flatMapConcurLimit = function(fn, limit) {};

/**
 * @template U, V
 * @param {?} transform
 * @return {?}
 */
Stream.prototype.flatMapErrors = function(transform) {};

/**
 * @template U
 * @param {?} otherObs
 * @return {?}
 */
Stream.prototype.filterBy = function(otherObs) {};

/**
 * @template U, V, W
 * @param {?} otherObs
 * @param {?=} combinator
 * @return {?}
 */
Stream.prototype.sampledBy = function(otherObs, combinator) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Stream.prototype.skipUntilBy = function(otherObs) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Stream.prototype.takeUntilBy = function(otherObs) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @param {?=} options
 * @return {?}
 */
Stream.prototype.bufferBy = function(otherObs, options) {};

/**
 * @template U
 * @param {?} otherObs
 * @param {?=} options
 * @return {?}
 */
Stream.prototype.bufferWhileBy = function(otherObs, options) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Stream.prototype.awaiting = function(otherObs) {};
/**
 * @extends {Observable}
 * @record
 * @struct
 */
function Property() {}

/**
 * @return {?}
 */
Property.prototype.changes = function() {};

/**
 * @template U
 * @param {?} fn
 * @return {?}
 */
Property.prototype.map = function(fn) {};

/**
 * @param {?=} predicate
 * @return {?}
 */
Property.prototype.filter = function(predicate) {};

/**
 * @param {number} n
 * @return {?}
 */
Property.prototype.take = function(n) {};

/**
 * @param {?=} predicate
 * @return {?}
 */
Property.prototype.takeWhile = function(predicate) {};

/**
 * @return {?}
 */
Property.prototype.last = function() {};

/**
 * @param {number} n
 * @return {?}
 */
Property.prototype.skip = function(n) {};

/**
 * @param {?=} predicate
 * @return {?}
 */
Property.prototype.skipWhile = function(predicate) {};

/**
 * @param {?=} comparator
 * @return {?}
 */
Property.prototype.skipDuplicates = function(comparator) {};

/**
 * @param {?=} fn
 * @param {?=} seed
 * @return {?}
 */
Property.prototype.diff = function(fn, seed) {};

/**
 * @param {?} fn
 * @param {?=} seed
 * @return {?}
 */
Property.prototype.scan = function(fn, seed) {};

/**
 * @param {number} wait
 * @return {?}
 */
Property.prototype.delay = function(wait) {};

/**
 * @param {number} wait
 * @param {?=} options
 * @return {?}
 */
Property.prototype.throttle = function(wait, options) {};

/**
 * @param {number} wait
 * @param {?=} options
 * @return {?}
 */
Property.prototype.debounce = function(wait, options) {};

/**
 * @template U
 * @param {?=} handler
 * @return {?}
 */
Property.prototype.valuesToErrors = function(handler) {};

/**
 * @template U
 * @param {?=} handler
 * @return {?}
 */
Property.prototype.errorsToValues = function(handler) {};

/**
 * @template U
 * @param {?} fn
 * @return {?}
 */
Property.prototype.mapErrors = function(fn) {};

/**
 * @param {?=} predicate
 * @return {?}
 */
Property.prototype.filterErrors = function(predicate) {};

/**
 * @return {?}
 */
Property.prototype.endOnError = function() {};

/**
 * @param {number} n
 * @return {?}
 */
Property.prototype.takeErrors = function(n) {};

/**
 * @return {?}
 */
Property.prototype.ignoreValues = function() {};

/**
 * @return {?}
 */
Property.prototype.ignoreErrors = function() {};

/**
 * @return {?}
 */
Property.prototype.ignoreEnd = function() {};

/**
 * @template U
 * @param {?} fn
 * @return {?}
 */
Property.prototype.beforeEnd = function(fn) {};

/**
 * @param {number} max
 * @param {number=} mix
 * @return {?}
 */
Property.prototype.slidingWindow = function(max, mix) {};

/**
 * @param {?} predicate
 * @return {?}
 */
Property.prototype.bufferWhile = function(predicate) {};

/**
 * @param {number} count
 * @param {?=} options
 * @return {?}
 */
Property.prototype.bufferWithCount = function(count, options) {};

/**
 * @param {number} interval
 * @param {number} count
 * @param {?=} options
 * @return {?}
 */
Property.prototype.bufferWithTimeOrCount = function(interval, count, options) {};

/**
 * @template U
 * @param {?} transducer
 * @return {?}
 */
Property.prototype.transduce = function(transducer) {};

/**
 * @template U, V
 * @param {?} handler
 * @return {?}
 */
Property.prototype.withHandler = function(handler) {};

/**
 * @template U, V, W
 * @param {?} otherObs
 * @param {?=} combinator
 * @return {?}
 */
Property.prototype.combine = function(otherObs, combinator) {};

/**
 * @template U, V, W
 * @param {?} otherObs
 * @param {?=} combinator
 * @return {?}
 */
Property.prototype.zip = function(otherObs, combinator) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Property.prototype.merge = function(otherObs) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Property.prototype.concat = function(otherObs) {};

/**
 * @template U, V
 * @param {?} transform
 * @return {?}
 */
Property.prototype.flatMap = function(transform) {};

/**
 * @template U, V
 * @param {?} fn
 * @return {?}
 */
Property.prototype.flatMapLatest = function(fn) {};

/**
 * @template U, V
 * @param {?} fn
 * @return {?}
 */
Property.prototype.flatMapFirst = function(fn) {};

/**
 * @template U, V
 * @param {?} fn
 * @return {?}
 */
Property.prototype.flatMapConcat = function(fn) {};

/**
 * @template U, V
 * @param {?} fn
 * @param {number} limit
 * @return {?}
 */
Property.prototype.flatMapConcurLimit = function(fn, limit) {};

/**
 * @template U, V
 * @param {?} transform
 * @return {?}
 */
Property.prototype.flatMapErrors = function(transform) {};

/**
 * @template U
 * @param {?} otherObs
 * @return {?}
 */
Property.prototype.filterBy = function(otherObs) {};

/**
 * @template U, V, W
 * @param {?} otherObs
 * @param {?=} combinator
 * @return {?}
 */
Property.prototype.sampledBy = function(otherObs, combinator) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Property.prototype.skipUntilBy = function(otherObs) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Property.prototype.takeUntilBy = function(otherObs) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @param {?=} options
 * @return {?}
 */
Property.prototype.bufferBy = function(otherObs, options) {};

/**
 * @template U
 * @param {?} otherObs
 * @param {?=} options
 * @return {?}
 */
Property.prototype.bufferWhileBy = function(otherObs, options) {};

/**
 * @template U, V
 * @param {?} otherObs
 * @return {?}
 */
Property.prototype.awaiting = function(otherObs) {};
/**
 * @extends {Observable}
 * @record
 * @struct
 */
function ObservablePool() {}

/**
 * @param {?} obs
 * @return {void}
 */
ObservablePool.prototype.plug = function(obs) {};

/**
 * @param {?} obs
 * @return {void}
 */
ObservablePool.prototype.unPlug = function(obs) {};
/**
 * @record
 * @struct
 */
function Event() {}
 /** @type {string} */
Event.prototype.type;
 /** @type {?} */
Event.prototype.value;
/**
 * @record
 * @struct
 */
function Emitter() {}

/**
 * @param {?} value
 * @return {void}
 */
Emitter.prototype.emit = function(value) {};

/**
 * @param {?} error
 * @return {void}
 */
Emitter.prototype.error = function(error) {};

/**
 * @return {void}
 */
Emitter.prototype.end = function() {};

/**
 * @param {?} event
 * @return {void}
 */
Emitter.prototype.emitEvent = function(event) {};

/**
 * @return {?}
 */
function never() {}

/**
 * @template T
 * @param {number} wait
 * @param {T} value
 * @return {?}
 */
function later(wait, value) {}

/**
 * @template T
 * @param {number} interval
 * @param {T} value
 * @return {?}
 */
function interval(interval, value) {}

/**
 * @template T
 * @param {number} interval
 * @param {!Array<T>} values
 * @return {?}
 */
function sequentially(interval, values) {}

/**
 * @template T
 * @param {number} interval
 * @param {function(): T} fn
 * @return {?}
 */
function fromPoll(interval, fn) {}

/**
 * @template T, S
 * @param {number} interval
 * @param {function(?): void} handler
 * @return {?}
 */
function withInterval(interval, handler) {}

/**
 * @template T
 * @param {function(function(T): void): void} fn
 * @return {?}
 */
function fromCallback(fn) {}

/**
 * @template T, S
 * @param {function(function(S, T): void): void} fn
 * @return {?}
 */
function fromNodeCallback(fn) {}

/**
 * @template T, S
 * @param {(!EventTarget|!NodeJS.EventEmitter|{on: !Function, off: !Function})} target
 * @param {string} eventName
 * @param {function(T): S=} transform
 * @return {?}
 */
function fromEvents(target, eventName, transform) {}

/**
 * @template T, S
 * @param {function(?): (void|!Function)} subscribe
 * @return {?}
 */
function stream(subscribe) {}

/**
 * @template T, S
 * @param {?} observable
 * @return {?}
 */
function fromESObservable(observable) {}

/**
 * @template T
 * @param {T} value
 * @return {?}
 */
function constant(value) {}

/**
 * @template T
 * @param {T} error
 * @return {?}
 */
function constantError(error) {}

/**
 * @template T, S
 * @param {?} promise
 * @return {?}
 */
function fromPromise(promise) {}

/**
 * @template T, S, U
 * @param {!Array<?>} obss
 * @param {!Array<?>|function(!Array<T>): U=} passiveObss_or_combinator
 * @param {function(!Array<T>): U=} combinator
 * @return {?}
 */
function combine(obss, passiveObss_or_combinator, combinator) {}

/**
 * @template T, S, U
 * @param {!Array<?>} obss
 * @param {!Array<?>=} passiveObss
 * @param {function(!Array<T>): U=} combinator
 * @return {?}
 */
function zip(obss, passiveObss, combinator) {}

/**
 * @template T, S
 * @param {!Array<?>} obss
 * @return {?}
 */
function merge(obss) {}

/**
 * @template T, S
 * @param {!Array<?>} obss
 * @return {?}
 */
function concat(obss) {}

/**
 * @template T, S
 * @return {?}
 */
function pool() {}

/**
 * @template T, S
 * @param {function(number): (boolean|?)} generator
 * @return {?}
 */
function repeat(generator) {}
