/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/qunit/index.d.ts:
/**
 * @record
 * @struct
 */
function Assert() {}

/**
 * Instruct QUnit to wait for an asynchronous operation.
 * 
 * The callback returned from `assert.async()` will throw an Error if it is
 * invoked more than once (or more often than the accepted call count, if
 * provided).
 * 
 * This replaces functionality previously provided by `QUnit.stop()` and
 * `QUnit.start()`.
 * 
 * @param {number=} acceptCallCount
 * @return {function(): void}
 */
Assert.prototype.async = function(acceptCallCount) {};

/**
 * A deep recursive comparison, working on primitive types, arrays, objects,
 * regular expressions, dates and functions.
 * 
 * The `deepEqual()` assertion can be used just like `equal()` when comparing
 * the value of objects, such that `{ key: value }` is equal to
 * `{ key: value }`. For non-scalar values, identity will be disregarded by
 * deepEqual.
 * 
 * `notDeepEqual()` can be used to explicitly test deep, strict inequality.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparision value
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.deepEqual = function(actual, expected, message) {};

/**
 * A non-strict comparison, roughly equivalent to JUnit's assertEquals.
 * 
 * The `equal` assertion uses the simple comparison operator (`==`) to
 * compare the actual and expected arguments. When they are equal, the
 * assertion passes; otherwise, it fails. When it fails, both actual and
 * expected values are displayed in the test result, in addition to a given
 * message.
 * 
 *  `notEqual()` can be used to explicitly test inequality.
 * 
 * `strictEqual()` can be used to test strict equality.
 * 
 * @param {?} actual Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.equal = function(actual, expected, message) {};

/**
 * Specify how many assertions are expected to run within a test.
 * 
 * To ensure that an explicit number of assertions are run within any test,
 * use `assert.expect( number )` to register an expected count. If the
 * number of assertions run does not match the expected count, the test will
 * fail.
 * 
 * @param {number} amount
 * @return {void}
 */
Assert.prototype.expect = function(amount) {};

/**
 * An inverted deep recursive comparison, working on primitive types,
 * arrays, objects, regular expressions, dates and functions.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.notDeepEqual = function(actual, expected, message) {};

/**
 * A non-strict comparison, checking for inequality.
 * 
 * The `notEqual` assertion uses the simple inverted comparison operator
 * (`!=`) to compare the actual and expected arguments. When they aren't
 * equal, the assertion passes; otherwise, it fails. When it fails, both
 * actual and expected values are displayed in the test result, in addition
 * to a given message.
 * 
 * `equal()` can be used to test equality.
 * 
 * `notStrictEqual()` can be used to test strict inequality.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.notEqual = function(actual, expected, message) {};

/**
 * A boolean check, inverse of `ok()` and CommonJS's `assert.ok()`, and
 * equivalent to JUnit's `assertFalse()`. Passes if the first argument is
 * falsy.
 * 
 * `notOk()` requires just one argument. If the argument evaluates to false,
 * the assertion passes; otherwise, it fails. If a second message argument
 * is provided, it will be displayed in place of the result.
 * 
 * @param {?} state Expression being tested
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.notOk = function(state, message) {};

/**
 * A strict comparison of an object's own properties, checking for inequality.
 * 
 * The `notPropEqual` assertion uses the strict inverted comparison operator
 * (`!==`) to compare the actual and expected arguments as Objects regarding
 * only their properties but not their constructors.
 * 
 * When they aren't equal, the assertion passes; otherwise, it fails. When
 * it fails, both actual and expected values are displayed in the test
 * result, in addition to a given message.
 * 
 * `equal()` can be used to test equality.
 * 
 * `propEqual()` can be used to test strict equality of an Object properties.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.notPropEqual = function(actual, expected, message) {};

/**
 * A strict comparison, checking for inequality.
 * 
 * The `notStrictEqual` assertion uses the strict inverted comparison
 * operator (`!==`) to compare the actual and expected arguments. When they
 * aren't equal, the assertion passes; otherwise, it fails. When it fails,
 * both actual and expected values are displayed in the test result, in
 * addition to a given message.
 * 
 * `equal()` can be used to test equality.
 * 
 * `strictEqual()` can be used to test strict equality.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.notStrictEqual = function(actual, expected, message) {};

/**
 * A boolean check, equivalent to CommonJS's assert.ok() and JUnit's
 * assertTrue(). Passes if the first argument is truthy.
 * 
 * The most basic assertion in QUnit, ok() requires just one argument. If
 * the argument evaluates to true, the assertion passes; otherwise, it
 * fails. If a second message argument is provided, it will be displayed in
 * place of the result.
 * 
 * @param {?} state Expression being tested
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.ok = function(state, message) {};

/**
 * A strict type and value comparison of an object's own properties.
 * 
 * The `propEqual()` assertion provides strictly (`===`) comparison of
 * Object properties. Unlike `deepEqual()`, this assertion can be used to
 * compare two objects made with different constructors and prototype.
 * 
 * `strictEqual()` can be used to test strict equality.
 * 
 * `notPropEqual()` can be used to explicitly test strict inequality of
 * Object properties.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.propEqual = function(actual, expected, message) {};

/**
 * Report the result of a custom assertion
 * 
 * Some test suites may need to express an expectation that is not defined
 * by any of QUnit's built-in assertions. This need may be met by
 * encapsulating the expectation in a JavaScript function which returns a
 * `Boolean` value representing the result; this value can then be passed
 * into QUnit's `ok` assertion.
 * 
 * A more readable solution would involve defining a custom assertion. If
 * the expectation function invokes `pushResult`, QUnit will be notified of
 * the result and report it accordingly.
 * 
 * @param {{result: boolean, actual: ?, expected: ?, message: string}} assertResult
 * @return {void}
 */
Assert.prototype.pushResult = function(assertResult) {};

/**
 * A strict type and value comparison.
 * 
 * The `strictEqual()` assertion provides the most rigid comparison of type
 * and value with the strict equality operator (`===`).
 * 
 * `equal()` can be used to test non-strict equality.
 * 
 * `notStrictEqual()` can be used to explicitly test strict inequality.
 * 
 * @param {?} actual Object or Expression being tested
 * @param {?} expected Known comparison value
 * @param {string=} message
 * @return {void}
 */
Assert.prototype.strictEqual = function(actual, expected, message) {};

/**
 * Test if a callback throws an exception, and optionally compare the thrown
 * error.
 * 
 * When testing code that is expected to throw an exception based on a
 * specific set of circumstances, use assert.throws() to catch the error
 * object for testing and comparison.
 * 
 * In very few environments, like Closure Compiler, throws is considered a
 * reserved word and will cause an error. For that case, an alias is bundled
 * called `raises`. It has the same signature and behaviour, just a
 * different name.
 * @param {function(): void} block
 * @param {?=} expected
 * @param {?=} message
 * @return {void}
 */
Assert.prototype.throws = function(block, expected, message) {};

/**
 * @param {function(): void} block
 * @param {?=} expected
 * @param {?=} message
 * @return {void}
 */
Assert.prototype.raises = function(block, expected, message) {};
/**
 * @record
 * @struct
 */
function Config() {}
 /** @type {boolean} */
Config.prototype.altertitle;
 /** @type {boolean} */
Config.prototype.autostart;
 /** @type {boolean} */
Config.prototype.collapse;
 /** @type {?} */
Config.prototype.current;
 /** @type {(string|!RegExp)} */
Config.prototype.filter;
 /** @type {string} */
Config.prototype.fixture;
 /** @type {boolean} */
Config.prototype.hidepassed;
 /** @type {number} */
Config.prototype.maxDepth;
 /** @type {string} */
Config.prototype.module;
 /** @type {!Array<string>} */
Config.prototype.moduleId;
 /** @type {boolean} */
Config.prototype.notrycatch;
 /** @type {boolean} */
Config.prototype.noglobals;
 /** @type {string} */
Config.prototype.seed;
 /** @type {boolean} */
Config.prototype.reorder;
 /** @type {boolean} */
Config.prototype.requireExpects;
 /** @type {!Array<string>} */
Config.prototype.testId;
 /** @type {number} */
Config.prototype.testTimeout;
 /** @type {boolean} */
Config.prototype.scrolltop;
 /** @type {!Array<{id: string, label: string, tooltip: string, value: (string|!Array<string>|!Object<string,string>)}>} */
Config.prototype.urlConfig;
/**
 * @record
 * @struct
 */
function Hooks() {}
 /** @type {function(!Assert): void} */
Hooks.prototype.after;
 /** @type {function(!Assert): void} */
Hooks.prototype.afterEach;
 /** @type {function(!Assert): void} */
Hooks.prototype.before;
 /** @type {function(!Assert): void} */
Hooks.prototype.beforeEach;
/**
 * @record
 * @struct
 */
function NestedHooks() {}
 /** @type {function(function(!Assert): void): void} */
NestedHooks.prototype.after;
 /** @type {function(function(!Assert): void): void} */
NestedHooks.prototype.afterEach;
 /** @type {function(function(!Assert): void): void} */
NestedHooks.prototype.before;
 /** @type {function(function(!Assert): void): void} */
NestedHooks.prototype.beforeEach;
/**
 * @record
 * @struct
 */
function QUnit() {}
 /** @type {!Assert} */
QUnit.prototype.assert;
 /** @type {!Config} */
QUnit.prototype.config;
 /** @type {{maxDepth: number, parse: function(?): string}} */
QUnit.prototype.dump;
 /** @type {boolean} */
QUnit.prototype.isLocal;
 /** @type {string} */
QUnit.prototype.version;

/**
 * Register a callback to fire whenever the test suite begins.
 * 
 * `QUnit.begin()` is called once before running any tests.
 * 
 * \@callback callback Callback to execute.
 * @param {function({totalTests: number}): void} callback
 * @return {void}
 */
QUnit.prototype.begin = function(callback) {};

/**
 * Register a callback to fire whenever the test suite ends.
 * 
 * @param {function({failed: number, passed: number, total: number, runtime: number}): void} callback Callback to execute
 * @return {void}
 */
QUnit.prototype.done = function(callback) {};

/**
 * Copy the properties defined by the `mixin` object into the `target` object.
 * 
 * This method will modify the `target` object to contain the "own" properties
 * defined by the `mixin`. If the `mixin` object specifies the value of any
 * attribute as undefined, this property will instead be removed from the
 * `target` object.
 * 
 * @param {?} target An object whose properties are to be modified
 * @param {?} mixin An object describing which properties should be modified
 * @return {void}
 */
QUnit.prototype.extend = function(target, mixin) {};

/**
 * Register a callback to fire whenever an assertion completes.
 * 
 * This is one of several callbacks QUnit provides. Its intended for
 * integration scenarios like PhantomJS or Jenkins. The properties of the
 * details argument are listed below as options.
 * 
 * @param {function({result: boolean, actual: ?, expected: ?, message: string, source: string, module: string, name: string, runtime: number}): void} callback Callback to execute
 * @return {void}
 */
QUnit.prototype.log = function(callback) {};

/**
 * Group related tests under a single label.
 * 
 * You can use the module name to organize, select, and filter tests to run.
 * 
 * All tests inside a module callback function will be grouped into that
 * module. The test names will all be preceded by the module name in the
 * test results. Other modules can be nested inside this callback function,
 * where their tests' names will be labeled by their names recursively
 * prefixed by their parent modules.
 * 
 * If `QUnit.module` is defined without a `nested` callback argument, all
 * subsequently defined tests will be grouped into the module until another
 * module is defined.
 * 
 * Modules with test group functions allow you to define nested modules, and
 * QUnit will run tests on the parent module before going deep on the nested
 * ones, even if they're declared first. Additionally, any hook callbacks on
 * a parent module will wrap the hooks on a nested module. In other words,
 * `before` and `beforeEach` callbacks will form a queue while the
 * `afterEach` and `after` callbacks will form a stack.
 * 
 * You can specify code to run before and after tests using the hooks
 * argument, and also to create properties that will be shared on the
 * testing context. Any additional properties on the `hooks` object will be
 * added to that context. The `hooks` argument is still optional if you call
 * `QUnit.module` with a callback argument.
 * 
 * The module's callback is invoked with the test environment as its `this`
 * context, with the environment's properties copied to the module's tests,
 * hooks, and nested modules. Note that changes on tests' `this` are not
 * preserved between sibling tests, where `this` will be reset to the initial
 * value for each test.
 *  
 * @param {string} name
 * @param {!Hooks|function(!NestedHooks): void=} hooks_or_nested
 * @param {function(!NestedHooks): void=} nested A callback with grouped tests and nested modules to run under the current module label
 * @return {void}
 */
QUnit.prototype.module = function(name, hooks_or_nested, nested) {};

/**
 * Register a callback to fire whenever a module ends.
 * 
 * @param {function({name: string, failed: number, passed: number, total: number, runtime: number}): void} callback Callback to execute
 * @return {void}
 */
QUnit.prototype.moduleDone = function(callback) {};

/**
 * Register a callback to fire whenever a module begins.
 * 
 * @param {function({name: string}): void} callback Callback to execute
 * @return {void}
 */
QUnit.prototype.moduleStart = function(callback) {};

/**
 * Adds a test to exclusively run, preventing all other tests from running.
 * 
 * Use this method to focus your test suite on a specific test. QUnit.only
 * will cause any other tests in your suite to be ignored.
 * 
 * Note, that if more than one QUnit.only is present only the first instance
 * will run.
 * 
 * This is an alternative to filtering tests to run in the HTML reporter. It
 * is especially useful when you use a console reporter or in a codebase
 * with a large set of long running tests.
 * 
 * @param {string} name
 * @param {function(!Assert): void} callback Function to close over assertions
 * @return {void}
 */
QUnit.prototype.only = function(name, callback) {};

/**
 * DEPRECATED: Report the result of a custom assertion.
 * 
 * This method is deprecated and it's recommended to use pushResult on its
 * direct reference in the assertion context.
 * 
 * QUnit.push reflects to the current running test, and it may leak
 * assertions in asynchronous mode. Checkout assert.pushResult() to set a
 * proper custom assertion.
 * 
 * Invoking QUnit.push allows to create a readable expectation that is not
 * defined by any of QUnit's built-in assertions.
 * 
 * @deprecated
 * @param {boolean} result
 * @param {?} actual
 * @param {?} expected
 * @param {string} message
 * @return {void}
 */
QUnit.prototype.push = function(result, actual, expected, message) {};

/**
 * Adds a test like object to be skipped.
 * 
 * Use this method to replace QUnit.test() instead of commenting out entire
 * tests.
 * 
 * This test's prototype will be listed on the suite as a skipped test,
 * ignoring the callback argument and the respective global and module's
 * hooks.
 * 
 * @param {string} name
 * @param {function(!Assert): void=} callback
 * @return {void}
 */
QUnit.prototype.skip = function(name, callback) {};

/**
 * Returns a single line string representing the stacktrace (call stack).
 * 
 * This method returns a single line string representing the stacktrace from
 * where it was called. According to its offset argument, `QUnit.stack()` will
 * return the correspondent line from the call stack.
 * 
 * The default `offset` is `0` and will return the current location where it
 * was called.
 * 
 * Not all browsers support retrieving stracktraces. In those, `QUnit.stack()`
 * will return undefined.
 * 
 * @param {number=} offset
 * @return {string}
 */
QUnit.prototype.stack = function(offset) {};

/**
 * `QUnit.start()` must be used to start a test run that has
 * `QUnit.config.autostart` set to `false`.
 * 
 * This method was previously used to control async tests on text contexts
 * along with QUnit.stop. For asynchronous tests, use assert.async instead.
 * 
 * When your async test has multiple exit points, call `QUnit.start()` for the
 * corresponding number of `QUnit.stop()` increments.
 * @return {void}
 */
QUnit.prototype.start = function() {};

/**
 * Add a test to run.
 * 
 * Add a test to run using `QUnit.test()`.
 * 
 * The `assert` argument to the callback contains all of QUnit's assertion
 * methods. Use this argument to call your test assertions.
 * 
 * `QUnit.test()` can automatically handle the asynchronous resolution of a
 * Promise on your behalf if you return a thenable Promise as the result of
 * your callback function.
 * 
 * @param {string} name
 * @param {function(!Assert): void} callback Function to close over assertions
 * @return {void}
 */
QUnit.prototype.test = function(name, callback) {};

/**
 * Register a callback to fire whenever a test ends.
 * 
 * @param {function({name: string, module: string, failed: number, passed: number, total: number, runtime: number}): void} callback Callback to execute
 * @return {void}
 */
QUnit.prototype.testDone = function(callback) {};

/**
 * Register a callback to fire whenever a test begins.
 * 
 * @param {function({name: string, module: string}): void} callback Callback to execute
 * @return {void}
 */
QUnit.prototype.testStart = function(callback) {};
 /** @type {?} */
var QUnit;
