/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/fetch-mock/index.d.ts:
/** @const */
var fetchMock = {};

/** @typedef {(!Request|!RequestInit)} */
fetchMock.MockRequest;

/** @typedef {function(string, (!Request|!RequestInit)): boolean} */
fetchMock.MockMatcherFunction;

/** @typedef {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} */
fetchMock.MockMatcher;
/**
 * @record
 * @struct
 */
fetchMock.MockResponseObject = function() {};
 /** @type {(string|!Object)} */
fetchMock.MockResponseObject.prototype.body;
 /** @type {number} */
fetchMock.MockResponseObject.prototype.status;
 /** @type {!Object<string,string>} */
fetchMock.MockResponseObject.prototype.headers;
 /** @type {boolean} */
fetchMock.MockResponseObject.prototype.throws;
 /** @type {boolean} */
fetchMock.MockResponseObject.prototype.sendAsJson;

/** @typedef {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>)} */
fetchMock.MockResponse;

/** @typedef {function(string, (!Request|!RequestInit)): (string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>)} */
fetchMock.MockResponseFunction;
/**
 * @record
 * @struct
 */
fetchMock.MockOptions = function() {};
 /** @type {string} */
fetchMock.MockOptions.prototype.name;
 /** @type {string} */
fetchMock.MockOptions.prototype.method;
 /** @type {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} */
fetchMock.MockOptions.prototype.matcher;
 /** @type {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} */
fetchMock.MockOptions.prototype.response;
 /** @type {number} */
fetchMock.MockOptions.prototype.times;

/** @typedef {!Array<?>} */
fetchMock.MockCall;
/**
 * @record
 * @struct
 */
fetchMock.MatchedRoutes = function() {};
 /** @type {!Array<!Array<?>>} */
fetchMock.MatchedRoutes.prototype.matched;
 /** @type {!Array<!Array<?>>} */
fetchMock.MatchedRoutes.prototype.unmatched;
/**
 * @extends {fetchMock.MockOptions}
 * @record
 * @struct
 */
fetchMock.MockOptionsMethodGet = function() {};
 /** @type {string} */
fetchMock.MockOptionsMethodGet.prototype.method;
/**
 * @extends {fetchMock.MockOptions}
 * @record
 * @struct
 */
fetchMock.MockOptionsMethodPost = function() {};
 /** @type {string} */
fetchMock.MockOptionsMethodPost.prototype.method;
/**
 * @extends {fetchMock.MockOptions}
 * @record
 * @struct
 */
fetchMock.MockOptionsMethodPut = function() {};
 /** @type {string} */
fetchMock.MockOptionsMethodPut.prototype.method;
/**
 * @extends {fetchMock.MockOptions}
 * @record
 * @struct
 */
fetchMock.MockOptionsMethodDelete = function() {};
 /** @type {string} */
fetchMock.MockOptionsMethodDelete.prototype.method;
/**
 * @extends {fetchMock.MockOptions}
 * @record
 * @struct
 */
fetchMock.MockOptionsMethodHead = function() {};
 /** @type {string} */
fetchMock.MockOptionsMethodHead.prototype.method;
/**
 * @record
 * @struct
 */
fetchMock.FetchMockStatic = function() {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Calls to .mock() can be chained.
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Calls to .mock() can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)|!fetchMock.MockOptions} matcher_or_options Condition for selecting which requests to mock / The route to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))=} response Configures the http response returned by the mock
 * @param {!fetchMock.MockOptions=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.mock = function(matcher_or_options, response, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() limited to being
 *  called one time only. Calls to .once() can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} response Configures the http response returned by the mock
 * @param {!fetchMock.MockOptions=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.once = function(matcher, response, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the GET
 *  method. Calls to .get() can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodGet=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.get = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the GET
 *  method and limited to being called one time only. Calls to .getOnce()
 *  can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodGet=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.getOnce = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the POST
 *  method. Calls to .post() can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodPost=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.post = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the POST
 *  method and limited to being called one time only. Calls to .postOnce()
 *  can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodPost=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.postOnce = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the PUT
 *  method. Calls to .put() can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodPut=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.put = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the PUT
 *  method and limited to being called one time only. Calls to .putOnce()
 *  can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodPut=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.putOnce = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the
 *  DELETE method. Calls to .delete() can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodDelete=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.delete = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the
 *  DELETE method and limited to being called one time only. Calls to
 *  .deleteOnce() can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodDelete=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.deleteOnce = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the HEAD
 *  method. Calls to .head() can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodHead=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.head = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the HEAD
 *  method and limited to being called one time only. Calls to .headOnce()
 *  can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodHead=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.headOnce = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the PATCH
 *  method. Calls to .patch() can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodHead=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.patch = function(matcher, reponse, options) {};

/**
 * Replaces fetch() with a stub which records its calls, grouped by
 * route, and optionally returns a mocked Response object or passes the
 *  call through to fetch(). Shorthand for mock() restricted to the PATCH
 *  method and limited to being called one time only. Calls to .patchOnce()
 *  can be chained.
 * @param {(string|!RegExp|function(string, (!Request|!RequestInit)): boolean)} matcher Condition for selecting which requests to mock
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))} reponse
 * @param {!fetchMock.MockOptionsMethodHead=} options
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.patchOnce = function(matcher, reponse, options) {};

/**
 * Chainable method that defines how to respond to calls to fetch that
 * don't match any of the defined mocks. It accepts the same types of
 * response as a normal call to .mock(matcher, response). It can also
 * take an arbitrary function to completely customise behaviour of
 * unmatched calls. If .catch() is called without any parameters then
 * every unmatched call will receive a 200 response.
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))=} response
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.catch = function(response) {};

/**
 * Chainable method that records the call history of unmatched calls,
 * but instead of responding with a stubbed response, the request is
 * passed through to native fetch() and is allowed to communicate
 * over the network. Similar to catch().
 * @param {(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>|function(string, (!Request|!RequestInit)): (string|number|?|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>))=} response
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.spy = function(response) {};

/**
 * Chainable method that restores fetch() to its unstubbed state and
 * clears all data recorded for its calls.
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.restore = function() {};

/**
 * Chainable method that clears all data recorded for fetch()'s calls
 * @return {FetchMockStatic}
 */
fetchMock.FetchMockStatic.prototype.reset = function() {};

/**
 * Returns a promise that resolves once all fetches handled by fetch-mock
 * have resolved.
 * @return {!Promise<!Array<(string|number|!Object|!Response|!Promise<!Response>|!Promise<number>|!Promise<string>|!Promise<?>|!fetchMock.MockResponseObject|!Promise<!fetchMock.MockResponseObject>)>>}
 */
fetchMock.FetchMockStatic.prototype.flush = function() {};

/**
 * Returns all calls to fetch, grouped by whether fetch-mock matched
 * them or not.
 * Returns all calls to fetch matching matcherName.
 * @param {string=} matcherName
 * @return {!fetchMock.MatchedRoutes|!Array<!Array<?>>}
 */
fetchMock.FetchMockStatic.prototype.calls = function(matcherName) {};

/**
 * Returns a Boolean indicating whether fetch was called and a route
 * was matched (or a specific route if matcherName is passed).
 * @param {string=} matcherName
 * @return {boolean}
 */
fetchMock.FetchMockStatic.prototype.called = function(matcherName) {};

/**
 * Returns a Boolean indicating whether fetch was called the expected
 * number of times (or at least once if the route defines no expectation
 * is set) for every route (or for a specific route if matcherName is
 * passed).
 * @param {string=} matcherName
 * @return {boolean}
 */
fetchMock.FetchMockStatic.prototype.done = function(matcherName) {};

/**
 * Returns the arguments for the last matched call to fetch (or the
 * last call to specific route is matcherName is passed).
 * @param {string=} matcherName
 * @return {!Array<?>}
 */
fetchMock.FetchMockStatic.prototype.lastCall = function(matcherName) {};

/**
 * Returns the url for the last matched call to fetch (or the last
 * call to specific route is matcherName is passed).
 * @param {string=} matcherName
 * @return {string}
 */
fetchMock.FetchMockStatic.prototype.lastUrl = function(matcherName) {};

/**
 * Returns the options for the last matched call to fetch (or the
 * last call to a specific route is matcherName is passed).
 * @param {string=} matcherName
 * @return {(!Request|!RequestInit)}
 */
fetchMock.FetchMockStatic.prototype.lastOptions = function(matcherName) {};

/**
 * Set some global config options, which include
 * sendAsJson [default `true`] - by default fetchMock will
 * convert objects to JSON before sending. This is overrideable
 * for each call but for some scenarios, e.g. when dealing with a
 * lot of array buffers, it can be useful to default to `false`
 * @param {!Object} opts
 * @return {void}
 */
fetchMock.FetchMockStatic.prototype.configure = function(opts) {};
 /** @type {!fetchMock.FetchMockStatic} */
var fetchMock;

/* TODO: ExportAssignment in  */
