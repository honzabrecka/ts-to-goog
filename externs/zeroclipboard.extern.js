/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/zeroclipboard/index.d.ts:
/** @const */
var ZC = {};
/**
 * @record
 * @struct
 */
ZC.List = function() {};

/* TODO: IndexSignature: ZC */
 /** @type {number} */
ZC.List.prototype.length;
/**
 * @record
 * @struct
 */
ZC.Dictionary = function() {};

/* TODO: IndexSignature: ZC */
/**
 * @record
 * @struct
 */
ZC.EventListener = function() {};

/* TODO: CallSignature: ZC */
/**
 * @record
 * @struct
 */
ZC.EventListenerObject = function() {};

/**
 * @param {T} ev
 * @return {void}
 */
ZC.EventListenerObject.prototype.handleEvent = function(ev) {};

/** @typedef {(!ZC.EventListener<T>|!ZC.EventListenerObject<T>)} */
ZC.EventListenerOrEventListenerObject;
/**
 * @extends {ZC.ZeroClipboardCommon}
 * @record
 * @struct
 */
ZC.ZeroClipboardStatic = function() {};

/* TODO: ConstructSignature: ZC */
 /** @type {string} */
ZC.ZeroClipboardStatic.prototype.version;

/**
 * Get a copy of the active configuration for ZeroClipboard.
 *  Get a copy of the actively configured value for this configuration property for ZeroClipboard.
 * Set the active configuration for ZeroClipboard. Returns a copy of the updated active configuration.
 * @param {string|!ZC.ZeroClipboardConfig=} propName_or_config
 * @return {!ZC.ZeroClipboardConfig|?|string|!Array<string>|boolean|number}
 */
ZC.ZeroClipboardStatic.prototype.config = function(propName_or_config) {};

/**
 * Create the Flash bridge SWF object.
 * IMPORTANT: This method should be considered private.
 * @return {void}
 */
ZC.ZeroClipboardStatic.prototype.create = function() {};

/**
 * Emit the "destroy" event, remove all event handlers, and destroy the Flash bridge.
 * @return {void}
 */
ZC.ZeroClipboardStatic.prototype.destroy = function() {};

/**
 * Focus/"activate" the provided element by moving the Flash SWF object in front of it.
 * \@since 2.1.0
 * @param {!Element} element
 * @return {void}
 */
ZC.ZeroClipboardStatic.prototype.focus = function(element) {};

/**
 * Focus/"activate" the provided element by moving the Flash SWF object in front of it.
 * \@deprecated: The preferred method to use is focus but the alias activate is available for backward compatibility's sake.
 * @param {!Element} element
 * @return {void}
 */
ZC.ZeroClipboardStatic.prototype.activate = function(element) {};

/**
 * Blur/"deactivate" the currently focused/"activated" element, moving the Flash SWF object off the screen.
 * \@since 2.1.0
 * @return {void}
 */
ZC.ZeroClipboardStatic.prototype.blur = function() {};

/**
 * Blur/"deactivate" the currently focused/"activated" element, moving the Flash SWF object off the screen.
 * \@deprecated: The preferred method to use is blur but the alias deactivate is available for backward compatibility's sake.
 * @return {void}
 */
ZC.ZeroClipboardStatic.prototype.deactivate = function() {};

/**
 * Return the currently "activated" element that the Flash SWF object is in front of it.
 * @return {!HTMLElement}
 */
ZC.ZeroClipboardStatic.prototype.activeElement = function() {};

/**
 * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard.
 * @return {!Object}
 */
ZC.ZeroClipboardStatic.prototype.state = function() {};

/**
 * Indicates if Flash Player is definitely unusable (disabled, outdated, unavailable, or deactivated).
 * IMPORTANT: This method should be considered private.
 * @return {boolean}
 */
ZC.ZeroClipboardStatic.prototype.isFlashUnusable = function() {};
/**
 * @extends {ZC.ZeroClipboardCommon}
 * @record
 * @struct
 */
ZC.ZeroClipboardClient = function() {};
 /** @type {string} */
ZC.ZeroClipboardClient.prototype.id;

/**
 * Remove all event handlers and unclip all clipped elements.
 * @return {void}
 */
ZC.ZeroClipboardClient.prototype.destroy = function() {};

/**
 * Set the pending data of type "text/plain" for clipboard injection.
 * @param {string} data
 * @return {void}
 */
ZC.ZeroClipboardClient.prototype.setText = function(data) {};

/**
 * Set the pending data of type "text/html" for clipboard injection.
 * @param {string} data
 * @return {void}
 */
ZC.ZeroClipboardClient.prototype.setHtml = function(data) {};

/**
 * Set the pending data of type "application/rtf" for clipboard injection.
 * @param {string} data
 * @return {void}
 */
ZC.ZeroClipboardClient.prototype.setRichText = function(data) {};

/**
 * Register clipboard actions for new element(s) to the client. This includes automatically invoking
 * ZeroClipboard.focus on the current element when it is hovered over, unless the autoActivate configuration
 * property is set to false.
 * Register clipboard actions for new element(s) to the client. This includes automatically invoking
 * ZeroClipboard.focus on the current element when it is hovered over, unless the autoActivate configuration
 * property is set to false.
 * @param {!ZC.List<!Element>|!Element} elements_or_element
 * @return {!ZC.ZeroClipboardClient}
 */
ZC.ZeroClipboardClient.prototype.clip = function(elements_or_element) {};

/**
 * Unregister the clipboard actions of previously registered element(s) on the page. If no elements are provided,
 * ALL clipped/registered elements will be unregistered.
 * Unregister the clipboard actions of previously registered element(s) on the page. If no elements are provided,
 * ALL clipped/registered elements will be unregistered.
 * @param {!ZC.List<!Element>|!Element=} elements
 * @return {!ZC.ZeroClipboardClient}
 */
ZC.ZeroClipboardClient.prototype.unclip = function(elements) {};

/**
 * Get all of the elements to which this client is clipped/registered.
 * @return {!Array<!HTMLElement>}
 */
ZC.ZeroClipboardClient.prototype.elements = function() {};
/**
 * @record
 * @struct
 */
ZC.ZeroClipboardEvent = function() {};
 /** @type {!ZC.ZeroClipboardClient} */
ZC.ZeroClipboardEvent.prototype.client;
 /** @type {string} */
ZC.ZeroClipboardEvent.prototype.type;
 /** @type {!HTMLElement} */
ZC.ZeroClipboardEvent.prototype.target;
 /** @type {!HTMLElement} */
ZC.ZeroClipboardEvent.prototype.relatedTarget;
 /** @type {!HTMLObjectElement} */
ZC.ZeroClipboardEvent.prototype.currentTarget;
 /** @type {number} */
ZC.ZeroClipboardEvent.prototype.timeStamp;
/**
 * @extends {ZC.ZeroClipboardEvent}
 * @record
 * @struct
 */
ZC.ZeroClipboardReadyEvent = function() {};
 /** @type {string} */
ZC.ZeroClipboardReadyEvent.prototype.message;
 /** @type {string} */
ZC.ZeroClipboardReadyEvent.prototype.version;
/**
 * @extends {ZC.ZeroClipboardEvent}
 * @record
 * @struct
 */
ZC.ZeroClipboardBeforeCopyEvent = function() {};
/**
 * @extends {ZC.ZeroClipboardEvent}
 * @record
 * @struct
 */
ZC.ZeroClipboardCopyEvent = function() {};
 /** @type {{setData: ?, clearData: function(string): void}} */
ZC.ZeroClipboardCopyEvent.prototype.clipboardData;
/**
 * @extends {ZC.ZeroClipboardEvent}
 * @record
 * @struct
 */
ZC.ZeroClipboardAfterCopyEvent = function() {};
 /** @type {!ZC.Dictionary<boolean>} */
ZC.ZeroClipboardAfterCopyEvent.prototype.success;
 /** @type {!ZC.Dictionary<string>} */
ZC.ZeroClipboardAfterCopyEvent.prototype.data;
 /** @type {!Array<?>} */
ZC.ZeroClipboardAfterCopyEvent.prototype.errors;
/**
 * @extends {ZC.ZeroClipboardEvent}
 * @record
 * @struct
 */
ZC.ZeroClipboardDestroyEvent = function() {};
 /** @type {!ZC.Dictionary<boolean>} */
ZC.ZeroClipboardDestroyEvent.prototype.success;
 /** @type {!ZC.Dictionary<string>} */
ZC.ZeroClipboardDestroyEvent.prototype.data;
/**
 * @extends {ZC.ZeroClipboardEvent}
 * @record
 * @struct
 */
ZC.ZeroClipboardErrorEvent = function() {};
 /** @type {string} */
ZC.ZeroClipboardErrorEvent.prototype.name;
 /** @type {string} */
ZC.ZeroClipboardErrorEvent.prototype.message;
 /** @type {string} */
ZC.ZeroClipboardErrorEvent.prototype.minimumVersion;
 /** @type {string} */
ZC.ZeroClipboardErrorEvent.prototype.version;
 /** @type {string} */
ZC.ZeroClipboardErrorEvent.prototype.jsVersion;
 /** @type {string} */
ZC.ZeroClipboardErrorEvent.prototype.swfVersion;
 /** @type {string} */
ZC.ZeroClipboardErrorEvent.prototype.property;
 /** @type {string} */
ZC.ZeroClipboardErrorEvent.prototype.configuredValue;
 /** @type {string} */
ZC.ZeroClipboardErrorEvent.prototype.actualValue;
 /** @type {!ZC.Dictionary<string>} */
ZC.ZeroClipboardErrorEvent.prototype.data;
 /** @type {!Array<?>} */
ZC.ZeroClipboardErrorEvent.prototype.errors;
/**
 * @record
 * @struct
 */
ZC.ZeroClipboardCommon = function() {};

/**
 * Set the pending data of type format for clipboard injection.
 * Set the pending data of various formats for clipboard injection. This particular function signature (passing in
 * an Object) will implicitly clear out any existing pending data.
 * @param {string|!ZC.Dictionary<string>} format_or_data
 * @param {string=} data
 * @return {void}
 */
ZC.ZeroClipboardCommon.prototype.setData = function(format_or_data, data) {};

/**
 * Clear the pending data of type format for clipboard injection.
 * Clear the pending data of ALL formats for clipboard injection.
 * @param {string=} mimeType
 * @return {void}
 */
ZC.ZeroClipboardCommon.prototype.clearData = function(mimeType) {};

/**
 * Get the pending data of type format for clipboard injection.
 * \@since 2.1.0
 * Get a copy of the pending data of ALL formats for clipboard injection.
 * \@since 2.1.0
 * @param {string=} format
 * @return {string|!ZC.Dictionary<string>}
 */
ZC.ZeroClipboardCommon.prototype.getData = function(format) {};

/**
 * Add a listener function/object for an eventType. If called as a client method will be within the client instance.
 * The ready event is fired when the Flash SWF completes loading and is ready for action. Please note that you need
 * to set most configuration options [with ZeroClipboard.config(...)] before ZeroClipboard.create() is invoked.
 * On click, the Flash object will fire off a beforecopy event. This event is generally only used for "UI
 * preparation" if you want to alter anything before the copy event fires.
 * IMPORTANT: Handlers of this event are expected to operate synchronously if they intend to be finished before
 * the "copy" event is triggered.
 * On click (and after the beforecopy event), the Flash object will fire off a copy event. If the HTML object has
 * data-clipboard-text or data-clipboard-target, then ZeroClipboard will take care of getting an initial set of
 * data. It will then invoke any copy event handlers, in which you can call event.clipboardData.setData to set the
 * text, which will complete the loop.
 * IMPORTANT: If a handler of this event intends to modify the pending data for clipboard injection, it MUST
 * operate synchronously in order to maintain the temporarily elevated permissions granted by the user's click
 * event. The most common "gotcha" for this restriction is if someone wants to make an asynchronous XMLHttpRequest
 * in response to the copy event to get the data to inject - this won't work; make it a synchronous XMLHttpRequest
 * instead, or do the work in advance before the copy event is fired.
 * The aftercopy event is fired when the text is copied [or failed to copy] to the clipboard.
 * The destroy event is fired when ZeroClipboard.destroy() is invoked.
 * IMPORTANT: Handlers of this event are expected to operate synchronously if they intend to be finished before the
 * destruction is complete.
 * The error event is fired under a number of conditions, which will be detailed as sub-sections. Some consumers
 * may not consider all error types to be critical, and thus ZeroClipboard does not take it upon itself to implode
 * by calling ZeroClipboard.destroy() under error conditions. However, many consumers may want to do just that.
 * Add a set of eventType to listener function/object mappings.
 * @param {string|{ready: (!ZC.EventListener<!ZC.ZeroClipboardReadyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardReadyEvent>), beforecopy: (!ZC.EventListener<!ZC.ZeroClipboardBeforeCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardBeforeCopyEvent>), copy: (!ZC.EventListener<!ZC.ZeroClipboardCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardCopyEvent>), aftercopy: (!ZC.EventListener<!ZC.ZeroClipboardAfterCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardAfterCopyEvent>), destroy: (!ZC.EventListener<!ZC.ZeroClipboardDestroyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardDestroyEvent>), error: (!ZC.EventListener<!ZC.ZeroClipboardErrorEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardErrorEvent>)}} eventType_or_listenerObj
 * @param {(!ZC.EventListener<!ZC.ZeroClipboardEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardReadyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardReadyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardBeforeCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardBeforeCopyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardCopyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardAfterCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardAfterCopyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardDestroyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardDestroyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardErrorEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardErrorEvent>)=} listener
 * @return {void}
 */
ZC.ZeroClipboardCommon.prototype.on = function(eventType_or_listenerObj, listener) {};

/**
 * Remove a listener function/object for an eventType.
 * Remove a set of eventType to listener function/object mappings.
 * Remove a set of eventType to listener function/object mappings.
 * Remove ALL listener functions/objects for ALL registered event types.
 * @param {string|{ready: (!ZC.EventListener<!ZC.ZeroClipboardReadyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardReadyEvent>), beforecopy: (!ZC.EventListener<!ZC.ZeroClipboardBeforeCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardBeforeCopyEvent>), copy: (!ZC.EventListener<!ZC.ZeroClipboardCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardCopyEvent>), aftercopy: (!ZC.EventListener<!ZC.ZeroClipboardAfterCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardAfterCopyEvent>), destroy: (!ZC.EventListener<!ZC.ZeroClipboardDestroyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardDestroyEvent>), error: (!ZC.EventListener<!ZC.ZeroClipboardErrorEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardErrorEvent>)}=} eventType_or_listenerObj
 * @param {(!ZC.EventListener<!ZC.ZeroClipboardReadyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardReadyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardBeforeCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardBeforeCopyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardCopyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardAfterCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardAfterCopyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardDestroyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardDestroyEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardErrorEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardErrorEvent>)|(!ZC.EventListener<!ZC.ZeroClipboardEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardEvent>)=} listener
 * @return {void}
 */
ZC.ZeroClipboardCommon.prototype.off = function(eventType_or_listenerObj, listener) {};

/**
 * Dispatch an event to all registered listeners. The emission of some types of events will result in side effects.
 * Dispatch an event to all registered listeners. The emission of some types of events will result in side effects.
 * @param {string|{type: string, name: string}} eventType_or_data
 * @return {?|void}
 */
ZC.ZeroClipboardCommon.prototype.emit = function(eventType_or_data) {};

/**
 * Retrieves a copy of the registered listener functions/objects for the given eventType.
 * Retrieves a copy of the map of registered listener functions/objects for ALL event types.
 * @param {string=} eventType
 * @return {!Array<(!ZC.EventListener<!ZC.ZeroClipboardEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardEvent>)>|!Array<(!ZC.EventListener<!ZC.ZeroClipboardReadyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardReadyEvent>)>|!Array<(!ZC.EventListener<!ZC.ZeroClipboardBeforeCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardBeforeCopyEvent>)>|!Array<(!ZC.EventListener<!ZC.ZeroClipboardCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardCopyEvent>)>|!Array<(!ZC.EventListener<!ZC.ZeroClipboardAfterCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardAfterCopyEvent>)>|!Array<(!ZC.EventListener<!ZC.ZeroClipboardDestroyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardDestroyEvent>)>|!Array<(!ZC.EventListener<!ZC.ZeroClipboardErrorEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardErrorEvent>)>|{ready: !Array<(!ZC.EventListener<!ZC.ZeroClipboardReadyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardReadyEvent>)>, beforecopy: !Array<(!ZC.EventListener<!ZC.ZeroClipboardBeforeCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardBeforeCopyEvent>)>, copy: !Array<(!ZC.EventListener<!ZC.ZeroClipboardCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardCopyEvent>)>, aftercopy: !Array<(!ZC.EventListener<!ZC.ZeroClipboardAfterCopyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardAfterCopyEvent>)>, destroy: !Array<(!ZC.EventListener<!ZC.ZeroClipboardDestroyEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardDestroyEvent>)>, error: !Array<(!ZC.EventListener<!ZC.ZeroClipboardErrorEvent>|!ZC.EventListenerObject<!ZC.ZeroClipboardErrorEvent>)>}}
 */
ZC.ZeroClipboardCommon.prototype.handlers = function(eventType) {};
/**
 * @record
 * @struct
 */
ZC.ZeroClipboardConfig = function() {};
 /** @type {string} */
ZC.ZeroClipboardConfig.prototype.swfPath;
 /** @type {!Array<string>} */
ZC.ZeroClipboardConfig.prototype.trustedDomains;
 /** @type {boolean} */
ZC.ZeroClipboardConfig.prototype.cacheBust;
 /** @type {boolean} */
ZC.ZeroClipboardConfig.prototype.forceEnhancedClipboard;
 /** @type {number} */
ZC.ZeroClipboardConfig.prototype.flashLoadTimeout;
 /** @type {boolean} */
ZC.ZeroClipboardConfig.prototype.autoActivate;
 /** @type {boolean} */
ZC.ZeroClipboardConfig.prototype.bubbleEvents;
 /** @type {boolean} */
ZC.ZeroClipboardConfig.prototype.fixLineEndings;
 /** @type {string} */
ZC.ZeroClipboardConfig.prototype.containerId;
 /** @type {string} */
ZC.ZeroClipboardConfig.prototype.containerClass;
 /** @type {string} */
ZC.ZeroClipboardConfig.prototype.swfObjectId;
 /** @type {string} */
ZC.ZeroClipboardConfig.prototype.hoverClass;
 /** @type {string} */
ZC.ZeroClipboardConfig.prototype.activeClass;
 /** @type {boolean} */
ZC.ZeroClipboardConfig.prototype.forceHandCursor;
 /** @type {string} */
ZC.ZeroClipboardConfig.prototype.title;
 /** @type {number} */
ZC.ZeroClipboardConfig.prototype.zIndex;
 /** @type {!ZC.ZeroClipboardStatic} */
var ZeroClipboard;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "zeroclipboard"
/** @const */
tsickle_declare_module.zeroclipboard = {};

/* TODO: ExportAssignment in tsickle_declare_module.zeroclipboard */
