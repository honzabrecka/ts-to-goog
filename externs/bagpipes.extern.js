/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bagpipes/index.d.ts:
/**
 * @record
 * @struct
 */
function FittingContext() {}
 /** @type {?} */
FittingContext.prototype.input;
 /** @type {?} */
FittingContext.prototype.output;

/* TODO: IndexSignature:  */

/** @typedef {string} */
var FittingType;
/**
 * @record
 * @struct
 */
function FittingDef() {}
 /** @type {string} */
FittingDef.prototype.type;
 /** @type {string} */
FittingDef.prototype.name;
 /** @type {?} */
FittingDef.prototype.config;
 /** @type {?} */
FittingDef.prototype.input;
 /** @type {?} */
FittingDef.prototype.output;

/* TODO: IndexSignature:  */

/** @typedef {?} */
var Fitting;

/** @typedef {?} */
var FittingFactory;
/**
 * @record
 * @struct
 */
function FittingTypesMap() {}

/* TODO: IndexSignature:  */

/** @typedef {(string|!Array<?>|?)} */
var PipeDef;
/**
 * @record
 * @struct
 */
function PipeDefMap() {}

/* TODO: IndexSignature:  */
/**
 * @constructor
 * @struct
 */
function Bagpipes() {}
 /** @type {?} */
Bagpipes.prototype.fittingTypes;
 /** @type {?} */
Bagpipes.prototype.pipes;
 /** @type {?} */
Bagpipes.prototype.config;

/**
 * Creates a `Fitting`
 * @throws {Error} Throws error if an invalid (not defined) fitting typ is used
 *                 (can't find argument `fittingType` in `Bagpipes.fittingTypes`)
 * @param {?} fittingDef
 * @return {?}
 */
Bagpipes.prototype.createFitting = function(fittingDef) {};

/**
 * returns `pipeworks` Pipe instance
 * @param {(string|!Array<?>|?)} pipeDef
 * @return {?}
 */
Bagpipes.prototype.createPipe = function(pipeDef) {};

/**
 * @param {?} fitting
 * @param {?} fittingDef
 * @return {?}
 */
Bagpipes.prototype.createPipeFromFitting = function(fitting, fittingDef) {};

/**
 * Finds and returns a `Pipe` by name and lazily creates if it is not defined
 * @throws {Error} Throws error if `pipeDef` pipe is not yet defined and `pipeDef` is
 *                 not supplied
 * @param {string} pipeName
 * @param {(string|!Array<?>|?)=} pipeDef
 * @return {?}
 */
Bagpipes.prototype.getPipe = function(pipeName, pipeDef) {};

/**
 * Handler for errors that occure when a `Fitting` gets 'played'
 * @param {?} context
 * @param {!Error} err
 * @return {void}
 */
Bagpipes.prototype.handleError = function(context, err) {};

/**
 * Loads `FittingFactory`s from file-system and adds them to `Bagpipes.fittingTypes`
 * @return {?}
 */
Bagpipes.prototype.loadFittingTypes = function() {};

/**
 * Builds a new (wrappend) `Fitting`
 * @throws {Error} Throws error if an invalid (not defined) fitting typ is used
 *                 (can't find argument `fittingType` in `Bagpipes.fittingTypes`)
 * @param {string} fittingType
 * @param {?} fittingDef
 * @return {?}
 */
Bagpipes.prototype.newFitting = function(fittingType, fittingDef) {};

/**
 * Run the pipeline
 * @param {?} pipe
 * @param {?} context
 * @return {void}
 */
Bagpipes.prototype.play = function(pipe, context) {};

/**
 * Wraps `Fitting` with debugging, `preflight`, `postflight`
 * and error handling functionality and returns as new Fitting
 * @param {?} fitting
 * @param {?} fittingDef
 * @return {?}
 */
Bagpipes.prototype.wrapFitting = function(fitting, fittingDef) {};
/**
 * @record
 * @struct
 */
function Config() {}
 /** @type {!Array<string>} */
Config.prototype.connectMiddlewareDirs;
 /** @type {!Array<string>} */
Config.prototype.userFittingsDirs;
 /** @type {!Array<string>} */
Config.prototype.userViewsDirs;

/* TODO: IndexSignature:  */

/**
 * Creates `Bagpipes`
 * @param {?} pipesDefs
 * @param {?=} conf
 * @return {?}
 */
function create(pipesDefs, conf) {}

/** @typedef {string} */
var Affinity;
/**
 * @record
 * @struct
 */
function PipeworksOptions() {}
 /** @type {string} */
PipeworksOptions.prototype.affinity;
/**
 * @constructor
 * @struct
 */
function Pipe() {}

/**
 * add a new `Fitting` (piece) to the pipe (aka. pipeline)
 * add a new `Fitting` (piece) to the pipe (aka. pipeline)
 * @param {?} pipe_or_options
 * @param {?=} pipe
 * @return {?}
 */
Pipe.prototype.fit = function(pipe_or_options, pipe) {};

/**
 * Redirect the flow to another pipe (aka. pipeline).
 * Redirect the flow to another pipe (aka. pipeline).
 * @param {?} pipe_or_options
 * @param {?=} pipe
 * @return {?}
 */
Pipe.prototype.siphon = function(pipe_or_options, pipe) {};

/**
 * Send something down the pipe (aka. pipeline)! Any number of arguments
 * can be sent, but often there's just a single `context` object.
 * @param {...?} args
 * @return {?}
 */
Pipe.prototype.flow = function(args) {};
