/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/slickgrid/index.d.ts:
/**
 * @record
 * @struct
 */
function DOMEvent() {}
/** @const */
var Slick = {};

/**
 * @constructor
 * @struct
 */
Slick.EventData = function() {};

/**
 * 
 * Stops event from propagating up the DOM tree.
 * \@method stopPropagation
 * @return {void}
 */
Slick.EventData.prototype.stopPropagation = function() {};

/**
 * 
 * Returns whether stopPropagation was called on this event object.
 * \@method isPropagationStopped
 * @return {boolean}
 */
Slick.EventData.prototype.isPropagationStopped = function() {};

/**
 * 
 * Prevents the rest of the handlers from being executed.
 * \@method stopImmediatePropagation
 * @return {void}
 */
Slick.EventData.prototype.stopImmediatePropagation = function() {};

/**
 * 
 * Returns whether stopImmediatePropagation was called on this event object.\
 * \@method isImmediatePropagationStopped
 * @return {boolean}
 */
Slick.EventData.prototype.isImmediatePropagationStopped = function() {};

/**
 * @constructor
 * @struct
 */
Slick.Event = function() {};

/**
 * 
 * Adds an event handler to be called when the event is fired.
 * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>
 * object the event was fired with.<p>
 * \@method subscribe
 * @param {function(!Slick.EventData, T): ?|function(!DOMEvent, T): ?} fn {Function} Event handler.
 * @return {void}
 */
Slick.Event.prototype.subscribe = function(fn) {};

/**
 * 
 * Removes an event handler added with <code>subscribe(fn)</code>.
 * \@method unsubscribe
 * @param {function(!Slick.EventData, T): ?|function(!DOMEvent, T): ?} fn {Function} Event handler to be removed.
 * @return {void}
 */
Slick.Event.prototype.unsubscribe = function(fn) {};

/**
 * 
 * Fires an event notifying all subscribers.
 * \@method notify
 * \@note slick.core.Event.notify shows this method as returning a value, type is unknown.
 * @param {T=} args {Object} Additional data object to be passed to all handlers.
 * @param {!Slick.EventData|!DOMEvent=} e {EventData}
 *      Optional.
 *      An <code>EventData</code> object to be passed to all handlers.
 *      For DOM events, an existing W3C/jQuery event object can be passed in.
 * @param {?=} scope {Object}
 *      Optional.
 *      The scope ("this") within which the handler will be executed.
 *      If not specified, the scope will be set to the <code>Event</code> instance.
 * @return {?} Last run callback result.
 */
Slick.Event.prototype.notify = function(args, e, scope) {};

/**
 * @constructor
 * @struct
 */
Slick.EventHandler = function() {};

/**
 * @param {!Slick.EventData} event
 * @param {!Function} handler
 * @return {!Slick.EventHandler}
 */
Slick.EventHandler.prototype.subscribe = function(event, handler) {};

/**
 * @param {!Slick.EventData} event
 * @param {!Function} handler
 * @return {!Slick.EventHandler}
 */
Slick.EventHandler.prototype.unsubscribe = function(event, handler) {};

/**
 * @return {!Slick.EventHandler}
 */
Slick.EventHandler.prototype.unsubscribeAll = function() {};

/**
 * @constructor
 * @struct
 * A structure containing a range of cells.
 * @param {number} fromRow {Integer} Starting row.
 * @param {number} fromCell {Integer} Starting cell.
 * @param {number=} toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.
 * @param {number=} toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.
 * 
 */
Slick.Range = function(fromRow, fromCell, toRow, toCell) {};
 /** @type {number} */
Slick.Range.prototype.fromRow;
 /** @type {number} */
Slick.Range.prototype.fromCell;
 /** @type {number} */
Slick.Range.prototype.toRow;
 /** @type {number} */
Slick.Range.prototype.toCell;

/**
 * 
 * Returns whether a range represents a single row.
 * \@method isSingleRow
 * @return {boolean}
 */
Slick.Range.prototype.isSingleRow = function() {};

/**
 * 
 * Returns whether a range represents a single cell.
 * \@method isSingleCell
 * @return {boolean}
 */
Slick.Range.prototype.isSingleCell = function() {};

/**
 * 
 * Returns whether a range contains a given cell.
 * \@method contains
 * @param {number} row {Integer}
 * @param {number} cell {Integer}
 * @return {boolean}
 */
Slick.Range.prototype.contains = function(row, cell) {};

/**
 * 
 * Returns a readable representation of a range.
 * \@method toString
 * @return {string}
 */
Slick.Range.prototype.toString = function() {};
/**
 * @constructor
 * @struct
 */
Slick.NonDataRow = function() {};

/**
 * @constructor
 * @struct
 */
Slick.Group = function() {};
 /** @type {number} */
Slick.Group.prototype.level;
 /** @type {number} */
Slick.Group.prototype.count;
 /** @type {?} */
Slick.Group.prototype.value;
 /** @type {string} */
Slick.Group.prototype.title;
 /** @type {boolean} */
Slick.Group.prototype.collapsed;
 /** @type {!Slick.GroupTotals<T>} */
Slick.Group.prototype.totals;
 /** @type {!Array<T>} */
Slick.Group.prototype.rows;
 /** @type {!Array<!Slick.Group>} */
Slick.Group.prototype.groups;
 /** @type {?} */
Slick.Group.prototype.groupingKey;

/**
 * 
 * Compares two Group instances.
 * \@method equals
 * @param {!Slick.Group} group {Group} Group instance to compare to.
 * todo: this is on the prototype (NonDataRow()) instance, not Group, maybe doesn't matter?
 * @return {boolean}
 */
Slick.Group.prototype.equals = function(group) {};

/**
 * @constructor
 * @struct
 */
Slick.GroupTotals = function() {};
 /** @type {!Slick.Group<T>} */
Slick.GroupTotals.prototype.group;

/**
 * @constructor
 * @struct
 */
Slick.EditorLock = function() {};

/**
 * 
 * Returns true if a specified edit controller is active (has the edit lock).
 * If the parameter is not specified, returns true if any edit controller is active.
 * \@method isActive
 * @param {!Slick.Editors.Editor<T>} editController {EditController}
 * @return {boolean}
 */
Slick.EditorLock.prototype.isActive = function(editController) {};

/**
 * 
 * Sets the specified edit controller as the active edit controller (acquire edit lock).
 * If another edit controller is already active, and exception will be thrown.
 * \@method activate
 * @param {!Slick.Editors.Editor<T>} editController {EditController} edit controller acquiring the lock
 * @return {void}
 */
Slick.EditorLock.prototype.activate = function(editController) {};

/**
 * 
 * Unsets the specified edit controller as the active edit controller (release edit lock).
 * If the specified edit controller is not the active one, an exception will be thrown.
 * \@method deactivate
 * @param {!Slick.Editors.Editor<T>} editController {EditController} edit controller releasing the lock
 * @return {void}
 */
Slick.EditorLock.prototype.deactivate = function(editController) {};

/**
 * 
 * Attempts to commit the current edit by calling "commitCurrentEdit" method on the active edit
 * controller and returns whether the commit attempt was successful (commit may fail due to validation
 * errors, etc.).  Edit controller's "commitCurrentEdit" must return true if the commit has succeeded
 * and false otherwise.  If no edit controller is active, returns true.
 * \@method commitCurrentEdit
 * @return {boolean}
 */
Slick.EditorLock.prototype.commitCurrentEdit = function() {};

/**
 * 
 * Attempts to cancel the current edit by calling "cancelCurrentEdit" method on the active edit
 * controller and returns whether the edit was successfully cancelled.  If no edit controller is
 * active, returns true.
 * \@method cancelCurrentEdit
 * @return {boolean}
 */
Slick.EditorLock.prototype.cancelCurrentEdit = function() {};
 /** @type {!Slick.EditorLock<!Slick.SlickData>} */
Slick.GlobalEditorLock;
/**
 * @record
 * @struct
 */
Slick.Column = function() {};
 /** @type {function(?, ?, ?, ?): void} */
Slick.Column.prototype.asyncPostRender;
 /** @type {?} */
Slick.Column.prototype.behavior;
 /** @type {boolean} */
Slick.Column.prototype.cannotTriggerInsert;
 /** @type {string} */
Slick.Column.prototype.cssClass;
 /** @type {boolean} */
Slick.Column.prototype.defaultSortAsc;
 /** @type {?} */
Slick.Column.prototype.editor;
 /** @type {string} */
Slick.Column.prototype.field;
 /** @type {boolean} */
Slick.Column.prototype.focusable;
 /** @type {!Slick.Formatter<T>} */
Slick.Column.prototype.formatter;
 /** @type {string} */
Slick.Column.prototype.headerCssClass;
 /** @type {string} */
Slick.Column.prototype.id;
 /** @type {number} */
Slick.Column.prototype.maxWidth;
 /** @type {number} */
Slick.Column.prototype.minWidth;
 /** @type {string} */
Slick.Column.prototype.name;
 /** @type {boolean} */
Slick.Column.prototype.rerenderOnResize;
 /** @type {boolean} */
Slick.Column.prototype.resizable;
 /** @type {boolean} */
Slick.Column.prototype.selectable;
 /** @type {boolean} */
Slick.Column.prototype.sortable;
 /** @type {string} */
Slick.Column.prototype.toolTip;
 /** @type {number} */
Slick.Column.prototype.width;
/**
 * @record
 * @struct
 */
Slick.EditorFactory = function() {};

/**
 * @template T
 * @param {!Slick.Column<T>} column
 * @return {!Slick.Editors.Editor<T>}
 */
Slick.EditorFactory.prototype.getEditor = function(column) {};
/**
 * @record
 * @struct
 */
Slick.FormatterFactory = function() {};

/**
 * @param {!Slick.Column<T>} column
 * @return {!Slick.Formatter<?>}
 */
Slick.FormatterFactory.prototype.getFormatter = function(column) {};
/**
 * @record
 * @struct
 */
Slick.GridOptions = function() {};
 /** @type {boolean} */
Slick.GridOptions.prototype.asyncEditorLoading;
 /** @type {number} */
Slick.GridOptions.prototype.asyncEditorLoadDelay;
 /** @type {number} */
Slick.GridOptions.prototype.asyncPostRenderDelay;
 /** @type {boolean} */
Slick.GridOptions.prototype.autoEdit;
 /** @type {boolean} */
Slick.GridOptions.prototype.autoHeight;
 /** @type {string} */
Slick.GridOptions.prototype.cellFlashingCssClass;
 /** @type {string} */
Slick.GridOptions.prototype.cellHighlightCssClass;
 /** @type {?} */
Slick.GridOptions.prototype.dataItemColumnValueExtractor;
 /** @type {number} */
Slick.GridOptions.prototype.defaultColumnWidth;
 /** @type {!Slick.Formatter<T>} */
Slick.GridOptions.prototype.defaultFormatter;
 /** @type {boolean} */
Slick.GridOptions.prototype.editable;
 /** @type {?} */
Slick.GridOptions.prototype.editCommandHandler;
 /** @type {!Slick.EditorFactory} */
Slick.GridOptions.prototype.editorFactory;
 /** @type {!Slick.EditorLock<T>} */
Slick.GridOptions.prototype.editorLock;
 /** @type {boolean} */
Slick.GridOptions.prototype.enableAddRow;
 /** @type {boolean} */
Slick.GridOptions.prototype.enableAsyncPostRender;
 /** @type {?} */
Slick.GridOptions.prototype.enableCellRangeSelection;
 /** @type {boolean} */
Slick.GridOptions.prototype.enableCellNavigation;
 /** @type {boolean} */
Slick.GridOptions.prototype.enableColumnReorder;
 /** @type {?} */
Slick.GridOptions.prototype.enableRowReordering;
 /** @type {boolean} */
Slick.GridOptions.prototype.enableTextSelectionOnCells;
 /** @type {boolean} */
Slick.GridOptions.prototype.explicitInitialization;
 /** @type {boolean} */
Slick.GridOptions.prototype.forceFitColumns;
 /** @type {boolean} */
Slick.GridOptions.prototype.forceSyncScrolling;
 /** @type {!Slick.FormatterFactory<T>} */
Slick.GridOptions.prototype.formatterFactory;
 /** @type {boolean} */
Slick.GridOptions.prototype.fullWidthRows;
 /** @type {number} */
Slick.GridOptions.prototype.headerRowHeight;
 /** @type {boolean} */
Slick.GridOptions.prototype.leaveSpaceForNewRows;
 /** @type {boolean} */
Slick.GridOptions.prototype.multiColumnSort;
 /** @type {boolean} */
Slick.GridOptions.prototype.multiSelect;
 /** @type {number} */
Slick.GridOptions.prototype.rowHeight;
 /** @type {string} */
Slick.GridOptions.prototype.selectedCellCssClass;
 /** @type {boolean} */
Slick.GridOptions.prototype.showHeaderRow;
 /** @type {boolean} */
Slick.GridOptions.prototype.syncColumnCellResize;
 /** @type {number} */
Slick.GridOptions.prototype.topPanelHeight;
/**
 * @record
 * @struct
 */
Slick.DataProvider = function() {};

/**
 * Returns the number of data items in the set.
 * @return {number}
 */
Slick.DataProvider.prototype.getLength = function() {};

/**
 * Returns the item at a given index.
 * @param {number} index
 * @return {T}
 */
Slick.DataProvider.prototype.getItem = function(index) {};

/**
 * Returns the metadata for the item at a given index (optional).
 * @param {number} index
 * @return {!Slick.RowMetadata<T>}
 */
Slick.DataProvider.prototype.getItemMetadata = function(index) {};
/**
 * @record
 * @struct
 */
Slick.SlickData = function() {};
/**
 * @record
 * @struct
 */
Slick.RowMetadata = function() {};
 /** @type {string} */
Slick.RowMetadata.prototype.cssClasses;
 /** @type {boolean} */
Slick.RowMetadata.prototype.focusable;
 /** @type {boolean} */
Slick.RowMetadata.prototype.selectable;
 /** @type {!Object<string,!Slick.ColumnMetadata<T>>} */
Slick.RowMetadata.prototype.columns;
/**
 * @record
 * @struct
 */
Slick.ColumnMetadata = function() {};
 /** @type {boolean} */
Slick.ColumnMetadata.prototype.focusable;
 /** @type {boolean} */
Slick.ColumnMetadata.prototype.selectable;
 /** @type {!Slick.Formatter<T>} */
Slick.ColumnMetadata.prototype.formatter;
 /** @type {!Slick.Editors.Editor<T>} */
Slick.ColumnMetadata.prototype.editor;
 /** @type {(string|number)} */
Slick.ColumnMetadata.prototype.colspan;
/**
 * @constructor
 * @struct
 */
Slick.SelectionModel = function() {};
 /** @type {!Slick.Event<E>} */
Slick.SelectionModel.prototype.onSelectedRangesChanged;

/**
 * An initializer function that will be called with an instance of the grid whenever a selection model is registered with setSelectionModel. The selection model can use this to initialize its state and subscribe to grid events.
 * 
 * @param {!Slick.Grid<T>} grid
 * @return {void}
 */
Slick.SelectionModel.prototype.init = function(grid) {};

/**
 * A destructor function that will be called whenever a selection model is unregistered from the grid by a call to setSelectionModel with another selection model or whenever a grid with this selection model is destroyed. The selection model can use this destructor to unsubscribe from grid events and release all resources (remove DOM nodes, event listeners, etc.).
 * 
 * @return {void}
 */
Slick.SelectionModel.prototype.destroy = function() {};

/**
 * @constructor
 * @struct
 * Create an instance of the grid.
 * @param {(string|!HTMLElement|?<!HTMLElement>)} container Container node to create the grid in. This can be a DOM Element, a jQuery node, or a jQuery selector.
 * @param {(!Array<T>|!Slick.DataProvider<T>)} data Databinding source. This can either be a regular JavaScript array or a custom object exposing getItem(index) and getLength() functions.
 * @param {!Array<!Slick.Column<T>>} columns An array of column definition objects. See Column Options for a list of options that can be included on each column definition object.
 * @param {!Slick.GridOptions<T>} options Additional options.  See Grid Options for a list of options that can be included.
 * 
 */
Slick.Grid = function(container, data, columns, options) {};
 /** @type {!Slick.Event<!Slick.OnScrollEventArgs<T>>} */
Slick.Grid.prototype.onScroll;
 /** @type {!Slick.Event<!Slick.OnSortEventArgs<T>>} */
Slick.Grid.prototype.onSort;
 /** @type {!Slick.Event<!Slick.OnHeaderMouseEventArgs<T>>} */
Slick.Grid.prototype.onHeaderMouseEnter;
 /** @type {!Slick.Event<!Slick.OnHeaderMouseEventArgs<T>>} */
Slick.Grid.prototype.onHeaderMouseLeave;
 /** @type {!Slick.Event<!Slick.OnHeaderContextMenuEventArgs<T>>} */
Slick.Grid.prototype.onHeaderContextMenu;
 /** @type {!Slick.Event<!Slick.OnHeaderClickEventArgs<T>>} */
Slick.Grid.prototype.onHeaderClick;
 /** @type {!Slick.Event<!Slick.OnHeaderCellRenderedEventArgs<T>>} */
Slick.Grid.prototype.onHeaderCellRendered;
 /** @type {!Slick.Event<!Slick.OnBeforeHeaderCellDestroyEventArgs<T>>} */
Slick.Grid.prototype.onBeforeHeaderCellDestroy;
 /** @type {!Slick.Event<!Slick.OnHeaderRowCellRenderedEventArgs<T>>} */
Slick.Grid.prototype.onHeaderRowCellRendered;
 /** @type {!Slick.Event<!Slick.OnBeforeHeaderRowCellDestroyEventArgs<T>>} */
Slick.Grid.prototype.onBeforeHeaderRowCellDestroy;
 /** @type {!Slick.Event<!Slick.OnMouseEnterEventArgs<T>>} */
Slick.Grid.prototype.onMouseEnter;
 /** @type {!Slick.Event<!Slick.OnMouseLeaveEventArgs<T>>} */
Slick.Grid.prototype.onMouseLeave;
 /** @type {!Slick.Event<!Slick.OnClickEventArgs<T>>} */
Slick.Grid.prototype.onClick;
 /** @type {!Slick.Event<!Slick.OnDblClickEventArgs<T>>} */
Slick.Grid.prototype.onDblClick;
 /** @type {!Slick.Event<!Slick.OnContextMenuEventArgs<T>>} */
Slick.Grid.prototype.onContextMenu;
 /** @type {!Slick.Event<!Slick.OnKeyDownEventArgs<T>>} */
Slick.Grid.prototype.onKeyDown;
 /** @type {!Slick.Event<!Slick.OnAddNewRowEventArgs<T>>} */
Slick.Grid.prototype.onAddNewRow;
 /** @type {!Slick.Event<!Slick.OnValidationErrorEventArgs<T>>} */
Slick.Grid.prototype.onValidationError;
 /** @type {!Slick.Event<!Slick.OnColumnsReorderedEventArgs<T>>} */
Slick.Grid.prototype.onColumnsReordered;
 /** @type {!Slick.Event<!Slick.OnColumnsResizedEventArgs<T>>} */
Slick.Grid.prototype.onColumnsResized;
 /** @type {!Slick.Event<!Slick.OnCellChangeEventArgs<T>>} */
Slick.Grid.prototype.onCellChange;
 /** @type {!Slick.Event<!Slick.OnBeforeEditCellEventArgs<T>>} */
Slick.Grid.prototype.onBeforeEditCell;
 /** @type {!Slick.Event<!Slick.OnBeforeCellEditorDestroyEventArgs<T>>} */
Slick.Grid.prototype.onBeforeCellEditorDestroy;
 /** @type {!Slick.Event<!Slick.OnBeforeDestroyEventArgs<T>>} */
Slick.Grid.prototype.onBeforeDestroy;
 /** @type {!Slick.Event<!Slick.OnActiveCellChangedEventArgs<T>>} */
Slick.Grid.prototype.onActiveCellChanged;
 /** @type {!Slick.Event<!Slick.OnActiveCellPositionChangedEventArgs<T>>} */
Slick.Grid.prototype.onActiveCellPositionChanged;
 /** @type {!Slick.Event<!Slick.OnDragInitEventArgs<T>>} */
Slick.Grid.prototype.onDragInit;
 /** @type {!Slick.Event<!Slick.OnDragStartEventArgs<T>>} */
Slick.Grid.prototype.onDragStart;
 /** @type {!Slick.Event<!Slick.OnDragEventArgs<T>>} */
Slick.Grid.prototype.onDrag;
 /** @type {!Slick.Event<!Slick.OnDragEndEventArgs<T>>} */
Slick.Grid.prototype.onDragEnd;
 /** @type {!Slick.Event<!Slick.OnSelectedRowsChangedEventArgs<T>>} */
Slick.Grid.prototype.onSelectedRowsChanged;
 /** @type {!Slick.Event<!Slick.OnCellCssStylesChangedEventArgs<T>>} */
Slick.Grid.prototype.onCellCssStylesChanged;
 /** @type {!Slick.Event<!Slick.OnViewportChangedEventArgs<T>>} */
Slick.Grid.prototype.onViewportChanged;

/**
 * Initializes the grid. Called after plugins are registered. Normally, this is called by the constructor, so you don't need to call it. However, in certain cases you may need to delay the initialization until some other process has finished. In that case, set the explicitInitialization option to true and call the grid.init() manually.
 * 
 * @return {void}
 */
Slick.Grid.prototype.init = function() {};

/**
 * todo: no docs
 * 
 * @return {void}
 */
Slick.Grid.prototype.destroy = function() {};

/**
 * Returns an array of every data object, unless you're using DataView in which case it returns a DataView object.
 * @return {?} 
 * 
 */
Slick.Grid.prototype.getData = function() {};

/**
 * Returns the databinding item at a given position.
 * @param {number} index Item index.
 * @return {T} 
 * 
 */
Slick.Grid.prototype.getDataItem = function(index) {};

/**
 * Sets a new source for databinding and removes all rendered rows. Note that this doesn't render the new rows - you can follow it with a call to render() to do that.
 * Sets a new source for databinding and removes all rendered rows. Note that this doesn't render the new rows - you can follow it with a call to render() to do that.
 * @param {!Array<T>|!Slick.DataProvider<T>} newData New databinding source using a regular JavaScript array.. / New databinding source using a custom object exposing getItem(index) and getLength() functions.
 * @param {boolean} scrollToTop If true, the grid will reset the vertical scroll position to the top of the grid.
 * 
 * @return {void}
 */
Slick.Grid.prototype.setData = function(newData, scrollToTop) {};

/**
 * Returns the size of the databinding source.
 * @return {number} 
 * 
 */
Slick.Grid.prototype.getDataLength = function() {};

/**
 * Returns an object containing all of the Grid options set on the grid. See a list of Grid Options here.
 * @return {!Slick.GridOptions<?>} 
 * 
 */
Slick.Grid.prototype.getOptions = function() {};

/**
 * Returns an array of row indices corresponding to the currently selected rows.
 * @return {!Array<number>} 
 * 
 */
Slick.Grid.prototype.getSelectedRows = function() {};

/**
 * Returns the current SelectionModel. See here for more information about SelectionModels.
 * @return {!Slick.SelectionModel<?, ?>} 
 * 
 */
Slick.Grid.prototype.getSelectionModel = function() {};

/**
 * Extends grid options with a given hash. If an there is an active edit, the grid will attempt to commit the changes and only continue if the attempt succeeds.
 * \@options An object with configuration options.
 * 
 * @param {!Slick.GridOptions<T>} options
 * @return {void}
 */
Slick.Grid.prototype.setOptions = function(options) {};

/**
 * Accepts an array of row indices and applies the current selectedCellCssClass to the cells in the row, respecting whether cells have been flagged as selectable.
 * @param {!Array<number>} rowsArray An array of row numbers.
 * 
 * @return {void}
 */
Slick.Grid.prototype.setSelectedRows = function(rowsArray) {};

/**
 * Returns container's HTML node (the element passed into Grid constructor).
 * @return {!HTMLElement}
 */
Slick.Grid.prototype.getContainerNode = function() {};

/**
 * Unregisters a current selection model and registers a new one. See the definition of SelectionModel for more information.
 * \@selectionModel A SelectionModel.
 * 
 * @param {!Slick.SelectionModel<T, ?>} selectionModel
 * @return {void}
 */
Slick.Grid.prototype.setSelectionModel = function(selectionModel) {};

/**
 * Proportionately resizes all columns to fill available horizontal space. This does not take the cell contents into consideration.
 * 
 * @return {void}
 */
Slick.Grid.prototype.autosizeColumns = function() {};

/**
 * Returns the index of a column with a given id. Since columns can be reordered by the user, this can be used to get the column definition independent of the order:
 * @param {string} id A column id.
 * @return {number} 
 * 
 */
Slick.Grid.prototype.getColumnIndex = function(id) {};

/**
 * Returns an array of column definitions, containing the option settings for each individual column.
 * @return {!Array<!Slick.Column<T>>} 
 * 
 */
Slick.Grid.prototype.getColumns = function() {};

/**
 * Sets grid columns. Column headers will be recreated and all rendered rows will be removed. To rerender the grid (if necessary), call render().
 * @param {!Array<!Slick.Column<T>>} columnDefinitions An array of column definitions.
 * 
 * @return {void}
 */
Slick.Grid.prototype.setColumns = function(columnDefinitions) {};

/**
 * Accepts a columnId string and an ascending boolean. Applies a sort glyph in either ascending or descending form to the header of the column. Note that this does not actually sort the column. It only adds the sort glyph to the header.
 * @param {string} columnId
 * @param {boolean} ascending 
 * 
 * @return {void}
 */
Slick.Grid.prototype.setSortColumn = function(columnId, ascending) {};

/**
 * Accepts an array of objects in the form [ { columnId: [string], sortAsc: [boolean] }, ... ]. When called, this will apply a sort glyph in either ascending or descending form to the header of each column specified in the array. Note that this does not actually sort the column. It only adds the sort glyph to the header
 * @param {!Array<{columnId: string, sortAsc: boolean}>} cols 
 * 
 * @return {void}
 */
Slick.Grid.prototype.setSortColumns = function(cols) {};

/**
 * todo: no docs or comments available
 * @return {!Array<{columnId: string, sortAsc: boolean}>} 
 * 
 */
Slick.Grid.prototype.getSortColumns = function() {};

/**
 * Updates an existing column definition and a corresponding header DOM element with the new title and tooltip.
 * @param {string} columnId Column id.
 * @param {string=} title New column name.
 * @param {string=} toolTip New column tooltip.
 * 
 * @return {void}
 */
Slick.Grid.prototype.updateColumnHeader = function(columnId, title, toolTip) {};

/**
 * Adds an "overlay" of CSS classes to cell DOM elements. SlickGrid can have many such overlays associated with different keys and they are frequently used by plugins. For example, SlickGrid uses this method internally to decorate selected cells with selectedCellCssClass (see options).
 * \@example 
 * {
 * 	0:    {
 * 		"number_column":    "cell-bold",
 * 		"title_column":     "cell-title cell-highlighted"
 * 	},
 * 	4:    {
 * 		"percent_column":    "cell-highlighted"
 * 	}
 * }
 * 
 * @param {string} key A unique key you can use in calls to setCellCssStyles and removeCellCssStyles. If a hash with that key has already been set, an exception will be thrown.
 * @param {!Slick.CellCssStylesHash} hash A hash of additional cell CSS classes keyed by row number and then by column id. Multiple CSS classes can be specified and separated by space.
 * @return {void}
 */
Slick.Grid.prototype.addCellCssStyles = function(key, hash) {};

/**
 * Returns true if you can click on a given cell and make it the active focus.
 * @param {number} row A row index.
 * @param {number} col A column index.
 * @return {boolean} 
 * 
 */
Slick.Grid.prototype.canCellBeActive = function(row, col) {};

/**
 * Returns true if selecting the row causes this particular cell to have the selectedCellCssClass applied to it. A cell can be selected if it exists and if it isn't on an empty / "Add New" row and if it is not marked as "unselectable" in the column definition.
 * @param {number} row A row index.
 * @param {number} col A column index.
 * @return {boolean} 
 * 
 */
Slick.Grid.prototype.canCellBeSelected = function(row, col) {};

/**
 * Attempts to switch the active cell into edit mode. Will throw an error if the cell is set to be not editable. Uses the specified editor, otherwise defaults to any default editor for that given cell.
 * @param {!Slick.Editors.Editor<T>} editor A SlickGrid editor (see examples in slick.editors.js).
 * 
 * @return {void}
 */
Slick.Grid.prototype.editActiveCell = function(editor) {};

/**
 * Flashes the cell twice by toggling the CSS class 4 times.
 * @param {number} row A row index.
 * @param {number} cell A column index.
 * @param {number=} speed (optional) - The milliseconds delay between the toggling calls. Defaults to 100 ms.
 * 
 * @return {void}
 */
Slick.Grid.prototype.flashCell = function(row, cell, speed) {};

/**
 * Returns an object representing the coordinates of the currently active cell:
 * \@example 
 * 	{
 * 	  row: activeRow,
 * 	  cell: activeCell
 * 	}
 * @return {!Slick.Cell} 
 * 
 */
Slick.Grid.prototype.getActiveCell = function() {};

/**
 * Returns the DOM element containing the currently active cell. If no cell is active, null is returned.
 * @return {!HTMLElement} 
 * 
 */
Slick.Grid.prototype.getActiveCellNode = function() {};

/**
 * Returns an object representing information about the active cell's position. All coordinates are absolute and take into consideration the visibility and scrolling position of all ancestors.
 * @return {!Slick.CellPosition} 
 * 
 */
Slick.Grid.prototype.getActiveCellPosition = function() {};

/**
 * Accepts a key name, returns the group of CSS styles defined under that name. See setCellCssStyles for more info.
 * @param {string} key A string.
 * @return {!Slick.CellCssStylesHash} 
 * 
 */
Slick.Grid.prototype.getCellCssStyles = function(key) {};

/**
 * Returns the active cell editor. If there is no actively edited cell, null is returned.
 * @return {!Slick.Editors.Editor<?>} 
 * 
 */
Slick.Grid.prototype.getCellEditor = function() {};

/**
 * Returns a hash containing row and cell indexes from a standard W3C/jQuery event.
 * @param {!DOMEvent} e A standard W3C/jQuery event.
 * @return {!Slick.Cell} 
 * 
 */
Slick.Grid.prototype.getCellFromEvent = function(e) {};

/**
 * Returns a hash containing row and cell indexes. Coordinates are relative to the top left corner of the grid beginning with the first row (not including the column headers).
 * @param {number} x An x coordinate.
 * @param {number} y A y coordinate.
 * @return {!Slick.Cell} 
 * 
 */
Slick.Grid.prototype.getCellFromPoint = function(x, y) {};

/**
 * Returns a DOM element containing a cell at a given row and cell.
 * @param {number} row A row index.
 * @param {number} cell A column index.
 * @return {!HTMLElement} 
 * 
 */
Slick.Grid.prototype.getCellNode = function(row, cell) {};

/**
 * Returns an object representing information about a cell's position. All coordinates are absolute and take into consideration the visibility and scrolling position of all ancestors.
 * @param {number} row A row index.
 * @param {number} cell A column index.
 * @return {!Slick.CellPosition} 
 * 
 */
Slick.Grid.prototype.getCellNodeBox = function(row, cell) {};

/**
 * Accepts a row integer and a cell integer, scrolling the view to the row where row is its row index, and cell is its cell index. Optionally accepts a forceEdit boolean which, if true, will attempt to initiate the edit dialogue for the field in the specified cell.
 * Unlike setActiveCell, this scrolls the row into the viewport and sets the keyboard focus.
 * @param {number} row A row index.
 * @param {number} cell A column index.
 * @param {boolean=} forceEdit If true, will attempt to initiate the edit dialogue for the field in the specified cell.
 * @return {void} 
 * 
 */
Slick.Grid.prototype.gotoCell = function(row, cell, forceEdit) {};

/**
 * todo: no docs
 * @return {!HTMLElement} 
 * 
 */
Slick.Grid.prototype.getTopPanel = function() {};

/**
 * todo: no docs
 * @param {boolean} visible 
 * 
 * @return {void}
 */
Slick.Grid.prototype.setTopPanelVisibility = function(visible) {};

/**
 * todo: no docs
 * @param {boolean} visible 
 * 
 * @return {void}
 */
Slick.Grid.prototype.setHeaderRowVisibility = function(visible) {};

/**
 * todo: no docs
 * @return {!HTMLElement} 
 * 
 */
Slick.Grid.prototype.getHeaderRow = function() {};

/**
 * todo: no docs, return type is probably wrong -> "return $header && $header[0]"
 * @param {string} columnId
 * @return {!Slick.Column<?>} 
 * 
 */
Slick.Grid.prototype.getHeaderRowColumn = function(columnId) {};

/**
 * todo: no docs
 * @return {!Slick.CellPosition} 
 * 
 */
Slick.Grid.prototype.getGridPosition = function() {};

/**
 * Switches the active cell one row down skipping unselectable cells. Returns a boolean saying whether it was able to complete or not.
 * @return {boolean} 
 * 
 */
Slick.Grid.prototype.navigateDown = function() {};

/**
 * Switches the active cell one cell left skipping unselectable cells. Unline navigatePrev, navigateLeft stops at the first cell of the row. Returns a boolean saying whether it was able to complete or not.
 * @return {boolean} 
 * 
 */
Slick.Grid.prototype.navigateLeft = function() {};

/**
 * Tabs over active cell to the next selectable cell. Returns a boolean saying whether it was able to complete or not.
 * @return {boolean} 
 * 
 */
Slick.Grid.prototype.navigateNext = function() {};

/**
 * Tabs over active cell to the previous selectable cell. Returns a boolean saying whether it was able to complete or not.
 * @return {boolean} 
 * 
 */
Slick.Grid.prototype.navigatePrev = function() {};

/**
 * Switches the active cell one cell right skipping unselectable cells. Unline navigateNext, navigateRight stops at the last cell of the row. Returns a boolean saying whether it was able to complete or not.
 * @return {boolean} 
 * 
 */
Slick.Grid.prototype.navigateRight = function() {};

/**
 * Switches the active cell one row up skipping unselectable cells. Returns a boolean saying whether it was able to complete or not.
 * @return {boolean} 
 * 
 */
Slick.Grid.prototype.navigateUp = function() {};

/**
 * Removes an "overlay" of CSS classes from cell DOM elements. See setCellCssStyles for more.
 * @param {string} key A string key.
 * 
 * @return {void}
 */
Slick.Grid.prototype.removeCellCssStyles = function(key) {};

/**
 * Resets active cell.
 * 
 * @return {void}
 */
Slick.Grid.prototype.resetActiveCell = function() {};

/**
 * Sets an active cell.
 * @param {number} row A row index.
 * @param {number} cell A column index.
 * 
 * @return {void}
 */
Slick.Grid.prototype.setActiveCell = function(row, cell) {};

/**
 * Sets CSS classes to specific grid cells by calling removeCellCssStyles(key) followed by addCellCssStyles(key, hash). key is name for this set of styles so you can reference it later - to modify it or remove it, for example. hash is a per-row-index, per-column-name nested hash of CSS classes to apply.
 * Suppose you have a grid with columns:
 * ["login", "name", "birthday", "age", "likes_icecream", "favorite_cake"]
 * ...and you'd like to highlight the "birthday" and "age" columns for people whose birthday is today, in this case, rows at index 0 and 9. (The first and tenth row in the grid).
 * @param {string} key A string key. Will overwrite any data already associated with this key.
 * @param {!Slick.CellCssStylesHash} hash A hash of additional cell CSS classes keyed by row number and then by column id. Multiple CSS classes can be specified and separated by space.
 * 
 * @return {void}
 */
Slick.Grid.prototype.setCellCssStyles = function(key, hash) {};

/**
 * @param {!Slick.Plugin<T>} plugin
 * @return {void}
 */
Slick.Grid.prototype.registerPlugin = function(plugin) {};

/**
 * @param {!Slick.Plugin<T>} plugin
 * @return {void}
 */
Slick.Grid.prototype.unregisterPlugin = function(plugin) {};

/**
 * @return {void}
 */
Slick.Grid.prototype.render = function() {};

/**
 * @return {void}
 */
Slick.Grid.prototype.invalidate = function() {};

/**
 * @param {number} row
 * @return {void}
 */
Slick.Grid.prototype.invalidateRow = function(row) {};

/**
 * @param {!Array<number>} rows
 * @return {void}
 */
Slick.Grid.prototype.invalidateRows = function(rows) {};

/**
 * @return {void}
 */
Slick.Grid.prototype.invalidateAllRows = function() {};

/**
 * @param {number} row
 * @param {number} cell
 * @return {void}
 */
Slick.Grid.prototype.updateCell = function(row, cell) {};

/**
 * @param {number} row
 * @return {void}
 */
Slick.Grid.prototype.updateRow = function(row) {};

/**
 * @param {number=} viewportTop
 * @param {number=} viewportLeft
 * @return {!Slick.Viewport}
 */
Slick.Grid.prototype.getViewport = function(viewportTop, viewportLeft) {};

/**
 * @param {number=} viewportTop
 * @param {number=} viewportLeft
 * @return {!Slick.Viewport}
 */
Slick.Grid.prototype.getRenderedRange = function(viewportTop, viewportLeft) {};

/**
 * @return {void}
 */
Slick.Grid.prototype.resizeCanvas = function() {};

/**
 * @return {void}
 */
Slick.Grid.prototype.updateRowCount = function() {};

/**
 * @param {number} row
 * @param {boolean} doPaging
 * @return {void}
 */
Slick.Grid.prototype.scrollRowIntoView = function(row, doPaging) {};

/**
 * @param {number} row
 * @return {void}
 */
Slick.Grid.prototype.scrollRowToTop = function(row) {};

/**
 * @param {number} row
 * @param {number} cell
 * @param {boolean} doPaging
 * @return {void}
 */
Slick.Grid.prototype.scrollCellIntoView = function(row, cell, doPaging) {};

/**
 * @return {!HTMLCanvasElement}
 */
Slick.Grid.prototype.getCanvasNode = function() {};

/**
 * @return {void}
 */
Slick.Grid.prototype.focus = function() {};

/**
 * @return {!Slick.EditorLock<?>}
 */
Slick.Grid.prototype.getEditorLock = function() {};

/**
 * @return {{commitCurrentEdit: function(): boolean, cancelCurrentEdit: function(): boolean}}
 */
Slick.Grid.prototype.getEditController = function() {};
/**
 * @record
 * @struct
 */
Slick.GridEventArgs = function() {};
 /** @type {!Slick.Grid<T>} */
Slick.GridEventArgs.prototype.grid;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnCellCssStylesChangedEventArgs = function() {};
 /** @type {string} */
Slick.OnCellCssStylesChangedEventArgs.prototype.key;
 /** @type {!Slick.CellCssStylesHash} */
Slick.OnCellCssStylesChangedEventArgs.prototype.hash;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnSelectedRowsChangedEventArgs = function() {};
 /** @type {!Array<number>} */
Slick.OnSelectedRowsChangedEventArgs.prototype.rows;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnDragEndEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnDragEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnDragStartEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnDragInitEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnActiveCellPositionChangedEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnActiveCellChangedEventArgs = function() {};
 /** @type {number} */
Slick.OnActiveCellChangedEventArgs.prototype.row;
 /** @type {number} */
Slick.OnActiveCellChangedEventArgs.prototype.cell;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnBeforeDestroyEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnBeforeCellEditorDestroyEventArgs = function() {};
 /** @type {!Slick.Editors.Editor<T>} */
Slick.OnBeforeCellEditorDestroyEventArgs.prototype.editor;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnBeforeEditCellEventArgs = function() {};
 /** @type {number} */
Slick.OnBeforeEditCellEventArgs.prototype.row;
 /** @type {number} */
Slick.OnBeforeEditCellEventArgs.prototype.cell;
 /** @type {T} */
Slick.OnBeforeEditCellEventArgs.prototype.item;
 /** @type {!Slick.Column<T>} */
Slick.OnBeforeEditCellEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnCellChangeEventArgs = function() {};
 /** @type {number} */
Slick.OnCellChangeEventArgs.prototype.row;
 /** @type {number} */
Slick.OnCellChangeEventArgs.prototype.cell;
 /** @type {T} */
Slick.OnCellChangeEventArgs.prototype.item;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnColumnsResizedEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnColumnsReorderedEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnValidationErrorEventArgs = function() {};
 /** @type {!Slick.Editors.Editor<T>} */
Slick.OnValidationErrorEventArgs.prototype.editor;
 /** @type {!HTMLElement} */
Slick.OnValidationErrorEventArgs.prototype.cellNode;
 /** @type {!Slick.ValidateResults} */
Slick.OnValidationErrorEventArgs.prototype.validationResults;
 /** @type {number} */
Slick.OnValidationErrorEventArgs.prototype.row;
 /** @type {number} */
Slick.OnValidationErrorEventArgs.prototype.cell;
 /** @type {!Slick.Column<T>} */
Slick.OnValidationErrorEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnAddNewRowEventArgs = function() {};
 /** @type {T} */
Slick.OnAddNewRowEventArgs.prototype.item;
 /** @type {!Slick.Column<T>} */
Slick.OnAddNewRowEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnKeyDownEventArgs = function() {};
 /** @type {number} */
Slick.OnKeyDownEventArgs.prototype.row;
 /** @type {number} */
Slick.OnKeyDownEventArgs.prototype.cell;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnContextMenuEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnDblClickEventArgs = function() {};
 /** @type {number} */
Slick.OnDblClickEventArgs.prototype.row;
 /** @type {number} */
Slick.OnDblClickEventArgs.prototype.cell;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnClickEventArgs = function() {};
 /** @type {number} */
Slick.OnClickEventArgs.prototype.row;
 /** @type {number} */
Slick.OnClickEventArgs.prototype.cell;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnMouseLeaveEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnMouseEnterEventArgs = function() {};
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnBeforeHeaderRowCellDestroyEventArgs = function() {};
 /** @type {!HTMLElement} */
Slick.OnBeforeHeaderRowCellDestroyEventArgs.prototype.node;
 /** @type {!Slick.Column<T>} */
Slick.OnBeforeHeaderRowCellDestroyEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnHeaderRowCellRenderedEventArgs = function() {};
 /** @type {!HTMLElement} */
Slick.OnHeaderRowCellRenderedEventArgs.prototype.node;
 /** @type {!Slick.Column<T>} */
Slick.OnHeaderRowCellRenderedEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnBeforeHeaderCellDestroyEventArgs = function() {};
 /** @type {!HTMLElement} */
Slick.OnBeforeHeaderCellDestroyEventArgs.prototype.node;
 /** @type {!Slick.Column<T>} */
Slick.OnBeforeHeaderCellDestroyEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnHeaderCellRenderedEventArgs = function() {};
 /** @type {!HTMLElement} */
Slick.OnHeaderCellRenderedEventArgs.prototype.node;
 /** @type {!Slick.Column<T>} */
Slick.OnHeaderCellRenderedEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnHeaderClickEventArgs = function() {};
 /** @type {!Slick.Column<T>} */
Slick.OnHeaderClickEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnHeaderContextMenuEventArgs = function() {};
 /** @type {!Slick.Column<T>} */
Slick.OnHeaderContextMenuEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnHeaderMouseEventArgs = function() {};
 /** @type {!Slick.Column<T>} */
Slick.OnHeaderMouseEventArgs.prototype.column;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnSortEventArgs = function() {};
 /** @type {boolean} */
Slick.OnSortEventArgs.prototype.multiColumnSort;
 /** @type {!Slick.Column<T>} */
Slick.OnSortEventArgs.prototype.sortCol;
 /** @type {boolean} */
Slick.OnSortEventArgs.prototype.sortAsc;
 /** @type {!Array<!Slick.SortColumn<T>>} */
Slick.OnSortEventArgs.prototype.sortCols;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnScrollEventArgs = function() {};
 /** @type {number} */
Slick.OnScrollEventArgs.prototype.scrollLeft;
 /** @type {number} */
Slick.OnScrollEventArgs.prototype.scrollTop;
/**
 * @extends {Slick.GridEventArgs}
 * @record
 * @struct
 */
Slick.OnViewportChangedEventArgs = function() {};
/**
 * @record
 * @struct
 */
Slick.SortColumn = function() {};
 /** @type {!Slick.Column<T>} */
Slick.SortColumn.prototype.sortCol;
 /** @type {boolean} */
Slick.SortColumn.prototype.sortAsc;
/**
 * @record
 * @struct
 */
Slick.Cell = function() {};
 /** @type {number} */
Slick.Cell.prototype.row;
 /** @type {number} */
Slick.Cell.prototype.cell;
/**
 * @record
 * @struct
 */
Slick.Position = function() {};
 /** @type {number} */
Slick.Position.prototype.top;
 /** @type {number} */
Slick.Position.prototype.left;
/**
 * @extends {Slick.Position}
 * @record
 * @struct
 */
Slick.CellPosition = function() {};
 /** @type {number} */
Slick.CellPosition.prototype.bottom;
 /** @type {number} */
Slick.CellPosition.prototype.height;
 /** @type {number} */
Slick.CellPosition.prototype.right;
 /** @type {boolean} */
Slick.CellPosition.prototype.visible;
 /** @type {number} */
Slick.CellPosition.prototype.width;
/**
 * @record
 * @struct
 */
Slick.CellCssStylesHash = function() {};

/* TODO: IndexSignature: Slick */
/**
 * @record
 * @struct
 */
Slick.Viewport = function() {};
 /** @type {number} */
Slick.Viewport.prototype.top;
 /** @type {number} */
Slick.Viewport.prototype.bottom;
 /** @type {number} */
Slick.Viewport.prototype.leftPx;
 /** @type {number} */
Slick.Viewport.prototype.rightPx;
/**
 * @record
 * @struct
 */
Slick.ValidateResults = function() {};
 /** @type {boolean} */
Slick.ValidateResults.prototype.valid;
 /** @type {string} */
Slick.ValidateResults.prototype.msg;
/** @const */
Slick.Editors = {};
/**
 * @record
 * @struct
 */
Slick.Editors.EditorOptions = function() {};
 /** @type {!Slick.Column<T>} */
Slick.Editors.EditorOptions.prototype.column;
 /** @type {!HTMLElement} */
Slick.Editors.EditorOptions.prototype.container;
 /** @type {!Slick.Grid<T>} */
Slick.Editors.EditorOptions.prototype.grid;
 /** @type {T} */
Slick.Editors.EditorOptions.prototype.item;
 /** @type {function(): void} */
Slick.Editors.EditorOptions.prototype.commitChanges;
 /** @type {function(): void} */
Slick.Editors.EditorOptions.prototype.cancelChanges;
 /** @type {!Slick.CellPosition} */
Slick.Editors.EditorOptions.prototype.gridPosition;
 /** @type {!Slick.CellPosition} */
Slick.Editors.EditorOptions.prototype.position;

/**
 * @constructor
 * @struct
 * @param {!Slick.Editors.EditorOptions<T>} args
 */
Slick.Editors.Editor = function(args) {};

/**
 * @return {void}
 */
Slick.Editors.Editor.prototype.init = function() {};

/**
 * @return {void}
 */
Slick.Editors.Editor.prototype.destroy = function() {};

/**
 * @return {void}
 */
Slick.Editors.Editor.prototype.focus = function() {};

/**
 * @param {T} item
 * @return {void}
 */
Slick.Editors.Editor.prototype.loadValue = function(item) {};

/**
 * @param {T} item
 * @param {string} state
 * @return {void}
 */
Slick.Editors.Editor.prototype.applyValue = function(item, state) {};

/**
 * @return {boolean}
 */
Slick.Editors.Editor.prototype.isValueChanged = function() {};

/**
 * @return {?}
 */
Slick.Editors.Editor.prototype.serializeValue = function() {};

/**
 * @return {!Slick.ValidateResults}
 */
Slick.Editors.Editor.prototype.validate = function() {};

/**
 * @constructor
 * @struct
 * @param {!Slick.Editors.EditorOptions<T>} args
 */
Slick.Editors.Text = function(args) {};

/**
 * @return {string}
 */
Slick.Editors.Text.prototype.getValue = function() {};

/**
 * @param {string} val
 * @return {void}
 */
Slick.Editors.Text.prototype.setValue = function(val) {};

/**
 * @return {string}
 */
Slick.Editors.Text.prototype.serializeValue = function() {};

/**
 * @constructor
 * @struct
 * @param {!Slick.Editors.EditorOptions<T>} args
 */
Slick.Editors.Integer = function(args) {};

/**
 * @return {number}
 */
Slick.Editors.Integer.prototype.serializeValue = function() {};

/**
 * @constructor
 * @struct
 * @param {!Slick.Editors.EditorOptions<T>} args
 */
Slick.Editors.Date = function(args) {};

/**
 * @return {void}
 */
Slick.Editors.Date.prototype.show = function() {};

/**
 * @return {void}
 */
Slick.Editors.Date.prototype.hide = function() {};

/**
 * @param {!Slick.Position} position
 * @return {void}
 */
Slick.Editors.Date.prototype.position = function(position) {};

/**
 * @return {string}
 */
Slick.Editors.Date.prototype.serializeValue = function() {};

/**
 * @constructor
 * @struct
 * @param {!Slick.Editors.EditorOptions<T>} args
 */
Slick.Editors.YesNoSelect = function(args) {};

/**
 * @return {boolean}
 */
Slick.Editors.YesNoSelect.prototype.serializeValue = function() {};

/**
 * @constructor
 * @struct
 * @param {!Slick.Editors.EditorOptions<T>} args
 */
Slick.Editors.Checkbox = function(args) {};

/**
 * @return {boolean}
 */
Slick.Editors.Checkbox.prototype.serializeValue = function() {};

/**
 * @constructor
 * @struct
 * @param {!Slick.Editors.EditorOptions<T>} args
 */
Slick.Editors.PercentComplete = function(args) {};

/**
 * @return {number}
 */
Slick.Editors.PercentComplete.prototype.serializeValue = function() {};

/**
 * @constructor
 * @struct
 * @param {!Slick.Editors.EditorOptions<T>} args
 */
Slick.Editors.LongText = function(args) {};

/**
 * @param {!DOMEvent} e
 * @return {void}
 */
Slick.Editors.LongText.prototype.handleKeyDown = function(e) {};

/**
 * @return {void}
 */
Slick.Editors.LongText.prototype.save = function() {};

/**
 * @return {void}
 */
Slick.Editors.LongText.prototype.cancel = function() {};

/**
 * @return {void}
 */
Slick.Editors.LongText.prototype.hide = function() {};

/**
 * @return {void}
 */
Slick.Editors.LongText.prototype.show = function() {};

/**
 * @param {!Slick.Position} position
 * @return {void}
 */
Slick.Editors.LongText.prototype.position = function(position) {};

/**
 * @return {string}
 */
Slick.Editors.LongText.prototype.serializeValue = function() {};
/**
 * @record
 * @struct
 */
Slick.Formatter = function() {};

/* TODO: CallSignature: Slick */
/** @const */
Slick.Formatters = {};
 /** @type {!Slick.Formatter<!Slick.SlickData>} */
Slick.Formatters.PercentComplete;
 /** @type {!Slick.Formatter<!Slick.SlickData>} */
Slick.Formatters.PercentCompleteBar;
 /** @type {!Slick.Formatter<!Slick.SlickData>} */
Slick.Formatters.YesNo;
 /** @type {!Slick.Formatter<!Slick.SlickData>} */
Slick.Formatters.Checkmark;
/** @const */
Slick.Data = {};
/**
 * @record
 * @struct
 */
Slick.Data.DataViewOptions = function() {};
 /** @type {!Slick.Data.GroupItemMetadataProvider<T>} */
Slick.Data.DataViewOptions.prototype.groupItemMetadataProvider;
 /** @type {boolean} */
Slick.Data.DataViewOptions.prototype.inlineFilters;

/**
 * @constructor
 * @struct
 * @param {!Slick.Data.DataViewOptions<T>=} options
 */
Slick.Data.DataView = function(options) {};
 /** @type {!Slick.Event<!Slick.Data.OnRowCountChangedEventData>} */
Slick.Data.DataView.prototype.onRowCountChanged;
 /** @type {!Slick.Event<!Slick.Data.OnRowsChangedEventData>} */
Slick.Data.DataView.prototype.onRowsChanged;
 /** @type {!Slick.Event<!Slick.Data.OnPagingInfoChangedEventData>} */
Slick.Data.DataView.prototype.onPagingInfoChanged;

/**
 * @return {void}
 */
Slick.Data.DataView.prototype.beginUpdate = function() {};

/**
 * @return {void}
 */
Slick.Data.DataView.prototype.endUpdate = function() {};

/**
 * @param {!Slick.Data.PagingOptions} args
 * @return {void}
 */
Slick.Data.DataView.prototype.setPagingOptions = function(args) {};

/**
 * @return {!Slick.Data.PagingOptions}
 */
Slick.Data.DataView.prototype.getPagingInfo = function() {};

/**
 * @return {!Array<T>}
 */
Slick.Data.DataView.prototype.getItems = function() {};

/**
 * @param {!Array<T>} data
 * @param {string=} objectIdProperty
 * @return {void}
 */
Slick.Data.DataView.prototype.setItems = function(data, objectIdProperty) {};

/**
 * @param {function(T, ?): boolean} filterFn
 * @return {void}
 */
Slick.Data.DataView.prototype.setFilter = function(filterFn) {};

/**
 * @param {!Function} comparer
 * @param {boolean} ascending
 * @return {void}
 */
Slick.Data.DataView.prototype.sort = function(comparer, ascending) {};

/**
 * @param {string|!Function} field
 * @param {boolean} ascending
 * @return {void}
 */
Slick.Data.DataView.prototype.fastSort = function(field, ascending) {};

/**
 * @return {void}
 */
Slick.Data.DataView.prototype.reSort = function() {};

/**
 * @param {(!Slick.Data.GroupingOptions<T>|!Array<!Slick.Data.GroupingOptions<T>>)} groupingInfos
 * @return {void}
 */
Slick.Data.DataView.prototype.setGrouping = function(groupingInfos) {};

/**
 * @return {!Array<!Slick.Data.GroupingOptions<T>>}
 */
Slick.Data.DataView.prototype.getGrouping = function() {};

/**
 * @deprecated 
 * 
 * @param {?} valueGetter
 * @param {?} valueFormatter
 * @param {?} sortComparer
 * @return {void}
 */
Slick.Data.DataView.prototype.groupBy = function(valueGetter, valueFormatter, sortComparer) {};

/**
 * @deprecated 
 * 
 * @param {?} groupAggregators
 * @param {?} includeCollapsed
 * @return {void}
 */
Slick.Data.DataView.prototype.setAggregators = function(groupAggregators, includeCollapsed) {};

/**
 * @param {number=} level Optional level to collapse.  If not specified, applies to all levels.
 * 
 * @return {void}
 */
Slick.Data.DataView.prototype.collapseAllGroups = function(level) {};

/**
 * @param {number=} level Optional level to collapse.  If not specified, applies to all levels.
 * 
 * @return {void}
 */
Slick.Data.DataView.prototype.expandAllGroups = function(level) {};

/**
 * @param {...string} varArgs Either a Slick.Group's "groupingKey" property, or a
 *     variable argument list of grouping values denoting a unique path to the row.  For
 *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of
 *     the 'high' setGrouping.
 * @return {void}
 */
Slick.Data.DataView.prototype.collapseGroup = function(varArgs) {};

/**
 * @param {...string} varArgs Either a Slick.Group's "groupingKey" property, or a
 *     variable argument list of grouping values denoting a unique path to the row.  For
 *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of
 *     the 'high' setGrouping.
 * @return {void}
 */
Slick.Data.DataView.prototype.expandGroup = function(varArgs) {};

/**
 * @return {!Array<!Slick.Group<T>>}
 */
Slick.Data.DataView.prototype.getGroups = function() {};

/**
 * @param {string} id
 * @return {number}
 */
Slick.Data.DataView.prototype.getIdxById = function(id) {};

/**
 * @param {string} id
 * @return {number}
 */
Slick.Data.DataView.prototype.getRowById = function(id) {};

/**
 * @param {?} id
 * @return {T}
 */
Slick.Data.DataView.prototype.getItemById = function(id) {};

/**
 * @param {number} idx
 * @return {T}
 */
Slick.Data.DataView.prototype.getItemByIdx = function(idx) {};

/**
 * @param {!Array<T>} rowArray
 * @return {!Array<string>}
 */
Slick.Data.DataView.prototype.mapRowsToIds = function(rowArray) {};

/**
 * @param {!Slick.Data.RefreshHints} hints
 * @return {void}
 */
Slick.Data.DataView.prototype.setRefreshHints = function(hints) {};

/**
 * @param {?} args
 * @return {void}
 */
Slick.Data.DataView.prototype.setFilterArgs = function(args) {};

/**
 * @return {void}
 */
Slick.Data.DataView.prototype.refresh = function() {};

/**
 * @param {string} id
 * @param {T} item
 * @return {void}
 */
Slick.Data.DataView.prototype.updateItem = function(id, item) {};

/**
 * @param {number} insertBefore
 * @param {T} item
 * @return {void}
 */
Slick.Data.DataView.prototype.insertItem = function(insertBefore, item) {};

/**
 * @param {T} item
 * @return {void}
 */
Slick.Data.DataView.prototype.addItem = function(item) {};

/**
 * @param {string} id
 * @return {void}
 */
Slick.Data.DataView.prototype.deleteItem = function(id) {};

/**
 * @param {!Slick.Grid<T>} grid
 * @param {boolean} preserveHidden
 * @return {void}
 */
Slick.Data.DataView.prototype.syncGridSelection = function(grid, preserveHidden) {};

/**
 * @param {!Slick.Grid<T>} grid
 * @param {string} key
 * @return {void}
 */
Slick.Data.DataView.prototype.syncGridCellCssStyles = function(grid, key) {};

/**
 * @return {number}
 */
Slick.Data.DataView.prototype.getLength = function() {};

/**
 * @param {number} index
 * @return {T}
 */
Slick.Data.DataView.prototype.getItem = function(index) {};

/**
 * @param {number} index
 * @return {!Slick.RowMetadata<T>}
 */
Slick.Data.DataView.prototype.getItemMetadata = function(index) {};
/**
 * @record
 * @struct
 */
Slick.Data.GroupingOptions = function() {};
 /** @type {(string|function(T): ?)} */
Slick.Data.GroupingOptions.prototype.getter;
 /** @type {function(T): string} */
Slick.Data.GroupingOptions.prototype.formatter;
 /** @type {function(!Slick.Group<T>, !Slick.Group<T>): number} */
Slick.Data.GroupingOptions.prototype.comparer;
 /** @type {!Array<?>} */
Slick.Data.GroupingOptions.prototype.predefinedValues;
 /** @type {!Array<!Slick.Data.Aggregators.Aggregator<T>>} */
Slick.Data.GroupingOptions.prototype.aggregators;
 /** @type {boolean} */
Slick.Data.GroupingOptions.prototype.aggregateEmpty;
 /** @type {boolean} */
Slick.Data.GroupingOptions.prototype.aggregateCollapsed;
 /** @type {boolean} */
Slick.Data.GroupingOptions.prototype.aggregateChildGroups;
 /** @type {boolean} */
Slick.Data.GroupingOptions.prototype.collapsed;
 /** @type {boolean} */
Slick.Data.GroupingOptions.prototype.displayTotalsRow;
/**
 * @record
 * @struct
 */
Slick.Data.PagingOptions = function() {};
 /** @type {number} */
Slick.Data.PagingOptions.prototype.pageSize;
 /** @type {number} */
Slick.Data.PagingOptions.prototype.pageNum;
 /** @type {number} */
Slick.Data.PagingOptions.prototype.totalRows;
 /** @type {number} */
Slick.Data.PagingOptions.prototype.totalPages;
/**
 * @record
 * @struct
 */
Slick.Data.RefreshHints = function() {};
 /** @type {boolean} */
Slick.Data.RefreshHints.prototype.isFilterNarrowing;
 /** @type {boolean} */
Slick.Data.RefreshHints.prototype.isFilterExpanding;
 /** @type {boolean} */
Slick.Data.RefreshHints.prototype.isFilterUnchanged;
 /** @type {boolean} */
Slick.Data.RefreshHints.prototype.ignoreDiffsBefore;
 /** @type {boolean} */
Slick.Data.RefreshHints.prototype.ignoreDiffsAfter;
/**
 * @record
 * @struct
 */
Slick.Data.OnRowCountChangedEventData = function() {};
/**
 * @record
 * @struct
 */
Slick.Data.OnRowsChangedEventData = function() {};
 /** @type {!Array<number>} */
Slick.Data.OnRowsChangedEventData.prototype.rows;
/**
 * @extends {Slick.Data.PagingOptions}
 * @record
 * @struct
 */
Slick.Data.OnPagingInfoChangedEventData = function() {};
/** @const */
Slick.Data.Aggregators = {};
/**
 * @constructor
 * @struct
 */
Slick.Data.Aggregators.Aggregator = function() {};
 /** @type {string} */
Slick.Data.Aggregators.Aggregator.prototype.field;

/**
 * @return {void}
 */
Slick.Data.Aggregators.Aggregator.prototype.init = function() {};

/**
 * @param {T} item
 * @return {void}
 */
Slick.Data.Aggregators.Aggregator.prototype.accumulate = function(item) {};

/**
 * @param {!Slick.GroupTotals<T>} groupTotals
 * @return {void}
 */
Slick.Data.Aggregators.Aggregator.prototype.storeResult = function(groupTotals) {};
/**
 * @extends {Slick.Data.Aggregators.Aggregator}
 * @constructor
 * @struct
 */
Slick.Data.Aggregators.Avg = function() {};
/**
 * @extends {Slick.Data.Aggregators.Aggregator}
 * @constructor
 * @struct
 */
Slick.Data.Aggregators.Min = function() {};
/**
 * @extends {Slick.Data.Aggregators.Aggregator}
 * @constructor
 * @struct
 */
Slick.Data.Aggregators.Max = function() {};
/**
 * @extends {Slick.Data.Aggregators.Aggregator}
 * @constructor
 * @struct
 */
Slick.Data.Aggregators.Sum = function() {};
/**
 * @constructor
 * @struct
 */
Slick.Data.GroupItemMetadataProvider = function() {};

/**
 * @return {void}
 */
Slick.Data.GroupItemMetadataProvider.prototype.init = function() {};

/**
 * @return {void}
 */
Slick.Data.GroupItemMetadataProvider.prototype.destroy = function() {};

/**
 * @param {!Slick.Group<T>=} item
 * @return {!Slick.RowMetadata<T>}
 */
Slick.Data.GroupItemMetadataProvider.prototype.getGroupRowMetadata = function(item) {};

/**
 * @param {!Slick.GroupTotals<T>=} item
 * @return {!Slick.RowMetadata<T>}
 */
Slick.Data.GroupItemMetadataProvider.prototype.getTotalsRowMetadata = function(item) {};
/**
 * @record
 * @struct
 */
Slick.Data.GroupItemMetadataProviderOptions = function() {};
 /** @type {string} */
Slick.Data.GroupItemMetadataProviderOptions.prototype.groupCssClass;
 /** @type {string} */
Slick.Data.GroupItemMetadataProviderOptions.prototype.groupTitleCssClass;
 /** @type {string} */
Slick.Data.GroupItemMetadataProviderOptions.prototype.totalsCssClass;
 /** @type {boolean} */
Slick.Data.GroupItemMetadataProviderOptions.prototype.groupFocusable;
 /** @type {boolean} */
Slick.Data.GroupItemMetadataProviderOptions.prototype.totalsFocusable;
 /** @type {string} */
Slick.Data.GroupItemMetadataProviderOptions.prototype.toggleCssClass;
 /** @type {string} */
Slick.Data.GroupItemMetadataProviderOptions.prototype.toggleExpandedCssCass;
 /** @type {string} */
Slick.Data.GroupItemMetadataProviderOptions.prototype.toggleCollapsedCssClass;
 /** @type {boolean} */
Slick.Data.GroupItemMetadataProviderOptions.prototype.enableExpandCollapse;

/**
 * @constructor
 * @struct
 * @param {!Slick.PluginOptions=} options
 */
Slick.Plugin = function(options) {};

/**
 * @param {!Slick.Grid<T>} grid
 * @return {void}
 */
Slick.Plugin.prototype.init = function(grid) {};

/**
 * @return {void}
 */
Slick.Plugin.prototype.destroy = function() {};
/**
 * @record
 * @struct
 */
Slick.PluginOptions = function() {};
