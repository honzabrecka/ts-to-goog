/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/angularfire/index.d.ts:
/**
 * @record
 * @struct
 */
function AngularFireService() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function AngularFire() {}

/**
 * @return {!AngularFireArray}
 */
AngularFire.prototype.$asArray = function() {};

/**
 * @return {!AngularFireObject}
 */
AngularFire.prototype.$asObject = function() {};

/**
 * @return {?}
 */
AngularFire.prototype.$ref = function() {};

/**
 * @param {?} data
 * @return {!angular.IPromise<?>}
 */
AngularFire.prototype.$push = function(data) {};

/**
 * @param {string|?} key_or_data
 * @param {?=} data
 * @return {!angular.IPromise<?>}
 */
AngularFire.prototype.$set = function(key_or_data, data) {};

/**
 * @param {string=} key
 * @return {!angular.IPromise<?>}
 */
AngularFire.prototype.$remove = function(key) {};

/**
 * @param {string|?} key_or_data
 * @param {!Object=} data
 * @return {!angular.IPromise<?>}
 */
AngularFire.prototype.$update = function(key_or_data, data) {};

/**
 * @param {function(?): ?|string} updateFn_or_key
 * @param {boolean|function(?): ?=} applyLocally_or_updateFn
 * @param {boolean=} applyLocally
 * @return {!angular.IPromise<!FirebaseDataSnapshot>}
 */
AngularFire.prototype.$transaction = function(updateFn_or_key, applyLocally_or_updateFn, applyLocally) {};
/**
 * @extends {AngularFireSimpleObject}
 * @record
 * @struct
 */
function AngularFireObject() {}
 /** @type {string} */
AngularFireObject.prototype.$id;
 /** @type {number} */
AngularFireObject.prototype.$priority;
 /** @type {?} */
AngularFireObject.prototype.$value;

/**
 * Removes all keys from the FirebaseObject and also removes
 * the remote data from the server.
 * 
 * @return {!angular.IPromise<?>} a promise which will resolve after the op completes
 */
AngularFireObject.prototype.$remove = function() {};

/**
 * Saves all data on the FirebaseObject back to Firebase.
 * @return {!angular.IPromise<?>} a promise which will resolve after the save is completed.
 */
AngularFireObject.prototype.$save = function() {};

/**
 * The loaded method is invoked after the initial batch of data arrives from the server.
 * When this resolves, all data which existed prior to calling $asObject() is now cached
 * locally in the object.
 * 
 * As a shortcut is also possible to pass resolve/reject methods directly into this
 * method just as they would be passed to .then()
 * 
 * The loaded method is invoked after the initial batch of data arrives from the server.
 * When this resolves, all data which existed prior to calling $asObject() is now cached
 * locally in the object.
 * 
 * As a shortcut is also possible to pass resolve/reject methods directly into this
 * method just as they would be passed to .then()
 * 
 * The loaded method is invoked after the initial batch of data arrives from the server.
 * When this resolves, all data which existed prior to calling $asObject() is now cached
 * locally in the object.
 * 
 * As a shortcut is also possible to pass resolve/reject methods directly into this
 * method just as they would be passed to .then()
 * 
 * @param {function(!AngularFireObject): !angular.IHttpPromise<!Object>|function(!AngularFireObject): !angular.IPromise<!Object>|function(!AngularFireObject): void=} resolve
 * @param {function(?): ?=} reject
 * @return {!angular.IPromise<!AngularFireObject>} a promise which resolves after initial data is downloaded from Firebase
 */
AngularFireObject.prototype.$loaded = function(resolve, reject) {};

/**
 * @return {?}
 */
AngularFireObject.prototype.$ref = function() {};

/**
 * Creates a 3-way data sync between this object, the Firebase server, and a
 * scope variable. This means that any changes made to the scope variable are
 * pushed to Firebase, and vice versa.
 * 
 * If scope emits a $destroy event, the binding is automatically severed. Otherwise,
 * it is possible to unbind the scope variable by using the `unbind` function
 * passed into the resolve method.
 * 
 * Can only be bound to one scope variable at a time. If a second is attempted,
 * the promise will be rejected with an error.
 * 
 * @param {!angular.IScope} scope
 * @param {string} varName
 * @return {!angular.IPromise<?>} a promise which resolves to an unbind method after data is set in scope
 */
AngularFireObject.prototype.$bindTo = function(scope, varName) {};

/**
 * Listeners passed into this method are notified whenever a new change is received
 * from the server. Each invocation is sent an object containing
 * <code>{ type: 'value', key: 'my_firebase_id' }</code>
 * 
 * This method returns an unbind function that can be used to detach the listener.
 * 
 * @param {!Function} callback
 * @param {?=} context
 * @return {!Function}
 */
AngularFireObject.prototype.$watch = function(callback, context) {};

/**
 * Informs $firebase to stop sending events and clears memory being used
 * by this object (delete's its local content).
 * @return {void}
 */
AngularFireObject.prototype.$destroy = function() {};
/**
 * @record
 * @struct
 */
function AngularFireObjectService() {}

/* TODO: CallSignature:  */

/**
 * @param {!Object} ChildClass
 * @param {!Object=} methods
 * @return {!Object}
 */
AngularFireObjectService.prototype.$extend = function(ChildClass, methods) {};
/**
 * @record
 * @struct
 */
function AngularFireArray() {}

/**
 * Create a new record with a unique ID and add it to the end of the array.
 * This should be used instead of Array.prototype.push, since those changes will not be
 * synchronized with the server.
 * 
 * Any value, including a primitive, can be added in this way. Note that when the record
 * is created, the primitive value would be stored in $value (records are always objects
 * by default).
 * 
 * Returns a future which is resolved when the data has successfully saved to the server.
 * The resolve callback will be passed a Firebase ref representing the new data element.
 * 
 * @param {?} newData
 * @return {!angular.IPromise<?>} a promise resolved after data is added
 */
AngularFireArray.prototype.$add = function(newData) {};

/**
 * Pass either an item in the array or the index of an item and it will be saved back
 * to Firebase. While the array is read-only and its structure should not be changed,
 * it is okay to modify properties on the objects it contains and then save those back
 * individually.
 * 
 * Returns a future which is resolved when the data has successfully saved to the server.
 * The resolve callback will be passed a Firebase ref representing the saved element.
 * If passed an invalid index or an object which is not a record in this array,
 * the promise will be rejected.
 * 
 * @param {?} recordOrIndex
 * @return {!angular.IPromise<?>} a promise resolved after data is saved
 */
AngularFireArray.prototype.$save = function(recordOrIndex) {};

/**
 * Pass either an existing item in this array or the index of that item and it will
 * be removed both locally and in Firebase. This should be used in place of
 * Array.prototype.splice for removing items out of the array, as calling splice
 * will not update the value on the server.
 * 
 * Returns a future which is resolved when the data has successfully removed from the
 * server. The resolve callback will be passed a Firebase ref representing the deleted
 * element. If passed an invalid index or an object which is not a record in this array,
 * the promise will be rejected.
 * 
 * @param {?} recordOrIndex
 * @return {!angular.IPromise<?>} a promise which resolves after data is removed
 */
AngularFireArray.prototype.$remove = function(recordOrIndex) {};

/**
 * Returns the record for a given Firebase key (record.$id). If the record is not found
 * then returns null.
 * 
 * @param {string} key
 * @return {!AngularFireSimpleObject}
 */
AngularFireArray.prototype.$getRecord = function(key) {};

/**
 * Given an item in this array or the index of an item in the array, this returns the
 * Firebase key (record.$id) for that record. If passed an invalid key or an item which
 * does not exist in this array, it will return null.
 * 
 * @param {?} recordOrIndex
 * @return {string}
 */
AngularFireArray.prototype.$keyAt = function(recordOrIndex) {};

/**
 * The inverse of $keyAt, this method takes a Firebase key (record.$id) and returns the
 * index in the array where that record is stored. If the record is not in the array,
 * this method returns -1.
 * 
 * @param {string} key
 * @return {number}
 */
AngularFireArray.prototype.$indexFor = function(key) {};

/**
 * The loaded method is invoked after the initial batch of data arrives from the server.
 * When this resolves, all data which existed prior to calling $asArray() is now cached
 * locally in the array.
 * 
 * As a shortcut is also possible to pass resolve/reject methods directly into this
 * method just as they would be passed to .then()
 * 
 * The loaded method is invoked after the initial batch of data arrives from the server.
 * When this resolves, all data which existed prior to calling $asArray() is now cached
 * locally in the array.
 * 
 * As a shortcut is also possible to pass resolve/reject methods directly into this
 * method just as they would be passed to .then()
 * 
 * The loaded method is invoked after the initial batch of data arrives from the server.
 * When this resolves, all data which existed prior to calling $asArray() is now cached
 * locally in the array.
 * 
 * As a shortcut is also possible to pass resolve/reject methods directly into this
 * method just as they would be passed to .then()
 * 
 * @param {function(!AngularFireArray): !angular.IHttpPromise<!Object>|function(!AngularFireArray): !angular.IPromise<!Object>|function(!AngularFireArray): void=} resolve
 * @param {function(?): ?=} reject
 * @return {!angular.IPromise<!AngularFireArray>} a promise
 */
AngularFireArray.prototype.$loaded = function(resolve, reject) {};

/**
 * @return {?}
 */
AngularFireArray.prototype.$ref = function() {};

/**
 * Listeners passed into this method are notified whenever a new change (add, updated,
 * move, remove) is received from the server. Each invocation is sent an object
 * containing <code>{ type: 'child_added|child_updated|child_moved|child_removed',
 * key: 'key_of_item_affected'}</code>
 * 
 * Additionally, added and moved events receive a prevChild parameter, containing the
 * key of the item before this one in the array.
 * 
 * This method returns a function which can be invoked to stop observing events.
 * 
 * @param {function(string, string, string): void} cb
 * @param {?=} context
 * @return {!Function}
 */
AngularFireArray.prototype.$watch = function(cb, context) {};

/**
 * Informs $firebase to stop sending events and clears memory being used
 * by this array (delete's its local content).
 * @return {void}
 */
AngularFireArray.prototype.$destroy = function() {};
/**
 * @record
 * @struct
 */
function AngularFireArrayService() {}

/* TODO: CallSignature:  */

/**
 * @param {!Object} ChildClass
 * @param {!Object=} methods
 * @return {!Object}
 */
AngularFireArrayService.prototype.$extend = function(ChildClass, methods) {};
/**
 * @record
 * @struct
 */
function AngularFireSimpleObject() {}
 /** @type {string} */
AngularFireSimpleObject.prototype.$id;
 /** @type {number} */
AngularFireSimpleObject.prototype.$priority;
 /** @type {?} */
AngularFireSimpleObject.prototype.$value;

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function AngularFireAuthService() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function AngularFireAuth() {}

/**
 * Authenticates the Firebase reference with a custom authentication token.
 * 
 * should only be used for authenticating a server process and provides full read / write
 * access to the entire Firebase.
 * session persistence.
 * @param {string} authToken
 * @param {!Object=} options
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$authWithCustomToken = function(authToken, options) {};

/**
 * Authenticates the Firebase reference anonymously.
 * 
 * session persistence.
 * @param {!Object=} options
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$authAnonymously = function(options) {};

/**
 * Authenticates the Firebase reference with an email/password user.
 * 
 * to the user account.
 * session persistence.
 * @param {!FirebaseCredentials} credentials
 * @param {!Object=} options
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$authWithPassword = function(credentials, options) {};

/**
 * Authenticates the Firebase reference with the OAuth popup flow.
 * 
 * with, e.g. google.
 * session persistence.
 * @param {string} provider
 * @param {!Object=} options
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$authWithOAuthPopup = function(provider, options) {};

/**
 * Authenticates the Firebase reference with the OAuth redirect flow.
 * 
 * with, e.g. google.
 * session persistence.
 * @param {string} provider
 * @param {!Object=} options
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$authWithOAuthRedirect = function(provider, options) {};

/**
 * Authenticates the Firebase reference with an OAuth token.
 * 
 * with, e.g. google.
 * Object of key / value pairs, such as a set of OAuth 1.0a credentials.
 * session persistence.
 * @param {string} provider
 * @param {(string|!Object)} credentials
 * @param {!Object=} options
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$authWithOAuthToken = function(provider, credentials, options) {};

/**
 * Synchronously retrieves the current authentication data.
 * 
 * @return {!FirebaseAuthData}
 */
AngularFireAuth.prototype.$getAuth = function() {};

/**
 * Asynchronously fires the provided callback with the current authentication data every time
 * the authentication data changes. It also fires as soon as the authentication data is
 * retrieved from the server.
 * 
 * changes. If authenticated, the callback will be passed an object containing authentication
 * data according to the provider used to authenticate. Otherwise, it will be passed null.
 * callback.
 * @param {!Function} callback
 * @param {?=} context
 * @return {!Function}
 */
AngularFireAuth.prototype.$onAuth = function(callback, context) {};

/**
 * Unauthenticates the Firebase reference.
 * @return {void}
 */
AngularFireAuth.prototype.$unauth = function() {};

/**
 * Utility method which can be used in a route's resolve() method to grab the current
 * authentication data.
 * 
 * state, which will be null if the client is not authenticated.
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$waitForAuth = function() {};

/**
 * Utility method which can be used in a route's resolve() method to require that a route has
 * a logged in client.
 * 
 * state or rejected if the client is not authenticated.
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$requireAuth = function() {};

/**
 * Creates a new email/password user. Note that this function only creates the user, if you
 * wish to log in as the newly created user, call $authWithPassword() after the promise for
 * this method has been resolved.
 * 
 * uid of the created user.
 * @param {!FirebaseCredentials} credentials
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$createUser = function(credentials) {};

/**
 * Removes an email/password user.
 * 
 * @param {!FirebaseCredentials} credentials
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$removeUser = function(credentials) {};

/**
 * Changes the email for an email/password user.
 * 
 * the user whose email is to change.
 * @param {!FirebaseChangeEmailCredentials} credentials
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$changeEmail = function(credentials) {};

/**
 * Changes the password for an email/password user.
 * 
 * the user whose password is to change.
 * @param {!FirebaseChangePasswordCredentials} credentials
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$changePassword = function(credentials) {};

/**
 * Sends a password reset email to an email/password user.
 * 
 * password email to.
 * @param {!FirebaseResetPasswordCredentials} credentials
 * @return {!angular.IPromise<?>}
 */
AngularFireAuth.prototype.$resetPassword = function(credentials) {};
