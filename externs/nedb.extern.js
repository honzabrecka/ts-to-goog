/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/nedb/index.d.ts:

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */

/**
 * @constructor
 * @struct
 * @param {(string|!Nedb.DataStoreOptions)=} pathOrOptions
 */
function Nedb(pathOrOptions) {}
 /** @type {!Nedb.Persistence} */
Nedb.prototype.persistence;

/**
 * Load the database from the datafile, and trigger the execution of buffered commands if any
 * @param {function(!Error): void=} cb
 * @return {void}
 */
Nedb.prototype.loadDatabase = function(cb) {};

/**
 * Get an array of all the data in the database
 * @return {!Array<?>}
 */
Nedb.prototype.getAllData = function() {};

/**
 * Reset all currently defined indexes
 * @param {?} newData
 * @return {void}
 */
Nedb.prototype.resetIndexes = function(newData) {};

/**
 * Ensure an index is kept for this field. Same parameters as lib/indexes
 * For now this function is synchronous, we need to test how much time it takes
 * We use an async API for consistency with the rest of the code
 * @param {!Nedb.EnsureIndexOptions} options
 * @param {function(!Error): void=} cb
 * @return {void}
 */
Nedb.prototype.ensureIndex = function(options, cb) {};

/**
 * Remove an index
 * @param {string} fieldName
 * @param {function(!Error): void=} cb
 * @return {void}
 */
Nedb.prototype.removeIndex = function(fieldName, cb) {};

/**
 * Add one or several document(s) to all indexes
 * @template T
 * @param {(T|!Array<T>)} doc
 * @return {void}
 */
Nedb.prototype.addToIndexes = function(doc) {};

/**
 * Remove one or several document(s) from all indexes
 * @template T
 * @param {(T|!Array<T>)} doc
 * @return {void}
 */
Nedb.prototype.removeFromIndexes = function(doc) {};

/**
 * Update one or several documents in all indexes
 * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs
 * If one update violates a constraint, all changes are rolled back
 * @template T
 * @param {T|!Array<{oldDoc: T, newDoc: T}>} oldDoc_or_updates
 * @param {T=} newDoc
 * @return {void}
 */
Nedb.prototype.updateIndexes = function(oldDoc_or_updates, newDoc) {};

/**
 * Return the list of candidates for a given query
 * Crude implementation for now, we return the candidates given by the first usable index if any
 * We try the following query types, in this order: basic match, $in match, comparison match
 * One way to make it better would be to enable the use of multiple indexes if the first usable index
 * returns too much data. I may do it in the future.
 * 
 * TODO: needs to be moved to the Cursor module
 * @param {?} query
 * @return {void}
 */
Nedb.prototype.getCandidates = function(query) {};

/**
 * Insert a new document
 * @template T
 * @param {T} newDoc
 * @param {function(!Error, T): void=} cb
 * @return {void}
 */
Nedb.prototype.insert = function(newDoc, cb) {};

/**
 * Count all documents matching the query
 * @param {?} query
 * @param {function(!Error, number): void=} callback
 * @return {void|!Nedb.CursorCount}
 */
Nedb.prototype.count = function(query, callback) {};

/**
 * Find all documents matching the query
 * If no callback is passed, we return the cursor so that user can limit, skip and finally exec
 * Find all documents matching the query
 * If no callback is passed, we return the cursor so that user can limit, skip and finally exec
 * * \@param {any} query MongoDB-style query
 * @template T
 * @param {?} query
 * @param {T|function(!Error, !Array<T>): void=} projection_or_callback
 * @param {function(!Error, !Array<T>): void=} callback
 * @return {void|!Nedb.Cursor<T>}
 */
Nedb.prototype.find = function(query, projection_or_callback, callback) {};

/**
 * Find one document matching the query
 * Find one document matching the query
 * @template T
 * @param {?} query
 * @param {T|function(!Error, T): void} projection_or_callback
 * @param {function(!Error, T): void=} callback
 * @return {void}
 */
Nedb.prototype.findOne = function(query, projection_or_callback, callback) {};

/**
 * Update all docs matching query v1.7.4 and prior signature.
 * For now, very naive implementation (recalculating the whole database)
 *                 options.multi If true, can update multiple documents (defaults to false)
 *                 options.upsert If true, document is inserted if the query doesn't match anything
 *                                                    numReplaced,
 *                                                    upsert (set to true if the update was in fact an upsert)
 * 
 * \@api private Use Datastore.update which has the same signature
 * Update all docs matching query v1.8 signature.
 * For now, very naive implementation (recalculating the whole database)
 *                 options.multi If true, can update multiple documents (defaults to false)
 *                 options.upsert If true, document is inserted if the query doesn't match anything
 *                                                    numAffected,
 *                                                    affectedDocuments (when returnUpdatedDocs is set to true), obj or array
 *                                                    upsert (set to true if the update was in fact an upsert)
 * 
 * \@api private Use Datastore.update which has the same signature
 * @template T
 * @param {?} query
 * @param {?} updateQuery
 * @param {!Nedb.UpdateOptions=} options
 * @param {function(!Error, number, boolean): void|function(!Error, number, ?, boolean): void=} cb
 * @return {void}
 */
Nedb.prototype.update = function(query, updateQuery, options, cb) {};

/**
 * Remove all docs matching the query
 * For now very naive implementation (similar to update)
 *                 options.multi If true, can update multiple documents (defaults to false)
 * 
 * \@api private Use Datastore.remove which has the same signature
 * @param {?} query
 * @param {!Nedb.RemoveOptions|function(!Error, number): void=} options_or_cb
 * @param {function(!Error, number): void=} cb
 * @return {void}
 */
Nedb.prototype.remove = function(query, options_or_cb, cb) {};
/**
 * @record
 * @struct
 */
Nedb.Cursor = function() {};

/**
 * @param {?} query
 * @return {!Nedb.Cursor}
 */
Nedb.Cursor.prototype.sort = function(query) {};

/**
 * @param {number} n
 * @return {!Nedb.Cursor}
 */
Nedb.Cursor.prototype.skip = function(n) {};

/**
 * @param {number} n
 * @return {!Nedb.Cursor}
 */
Nedb.Cursor.prototype.limit = function(n) {};

/**
 * @param {?} query
 * @return {!Nedb.Cursor}
 */
Nedb.Cursor.prototype.projection = function(query) {};

/**
 * @param {function(!Error, !Array<T>): void} callback
 * @return {void}
 */
Nedb.Cursor.prototype.exec = function(callback) {};
/**
 * @record
 * @struct
 */
Nedb.CursorCount = function() {};

/**
 * @param {function(!Error, number): void} callback
 * @return {void}
 */
Nedb.CursorCount.prototype.exec = function(callback) {};
/**
 * @record
 * @struct
 */
Nedb.DataStoreOptions = function() {};
 /** @type {string} */
Nedb.DataStoreOptions.prototype.filename;
 /** @type {boolean} */
Nedb.DataStoreOptions.prototype.inMemoryOnly;
 /** @type {boolean} */
Nedb.DataStoreOptions.prototype.nodeWebkitAppName;
 /** @type {boolean} */
Nedb.DataStoreOptions.prototype.autoload;
 /** @type {number} */
Nedb.DataStoreOptions.prototype.corruptAlertThreshold;

/**
 * @param {!Error} error
 * @return {?}
 */
Nedb.DataStoreOptions.prototype.onload = function(error) {};

/**
 * @param {string} line
 * @return {string}
 */
Nedb.DataStoreOptions.prototype.afterSerialization = function(line) {};

/**
 * @param {string} line
 * @return {string}
 */
Nedb.DataStoreOptions.prototype.beforeDeserialization = function(line) {};
/**
 * @record
 * @struct
 */
Nedb.UpdateOptions = function() {};
 /** @type {boolean} */
Nedb.UpdateOptions.prototype.multi;
 /** @type {boolean} */
Nedb.UpdateOptions.prototype.upsert;
 /** @type {boolean} */
Nedb.UpdateOptions.prototype.returnUpdatedDocs;
/**
 * @record
 * @struct
 */
Nedb.RemoveOptions = function() {};
 /** @type {boolean} */
Nedb.RemoveOptions.prototype.multi;
/**
 * @record
 * @struct
 */
Nedb.EnsureIndexOptions = function() {};
 /** @type {string} */
Nedb.EnsureIndexOptions.prototype.fieldName;
 /** @type {boolean} */
Nedb.EnsureIndexOptions.prototype.unique;
 /** @type {boolean} */
Nedb.EnsureIndexOptions.prototype.sparse;
/**
 * @record
 * @struct
 */
Nedb.Persistence = function() {};

/**
 * @return {void}
 */
Nedb.Persistence.prototype.compactDatafile = function() {};

/**
 * @param {number} interval
 * @return {void}
 */
Nedb.Persistence.prototype.setAutocompactionInterval = function(interval) {};

/**
 * @return {void}
 */
Nedb.Persistence.prototype.stopAutocompaction = function() {};
