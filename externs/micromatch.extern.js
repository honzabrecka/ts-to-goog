/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/micromatch/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */
/** @const */
var micromatch = {};

/** @typedef {function(T): boolean} */
micromatch.MatchFunction;

/** @typedef {(string|!RegExp|function(string): boolean)} */
micromatch.Pattern;
/**
 * @record
 * @struct
 */
micromatch.Options = function() {};
 /** @type {boolean} */
micromatch.Options.prototype.unixify;
 /** @type {boolean} */
micromatch.Options.prototype.dot;
 /** @type {boolean} */
micromatch.Options.prototype.unescape;
 /** @type {boolean} */
micromatch.Options.prototype.nodupes;
 /** @type {boolean} */
micromatch.Options.prototype.matchBase;
 /** @type {boolean} */
micromatch.Options.prototype.nobraces;
 /** @type {boolean} */
micromatch.Options.prototype.nobrackets;
 /** @type {boolean} */
micromatch.Options.prototype.noextglob;
 /** @type {boolean} */
micromatch.Options.prototype.nocase;
 /** @type {boolean} */
micromatch.Options.prototype.nonull;
 /** @type {boolean} */
micromatch.Options.prototype.cache;
/**
 * @record
 * @struct
 */
micromatch.Glob = function() {};
 /** @type {!micromatch.Options} */
micromatch.Glob.prototype.options;
 /** @type {string} */
micromatch.Glob.prototype.pattern;
 /** @type {!Array<{msg: ?, pattern: string}>} */
micromatch.Glob.prototype.history;
 /** @type {!parseGlob.Result} */
micromatch.Glob.prototype.tokens;
 /** @type {string} */
micromatch.Glob.prototype.orig;
 /** @type {boolean} */
micromatch.Glob.prototype.negated;

/**
 * Initialize defaults.
 * @param {string} pattern
 * @return {void}
 */
micromatch.Glob.prototype.init = function(pattern) {};

/**
 * Push a change into `glob.history`. Useful for debugging.
 * @param {?} msg
 * @return {void}
 */
micromatch.Glob.prototype.track = function(msg) {};

/**
 * Return true if `glob.pattern` was negated with `!`, also remove the `!` from the pattern.
 * @return {boolean}
 */
micromatch.Glob.prototype.isNegated = function() {};

/**
 * Expand braces in the given glob pattern.
 * @return {void}
 */
micromatch.Glob.prototype.braces = function() {};

/**
 * Expand bracket expressions in `glob.pattern`.
 * @return {void}
 */
micromatch.Glob.prototype.brackets = function() {};

/**
 * Expand extended globs in `glob.pattern`.
 * @return {void}
 */
micromatch.Glob.prototype.extglob = function() {};

/**
 * Parse the given pattern.
 * @param {string} pattern
 * @return {!parseGlob.Result}
 */
micromatch.Glob.prototype.parse = function(pattern) {};

/**
 * Escape special characters in the given string.
 * @param {string} pattern
 * @return {string}
 */
micromatch.Glob.prototype.escape = function(pattern) {};

/**
 * Unescape special characters in the given string.
 * @param {string} pattern
 * @return {string}
 */
micromatch.Glob.prototype.unescape = function(pattern) {};
/**
 * @record
 * @struct
 */
micromatch.GlobData = function() {};
 /** @type {string} */
micromatch.GlobData.prototype.pattern;
 /** @type {!parseGlob.Result} */
micromatch.GlobData.prototype.tokens;
 /** @type {!micromatch.Options} */
micromatch.GlobData.prototype.options;
/**
 * @record
 * @struct
 */
function Micromatch() {}

/* TODO: CallSignature:  */
 /** @type {?} */
Micromatch.prototype.isMatch;

/**
 * Returns true if any part of a file path matches the given pattern. Think of this as "has path" versus
 * "is path".
 * @param {string} filePath
 * @param {(string|!RegExp|function(string): boolean)} pattern
 * @param {!micromatch.Options=} opts
 * @return {boolean}
 */
Micromatch.prototype.contains = function(filePath, pattern, opts) {};

/**
 * Returns a function for matching using the supplied pattern. e.g. create your own "matcher". The advantage of
 * this method is that the pattern can be compiled outside of a loop.
 * @param {(string|!RegExp|function(string): boolean)} pattern
 * @return {function(string): boolean}
 */
Micromatch.prototype.matcher = function(pattern) {};

/**
 * Returns a function that can be passed to Array#filter().
 * @param {(string|!RegExp|function(string): boolean|!Array<(string|!RegExp|?)>)} patterns
 * @param {!micromatch.Options=} opts
 * @return {function(?): boolean}
 */
Micromatch.prototype.filter = function(patterns, opts) {};

/**
 * Returns true if a file path matches any of the given patterns.
 * @param {string} filePath
 * @param {(string|!RegExp|function(string): boolean|!Array<(string|!RegExp|?)>)} patterns
 * @param {!micromatch.Options=} opts
 * @return {boolean}
 */
Micromatch.prototype.any = function(filePath, patterns, opts) {};

/**
 * Returns an object with a regex-compatible string and tokens.
 * @param {string} pattern
 * @param {!micromatch.Options=} opts
 * @return {(!micromatch.Glob|!micromatch.GlobData)}
 */
Micromatch.prototype.expand = function(pattern, opts) {};

/**
 * Create a regular expression for matching file paths based on the given pattern.
 * @param {string} pattern
 * @param {!micromatch.Options=} opts
 * @return {!RegExp}
 */
Micromatch.prototype.makeRe = function(pattern, opts) {};
 /** @type {?} */
var micromatch;

/* TODO: ExportAssignment in  */
