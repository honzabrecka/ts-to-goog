/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/prosemirror-model/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportDeclaration in  */
/**
 * @record
 * @struct
 */
function AnyObject() {}

/* TODO: IndexSignature:  */
/**
 * @constructor
 * @struct
 */
function ContentMatch() {}

/**
 * @param {?} node
 * @return {?}
 */
ContentMatch.prototype.matchNode = function(node) {};

/**
 * @param {?} type
 * @param {?=} attrs
 * @param {!Array<?>=} marks
 * @return {?}
 */
ContentMatch.prototype.matchType = function(type, attrs, marks) {};

/**
 * @param {?} fragment
 * @param {number=} from
 * @param {number=} to
 * @return {(boolean|?)}
 */
ContentMatch.prototype.matchFragment = function(fragment, from, to) {};

/**
 * @param {?} fragment
 * @param {number=} start
 * @param {number=} end
 * @return {boolean}
 */
ContentMatch.prototype.matchToEnd = function(fragment, start, end) {};

/**
 * @return {boolean}
 */
ContentMatch.prototype.validEnd = function() {};

/**
 * @param {?} after
 * @param {boolean} toEnd
 * @param {number=} startIndex
 * @return {?}
 */
ContentMatch.prototype.fillBefore = function(after, toEnd, startIndex) {};

/**
 * @param {?} markType
 * @return {boolean}
 */
ContentMatch.prototype.allowsMark = function(markType) {};

/**
 * @param {?} target
 * @param {?=} targetAttrs
 * @param {!Array<?>=} targetMarks
 * @return {!Array<?>}
 */
ContentMatch.prototype.findWrapping = function(target, targetAttrs, targetMarks) {};

/**
 * @param {?} node
 * @return {!Array<?>}
 */
ContentMatch.prototype.findWrappingFor = function(node) {};
/**
 * @constructor
 * @struct
 */
function Fragment() {}
 /** @type {?} */
Fragment.prototype.firstChild;
 /** @type {?} */
Fragment.prototype.lastChild;
 /** @type {number} */
Fragment.prototype.childCount;
 /** @type {?} */
Fragment.empty;

/**
 * @param {number} from
 * @param {number} to
 * @param {?} f
 * @return {void}
 */
Fragment.prototype.nodesBetween = function(from, to, f) {};

/**
 * @param {?} f
 * @return {void}
 */
Fragment.prototype.descendants = function(f) {};

/**
 * @param {?} other
 * @return {?}
 */
Fragment.prototype.append = function(other) {};

/**
 * @param {number} from
 * @param {number=} to
 * @return {?}
 */
Fragment.prototype.cut = function(from, to) {};

/**
 * @param {number} index
 * @param {?} node
 * @return {?}
 */
Fragment.prototype.replaceChild = function(index, node) {};

/**
 * @param {?} other
 * @return {boolean}
 */
Fragment.prototype.eq = function(other) {};

/**
 * @param {number} index
 * @return {?}
 */
Fragment.prototype.child = function(index) {};

/**
 * @param {number} index
 * @return {number}
 */
Fragment.prototype.offsetAt = function(index) {};

/**
 * @param {number} index
 * @return {?}
 */
Fragment.prototype.maybeChild = function(index) {};

/**
 * @param {?} f
 * @return {void}
 */
Fragment.prototype.forEach = function(f) {};

/**
 * @param {?} other
 * @return {number}
 */
Fragment.prototype.findDiffStart = function(other) {};

/**
 * @param {?} other
 * @return {?}
 */
Fragment.prototype.findDiffEnd = function(other) {};

/**
 * @return {string}
 */
Fragment.prototype.toString = function() {};

/**
 * @return {?}
 */
Fragment.prototype.toJSON = function() {};

/**
 * @param {?} schema
 * @param {?=} value
 * @return {?}
 */
Fragment.fromJSON = function(schema, value) {};

/**
 * @param {!Array<?>} array
 * @return {?}
 */
Fragment.fromArray = function(array) {};

/**
 * @param {(?|!Array<?>)=} nodes
 * @return {?}
 */
Fragment.from = function(nodes) {};
/**
 * @record
 * @struct
 */
function ParseRule() {}
 /** @type {string} */
ParseRule.prototype.tag;
 /** @type {string} */
ParseRule.prototype.namespace;
 /** @type {string} */
ParseRule.prototype.style;
 /** @type {string} */
ParseRule.prototype.context;
 /** @type {string} */
ParseRule.prototype.node;
 /** @type {string} */
ParseRule.prototype.mark;
 /** @type {number} */
ParseRule.prototype.priority;
 /** @type {boolean} */
ParseRule.prototype.ignore;
 /** @type {boolean} */
ParseRule.prototype.skip;
 /** @type {?} */
ParseRule.prototype.attrs;
 /** @type {?} */
ParseRule.prototype.getAttrs;
 /** @type {string} */
ParseRule.prototype.contentElement;
 /** @type {?} */
ParseRule.prototype.getContent;
 /** @type {(boolean|string)} */
ParseRule.prototype.preserveWhitespace;

/**
 * @constructor
 * @struct
 * @param {?} schema
 * @param {!Array<?>} rules
 */
function DOMParser(schema, rules) {}
 /** @type {?} */
DOMParser.prototype.schema;
 /** @type {!Array<?>} */
DOMParser.prototype.rules;

/**
 * @param {!Node} dom
 * @param {?=} options
 * @return {?}
 */
DOMParser.prototype.parse = function(dom, options) {};

/**
 * @param {!Node} dom
 * @param {?=} options
 * @return {?}
 */
DOMParser.prototype.parseSlice = function(dom, options) {};

/**
 * @param {?} schema
 * @return {!Array<?>}
 */
DOMParser.schemaRules = function(schema) {};

/**
 * @param {?} schema
 * @return {?}
 */
DOMParser.fromSchema = function(schema) {};
/**
 * @constructor
 * @struct
 */
function Mark() {}
 /** @type {?} */
Mark.prototype.type;
 /** @type {?} */
Mark.prototype.attrs;
 /** @type {!Array<?>} */
Mark.none;

/**
 * @param {!Array<?>} set
 * @return {!Array<?>}
 */
Mark.prototype.addToSet = function(set) {};

/**
 * @param {!Array<?>} set
 * @return {!Array<?>}
 */
Mark.prototype.removeFromSet = function(set) {};

/**
 * @param {!Array<?>} set
 * @return {boolean}
 */
Mark.prototype.isInSet = function(set) {};

/**
 * @param {?} other
 * @return {boolean}
 */
Mark.prototype.eq = function(other) {};

/**
 * @return {?}
 */
Mark.prototype.toJSON = function() {};

/**
 * @param {?} schema
 * @param {?} json
 * @return {?}
 */
Mark.fromJSON = function(schema, json) {};

/**
 * @param {!Array<?>} a
 * @param {!Array<?>} b
 * @return {boolean}
 */
Mark.sameSet = function(a, b) {};

/**
 * @param {(?|!Array<?>)=} marks
 * @return {!Array<?>}
 */
Mark.setFrom = function(marks) {};
/**
 * @constructor
 * @struct
 */
function Node() {}
 /** @type {?} */
Node.prototype.type;
 /** @type {?} */
Node.prototype.attrs;
 /** @type {?} */
Node.prototype.content;
 /** @type {!Array<?>} */
Node.prototype.marks;
 /** @type {string} */
Node.prototype.text;
 /** @type {number} */
Node.prototype.nodeSize;
 /** @type {number} */
Node.prototype.childCount;
 /** @type {string} */
Node.prototype.textContent;
 /** @type {?} */
Node.prototype.firstChild;
 /** @type {?} */
Node.prototype.lastChild;
 /** @type {boolean} */
Node.prototype.isBlock;
 /** @type {boolean} */
Node.prototype.isTextblock;
 /** @type {boolean} */
Node.prototype.inlineContent;
 /** @type {boolean} */
Node.prototype.isInline;
 /** @type {boolean} */
Node.prototype.isText;
 /** @type {boolean} */
Node.prototype.isLeaf;
 /** @type {boolean} */
Node.prototype.isAtom;

/**
 * @param {number} index
 * @return {?}
 */
Node.prototype.child = function(index) {};

/**
 * @param {number} index
 * @return {?}
 */
Node.prototype.maybeChild = function(index) {};

/**
 * @param {?} f
 * @return {void}
 */
Node.prototype.forEach = function(f) {};

/**
 * @param {number} from
 * @param {number} to
 * @param {?} f
 * @return {void}
 */
Node.prototype.nodesBetween = function(from, to, f) {};

/**
 * @param {?} f
 * @return {void}
 */
Node.prototype.descendants = function(f) {};

/**
 * @param {number} from
 * @param {number} to
 * @param {string=} blockSeparator
 * @param {string=} leafText
 * @return {string}
 */
Node.prototype.textBetween = function(from, to, blockSeparator, leafText) {};

/**
 * @param {?} other
 * @return {boolean}
 */
Node.prototype.eq = function(other) {};

/**
 * @param {?} other
 * @return {boolean}
 */
Node.prototype.sameMarkup = function(other) {};

/**
 * @param {?} type
 * @param {?=} attrs
 * @param {!Array<?>=} marks
 * @return {boolean}
 */
Node.prototype.hasMarkup = function(type, attrs, marks) {};

/**
 * @param {?=} content
 * @return {?}
 */
Node.prototype.copy = function(content) {};

/**
 * @param {!Array<?>} marks
 * @return {?}
 */
Node.prototype.mark = function(marks) {};

/**
 * @param {number} from
 * @param {number=} to
 * @return {?}
 */
Node.prototype.cut = function(from, to) {};

/**
 * @param {number} from
 * @param {number=} to
 * @return {?}
 */
Node.prototype.slice = function(from, to) {};

/**
 * @param {number} from
 * @param {number} to
 * @param {?} slice
 * @return {?}
 */
Node.prototype.replace = function(from, to, slice) {};

/**
 * @param {number} pos
 * @return {?}
 */
Node.prototype.nodeAt = function(pos) {};

/**
 * @param {number} pos
 * @return {?}
 */
Node.prototype.childAfter = function(pos) {};

/**
 * @param {number} pos
 * @return {?}
 */
Node.prototype.childBefore = function(pos) {};

/**
 * @param {number} pos
 * @return {?}
 */
Node.prototype.resolve = function(pos) {};

/**
 * @param {number} from
 * @param {number} to
 * @param {?} type
 * @return {boolean}
 */
Node.prototype.rangeHasMark = function(from, to, type) {};

/**
 * @return {string}
 */
Node.prototype.toString = function() {};

/**
 * @param {number} index
 * @return {?}
 */
Node.prototype.contentMatchAt = function(index) {};

/**
 * @param {number} from
 * @param {number} to
 * @param {?=} replacement
 * @param {number=} start
 * @param {number=} end
 * @return {boolean}
 */
Node.prototype.canReplace = function(from, to, replacement, start, end) {};

/**
 * @param {number} from
 * @param {number} to
 * @param {?} type
 * @param {!Array<?>=} attrs
 * @return {boolean}
 */
Node.prototype.canReplaceWith = function(from, to, type, attrs) {};

/**
 * @param {?} other
 * @return {boolean}
 */
Node.prototype.canAppend = function(other) {};

/**
 * @return {void}
 */
Node.prototype.check = function() {};

/**
 * @return {?}
 */
Node.prototype.toJSON = function() {};

/**
 * @param {?} schema
 * @param {?} json
 * @return {?}
 */
Node.fromJSON = function(schema, json) {};
/**
 * @constructor
 * @struct
 */
function ReplaceError() {}

/**
 * @constructor
 * @struct
 * @param {?} content
 * @param {number} openStart
 * @param {number} openEnd
 */
function Slice(content, openStart, openEnd) {}
 /** @type {?} */
Slice.prototype.content;
 /** @type {number} */
Slice.prototype.openStart;
 /** @type {number} */
Slice.prototype.openEnd;
 /** @type {number} */
Slice.prototype.size;
 /** @type {?} */
Slice.empty;

/**
 * @param {?} other
 * @return {boolean}
 */
Slice.prototype.eq = function(other) {};

/**
 * @return {?}
 */
Slice.prototype.toJSON = function() {};

/**
 * @param {?} schema
 * @param {?=} json
 * @return {?}
 */
Slice.fromJSON = function(schema, json) {};

/**
 * @param {?} fragment
 * @return {?}
 */
Slice.maxOpen = function(fragment) {};
/**
 * @constructor
 * @struct
 */
function ResolvedPos() {}
 /** @type {number} */
ResolvedPos.prototype.pos;
 /** @type {number} */
ResolvedPos.prototype.depth;
 /** @type {number} */
ResolvedPos.prototype.parentOffset;
 /** @type {?} */
ResolvedPos.prototype.parent;
 /** @type {?} */
ResolvedPos.prototype.doc;
 /** @type {number} */
ResolvedPos.prototype.textOffset;
 /** @type {?} */
ResolvedPos.prototype.nodeAfter;
 /** @type {?} */
ResolvedPos.prototype.nodeBefore;

/**
 * @param {number=} depth
 * @return {?}
 */
ResolvedPos.prototype.node = function(depth) {};

/**
 * @param {number=} depth
 * @return {number}
 */
ResolvedPos.prototype.index = function(depth) {};

/**
 * @param {number=} depth
 * @return {number}
 */
ResolvedPos.prototype.indexAfter = function(depth) {};

/**
 * @param {number=} depth
 * @return {number}
 */
ResolvedPos.prototype.start = function(depth) {};

/**
 * @param {number=} depth
 * @return {number}
 */
ResolvedPos.prototype.end = function(depth) {};

/**
 * @param {number=} depth
 * @return {number}
 */
ResolvedPos.prototype.before = function(depth) {};

/**
 * @param {number=} depth
 * @return {number}
 */
ResolvedPos.prototype.after = function(depth) {};

/**
 * @param {boolean=} after
 * @return {!Array<?>}
 */
ResolvedPos.prototype.marks = function(after) {};

/**
 * @param {number} pos
 * @return {number}
 */
ResolvedPos.prototype.sharedDepth = function(pos) {};

/**
 * @param {?=} other
 * @param {?=} pred
 * @return {?}
 */
ResolvedPos.prototype.blockRange = function(other, pred) {};

/**
 * @param {?} other
 * @return {boolean}
 */
ResolvedPos.prototype.sameParent = function(other) {};

/**
 * @param {?} other
 * @return {?}
 */
ResolvedPos.prototype.max = function(other) {};

/**
 * @param {?} other
 * @return {?}
 */
ResolvedPos.prototype.min = function(other) {};
/**
 * @constructor
 * @struct
 */
function NodeRange() {}
 /** @type {?} */
NodeRange.prototype.$from;
 /** @type {?} */
NodeRange.prototype.$to;
 /** @type {number} */
NodeRange.prototype.depth;
 /** @type {number} */
NodeRange.prototype.start;
 /** @type {number} */
NodeRange.prototype.end;
 /** @type {?} */
NodeRange.prototype.parent;
 /** @type {number} */
NodeRange.prototype.startIndex;
 /** @type {number} */
NodeRange.prototype.endIndex;
/**
 * @constructor
 * @struct
 */
function NodeType() {}
 /** @type {string} */
NodeType.prototype.name;
 /** @type {?} */
NodeType.prototype.schema;
 /** @type {?} */
NodeType.prototype.spec;
 /** @type {boolean} */
NodeType.prototype.isBlock;
 /** @type {boolean} */
NodeType.prototype.isText;
 /** @type {boolean} */
NodeType.prototype.isInline;
 /** @type {boolean} */
NodeType.prototype.isTextblock;
 /** @type {boolean} */
NodeType.prototype.inlineContent;
 /** @type {boolean} */
NodeType.prototype.isLeaf;
 /** @type {boolean} */
NodeType.prototype.isAtom;

/**
 * @param {?=} attrs
 * @param {(?|!Array<?>)=} content
 * @param {!Array<?>=} marks
 * @return {?}
 */
NodeType.prototype.create = function(attrs, content, marks) {};

/**
 * @param {?=} attrs
 * @param {(?|!Array<?>)=} content
 * @param {!Array<?>=} marks
 * @return {?}
 */
NodeType.prototype.createChecked = function(attrs, content, marks) {};

/**
 * @param {?=} attrs
 * @param {(?|!Array<?>)=} content
 * @param {!Array<?>=} marks
 * @return {?}
 */
NodeType.prototype.createAndFill = function(attrs, content, marks) {};

/**
 * @param {?} content
 * @param {?=} attrs
 * @return {boolean}
 */
NodeType.prototype.validContent = function(content, attrs) {};
/**
 * @constructor
 * @struct
 */
function MarkType() {}
 /** @type {string} */
MarkType.prototype.name;
 /** @type {?} */
MarkType.prototype.schema;
 /** @type {?} */
MarkType.prototype.spec;

/**
 * @param {?=} attrs
 * @return {?}
 */
MarkType.prototype.create = function(attrs) {};

/**
 * @param {!Array<?>} set
 * @return {!Array<?>}
 */
MarkType.prototype.removeFromSet = function(set) {};

/**
 * @param {!Array<?>} set
 * @return {?}
 */
MarkType.prototype.isInSet = function(set) {};

/**
 * @param {?} other
 * @return {boolean}
 */
MarkType.prototype.excludes = function(other) {};
/**
 * @record
 * @struct
 */
function SchemaSpec() {}
 /** @type {(?|!OrderedMap<?>)} */
SchemaSpec.prototype.nodes;
 /** @type {(?|!OrderedMap<?>)} */
SchemaSpec.prototype.marks;
 /** @type {string} */
SchemaSpec.prototype.topNode;
/**
 * @record
 * @struct
 */
function NodeSpec() {}
 /** @type {string} */
NodeSpec.prototype.content;
 /** @type {string} */
NodeSpec.prototype.group;
 /** @type {boolean} */
NodeSpec.prototype.inline;
 /** @type {boolean} */
NodeSpec.prototype.atom;
 /** @type {?} */
NodeSpec.prototype.attrs;
 /** @type {boolean} */
NodeSpec.prototype.selectable;
 /** @type {boolean} */
NodeSpec.prototype.draggable;
 /** @type {boolean} */
NodeSpec.prototype.code;
 /** @type {boolean} */
NodeSpec.prototype.defining;
 /** @type {boolean} */
NodeSpec.prototype.isolating;
 /** @type {?} */
NodeSpec.prototype.toDOM;
 /** @type {!Array<?>} */
NodeSpec.prototype.parseDOM;
/**
 * @record
 * @struct
 */
function MarkSpec() {}
 /** @type {?} */
MarkSpec.prototype.attrs;
 /** @type {boolean} */
MarkSpec.prototype.inclusive;
 /** @type {string} */
MarkSpec.prototype.excludes;
 /** @type {string} */
MarkSpec.prototype.group;
 /** @type {?} */
MarkSpec.prototype.toDOM;
 /** @type {!Array<?>} */
MarkSpec.prototype.parseDOM;
/**
 * @record
 * @struct
 */
function AttributeSpec() {}
 /** @type {?} */
AttributeSpec.prototype.default;
 /** @type {?} */
AttributeSpec.prototype.compute;

/**
 * @constructor
 * @struct
 * @param {?} spec
 */
function Schema(spec) {}
 /** @type {?} */
Schema.prototype.spec;
 /** @type {?} */
Schema.prototype.nodes;
 /** @type {?} */
Schema.prototype.marks;
 /** @type {?} */
Schema.prototype.cached;
 /** @type {?} */
Schema.prototype.topNodeType;

/**
 * @param {(string|?)} type
 * @param {?=} attrs
 * @param {(?|!Array<?>)=} content
 * @param {!Array<?>=} marks
 * @return {?}
 */
Schema.prototype.node = function(type, attrs, content, marks) {};

/**
 * @param {string} text
 * @param {!Array<?>=} marks
 * @return {?}
 */
Schema.prototype.text = function(text, marks) {};

/**
 * @param {(string|?)} type
 * @param {?=} attrs
 * @return {?}
 */
Schema.prototype.mark = function(type, attrs) {};

/**
 * @param {?} json
 * @return {?}
 */
Schema.prototype.nodeFromJSON = function(json) {};

/**
 * @param {?} json
 * @return {?}
 */
Schema.prototype.markFromJSON = function(json) {};
/**
 * @record
 * @struct
 */
function DOMOutputSpecArray() {}

/* TODO: PropertySignature: 0 */

/* TODO: PropertySignature: 1 */

/* TODO: PropertySignature: 2 */

/* TODO: PropertySignature: 3 */

/* TODO: PropertySignature: 4 */

/* TODO: PropertySignature: 5 */

/* TODO: PropertySignature: 6 */

/* TODO: PropertySignature: 7 */

/* TODO: PropertySignature: 8 */

/* TODO: PropertySignature: 9 */

/** @typedef {(string|!Node|?)} */
var DOMOutputSpec;

/**
 * @constructor
 * @struct
 * @param {?} nodes
 * @param {?} marks
 */
function DOMSerializer(nodes, marks) {}
 /** @type {?} */
DOMSerializer.prototype.nodes;
 /** @type {?} */
DOMSerializer.prototype.marks;

/**
 * @param {?} fragment
 * @param {?=} options
 * @return {!DocumentFragment}
 */
DOMSerializer.prototype.serializeFragment = function(fragment, options) {};

/**
 * @param {?} node
 * @param {?=} options
 * @return {?}
 */
DOMSerializer.prototype.serializeNode = function(node, options) {};

/**
 * @param {!Document} doc
 * @param {(string|!Node|?)} structure
 * @return {?}
 */
DOMSerializer.renderSpec = function(doc, structure) {};

/**
 * @param {?} schema
 * @return {?}
 */
DOMSerializer.fromSchema = function(schema) {};

/**
 * @param {?} schema
 * @return {?}
 */
DOMSerializer.nodesFromSchema = function(schema) {};

/**
 * @param {?} schema
 * @return {?}
 */
DOMSerializer.marksFromSchema = function(schema) {};
