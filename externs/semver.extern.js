/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/semver/index.d.ts:
 /** @type {string} */
var SEMVER_SPEC_VERSION;

/** @typedef {string} */
var ReleaseType;

/**
 * Return the parsed version, or null if it's not valid.
 * @param {string} v
 * @param {boolean=} loose
 * @return {string}
 */
function valid(v, loose) {}

/**
 * Returns cleaned (removed leading/trailing whitespace, remove '=v' prefix) and parsed version, or null if version is invalid.
 * @param {string} version
 * @param {boolean=} loose
 * @return {string}
 */
function clean(version, loose) {}

/**
 * Return the version incremented by the release type (major, minor, patch, or prerelease), or null if it's not valid.
 * @param {string} v
 * @param {string} release
 * @param {boolean=} loose
 * @param {string=} identifier
 * @return {string}
 */
function inc(v, release, loose, identifier) {}

/**
 * Return the major version number.
 * @param {string} v
 * @param {boolean=} loose
 * @return {number}
 */
function major(v, loose) {}

/**
 * Return the minor version number.
 * @param {string} v
 * @param {boolean=} loose
 * @return {number}
 */
function minor(v, loose) {}

/**
 * Return the patch version number.
 * @param {string} v
 * @param {boolean=} loose
 * @return {number}
 */
function patch(v, loose) {}

/**
 * Returns an array of prerelease components, or null if none exist.
 * @param {string} v
 * @param {boolean=} loose
 * @return {!Array<string>}
 */
function prerelease(v, loose) {}

/**
 * v1 > v2
 * @param {string} v1
 * @param {string} v2
 * @param {boolean=} loose
 * @return {boolean}
 */
function gt(v1, v2, loose) {}

/**
 * v1 >= v2
 * @param {string} v1
 * @param {string} v2
 * @param {boolean=} loose
 * @return {boolean}
 */
function gte(v1, v2, loose) {}

/**
 * v1 < v2
 * @param {string} v1
 * @param {string} v2
 * @param {boolean=} loose
 * @return {boolean}
 */
function lt(v1, v2, loose) {}

/**
 * v1 <= v2
 * @param {string} v1
 * @param {string} v2
 * @param {boolean=} loose
 * @return {boolean}
 */
function lte(v1, v2, loose) {}

/**
 * v1 == v2 This is true if they're logically equivalent, even if they're not the exact same string. You already know how to compare strings.
 * @param {string} v1
 * @param {string} v2
 * @param {boolean=} loose
 * @return {boolean}
 */
function eq(v1, v2, loose) {}

/**
 * v1 != v2 The opposite of eq.
 * @param {string} v1
 * @param {string} v2
 * @param {boolean=} loose
 * @return {boolean}
 */
function neq(v1, v2, loose) {}

/**
 * Pass in a comparison string, and it'll call the corresponding semver comparison function.
 * "===" and "!==" do simple string comparison, but are included for completeness.
 * Throws if an invalid comparison string is provided.
 * @param {string} v1
 * @param {?} comparator
 * @param {string} v2
 * @param {boolean=} loose
 * @return {boolean}
 */
function cmp(v1, comparator, v2, loose) {}

/**
 * Return 0 if v1 == v2, or 1 if v1 is greater, or -1 if v2 is greater. Sorts in ascending order if passed to Array.sort().
 * @param {string} v1
 * @param {string} v2
 * @param {boolean=} loose
 * @return {number}
 */
function compare(v1, v2, loose) {}

/**
 * The reverse of compare. Sorts an array of versions in descending order when passed to Array.sort().
 * @param {string} v1
 * @param {string} v2
 * @param {boolean=} loose
 * @return {number}
 */
function rcompare(v1, v2, loose) {}

/**
 * Returns difference between two versions by the release type (major, premajor, minor, preminor, patch, prepatch, or prerelease), or null if the versions are the same.
 * @param {string} v1
 * @param {string} v2
 * @param {boolean=} loose
 * @return {string}
 */
function diff(v1, v2, loose) {}

/**
 * Return the valid range or null if it's not valid
 * @param {string} range
 * @param {boolean=} loose
 * @return {string}
 */
function validRange(range, loose) {}

/**
 * Return true if the version satisfies the range.
 * @param {string} version
 * @param {string} range
 * @param {boolean=} loose
 * @return {boolean}
 */
function satisfies(version, range, loose) {}

/**
 * Return the highest version in the list that satisfies the range, or null if none of them do.
 * @param {!Array<string>} versions
 * @param {string} range
 * @param {boolean=} loose
 * @return {string}
 */
function maxSatisfying(versions, range, loose) {}

/**
 * Return the lowest version in the list that satisfies the range, or null if none of them do.
 * @param {!Array<string>} versions
 * @param {string} range
 * @param {boolean=} loose
 * @return {string}
 */
function minSatisfying(versions, range, loose) {}

/**
 * Return true if version is greater than all the versions possible in the range.
 * @param {string} version
 * @param {string} range
 * @param {boolean=} loose
 * @return {boolean}
 */
function gtr(version, range, loose) {}

/**
 * Return true if version is less than all the versions possible in the range.
 * @param {string} version
 * @param {string} range
 * @param {boolean=} loose
 * @return {boolean}
 */
function ltr(version, range, loose) {}

/**
 * Return true if the version is outside the bounds of the range in either the high or low direction.
 * The hilo argument must be either the string '>' or '<'. (This is the function called by gtr and ltr.)
 * @param {string} version
 * @param {string} range
 * @param {string} hilo
 * @param {boolean=} loose
 * @return {boolean}
 */
function outside(version, range, hilo, loose) {}

/**
 * @constructor
 * @struct
 * @param {string} version
 * @param {boolean=} loose
 */
function SemVer(version, loose) {}
 /** @type {string} */
SemVer.prototype.raw;
 /** @type {boolean} */
SemVer.prototype.loose;
 /** @type {number} */
SemVer.prototype.major;
 /** @type {number} */
SemVer.prototype.minor;
 /** @type {number} */
SemVer.prototype.patch;
 /** @type {string} */
SemVer.prototype.version;
 /** @type {!Array<string>} */
SemVer.prototype.build;
 /** @type {!Array<string>} */
SemVer.prototype.prerelease;

/**
 * @return {string}
 */
SemVer.prototype.format = function() {};

/**
 * @return {string}
 */
SemVer.prototype.inspect = function() {};

/**
 * @param {?} other
 * @return {number}
 */
SemVer.prototype.compare = function(other) {};

/**
 * @param {?} other
 * @return {number}
 */
SemVer.prototype.compareMain = function(other) {};

/**
 * @param {?} other
 * @return {number}
 */
SemVer.prototype.comparePre = function(other) {};

/**
 * @param {string} release
 * @param {string=} identifier
 * @return {?}
 */
SemVer.prototype.inc = function(release, identifier) {};

/**
 * @constructor
 * @struct
 * @param {string} comp
 * @param {boolean=} loose
 */
function Comparator(comp, loose) {}
 /** @type {?} */
Comparator.prototype.semver;
 /** @type {string} */
Comparator.prototype.operator;
 /** @type {boolean} */
Comparator.prototype.value;

/**
 * @param {string} comp
 * @return {void}
 */
Comparator.prototype.parse = function(comp) {};

/**
 * @param {?} version
 * @return {boolean}
 */
Comparator.prototype.test = function(version) {};

/**
 * @constructor
 * @struct
 * @param {string} range
 * @param {boolean=} loose
 */
function Range(range, loose) {}
 /** @type {string} */
Range.prototype.raw;
 /** @type {boolean} */
Range.prototype.loose;
 /** @type {!Array<!Array<?>>} */
Range.prototype.set;

/**
 * @return {string}
 */
Range.prototype.format = function() {};

/**
 * @return {string}
 */
Range.prototype.inspect = function() {};

/**
 * @param {string} range
 * @return {!Array<?>}
 */
Range.prototype.parseRange = function(range) {};

/**
 * @param {?} version
 * @return {boolean}
 */
Range.prototype.test = function(version) {};
