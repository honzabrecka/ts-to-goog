/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/flatbuffers/index.d.ts:

/* TODO: ExportDeclaration in  */
/** @const */
var flatbuffers = {};

/** @typedef {number} */
flatbuffers.Offset;
/**
 * @record
 * @struct
 */
flatbuffers.Table = function() {};
 /** @type {!flatbuffers.ByteBuffer} */
flatbuffers.Table.prototype.bb;
 /** @type {number} */
flatbuffers.Table.prototype.bb_pos;
 /** @type {number} */
flatbuffers.SIZEOF_SHORT;
 /** @type {number} */
flatbuffers.SIZEOF_INT;
 /** @type {number} */
flatbuffers.FILE_IDENTIFIER_LENGTH;

/** @const */
flatbuffers.Encoding = {};
/** @const {number} */
flatbuffers.Encoding.UTF8_BYTES;
/** @const {number} */
flatbuffers.Encoding.UTF16_STRING;
 /** @type {!Int32Array} */
flatbuffers.int32;
 /** @type {!Float32Array} */
flatbuffers.float32;
 /** @type {!Float64Array} */
flatbuffers.float64;
 /** @type {boolean} */
flatbuffers.isLittleEndian;

/**
 * @constructor
 * @struct
 * @param {number} low
 * @param {number} high
 */
flatbuffers.Long = function(low, high) {};
 /** @type {number} */
flatbuffers.Long.prototype.low;
 /** @type {number} */
flatbuffers.Long.prototype.high;
 /** @type {!flatbuffers.Long} */
flatbuffers.Long.ZERO;

/**
 * @return {number}
 */
flatbuffers.Long.prototype.toFloat64 = function() {};

/**
 * @param {?} other
 * @return {boolean}
 */
flatbuffers.Long.prototype.equals = function(other) {};

/**
 * @param {number} low
 * @param {number} high
 * @return {!flatbuffers.Long}
 */
flatbuffers.Long.create = function(low, high) {};

/**
 * @constructor
 * @struct
 * @param {number=} initial_size
 */
flatbuffers.Builder = function(initial_size) {};

/**
 * In order to save space, fields that are set to their default value
 * don't get serialized into the buffer. Forcing defaults provides a
 * way to manually disable this optimization.
 * 
 * @param {boolean} forceDefaults
 * @return {void}
 */
flatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {};

/**
 * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
 * called finish(). The actual data starts at the ByteBuffer's current position,
 * not necessarily at 0.
 * 
 * @return {!flatbuffers.ByteBuffer}
 */
flatbuffers.Builder.prototype.dataBuffer = function() {};

/**
 * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
 * called finish(). The actual data starts at the ByteBuffer's current position,
 * not necessarily at 0.
 * 
 * @return {!Uint8Array}
 */
flatbuffers.Builder.prototype.asUint8Array = function() {};

/**
 * Prepare to write an element of `size` after `additional_bytes` have been
 * written, e.g. if you write a string, you need to align such the int length
 * field is aligned to 4 bytes, and the string data follows it directly. If all
 * you need to do is alignment, `additional_bytes` will be 0.
 * 
 * @param {number} size
 * @param {number} additional_bytes
 * @return {void}
 */
flatbuffers.Builder.prototype.prep = function(size, additional_bytes) {};

/**
 * @param {number} byte_size
 * @return {void}
 */
flatbuffers.Builder.prototype.pad = function(byte_size) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.writeInt8 = function(value) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.writeInt16 = function(value) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.writeInt32 = function(value) {};

/**
 * @param {!flatbuffers.Long} value
 * @return {void}
 */
flatbuffers.Builder.prototype.writeInt64 = function(value) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.writeFloat32 = function(value) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.writeFloat64 = function(value) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.addInt8 = function(value) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.addInt16 = function(value) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.addInt32 = function(value) {};

/**
 * @param {!flatbuffers.Long} value
 * @return {void}
 */
flatbuffers.Builder.prototype.addInt64 = function(value) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.addFloat32 = function(value) {};

/**
 * @param {number} value
 * @return {void}
 */
flatbuffers.Builder.prototype.addFloat64 = function(value) {};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 * @return {void}
 */
flatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 * @return {void}
 */
flatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 * @return {void}
 */
flatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {};

/**
 * @param {number} voffset
 * @param {!flatbuffers.Long} value
 * @param {!flatbuffers.Long} defaultValue
 * @return {void}
 */
flatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 * @return {void}
 */
flatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 * @return {void}
 */
flatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 * @return {void}
 */
flatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {};

/**
 * Structs are stored inline, so nothing additional is being added. `d` is always 0.
 * 
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 * @return {void}
 */
flatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {};

/**
 * Structures are always stored inline, they need to be created right
 * where they're used.  You'll get this assertion failure if you
 * created it elsewhere.
 * 
 * @param {number} obj
 * @return {void}
 */
flatbuffers.Builder.prototype.nested = function(obj) {};

/**
 * Should not be creating any other object, string or vector
 * while an object is being constructed
 * @return {void}
 */
flatbuffers.Builder.prototype.notNested = function() {};

/**
 * Set the current vtable at `voffset` to the current location in the buffer.
 * 
 * @param {number} voffset
 * @return {void}
 */
flatbuffers.Builder.prototype.slot = function(voffset) {};

/**
 * @return {number}
 */
flatbuffers.Builder.prototype.offset = function() {};

/**
 * Doubles the size of the backing ByteBuffer and copies the old data towards
 * the end of the new buffer (since we build the buffer backwards).
 * 
 * to it. The data is located at the end of the buffer.
 * @param {!flatbuffers.ByteBuffer} bb
 * @return {!flatbuffers.ByteBuffer}
 */
flatbuffers.Builder.growByteBuffer = function(bb) {};

/**
 * Adds on offset, relative to where it will be written.
 * 
 * @param {number} offset
 * @return {void}
 */
flatbuffers.Builder.prototype.addOffset = function(offset) {};

/**
 * Start encoding a new object in the buffer.  Users will not usually need to
 * call this directly. The FlatBuffers compiler will generate helper methods
 * that call this method internally.
 * 
 * @param {number} numfields
 * @return {void}
 */
flatbuffers.Builder.prototype.startObject = function(numfields) {};

/**
 * Finish off writing the object that is under construction.
 * 
 * @return {number}
 */
flatbuffers.Builder.prototype.endObject = function() {};

/**
 * @param {number} root_table
 * @param {string=} file_identifier
 * @return {void}
 */
flatbuffers.Builder.prototype.finish = function(root_table, file_identifier) {};

/**
 * This checks a required field has been set in a given table that has
 * just been constructed.
 * 
 * @param {number} table
 * @param {number} field
 * @return {void}
 */
flatbuffers.Builder.prototype.requiredField = function(table, field) {};

/**
 * Start a new array/vector of objects.  Users usually will not call
 * this directly. The FlatBuffers compiler will create a start/end
 * method for vector types in generated code.
 * 
 * @param {number} elem_size
 * @param {number} num_elems
 * @param {number} alignment
 * @return {void}
 */
flatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {};

/**
 * Finish off the creation of an array and all its elements. The array must be
 * created with `startVector`.
 * 
 * starts.
 * @return {number}
 */
flatbuffers.Builder.prototype.endVector = function() {};

/**
 * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
 * instead of a string, it is assumed to contain valid UTF-8 encoded data.
 * 
 * @param {(string|!Uint8Array)} s
 * @return {number}
 */
flatbuffers.Builder.prototype.createString = function(s) {};

/**
 * Conveniance function for creating Long objects.
 * 
 * @param {number} low
 * @param {number} high
 * @return {!flatbuffers.Long}
 */
flatbuffers.Builder.prototype.createLong = function(low, high) {};

/**
 * @constructor
 * @struct
 * @param {!Uint8Array} bytes
 */
flatbuffers.ByteBuffer = function(bytes) {};

/**
 * @param {number} byte_size
 * @return {!flatbuffers.ByteBuffer}
 */
flatbuffers.ByteBuffer.allocate = function(byte_size) {};

/**
 * @return {!Uint8Array}
 */
flatbuffers.ByteBuffer.prototype.bytes = function() {};

/**
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.position = function() {};

/**
 * @param {number} position
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.setPosition = function(position) {};

/**
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.capacity = function() {};

/**
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {};

/**
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {};

/**
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {};

/**
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {};

/**
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {};

/**
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {};

/**
 * @param {number} offset
 * @return {!flatbuffers.Long}
 */
flatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {};

/**
 * @param {number} offset
 * @return {!flatbuffers.Long}
 */
flatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {};

/**
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {};

/**
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {};

/**
 * @param {number} offset
 * @param {number} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {};

/**
 * @param {number} offset
 * @param {number} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {};

/**
 * @param {number} offset
 * @param {number} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {};

/**
 * @param {number} offset
 * @param {number} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {};

/**
 * @param {number} offset
 * @param {number} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {};

/**
 * @param {number} offset
 * @param {number} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {};

/**
 * @param {number} offset
 * @param {!flatbuffers.Long} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {};

/**
 * @param {number} offset
 * @param {!flatbuffers.Long} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {};

/**
 * @param {number} offset
 * @param {number} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {};

/**
 * @param {number} offset
 * @param {number} value
 * @return {void}
 */
flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {};

/**
 * Look up a field in the vtable, return an offset into the object, or 0 if the
 * field is not present.
 * 
 * @param {number} bb_pos
 * @param {number} vtable_offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {};

/**
 * Initialize any Table-derived type to point to the union at the given offset.
 * 
 * @template T
 * @param {T} t
 * @param {number} offset
 * @return {T}
 */
flatbuffers.ByteBuffer.prototype.__union = function(t, offset) {};

/**
 * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
 * This allocates a new string and converts to wide chars upon each access.
 * 
 * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as
 * the "optionalEncoding" argument. This is useful for avoiding conversion to
 * and from UTF-16 when the data will just be packaged back up in another
 * FlatBuffer later on.
 * 
 * @param {number} offset
 * @param {flatbuffers.Encoding=} optionalEncoding
 * @return {(string|!Uint8Array)}
 */
flatbuffers.ByteBuffer.prototype.__string = function(offset, optionalEncoding) {};

/**
 * Retrieve the relative offset stored at "offset"
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.__indirect = function(offset) {};

/**
 * Get the start of data of a vector whose offset is stored at "offset" in this object.
 * 
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.__vector = function(offset) {};

/**
 * Get the length of a vector whose offset is stored at "offset" in this object.
 * 
 * @param {number} offset
 * @return {number}
 */
flatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {};

/**
 * @param {string} ident
 * @return {boolean}
 */
flatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {};

/**
 * Conveniance function for creating Long objects.
 * 
 * @param {number} low
 * @param {number} high
 * @return {!flatbuffers.Long}
 */
flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {};
