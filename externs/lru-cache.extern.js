/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/lru-cache/index.d.ts:

/**
 * @template T
 * @param {!LRU.Options<T>|number} opts_or_max
 * @return {!LRU.Cache<T>}
 */
function LRU(opts_or_max) {}
/**
 * @record
 * @struct
 */
LRU.Options = function() {};
 /** @type {number} */
LRU.Options.prototype.max;
 /** @type {number} */
LRU.Options.prototype.maxAge;
 /** @type {function(T): number} */
LRU.Options.prototype.length;
 /** @type {function(?, T): void} */
LRU.Options.prototype.dispose;
 /** @type {boolean} */
LRU.Options.prototype.stale;
/**
 * @record
 * @struct
 */
LRU.Cache = function() {};
 /** @type {number} */
LRU.Cache.prototype.itemCount;
 /** @type {number} */
LRU.Cache.prototype.length;

/**
 * Will update the "recently used"-ness of the key. They do what you think.
 * `maxAge` is optional and overrides the cache `maxAge` option if provided.
 * @param {?} key
 * @param {T} value
 * @param {number=} maxAge
 * @return {void}
 */
LRU.Cache.prototype.set = function(key, value, maxAge) {};

/**
 * Will update the "recently used"-ness of the key. They do what you think.
 * `maxAge` is optional and overrides the cache `maxAge` option if provided.
 * 
 * If the key is not found, will return `undefined`.
 * @param {?} key
 * @return {T}
 */
LRU.Cache.prototype.get = function(key) {};

/**
 * Returns the key value (or `undefined` if not found) without updating
 * the "recently used"-ness of the key.
 * 
 * (If you find yourself using this a lot, you might be using the wrong
 * sort of data structure, but there are some use cases where it's handy.)
 * @param {?} key
 * @return {T}
 */
LRU.Cache.prototype.peek = function(key) {};

/**
 * Check if a key is in the cache, without updating the recent-ness
 * or deleting it for being stale.
 * @param {?} key
 * @return {boolean}
 */
LRU.Cache.prototype.has = function(key) {};

/**
 * Deletes a key out of the cache.
 * @param {?} key
 * @return {void}
 */
LRU.Cache.prototype.del = function(key) {};

/**
 * Clear the cache entirely, throwing away all values.
 * @return {void}
 */
LRU.Cache.prototype.reset = function() {};

/**
 * Manually iterates over the entire cache proactively pruning old entries.
 * @return {void}
 */
LRU.Cache.prototype.prune = function() {};

/**
 * Just like `Array.prototype.forEach`. Iterates over all the keys in the cache,
 * in order of recent-ness. (Ie, more recently used items are iterated over first.)
 * @param {function(T, ?, !LRU.Cache): void} iter
 * @param {?=} thisp
 * @return {void}
 */
LRU.Cache.prototype.forEach = function(iter, thisp) {};

/**
 * The same as `cache.forEach(...)` but items are iterated over in reverse order.
 * (ie, less recently used items are iterated over first.)
 * @param {function(T, ?, !LRU.Cache): void} iter
 * @param {?=} thisp
 * @return {void}
 */
LRU.Cache.prototype.rforEach = function(iter, thisp) {};

/**
 * Return an array of the keys in the cache.
 * @return {!Array<?>}
 */
LRU.Cache.prototype.keys = function() {};

/**
 * Return an array of the values in the cache.
 * @return {!Array<T>}
 */
LRU.Cache.prototype.values = function() {};

/**
 * Return an array of the cache entries ready for serialization and usage with `destinationCache.load(arr)`.
 * @return {!Array<T>}
 */
LRU.Cache.prototype.dump = function() {};

/**
 * Loads another cache entries array, obtained with `sourceCache.dump()`,
 * into the cache. The destination cache is reset before loading new entries
 * 
 * @param {!Array<T>} cacheEntries Obtained from `sourceCache.dump()`
 * @return {void}
 */
LRU.Cache.prototype.load = function(cacheEntries) {};

/* TODO: ExportAssignment in  */
