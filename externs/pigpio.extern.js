/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/pigpio/index.d.ts:

/**
 * @constructor
 * @struct
 * Returns a new Gpio object for accessing a GPIO
 * @param {number} gpio      an unsigned integer specifying the GPIO number
 * @param {?=} options   object (optional)
 */
function Gpio(gpio, options) {}
 /** @type {number} */
Gpio.INPUT;
 /** @type {number} */
Gpio.OUTPUT;
 /** @type {number} */
Gpio.ALT0;
 /** @type {number} */
Gpio.ALT1;
 /** @type {number} */
Gpio.ALT2;
 /** @type {number} */
Gpio.ALT3;
 /** @type {number} */
Gpio.ALT4;
 /** @type {number} */
Gpio.ALT5;
 /** @type {number} */
Gpio.PUD_OFF;
 /** @type {number} */
Gpio.PUD_DOWN;
 /** @type {number} */
Gpio.PUD_UP;
 /** @type {number} */
Gpio.RISING_EDGE;
 /** @type {number} */
Gpio.FALLING_EDGE;
 /** @type {number} */
Gpio.EITHER_EDGE;
 /** @type {number} */
Gpio.TIMEOUT;
 /** @type {number} */
Gpio.MIN_GPIO;
 /** @type {number} */
Gpio.MAX_GPIO;
 /** @type {number} */
Gpio.MAX_USER_GPIO;

/**
 * Sets the GPIO mode.
 * @param {number} mode  INPUT, OUTPUT, ALT0, ALT1, ALT2, ALT3, ALT4, or ALT5
 * @return {?}
 */
Gpio.prototype.mode = function(mode) {};

/**
 * Sets or clears the resistor pull type for the GPIO.
 * @param {number} pud   PUD_OFF, PUD_DOWN, or PUD_UP
 * @return {?}
 */
Gpio.prototype.pullUpDown = function(pud) {};

/**
 * Returns the GPIO mode.
 * @return {number}
 */
Gpio.prototype.getMode = function() {};

/**
 * Returns the GPIO level, 0 or 1.
 * @return {number}
 */
Gpio.prototype.digitalRead = function() {};

/**
 * Sets the GPIO level to 0 or 1. If PWM or servo pulses are active on the GPIO they are switched off.
 * @param {number} levle     0 or 1
 * @return {?}
 */
Gpio.prototype.digitalWrite = function(levle) {};

/**
 * Sends a trigger pulse to the GPIO. The GPIO is set to level for pulseLen microseconds and then reset to not level.
 * @param {number} pulseLen  pulse length in microseconds (1 - 100)
 * @param {number} level     0 or 1
 * @return {?}
 */
Gpio.prototype.trigger = function(pulseLen, level) {};

/**
 * Starts PWM on the GPIO. Returns this.
 * @param {number} dutyCycle     an unsigned integer >= 0 (off) and <= range (fully on). range defaults to 255.
 * @return {?}
 */
Gpio.prototype.pwmWrite = function(dutyCycle) {};

/**
 * The same to #pwmWrite.
 * @param {number} dutyCycle     an unsigned integer >= 0 (off) and <= range (fully on). range defaults to 255.
 * @return {?}
 */
Gpio.prototype.analogWrite = function(dutyCycle) {};

/**
 * Starts hardware PWM on the GPIO at the specified frequency and dutyCycle. Frequencies above 30MHz are unlikely to work.
 * @param {number} frequency     an unsigned integer >= 0 and <= 125000000
 * @param {number} dutyCycle     an unsigned integer >= 0 (off) and <= 1000000 (fully on).
 * @return {?}
 */
Gpio.prototype.hardwarePwmWrite = function(frequency, dutyCycle) {};

/**
 * Returns the PWM duty cycle setting on the GPIO.
 * @return {number}
 */
Gpio.prototype.getPwmDutyCycle = function() {};

/**
 * Selects the duty cycle range to be used for the GPIO. Subsequent calls to pwmWrite will use a duty cycle between 0 (off) and range (fully on).
 * @param {number} range     an unsigned integer in the range 25 through 40000
 * @return {?}
 */
Gpio.prototype.pwmRange = function(range) {};

/**
 * Returns the duty cycle range used for the GPIO.
 * If hardware PWM is active on the GPIO the reported range will be 1000000.
 * @return {number}
 */
Gpio.prototype.getPwmRange = function() {};

/**
 * Returns the real range used for the GPIO.
 * If hardware PWM is active on the GPIO the reported real range will be approximately 250M divided by the set PWM frequency.
 * @return {number}
 */
Gpio.prototype.getPwmRealRange = function() {};

/**
 * Sets the frequency in hertz to be used for the GPIO. Returns this.
 * @param {number} frequency      an unsigned integer >= 0
 * @return {?}
 */
Gpio.prototype.pwmFrequency = function(frequency) {};

/**
 * Returns the frequency (in hertz) used for the GPIO. The default frequency is 800Hz.
 * @return {number}
 */
Gpio.prototype.getPwmFrequency = function() {};

/**
 * Starts servo pulses at 50Hz on the GPIO, 0 (off), 500 (most anti-clockwise) to 2500 (most clockwise)
 * @param {number} pulseWidth    pulse width in microseconds, an unsigned integer, 0 or a number in the range 500 through 2500
 * @return {?}
 */
Gpio.prototype.servoWrite = function(pulseWidth) {};

/**
 * Returns the servo pulse width setting on the GPIO.
 * @return {number}
 */
Gpio.prototype.getServoPulseWidth = function() {};

/**
 * Enables interrupts for the GPI
 * @param {number} edge      RISING_EDGE, FALLING_EDGE, or EITHER_EDGE
 * @param {number=} timeout   interrupt timeout in milliseconds (optional, defaults to 0 meaning no timeout)
 * @return {?}
 */
Gpio.prototype.enableInterrupt = function(edge, timeout) {};

/**
 * Disables interrupts for the GPIO. Returns this.
 * @return {?}
 */
Gpio.prototype.disableInterrupt = function() {};

/**
 * Enables alerts for the GPIO.
 * @return {?}
 */
Gpio.prototype.enableAlert = function() {};

/**
 * Disables aterts for the GPIO.
 * @return {?}
 */
Gpio.prototype.disableAlert = function() {};

/**
 * @constructor
 * @struct
 * Returns a new GpioBank object for accessing up to 32 GPIOs as one operation.
 * @param {number=} bank  BANK1 or BANK2 (optional, defaults to BANK1)
 */
function GpioBank(bank) {}
 /** @type {number} */
GpioBank.BANK1;
 /** @type {number} */
GpioBank.BACK2;

/**
 * Returns the current level of all GPIOs in the bank.
 * @return {number}
 */
GpioBank.prototype.read = function() {};

/**
 * For each GPIO in the bank, sets the GPIO level to 1 if the corresponding bit in bits is set.
 * @param {number} bits  a bit mask of the the GPIOs to set to 1
 * @return {?}
 */
GpioBank.prototype.set = function(bits) {};

/**
 * For each GPIO in the bank, sets the GPIO level to 0 if the corresponding bit in bits is set.
 * @param {number} bits   a bit mask of the the GPIOs to clear or set to 0
 * @return {?}
 */
GpioBank.prototype.clear = function(bits) {};

/**
 * Returns the bank identifier (BANK1 or BANK2.)
 * @return {number}
 */
GpioBank.prototype.bank = function() {};

/**
 * @constructor
 * @struct
 * Returns a new Notifier object that contains a stream which provides notifications about state changes on any of GPIOs 0 through 31 concurrently.
 * @param {?=} options   Used to configure which GPIOs notifications should be provided for.
 */
function Notifier(options) {}
 /** @type {number} */
Notifier.NOTIFICATION_LENGTH;
 /** @type {number} */
Notifier.PI_NTFY_FLAGS_ALIVE;

/**
 * Starts notifications for the GPIOs specified in the bit mask.
 * @param {number} bits  a bit mask indicating the GPIOs of interest, bit0 corresponds to GPIO0, bit1 corresponds to GPIO1, ..., bit31 corresponds to GPIO31.
 * If a bit is set, the corresponding GPIO will be monitored for state changes.
 * @return {?}
 */
Notifier.prototype.start = function(bits) {};

/**
 * Stops notifications. Notifications can be restarted with the start method.
 * @return {?}
 */
Notifier.prototype.stop = function() {};

/**
 * Stops notifications and releases resources.
 * @return {?}
 */
Notifier.prototype.close = function() {};

/**
 * Returns the notification stream which is a Readable stream.
 * @return {!NodeJS.ReadableStream}
 */
Notifier.prototype.stream = function() {};
 /** @type {number} */
var CLOCK_PWM;
 /** @type {number} */
var CLOCK_PCM;

/**
 * Initialize the pigpio package
 * @return {void}
 */
function initialize() {}

/**
 * Terminate the pigpio package
 * @return {void}
 */
function terminate() {}

/**
 * The configureClock function can be used to configure the sample rate and timing peripheral.
 * @param {number} microseconds  an unsigned integer specifying the sample rate in microseconds (1, 2, 4, 5, 8, or 10)
 * @param {number} peripheral    an unsigned integer specifying the peripheral for timing (CLOCK_PWM or CLOCK_PCM)
 * @return {void}
 */
function configureClock(microseconds, peripheral) {}
