/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/any-db/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */
/**
 * @record
 * @struct
 */
function ConnectOpts() {}
 /** @type {string} */
ConnectOpts.prototype.adapter;
/**
 * @record
 * @struct
 */
function Adapter() {}
 /** @type {string} */
Adapter.prototype.name;

/**
 * Create a new connection object. In common usage, config will be created by parse-db-url and passed to the adapter by any-db.
 * If a continuation is given, it must be called, either with an error or the established connection.
 * @param {?} opts
 * @param {?=} callback
 * @return {?}
 */
Adapter.prototype.createConnection = function(opts, callback) {};

/**
 * Create a Query that may eventually be executed later on by a Connection. While this function is rarely needed by user code,
 * it makes it possible for ConnectionPool.query and Transaction.query to fulfill the Queryable.query contract
 * by synchronously returning a Query stream
 * @param {string|?} text_or_query
 * @param {!Array<?>=} params
 * @param {?=} callback
 * @return {?}
 */
Adapter.prototype.createQuery = function(text_or_query, params, callback) {};
/**
 * @record
 * @struct
 */
function Field() {}
 /** @type {string} */
Field.prototype.name;
/**
 * @record
 * @struct
 */
function ResultSet() {}
 /** @type {number} */
ResultSet.prototype.rowCount;
 /** @type {!Array<?>} */
ResultSet.prototype.rows;
 /** @type {!Array<?>} */
ResultSet.prototype.fields;
 /** @type {number} */
ResultSet.prototype.fieldCount;
 /** @type {?} */
ResultSet.prototype.lastInsertId;
 /** @type {number} */
ResultSet.prototype.affectedRows;
 /** @type {number} */
ResultSet.prototype.changedRows;
/**
 * @record
 * @struct
 */
function Query() {}
 /** @type {string} */
Query.prototype.text;
 /** @type {!Array<?>} */
Query.prototype.values;
 /** @type {?} */
Query.prototype.callback;
/**
 * @record
 * @struct
 */
function Queryable() {}
 /** @type {?} */
Queryable.prototype.adapter;

/**
 * Execute a SQL statement using bound parameters (if they are provided) and return a Query object
 * that is a Readable stream of the resulting rows. If a Continuation<ResultSet> is provided the rows
 * returned by the database will be aggregated into a [ResultSet][] which will be passed to the
 * continuation after the query has completed.
 * The second form is not needed for normal use, but must be implemented by adapters to work correctly
 * with ConnectionPool and Transaction. See Adapter.createQuery for more details.
 * @param {string} text
 * @param {!Array<?>=} params
 * @param {?=} callback
 * @return {?}
 */
Queryable.prototype.query = function(text, params, callback) {};
/**
 * @extends {Queryable}
 * @record
 * @struct
 */
function Connection() {}

/**
 * Close the database connection. If a continuation is provided it
 * will be called after the connection has closed.
 * @param {?=} callback
 * @return {void}
 */
Connection.prototype.end = function(callback) {};
/**
 * @record
 * @struct
 */
function ConnectionStatic() {}

/* TODO: ConstructSignature:  */
 /** @type {string} */
ConnectionStatic.prototype.name;

/**
 * @return {void}
 */
ConnectionStatic.prototype.createConnection = function() {};

/**
 * @return {void}
 */
ConnectionStatic.prototype.createPool = function() {};
/**
 * @extends {Queryable}
 * @record
 * @struct
 */
function ConnectionPool() {}

/**
 * Implements Queryable.query by automatically acquiring a connection
 * and releasing it when the query completes.
 * @param {string} text
 * @param {!Array<?>=} params
 * @param {?=} callback
 * @return {?}
 */
ConnectionPool.prototype.query = function(text, params, callback) {};

/**
 * Remove a connection from the pool. If you use this method you must
 * return the connection back to the pool using ConnectionPool.release
 * @param {?} callback
 * @return {void}
 */
ConnectionPool.prototype.acquire = function(callback) {};

/**
 * Return a connection to the pool. This should only be called with connections
 * you've manually acquired. You must not continue to use the connection after releasing it.
 * @param {?} connection
 * @return {void}
 */
ConnectionPool.prototype.release = function(connection) {};

/**
 * Stop giving out new connections, and close all existing database connections as they
 * are returned to the pool.
 * @param {?=} callback
 * @return {void}
 */
ConnectionPool.prototype.close = function(callback) {};
/**
 * @record
 * @struct
 */
function PoolConfig() {}
 /** @type {number} */
PoolConfig.prototype.min;
 /** @type {number} */
PoolConfig.prototype.max;
 /** @type {number} */
PoolConfig.prototype.idleTimeout;
 /** @type {number} */
PoolConfig.prototype.reapInterval;
 /** @type {boolean} */
PoolConfig.prototype.refreshIdle;
 /** @type {?} */
PoolConfig.prototype.onConnect;
 /** @type {?} */
PoolConfig.prototype.reset;
 /** @type {?} */
PoolConfig.prototype.shouldDestroyConnection;

/**
 * Create a database connection.
 * Create a database connection.
 * @param {string|?} url_or_opts 	String of the form adapter://user:password\@host/database / 	Object with adapter name and any properties that the given adapter requires
 * @param {function(!Error, ?): void=} callback
 * @return {?} 	Connection object.
 */
function createConnection(url_or_opts, callback) {}

/**
 * @param {string|?} url_or_opts
 * @param {?} config
 * @return {?}
 */
function createPool(url_or_opts, config) {}
