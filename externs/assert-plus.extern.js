/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/assert-plus/index.d.ts:

/* TODO: ImportDeclaration in  */

/**
 * @param {!Array<?>} arr
 * @param {string=} message
 * @return {void}
 */
function array(arr, message) {}

/**
 * @param {boolean} bool
 * @param {string=} message
 * @return {void}
 */
function bool(bool, message) {}

/**
 * @param {?} buffer
 * @param {string=} message
 * @return {void}
 */
function buffer(buffer, message) {}

/**
 * @param {?} func
 * @param {string=} message
 * @return {void}
 */
function func(func, message) {}

/**
 * @param {number} number
 * @param {string=} message
 * @return {void}
 */
function number(number, message) {}

/**
 * @param {number} finite
 * @param {string=} message
 * @return {void}
 */
function finite(finite, message) {}

/**
 * @param {?} obj
 * @param {string=} message
 * @return {void}
 */
function object(obj, message) {}

/**
 * @param {string} str
 * @param {string=} message
 * @return {void}
 */
function string(str, message) {}

/**
 * @param {!internal.Stream} stream
 * @param {string=} message
 * @return {void}
 */
function stream(stream, message) {}

/**
 * @param {!Date} date
 * @param {string=} message
 * @return {void}
 */
function date(date, message) {}

/**
 * @param {!RegExp} regexp
 * @param {string=} message
 * @return {void}
 */
function regexp(regexp, message) {}

/**
 * @param {string} uuid
 * @param {string=} message
 * @return {void}
 */
function uuid(uuid, message) {}

/**
 * @param {!Array<!Array<?>>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfArray(arr, message) {}

/**
 * @param {!Array<boolean>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfBool(arr, message) {}

/**
 * @param {!Array<?>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfBuffer(arr, message) {}

/**
 * @param {!Array<?>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfFunc(arr, message) {}

/**
 * @param {!Array<number>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfNumber(arr, message) {}

/**
 * @param {!Array<number>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfFinite(arr, message) {}

/**
 * @param {!Array<?>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfObject(arr, message) {}

/**
 * @param {!Array<string>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfString(arr, message) {}

/**
 * @param {!Array<!internal.Stream>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfStream(arr, message) {}

/**
 * @param {!Array<!Date>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfDate(arr, message) {}

/**
 * @param {!Array<!RegExp>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfRegexp(arr, message) {}

/**
 * @param {!Array<string>} arr
 * @param {string=} message
 * @return {void}
 */
function arrayOfUuid(arr, message) {}

/**
 * @param {!Array<?>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArray(arr, message) {}

/**
 * @param {boolean} bool
 * @param {string=} message
 * @return {void}
 */
function optionalBool(bool, message) {}

/**
 * @param {?} buffer
 * @param {string=} message
 * @return {void}
 */
function optionalBuffer(buffer, message) {}

/**
 * @param {?} options
 * @param {string=} message
 * @return {void}
 */
function optionalFunc(options, message) {}

/**
 * @param {number} options
 * @param {string=} message
 * @return {void}
 */
function optionalNumber(options, message) {}

/**
 * @param {number} options
 * @param {string=} message
 * @return {void}
 */
function optionalFinite(options, message) {}

/**
 * @param {?} options
 * @param {string=} message
 * @return {void}
 */
function optionalObject(options, message) {}

/**
 * @param {string} options
 * @param {string=} message
 * @return {void}
 */
function optionalString(options, message) {}

/**
 * @param {!internal.Stream} options
 * @param {string=} message
 * @return {void}
 */
function optionalStream(options, message) {}

/**
 * @param {!Date} options
 * @param {string=} message
 * @return {void}
 */
function optionalDate(options, message) {}

/**
 * @param {!RegExp} options
 * @param {string=} message
 * @return {void}
 */
function optionalRegexp(options, message) {}

/**
 * @param {string} options
 * @param {string=} message
 * @return {void}
 */
function optionalUuid(options, message) {}

/**
 * @param {!Array<!Array<?>>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfArray(arr, message) {}

/**
 * @param {!Array<boolean>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfBool(arr, message) {}

/**
 * @param {!Array<?>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfBuffer(arr, message) {}

/**
 * @param {!Array<?>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfFunc(arr, message) {}

/**
 * @param {!Array<number>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfNumber(arr, message) {}

/**
 * @param {!Array<number>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfFinite(arr, message) {}

/**
 * @param {!Array<?>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfObject(arr, message) {}

/**
 * @param {!Array<string>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfString(arr, message) {}

/**
 * @param {!Array<!internal.Stream>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfStream(arr, message) {}

/**
 * @param {!Array<!Date>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfDate(arr, message) {}

/**
 * @param {!Array<!RegExp>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfRegexp(arr, message) {}

/**
 * @param {!Array<string>} arr
 * @param {string=} message
 * @return {void}
 */
function optionalArrayOfUuid(arr, message) {}

/**
 * @param {?} options
 * @param {string=} message
 * @return {void}
 */
function AssertionError(options, message) {}

/**
 * Throws an `AssertionError`. If `message` is falsy, the error message is set
 * as the values of `actual` and `expected` separated by the provided `operator`.
 * Otherwise, the error message is the value of `message`.
 * 
 * ```js
 * const assert = require('assert');
 * 
 * assert.fail(1, 2, undefined, '>');
 * // AssertionError: 1 > 2
 * 
 * assert.fail(1, 2, 'whoops', '>');
 * // AssertionError: whoops
 * ```
 * @param {?} actual
 * @param {?} expected
 * @param {?} message
 * @param {?} operator
 * @return {void}
 */
function fail(actual, expected, message, operator) {}

/**
 * Tests if `value` is truthy. It is equivalent to `assert.equal(!!value, true, message)`.
 * 
 * If `value` is not truthy, an `AssertionError` is thrown with a `message` property
 * set equal to the value of the `message` parameter.
 * If the `message` parameter is `undefined`, a default error message is assigned.
 * 
 * ```js
 * const assert = require('assert');
 * 
 * assert.ok(true);
 * // OK
 * assert.ok(1);
 * // OK
 * assert.ok(false);
 * // throws "AssertionError: false == true"
 * assert.ok(0);
 * // throws "AssertionError: 0 == true"
 * assert.ok(false, 'it\'s false');
 * // throws "AssertionError: it's false"
 * ```
 * @param {?} options
 * @param {string=} message
 * @return {void}
 */
function ok(options, message) {}

/**
 * Tests shallow, coercive equality between the actual and expected parameters
 * using the equal comparison operator ( `==` ).
 * 
 * ```js
 * const assert = require('assert');
 * 
 * assert.equal(1, 1);
 * // OK, 1 == 1
 * assert.equal(1, '1');
 * // OK, 1 == '1'
 * 
 * assert.equal(1, 2);
 * // AssertionError: 1 == 2
 * assert.equal({a: {b: 1}}, {a: {b: 1}});
 * //AssertionError: { a: { b: 1 } } == { a: { b: 1 } }
 * ```
 * 
 * If the values are not equal, an `AssertionError` is thrown with
 * a `message` property set equal to the value of the `message` parameter.
 * If the `message` parameter is undefined, a default error message is assigned.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {void}
 */
function equal(actual, expected, message) {}

/**
 * Tests shallow, coercive inequality with the not equal comparison operator ( `!=` ).
 * 
 * ```js
 * const assert = require('assert');
 * 
 * assert.notEqual(1, 2);
 * // OK
 * 
 * assert.notEqual(1, 1);
 * // AssertionError: 1 != 1
 * 
 * assert.notEqual(1, '1');
 * // AssertionError: 1 != '1'
 * ```
 * 
 * If the values are equal, an `AssertionError` is thrown with
 * a `message` property set equal to the value of the `message` parameter.
 * If the `message` parameter is undefined, a default error message is assigned.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {void}
 */
function notEqual(actual, expected, message) {}

/**
 * Tests for deep equality between the `actual` and `expected` parameters.
 * Primitive values are compared with the equal comparison operator ( `==` ).
 * 
 * Only enumerable "own" properties are considered.
 * The `deepEqual()` implementation does not test object prototypes, attached symbols,
 * or non-enumerable properties. This can lead to some potentially surprising results.
 * For example, the following example does not throw an `AssertionError` because
 * the properties on the Error object are non-enumerable:
 * 
 * ```js
 * // WARNING: This does not throw an AssertionError!
 * assert.deepEqual(Error('a'), Error('b'));
 * ```
 * 
 * "Deep" equality means that the enumerable "own" properties of child objects are evaluated also.
 * 
 * If the values are not equal, an `AssertionError` is thrown with a `message` property
 * set equal to the value of the `message` parameter. If the `message` parameter is undefined,
 * a default error message is assigned.
 * @template T
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {void}
 */
function deepEqual(actual, expected, message) {}

/**
 * Tests for any deep inequality. Opposite of `assert.deepEqual()`.
 * 
 * ```js
 * const assert = require('assert');
 * 
 * const obj1 = { a : { b : 1 } };
 * const obj2 = { a : { b : 2 } };
 * const obj3 = { a : { b : 1 } };
 * const obj4 = Object.create(obj1);
 * 
 * assert.notDeepEqual(obj1, obj1);
 * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }
 * 
 * assert.notDeepEqual(obj1, obj2);
 * // OK, obj1 and obj2 are not deeply equal
 * 
 * assert.notDeepEqual(obj1, obj3);
 * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }
 * 
 * assert.notDeepEqual(obj1, obj4);
 * // OK, obj1 and obj2 are not deeply equal
 * ```
 * 
 * If the values are deeply equal, an `AssertionError` is thrown with
 * a `message` property set equal to the value of the `message` parameter.
 * If the `message` parameter is undefined, a default error message is assigned.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {void}
 */
function notDeepEqual(actual, expected, message) {}

/**
 * Tests strict equality as determined by the strict equality operator ( `===` ).
 * 
 * ```js
 * const assert = require('assert');
 * 
 * assert.strictEqual(1, 2);
 * // AssertionError: 1 === 2
 * 
 * assert.strictEqual(1, 1);
 * // OK
 * 
 * assert.strictEqual(1, '1');
 * // AssertionError: 1 === '1'
 * ```
 * 
 * If the values are not strictly equal, an `AssertionError` is thrown with
 * a `message` property set equal to the value of the `message` parameter.
 * If the `message` parameter is undefined, a default error message is assigned.
 * @template T
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {void}
 */
function strictEqual(actual, expected, message) {}

/**
 * Tests strict inequality as determined by the strict not equal operator ( `!==` ).
 * 
 * ```js
 * const assert = require('assert');
 * 
 * assert.notStrictEqual(1, 2);
 * // OK
 * 
 * assert.notStrictEqual(1, 1);
 * // AssertionError: 1 !== 1
 * 
 * assert.notStrictEqual(1, '1');
 * // OK
 * ```
 * 
 * If the values are strictly equal, an `AssertionError` is thrown with a `message` property
 * set equal to the value of the `message` parameter. If the `message` parameter is undefined,
 * a default error message is assigned.
 * @param {?} actual
 * @param {?} expected
 * @param {string=} message
 * @return {void}
 */
function notStrictEqual(actual, expected, message) {}

/**
 * @param {?} block
 * @param {?=} error
 * @param {string=} message
 * @return {void}
 */
function throws(block, error, message) {}

/**
 * Asserts that the function `block` does not throw an error. See `assert.throws()` for more details.
 * 
 * When `assert.doesNotThrow()` is called, it will immediately call the `block` function.
 * 
 * If an error is thrown and it is the same type as that specified by the `error` parameter,
 * then an `AssertionError` is thrown. If the error is of a different type,
 * or if the `error` parameter is undefined, the error is propagated back to the caller.
 * 
 * The following, for instance, will throw the TypeError because there is no matching error type in the assertion:
 * ```js
 * assert.doesNotThrow(
 *   () => {
 *     throw new TypeError('Wrong value');
 *   },
 *   SyntaxError
 * );
 * ```
 * 
 * However, the following will result in an `AssertionError` with the message 'Got unwanted exception (TypeError)..':
 * ```js
 * assert.doesNotThrow(
 *   () => {
 *     throw new TypeError('Wrong value');
 *   },
 *   TypeError
 * );
 * ```
 * 
 * If an `AssertionError` is thrown and a value is provided for the `message` parameter,
 * the value of `message` will be appended to the `AssertionError` message:
 * ```js
 * assert.doesNotThrow(
 *   () => {
 *     throw new TypeError('Wrong value');
 *   },
 *   TypeError,
 *   'Whoops'
 * );
 * // Throws: AssertionError: Got unwanted exception (TypeError). Whoops
 * ```
 * @param {?} block
 * @param {?=} error
 * @param {string=} message
 * @return {void}
 */
function doesNotThrow(block, error, message) {}

/**
 * Throws `value` if `value` is truthy. This is useful when testing the `error` argument in callbacks.
 * ```js
 * const assert = require('assert');
 * 
 * assert.ifError(0);
 * // OK
 * assert.ifError(1);
 * // Throws 1
 * assert.ifError('error');
 * // Throws 'error'
 * assert.ifError(new Error());
 * // Throws Error
 * ```
 * @param {?} value
 * @return {void}
 */
function ifError(value) {}

/* TODO: NamespaceExportDeclaration in  */
