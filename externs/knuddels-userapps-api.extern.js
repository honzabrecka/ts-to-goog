/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/knuddels-userapps-api/index.d.ts:
/**
 * @record
 * @struct
 */
function Json() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function JsonArray() {}

/** @typedef {(string|number|boolean|!User|!BotUser)} */
var KnuddelsSerializable;
/**
 * @record
 * @struct
 */
function KnuddelsJson() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function KnuddelsJsonArray() {}

/** @typedef {(string|!Json|!KnuddelsEventArray)} */
var KnuddelsEvent;
/**
 * @record
 * @struct
 */
function KnuddelsEventArray() {}
/**
 * @record
 * @struct
 */
function App() {}
 /** @type {!Object<string,function(!User, string, string): void>} */
App.prototype.chatCommands;

/**
 * Dieses Methode wird aufgerufen, sobald ein Nutzer versucht den Channel zu betreten.
 * Die App kann nun entscheiden, ob der Nutzer den Channel betreten darf.
 * 
 * <b style="color:red;">Hinweis:</b> Um ein responsives User Interface für den Nutzer,
 * der den Channel betreten möchte zu garantieren, muss die App innerhalb von einer Sekunde auf diese Anfrage reagieren,
 * damit ihre Antwort in das Ergebnis einfliesst.
 * 
 * Mit bestimmten Smileyfeatures ist es derzeit trotzdem möglich, den Channel zu betreten.
 * Diese Nutzer können nicht ausgesperrt werden:
 * <ul>
 * <li>Channelbesitzer</li>
 * <li>Channelmoderatoren und HZAs</li>
 * <li>Admins (sofern notwendig)</li>
 * <li>Sysadmins</li>
 * <li>User Apps Team (Mitarbeiter von Knuddels)</li>
 * </ul>
 * 
 * Ist der Channel mit einem Passwort geschützt und der Nutzer, der versucht den Channel zu betreten kennt das Passwort,
 * so kann er nicht aus dem Channel ausgeschlossen werden.
 * @param {!User} user
 * @return {!ChannelJoinPermission}
 */
App.prototype.mayJoinChannel = function(user) {};

/**
 * Diese Methode wird jedes Mal aufgerufen, sobald ein Nutzer versucht eine öffentliche Nachricht zu senden.
 * Die App kann nun entscheiden, ob die Nachricht veröffentlicht werden darf.
 * 
 * Laufen mehrere Apps im selben Channel, so wird die Nachricht veröffentlicht, sofern alle Apps es erlauben.
 * 
 * Dauert das Fragen aller Apps nach Erlaubnis länger als 10 Sekunden, so wird die Antwort genutzt, die bis dahin
 * gegeben wurde.
 * @param {!PublicMessage} publicMessage
 * @return {boolean}
 */
App.prototype.mayShowPublicMessage = function(publicMessage) {};

/**
 * Diese Methode wird jedes Mal aufgerufen, sobald ein Nutzer versucht eine öffentliche Handlung auszuführen.
 * Die App kann nun entscheiden, ob die Handlung ausgeführt werden darf.
 * 
 * Laufen mehrere Apps im selben Channel, so wird die Handlung ausgeführt, sofern alle Apps es erlauben.
 * 
 * Dauert das Fragen aller Apps nach Erlaubnis länger als 10 Sekunden, so wird die Antwort genutzt, die bis dahin
 * gegeben wurde.
 * @param {!PublicActionMessage} publicActionMessage
 * @return {boolean}
 */
App.prototype.mayShowPublicActionMessage = function(publicActionMessage) {};

/**
 * Diese Methode wird aufgerufen, sobald die App startet.
 * Dies ist der beste Zeipunkt um Werte zu initialisieren und aus der Persistenz zu lesen.
 * @return {void}
 */
App.prototype.onAppStart = function() {};

/**
 * Diese Methode wird aufgerufen, wenn ein User Knuddel an den BotUser gesendet hat.
 * Es ist die Aufgabe der App in dieser Methode zu entscheiden, ob sie die Knuddel annimmt oder ablehnt.
 * Wird diese Methode von der App nicht implementiert, so werden Knuddel automatisch akzeptiert.
 * Ist diese Methode implementiert und es treten Fehler (Exceptions, Timeout,...) auf oder der Entwickler entscheidet nicht,
 * was mit den Knuddel geschehen soll, so werden diese vom App-System automatisch an den Absender zurück geschickt.
 * <br />
 * <b style="color:red;">Wichtig:</b> Zum Zeitpunkt des Aufrufs dieser Methode wurden die Knuddel noch nicht an den BotUser übertragen.
 * @param {!KnuddelTransfer} knuddelTransfer
 * @return {void}
 */
App.prototype.onBeforeKnuddelReceived = function(knuddelTransfer) {};

/**
 * Diese Methode wird aufgerufen, sobald ein BotUser Knuddel von einem User erhalten hat.
 * @param {!User} sender
 * @param {!BotUser} receiver
 * @param {!KnuddelAmount} knuddelAmount
 * @param {string} transferReason
 * @return {void}
 */
App.prototype.onKnuddelReceived = function(sender, receiver, knuddelAmount, transferReason) {};

/**
 * Diese Methode wird aufgerufen, wenn die App sich darauf vorbereiten soll heruntergefahren zu werden.
 * Als Parameter wird die geschätzte Zeit übergeben, die die App noch hat, bis sie heruntergefahren wird
 * und der Aufruf App/onShutdown:event folgt.
 * 
 * App/onPrepareShutdown:event kann dazu benutzt werden das Nutzererlebnis zu verbessern,
 * sofern eine App heruntergefahren werden muss (bsp. für Updates).
 * Eine Spiele-App könnte z.B. entscheiden, dass sie keine weiteren Spiele eröffnet und den Spielern offener Spiele
 * die Information anzeigt, wie lange das Spiel noch läuft, bevor es unentschieden endet.
 * 
 * <br><br><b style="color:red;">Achtung:</b> Die Methode kann im Lebenszyklus einer App mehrfach aufgerufen werden.
 * @param {number} secondsTillShutdown
 * @return {void}
 */
App.prototype.onPrepareShutdown = function(secondsTillShutdown) {};

/**
 * Diese Methode wird aufgerufen, wenn ein BotUser privat angeschrieben wird.
 * @param {!PrivateMessage} privateMessage
 * @return {void}
 */
App.prototype.onPrivateMessage = function(privateMessage) {};

/**
 * Diese Methode wird aufgerufen, wenn im Channel der App
 * eine öffentliche Nachricht geschrieben wird.
 * Für Nachrichten von BotUsern wird diese Methode nicht aufgerufen.
 * @param {!PublicMessage} publicMessage
 * @return {void}
 */
App.prototype.onPublicMessage = function(publicMessage) {};

/**
 * Diese Methode wird aufgerufen, wenn im Channel der App
 * eine Event-Nachricht veröffentlicht wird.
 * Für Nachrichten von BotUsern wird diese Methode nicht aufgerufen.
 * @param {!PublicEventMessage} publicEventMessage
 * @return {void}
 */
App.prototype.onPublicEventMessage = function(publicEventMessage) {};

/**
 * Diese Methode wird aufgerufen, wenn im Channel der App
 * eine öffentliche Handlung durchgeführt wird.
 * Für Handlungen von BotUsern wird diese Methode nicht aufgerufen.
 * @param {!PublicActionMessage} publicActionMessage
 * @return {void}
 */
App.prototype.onPublicActionMessage = function(publicActionMessage) {};

/**
 * Diese Methode wird aufgerufen, wenn eine App beendet wird.
 * Sobald diese Methode aufgerufen wird, steht nur noch ein begrenzter Teil der API zur Verfügung.
 * Die App sollte den kompletten Zustand in der Persistenz speichern, sodass der Zustand
 * beim nächsten App/onAppStart:event wiederhergestellt werden kann.
 * 
 * Während des Shutdowns können asynchrone each-Methoden, wie UserPersistenceNumbers/each:method
 * und UserAccess/eachAccessibleUser:method nicht zuverlässig genutzt werden.
 * @return {void}
 */
App.prototype.onShutdown = function() {};

/**
 * Diese Methode wird aufgerufen, wenn ein User im Channel der App
 * über die Systemfunktionen (/dice, /diceo) würfelt.
 * Die App kann auf das Ergebnis zugreifen und die Daten für die Auswertung und Entscheidungen nutzen.
 * @param {!DiceEvent} diceEvent
 * @return {void}
 */
App.prototype.onUserDiced = function(diceEvent) {};

/**
 * Diese Methode wird aufgerufen, wenn ein User den Channel der App betritt.
 * @param {!User} user
 * @return {void}
 */
App.prototype.onUserJoined = function(user) {};

/**
 * Diese Methode wird aufgerufen, wenn ein User den Channel der App verlässt.
 * @param {!User} user
 * @return {void}
 */
App.prototype.onUserLeft = function(user) {};

/**
 * Diese Methode wird aufgerufen, wenn aus einer anderen App ein Event mit sendAppEvent versendet wurde.
 * @param {!AppInstance} appInstance
 * @param {string} type
 * @param {(string|!Json|!KnuddelsEventArray)} data
 * @return {void}
 */
App.prototype.onAppEventReceived = function(appInstance, type, data) {};

/**
 * Diese Methode wird aufgerufen, wenn aus dem HTML User Interface ein Event mit
 * sendEvent() gesendet wurde.
 * @param {!User} user
 * @param {string} type
 * @param {(string|!Json|!KnuddelsEventArray)} data
 * @param {!AppContentSession} appContentSession
 * @return {void}
 */
App.prototype.onEventReceived = function(user, type, data, appContentSession) {};

/**
 * Diese Methode wird aufgerufen, wenn ein User Knuddel in seinen KnuddelAccount
 * eingezahlt hat.
 * @param {!User} sender
 * @param {!BotUser} receiver
 * @param {!KnuddelAmount} knuddelAmount
 * @param {string} transferReason
 * @param {!KnuddelAccount} knuddelAccount
 * @return {void}
 */
App.prototype.onAccountReceivedKnuddel = function(sender, receiver, knuddelAmount, transferReason, knuddelAccount) {};

/**
 * Diese Methode wird aufgerufen, wenn sich die Anzahl der Knuddel auf einem KnuddelAccount eines User
 * geändert hat.
 * @param {!User} user
 * @param {!KnuddelAccount} knuddelAccount
 * @param {!KnuddelAmount} oldKnuddelAmount
 * @param {!KnuddelAmount} newKnuddelAmount
 * @return {void}
 */
App.prototype.onAccountChangedKnuddelAmount = function(user, knuddelAccount, oldKnuddelAmount, newKnuddelAmount) {};
/**
 * @constructor
 * @struct
 */
function AppAccess() {}

/**
 * Liefert die Instanz der eigenen App.
 * @return {!AppInstance}
 */
AppAccess.prototype.getOwnInstance = function() {};

/**
 * Liefert die Instanzen aller anderen Apps, die gerade in diesem Channel laufen.
 * \@since AppServer 82904
 * @param {boolean=} includeSelf
 * @return {!Array<!AppInstance>}
 */
AppAccess.prototype.getAllRunningAppsInChannel = function(includeSelf) {};

/**
 * Liefert die Instanzen aller anderen Apps, die gerade in diesem Channel laufen.
 * \@since AppServer 82904
 * @param {string} appId
 * @return {!AppInstance}
 */
AppAccess.prototype.getRunningAppInChannel = function(appId) {};
/**
 * @constructor
 * @struct
 */
function AppContent() {}

/**
 * Liefert den AppViewMode.
 * @return {!AppViewMode}
 */
AppContent.prototype.getAppViewMode = function() {};

/**
 * Liefert das HTMLFile, das beim Anlegen des AppContents
 * genutzt wurde.
 * @return {!HTMLFile}
 */
AppContent.prototype.getHTMLFile = function() {};

/**
 * Liefert die Breite des AppContent.
 * @return {number}
 */
AppContent.prototype.getWidth = function() {};

/**
 * Liefert die Höhe des AppContent.
 * @return {number}
 */
AppContent.prototype.getHeight = function() {};

/**
 * Liefert die LoadConfiguration, mit der die Optik beim Laden des HTML User Interface beeinflusst werden kann.
 * @return {!LoadConfiguration}
 */
AppContent.prototype.getLoadConfiguration = function() {};

/**
 * Liefert einen AppContent, der das HTMLFile als Overlay oben rechts im Channel anzeigt.
 * Liefert einen AppContent, der das HTMLFile als Overlay (200x350) oben rechts im Channel anzeigt.
 * @param {!HTMLFile} htmlFile
 * @param {number=} width
 * @param {number=} height
 * @return {!AppContent}
 */
AppContent.overlayContent = function(htmlFile, width, height) {};

/**
 * Liefert einen AppContent, der das HTMLFile im Applet/HTML-Chat
 * als Popup (300x400) und auf Android als Fullscreen-View anzeigt.
 * Liefert einen AppContent, der das HTMLFile im Applet/HTML-Chat
 * als Popup und auf Android als Fullscreen-View anzeigt.
 * @param {!HTMLFile} htmlFile
 * @param {number=} width
 * @param {number=} height
 * @return {!AppContent}
 */
AppContent.popupContent = function(htmlFile, width, height) {};

/**
 * Sendet Daten an alle Nutzer, die diesen AppContent geöffnet haben.
 * @param {string} type
 * @param {(string|!Json|!KnuddelsEventArray)=} data
 * @return {void}
 */
AppContent.prototype.sendEvent = function(type, data) {};

/**
 * Liefert eine Liste aller User, die diesen AppContent
 * geöffnet haben.
 * @return {!Array<!User>}
 */
AppContent.prototype.getUsers = function() {};

/**
 * Liefert eine Liste aller AppContentSessions, die dieses AppContent,
 * die User gerade geöffnet haben.
 * @return {!Array<!AppContentSession>}
 */
AppContent.prototype.getSessions = function() {};

/**
 * Ersetzt den AppContent, bei allen Usern, die diesen AppContent
 * geöffnet haben durch den neuen AppContent.
 * 
 * <br /><br /><b><font color="red">Hinweis:</font></b> Es können nur AppContent mit demselben AppViewMode
 * zum Ersetzen genutzt werden.
 * @param {!AppContent} newAppContent
 * @return {void}
 */
AppContent.prototype.replaceWithAppContent = function(newAppContent) {};

/**
 * Entfernt diesen AppContent, bei allen Usern, die diesen AppContent
 * geöffnet haben.
 * @return {void}
 */
AppContent.prototype.remove = function() {};

/**
 * Fügt einen Listener hinzu, der aufgerufen wird, wenn jemand den AppContent schließt.
 * @param {{user: !User, appContent: !AppContent}} callback
 * @return {void}
 */
AppContent.prototype.addCloseListener = function(callback) {};
/**
 * @constructor
 * @struct
 */
function AppContentSession() {}

/**
 * Sendet Daten an den verbundenen Client.
 * @param {string} type
 * @param {(string|!Json|!KnuddelsEventArray)=} data
 * @return {void}
 */
AppContentSession.prototype.sendEvent = function(type, data) {};

/**
 * Liefert den AppViewMode.
 * @return {!AppViewMode}
 */
AppContentSession.prototype.getAppViewMode = function() {};

/**
 * Entfernt die AppContentSession beim verbundenen User.
 * @return {void}
 */
AppContentSession.prototype.remove = function() {};

/**
 * Liefert den User.
 * @return {!User}
 */
AppContentSession.prototype.getUser = function() {};

/**
 * Liefert den verbundenen AppContent.
 * @return {!AppContent}
 */
AppContentSession.prototype.getAppContent = function() {};
/**
 * @constructor
 * @struct
 */
function AppInfo() {}

/**
 * Liefert die AppUid.
 * Diese ist für jede Sub-Channel Instanz der App unterschiedlich.
 * Wenn RootAppUid == AppUid dann ist dies die Root-App-Instanz.
 * @return {number}
 */
AppInfo.prototype.getAppUid = function() {};

/**
 * Liefert die RootAppUid.
 * Diese ist für jede Sub-Channel Instanz der App gleich.
 * Wenn RootAppUid == AppUid dann ist dies die Root-App-Instanz.
 * 
 * Sie wird für den Link für Auszahlungen aus einem Knuddel-Account benötigt: <code>/knuddelaccount payout:&lt;RootAppUid&gt;:&lt;BETRAG&gt;</code>
 * @return {number}
 */
AppInfo.prototype.getRootAppUid = function() {};

/**
 * Liefert den in der Konfiguration eingestellten Namen der App.
 * @return {string}
 */
AppInfo.prototype.getAppName = function() {};

/**
 * Liefert die Version der App, die in der Konfiguration eingestellt wurde.
 * @return {string}
 */
AppInfo.prototype.getAppVersion = function() {};

/**
 * Liefert die eindeutige Id der App.
 * Die appId setzt sich zusammen aus
 * <ul>
 * 	<li>id des Entwicklungsservers</li>
 * 	<li>FTP-Nutzername</li>
 * 	<li>Ordnername der App -> appKey</li>
 * </ul>
 * @return {string}
 */
AppInfo.prototype.getAppId = function() {};

/**
 * Liefert den eindeutigen Key der App.
 * Der appKey ist der Ordnername, in dem die App liegt.
 * @return {string}
 */
AppInfo.prototype.getAppKey = function() {};

/**
 * Liefert den Entwickler der App, falls die serverId knuddelsDE oder knuddelsDEV ist, ansonsten null.
 * @return {!User}
 */
AppInfo.prototype.getAppDeveloper = function() {};

/**
 * Liefert die Liste der AppManager für diese App. Die Channelbesitzer zählen automatisch auch als AppManager.
 * @return {!Array<!User>}
 */
AppInfo.prototype.getAppManagers = function() {};

/**
 * Liefert den Steuersatz, der bei Auszahlung bereits genutzer Knuddel von einem
 * KnuddelAccount an einen User
 * anfällt. Die anfallenden Steuern werden bei Auszahlung vom BotUser
 * abgezogen.
 * @return {number}
 */
AppInfo.prototype.getTaxRate = function() {};

/**
 * Liefert den KnuddelAmount, der an Steuern anfallen würde,
 * wenn alle User jetzt all ihre Knuddel aus ihrem
 * KnuddelAccount abheben würden.
 * @return {!KnuddelAmount}
 */
AppInfo.prototype.getTotalTaxKnuddelAmount = function() {};

/**
 * Liefert den KnuddelAmount, der jetzt noch vom
 * BotUser an KnuddelAccounts
 * übertragen werden kann, so dass für alle Knuddel noch die Steuern bezahlt werden können.
 * @return {!KnuddelAmount}
 */
AppInfo.prototype.getMaxPayoutKnuddelAmount = function() {};
/**
 * @constructor
 * @struct
 */
function AppInstance() {}

/**
 * Liefert die AppInfo.
 * @return {!AppInfo}
 */
AppInstance.prototype.getAppInfo = function() {};

/**
 * Sendet ein App-Event an diese App-Instanz.
 * @param {string} type
 * @param {(string|!Json|!KnuddelsEventArray)} data
 * @return {void}
 */
AppInstance.prototype.sendAppEvent = function(type, data) {};

/**
 * Informiert, ob die aktuelle AppInstanz eine Root-Instanz ist.
 * @return {boolean}
 */
AppInstance.prototype.isRootInstance = function() {};

/**
 * Liefert die Root-Instanz der aktuellen App-Instanz.
 * @return {!RootAppInstance}
 */
AppInstance.prototype.getRootInstance = function() {};

/**
 * Liefert alle App-Instanzen dieser App in diesem Channel und Subchannels.
 * Mit <code>includeSelf = false</code> kann man die eigene Instanz ausschließen.
 * @param {boolean=} includeSelf
 * @return {!Array<!AppInstance>}
 */
AppInstance.prototype.getAllInstances = function(includeSelf) {};

/**
 * Liefert den Startzeitpunkt dieser AppInstance.
 * @return {!Date}
 */
AppInstance.prototype.getStartDate = function() {};

/**
 * Liefert die Namen der ChatCommands, die diese AppInstnce derzeit registriert hat.
 * @return {!Array<string>}
 */
AppInstance.prototype.getRegisteredChatCommandNames = function() {};

/**
 * Liefert den Namen des Channels in dem diese AppInstance läuft.
 * @return {string}
 */
AppInstance.prototype.getChannelName = function() {};
/**
 * @extends {Persistence}
 * @constructor
 * @struct
 */
function AppPersistence() {}
/**
 * @constructor
 * @struct
 */
function AppProfileEntry() {}

/**
 * Liefert den key für den die Topliste, die den Profileintrag erzeugt angelegt wurde.
 * @return {string}
 */
AppProfileEntry.prototype.getKey = function() {};

/**
 * Liefert den getDisplayType
 * @return {!ToplistDisplayType}
 */
AppProfileEntry.prototype.getDisplayType = function() {};

/**
 * Liefert das Toplist-Objekt.
 * @return {!Toplist}
 */
AppProfileEntry.prototype.getToplist = function() {};
/**
 * @constructor
 * @struct
 */
function AppProfileEntryAccess() {}

/**
 * Liefert die Liste aller AppProfileEntry-Objekte, die diese App erzeugt hat.
 * @return {!Array<!AppProfileEntry>}
 */
AppProfileEntryAccess.prototype.getAllProfileEntries = function() {};

/**
 * Liefert den AppProfileEntry für den übergebenen userPersistenceNumberKey.
 * @param {string} userPersistenceNumberKey
 * @return {!AppProfileEntry}
 */
AppProfileEntryAccess.prototype.getAppProfileEntry = function(userPersistenceNumberKey) {};

/**
 * Erzeugt oder aktualisiert ein AppProfileEntry anhand der übergebenen Toplist
 * und dem ToplistDisplayType und liefert den AppProfileEntry im Anschluss zurück.
 * 
 * Profileinträge, die erzeugt werden, sind nur sichtbar, solange die App läuft und werden im Profil ausgeblendet, sofern die App aus ist.
 * @param {!Toplist} toplist
 * @param {!ToplistDisplayType} toplistDisplayType
 * @return {!AppProfileEntry}
 */
AppProfileEntryAccess.prototype.createOrUpdateEntry = function(toplist, toplistDisplayType) {};

/**
 * Löscht den übergebenen AppProfileEntry.
 * @param {!AppProfileEntry} appProfileEntry
 * @return {void}
 */
AppProfileEntryAccess.prototype.removeEntry = function(appProfileEntry) {};
/**
 * @extends {ServerInfo}
 * @constructor
 * @struct
 */
function AppServerInfo() {}
/**
 * @constructor
 * @struct
 */
function AppViewMode() {}
 /** @type {!AppViewMode} */
AppViewMode.Overlay;
 /** @type {!AppViewMode} */
AppViewMode.Popup;
/**
 * @extends {User}
 * @constructor
 * @struct
 */
function BotUser() {}

/**
 * Sendet eine öffentliche Nachricht in den Channel.
 * @param {string} message
 * @return {void}
 */
BotUser.prototype.sendPublicMessage = function(message) {};

/**
 * Sendet eine öffentliche Handlung in den Channel.
 * Dies funktioniert so, als ob der BotUser /me TEXT im Chat eingeben würde.
 * @param {string} actionMessage
 * @return {void}
 */
BotUser.prototype.sendPublicActionMessage = function(actionMessage) {};

/**
 * Sendet eine private Nachricht an bestimmte Nutzer.
 * @param {string} message
 * @param {!Array<!User>=} users
 * @return {void}
 */
BotUser.prototype.sendPrivateMessage = function(message, users) {};

/**
 * Sendet eine persistente Nachricht an einen bestimmten Nutzer.
 * @param {string} topic
 * @param {string} text
 * @param {!User=} receivingUser
 * @return {void}
 */
BotUser.prototype.sendPostMessage = function(topic, text, receivingUser) {};

/**
 * Transferiert eine bestimmte Anzahl Knuddel an einen Zielnutzer oder KnuddelAccount.<br /><br />
 * <b style="color:red;">Wichtiger Hinweis:</b> Sollte die App versuchen mehr Knuddel zu transferieren,
 * als sie besitzt, so wird der <code>onError</code>-Callback aufgerufen und die App transferiert so viele Knuddel, wie möglich.
 * Zudem werden die Schulden für den Channelbesitzer gemerkt. Sobald sich der Channelbesitzer einloggt, erhält er einen Hinweis über offene Schulden
 * und sollte diese direkt begleichen.
 * Hat ein Channelbesitzer eine gewisse Menge Schulden angesammelt, so schalten wir alle Apps in diesem Channel ab.
 * <br />Es können nur Knuddel transferiert werden zu Nutzern mit <code>UserType.Human</code>.
 * @param {(!User|!KnuddelAccount)} receivingUserOrAccount
 * @param {!KnuddelAmount} knuddelAmount
 * @param {{displayReasonText: string, transferDisplayType: !KnuddelTransferDisplayType, onSuccess: function(): void, onError: function(string): void}=} parameters
 * @return {void}
 */
BotUser.prototype.transferKnuddel = function(receivingUserOrAccount, knuddelAmount, parameters) {};
/**
 * @constructor
 * @struct
 */
function Channel() {}

/**
 * Gibt Zugriff auf das ChannelConfiguration-Objekt des Channels.
 * @return {!ChannelConfiguration}
 */
Channel.prototype.getChannelConfiguration = function() {};

/**
 * Gibt Zugriff auf das ChannelRestrictions-Objekt des Channels.
 * @return {!ChannelRestrictions}
 */
Channel.prototype.getChannelRestrictions = function() {};

/**
 * Gibt Zugriff auf das ChannelDesign-Objekt des Channels.
 * \@since AppServer 87470, ChatServer 87470
 * @return {!ChannelDesign}
 */
Channel.prototype.getChannelDesign = function() {};

/**
 * Gibt Zugriff auf Nutzer, die gerade im Channel online sind.
 * @param {...!UserType} userType
 * @return {!Array<!User>}
 */
Channel.prototype.getOnlineUsers = function(userType) {};

/**
 * Liefert die Information, ob in diesem Channel Videos gestreamt werden können.
 * @return {boolean}
 */
Channel.prototype.isVideoChannel = function() {};

/**
 * Liefert die VideoChannelData des Channels.
 * @return {!VideoChannelData}
 */
Channel.prototype.getVideoChannelData = function() {};

/**
 * Liefert den Namen des Channels.
 * @return {string}
 */
Channel.prototype.getChannelName = function() {};

/**
 * Liefert den Namen des Root-Channels (nur relevant, falls die App Tochterchannel haben kann).
 * @return {string}
 */
Channel.prototype.getRootChannelName = function() {};

/**
 * Liefert den ChannelTalkMode, in dem sich der Channel gerade befindet.
 * @return {!ChannelTalkMode}
 */
Channel.prototype.getTalkMode = function() {};

/**
 * Liefert alle User, die bestimmte ChannelTalkPermissions haben.
 * @param {...!ChannelTalkPermission} channelTalkPermission
 * @return {!Array<!User>}
 */
Channel.prototype.getAllUsersWithTalkPermission = function(channelTalkPermission) {};

/**
 * Liefert die Information, ob der Channel sichtbar (<code>true</code>) oder unsichtbar (<code>false</code>) ist.
 * \@since AppServer 82202
 * @return {boolean}
 */
Channel.prototype.isVisible = function() {};
/**
 * @constructor
 * @struct
 */
function ChannelConfiguration() {}

/**
 * Liefert das ChannelRights-Objekt des Channels.
 * @return {!ChannelRights}
 */
ChannelConfiguration.prototype.getChannelRights = function() {};

/**
 * Liefert das ChannelInformation-Objekt des Channels.
 * @return {!ChannelInformation}
 */
ChannelConfiguration.prototype.getChannelInformation = function() {};
/**
 * @constructor
 * @struct
 */
function ChannelDesign() {}

/**
 * Liefert die eingestellte Standard-Schriftgröße des Channels.
 * \@since AppServer 87470, ChatServer 87470
 * @return {number}
 */
ChannelDesign.prototype.getDefaultFontSize = function() {};

/**
 * Liefert die eingestellte Standard-Schriftfarbe des Channels.
 * \@since AppServer 87470, ChatServer 87470
 * @return {!Color}
 */
ChannelDesign.prototype.getDefaultFontColor = function() {};

/**
 * Liefert die eingestellte Hintergrundfarbe des Channels.
 * \@since AppServer 87470, ChatServer 87470
 * @return {!Color}
 */
ChannelDesign.prototype.getBackgroundColor = function() {};
/**
 * @constructor
 * @struct
 */
function ChannelInformation() {}

/**
 * Liefert das eingestellte Thema des Channels.
 * @return {string}
 */
ChannelInformation.prototype.getTopic = function() {};

/**
 * Aktualisiert das Thema das Channels.
 * @param {string} topic
 * @param {boolean} showMessage
 * @return {void}
 */
ChannelInformation.prototype.setTopic = function(topic, showMessage) {};
/**
 * @constructor
 * @struct
 */
function ChannelJoinPermission() {}

/**
 * Erzeugt ein ChannelJoinPermission-Objekt, das den Zugriff in den Channel erlaubt.
 * @return {!ChannelJoinPermission}
 */
ChannelJoinPermission.accepted = function() {};

/**
 * Erzeugt ein ChannelJoinPermission-Objekt, das den Zugriff in den Channel verbietet.
 * @param {string} denyReason
 * @return {!ChannelJoinPermission}
 */
ChannelJoinPermission.denied = function(denyReason) {};
/**
 * @constructor
 * @struct
 */
function ChannelRestrictions() {}

/**
 * Liefert alle User die im Channel derzeit für das Schreiben öffentlicher Nachrichten gesperrt sind.
 * @return {!Array<!User>}
 */
ChannelRestrictions.prototype.getMutedUsers = function() {};

/**
 * Liefert alle User die im Channel derzeit für das Nutzen
 * von Farben, Textformatierung und Smileys in öffentlichen Nachrichten gesperrt sind.
 * @return {!Array<!User>}
 */
ChannelRestrictions.prototype.getColorMutedUsers = function() {};

/**
 * Liefert alle User die für das Betreten des Channel derzeit gesperrt sind.
 * @return {!Array<!User>}
 */
ChannelRestrictions.prototype.getLockedUsers = function() {};
/**
 * @constructor
 * @struct
 */
function ChannelRights() {}

/**
 * Liefert die Liste aller Channelbesitzer. In öffentlichen Channels sind dies alle hauptzuständigen betreuenden Mitglieder. (HZA/HZE)
 * @return {!Array<!User>}
 */
ChannelRights.prototype.getChannelOwners = function() {};

/**
 * Liefert die Liste aller Channel-Moderatoren.
 * @return {!Array<!User>}
 */
ChannelRights.prototype.getChannelModerators = function() {};

/**
 * Liefert die Liste aller Event-Moderatoren.
 * @return {!Array<!User>}
 */
ChannelRights.prototype.getEventModerators = function() {};
/**
 * @constructor
 * @struct
 */
function ChannelTalkMode() {}
 /** @type {!ChannelTalkMode} */
ChannelTalkMode.Everyone;
 /** @type {!ChannelTalkMode} */
ChannelTalkMode.OnlyWithTalkPermission;
 /** @type {!ChannelTalkMode} */
ChannelTalkMode.FilteredByModerators;
/**
 * @constructor
 * @struct
 */
function ChannelTalkPermission() {}
 /** @type {!ChannelTalkPermission} */
ChannelTalkPermission.NotInChannel;
 /** @type {!ChannelTalkPermission} */
ChannelTalkPermission.Default;
 /** @type {!ChannelTalkPermission} */
ChannelTalkPermission.TalkOnce;
 /** @type {!ChannelTalkPermission} */
ChannelTalkPermission.TalkPermanent;
 /** @type {!ChannelTalkPermission} */
ChannelTalkPermission.VIP;
 /** @type {!ChannelTalkPermission} */
ChannelTalkPermission.Moderator;
/**
 * @extends {ServerInfo}
 * @constructor
 * @struct
 */
function ChatServerInfo() {}

/**
 * Liefert die Information, ob dieser Chat-Server ein Test-System ist.
 * @return {boolean}
 */
ChatServerInfo.prototype.isTestSystem = function() {};
/**
 * @constructor
 * @struct
 */
function Client() {}
 /** @type {!Json} */
Client.pageData;

/**
 * Schließt das HTML User Interface.
 * @return {void}
 */
Client.close = function() {};

/**
 * Sendet ein Event zum Server, das mit dem AppHook onEventReceived in der App
 * abgefangen werden kann.
 * @param {string} type
 * @param {(string|!Json|!KnuddelsEventArray)} data
 * @return {void}
 */
Client.sendEvent = function(type, data) {};

/**
 * Sagt dem Chatserver, dass dieser Befehl für den Nutzer, der das HTML User Interface sieht, ausgeführt werden soll.
 * Ist der Befehl auf einer Whitelist vom Server, so wird er sofort ausgeführt. Im anderen Falle sieht der Nutzer einen
 * Link zum Bestätigen, mit dem er die Aktion starten kann.
 * 
 * Derzeit sind diese Befehle auf der Whitelist: w, info, wc, top, h, dice, d, diceo, w2, serverpp, knuddelaccount,
 * /tf-insert, /tf-inserts, /tf-insertb, /tf-insertsb, /tf-override, /tf-overrides, /tf-overrideb, /tf-overridesb, /autotype
 * @param {string} command
 * @return {void}
 */
Client.executeSlashCommand = function(command) {};

/**
 * Bindet eine Javascript-Datei ein und sorgt dafür, dass immer die aktuellste Version vom Server geladen wird.
 * @param {...string} files
 * @return {void}
 */
Client.includeJS = function(files) {};

/**
 * Registriert sich für ein bestimmtes Event, das vom Server mittels User/sendEvent:method oder vom Client via Client/dispatchEvent:method verschickt wurde.
 * @param {string} type
 * @param {function({type: string, data: (string|!Json|!KnuddelsEventArray)}): void} callback
 * @return {void}
 */
Client.addEventListener = function(type, callback) {};

/**
 * Sendet ein bestimmtes Event, so dass alle mit Client/addEventListener:method registrierten Listener aufgerufen werden.
 * @param {!Client.Event} event
 * @return {void}
 */
Client.dispatchEvent = function(event) {};

/**
 * Entfernt alle Event-Listener für einen bestimmten Event-Typ.
 * @param {string} type
 * @return {void}
 */
Client.removeEventListener = function(type) {};

/**
 * Bindet eine CSS-Datei ein und sorgt dafür, dass immer die aktuellste Version vom Server geladen wird.
 * @param {...string} files
 * @return {void}
 */
Client.includeCSS = function(files) {};

/**
 * Spielt einen Sound ab. Der angegebene Dateiname kann hierbei entweder absolut oder relativ zur angezeigten HTML-Datei sein.
 * Bisher können nur Dateien mit Wave-Format zuverlässig abgespielt werden.
 * @param {string} fileName
 * @return {void}
 */
Client.playSound = function(fileName) {};

/**
 * Lädt einen Sound herunter, damit die Datei später ohne Wartezeit abgespielt werden kann.
 * (Android only)
 * Der angegebene Dateiname kann hierbei entweder absolut oder relativ zur angezeigten HTML-Datei sein.
 * @param {string} fileName
 * @return {void}
 */
Client.prefetchSound = function(fileName) {};

/**
 * Gibt einen Sound wieder frei, der in nächster Zeit vom Client nicht mehr gebraucht wird.
 * (Android only)
 * Der angegebene Dateiname kann hierbei entweder absolut oder relativ zur angezeigten HTML-Datei sein.
 * @param {string} fileName
 * @return {void}
 */
Client.freeSound = function(fileName) {};

/**
 * Liefert den HostFrame des aktuellen Inhalts.
 * @return {!Client.HostFrame}
 */
Client.getHostFrame = function() {};

/**
 * Liefert den Nicknamen des Users, der gerade dieses HTML User Interface angezeigt bekommt.
 * @return {string}
 */
Client.getNick = function() {};

/**
 * Liefert den aktuellen ClientType des Nutzers, der gerade dieses HTML User Interface angezeigt bekommt.
 * @return {!ClientType}
 */
Client.getClientType = function() {};

/**
 * Liefert die Id, die beim Laden von Skripten und Stylesheets an die URL angehängt wird, um sicherzustellen, dass eine neue Version
 * der Datei vom Server geholt wird, statt die Datei aus dem Cache zu laden.
 * 
 * Diese Id kann beim Einbinden eigener Ressourcen zum selben Zweck genutzt werden.
 * @return {string}
 */
Client.getCacheInvalidationId = function() {};
/**
 * @constructor
 * @struct
 */
Client.Color = function() {};

/**
 * Erzeugt ein Color-Objekt mit RGB-Werten.
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 * @return {!Client.Color}
 */
Client.Color.fromRGB = function(red, green, blue) {};

/**
 * Erzeugt ein Color-Objekt aus einem HexString.
 * @param {string} colorString
 * @return {!Client.Color}
 */
Client.Color.fromHexString = function(colorString) {};

/**
 * Liefert den Rot-Anteil der Farbe als Zahl zwischen 0 und 255.
 * @return {number}
 */
Client.Color.prototype.getRed = function() {};

/**
 * Liefert den Grün-Anteil der Farbe als Zahl zwischen 0 und 255.
 * @return {number}
 */
Client.Color.prototype.getGreen = function() {};

/**
 * Liefert den Blau-Anteil der Farbe als Zahl zwischen 0 und 255.
 * @return {number}
 */
Client.Color.prototype.getBlue = function() {};

/**
 * Liefert die Farbe als in CSS nutzbaren HexString.
 * @return {string}
 */
Client.Color.prototype.asHexString = function() {};

/**
 * @constructor
 * @struct
 * Erzeugt ein Event.
 * @param {string} type
 * @param {(string|!Json|!KnuddelsEventArray)} data
 */
Client.Event = function(type, data) {};
/**
 * @constructor
 * @struct
 */
Client.HostFrame = function() {};

/**
 * Setzt den Titel der Seite im gezoomten Modus (nur Android).
 * @param {string} newTitle
 * @return {void}
 */
Client.HostFrame.prototype.setTitle = function(newTitle) {};

/**
 * Ändert die sichtbare Hintergrundfarbe des Hostframes animiert. (Android-only)
 * @param {!Client.Color} newColor
 * @param {number=} durationMillis
 * @return {void}
 */
Client.HostFrame.prototype.setBackgroundColor = function(newColor, durationMillis) {};

/**
 * Setzt die Icons, die als Fenster-Icon angezeigt werden sollen. (Applet-only, nur mit AppViewMode.Popup)
 * Die Bilder müssen von groß nach klein sortiert sein. Die größeren Bilder werden (je nach System) automatisch dann eingesetzt,
 * wenn größere Bilder benötigt werden (z.B. in der Task-Leiste, oder beim Alt+Tab Fenster-Wechsel).
 * \@since Applet: 9.0bwj, AppServer: 84904
 * @param {...string} path
 * @return {void}
 */
Client.HostFrame.prototype.setIcons = function(path) {};

/**
 * Setzt, ob das Fenster resizable ist. (Applet-only, nur mit AppViewMode.Popup)
 * @param {boolean} resizable
 * @return {void}
 */
Client.HostFrame.prototype.setResizable = function(resizable) {};

/**
 * Bringt das Fenster der App (App-Popup bzw. Chat-Fenster) in den Vordergrund. (Applet-only)
 * \@since Applet: 9.0bwj, AppServer: 84904
 * @return {void}
 */
Client.HostFrame.prototype.focus = function() {};

/**
 * Ändert die Größe des App-Fensters (AppViewMode.Popup) bzw. App-Overlays (AppViewMode.Overlay).
 * \@since Applet: 9.0bwj, AppServer: 84516
 * @param {number} width
 * @param {number} height
 * @return {void}
 */
Client.HostFrame.prototype.setSize = function(width, height) {};
/**
 * @constructor
 * @struct
 */
function ClientType() {}
 /** @type {!ClientType} */
ClientType.Applet;
 /** @type {!ClientType} */
ClientType.Browser;
 /** @type {!ClientType} */
ClientType.Android;
 /** @type {!ClientType} */
ClientType.IOS;
 /** @type {!ClientType} */
ClientType.Offline;
/**
 * @constructor
 * @struct
 */
function Color() {}

/**
 * Erzeugt ein serverseitiges Color-Objekt mit RGB-Werten.
 * Als Alpha-Wert wird automatisch 255 genutzt.
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 * @return {!Color}
 */
Color.fromRGB = function(red, green, blue) {};

/**
 * Erzeugt ein serverseitiges Color-Objekt mit RGBA-Werten.
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 * @param {number} alpha
 * @return {!Color}
 */
Color.fromRGBA = function(red, green, blue, alpha) {};

/**
 * Liefert den Alpha-Wert der Farbe als Zahl zwischen 0 und 255.
 * @return {number}
 */
Color.prototype.getAlpha = function() {};

/**
 * Liefert den Blau-Anteil der Farbe als Zahl zwischen 0 und 255.
 * @return {number}
 */
Color.prototype.getBlue = function() {};

/**
 * Liefert den Grün-Anteil der Farbe als Zahl zwischen 0 und 255.
 * @return {number}
 */
Color.prototype.getGreen = function() {};

/**
 * Liefert den Rot-Anteil der Farbe als Zahl zwischen 0 und 255.
 * @return {number}
 */
Color.prototype.getRed = function() {};

/**
 * Liefert die Farbe als KCode zurück.
 * @return {string}
 */
Color.prototype.toKCode = function() {};

/**
 * Liefert die numerische Repräsentation der Farbe zurück.
 * @return {number}
 */
Color.prototype.asNumber = function() {};

/**
 * Erzeugt ein serverseitiges Color-Objekt aus der numerischen Repräsentation einer Farbe.
 * @param {number} value
 * @return {!Color}
 */
Color.fromNumber = function(value) {};

/**
 * @constructor
 * @struct
 * Erzeugt ein Dice-Objekt mit der übergebenen Anzahl Würfel und Augenzahl.
 * @param {number} count
 * @param {number} value
 */
function Dice(count, value) {}

/**
 * Liefert die Anzahl der Würfel.
 * @return {number}
 */
Dice.prototype.getAmount = function() {};

/**
 * Liefert die Anzahl der Seiten der Würfel.
 * @return {number}
 */
Dice.prototype.getNumberOfSides = function() {};
/**
 * @constructor
 * @struct
 */
function DiceConfiguration() {}

/**
 * Informiert, ob es sich um einen offenen Würfelwurf handelt.
 * Offene Würfelwürfe sind speziell. Falls die Augenzahl des Würfels die Maximalsumme zeigt,
 * so wird noch einmal gewürfelt und die neue Zahl dazu addiert, solange bis der Würfel
 * nicht mehr die Maximalsumme zeigt.
 * 
 * <b>Beispiel:</b> /diceo 1w4 -> 4 -> 4 -> 3 = 11
 * @return {boolean}
 */
DiceConfiguration.prototype.isUsingOpenThrow = function() {};

/**
 * Informiert darüber, ob die Würfel privat geworfen worden sind.
 * Würfelwürfe zählen als privat, wenn am Ende des Würfelbefehls ein Ausrufezeichen steht.
 * <b>Beispiel:</b> /dice 10w2!
 * @return {boolean}
 */
DiceConfiguration.prototype.isUsingPrivateThrow = function() {};

/**
 * Liefert ein Array mit Würfeln, mit denen gewürfelt wurde.
 * @return {!Array<!Dice>}
 */
DiceConfiguration.prototype.getDices = function() {};

/**
 * Vergleicht, ob zwei Konfigurationen inhaltlich identisch sind
 * @param {!DiceConfiguration} diceConfiguration
 * @return {boolean}
 */
DiceConfiguration.prototype.equals = function(diceConfiguration) {};

/**
 * Liefert den Befehl, der im Chat eingegeben werden kann, um einen Wurf auszuführen,
 * der zur DiceConfiguration passt.
 * \@since AppServer 82248
 * @return {string}
 */
DiceConfiguration.prototype.getChatCommand = function() {};
/**
 * @constructor
 * @struct
 */
function DiceConfigurationFactory() {}

/**
 * Fügt der Konfiguration einen Würfel hinzu.
 * @param {!Dice} dice
 * @return {void}
 */
DiceConfigurationFactory.prototype.addDice = function(dice) {};

/**
 * Liefert die Anzahl der Würfel, die zur Konfiguration gehören.
 * @return {number}
 */
DiceConfigurationFactory.prototype.computeCurrentDiceCount = function() {};

/**
 * Setzt die Information, ob ein offener Wurf oder ein normaler Wurf stattfinden soll.
 * Offene Würfelwürfe sind speziell. Falls die Augenzahl des Würfels die Maximalsumme zeigt,
 * so wird noch einmal gewürfelt und die neue Zahl dazu addiert, solange bis der Würfel
 * nicht mehr die Maximalsumme zeigt.
 * 
 * <b>Beispiel:</b> /diceo 1w4 -> 4 -> 4 -> 3 = 11
 * @param {boolean} shouldUseOpenThrow
 * @return {void}
 */
DiceConfigurationFactory.prototype.setUseOpenThrow = function(shouldUseOpenThrow) {};

/**
 * Setzt die Information, ob der Würfelwurf privat stattfinden soll.
 * @param {boolean} shouldUsePrivateThrow
 * @return {void}
 */
DiceConfigurationFactory.prototype.setShouldUsePrivateThrow = function(shouldUsePrivateThrow) {};

/**
 * Liefert die erzeugte Würfelkonfiguration.
 * @return {!DiceConfiguration}
 */
DiceConfigurationFactory.prototype.getDiceConfiguration = function() {};

/**
 * Erzeugt eine Würfelkonfiguration.
 * @param {string} diceConfigurationString
 * @return {!DiceConfiguration}
 */
DiceConfigurationFactory.fromString = function(diceConfigurationString) {};
/**
 * @constructor
 * @struct
 */
function DiceEvent() {}

/**
 * Liefert den Nutzer, der gewürfelt hat.
 * @return {!User}
 */
DiceEvent.prototype.getUser = function() {};

/**
 * Liefert das DiceResult des Würfelwurfs.
 * @return {!DiceResult}
 */
DiceEvent.prototype.getDiceResult = function() {};
/**
 * @constructor
 * @struct
 */
function DiceResult() {}

/**
 * Liefert die Konfiguration mit der gewürfelt wurde.
 * @return {!DiceConfiguration}
 */
DiceResult.prototype.getDiceConfiguration = function() {};

/**
 * Liefert ein Array mit Details zu den einzelnen Ergebnissen pro Würfeltyp.
 * @return {!Array<!SingleDiceResult>}
 */
DiceResult.prototype.getSingleDiceResults = function() {};

/**
 * Liefert die Summe der Augenzahlen aller  Würfel
 * @return {number}
 */
DiceResult.prototype.totalSum = function() {};
/**
 * @constructor
 * @struct
 */
function Domain() {}

/**
 * Liefert ein den Domain-Namen der aktuellen Domain.
 * @return {string}
 */
Domain.prototype.getDomainName = function() {};
/**
 * @constructor
 * @struct
 */
function ExternalServerAccess() {}

/**
 * Liefert eine Liste aller zugreifbaren Domains
 * @return {!Array<!Domain>}
 */
ExternalServerAccess.prototype.getAllAccessibleDomains = function() {};

/**
 * Prüft den Zugriff auf eine bestimmte URL. Wird je Kombination von "Protokoll + Host + Port" geprüft.<br>
 * Beispiel: http://www.example.de:8080
 * @param {string} urlString
 * @return {boolean}
 */
ExternalServerAccess.prototype.canAccessURL = function(urlString) {};

/**
 * Macht einen GET-Request auf die übergebene URL und liefert den Inhalt zurück.
 * Diese Methode ist eine Convenience-Methode für externalServerAccess.callURL().
 * @param {string} urlString
 * @param {{onSuccess: function(string, !ExternalServerResponse): void, onFailure: function(string, !ExternalServerResponse): void}=} parameters
 * @return {void}
 */
ExternalServerAccess.prototype.getURL = function(urlString, parameters) {};

/**
 * Macht einen POST-Request auf die übergebene URL und liefert den Inhalt zurück.
 * Diese Methode ist eine Convenience-Methode für externalServerAccess.callURL().
 * @param {string} urlString
 * @param {{onSuccess: function(string, !ExternalServerResponse): void, onFailure: function(string, !ExternalServerResponse): void, data: !Json}=} parameters
 * @return {void}
 */
ExternalServerAccess.prototype.postURL = function(urlString, parameters) {};

/**
 * Macht einen GET-Request auf die übergebene URL. Im Gegensatz zum GET-Request wird der Inhalt der Webseite wird nicht ausgelesen.
 * Aus diesem Grund ist diese Methode schneller.
 * Diese Methode ist eine Convenience-Methode für externalServerAccess.callURL().
 * @param {string} urlString
 * @param {{onSuccess: function(string, !ExternalServerResponse): void, onFailure: function(string, !ExternalServerResponse): void}=} parameters
 * @return {void}
 */
ExternalServerAccess.prototype.touchURL = function(urlString, parameters) {};

/**
 * Macht einen Request auf die übergebene URL.
 * @param {string} urlString
 * @param {{onSuccess: function(string, !ExternalServerResponse): void, onFailure: function(string, !ExternalServerResponse): void, method: string, data: !Json}=} parameters
 * @return {void}
 */
ExternalServerAccess.prototype.callURL = function(urlString, parameters) {};
/**
 * @constructor
 * @struct
 */
function ExternalServerResponse() {}

/**
 * Liefert die abgefragte URL.
 * @return {string}
 */
ExternalServerResponse.prototype.getURLString = function() {};

/**
 * Liefert den <a href="https://de.wikipedia.org/wiki/HTTP-Statuscode" target="_blank">HTTP-Statuscode</a> der Seite.
 * @return {number}
 */
ExternalServerResponse.prototype.getResponseCode = function() {};

/**
 * Liefert ein Objekt, das die Headerdaten der Antwort enthält.
 * @return {!Object<string,!Array<string>>}
 */
ExternalServerResponse.prototype.getHeaderFields = function() {};
/**
 * @constructor
 * @struct
 */
function Gender() {}
 /** @type {!Gender} */
Gender.Male;
 /** @type {!Gender} */
Gender.Female;
 /** @type {!Gender} */
Gender.Unknown;

/**
 * @constructor
 * @struct
 *
 * @param {string} assetPath
 * @param {!Json=} pageData
 */
function HTMLFile(assetPath, pageData) {}

/**
 * Liefert den Pfad, der beim Anlegen der HTMLFile-Instanz genutzt wurde.
 * @return {string}
 */
HTMLFile.prototype.getAssetPath = function() {};

/**
 * Liefert die pageData, die beim Anlegen der HTMLFile-Instanz genutzt wurden.
 * @return {!Json}
 */
HTMLFile.prototype.getPageData = function() {};
/**
 * @constructor
 * @struct
 */
function KnuddelAccount() {}

/**
 * Liefert den KnuddelAmount eines Users,
 * über den die App gerade frei verfügen kann.
 * @return {!KnuddelAmount}
 */
KnuddelAccount.prototype.getKnuddelAmount = function() {};

/**
 * Liefert den KnuddelAmount aus dem KnuddelAccount,
 * der bereits von der App genutzt wurde.
 * Beim Auszahlen dieser Knuddel aus dem KnuddelAccount an den
 * User fallen Steuern an.
 * @return {!KnuddelAmount}
 */
KnuddelAccount.prototype.getKnuddelAmountUsed = function() {};

/**
 * Liefert den KnuddelAmount aus dem KnuddelAccount,
 * der noch nicht von der App genutzt wurde.
 * Beim Auszahlen dieser Knuddel aus dem KnuddelAccount an den
 * User fallen <strong>keine</strong> Steuern an.
 * @return {!KnuddelAmount}
 */
KnuddelAccount.prototype.getKnuddelAmountUnused = function() {};

/**
 * Liefert die Summe aller Transfers, die die App an diesen KnuddelAccount bzw. User überwiesen hat.
 * @return {!KnuddelAmount}
 */
KnuddelAccount.prototype.getTotalKnuddelAmountAppToUser = function() {};

/**
 * Liefert die Summe aller Transfers, die die App von diesem KnuddelAccount bzw. User abgebucht/erhalten hat.
 * @return {!KnuddelAmount}
 */
KnuddelAccount.prototype.getTotalKnuddelAmountUserToApp = function() {};

/**
 * Liefert die Information, ob in diesem Moment genug Knuddel verfügbar sind.
 * @param {!KnuddelAmount} knuddelAmount
 * @return {boolean}
 */
KnuddelAccount.prototype.hasEnough = function(knuddelAmount) {};

/**
 * Liefert den Nutzer, dem der KnuddelAccount gehört.
 * @return {!User}
 */
KnuddelAccount.prototype.getUser = function() {};

/**
 * Versucht eine bestimmte Menge Knuddel zu verwenden. Dies ist nur möglich, wenn der User auf seinem KnuddelAccount
 * genug Knuddel besitzt <strong>und</strong> online im Channel ist.
 * Vom KnuddelAccount des Besitzer des Channel können Knuddel auch abgebucht werden, wenn dieser nicht im Channel online ist.
 * 
 * Ist das Event App.onBeforeKnuddelReceived implementiert, so wird diese direkt nach dem <code>use</code> aufgerufen,
 * um zu entscheiden, ob die Knuddel angenommen werden sollen.
 * 
 * <br ><br ><b>Hinweis:</b> Knuddel an einen Nutzer senden kannst du mit der Methode BotUser/transferKnuddel:method.
 * @param {!KnuddelAmount} knuddelAmount
 * @param {string} displayReasonText
 * @param {{transferReason: string, onError: function(string): void, onSuccess: function(): void}=} parameters
 * @return {void}
 */
KnuddelAccount.prototype.use = function(knuddelAmount, displayReasonText, parameters) {};

/**
 * @constructor
 * @struct
 * Erzeugt eine Instanz von KnuddelAmount mit der Anzahl Knuddel.
 * @param {number} knuddel
 */
function KnuddelAmount(knuddel) {}

/**
 * Erzeugt eine Instanz von KnuddelAmount mit einer bestimmten Cent-Anzahl.
 * @param {number} knuddel
 * @return {!KnuddelAmount}
 */
KnuddelAmount.fromCents = function(knuddel) {};

/**
 * Erzeugt eine Instanz von KnuddelAmount mit einer bestimmten Knuddel-Anzahl.
 * @param {number} knuddel
 * @return {!KnuddelAmount}
 */
KnuddelAmount.fromKnuddel = function(knuddel) {};

/**
 * Liefert die Anzahl der Knuddel in KnuddelCent zurück.
 * @return {number}
 */
KnuddelAmount.prototype.getKnuddelCents = function() {};

/**
 * Gibt den Wert der Knuddel als Zahl zurück.
 * @return {number}
 */
KnuddelAmount.prototype.asNumber = function() {};

/**
 * Liefert eine negierte Kopie des KnuddelAmount zurück.
 * @return {!KnuddelAmount}
 */
KnuddelAmount.prototype.negate = function() {};

/**
 * Liefert die Information, ob der Knuddelwert unter 0 ist.
 * @return {boolean}
 */
KnuddelAmount.prototype.isNegative = function() {};
/**
 * @constructor
 * @struct
 */
function KnuddelPot() {}

/**
 * Liefert die id des KnuddelPot.
 * @return {number}
 */
KnuddelPot.prototype.getId = function() {};

/**
 * Liefert den Status des KnuddelPot.
 * @return {!KnuddelPotState}
 */
KnuddelPot.prototype.getState = function() {};

/**
 * Liefert den beim Kreieren des KnuddelPots festgelegten KnuddelAmount, den jeder Teilnehmer zahlen muss.
 * @return {!KnuddelAmount}
 */
KnuddelPot.prototype.getKnuddelAmountPerParticipant = function() {};

/**
 * Liefert den KnuddelAmount, der bisher insgesamt in den KnuddelPot eingezahlt wurde.
 * @return {!KnuddelAmount}
 */
KnuddelPot.prototype.getKnuddelAmountTotal = function() {};

/**
 * Liefert die Liste der Teilnehmer, die bisher in den KnuddelPot eingezahlt haben.
 * @return {!Array<!User>}
 */
KnuddelPot.prototype.getParticipants = function() {};

/**
 * Liefert den höchsten Multiplikator, der gültig ist.
 * @return {number}
 */
KnuddelPot.prototype.getMaxFeeMultiplier = function() {};

/**
 * Setzt den BotUser, der den Anteil der Einzahlungen nach dem Spiel erhält
 * und den Anteil, vom Gesamtpot, den er erhalten soll.
 * @param {!BotUser} feeUser
 * @param {number} feeMultiplier
 * @return {void}
 */
KnuddelPot.prototype.setFee = function(feeUser, feeMultiplier) {};

/**
 * Liefert den mit KnuddelPot/setFee:method gesetzten BotUser an den die Gebühr ausbezahlt wird.
 * @return {!User}
 */
KnuddelPot.prototype.getFeeUser = function() {};

/**
 * Liefert den mit KnuddelPot/setFee:method gesetzten Multiplikator der Gebühr.
 * @return {number}
 */
KnuddelPot.prototype.getFeeMultiplier = function() {};

/**
 * Versiegelt den KnuddelPot, sodass keine weiteren Einzahlungen vorgenommen
 * werden können und Gewinne ausgeschüttet werden können.
 * @return {void}
 */
KnuddelPot.prototype.seal = function() {};

/**
 * Bezahlt alle Einsätze an die Teilnehmer zurück und informiert mit dem übergeben Text über den Grund.
 * @param {string=} reason
 * @return {void}
 */
KnuddelPot.prototype.refund = function(reason) {};

/**
 * Fügt einen Gewinner in die Liste der Gewinner hinzu.
 * Der zweite Parameter ist die Gewichtung mit der ausgezahlt werden soll.
 * Wird der Parameter weggelassen, so ist er automatisch 1.
 * @param {!User} user
 * @param {number=} weight
 * @return {void}
 */
KnuddelPot.prototype.addWinner = function(user, weight) {};

/**
 * Zahlt den KnuddelPot an die mit addWinner gesetzten Gewinner aus.
 * @param {string=} text
 * @return {void}
 */
KnuddelPot.prototype.payout = function(text) {};
/**
 * @constructor
 * @struct
 */
function KnuddelPotState() {}
 /** @type {!KnuddelPotState} */
KnuddelPotState.Open;
 /** @type {!KnuddelPotState} */
KnuddelPotState.Sealed;
 /** @type {!KnuddelPotState} */
KnuddelPotState.Closed;
/**
 * @constructor
 * @struct
 */
function KnuddelTransfer() {}

/**
 * Liefert den User, der den KnuddelTransfer ausgelöst hat.
 * @return {!User}
 */
KnuddelTransfer.prototype.getSender = function() {};

/**
 * Liefert den BotUser, der die Knuddel des KnuddelTransfer erhält,
 * wenn dieser mit accept()</code> angenommen wurde.
 * @return {!BotUser}
 */
KnuddelTransfer.prototype.getReceiver = function() {};

/**
 * Liefert die Anzahl der Knuddel, die mit diesem Transfer überwiesen werden.
 * @return {!KnuddelAmount}
 */
KnuddelTransfer.prototype.getKnuddelAmount = function() {};

/**
 * Liefert den Grund für den Transfer, der bei der Überweisung angegeben wurde mit
 * <code>/appknuddel BOTNICK:KNUDDEL:GRUND</code>.
 * @return {string}
 */
KnuddelTransfer.prototype.getTransferReason = function() {};

/**
 * Lehnt die Knuddel aus dem KnuddelTransfer ab und sendet sie zurück an den Absender.
 * Als Grund sieht der Absender den übergebenen <code>reason</code>.
 * 
 * Diese Methode wirft eine Exception, wenn sie auf einen bereits verarbeiteten Transfer aufgerufen wird.
 * Sie kann nur erfolgreich aus dem AppHook <code>onBeforeKnuddelReceived</code> aufgerufen werden.
 * 
 * In der Methode <code>onBeforeKnuddelReceived</code> kann genau ein Aufruf einer dieser drei Methoden gemacht werden:
 * KnuddelTransfer/accept:method,
 * KnuddelTransfer/addToPot:method,
 * KnuddelTransfer/reject:method
 * @param {string} reason
 * @return {void}
 */
KnuddelTransfer.prototype.reject = function(reason) {};

/**
 * Nimmt die Knuddel aus dem KnuddelTransfer an und übergibt sie an den BotUser,
 * der mit <code>getReceiver()</code> abgefragt werden kann.
 * 
 * Diese Methode wirft eine Exception, wenn sie auf einen bereits verarbeiteten Transfer aufgerufen wird.
 * Sie kann nur erfolgreich aus dem AppHook <code>onBeforeKnuddelReceived</code> aufgerufen werden.
 * In der Methode <code>onBeforeKnuddelReceived</code> kann genau ein Aufruf einer dieser drei Methoden gemacht werden:
 * 
 * KnuddelTransfer/accept:method,
 * KnuddelTransfer/addToPot:method,
 * KnuddelTransfer/reject:method
 * @return {void}
 */
KnuddelTransfer.prototype.accept = function() {};

/**
 * Liefert die Information, ob ein bestimmter KnuddelTransfer zu einem KnuddelPot hinzugefügt werden kann.
 * @param {!KnuddelPot} pot
 * @return {boolean}
 */
KnuddelTransfer.prototype.canAddToPot = function(pot) {};

/**
 * Nimmt die Knuddel aus dem KnuddelTransfer an und übergibt sie an den übergebenen KnuddelPot.
 * 
 * Diese Methode funktioniert analog zu KnuddelTransfer/accept:method, nur dass die Knuddel im KnuddelPot statt beim BotUser landen.
 * 
 * Diese Methode wirft eine Exception, wenn sie auf einen bereits verarbeiteten Transfer aufgerufen wird.
 * Sie kann nur erfolgreich aus dem AppHook <code>onBeforeKnuddelReceived</code> aufgerufen werden.
 * 
 * In der Methode <code>onBeforeKnuddelReceived</code> kann genau ein Aufruf einer dieser drei Methoden gemacht werden:
 * KnuddelTransfer/accept:method,
 * KnuddelTransfer/addToPot:method,
 * KnuddelTransfer/reject:method
 * @param {!KnuddelPot} knuddelPot
 * @return {void}
 */
KnuddelTransfer.prototype.addToPot = function(knuddelPot) {};

/**
 * Liefert die Information, ob der KnuddelTransfer bereits verarbeitet wurde.
 * Falls die Methode <code>false</code> zurückliefert muss noch entschieden werden, ob der
 * KnuddelTransfer angenommen oder abgelehnt wird.
 * @return {boolean}
 */
KnuddelTransfer.prototype.isProcessed = function() {};
/**
 * @constructor
 * @struct
 */
function KnuddelTransferDisplayType() {}
 /** @type {!KnuddelTransferDisplayType} */
KnuddelTransferDisplayType.Public;
 /** @type {!KnuddelTransferDisplayType} */
KnuddelTransferDisplayType.Private;
 /** @type {!KnuddelTransferDisplayType} */
KnuddelTransferDisplayType.Post;
/**
 * @constructor
 * @struct
 */
function KnuddelsServer() {}

/**
 * Liefert den BotUser, der standardmäßig zur App gehört.
 * @return {!BotUser}
 */
KnuddelsServer.getDefaultBotUser = function() {};

/**
 * Liefert die AppPersistence, mit der sich Zahlen, Strings und Javascript-Objekte langfristig und über die Session einer App hinaus gespeichert werden können.
 * @return {!AppPersistence}
 */
KnuddelsServer.getPersistence = function() {};

/**
 * Liefert den Channel in dem die App läuft.
 * @return {!Channel}
 */
KnuddelsServer.getChannel = function() {};

/**
 * Liefert das UserAccess-Objekt, über das
 * User zugreifbar werden.
 * @return {!UserAccess}
 */
KnuddelsServer.getUserAccess = function() {};

/**
 * Liefert ein ExternalServerAccess-Objekt, mit dem
 * andere Server angesteuert werden können.
 * @return {!ExternalServerAccess}
 */
KnuddelsServer.getExternalServerAccess = function() {};

/**
 * Aktualisiert die Liste der genutzten Hooks. Werden zur Laufzeit chatCommands oder App-Hooks (wie mayJoinChannel) dynamisch erzeugt oder gelöscht, so muss danach <code>refreshHooks()</code>
 * aufgerufen werden, damit diese Änderung wirksam wird.
 * @return {void}
 */
KnuddelsServer.refreshHooks = function() {};

/**
 * Liefert den Standard-Logger für diese App. Alles, was geloggt wird, wird vom Nutzer "App-Logs" als private Nachricht zugestellt.
 * @return {!Logger}
 */
KnuddelsServer.getDefaultLogger = function() {};

/**
 * Liefert den Pfad eines Bildes zur Integration in der eigenen App.
 * Alle Bilder, die im Ordner /www in der App abgelegt werden können hier referenziert werden.
 * @param {string} imageName
 * @return {string}
 */
KnuddelsServer.getFullImagePath = function(imageName) {};

/**
 * Liefert den Pfad eines <b>Systembildes</b> zur Integration in der eigenen App.
 * Alle Bilder, die unter <a href="http://apps4.knuddels.biz/kimg/" target="_blank">http://apps4.knuddels.biz/kimg/</a>
 * erreichbar sind können hier referenziert werden.
 * @param {string} imageName
 * @return {string}
 */
KnuddelsServer.getFullSystemImagePath = function(imageName) {};

/**
 * Liefert die Informationen über den ChatServer auf dem die App läuft.
 * @return {!ChatServerInfo}
 */
KnuddelsServer.getChatServerInfo = function() {};

/**
 * Liefert die Informationen über den AppServer auf dem die App läuft.
 * @return {!AppServerInfo}
 */
KnuddelsServer.getAppServerInfo = function() {};

/**
 * Liefert das AppAccess-Object.
 * @return {!AppAccess}
 */
KnuddelsServer.getAppAccess = function() {};

/**
 * Erzeugt einen KnuddelPot.
 * 
 * Ist ein KnuddelPot 30 Minuten nach dem Erzeugen noch nicht gesealt,
 * so wird vom Server automatisch ein KnuddelPot/refund:method ausgelöst.
 * @param {!KnuddelAmount} knuddelAmount
 * @param {{payoutTimeoutMinutes: number, shouldSealPot: function(!KnuddelPot): boolean, onPotSealed: function(!KnuddelPot): void}=} params
 * @return {!KnuddelPot}
 */
KnuddelsServer.createKnuddelPot = function(knuddelAmount, params) {};

/**
 * Liefert den KnuddelPot mit der angegeben id.
 * @param {number} id
 * @return {!KnuddelPot}
 */
KnuddelsServer.getKnuddelPot = function(id) {};

/**
 * Liefert alle für die App noch verwaltbaren KnuddelPot-Objekte.
 * @return {!Array<!KnuddelPot>}
 */
KnuddelsServer.getAllKnuddelPots = function() {};

/**
 * Liefert das ToplistAccess-Objekt, über das
 * Toplisten erzeugt und verwaltet werden können.
 * @return {!ToplistAccess}
 */
KnuddelsServer.getToplistAccess = function() {};

/**
 * Liefert das AppProfileEntryAccess-Objekt, über das
 * App-Profileinträge erzeugt und verwaltet werden können.
 * @return {!AppProfileEntryAccess}
 */
KnuddelsServer.getAppProfileEntryAccess = function() {};
/**
 * @constructor
 * @struct
 */
function LoadConfiguration() {}

/**
 * Setzt die Farbe des Hintergrundes vom Loading-View, der angezeigt wird, während das HTML User Interface lädt. (standardmäßig weiß)
 * @param {!Color} color
 * @return {void}
 */
LoadConfiguration.prototype.setBackgroundColor = function(color) {};

/**
 * Setzt das Hintergrundbild vom Loading-View, das angezeigt wird, während das HTML User Interface lädt. (standardmäßig nicht gesetzt)
 * @param {string} imageUrl
 * @return {void}
 */
LoadConfiguration.prototype.setBackgroundImage = function(imageUrl) {};

/**
 * Setzt den Text des Ladehinweiseses im Loading-View, der angezeigt wird, während das HTML User Interface lädt. (standardmäßig "Lädt...")
 * Hinweis: Wird mit setLoadingIndicatorImage ein Loaading-Indicator-Bild gesetzt, so wird der mit setText gesetzte Texte ignoriert.
 * @param {string} text
 * @return {void}
 */
LoadConfiguration.prototype.setText = function(text) {};

/**
 * Setzt ein Loading-Indicator-Bild im Loading-View, das angezeigt wird, während das HTML User Interface lädt. (standardmäßig nicht gesetzt)
 * Hinweis: Wird mit setLoadingIndicatorImage ein Loaading-Indicator-Bild gesetzt, so wird der mit setText gesetzte Texte ignoriert.
 * @param {string} imageUrl
 * @return {void}
 */
LoadConfiguration.prototype.setLoadingIndicatorImage = function(imageUrl) {};

/**
 * Setzt die Farbe des Textes im Loading-View, der angezeigt wird, während das HTML User Interface lädt. (standardmäßig schwarz)
 * @param {!Color} color
 * @return {void}
 */
LoadConfiguration.prototype.setForegroundColor = function(color) {};

/**
 * Aktiviert/Deaktiviert die Nutzung vom Loading-View. (standardmäßig aktiviert)
 * Es kann sinnvoll sein, den Loading-View zu deaktivieren, wenn man selbst einen komplett eigenen Loading-View in seine App einbauen möchte.
 * @param {boolean} enabled
 * @return {void}
 */
LoadConfiguration.prototype.setEnabled = function(enabled) {};
/**
 * @constructor
 * @struct
 */
function Logger() {}

/**
 * Logge einen Text mit Level DEBUG. Dieser wird im Chat allen dafür registrierten AppManagern per /p vom App-Logs-User zugestellt. Siehe: /apps, Tab: Logs.
 * 
 * Die Methode erwartet beliebig viele Strings als Parameter. Diese werden vor dem Logging mit einem Leerzeichen gejoint.
 * @param {...?} msg
 * @return {void}
 */
Logger.prototype.debug = function(msg) {};

/**
 * Logge einen Text mit Level INFO. Dieser wird im Chat allen dafür registrierten AppManagern per /p vom App-Logs-User zugestellt. Siehe: /apps, Tab: Logs.
 * 
 * Die Methode erwartet beliebig viele Strings als Parameter. Diese werden vor dem Logging mit einem Leerzeichen gejoint.
 * @param {...?} msg
 * @return {void}
 */
Logger.prototype.info = function(msg) {};

/**
 * Logge einen Text mit Level WARN. Dieser wird im Chat allen dafür registrierten AppManagern per /p vom App-Logs-User zugestellt, sowie im /apps Fenster im Log angezeigt. Siehe: /apps, Tab: Logs.
 * 
 * Die Methode erwartet beliebig viele Strings als Parameter. Diese werden vor dem Logging mit einem Leerzeichen gejoint.
 * @param {...?} msg
 * @return {void}
 */
Logger.prototype.warn = function(msg) {};

/**
 * Logge einen Text mit Level ERROR. Dieser wird im Chat allen dafür registrierten AppManagern per /p vom App-Logs-User zugestellt, sowie im /apps Fenster im Log angezeigt. Siehe: /apps, Tab: Logs.
 * 
 * Die Methode erwartet beliebig viele Strings als Parameter. Diese werden vor dem Logging mit einem Leerzeichen gejoint.
 * @param {...?} msg
 * @return {void}
 */
Logger.prototype.error = function(msg) {};

/**
 * Logge einen Text mit Level FATAL. Dieser wird im Chat allen dafür registrierten AppManagern per /p vom App-Logs-User zugestellt, sowie im /apps Fenster im Log angezeigt. Siehe: /apps, Tab: Logs.
 * 
 * Die Methode erwartet beliebig viele Strings als Parameter. Diese werden vor dem Logging mit einem Leerzeichen gejoint.
 * @param {...?} msg
 * @return {void}
 */
Logger.prototype.fatal = function(msg) {};
/**
 * @constructor
 * @struct
 */
function Message() {}

/**
 * Liefert den User, der die Nachricht verfasst hat.
 * @return {!User}
 */
Message.prototype.getAuthor = function() {};

/**
 * Liefert den Inhalt der Nachricht.
 * @return {string}
 */
Message.prototype.getText = function() {};

/**
 * Liefert den genauen Zeitpunkt, zu dem die Nachricht erstellt wurde.
 * @return {!Date}
 */
Message.prototype.getCreationDate = function() {};
/**
 * @constructor
 * @struct
 */
function OwnAppInstance() {}

/**
 * Gibt Zugriff auf Nutzer, die gerade im Channel dieser AppInstance online sind.
 * \@since AppServer 82560
 * @param {!AppInstance} otherAppInstance
 * @param {...!UserType} userType
 * @return {!Array<!User>}
 */
OwnAppInstance.prototype.getOnlineUsers = function(otherAppInstance, userType) {};
/**
 * @constructor
 * @struct
 */
function Persistence() {}

/**
 * Informiert darüber, ob unter dem <code>key</code> ein String abgespeichert ist.
 * @param {string} key
 * @return {boolean}
 */
Persistence.prototype.hasString = function(key) {};

/**
 * Setzt die Zeichenkette <code>value</code> für den <code>key</code>.
 * Falls bereits eine Zeichenkette für den <code>key</code> existiert, so wird diese überschrieben.
 * @param {string} key
 * @param {string} value
 * @return {void}
 */
Persistence.prototype.setString = function(key, value) {};

/**
 * Liefert die Zeichenkette, die für den <code>key</code> gespeichert ist.
 * Falls für <code>key</code> keine Zeichenkette gespeichert ist, so gibt die Methode
 * den <code>defaultValue</code> zurück.
 * @param {string} key
 * @param {string=} defaultValue
 * @return {string}
 */
Persistence.prototype.getString = function(key, defaultValue) {};

/**
 * Löscht die Zeichenkette, die unter <code>key</code> gespeichert ist.
 * @param {string} key
 * @return {void}
 */
Persistence.prototype.deleteString = function(key) {};

/**
 * Informiert darüber, ob unter dem <code>key</code> eine Zahl abgespeichert ist.
 * @param {string} key
 * @return {boolean}
 */
Persistence.prototype.hasNumber = function(key) {};

/**
 * Setzt die Zahl <code>value</code> für den <code>key</code>.
 * Falls bereits eine Zahl für den <code>key</code> existiert, so wird diese überschrieben.
 * @param {string} key
 * @param {number} value
 * @return {void}
 */
Persistence.prototype.setNumber = function(key, value) {};

/**
 * Addiert den übergebenen <code>value</code> auf die unter dem Key <code>key</code> vorhandenen Wert drauf.
 * Value kann auch negativ sein um eine Subtraktion durchzuführen.
 * Falls keine Zahl für den <code>key</code> existiert, so wird der <code>value</code> für <code>key</code> gespeichert.
 * @param {string} key
 * @param {number} value
 * @return {number}
 */
Persistence.prototype.addNumber = function(key, value) {};

/**
 * Liefert die Zahl, die für den <code>key</code> gespeichert ist.
 * Falls für <code>key</code> keine Zahl gespeichert ist, so gibt die Methode
 * den <code>defaultValue</code> zurück.
 * @param {string} key
 * @param {number=} defaultValue
 * @return {number}
 */
Persistence.prototype.getNumber = function(key, defaultValue) {};

/**
 * Löscht die Zahl, die unter <code>key</code> gespeichert ist.
 * @param {string} key
 * @return {void}
 */
Persistence.prototype.deleteNumber = function(key) {};

/**
 * Informiert darüber, ob unter dem <code>key</code> ein Objekt abgespeichert ist.
 * @param {string} key
 * @return {boolean}
 */
Persistence.prototype.hasObject = function(key) {};

/**
 * Setzt das Objekt <code>value</code> für den <code>key</code>.
 * Falls bereits ein Objekt für den <code>key</code> existiert, so wird dieses überschrieben.
 * Das als JSON serialisierte Objekt darf maximal 100kb groß sein.
 * @param {string} key
 * @param {(string|number|boolean|!User|!BotUser|!KnuddelsJson|!KnuddelsJsonArray)} object
 * @return {void}
 */
Persistence.prototype.setObject = function(key, object) {};

/**
 * Liefert das Objekt, das für den <code>key</code> gespeichert ist.
 * Falls für <code>key</code> kein Objekt gespeichert ist, so gibt die Methode
 * den <code>defaultValue</code> zurück.
 * @param {string} key
 * @param {(string|number|boolean|!User|!BotUser|!KnuddelsJson|!KnuddelsJsonArray)=} defaultValue
 * @return {(string|number|boolean|!User|!BotUser|!KnuddelsJson|!KnuddelsJsonArray)}
 */
Persistence.prototype.getObject = function(key, defaultValue) {};

/**
 * Löscht das Objekt, das unter <code>key</code> gespeichert ist.
 * @param {string} key
 * @return {void}
 */
Persistence.prototype.deleteObject = function(key) {};
/**
 * @extends {Message}
 * @constructor
 * @struct
 */
function PrivateMessage() {}

/**
 * Liefert die Liste der Empfänger der Nachricht.
 * @return {!Array<!User>}
 */
PrivateMessage.prototype.getReceivingUsers = function() {};

/**
 * Sendet eine private Nachricht an alle Beteiligten des Gespräches.
 * @param {string} text
 * @return {void}
 */
PrivateMessage.prototype.sendReply = function(text) {};
/**
 * @extends {Message}
 * @constructor
 * @struct
 */
function PublicActionMessage() {}
/**
 * @extends {Message}
 * @constructor
 * @struct
 */
function PublicEventMessage() {}
/**
 * @extends {Message}
 * @constructor
 * @struct
 */
function PublicMessage() {}
/**
 * @constructor
 * @struct
 */
function Quest() {}

/**
 * Löst ein Quest-Event aus.
 * \@since AppServer 82290, ChatServer 82290
 * @param {number=} count
 * @return {void}
 */
Quest.prototype.setSolved = function(count) {};

/**
 * Liefert den Key der Quest.
 * \@since AppServer 82290, ChatServer 82290
 * @return {string}
 */
Quest.prototype.getQuestKey = function() {};
/**
 * @constructor
 * @struct
 */
function QuestAccess() {}

/**
 * Liefert die Quests
 * für diesen Nutzer in dieser App.
 * \@since AppServer 82290, ChatServer 82290
 * @return {!Array<!Quest>}
 */
QuestAccess.prototype.getQuests = function() {};

/**
 * Liefert die Information, ob eine bestimmte Quest offen ist.
 * \@since AppServer 82290, ChatServer 82290
 * @param {string} questKey
 * @return {boolean}
 */
QuestAccess.prototype.hasQuest = function(questKey) {};

/**
 * Liefert eine bestimmte Quest, falls vorhanden.
 * \@since AppServer 82290, ChatServer 82290
 * @param {string} questKey
 * @return {!Quest}
 */
QuestAccess.prototype.getQuest = function(questKey) {};

/**
 * Liefert den User, der zu diesem QuestAccess-Objekt gehört.
 * \@since AppServer 82290, ChatServer 82290
 * @return {!User}
 */
QuestAccess.prototype.getUser = function() {};
/**
 * @constructor
 * @struct
 */
function RandomOperations() {}

/**
 * Liefert eine Zufallszahl zwischen <code>minValue</code> (inklusiv) und <code>maxValue</code> (exklusiv).
 * @param {number} minValue
 * @param {number} maxValue
 * @return {number}
 */
RandomOperations.nextInt = function(minValue, maxValue) {};

/**
 * Liefert ein Array mit Zufallszahlen zwischen minValue (inklusiv) und <code>n</code> (exklusiv).
 * @param {number} minValue
 * @param {number} maxValue
 * @param {number} count
 * @param {boolean} onlyDifferentNumbers
 * @return {!Array<number>}
 */
RandomOperations.nextInts = function(minValue, maxValue, count, onlyDifferentNumbers) {};

/**
 * Liefert <code>true</code> in <code>truePropability</code>/1 Fällen
 * @param {number} truePropability
 * @return {boolean}
 */
RandomOperations.flipTrue = function(truePropability) {};

/**
 * Liefert ein zufälliges Objekt aus einem Array.
 * Falls das Array leer ist, wird <code>null</code> zurückgeliefert.
 * @template T
 * @param {!Array<T>} objects
 * @return {T}
 */
RandomOperations.getRandomObject = function(objects) {};

/**
 * Mischt das Array der übergebenen Objekte und liefert es zurück.
 * @template T
 * @param {!Array<T>} objects
 * @return {!Array<T>}
 */
RandomOperations.shuffleObjects = function(objects) {};

/**
 * Liefert einen zufälligen String zurück.
 * \@since AppServer 92699
 * @param {number} length
 * @param {string=} allowedCharacters
 * @return {string}
 */
RandomOperations.getRandomString = function(length, allowedCharacters) {};
/**
 * @extends {AppInstance}
 * @constructor
 * @struct
 */
function RootAppInstance() {}

/**
 * Aktualisiert diese App im Channel (und ggf. vorhandenen Tochterchanneln) auf die neueste Version.
 * @param {string} message
 * @param {string=} logMessage
 * @return {void}
 */
RootAppInstance.prototype.updateApp = function(message, logMessage) {};

/**
 * Stoppt diese App.
 * @param {string} message
 * @param {string=} logMessage
 * @return {void}
 */
RootAppInstance.prototype.stopApp = function(message, logMessage) {};
/**
 * @constructor
 * @struct
 */
function ServerInfo() {}

/**
 * Liefert die interne ServerId des Servers.
 * @return {string}
 */
ServerInfo.prototype.getServerId = function() {};

/**
 * Liefert die Code-Revision des Servers.
 * @return {number}
 */
ServerInfo.prototype.getRevision = function() {};
/**
 * @constructor
 * @struct
 */
function SingleDiceResult() {}

/**
 * Liefert den Würfel zurück, durch den dieses SingleDiceResult erzeugt wurde.
 * @return {!Dice}
 */
SingleDiceResult.prototype.getDice = function() {};

/**
 * Liefert die Ziffern, die gewürfelt wurden.
 * @return {!Array<number>}
 */
SingleDiceResult.prototype.valuesRolled = function() {};

/**
 * Liefert die Summe der Augenzahlen des SingleDiceResult.
 * @return {number}
 */
SingleDiceResult.prototype.sum = function() {};

/**
 * Die Methode liefert den <code>String</code> zurück, auf dem sie aufgerufen wurde mit KCode escaped.
 * @return {string}
 */
String.prototype.escapeKCode = function() {};

/**
 * Entfernt jeglichen KCode aus dem <code>String</code> und gibt ihn zurück.
 * @return {string}
 */
String.prototype.stripKCode = function() {};

/**
 * Diese Methode liefert die Information, ob der <code>String</code> auf dem die Methode aufgerufen wurde
 * mit einem bestimmten Prefix beginnt.
 * @param {string} prefix
 * @return {boolean}
 */
String.prototype.startsWith = function(prefix) {};

/**
 * Diese Methode liefert die Information, ob der <code>String</code> auf dem die Methode aufgerufen wurde
 * mit einem bestimmten Suffix endet.
 * @param {string} suffix
 * @return {boolean}
 */
String.prototype.endsWith = function(suffix) {};

/**
 * Liefert die Breite des Strings in der Schriftart Arial mit der gegeben Schriftgröße und Information, ob Text fett dargestellt werden soll.
 * @param {number} fontSize
 * @param {boolean} isBold
 * @return {number}
 */
String.prototype.getPixelWidth = function(fontSize, isBold) {};

/**
 * Liefert einen  <code>String</code>, der in der Schriftart Arial mit der gegeben Schriftgröße und Information, ob Text fett dargestellt werden soll
 * maximal <code>maxPixelWidth</code> breit ist. Wird der Text dafür gekürzt, so wird an das Ende <code>abbreviationMarker</code> angehangen.
 * Falls <code>abbreviationMarker</code> nicht übergeben wurde, so ist es automatisch '...'.
 * @param {number} fontSize
 * @param {boolean} isBold
 * @param {number} maxPixelWidth
 * @param {string=} abbreviationMarker
 * @return {string}
 */
String.prototype.limitString = function(fontSize, isBold, maxPixelWidth, abbreviationMarker) {};

/**
 * Liefert die Information, ob ein bestimmter <code>String</code> in diesem <code>String</code> vorhanden ist.
 * @param {string} needle
 * @return {boolean}
 */
String.prototype.contains = function(needle) {};

/**
 * Liefert die Levenshtein-Distanz zum übergebenen  <code>String</code>.
 * Levenshtein-Distanz: Minimale Anzahl von Einfüge-, Lösch- und Ersetz-Operationen, um die erste Zeichenkette in die zweite umzuwandeln.
 * \@since AppServer 82271
 * @param {string} otherString
 * @return {number}
 */
String.prototype.minimalConversionCost = function(otherString) {};

/**
 * Liefert die Information, ob der <code>String</code> nur aus Zeichen besteht, die in einem Nicknamen
 * vorkommen dürfen.
 * \@since AppServer 82271
 * @return {boolean}
 */
String.prototype.hasOnlyNicknameCharacters = function() {};

/**
 * Liefert die Information, ob der <code>String</code> nur aus Zeichen besteht, die Nummern sind.
 * \@since AppServer 82271
 * @return {boolean}
 */
String.prototype.hasOnlyDigits = function() {};

/**
 * Liefert die Information, ob der <code>String</code> nur aus Zeichen besteht, die alphanumerisch + Whitespaces sind.
 * \@since AppServer 82271
 * @return {boolean}
 */
String.prototype.hasOnlyAlphanumericalAndWhitespaceCharacters = function() {};

/**
 * Liefert die Information, ob der <code>String</code> leer oder <code>null</code> ist.
 * \@since AppServer 92695
 * @return {boolean}
 */
String.prototype.isEmpty = function() {};

/**
 * Liefert den <code>String</code> in CamelCase.
 * \@since AppServer 92695
 * @return {string}
 */
String.prototype.toCamelCase = function() {};

/**
 * Liefert den <code>String</code> mit dem ersten Buchstaben als Großbuchstaben.
 * \@since AppServer 92695
 * @return {string}
 */
String.prototype.capitalize = function() {};

/**
 * Erstellt eine Kopie des  <code>String</code>, in dem alle Vorkommnisse des  <code>String</code> <code>search</code> in <code>replacement</code>
 * ersetzt werden und liefert diesen zurück.
 * @param {(string|!RegExp)} search
 * @param {string} replacement
 * @return {string}
 */
String.prototype.replaceAll = function(search, replacement) {};

/**
 * Prüft primitiv, ob der <code>String</code> laut Knuddels-Filterregeln ok ist.
 * \@since ChatServer 82262, AppServer 82262
 * @return {boolean}
 */
String.prototype.isOk = function() {};
/**
 * @constructor
 * @struct
 */
function Toplist() {}

/**
 * Liefert den userPersistenceNumberKey mit dem die Topliste erzeugt wurde.
 * @return {string}
 */
Toplist.prototype.getUserPersistenceNumberKey = function() {};

/**
 * Liefert den Anzeigenamen der Topliste.
 * @return {string}
 */
Toplist.prototype.getDisplayName = function() {};

/**
 * Liefert den Befehl, der im Chat eingegeben werden kann, um diese Topliste zu öffnen.
 * Wird ein User oder eine userId übergeben, so öffnet sich die Topliste mit diesem Nutzer im Fokus.
 * @param {(number|!User)=} user_or_userId
 * @return {string}
 */
Toplist.prototype.getChatCommand = function(user_or_userId) {};

/**
 * Liefert den Anzeigenamen für den übergebenen User oder eine userId.
 * @param {(number|!User)} user_or_userId
 * @return {string}
 */
Toplist.prototype.getLabel = function(user_or_userId) {};

/**
 * Legt einen Change-Listener an, der jedes mal aufgerufen wird, wenn ein User
 * einen neuen Anzeigenamen erhält.
 * @param {function(!ToplistLabelChangeEvent): void} listener
 * @return {void}
 */
Toplist.prototype.addLabelChangeListener = function(listener) {};

/**
 * Löscht einen LabelChangeListener, der mit Toplist/addLabelChangeListener:method erzeugt wurde.
 * @param {function(!ToplistLabelChangeEvent): void} listener
 * @return {void}
 */
Toplist.prototype.removeLabelChangeListener = function(listener) {};

/**
 * Legt einen Change-Listener an, der jedes mal aufgerufen wird, wenn ein sich der Rang User eines Nutzers ändert.
 * @param {function(!ToplistRankChangeEvent): void} listener
 * @return {void}
 */
Toplist.prototype.addRankChangeListener = function(listener) {};

/**
 * Löscht einen RankChangeListener, der mit Toplist/addRankChangeListener:method erzeugt wurde.
 * @param {function(!ToplistRankChangeEvent): void} listener
 * @return {void}
 */
Toplist.prototype.removeRankChangeListener = function(listener) {};
/**
 * @constructor
 * @struct
 */
function ToplistAccess() {}

/**
 * Liefert die Liste aller Toplisten, die diese App erzeugt hat.
 * @return {!Array<!Toplist>}
 */
ToplistAccess.prototype.getAllToplists = function() {};

/**
 * Liefert die Toplist mit dem Persistenz-Key zurück.
 * @param {string} userPersistenceNumberKey
 * @return {!Toplist}
 */
ToplistAccess.prototype.getToplist = function(userPersistenceNumberKey) {};

/**
 * Löscht die übergebene Toplist oder die Toplist mit dem Persistenz-Key.
 * @param {!Toplist} toplist
 * @return {void}
 */
ToplistAccess.prototype.removeToplist = function(toplist) {};

/**
 * Erzeugt oder aktualisiert die Toplist für den übergebenen userPersistenceNumberKey.
 * @param {string} userPersistenceNumberKey
 * @param {string} displayName
 * @param {{labelMapping: !Object<string,string>, ascending: boolean}=} parameters
 * @return {!Toplist}
 */
ToplistAccess.prototype.createOrUpdateToplist = function(userPersistenceNumberKey, displayName, parameters) {};
/**
 * @constructor
 * @struct
 */
function ToplistDisplayType() {}
 /** @type {!ToplistDisplayType} */
ToplistDisplayType.Label;
 /** @type {!ToplistDisplayType} */
ToplistDisplayType.Value;
 /** @type {!ToplistDisplayType} */
ToplistDisplayType.LabelAndRank;
 /** @type {!ToplistDisplayType} */
ToplistDisplayType.ValueAndRank;
/**
 * @constructor
 * @struct
 */
function ToplistLabelChangeEvent() {}

/**
 * Liefert die zugehörige Toplist.
 * @return {!Toplist}
 */
ToplistLabelChangeEvent.prototype.getToplist = function() {};

/**
 * Liefert den vorherigen Anzeigenamen. Hatte der User vorher keinen
 * Anzeigenamen, so ist dieser Wert <code>null</code>.
 * @return {string}
 */
ToplistLabelChangeEvent.prototype.getOldLabel = function() {};

/**
 * Liefert den neuen Anzeigenamen. Hatte der User nun keinen
 * Anzeigenamen mehr, so ist dieser Wert <code>null</code>.
 * @return {string}
 */
ToplistLabelChangeEvent.prototype.getNewLabel = function() {};

/**
 * Liefert den User für den das Event ausgelöst wurde.
 * @return {!User}
 */
ToplistLabelChangeEvent.prototype.getUser = function() {};

/**
 * Liefert den Wert, der vor der Änderung gespeichert war.
 * @return {number}
 */
ToplistLabelChangeEvent.prototype.getOldValue = function() {};

/**
 * Liefert den neuen Wert.
 * @return {number}
 */
ToplistLabelChangeEvent.prototype.getNewValue = function() {};
/**
 * @constructor
 * @struct
 */
function ToplistRankChangeEvent() {}

/**
 * Liefert die zugehörige Toplist.
 * @return {!Toplist}
 */
ToplistRankChangeEvent.prototype.getToplist = function() {};

/**
 * Liefert den Toplisten-Rang, den der User vor der Änderung hatte.
 * @return {number}
 */
ToplistRankChangeEvent.prototype.getOldRank = function() {};

/**
 * Liefert den neuen Toplisten-Rang, des Users.
 * @return {number}
 */
ToplistRankChangeEvent.prototype.getNewRank = function() {};

/**
 * Liefert den User für den das Event ausgelöst wurde.
 * @return {!User}
 */
ToplistRankChangeEvent.prototype.getUser = function() {};

/**
 * Liefert die User, die bei dieser Änderung überholt worden sind.
 * <br><br><b style="color:red;">Achtung:</b> Wenn mehr als <b>10 User</b>
 * überholt wurden, so liefert die Methode die besten 10 überholten User.
 * @return {!Array<!User>}
 */
ToplistRankChangeEvent.prototype.getUsersOvertook = function() {};

/**
 * Liefert den Wert, der vor der Änderung gespeichert war.
 * @return {number}
 */
ToplistRankChangeEvent.prototype.getOldValue = function() {};

/**
 * Liefert den neuen Wert.
 * @return {number}
 */
ToplistRankChangeEvent.prototype.getNewValue = function() {};
/**
 * @constructor
 * @struct
 */
function User() {}

/**
 * Liefert die eindeutige Nutzerkennung des Nutzers.
 * @return {number}
 */
User.prototype.getUserId = function() {};

/**
 * Liefert den Nicknamen des Nutzers.
 * @return {string}
 */
User.prototype.getNick = function() {};

/**
 * Liefert das Alter des Nutzers. Bei Nutzern, die bereits sehr lange in der Plattform sind kann es vorkommen, dass kein Alter angegeben wurde. In diesem Fall ist das Alter <code>0</code>.
 * @return {number}
 */
User.prototype.getAge = function() {};

/**
 * Liefert das Geschlecht des Nutzers.
 * @return {!Gender}
 */
User.prototype.getGender = function() {};

/**
 * Liefert den Zeitpunkt der Registrierung des Nutzers.
 * @return {!Date}
 */
User.prototype.getRegDate = function() {};

/**
 * Liefert den UserStatus des Nutzers.
 * @return {!UserStatus}
 */
User.prototype.getUserStatus = function() {};

/**
 * Liefert den UserType des Nutzers.
 * @return {!UserType}
 */
User.prototype.getUserType = function() {};

/**
 * Liefert den aktuellen ClientType des Nutzers oder Offline wenn er nicht im Chat online ist.
 * @return {!ClientType}
 */
User.prototype.getClientType = function() {};

/**
 * Prüft ob der Client des Users den übergebenen AppViewMode (für User/sendAppContent:method) anzeigen kann.
 * @param {!AppViewMode} mode
 * @return {boolean}
 */
User.prototype.canShowAppViewMode = function(mode) {};

/**
 * Prüft ob der Client des User's den übergebenen AppContent anzeigen kann.
 * @param {!AppContent} appContent
 * @return {boolean}
 */
User.prototype.canSendAppContent = function(appContent) {};

/**
 * Prüft, ob der User in dem angegebenen Team ist.
 * Dies funktioniert derzeit nur für Teams, die eine eigene /fa haben.
 * 
 * <b style="color:red;">Achtung:</b> Bei Nutzern, die neu in ein Team kommen, funktioniert die Abfrage erst dann korrekt,
 * wenn er sich neu in den Channel eingeloggt hat.
 * @param {string} teamName
 * @param {string=} subTeamName
 * @return {boolean}
 */
User.prototype.isInTeam = function(teamName, subTeamName) {};

/**
 * Liefert ein UserPersistence-Objekt für diesen Nutzer. Mit diesem Objekt kann eine App sich Dinge über diesen speziellen Nutzer merken.
 * @return {!UserPersistence}
 */
User.prototype.getPersistence = function() {};

/**
 * Shortcut-Funktion um mit dem DefaultBotUser eine private Nachricht zu versenden.
 * @param {string} message
 * @return {void}
 */
User.prototype.sendPrivateMessage = function(message) {};

/**
 * Shortcut-Funktion um mit dem DefaultBotUser eine /m zu versenden.
 * @param {string} topic
 * @param {string} text
 * @return {void}
 */
User.prototype.sendPostMessage = function(topic, text) {};

/**
 * Liefert die Information, ob dieser Nutzer Channelbesitzer im Channel der App ist.
 * @return {boolean}
 */
User.prototype.isChannelOwner = function() {};

/**
 * Liefert die Information, ob der Channel der App
 *  ein Lieblingschannel des Nutzers ist.
 * @return {boolean}
 */
User.prototype.isLikingChannel = function() {};

/**
 * Liefert die Information, ob der Nutzer im harten Kern des Channels der App ist.
 * \@since AppServer 92701, ChatServer 92701
 * @return {boolean}
 */
User.prototype.isChannelCoreUser = function() {};

/**
 * Liefert die Information, ob dieser Nutzer ein AppManager für diese App ist. Die Channelbesitzer zählen automatisch auch als AppManager.
 * @return {boolean}
 */
User.prototype.isAppManager = function() {};

/**
 * Liefert Information, ob dieser Nutzer derzeit für das Schreiben öffentlicher Nachrichten im Channel gesperrt ist.
 * @return {boolean}
 */
User.prototype.isMuted = function() {};

/**
 * Liefert Information, ob dieser Nutzer beim Schreiben öffentlicher Nachrichten im Channel
 * derzeit für die Verwendung von Textformatierungen, Farben und Smileys gesperrt ist.
 * @return {boolean}
 */
User.prototype.isColorMuted = function() {};

/**
 * Liefert Information, ob dieser Nutzer derzeit für das Betreten des Channel gesperrt ist.
 * @return {boolean}
 */
User.prototype.isLocked = function() {};

/**
 * Liefert Information, ob dieser Nutzer Channelmoderator im Channel der App ist.
 * @return {boolean}
 */
User.prototype.isChannelModerator = function() {};

/**
 * Liefert Information, ob dieser Nutzer Eventmoderator im Channel der App ist.
 * @return {boolean}
 */
User.prototype.isEventModerator = function() {};

/**
 * Liefert Information, ob dieser Nutzers der Entwickler der App ist.
 * @return {boolean}
 */
User.prototype.isAppDeveloper = function() {};

/**
 * Liefert einen Link zum Profil des Nutzers, den man im Chat anzeigen kann.
 * @param {string=} displayText
 * @return {string}
 */
User.prototype.getProfileLink = function(displayText) {};

/**
 * Liefert die Information, ob der Nutzer online im Channel der App ist.
 * @return {boolean}
 */
User.prototype.isOnlineInChannel = function() {};

/**
 * Liefert die Anzahl der Knuddel, die der Nutzer besitzt.
 * @return {!KnuddelAmount}
 */
User.prototype.getKnuddelAmount = function() {};

/**
 * Liefert die Information, ob der Nutzer irgendwo im Chat online ist.
 * @return {boolean}
 */
User.prototype.isOnline = function() {};

/**
 * Liefert die Readme des Nutzers, die er mit /readme TEXT in sein Profil gesetzt hat.
 * @return {string}
 */
User.prototype.getReadme = function() {};

/**
 * Liefert die vom Nutzer verbrachte Zeit im gesamten Chatsystem In Minuten.
 * <b>Hinweis:</b> Die Minutenzahl wird derzeit immer nur zu dem Zeitpunkt aktualisiert,
 * wenn der Nutzer offline geht.
 * @return {number}
 */
User.prototype.getOnlineMinutes = function() {};

/**
 * Liefert die Information, ob der Nutzer sich mittels /away-Funktion kurz abgemeldet hat.
 * @return {boolean}
 */
User.prototype.isAway = function() {};

/**
 * Liefert die Information, ob der Nutzer ein Profilfoto hat.
 * @return {boolean}
 */
User.prototype.hasProfilePhoto = function() {};

/**
 * (Er)setzt den übergebenen AppContent beim Nutzer.
 * @param {!AppContent} appContent
 * @return {!AppContentSession}
 */
User.prototype.sendAppContent = function(appContent) {};

/**
 * Liefert alle AppContentSession, die der User
 * aktuell geöffnet hat.
 * @return {!Array<!AppContentSession>}
 */
User.prototype.getAppContentSessions = function() {};

/**
 * Liefert die AppContentSession, die der User
 * mit einem bestimmten AppViewMode aktuell geöffnet hat.
 * @param {!AppViewMode} appViewMode
 * @return {!AppContentSession}
 */
User.prototype.getAppContentSession = function(appViewMode) {};

/**
 * Vergleicht den übergebenen Nutzer und liefert <code>true</code>, falls der übergebene Nutzer
 * identisch ist mit dem aktuellen Nutzer.
 * @param {!User} user
 * @return {boolean}
 */
User.prototype.equals = function(user) {};

/**
 * Liefert die URL zum Profilfoto des Nutzers. Die übergebene Breite und Höhe
 * liefern dem Server einen Anhaltswert, um das bestmögliche Foto zu finden,
 * sind aber keine Garantie, dass das Foto diese Ausmaße haben wird.
 * @param {number} width
 * @param {number} height
 * @return {string}
 */
User.prototype.getProfilePhoto = function(width, height) {};

/**
 * Liefert das QuestAccess-Objekt
 * für diesen Nutzer in dieser App.
 * \@since AppServer 82290, ChatServer 82290
 * @return {!QuestAccess}
 */
User.prototype.getQuestAccess = function() {};

/**
 * Liefert die Information, ob der Nutzer gerade sein Video streamt.
 * @return {boolean}
 */
User.prototype.isStreamingVideo = function() {};

/**
 * Liefert den KnuddelAccount des Nutzers.
 * @return {!KnuddelAccount}
 */
User.prototype.getKnuddelAccount = function() {};

/**
 * Liefert die ChannelTalkPermission für diesen Nutzer in diesem
 * Channel.
 * @return {!ChannelTalkPermission}
 */
User.prototype.getChannelTalkPermission = function() {};

/**
 * Liefert die Information, ob der User ein verifiziertes Profilbild hat.
 * @return {boolean}
 */
User.prototype.isProfilePhotoVerified = function() {};

/**
 * Liefert die Information, ob das Alter des Users verifiziert ist.
 * @return {boolean}
 */
User.prototype.isAgeVerified = function() {};

/**
 * Setzt dem Nutzer ein Icon in die Nickliste, das auf der rechten Seite seines Nicks angezeigt wird.
 * Der Eintrag wird automatisch entfernt, sobald der Nutzer den Channel verlässt,
 * kann aber auch mit User/removeNicklistIcon:method
 * entfernt werden.
 * @param {string} imagePath
 * @param {number} imageWidth
 * @return {void}
 */
User.prototype.addNicklistIcon = function(imagePath, imageWidth) {};

/**
 * Entfernt dem Nutzer ein über die API gesetztes Icon in die Nickliste.
 * @param {string} imagePath
 * @return {void}
 */
User.prototype.removeNicklistIcon = function(imagePath) {};

/**
 * Startet einen Würfelwurf für den Nutzer, falls er online im Channel ist und er nicht gemuted ist.
 * \@since AppServer 89159, ChatServer 89159
 * @param {!DiceConfiguration} diceConfiguration
 * @return {void}
 */
User.prototype.triggerDice = function(diceConfiguration) {};
/**
 * @constructor
 * @struct
 */
function UserAccess() {}

/**
 * Liefert die userId des Nutzers mit dem übergebenen Nicknamen.
 * @param {string} nick
 * @return {number}
 */
UserAccess.prototype.getUserId = function(nick) {};

/**
 * Informiert darüber, ob ein Nutzer mit dem übergebenen Nicknamen existiert.
 * @param {string} nick
 * @return {boolean}
 */
UserAccess.prototype.exists = function(nick) {};

/**
 * Informiert darüber, ob der Nutzer mit der übergebenen userId geladen werden darf. Neben dem AppDeveloper können nur Nutzer geladen werden, die sich einmal im Channel befanden, als die App
 * lief.
 * @param {number} userId
 * @return {boolean}
 */
UserAccess.prototype.mayAccess = function(userId) {};

/**
 * Liefert den Nutzer mit der übergebenen userId. Neben dem AppDeveloper können nur Nutzer geladen werden, die sich einmal im Channel befanden, als die App lief. Es wird empfohlen vor der
 * Abfrage von <code>getUserById(userId)</code> mit UserAccess/mayAccess:method abzufragen, ob dies funktionieren wird.
 * @param {number} userId
 * @return {!User}
 */
UserAccess.prototype.getUserById = function(userId) {};

/**
 * Liefert den Nicknamen des Nutzers mit der übergebenen userId in der korrekten Schreibweise.
 * @param {number} userId
 * @return {string}
 */
UserAccess.prototype.getNick = function(userId) {};

/**
 * Loopt über alle zugreifbaren User sortiert nach Registrierzeitpunkt und
 * führt für jeden User das übergebene Callback aus.
 * @param {function(!User, number, number, string): boolean} callback
 * @param {{onStart: function(number, string): void, onEnd: function(number, string): void}=} parameters
 * @return {void}
 */
UserAccess.prototype.eachAccessibleUser = function(callback, parameters) {};
/**
 * @extends {Persistence}
 * @constructor
 * @struct
 */
function UserPersistence() {}

/**
 * Löscht alle Zahlenwerte, die in dieser UserPersistence gespeichert sind.
 * \@since AppServer 88569
 * @return {number}
 */
UserPersistence.prototype.deleteAllNumbers = function() {};

/**
 * Löscht alle Objekte, die in dieser UserPersistence gespeichert sind.
 * \@since AppServer 88569
 * @return {number}
 */
UserPersistence.prototype.deleteAllObjects = function() {};

/**
 * Löscht alle Zeichenketten, die in dieser UserPersistence gespeichert sind.
 * \@since AppServer 88569
 * @return {number}
 */
UserPersistence.prototype.deleteAllStrings = function() {};

/**
 * Löscht alle Daten, die in dieser UserPersistence gespeichert sind.
 * \@since AppServer 88569
 * @return {number}
 */
UserPersistence.prototype.deleteAll = function() {};
/**
 * @constructor
 * @struct
 */
function UserPersistenceNumberEntry() {}

/**
 * Liefert den Nutzer.
 * @return {!User}
 */
UserPersistenceNumberEntry.prototype.getUser = function() {};

/**
 * Liefert den Wert.
 * @return {number}
 */
UserPersistenceNumberEntry.prototype.getValue = function() {};

/**
 * Liefert den Rang des Elements in der Persistenz.
 * @return {number}
 */
UserPersistenceNumberEntry.prototype.getRank = function() {};

/**
 * Liefert die Position des Elements in der Persistenz.
 * @return {number}
 */
UserPersistenceNumberEntry.prototype.getPosition = function() {};
/**
 * @constructor
 * @struct
 */
function UserPersistenceNumbers() {}

/**
 * Liefert die Summe aller via <code>UserPersistence</code> gespeicherten Zahlen für den übergebenen <code>key</code>.
 * @param {string} key
 * @return {number}
 */
UserPersistenceNumbers.getSum = function(key) {};

/**
 * Löscht alle gespeicherten Zahlen-Werte für den übergebenen <code>key</code>.
 * @param {string} key
 * @return {number}
 */
UserPersistenceNumbers.deleteAll = function(key) {};

/**
 * Liefert die Anzahl aller unterschiedlichen Nutzer, die Werte für einen bestimmten <code>key</code> gespeichert haben.
 * Hierbei kann optional der Wertebereich über die <code>parameters</code> eingegrenzt werden.
 * @param {string} key
 * @param {{minimumValue: number, maximumValue: number}=} parameters
 * @return {number}
 */
UserPersistenceNumbers.getCount = function(key, parameters) {};

/**
 * Ändert einen bestimmten <code>key</code> bei allen UserPersistence.
 * @param {string} oldKeyName
 * @param {string} newKeyName
 * @return {number}
 */
UserPersistenceNumbers.updateKey = function(oldKeyName, newKeyName) {};

/**
 * Ändert alle Werte für einen bestimmten <code>key</code>, die vorher einen bestimmten anderen Wert hatten in der UserPersistence.
 * <br /><strong>Hinweis:</strong> Da diese Methode ein Batch-Update ist werden keine Change-Listener (ToplistRankChangeEvent, ToplistLabelChangeEvent) ausgelöst.
 * @param {string} key
 * @param {number} oldValue
 * @param {number} newValue
 * @return {number}
 */
UserPersistenceNumbers.updateValue = function(key, oldValue, newValue) {};

/**
 * Addiert einen Wert für Einträge mit einem bestimmten <code>key</code> in der UserPersistence.
 * <br /><strong>Hinweis:</strong> Da diese Methode ein Batch-Update ist werden keine Change-Listener (ToplistRankChangeEvent, ToplistLabelChangeEvent) ausgelöst.
 * @param {string} key
 * @param {number} value
 * @param {{minimumValue: number, maximumValue: number, targetUsers: !Array<!User>}=} parameters
 * @return {number}
 */
UserPersistenceNumbers.addNumber = function(key, value, parameters) {};

/**
 * Liefert ein Array mit <code>UserPersistenceNumberEntry</code>-Objekten für einen bestimmten <code>key</code>.
 * Hierdurch kann beispielsweise eine blätterbare Topliste abgebildet werden.
 * @param {string} key
 * @param {{ascending: boolean, count: number, page: number, minimumValue: number, maximumValue: number}=} parameters
 * @return {!Array<!UserPersistenceNumberEntry>}
 */
UserPersistenceNumbers.getSortedEntries = function(key, parameters) {};

/**
 * Liefert ein Array mit <code>UserPersistenceNumberEntry</code>-Objekten für einen bestimmten <code>key</code>. Hierbei werden die nähesten Elemente gewählt,
 * die am übergebenen User/UserId liegen.
 * 
 * Beispiel: Der Nutzer ist in der Liste auf Position 20, dann werden die Resultate von 14-24 bei einem Count von 10 ausgegeben.
 * Beispiel: Der Nutzer ist in der Liste auf Position 3, dann werden die Resultate von 1-10 bei einem Count von 10 ausgegeben.
 * @param {string} key
 * @param {(number|!User)} user_or_userId
 * @param {{ascending: boolean, count: number}=} parameters
 * @return {!Array<!UserPersistenceNumberEntry>}
 */
UserPersistenceNumbers.getSortedEntriesAdjacent = function(key, user_or_userId, parameters) {};

/**
 * Liefert die absolute Position des Nutzers in der Liste. Die Position ist im Gegensatz zum Rang immer eindeutig.
 * 
 * Bei gleichem Wert hat der Nutzer die höhere Position, der zuerst einen Eintrag in der Persistenz hatte.
 * 
 * Mit der Methode UserPersistenceNumbers/getRank:method kann man den Rang des Nutzers herausfinden. Dieser ist identisch, wenn
 * unterschiedliche Nutzer denselben Wert haben.
 * @param {string} key
 * @param {(number|!User)} user_or_userId
 * @param {{ascending: boolean, minimumValue: number}=} parameters
 * @return {number}
 */
UserPersistenceNumbers.getPosition = function(key, user_or_userId, parameters) {};

/**
 * Liefert den Rang des Nutzers. Der Rang ist nicht eindeutig. Bei gleicher Punktzahl haben Nutzer denselben Rang.
 * Mit der Methode UserPersistenceNumbers/getPosition:method kann man die Position eindeutige Position, statt des Ranges herausfinden.
 * @param {string} key
 * @param {(number|!User)} user_or_userId
 * @param {{ascending: boolean, minimumValue: number}=} parameters
 * @return {number}
 */
UserPersistenceNumbers.getRank = function(key, user_or_userId, parameters) {};

/**
 * Ruft eine Funktion für alle Nutzer auf, die einen bestimmten <code>key</code> in der <code>UserPersistence</code> gesetzt haben.
 * Hierbei greifen die übergebenen Filter.
 * @param {string} key
 * @param {{user: !User, value: number, index: number, totalCount: number, key: string}} callback
 * @param {{ascending: boolean, minimumValue: number, maximumValue: number, maximumCount: number, onStart: function(number, string): void, onEnd: function(number, string): void}=} parameters
 * @return {void}
 */
UserPersistenceNumbers.each = function(key, callback, parameters) {};

/**
 * Liefert alle keys, die für User in der Persistence
 * gespeichert wurden.
 * \@since AppServer 82483
 * @param {string=} filterKey
 * @return {!Array<string>}
 */
UserPersistenceNumbers.getAllKeys = function(filterKey) {};
/**
 * @constructor
 * @struct
 */
function UserPersistenceObjects() {}

/**
 * Löscht alle gespeicherten Objekte für den übergebenen <code>key</code>.
 * \@since AppServer 82478
 * @param {string} key
 * @return {number}
 */
UserPersistenceObjects.deleteAll = function(key) {};

/**
 * Liefert alle keys, die für User in der Persistence
 * gespeichert wurden.
 * \@since AppServer 82483
 * @param {string=} filterKey
 * @return {!Array<string>}
 */
UserPersistenceObjects.getAllKeys = function(filterKey) {};
/**
 * @constructor
 * @struct
 */
function UserPersistenceStrings() {}

/**
 * Liefert die Information, ob für einen bestimmten key und value bei einem beliebigen Nutzer eine Paarung existiert.
 * \@since AppServer 88571
 * @param {string} key
 * @param {string} value
 * @param {boolean=} ignoreCase
 * @return {boolean}
 */
UserPersistenceStrings.exists = function(key, value, ignoreCase) {};

/**
 * Löscht alle gespeicherten Strings für den übergebenen <code>key</code>.
 * \@since AppServer 82478
 * @param {string} key
 * @return {number}
 */
UserPersistenceStrings.deleteAll = function(key) {};

/**
 * Liefert alle keys, die für User in der Persistence
 * gespeichert wurden.
 * \@since AppServer 82483
 * @param {string=} filterKey
 * @return {!Array<string>}
 */
UserPersistenceStrings.getAllKeys = function(filterKey) {};
/**
 * @constructor
 * @struct
 */
function UserStatus() {}
 /** @type {!UserStatus} */
UserStatus.Newbie;
 /** @type {!UserStatus} */
UserStatus.Family;
 /** @type {!UserStatus} */
UserStatus.Stammi;
 /** @type {!UserStatus} */
UserStatus.HonoryMember;
 /** @type {!UserStatus} */
UserStatus.Admin;
 /** @type {!UserStatus} */
UserStatus.SystemBot;
 /** @type {!UserStatus} */
UserStatus.Sysadmin;

/**
 * Liefert den numerischen Wert das UserStatus.
 * @return {number}
 */
UserStatus.prototype.getNumericStatus = function() {};

/**
 * Liefert die Information ob der aktuelle UserStatus mindestens so hoch ist, wie der übergebene UserStatus.
 * @param {!UserStatus} otherUserStatus
 * @return {boolean}
 */
UserStatus.prototype.isAtLeast = function(otherUserStatus) {};
/**
 * @constructor
 * @struct
 */
function UserType() {}
 /** @type {!UserType} */
UserType.AppBot;
 /** @type {!UserType} */
UserType.SystemBot;
 /** @type {!UserType} */
UserType.Human;
/**
 * @constructor
 * @struct
 */
function VideoChannelData() {}

/**
 * Liefert alle User die im Channel derzeit ihr Video streamen.
 * @return {!Array<!User>}
 */
VideoChannelData.prototype.getStreamingVideoUsers = function() {};
