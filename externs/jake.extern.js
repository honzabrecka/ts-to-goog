/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/jake/index.d.ts:

/**
 * Complets an asynchronous task, allowing Jake's execution to proceed to the next task
 * @param {?=} value A value to return from the task.
 * @return {void}
 */
function complete(value) {}

/**
 * Creates a description for a Jake Task (or FileTask, DirectoryTask). When invoked, the description that iscreated will be associated with whatever Task is created next.
 * @param {string} description The description for the Task
 * @return {void}
 */
function desc(description) {}

/**
 * Creates a Jake DirectoryTask. Can be used as a prerequisite for FileTasks, or for simply ensuring a directory exists for use with a Task's action.
 * @param {string} name The name of the DiretoryTask
 * @return {!jake.DirectoryTask}
 */
function directory(name) {}

/**
 * Causes Jake execution to abort with an error. Allows passing an optional error code, which will be used to set the exit-code of exiting process.
 * @param {...string|!Error|?} err The error to thow when aborting execution. If this argument is an Error object, it will simply be thrown. If a String, it will be used as the error-message. (If it is a multi-line String, the first line will be used as the Error message, and the remaining lines will be used as the error-stack.)
 * @return {void}
 */
function fail(err) {}

/**
 * Creates a Jake FileTask.
 * \@name name The name of the Task
 * @param {string} name
 * @param {!Array<string>=} prereqs Prerequisites to be run before this task
 * @param {function(): void=} action The action to perform for this task
 * @param {!jake.FileTaskOptions=} opts Perform this task asynchronously. If you flag a task with this option, you must call the global `complete` method inside the task's action, for execution to proceed to the next task.
 * @return {!jake.FileTask}
 */
function file(name, prereqs, action, opts) {}

/**
 * Creates Jake FileTask from regex patterns
 * \@name name/pattern of the Task
 * @param {!RegExp} pattern
 * @param {(string|function(string): string)} source calculated from the name pattern
 * @param {!Array<string>=} prereqs Prerequisites to be run before this task
 * @param {function(): void=} action The action to perform for this task
 * @param {!jake.TaskOptions=} opts Perform this task asynchronously. If you flag a task with this option, you must call the global `complete` method inside the task's action, for execution to proceed to the next task.
 * @return {void}
 */
function rule(pattern, source, prereqs, action, opts) {}

/**
 * Creates a namespace which allows logical grouping of tasks, and prevents name-collisions with task-names. Namespaces can be nested inside of other namespaces.
 * @param {string} name The name of the namespace
 * @param {function(): void} scope The enclosing scope for the namespaced tasks
 * @return {void}
 */
function namespace(name, scope) {}

/**
 * @param {string} name The name of the Task
 * @param {!Array<string>|function(!Array<?>): ?|!jake.TaskOptions=} prereqs_or_action_or_opts Prerequisites to be run before this task
 * @param {function(!Array<?>): ?|!jake.TaskOptions=} action_or_opts The action to perform for this task
 * @param {!jake.TaskOptions=} opts
 * @return {!jake.Task}
 */
function task(name, prereqs_or_action_or_opts, action_or_opts, opts) {}

/**
 * @param {string} name The name of the NpmPublishTask
 * @param {!Array<string>|function(): void=} packageFiles_or_definition The files to include in the package
 * @return {!jake.NpmPublishTask}
 */
function npmPublishTask(name, packageFiles_or_definition) {}
/** @const */
var jake = {};
/**
 * @record
 * @struct
 */
jake.UtilOptions = function() {};
 /** @type {boolean} */
jake.UtilOptions.prototype.silent;

/**
 * The jake.mkdirP utility recursively creates a set of nested directories. It will not throw an error if any of the directories already exists.
 * https://github.com/substack/node-mkdirp
 * @param {string} name
 * @param {string|function(!Error, ?): void=} mode_or_f
 * @param {function(!Error, ?): void=} f
 * @return {void}
 */
jake.mkdirP = function(name, mode_or_f, f) {};

/**
 * The jake.cpR utility does a recursive copy of a file or directory.
 * Note that this command can only copy files and directories; it does not perform globbing (so arguments like '*.txt' are not possible).
 * @param {string} path the file/directory to copy,
 * @param {string} destination the destination.
 * @param {!jake.UtilOptions|function(!Error): void=} opts_or_callback
 * @param {function(): void=} callback
 * @return {void}
 */
jake.cpR = function(path, destination, opts_or_callback, callback) {};

/**
 * The jake.readdirR utility gives you a recursive directory listing, giving you output somewhat similar to the Unix find command. It only works with a directory name, and does not perform filtering or globbing.
 * @param {string} name
 * @param {!jake.UtilOptions=} opts
 * @return {!Array<string>} an array of filepaths for all files in the 'pkg' directory, and all its subdirectories.
 */
jake.readdirR = function(name, opts) {};

/**
 * The jake.rmRf utility recursively removes a directory and all its contents.
 * @param {string} name
 * @param {!jake.UtilOptions=} opts
 * @return {void}
 */
jake.rmRf = function(name, opts) {};
/**
 * @record
 * @struct
 */
jake.ExecOptions = function() {};
 /** @type {boolean} */
jake.ExecOptions.prototype.printStdout;
 /** @type {boolean} */
jake.ExecOptions.prototype.printStderr;
 /** @type {boolean} */
jake.ExecOptions.prototype.breakOnError;
 /** @type {boolean} */
jake.ExecOptions.prototype.windowsVerbatimArguments;

/**
 * @param {!Array<string>} cmds
 * @param {function(): void=} callback
 * @param {!jake.ExecOptions=} opts
 * @return {void}
 */
jake.exec = function(cmds, callback, opts) {};
/**
 * @record
 * @struct
 */
jake.Exec = function() {};

/**
 * @param {string} cmd
 * @return {void}
 */
jake.Exec.prototype.append = function(cmd) {};

/**
 * @return {void}
 */
jake.Exec.prototype.run = function() {};

/**
 * @param {!Array<string>|string} cmds
 * @param {function(): void|!jake.ExecOptions=} callback_or_opts
 * @param {!jake.ExecOptions|function(): void=} opts_or_callback
 * @return {!jake.Exec}
 */
jake.createExec = function(cmds, callback_or_opts, opts_or_callback) {};
/**
 * @record
 * @struct
 */
jake.Logger = function() {};

/**
 * @param {?} value
 * @return {void}
 */
jake.Logger.prototype.log = function(value) {};

/**
 * @param {?} value
 * @return {void}
 */
jake.Logger.prototype.error = function(value) {};
 /** @type {!jake.Logger} */
jake.logger;
 /** @type {{opts: ?, taskNames: !Array<string>, taskArgs: !Array<string>, envVars: !Object<string,string>}} */
jake.program;
/**
 * @record
 * @struct
 */
jake.TaskOptions = function() {};
 /** @type {boolean} */
jake.TaskOptions.prototype.async;
 /** @type {number} */
jake.TaskOptions.prototype.parallelLimit;

/**
 * @constructor
 * @struct
 * \@name name The name of the Task
 * @param {string} name
 * @param {!Array<string>=} prereqs Prerequisites to be run before this task
 * @param {function(): void=} action The action to perform for this task
 * @param {!jake.TaskOptions=} opts Perform this task asynchronously. If you flag a task with this option, you must call the global `complete` method inside the task's action, for execution to proceed to the next task.
 */
jake.Task = function(name, prereqs, action, opts) {};
 /** @type {?} */
jake.Task.prototype.value;
 /** @type {string} */
jake.Task.prototype.name;
 /** @type {!Array<string>} */
jake.Task.prototype.prereqs;
 /** @type {function(!Array<?>): ?} */
jake.Task.prototype.action;
 /** @type {string} */
jake.Task.prototype.taskStatus;
 /** @type {boolean} */
jake.Task.prototype.async;
 /** @type {string} */
jake.Task.prototype.description;
 /** @type {string} */
jake.Task.prototype.fullName;

/**
 * Runs prerequisites, then this task. If the task has already been run, will not run the task again.
 * @return {void}
 */
jake.Task.prototype.invoke = function() {};

/**
 * Runs this task, without running any prerequisites. If the task has already been run, it will still run it again.
 * @return {void}
 */
jake.Task.prototype.reenable = function() {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Task}
 */
jake.Task.prototype.addListener = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Task}
 */
jake.Task.prototype.on = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Task}
 */
jake.Task.prototype.once = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {Task}
 */
jake.Task.prototype.removeListener = function(event, listener) {};

/**
 * @param {string=} event
 * @return {Task}
 */
jake.Task.prototype.removeAllListeners = function(event) {};

/**
 * @param {number} n
 * @return {Task}
 */
jake.Task.prototype.setMaxListeners = function(n) {};

/**
 * @return {number}
 */
jake.Task.prototype.getMaxListeners = function() {};

/**
 * @param {string} event
 * @return {!Array<!Function>}
 */
jake.Task.prototype.listeners = function(event) {};

/**
 * @param {string} event
 * @param {...?} args
 * @return {boolean}
 */
jake.Task.prototype.emit = function(event, args) {};

/**
 * @param {string} type
 * @return {number}
 */
jake.Task.prototype.listenerCount = function(type) {};

/**
 * @param {?=} value
 * @return {void}
 */
jake.Task.prototype.complete = function(value) {};

/**
 * @constructor
 * @struct
 * @param {string} name The name of the directory to create.
 */
jake.DirectoryTask = function(name) {};
/**
 * @record
 * @struct
 */
jake.FileTaskOptions = function() {};
 /** @type {boolean} */
jake.FileTaskOptions.prototype.async;

/**
 * @constructor
 * @struct
 * @param {string} name The name of the Task
 * @param {!Array<string>=} prereqs Prerequisites to be run before this task
 * @param {function(): void=} action The action to perform to create this file
 * @param {!jake.FileTaskOptions=} opts Perform this task asynchronously. If you flag a task with this option, you must call the global `complete` method inside the task's action, for execution to proceed to the next task.
 */
jake.FileTask = function(name, prereqs, action, opts) {};
/**
 * @record
 * @struct
 */
jake.FileFilter = function() {};

/* TODO: CallSignature: jake */

/**
 * @constructor
 * @struct
 */
jake.FileList = function() {};

/**
 * Includes file-patterns in the FileList. Should be called with one or more
 * pattern for finding file to include in the list. Arguments should be strings
 * for either a glob-pattern or a specific file-name, or an array of them
 * @param {...!Array<string>|string} files
 * @return {void}
 */
jake.FileList.prototype.include = function(files) {};

/**
 * Indicates whether a particular file would be filtered out by the current
 * exclusion rules for this FileList.
 * @param {string} name The filename to check
 * @return {boolean} Whether or not the file should be excluded
 */
jake.FileList.prototype.shouldExclude = function(name) {};

/**
 * Excludes file-patterns from the FileList. Should be called with one or more
 * pattern for finding file to include in the list. Arguments can be:
 * 1. Strings for either a glob-pattern or a specific file-name
 * 2. Regular expression literals
 * 3. Functions to be run on the filename that return a true/false
 * @param {...!Array<string>|string|!Array<!RegExp>|!RegExp|!Array<!jake.FileFilter>|!jake.FileFilter} file
 * @return {void}
 */
jake.FileList.prototype.exclude = function(file) {};

/**
 * Populates the FileList from the include/exclude rules with a list of
 * actual files
 * @return {void}
 */
jake.FileList.prototype.resolve = function() {};

/**
 * Convert to a plain-jane array
 * @return {!Array<string>}
 */
jake.FileList.prototype.toArray = function() {};

/**
 * Get rid of any current exclusion rules
 * @return {void}
 */
jake.FileList.prototype.clearExclude = function() {};

/**
 * @constructor
 * @struct
 * Instantiating a PackageTask creates a number of Jake Tasks that make packaging and distributing your software easy.
 * @param {string} name The name of the project
 * @param {string} version The current project version (will be appended to the project-name in the package-archive
 * @param {function(): void} definition Defines the contents of the package, and format of the package-archive. Will be executed on the instantiated PackageTask (i.e., 'this', will be the PackageTask instance), to set the various instance-propertiess.
 */
jake.PackageTask = function(name, version, definition) {};
 /** @type {string} */
jake.PackageTask.prototype.archiveChangeDir;
 /** @type {string} */
jake.PackageTask.prototype.archiveContentDir;
 /** @type {string} */
jake.PackageTask.prototype.jarCommand;
 /** @type {string} */
jake.PackageTask.prototype.manifestFile;
 /** @type {string} */
jake.PackageTask.prototype.name;
 /** @type {boolean} */
jake.PackageTask.prototype.needJar;
 /** @type {boolean} */
jake.PackageTask.prototype.needTar;
 /** @type {boolean} */
jake.PackageTask.prototype.needTarBz2;
 /** @type {boolean} */
jake.PackageTask.prototype.needZip;
 /** @type {!jake.FileList} */
jake.PackageTask.prototype.packageFiles;
 /** @type {string} */
jake.PackageTask.prototype.tarCommand;
 /** @type {string} */
jake.PackageTask.prototype.version;
 /** @type {string} */
jake.PackageTask.prototype.zipCommand;

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {function(): void=} definition
 */
jake.TestTask = function(name, definition) {};

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {!Array<string>|function(): void=} packageFiles_or_definition
 */
jake.NpmPublishTask = function(name, packageFiles_or_definition) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {!NodeJS.EventEmitter}
 */
jake.addListener = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {!NodeJS.EventEmitter}
 */
jake.on = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {!NodeJS.EventEmitter}
 */
jake.once = function(event, listener) {};

/**
 * @param {string} event
 * @param {!Function} listener
 * @return {!NodeJS.EventEmitter}
 */
jake.removeListener = function(event, listener) {};

/**
 * @param {string} event
 * @return {!NodeJS.EventEmitter}
 */
jake.removeAllListener = function(event) {};

/**
 * @param {number} n
 * @return {void}
 */
jake.setMaxListeners = function(n) {};

/**
 * @param {string} event
 * @return {!Array<!Function>}
 */
jake.listeners = function(event) {};

/**
 * @param {string} event
 * @param {...?} args
 * @return {boolean}
 */
jake.emit = function(event, args) {};
