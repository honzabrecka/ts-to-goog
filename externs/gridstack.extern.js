/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/gridstack/index.d.ts:
/**
 * @record
 * @struct
 */
function JQuery() {}

/**
 * @param {!IGridstackOptions} options
 * @return {!JQuery}
 */
JQuery.prototype.gridstack = function(options) {};

/**
 * @param {string} key
 * @return {!GridStack}
 */
JQuery.prototype.data = function(key) {};
/**
 * @record
 * @struct
 */
function GridStack() {}

/**
 * Creates new widget and returns it.
 * 
 *   Widget will be always placed even if result height is more than actual grid height. You need to use willItFit method before calling addWidget for additional check.
 * 
 * @param {(string|!JQuery|!HTMLElement)} el
 * @param {number=} x
 * @param {number=} y
 * @param {number=} width
 * @param {number=} height
 * @param {boolean=} autoPosition
 * @param {number=} minWidth
 * @param {number=} maxWidth
 * @param {number=} minHeight
 * @param {number=} maxHeight
 * @param {number=} id
 * @return {!JQuery}
 */
GridStack.prototype.addWidget = function(el, x, y, width, height, autoPosition, minWidth, maxWidth, minHeight, maxHeight, id) {};

/**
 * Initializes batch updates. You will see no changes until commit method is called.
 * @return {void}
 */
GridStack.prototype.batchUpdate = function() {};

/**
 * Gets current cell height.
 * Update current cell height. This method rebuilds an internal CSS style sheet. Note: You can expect performance issues if call this method too often.
 * @param {number=} val
 * @return {number|void}
 */
GridStack.prototype.cellHeight = function(val) {};

/**
 * Gets current cell width.
 * @return {number}
 */
GridStack.prototype.cellWidth = function() {};

/**
 * Finishes batch updates. Updates DOM nodes. You must call it after batchUpdate.
 * @return {void}
 */
GridStack.prototype.commit = function() {};

/**
 * Destroys a grid instance.
 * @param {boolean=} detachGrid
 * @return {void}
 */
GridStack.prototype.destroy = function(detachGrid) {};

/**
 * @return {void}
 */
GridStack.prototype.disable = function() {};

/**
 * @return {void}
 */
GridStack.prototype.enable = function() {};

/**
 * Enables/disables widget moving.
 * This is a shortcut for:
 * grid.movable(this.container.children('.' + this.opts.itemClass), doEnable);
 * @param {boolean} doEnable
 * @param {boolean} includeNewWidgets
 * @return {void}
 */
GridStack.prototype.enableMove = function(doEnable, includeNewWidgets) {};

/**
 * Enables/disables widget resizing.
 * @param {boolean} doEnable
 * @param {boolean} includeNewWidgets
 * @return {void}
 */
GridStack.prototype.enableResize = function(doEnable, includeNewWidgets) {};

/**
 * Get the position of the cell under a pixel on screen.
 * @param {!MousePosition} position
 * @param {boolean=} useOffset
 * @return {!CellPosition}
 */
GridStack.prototype.getCellFromPixel = function(position, useOffset) {};

/**
 * Checks if specified area is empty.
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @return {void}
 */
GridStack.prototype.isAreaEmpty = function(x, y, width, height) {};

/**
 * Locks/unlocks widget.
 * @param {!HTMLElement} el
 * @param {boolean} val
 * @return {void}
 */
GridStack.prototype.locked = function(el, val) {};

/**
 * If you add elements to your gridstack container by hand, you have to tell gridstack afterwards to make them widgets. 
 * 
 *   If you want gridstack to add the elements for you, use addWidget instead. Makes the given element a widget and returns it.
 * 
 * @param {(string|!JQuery|!HTMLElement)} el
 * @return {!JQuery}
 */
GridStack.prototype.makeWidget = function(el) {};

/**
 * Set the maxWidth for a widget.
 * @param {!HTMLElement} el
 * @param {number} val
 * @return {void}
 */
GridStack.prototype.maxWidth = function(el, val) {};

/**
 * Set the minWidth for a widget.
 * @param {!HTMLElement} el
 * @param {number} val
 * @return {void}
 */
GridStack.prototype.minWidth = function(el, val) {};

/**
 * Set the maxHeight for a widget.
 * @param {!HTMLElement} el
 * @param {number} val
 * @return {void}
 */
GridStack.prototype.maxHeight = function(el, val) {};

/**
 * Set the minHeight for a widget.
 * @param {!HTMLElement} el
 * @param {number} val
 * @return {void}
 */
GridStack.prototype.minHeight = function(el, val) {};

/**
 * Enables/Disables moving.
 * @param {!HTMLElement} el
 * @param {boolean} val
 * @return {void}
 */
GridStack.prototype.movable = function(el, val) {};

/**
 * Changes widget position
 * 
 * @param {!HTMLElement} el
 * @param {number} x
 * @param {number} y
 * @return {void}
 */
GridStack.prototype.move = function(el, x, y) {};

/**
 * Removes widget from the grid.
 * @param {!HTMLElement} el
 * @param {boolean=} detachNode
 * @return {void}
 */
GridStack.prototype.removeWidget = function(el, detachNode) {};

/**
 * Removes all widgets from the grid.
 * @param {boolean=} detachNode
 * @return {void}
 */
GridStack.prototype.removeAll = function(detachNode) {};

/**
 * Changes widget size
 * @param {!HTMLElement} el
 * @param {number} width
 * @param {number} height
 * @return {void}
 */
GridStack.prototype.resize = function(el, width, height) {};

/**
 * Enables/Disables resizing.
 * @param {!HTMLElement} el
 * @param {boolean} val
 * @return {void}
 */
GridStack.prototype.resizable = function(el, val) {};

/**
 * Toggle the grid animation state. Toggles the grid-stack-animate class.
 * @param {boolean} doAnimate
 * @return {void}
 */
GridStack.prototype.setAnimation = function(doAnimate) {};

/**
 * (Experimental) Modify number of columns in the grid. 
 * Will attempt to update existing widgets to conform to new number of columns. 
 * Requires gridstack-extra.css or gridstack-extra.min.css.
 * @param {number} gridWidth
 * @param {boolean} doNotPropagate
 * @return {void}
 */
GridStack.prototype.setGridWidth = function(gridWidth, doNotPropagate) {};

/**
 * Toggle the grid static state. Also toggle the grid-stack-static class.
 * @param {boolean} staticValue
 * @return {void}
 */
GridStack.prototype.setStatic = function(staticValue) {};

/**
 * Updates widget position/size.
 * @param {!HTMLElement} el
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @return {void}
 */
GridStack.prototype.update = function(el, x, y, width, height) {};

/**
 * Sets the vertial margin
 * @param {number} value
 * @param {boolean} noUpdate
 * @return {void}
 */
GridStack.prototype.verticalMargin = function(value, noUpdate) {};

/**
 * Returns true if the height of the grid will be less the vertical constraint. Always returns true if grid doesn't have height constraint.
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {boolean} autoPosition
 * @return {boolean}
 */
GridStack.prototype.willItFit = function(x, y, width, height, autoPosition) {};
/**
 * @record
 * @struct
 */
function MousePosition() {}
 /** @type {number} */
MousePosition.prototype.top;
 /** @type {number} */
MousePosition.prototype.left;
/**
 * @record
 * @struct
 */
function CellPosition() {}
 /** @type {number} */
CellPosition.prototype.x;
 /** @type {number} */
CellPosition.prototype.y;
/** @const */
var GridStackUI = {};
/**
 * @record
 * @struct
 */
GridStackUI.Utils = function() {};

/**
 * Sorts array of nodes
 * @param {!Array<!HTMLElement>} nodes array to sort
 * @param {number=} dir 1 for asc, -1 for desc (optional)
 * @param {number=} width width of the grid. If undefined the width will be calculated automatically (optional).
 * 
 * @return {void}
 */
GridStackUI.Utils.prototype.sort = function(nodes, dir, width) {};
/**
 * @record
 * @struct
 */
function IGridstackOptions() {}
 /** @type {boolean} */
IGridstackOptions.prototype.acceptWidgets;
 /** @type {boolean} */
IGridstackOptions.prototype.alwaysShowResizeHandle;
 /** @type {boolean} */
IGridstackOptions.prototype.animate;
 /** @type {boolean} */
IGridstackOptions.prototype.auto;
 /** @type {number} */
IGridstackOptions.prototype.cellHeight;
 /** @type {?} */
IGridstackOptions.prototype.ddPlugin;
 /** @type {boolean} */
IGridstackOptions.prototype.disableDrag;
 /** @type {boolean} */
IGridstackOptions.prototype.disableResize;
 /** @type {!Object} */
IGridstackOptions.prototype.draggable;
 /** @type {string} */
IGridstackOptions.prototype.handle;
 /** @type {string} */
IGridstackOptions.prototype.handleClass;
 /** @type {number} */
IGridstackOptions.prototype.height;
 /** @type {boolean} */
IGridstackOptions.prototype.float;
 /** @type {string} */
IGridstackOptions.prototype.itemClass;
 /** @type {number} */
IGridstackOptions.prototype.minWidth;
 /** @type {boolean} */
IGridstackOptions.prototype.disableOneColumnMode;
 /** @type {string} */
IGridstackOptions.prototype.oneColumnModeClass;
 /** @type {string} */
IGridstackOptions.prototype.placeholderClass;
 /** @type {string} */
IGridstackOptions.prototype.placeholderText;
 /** @type {!Object} */
IGridstackOptions.prototype.resizable;
 /** @type {boolean} */
IGridstackOptions.prototype.removable;
 /** @type {number} */
IGridstackOptions.prototype.removeTimeout;
 /** @type {(boolean|string)} */
IGridstackOptions.prototype.rtl;
 /** @type {boolean} */
IGridstackOptions.prototype.staticGrid;
 /** @type {number} */
IGridstackOptions.prototype.verticalMargin;
 /** @type {number} */
IGridstackOptions.prototype.width;
