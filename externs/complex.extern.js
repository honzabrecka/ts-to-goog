/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/complex/index.d.ts:

/**
 * @constructor
 * @struct
 * @param {number} real The real part of the number
 * @param {number} im The imaginary part of the number
 */
function Complex(real, im) {}
 /** @type {?} */
Complex.i;
 /** @type {?} */
Complex.one;

/**
 * A in line function like Number.from.
 * 
 * Examples:
 * var z = Complex.from(2, 4);
 * var z = Complex.from(5);
 * var z = Complex.from('2+5i');
 * 
 * A in line function like Number.from.
 * @param {string|number} real A string representation of the number, for example 1+4i / The real part of the number
 * @param {number=} im The imaginary part of the number
 * @return {?}
 */
Complex.from = function(real, im) {};

/**
 * Creates a complex instance from a polar representation
 * @param {number} r The radius/magnitude of the number
 * @param {number} phi The angle/phase of the number
 * @return {?}
 */
Complex.fromPolar = function(r, phi) {};

/**
 * Set the real and imaginary properties a and b from a + bi.
 * @param {number} real The real part of the number
 * @param {number} im The imaginary part of the number
 * @return {?}
 */
Complex.prototype.fromRect = function(real, im) {};

/**
 * Set the a and b in a + bi from a polar representation.
 * @param {number} r The radius/magnitude of the number
 * @param {number} phi The angle/phase of the number
 * @return {?}
 */
Complex.prototype.fromPolar = function(r, phi) {};

/**
 * Set the precision of the numbers. Similar to Number.prototype.toPrecision. Useful before printing the number with the toString method.
 * @param {number} k An integer specifying the number of significant digits
 * @return {?}
 */
Complex.prototype.toPrecision = function(k) {};

/**
 * Format a number using fixed-point notation. Similar to Number.prototype.toFixed. Useful before printing the number with the toString method.
 * @param {number} k The number of digits to appear after the decimal point; this may be a value between 0 and 20, inclusive, and implementations may optionally support a larger range of values. If this argument is omitted, it is treated as 0.
 * @return {?}
 */
Complex.prototype.toFixed = function(k) {};

/**
 * Finalize the instance. The number will not change and any other method call will return a new instance. Very useful when a complex instance should stay constant. For example the Complex.i variable is a finalized instance.
 * @return {?}
 */
Complex.prototype.finalize = function() {};

/**
 * Calculate the magnitude of the complex number
 * @return {number}
 */
Complex.prototype.magnitude = function() {};

/**
 * Alias for magnitude(). Calculate the magnitude of the complex number.
 * @return {number}
 */
Complex.prototype.abs = function() {};

/**
 * Calculate the angle with respect to the real axis, in radians.
 * @return {number}
 */
Complex.prototype.angle = function() {};

/**
 * Alias for angle(). Calculate the angle with respect to the real axis, in radians.
 * @return {number}
 */
Complex.prototype.arg = function() {};

/**
 * Alias for angle(). Calculate the angle with respect to the real axis, in radians.
 * @return {number}
 */
Complex.prototype.phase = function() {};

/**
 * Calculate the conjugate of the complex number (multiplies the imaginary part with -1)
 * @return {?}
 */
Complex.prototype.conjugate = function() {};

/**
 * Negate the number (multiplies both the real and imaginary part with -1)
 * @return {?}
 */
Complex.prototype.negate = function() {};

/**
 * Multiply the number with a real or complex number
 * @param {(number|?)} z The number to multiply with
 * @return {?}
 */
Complex.prototype.multiply = function(z) {};

/**
 * Alias for multiply(). Multiply the number with a real or complex number
 * @param {(number|?)} z The number to multiply with
 * @return {?}
 */
Complex.prototype.mult = function(z) {};

/**
 * Divide the number by a real or complex number
 * @param {(number|?)} z The number to divide by
 * @return {?}
 */
Complex.prototype.divide = function(z) {};

/**
 * Alias for divide(). Divide the number by a real or complex number
 * @param {(number|?)} z The number to divide by
 * @return {?}
 */
Complex.prototype.div = function(z) {};

/**
 * Add a real or complex number
 * @param {(number|?)} z The number to add
 * @return {?}
 */
Complex.prototype.add = function(z) {};

/**
 * Subtract a real or complex number
 * @param {(number|?)} z The number to subtract
 * @return {?}
 */
Complex.prototype.subtract = function(z) {};

/**
 * Alias for subtract(). Subtract a real or complex number
 * @param {(number|?)} z The number to subtract
 * @return {?}
 */
Complex.prototype.sub = function(z) {};

/**
 * Return the base to the exponent
 * @param {(number|?)} z The exponent
 * @return {?}
 */
Complex.prototype.pow = function(z) {};

/**
 * Return the square root
 * @return {?}
 */
Complex.prototype.sqrt = function() {};

/**
 * Return the natural logarithm (base E)
 * @param {number=} k The actual answer has a multiplicity (ln(z) = ln|z| + arg(z)) where arg(z) can return the same for different angles (every 2*pi), with this argument you can define which answer is required
 * @return {?}
 */
Complex.prototype.log = function(k) {};

/**
 * Calculate the e^z where the base is E and the exponential the complex number.
 * @return {?}
 */
Complex.prototype.exp = function() {};

/**
 * Calculate the sine of the complex number
 * @return {?}
 */
Complex.prototype.sin = function() {};

/**
 * Calculate the cosine of the complex number
 * @return {?}
 */
Complex.prototype.cos = function() {};

/**
 * Calculate the tangent of the complex number
 * @return {?}
 */
Complex.prototype.tan = function() {};

/**
 * Calculate the hyperbolic sine of the complex number
 * @return {?}
 */
Complex.prototype.sinh = function() {};

/**
 * Calculate the hyperbolic cosine of the complex number
 * @return {?}
 */
Complex.prototype.cosh = function() {};

/**
 * Calculate the hyperbolic tangent of the complex number
 * @return {?}
 */
Complex.prototype.tanh = function() {};

/**
 * Return a new Complex instance with the same real and imaginary properties
 * @return {?}
 */
Complex.prototype.clone = function() {};

/**
 * Return a string representation of the complex number
 * 
 * Examples:
 * new Complex(1, 2).toString(); // 1+2i
 * new Complex(0, 1).toString(); // i
 * new Complex(4, 0).toString(); // 4
 * new Complex(1, 1).toString(); // 1+i
 * 'my Complex Number is: ' + (new Complex(3, 5)); // 'my Complex Number is: 3+5i
 * @return {string}
 */
Complex.prototype.toString = function() {};

/**
 * Check if the real and imaginary components are equal to the passed in compelex components.
 * 
 * Examples:
 * new Complex(1, 4).equals(new Complex(1, 4)); // true
 * new Complex(1, 4).equals(new Complex(1, 3)); // false
 * 
 * @param {(number|?)} z The complex number to compare with
 * @return {boolean}
 */
Complex.prototype.equals = function(z) {};
