/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/nearley/index.d.ts:

/* TODO: NamespaceExportDeclaration in  */

/**
 * @constructor
 * @struct
 * @param {!Array<?>|?} rules_or_grammar
 * @param {string|?=} start_or_options
 * @param {?=} options
 */
function Parser(rules_or_grammar, start_or_options, options) {}
 /** @type {?} */
Parser.prototype.grammar;
 /** @type {?} */
Parser.prototype.options;
 /** @type {?} */
Parser.prototype.lexer;
 /** @type {?} */
Parser.prototype.lexerState;
 /** @type {number} */
Parser.prototype.current;
 /** @type {!Array<?>} */
Parser.prototype.results;
 /** @type {!Object} */
Parser.fail;

/**
 * The Parser object can be fed data in parts with .feed(data).
 * You can then find an array of parsings with the .results property.
 * If results is empty, then there are no parsings.
 * If results contains multiple values, then that combination is ambiguous.
 * 
 * @throws If there are no possible parsings, nearley will throw an error
 * whose offset property is the index of the offending token.
 * @param {string} chunk
 * @return {void}
 */
Parser.prototype.feed = function(chunk) {};

/**
 * @return {!Array<?>}
 */
Parser.prototype.finish = function() {};

/**
 * @param {?} column
 * @return {void}
 */
Parser.prototype.restore = function(column) {};

/**
 * @return {?}
 */
Parser.prototype.save = function() {};
/**
 * @record
 * @struct
 */
function ParserOptions() {}
 /** @type {boolean} */
ParserOptions.prototype.keepHistory;
 /** @type {?} */
ParserOptions.prototype.lexer;

/**
 * @constructor
 * @struct
 * @param {?} name
 * @param {?} symbols
 * @param {?} postprocess
 */
function Rule(name, symbols, postprocess) {}
 /** @type {number} */
Rule.highestId;

/**
 * @param {?} withCursorAt
 * @return {?}
 */
Rule.prototype.toString = function(withCursorAt) {};

/**
 * @constructor
 * @struct
 * @param {!Array<?>} rules
 * @param {string} start
 */
function Grammar(rules, start) {}
 /** @type {!Array<?>} */
Grammar.prototype.rules;
 /** @type {?} */
Grammar.prototype.byName;

/**
 * @param {!Array<?>} rules
 * @param {string} start
 * @return {?}
 */
Grammar.fromCompiled = function(rules, start) {};
/**
 * @record
 * @struct
 */
function Lexer() {}

/**
 * Sets the internal buffer to chunk, and restore line/col/state info taken from save().
 * @param {string} chunk
 * @param {?=} state
 * @return {void}
 */
Lexer.prototype.reset = function(chunk, state) {};

/**
 * Returns e.g. {type, value, line, col, â€¦}. Only the value attribute is required.
 * @return {?}
 */
Lexer.prototype.next = function() {};

/**
 * Returns an object describing the current line/col etc. This allows us
 * to preserve this information between feed() calls, and also to support Parser#rewind().
 * The exact structure is lexer-specific; nearley doesn't care what's in it.
 * @return {?}
 */
Lexer.prototype.save = function() {};

/**
 * Returns a string with an error message describing the line/col of the offending token.
 * You might like to include a preview of the line in question.
 * @param {?} token
 * @return {string}
 */
Lexer.prototype.formatError = function(token) {};

/**
 * Returns true if the lexer can emit tokens with that name.
 * Used to resolve %-specifiers in compiled nearley grammars.
 * @param {string} tokenType
 * @return {boolean}
 */
Lexer.prototype.has = function(tokenType) {};
/**
 * @record
 * @struct
 */
function Token() {}

/* TODO: IndexSignature:  */
 /** @type {string} */
Token.prototype.value;
/**
 * @record
 * @struct
 */
function LexerState() {}

/* TODO: IndexSignature:  */
