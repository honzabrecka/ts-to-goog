/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/fabric/index.d.ts:

/* TODO: NamespaceExportDeclaration in  */
 /** @type {boolean} */
var isLikelyNode;
 /** @type {boolean} */
var isTouchSupported;

/**
 * @param {number} width
 * @param {number} height
 * @return {?}
 */
function createCanvasForNode(width, height) {}

/**
 * Creates markup containing SVG referenced elements like patterns, gradients etc.
 * @param {?} canvas
 * @return {string}
 */
function createSVGRefElementsMarkup(canvas) {}

/**
 * Creates markup containing SVG font faces
 * @param {!Array<?>} objects
 * @return {string}
 */
function createSVGFontFacesMarkup(objects) {}

/**
 * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
 * @param {string} string
 * @param {?} callback
 * @param {!Function=} reviver
 * @return {void}
 */
function loadSVGFromString(string, callback, reviver) {}

/**
 * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
 * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
 * @param {string} url
 * @param {?} callback
 * @param {!Function=} reviver
 * @return {void}
 */
function loadSVGFromURL(url, callback, reviver) {}

/**
 * Returns CSS rules for a given SVG document
 * @param {!SVGElement} doc
 * @return {?}
 */
function getCSSRules(doc) {}

/**
 * Transforms an array of svg elements to corresponding fabric.* instances
 * @param {!Array<?>} elements
 * @param {!Function} callback
 * @param {?=} options
 * @param {!Function=} reviver
 * @return {void}
 */
function parseElements(elements, callback, options, reviver) {}

/**
 * Parses "points" attribute, returning an array of values
 * @param {string} points
 * @return {!Array<?>}
 */
function parsePointsAttribute(points) {}

/**
 * Parses "style" attribute, retuning an object with values
 * @param {!SVGElement} element
 * @return {?}
 */
function parseStyleAttribute(element) {}

/**
 * Returns an object of attributes' name/value, given element and an array of attribute names;
 * Parses parent "g" nodes recursively upwards.
 * @param {!HTMLElement} element
 * @param {!Array<string>} attributes
 * @param {string=} svgUid
 * @return {?}
 */
function parseAttributes(element, attributes, svgUid) {}

/**
 * Parses an SVG document, returning all of the gradient declarations found in it
 * @param {!SVGElement} doc
 * @return {?}
 */
function getGradientDefs(doc) {}

/**
 * Parses a short font declaration, building adding its properties to a style object
 * @param {string} value
 * @param {?} oStyle
 * @return {void}
 */
function parseFontDeclaration(value, oStyle) {}

/**
 * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
 * @param {!SVGElement} doc
 * @param {?} callback
 * @param {!Function=} reviver
 * @return {void}
 */
function parseSVGDocument(doc, callback, reviver) {}

/**
 * Parses "transform" attribute, returning an array of values
 * @param {string} attributeValue
 * @return {!Array<number>}
 */
function parseTransformAttribute(attributeValue) {}

/**
 * Wrapper around `console.log` (when available)
 * @param {...?} values
 * @return {void}
 */
function log(values) {}

/**
 * Wrapper around `console.warn` (when available)
 * @param {...?} values
 * @return {void}
 */
function warn(values) {}
/**
 * @record
 * @struct
 */
function IDataURLOptions() {}
 /** @type {string} */
IDataURLOptions.prototype.format;
 /** @type {number} */
IDataURLOptions.prototype.quality;
 /** @type {number} */
IDataURLOptions.prototype.multiplier;
 /** @type {number} */
IDataURLOptions.prototype.left;
 /** @type {number} */
IDataURLOptions.prototype.top;
 /** @type {number} */
IDataURLOptions.prototype.width;
 /** @type {number} */
IDataURLOptions.prototype.height;
/**
 * @record
 * @struct
 */
function IEvent() {}
 /** @type {!Event} */
IEvent.prototype.e;
 /** @type {?} */
IEvent.prototype.target;
/**
 * @record
 * @struct
 */
function IFillOptions() {}
 /** @type {(string|!HTMLImageElement)} */
IFillOptions.prototype.source;
 /** @type {string} */
IFillOptions.prototype.repeat;
 /** @type {number} */
IFillOptions.prototype.offsetX;
 /** @type {number} */
IFillOptions.prototype.offsetY;
/**
 * @record
 * @struct
 */
function IToSVGOptions() {}
 /** @type {boolean} */
IToSVGOptions.prototype.suppressPreamble;
 /** @type {?} */
IToSVGOptions.prototype.viewBox;
 /** @type {string} */
IToSVGOptions.prototype.encoding;
/**
 * @record
 * @struct
 */
function IViewBox() {}
 /** @type {number} */
IViewBox.prototype.x;
 /** @type {number} */
IViewBox.prototype.y;
 /** @type {number} */
IViewBox.prototype.width;
 /** @type {number} */
IViewBox.prototype.height;
/**
 * @record
 * @struct
 */
function ICollection() {}

/**
 * Adds objects to collection, then renders canvas (if `renderOnAddRemove` is not `false`)
 * Objects should be instances of (or inherit from) fabric.Object
 * @param {...?} object
 * @return {?}
 */
ICollection.prototype.add = function(object) {};

/**
 * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
 * An object should be an instance of (or inherit from) fabric.Object
 * \@chainable
 * @param {?} object
 * @param {number} index
 * @param {boolean} nonSplicing
 * @return {?}
 */
ICollection.prototype.insertAt = function(object, index, nonSplicing) {};

/**
 * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
 * \@chainable
 * @param {...?} object
 * @return {?}
 */
ICollection.prototype.remove = function(object) {};

/**
 * Executes given function for each object in this group
 * @param {?} callback
 * @param {?=} context
 * @return {?}
 */
ICollection.prototype.forEachObject = function(callback, context) {};

/**
 * Returns an array of children objects of this instance
 * Type parameter introduced in 1.3.10
 * @param {string=} type
 * @return {!Array<?>}
 */
ICollection.prototype.getObjects = function(type) {};

/**
 * Returns object at specified index
 * @param {number} index
 * @return {?}
 */
ICollection.prototype.item = function(index) {};

/**
 * Returns true if collection contains no objects
 * @return {boolean}
 */
ICollection.prototype.isEmpty = function() {};

/**
 * Returns a size of a collection (i.e: length of an array containing its objects)
 * @return {number}
 */
ICollection.prototype.size = function() {};

/**
 * Returns true if collection contains an object
 * @param {?} object
 * @return {boolean}
 */
ICollection.prototype.contains = function(object) {};

/**
 * Returns number representation of a collection complexity
 * @return {number}
 */
ICollection.prototype.complexity = function() {};
/**
 * @record
 * @struct
 */
function IObservable() {}

/**
 * Observes specified event
 * Observes specified event
 * @param {string|?} eventName Event name (eg. 'after:render') / Object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
 * @param {?=} handler Function that receives a notification when an event of the specified type occurs
 * @return {?}
 */
IObservable.prototype.on = function(eventName, handler) {};

/**
 * Fires event with an optional options object
 * @param {string} eventName
 * @param {?=} options
 * @return {?}
 */
IObservable.prototype.trigger = function(eventName, options) {};

/**
 * Stops event observing for a particular event handler. Calling this method
 * without arguments removes all handlers for all events
 * @param {?=} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
 * @param {?=} handler Function to be deleted from EventListeners
 * @return {?}
 */
IObservable.prototype.off = function(eventName, handler) {};
/**
 * @record
 * @struct
 */
function ICanvasAnimation() {}
 /** @type {number} */
ICanvasAnimation.prototype.FX_DURATION;

/**
 * Centers object horizontally with animation.
 * @param {?} object
 * @param {?=} callbacks
 * @return {?}
 */
ICanvasAnimation.prototype.fxCenterObjectH = function(object, callbacks) {};

/**
 * Centers object vertically with animation.
 * @param {?} object
 * @param {?=} callbacks
 * @return {?}
 */
ICanvasAnimation.prototype.fxCenterObjectV = function(object, callbacks) {};

/**
 * Same as `fabric.Canvas#remove` but animated
 * \@chainable
 * @param {?} object
 * @param {?=} callbacks
 * @return {?}
 */
ICanvasAnimation.prototype.fxRemove = function(object, callbacks) {};
/**
 * @record
 * @struct
 */
function IObjectAnimation() {}

/**
 * Animates object's properties
 * object.animate('left', ..., {duration: ...});
 * Animates object's properties
 * object.animate({ left: ..., top: ... }, { duration: ... });
 * @param {string|?} property_or_properties Property to animate / Properties to animate
 * @param {(string|number)|?=} value_or_options Value to animate property
 * @param {?=} options The animation options
 * @return {?}
 */
IObjectAnimation.prototype.animate = function(property_or_properties, value_or_options, options) {};
/**
 * @record
 * @struct
 */
function IAnimationOptions() {}
 /** @type {(string|number)} */
IAnimationOptions.prototype.from;
 /** @type {number} */
IAnimationOptions.prototype.duration;
 /** @type {!Function} */
IAnimationOptions.prototype.onChange;
 /** @type {!Function} */
IAnimationOptions.prototype.onComplete;
 /** @type {!Function} */
IAnimationOptions.prototype.easing;
 /** @type {number} */
IAnimationOptions.prototype.by;

/**
 * @constructor
 * @struct
 * Color class
 * The purpose of Color is to abstract and encapsulate common color operations;
 * @param {string=} color
 */
function Color(color) {}

/**
 * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
 * @return {!Array<number>}
 */
Color.prototype.getSource = function() {};

/**
 * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
 * @param {!Array<number>} source
 * @return {void}
 */
Color.prototype.setSource = function(source) {};

/**
 * Returns color represenation in RGB format ex: rgb(0-255,0-255,0-255)
 * @return {string}
 */
Color.prototype.toRgb = function() {};

/**
 * Returns color represenation in RGBA format ex: rgba(0-255,0-255,0-255,0-1)
 * @return {string}
 */
Color.prototype.toRgba = function() {};

/**
 * Returns color represenation in HSL format ex: hsl(0-360,0%-100%,0%-100%)
 * @return {string}
 */
Color.prototype.toHsl = function() {};

/**
 * Returns color represenation in HSLA format ex: hsla(0-360,0%-100%,0%-100%,0-1)
 * @return {string}
 */
Color.prototype.toHsla = function() {};

/**
 * Returns color represenation in HEX format ex: FF5555
 * @return {string}
 */
Color.prototype.toHex = function() {};

/**
 * Gets value of alpha channel for this color
 * @return {number}
 */
Color.prototype.getAlpha = function() {};

/**
 * Sets value of alpha channel for this color
 * @param {number} alpha
 * @return {void}
 */
Color.prototype.setAlpha = function(alpha) {};

/**
 * Transforms color to its grayscale representation
 * @return {?}
 */
Color.prototype.toGrayscale = function() {};

/**
 * Transforms color to its black and white representation
 * @param {number} threshold
 * @return {?}
 */
Color.prototype.toBlackWhite = function(threshold) {};

/**
 * Overlays color with another color
 * @param {(string|?)} otherColor
 * @return {?}
 */
Color.prototype.overlayWith = function(otherColor) {};

/**
 * Returns new color object, when given a color in RGB format
 * @param {string} color
 * @return {?}
 */
Color.fromRgb = function(color) {};

/**
 * Returns new color object, when given a color in RGBA format
 * @param {string} color
 * @return {?}
 */
Color.fromRgba = function(color) {};

/**
 * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
 * @param {string} color
 * @return {!Array<number>}
 */
Color.sourceFromRgb = function(color) {};

/**
 * Returns new color object, when given a color in HSL format
 * @param {string} color
 * @return {?}
 */
Color.fromHsl = function(color) {};

/**
 * Returns new color object, when given a color in HSLA format
 * @param {string} color
 * @return {?}
 */
Color.fromHsla = function(color) {};

/**
 * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
 * @param {string} color
 * @return {!Array<number>}
 */
Color.sourceFromHsl = function(color) {};

/**
 * Returns new color object, when given a color in HEX format
 * @param {string} color
 * @return {?}
 */
Color.fromHex = function(color) {};

/**
 * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HEX format
 * @param {string} color
 * @return {!Array<number>}
 */
Color.sourceFromHex = function(color) {};

/**
 * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
 * @param {!Array<number>} source
 * @return {?}
 */
Color.fromSource = function(source) {};
/**
 * @record
 * @struct
 */
function IGradientOptions() {}
 /** @type {string} */
IGradientOptions.prototype.type;
 /** @type {number} */
IGradientOptions.prototype.x1;
 /** @type {number} */
IGradientOptions.prototype.y1;
 /** @type {number} */
IGradientOptions.prototype.x2;
 /** @type {number} */
IGradientOptions.prototype.y2;
 /** @type {number} */
IGradientOptions.prototype.r1;
 /** @type {number} */
IGradientOptions.prototype.r2;
 /** @type {?} */
IGradientOptions.prototype.colorStops;
/**
 * @extends {IGradientOptions}
 * @record
 * @struct
 */
function IGradient() {}

/**
 * Adds another colorStop
 * @param {?} colorStop
 * @return {?}
 */
IGradient.prototype.addColorStop = function(colorStop) {};

/**
 * Returns object representation of a gradient
 * @return {?}
 */
IGradient.prototype.toObject = function() {};

/**
 * Returns SVG representation of an gradient
 * @param {?} object
 * @param {boolean=} normalize
 * @return {string}
 */
IGradient.prototype.toSVG = function(object, normalize) {};

/**
 * Returns an instance of CanvasGradient
 * @param {!CanvasRenderingContext2D} ctx
 * @param {?=} object
 * @return {!CanvasGradient}
 */
IGradient.prototype.toLive = function(ctx, object) {};
/**
 * @record
 * @struct
 */
function IGrandientStatic() {}

/* TODO: ConstructSignature:  */

/**
 * Returns instance from an SVG element
 * @param {!SVGGradientElement} el
 * @param {?} instance
 * @return {?}
 */
IGrandientStatic.prototype.fromElement = function(el, instance) {};

/**
 * Returns instance from its object representation
 * @param {?} obj
 * @param {!Array<?>} options
 * @return {?}
 */
IGrandientStatic.prototype.fromObject = function(obj, options) {};

/**
 * @constructor
 * @struct
 * @param {string=} status
 */
function Intersection(status) {}

/**
 * Appends a point to intersection
 * @param {?} point
 * @return {void}
 */
Intersection.prototype.appendPoint = function(point) {};

/**
 * Appends points to intersection
 * @param {!Array<?>} points
 * @return {void}
 */
Intersection.prototype.appendPoints = function(points) {};

/**
 * Checks if polygon intersects another polygon
 * @param {!Array<?>} points1
 * @param {!Array<?>} points2
 * @return {?}
 */
Intersection.intersectPolygonPolygon = function(points1, points2) {};

/**
 * Checks if line intersects polygon
 * @param {?} a1
 * @param {?} a2
 * @param {!Array<?>} points
 * @return {?}
 */
Intersection.intersectLinePolygon = function(a1, a2, points) {};

/**
 * Checks if one line intersects another
 * @param {?} a1
 * @param {?} a2
 * @param {?} b1
 * @param {?} b2
 * @return {?}
 */
Intersection.intersectLineLine = function(a1, a2, b1, b2) {};

/**
 * Checks if polygon intersects rectangle
 * @param {!Array<?>} points
 * @param {number} r1
 * @param {number} r2
 * @return {?}
 */
Intersection.intersectPolygonRectangle = function(points, r1, r2) {};
/**
 * @record
 * @struct
 */
function IPatternOptions() {}
 /** @type {string} */
IPatternOptions.prototype.repeat;
 /** @type {number} */
IPatternOptions.prototype.offsetX;
 /** @type {number} */
IPatternOptions.prototype.offsetY;
 /** @type {(string|!HTMLImageElement)} */
IPatternOptions.prototype.source;
/**
 * @extends {IPatternOptions}
 * @record
 * @struct
 */
function Pattern() {}

/**
 * @param {?=} options
 * @return {?}
 */
Pattern.prototype.initialise = function(options) {};

/**
 * Returns an instance of CanvasPattern
 * @param {!CanvasRenderingContext2D} ctx
 * @return {?}
 */
Pattern.prototype.toLive = function(ctx) {};

/**
 * Returns object representation of a pattern
 * @return {?}
 */
Pattern.prototype.toObject = function() {};

/**
 * Returns SVG representation of a pattern
 * @param {?} object
 * @return {string}
 */
Pattern.prototype.toSVG = function(object) {};

/**
 * @constructor
 * @struct
 * @param {number} x
 * @param {number} y
 */
function Point(x, y) {}
 /** @type {number} */
Point.prototype.x;
 /** @type {number} */
Point.prototype.y;

/**
 * Adds another point to this one and returns another one
 * @param {?} that
 * @return {?}
 */
Point.prototype.add = function(that) {};

/**
 * Adds another point to this one
 * @param {?} that
 * @return {?}
 */
Point.prototype.addEquals = function(that) {};

/**
 * Adds value to this point and returns a new one
 * @param {number} scalar
 * @return {?}
 */
Point.prototype.scalarAdd = function(scalar) {};

/**
 * Adds value to this point
 * @param {number} scalar
 * @return {?}
 */
Point.prototype.scalarAddEquals = function(scalar) {};

/**
 * Subtracts another point from this point and returns a new one
 * @param {?} that
 * @return {?}
 */
Point.prototype.subtract = function(that) {};

/**
 * Subtracts another point from this point
 * @param {?} that
 * @return {?}
 */
Point.prototype.subtractEquals = function(that) {};

/**
 * Subtracts value from this point and returns a new one
 * @param {number} scalar
 * @return {?}
 */
Point.prototype.scalarSubtract = function(scalar) {};

/**
 * Subtracts value from this point
 * @param {number} scalar
 * @return {?}
 */
Point.prototype.scalarSubtractEquals = function(scalar) {};

/**
 * Miltiplies this point by a value and returns a new one
 * @param {number} scalar
 * @return {?}
 */
Point.prototype.multiply = function(scalar) {};

/**
 * Miltiplies this point by a value
 * @param {number} scalar
 * @return {?}
 */
Point.prototype.multiplyEquals = function(scalar) {};

/**
 * Divides this point by a value and returns a new one
 * @param {number} scalar
 * @return {?}
 */
Point.prototype.divide = function(scalar) {};

/**
 * Divides this point by a value
 * @param {number} scalar
 * @return {?}
 */
Point.prototype.divideEquals = function(scalar) {};

/**
 * Returns true if this point is equal to another one
 * @param {?} that
 * @return {?}
 */
Point.prototype.eq = function(that) {};

/**
 * Returns true if this point is less than another one
 * @param {?} that
 * @return {?}
 */
Point.prototype.lt = function(that) {};

/**
 * Returns true if this point is less than or equal to another one
 * @param {?} that
 * @return {?}
 */
Point.prototype.lte = function(that) {};

/**
 * Returns true if this point is greater another one
 * @param {?} that
 * @return {?}
 */
Point.prototype.gt = function(that) {};

/**
 * Returns true if this point is greater than or equal to another one
 * @param {?} that
 * @return {?}
 */
Point.prototype.gte = function(that) {};

/**
 * Returns new point which is the result of linear interpolation with this one and another one
 * @param {?} that
 * @param {number} t
 * @return {?}
 */
Point.prototype.lerp = function(that, t) {};

/**
 * Returns distance from this point and another one
 * @param {?} that
 * @return {number}
 */
Point.prototype.distanceFrom = function(that) {};

/**
 * Returns the point between this point and another one
 * @param {?} that
 * @return {?}
 */
Point.prototype.midPointFrom = function(that) {};

/**
 * Returns a new point which is the min of this and another one
 * @param {?} that
 * @return {?}
 */
Point.prototype.min = function(that) {};

/**
 * Returns a new point which is the max of this and another one
 * @param {?} that
 * @return {?}
 */
Point.prototype.max = function(that) {};

/**
 * Returns string representation of this point
 * @return {string}
 */
Point.prototype.toString = function() {};

/**
 * Sets x/y of this point
 * @param {number} x
 * @param {number} y
 * @return {?}
 */
Point.prototype.setXY = function(x, y) {};

/**
 * Sets x/y of this point from another point
 * @param {?} that
 * @return {?}
 */
Point.prototype.setFromPoint = function(that) {};

/**
 * Swaps x/y of this point and another point
 * @param {?} that
 * @return {?}
 */
Point.prototype.swap = function(that) {};
/**
 * @record
 * @struct
 */
function IShadowOptions() {}
 /** @type {boolean} */
IShadowOptions.prototype.affectStrike;
 /** @type {number} */
IShadowOptions.prototype.blur;
 /** @type {string} */
IShadowOptions.prototype.color;
 /** @type {boolean} */
IShadowOptions.prototype.includeDefaultValues;
 /** @type {number} */
IShadowOptions.prototype.offsetX;
 /** @type {number} */
IShadowOptions.prototype.offsetY;
/**
 * @extends {IShadowOptions}
 * @record
 * @struct
 */
function IShadow() {}
 /** @type {!RegExp} */
IShadow.prototype.reOffsetsAndBlur;
 /** @type {!RegExp} */
IShadow.reOffsetsAndBlur;

/**
 * @param {(string|?)=} options
 * @return {?}
 */
IShadow.prototype.initialize = function(options) {};

/**
 * Returns object representation of a shadow
 * @return {?}
 */
IShadow.prototype.toObject = function() {};

/**
 * Returns a string representation of an instance, CSS3 text-shadow declaration
 * @return {string}
 */
IShadow.prototype.toString = function() {};

/**
 * Returns SVG representation of a shadow
 * @param {?} object
 * @return {string}
 */
IShadow.prototype.toSVG = function(object) {};
/**
 * @record
 * @struct
 */
function ICanvasDimensions() {}
 /** @type {number} */
ICanvasDimensions.prototype.width;
 /** @type {number} */
ICanvasDimensions.prototype.height;
/**
 * @record
 * @struct
 */
function ICanvasDimensionsOptions() {}
 /** @type {boolean} */
ICanvasDimensionsOptions.prototype.backstoreOnly;
 /** @type {boolean} */
ICanvasDimensionsOptions.prototype.cssOnly;
/**
 * @record
 * @struct
 */
function IStaticCanvasOptions() {}
 /** @type {boolean} */
IStaticCanvasOptions.prototype.allowTouchScrolling;
 /** @type {boolean} */
IStaticCanvasOptions.prototype.imageSmoothingEnabled;
 /** @type {boolean} */
IStaticCanvasOptions.prototype.preserveObjectStacking;
 /** @type {!Array<number>} */
IStaticCanvasOptions.prototype.viewportTransform;
 /** @type {string} */
IStaticCanvasOptions.prototype.freeDrawingColor;
 /** @type {number} */
IStaticCanvasOptions.prototype.freeDrawingLineWidth;
 /** @type {(string|?)} */
IStaticCanvasOptions.prototype.backgroundColor;
 /** @type {(string|?)} */
IStaticCanvasOptions.prototype.backgroundImage;
 /** @type {number} */
IStaticCanvasOptions.prototype.backgroundImageOpacity;
 /** @type {number} */
IStaticCanvasOptions.prototype.backgroundImageStretch;
 /** @type {boolean} */
IStaticCanvasOptions.prototype.controlsAboveOverlay;
 /** @type {boolean} */
IStaticCanvasOptions.prototype.includeDefaultValues;
 /** @type {(string|?)} */
IStaticCanvasOptions.prototype.overlayColor;
 /** @type {?} */
IStaticCanvasOptions.prototype.overlayImage;
 /** @type {number} */
IStaticCanvasOptions.prototype.overlayImageLeft;
 /** @type {number} */
IStaticCanvasOptions.prototype.overlayImageTop;
 /** @type {boolean} */
IStaticCanvasOptions.prototype.renderOnAddRemove;
 /** @type {boolean} */
IStaticCanvasOptions.prototype.stateful;

/**
 * Function that determines clipping of entire canvas area
 * Being passed context as first argument. See clipping canvas area
 * @param {!CanvasRenderingContext2D} context
 * @return {void}
 */
IStaticCanvasOptions.prototype.clipTo = function(context) {};
/**
 * @extends {IObservable}
 * @extends {IStaticCanvasOptions}
 * @extends {ICollection}
 * @extends {ICanvasAnimation}
 * @record
 * @struct
 */
function StaticCanvas() {}
 /** @type {boolean} */
StaticCanvas.prototype.svgViewportTransformation;
 /** @type {string} */
StaticCanvas.EMPTY_JSON;

/**
 * Calculates canvas element offset relative to the document
 * This method is also attached as "resize" event handler of window
 * @return {?}
 */
StaticCanvas.prototype.calcOffset = function() {};

/**
 * Sets {\@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
 * @param {(string|?)} image
 * @param {!Function} callback
 * @param {?=} options
 * @return {?}
 */
StaticCanvas.prototype.setOverlayImage = function(image, callback, options) {};

/**
 * Sets {\@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
 * @param {(string|?)} image
 * @param {!Function} callback
 * @param {?=} options
 * @return {?}
 */
StaticCanvas.prototype.setBackgroundImage = function(image, callback, options) {};

/**
 * Sets {\@link fabric.StaticCanvas#overlayColor|background color} for this canvas
 * @param {(string|?)} overlayColor
 * @param {!Function} callback
 * @return {?}
 */
StaticCanvas.prototype.setOverlayColor = function(overlayColor, callback) {};

/**
 * Sets {\@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
 * @param {(string|?)} backgroundColor
 * @param {!Function} callback
 * @return {?}
 */
StaticCanvas.prototype.setBackgroundColor = function(backgroundColor, callback) {};

/**
 * Returns canvas width (in px)
 * @return {number}
 */
StaticCanvas.prototype.getWidth = function() {};

/**
 * Returns canvas height (in px)
 * @return {number}
 */
StaticCanvas.prototype.getHeight = function() {};

/**
 * Sets width of this canvas instance
 * @param {(string|number)} value
 * @param {?=} options
 * @return {?}
 */
StaticCanvas.prototype.setWidth = function(value, options) {};

/**
 * Sets height of this canvas instance
 * @param {(string|number)} value
 * @param {?=} options
 * @return {?}
 */
StaticCanvas.prototype.setHeight = function(value, options) {};

/**
 * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
 * @param {?} dimensions
 * @param {?=} options
 * @return {?}
 */
StaticCanvas.prototype.setDimensions = function(dimensions, options) {};

/**
 * Returns canvas zoom level
 * @return {number}
 */
StaticCanvas.prototype.getZoom = function() {};

/**
 * Sets viewport transform of this canvas instance
 * @param {!Array<number>} vpt
 * @return {?}
 */
StaticCanvas.prototype.setViewportTransform = function(vpt) {};

/**
 * Sets zoom level of this canvas instance, zoom centered around point
 * @param {?} point
 * @param {number} value
 * @return {?}
 */
StaticCanvas.prototype.zoomToPoint = function(point, value) {};

/**
 * Sets zoom level of this canvas instance
 * @param {number} value
 * @return {?}
 */
StaticCanvas.prototype.setZoom = function(value) {};

/**
 * Pan viewport so as to place point at top left corner of canvas
 * @param {?} point
 * @return {?}
 */
StaticCanvas.prototype.absolutePan = function(point) {};

/**
 * Pans viewpoint relatively
 * @param {?} point
 * @return {?}
 */
StaticCanvas.prototype.relativePan = function(point) {};

/**
 * Returns <canvas> element corresponding to this instance
 * @return {!HTMLCanvasElement}
 */
StaticCanvas.prototype.getElement = function() {};

/**
 * Returns currently selected object, if any
 * @return {?}
 */
StaticCanvas.prototype.getActiveObject = function() {};

/**
 * Returns currently selected group of object, if any
 * @return {?}
 */
StaticCanvas.prototype.getActiveGroup = function() {};

/**
 * Clears specified context of canvas element
 * \@chainable
 * @param {!CanvasRenderingContext2D} ctx
 * @return {?}
 */
StaticCanvas.prototype.clearContext = function(ctx) {};

/**
 * Returns context of canvas where objects are drawn
 * @return {!CanvasRenderingContext2D}
 */
StaticCanvas.prototype.getContext = function() {};

/**
 * Clears all contexts (background, main, top) of an instance
 * @return {?}
 */
StaticCanvas.prototype.clear = function() {};

/**
 * Renders both the top canvas and the secondary container canvas.
 * \@chainable
 * @param {boolean=} allOnTop
 * @return {?}
 */
StaticCanvas.prototype.renderAll = function(allOnTop) {};

/**
 * Method to render only the top canvas.
 * Also used to render the group selection box.
 * \@chainable
 * @return {?}
 */
StaticCanvas.prototype.renderTop = function() {};

/**
 * Returns coordinates of a center of canvas.
 * Returned value is an object with top and left properties
 * @return {?}
 */
StaticCanvas.prototype.getCenter = function() {};

/**
 * Centers object horizontally.
 * You might need to call `setCoords` on an object after centering, to update controls area.
 * @param {?} object
 * @return {?}
 */
StaticCanvas.prototype.centerObjectH = function(object) {};

/**
 * Centers object vertically.
 * You might need to call `setCoords` on an object after centering, to update controls area.
 * @param {?} object
 * @return {?}
 */
StaticCanvas.prototype.centerObjectV = function(object) {};

/**
 * Centers object vertically and horizontally.
 * You might need to call `setCoords` on an object after centering, to update controls area.
 * @param {?} object
 * @return {?}
 */
StaticCanvas.prototype.centerObject = function(object) {};

/**
 * Returs dataless JSON representation of canvas
 * @param {!Array<?>=} propertiesToInclude
 * @return {string}
 */
StaticCanvas.prototype.toDatalessJSON = function(propertiesToInclude) {};

/**
 * Returns object representation of canvas
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
StaticCanvas.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns dataless object representation of canvas
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
StaticCanvas.prototype.toDatalessObject = function(propertiesToInclude) {};

/**
 * Returns SVG representation of canvas
 * @param {?} options
 * @param {!Function=} reviver
 * @return {string}
 */
StaticCanvas.prototype.toSVG = function(options, reviver) {};

/**
 * Moves an object to the bottom of the stack of drawn objects
 * \@chainable
 * @param {?} object
 * @return {?}
 */
StaticCanvas.prototype.sendToBack = function(object) {};

/**
 * Moves an object to the top of the stack of drawn objects
 * \@chainable
 * @param {?} object
 * @return {?}
 */
StaticCanvas.prototype.bringToFront = function(object) {};

/**
 * Moves an object down in stack of drawn objects
 * \@chainable
 * @param {?} object
 * @return {?}
 */
StaticCanvas.prototype.sendBackwards = function(object) {};

/**
 * Moves an object up in stack of drawn objects
 * \@chainable
 * @param {?} object
 * @return {?}
 */
StaticCanvas.prototype.bringForward = function(object) {};

/**
 * Moves an object to specified level in stack of drawn objects
 * \@chainable
 * @param {?} object
 * @param {number} index
 * @return {?}
 */
StaticCanvas.prototype.moveTo = function(object, index) {};

/**
 * Clears a canvas element and removes all event listeners
 * @return {?}
 */
StaticCanvas.prototype.dispose = function() {};

/**
 * Returns a string representation of an instance
 * @return {string}
 */
StaticCanvas.prototype.toString = function() {};

/**
 * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
 * @param {?=} options
 * @return {string}
 */
StaticCanvas.prototype.toDataURL = function(options) {};

/**
 * Provides a way to check support of some of the canvas methods
 * (either those of HTMLCanvasElement itself, or rendering context)
 * @param {string} methodName
 * @return {boolean}
 */
StaticCanvas.prototype.supports = function(methodName) {};

/**
 * Populates canvas with data from the specified JSON.
 * JSON format must conform to the one of toJSON formats
 *                            and corresponding objects (e.g: {\@link fabric.Image})
 *                            are initialized
 * @param {?} json
 * @param {!Function} callback
 * @param {!Function=} reviver
 * @return {?}
 */
StaticCanvas.prototype.loadFromJSON = function(json, callback, reviver) {};

/**
 * Clones canvas instance
 * @param {?} callback
 * @param {!Array<?>=} properties
 * @return {void}
 */
StaticCanvas.prototype.clone = function(callback, properties) {};

/**
 * Clones canvas instance without cloning existing data.
 * This essentially copies canvas dimensions, clipping properties, etc.
 * but leaves data empty (so that you can populate it with your own)
 * @param {?} callback
 * @return {void}
 */
StaticCanvas.prototype.cloneWithoutData = function(callback) {};

/**
 * Callback; invoked right before object is about to be scaled/rotated
 * @param {?} target
 * @return {void}
 */
StaticCanvas.prototype.onBeforeScaleRotate = function(target) {};

/**
 * Straightens object, then rerenders canvas
 * @param {?} object
 * @return {?}
 */
StaticCanvas.prototype.straightenObject = function(object) {};

/**
 * Same as straightenObject, but animated
 * @param {?} object
 * @return {?}
 */
StaticCanvas.prototype.fxStraightenObject = function(object) {};

/**
 * Provides a way to check support of some of the canvas methods
 * (either those of HTMLCanvasElement itself, or rendering context)
 * @param {string} methodName
 * @return {boolean}
 */
StaticCanvas.supports = function(methodName) {};

/**
 * Returns JSON representation of canvas
 * @param {!Array<?>=} propertiesToInclude
 * @return {string}
 */
StaticCanvas.toJSON = function(propertiesToInclude) {};
/**
 * @extends {IStaticCanvasOptions}
 * @record
 * @struct
 */
function ICanvasOptions() {}
 /** @type {boolean} */
ICanvasOptions.prototype.uniScaleTransform;
 /** @type {boolean} */
ICanvasOptions.prototype.centeredScaling;
 /** @type {boolean} */
ICanvasOptions.prototype.centeredRotation;
 /** @type {boolean} */
ICanvasOptions.prototype.interactive;
 /** @type {boolean} */
ICanvasOptions.prototype.selection;
 /** @type {string} */
ICanvasOptions.prototype.selectionColor;
 /** @type {!Array<?>} */
ICanvasOptions.prototype.selectionDashArray;
 /** @type {string} */
ICanvasOptions.prototype.selectionBorderColor;
 /** @type {number} */
ICanvasOptions.prototype.selectionLineWidth;
 /** @type {string} */
ICanvasOptions.prototype.hoverCursor;
 /** @type {string} */
ICanvasOptions.prototype.moveCursor;
 /** @type {string} */
ICanvasOptions.prototype.defaultCursor;
 /** @type {string} */
ICanvasOptions.prototype.freeDrawingCursor;
 /** @type {string} */
ICanvasOptions.prototype.rotationCursor;
 /** @type {string} */
ICanvasOptions.prototype.containerClass;
 /** @type {boolean} */
ICanvasOptions.prototype.perPixelTargetFind;
 /** @type {number} */
ICanvasOptions.prototype.targetFindTolerance;
 /** @type {boolean} */
ICanvasOptions.prototype.skipTargetFind;
 /** @type {boolean} */
ICanvasOptions.prototype.isDrawingMode;
/**
 * @record
 * @struct
 */
function Canvas() {}
 /** @type {!Array<?>} */
Canvas.prototype._objects;
 /** @type {string} */
Canvas.EMPTY_JSON;

/**
 * Checks if point is contained within an area of given object
 * @param {!Event} e
 * @param {?} target
 * @return {boolean}
 */
Canvas.prototype.containsPoint = function(e, target) {};

/**
 * Deactivates all objects on canvas, removing any active group or object
 * @return {?}
 */
Canvas.prototype.deactivateAll = function() {};

/**
 * Deactivates all objects and dispatches appropriate events
 * @param {!Event=} e
 * @return {?}
 */
Canvas.prototype.deactivateAllWithDispatch = function(e) {};

/**
 * Discards currently active group
 * @param {!Event=} e
 * @return {?}
 */
Canvas.prototype.discardActiveGroup = function(e) {};

/**
 * Discards currently active object
 * \@chainable
 * @param {!Event=} e
 * @return {?}
 */
Canvas.prototype.discardActiveObject = function(e) {};

/**
 * Draws objects' controls (borders/controls)
 * @param {!CanvasRenderingContext2D} ctx
 * @return {void}
 */
Canvas.prototype.drawControls = function(ctx) {};

/**
 * Method that determines what object we are clicking on
 * @param {!MouseEvent} e
 * @param {boolean} skipGroup
 * @return {?}
 */
Canvas.prototype.findTarget = function(e, skipGroup) {};

/**
 * Returns currently active group
 * @return {?}
 */
Canvas.prototype.getActiveGroup = function() {};

/**
 * Returns currently active object
 * @return {?}
 */
Canvas.prototype.getActiveObject = function() {};

/**
 * Returns pointer coordinates relative to canvas.
 * @param {!Event} e
 * @param {boolean=} ignoreZoom
 * @param {!CanvasRenderingContext2D=} upperCanvasEl
 * @return {?}
 */
Canvas.prototype.getPointer = function(e, ignoreZoom, upperCanvasEl) {};

/**
 * Returns context of canvas where object selection is drawn
 * @return {!CanvasRenderingContext2D}
 */
Canvas.prototype.getSelectionContext = function() {};

/**
 * Returns <canvas> element on which object selection is drawn
 * @return {!HTMLCanvasElement}
 */
Canvas.prototype.getSelectionElement = function() {};

/**
 * Returns true if object is transparent at a certain location
 * @param {?} target
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
Canvas.prototype.isTargetTransparent = function(target, x, y) {};

/**
 * Sets active group to a speicified one
 * @param {?} group
 * @param {!Event=} e
 * @return {?}
 */
Canvas.prototype.setActiveGroup = function(group, e) {};

/**
 * Sets given object as the only active object on canvas
 * @param {?} object
 * @param {!Event=} e
 * @return {?}
 */
Canvas.prototype.setActiveObject = function(object, e) {};

/**
 * Set the cursor type of the canvas element
 * @see http://www.w3.org/TR/css3-ui/#cursor
 * @param {string} value
 * @return {void}
 */
Canvas.prototype.setCursor = function(value) {};

/**
 * Removes all event listeners
 * @return {void}
 */
Canvas.prototype.removeListeners = function() {};

/**
 * Provides a way to check support of some of the canvas methods
 * (either those of HTMLCanvasElement itself, or rendering context)
 * @param {string} methodName
 * @return {boolean}
 */
Canvas.supports = function(methodName) {};

/**
 * Returns JSON representation of canvas
 * @param {!Array<?>=} propertiesToInclude
 * @return {string}
 */
Canvas.toJSON = function(propertiesToInclude) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function ICircleOptions() {}
 /** @type {number} */
ICircleOptions.prototype.radius;
 /** @type {number} */
ICircleOptions.prototype.startAngle;
 /** @type {number} */
ICircleOptions.prototype.endAngle;
/**
 * @extends {ICircleOptions}
 * @record
 * @struct
 */
function Circle() {}
 /** @type {!Array<string>} */
Circle.ATTRIBUTE_NAMES;

/**
 * Returns complexity of an instance
 * @return {number}
 */
Circle.prototype.complexity = function() {};

/**
 * Returns horizontal radius of an object (according to how an object is scaled)
 * @return {number}
 */
Circle.prototype.getRadiusX = function() {};

/**
 * Returns vertical radius of an object (according to how an object is scaled)
 * @return {number}
 */
Circle.prototype.getRadiusY = function() {};

/**
 * Sets radius of an object (and updates width accordingly)
 * @param {number} value
 * @return {number}
 */
Circle.prototype.setRadius = function(value) {};

/**
 * Returns object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Circle.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns svg representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Circle.prototype.toSVG = function(reviver) {};

/**
 * Returns Circle instance from an SVG element
 * @param {!SVGElement} element
 * @param {?} options
 * @return {?}
 */
Circle.fromElement = function(element, options) {};

/**
 * Returns Circle instance from an object representation
 * @param {?} object
 * @return {?}
 */
Circle.fromObject = function(object) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function IEllipseOptions() {}
 /** @type {number} */
IEllipseOptions.prototype.rx;
 /** @type {number} */
IEllipseOptions.prototype.ry;
/**
 * @extends {IEllipseOptions}
 * @record
 * @struct
 */
function Ellipse() {}
 /** @type {!Array<string>} */
Ellipse.ATTRIBUTE_NAMES;

/**
 * Returns horizontal radius of an object (according to how an object is scaled)
 * @return {number}
 */
Ellipse.prototype.getRx = function() {};

/**
 * Returns Vertical radius of an object (according to how an object is scaled)
 * @return {number}
 */
Ellipse.prototype.getRy = function() {};

/**
 * Returns object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Ellipse.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns svg representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Ellipse.prototype.toSVG = function(reviver) {};

/**
 * Returns complexity of an instance
 * @return {number}
 */
Ellipse.prototype.complexity = function() {};

/**
 * Returns Ellipse instance from an SVG element
 * @param {!SVGElement} element
 * @param {?=} options
 * @return {?}
 */
Ellipse.fromElement = function(element, options) {};

/**
 * Returns Ellipse instance from an object representation
 * @param {?} object
 * @return {?}
 */
Ellipse.fromObject = function(object) {};
/**
 * @extends {ICollection}
 * @record
 * @struct
 */
function Group() {}

/**
 * @return {?}
 */
Group.prototype.activateAllObjects = function() {};

/**
 * Adds an object to a group; Then recalculates group's dimension, position.
 * \@chainable
 * @param {?} object
 * @return {?}
 */
Group.prototype.addWithUpdate = function(object) {};

/**
 * @param {?} point
 * @return {boolean}
 */
Group.prototype.containsPoint = function(point) {};

/**
 * Destroys a group (restoring state of its objects)
 * \@chainable
 * @return {?}
 */
Group.prototype.destroy = function() {};

/**
 * Returns requested property
 * @param {string} prop
 * @return {?}
 */
Group.prototype.get = function(prop) {};

/**
 * Checks whether this group was moved (since `saveCoords` was called last)
 * @return {boolean}
 */
Group.prototype.hasMoved = function() {};

/**
 * Removes an object from a group; Then recalculates group's dimension, position.
 * \@chainable
 * @param {?} object
 * @return {?}
 */
Group.prototype.removeWithUpdate = function(object) {};

/**
 * Renders instance on a given context
 * @param {!CanvasRenderingContext2D} ctx
 * @return {void}
 */
Group.prototype.render = function(ctx) {};

/**
 * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
 * \@chainable
 * @param {...?} object
 * @return {?}
 */
Group.prototype.remove = function(object) {};

/**
 * Saves coordinates of this instance (to be used together with `hasMoved`)
 * \@saveCoords
 * \@chainable
 * @return {?}
 */
Group.prototype.saveCoords = function() {};

/**
 * Sets coordinates of all group objects
 * \@chainable
 * @return {?}
 */
Group.prototype.setObjectsCoords = function() {};

/**
 * Returns object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Group.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns string represenation of a group
 * @return {string}
 */
Group.prototype.toString = function() {};

/**
 * Returns svg representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Group.prototype.toSVG = function(reviver) {};

/**
 * Returns {\@link fabric.Group} instance from an object representation
 * @param {?} object
 * @param {?} callback
 * @return {void}
 */
Group.fromObject = function(object, callback) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function IImageOptions() {}
 /** @type {string} */
IImageOptions.prototype.crossOrigin;
 /** @type {string} */
IImageOptions.prototype.alignX;
 /** @type {string} */
IImageOptions.prototype.alignY;
 /** @type {string} */
IImageOptions.prototype.meetOrSlice;
 /** @type {!Array<?>} */
IImageOptions.prototype.filters;
/**
 * @extends {IImageOptions}
 * @record
 * @struct
 */
function Image() {}
 /** @type {string} */
Image.CSS_CANVAS;
 /** @type {?} */
Image.filters;

/**
 * @param {(string|!HTMLImageElement)=} element
 * @param {?=} options
 * @return {void}
 */
Image.prototype.initialize = function(element, options) {};

/**
 * Applies filters assigned to this image (from "filters" array)
 * @param {!Function} callback
 * @return {void}
 */
Image.prototype.applyFilters = function(callback) {};

/**
 * Returns a clone of an instance
 * @param {!Function=} callback
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Image.prototype.clone = function(callback, propertiesToInclude) {};

/**
 * Returns complexity of an instance
 * @return {number}
 */
Image.prototype.complexity = function() {};

/**
 * Returns image element which this instance if based on
 * @return {!HTMLImageElement}
 */
Image.prototype.getElement = function() {};

/**
 * Returns original size of an image
 * @return {?}
 */
Image.prototype.getOriginalSize = function() {};

/**
 * Returns source of an image
 * @return {string}
 */
Image.prototype.getSrc = function() {};

/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param {boolean} noTransform
 * @return {void}
 */
Image.prototype.render = function(ctx, noTransform) {};

/**
 * Sets image element for this instance to a specified one.
 * If filters defined they are applied to new image.
 * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
 * @param {!HTMLImageElement} element
 * @param {!Function} callback
 * @param {?} options
 * @return {?}
 */
Image.prototype.setElement = function(element, callback, options) {};

/**
 * Sets crossOrigin value (on an instance and corresponding image element)
 * @param {string} value
 * @return {?}
 */
Image.prototype.setCrossOrigin = function(value) {};

/**
 * Returns object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Image.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns string representation of an instance
 * @return {string}
 */
Image.prototype.toString = function() {};

/**
 * Returns SVG representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Image.prototype.toSVG = function(reviver) {};

/**
 * Sets source of an image
 * @param {string} src
 * @param {!Function=} callback
 * @param {?=} options
 * @return {?}
 */
Image.prototype.setSrc = function(src, callback, options) {};

/**
 * Creates an instance of fabric.Image from an URL string
 * @param {string} url
 * @param {?=} callback
 * @param {?=} objObjects
 * @return {?}
 */
Image.fromURL = function(url, callback, objObjects) {};

/**
 * Creates an instance of fabric.Image from its object representation
 * @param {?} object
 * @param {?} callback
 * @return {void}
 */
Image.fromObject = function(object, callback) {};

/**
 * Returns Image instance from an SVG element
 * @param {!SVGElement} element
 * @param {!Function} callback
 * @param {?=} options
 * @return {void}
 */
Image.fromElement = function(element, callback, options) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function ILineOptions() {}
 /** @type {number} */
ILineOptions.prototype.x1;
 /** @type {number} */
ILineOptions.prototype.x2;
 /** @type {number} */
ILineOptions.prototype.y1;
 /** @type {number} */
ILineOptions.prototype.y2;
/**
 * @extends {ILineOptions}
 * @record
 * @struct
 */
function Line() {}
 /** @type {!Array<string>} */
Line.ATTRIBUTE_NAMES;

/**
 * Returns complexity of an instance
 * @return {number}
 */
Line.prototype.complexity = function() {};

/**
 * @param {!Array<number>=} points
 * @param {?=} options
 * @return {?}
 */
Line.prototype.initialize = function(points, options) {};

/**
 * Returns object representation of an instance
 * \@methd toObject
 * @param {!Array<?>} propertiesToInclude
 * @return {?}
 */
Line.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns SVG representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Line.prototype.toSVG = function(reviver) {};

/**
 * Returns fabric.Line instance from an SVG element
 * @param {!SVGElement} element
 * @param {?=} options
 * @return {?}
 */
Line.fromElement = function(element, options) {};

/**
 * Returns fabric.Line instance from an object representation
 * @param {?} object
 * @return {?}
 */
Line.fromObject = function(object) {};
/**
 * @record
 * @struct
 */
function IObjectOptions() {}
 /** @type {string} */
IObjectOptions.prototype.type;
 /** @type {string} */
IObjectOptions.prototype.originX;
 /** @type {string} */
IObjectOptions.prototype.originY;
 /** @type {number} */
IObjectOptions.prototype.top;
 /** @type {number} */
IObjectOptions.prototype.left;
 /** @type {number} */
IObjectOptions.prototype.width;
 /** @type {number} */
IObjectOptions.prototype.height;
 /** @type {number} */
IObjectOptions.prototype.scaleX;
 /** @type {number} */
IObjectOptions.prototype.scaleY;
 /** @type {boolean} */
IObjectOptions.prototype.flipX;
 /** @type {boolean} */
IObjectOptions.prototype.flipY;
 /** @type {number} */
IObjectOptions.prototype.opacity;
 /** @type {number} */
IObjectOptions.prototype.angle;
 /** @type {number} */
IObjectOptions.prototype.cornerSize;
 /** @type {boolean} */
IObjectOptions.prototype.transparentCorners;
 /** @type {string} */
IObjectOptions.prototype.hoverCursor;
 /** @type {number} */
IObjectOptions.prototype.padding;
 /** @type {string} */
IObjectOptions.prototype.borderColor;
 /** @type {string} */
IObjectOptions.prototype.cornerColor;
 /** @type {boolean} */
IObjectOptions.prototype.centeredScaling;
 /** @type {boolean} */
IObjectOptions.prototype.centeredRotation;
 /** @type {string} */
IObjectOptions.prototype.fill;
 /** @type {string} */
IObjectOptions.prototype.fillRule;
 /** @type {string} */
IObjectOptions.prototype.globalCompositeOperation;
 /** @type {string} */
IObjectOptions.prototype.backgroundColor;
 /** @type {string} */
IObjectOptions.prototype.stroke;
 /** @type {number} */
IObjectOptions.prototype.strokeWidth;
 /** @type {!Array<?>} */
IObjectOptions.prototype.strokeDashArray;
 /** @type {string} */
IObjectOptions.prototype.strokeLineCap;
 /** @type {string} */
IObjectOptions.prototype.strokeLineJoin;
 /** @type {number} */
IObjectOptions.prototype.strokeMiterLimit;
 /** @type {(string|?)} */
IObjectOptions.prototype.shadow;
 /** @type {number} */
IObjectOptions.prototype.borderOpacityWhenMoving;
 /** @type {number} */
IObjectOptions.prototype.borderScaleFactor;
 /** @type {!Array<?>} */
IObjectOptions.prototype.transformMatrix;
 /** @type {number} */
IObjectOptions.prototype.minScaleLimit;
 /** @type {boolean} */
IObjectOptions.prototype.selectable;
 /** @type {boolean} */
IObjectOptions.prototype.evented;
 /** @type {boolean} */
IObjectOptions.prototype.visible;
 /** @type {boolean} */
IObjectOptions.prototype.hasControls;
 /** @type {boolean} */
IObjectOptions.prototype.hasBorders;
 /** @type {boolean} */
IObjectOptions.prototype.hasRotatingPoint;
 /** @type {number} */
IObjectOptions.prototype.rotatingPointOffset;
 /** @type {boolean} */
IObjectOptions.prototype.perPixelTargetFind;
 /** @type {boolean} */
IObjectOptions.prototype.includeDefaultValues;
 /** @type {!Function} */
IObjectOptions.prototype.clipTo;
 /** @type {boolean} */
IObjectOptions.prototype.lockMovementX;
 /** @type {boolean} */
IObjectOptions.prototype.lockMovementY;
 /** @type {boolean} */
IObjectOptions.prototype.lockRotation;
 /** @type {boolean} */
IObjectOptions.prototype.lockScalingX;
 /** @type {boolean} */
IObjectOptions.prototype.lockScalingY;
 /** @type {boolean} */
IObjectOptions.prototype.lockUniScaling;
 /** @type {boolean} */
IObjectOptions.prototype.lockScalingFlip;
 /** @type {string} */
IObjectOptions.prototype.name;
 /** @type {?} */
IObjectOptions.prototype.data;
/**
 * @extends {IObservable}
 * @extends {IObjectOptions}
 * @extends {IObjectAnimation}
 * @record
 * @struct
 */
function Object() {}
 /** @type {string} */
Object.prototype.overlayFill;
 /** @type {!Array<?>} */
Object.prototype.stateProperties;

/**
 * @return {number}
 */
Object.prototype.getCurrentWidth = function() {};

/**
 * @return {number}
 */
Object.prototype.getCurrentHeight = function() {};

/**
 * @return {number}
 */
Object.prototype.getAngle = function() {};

/**
 * Sets "angle" of an instance
 * @param {number} value_or_angle
 * @return {?}
 */
Object.prototype.setAngle = function(value_or_angle) {};

/**
 * @return {string}
 */
Object.prototype.getBorderColor = function() {};

/**
 * @param {string} value
 * @return {?}
 */
Object.prototype.setBorderColor = function(value) {};

/**
 * @return {number}
 */
Object.prototype.getBorderScaleFactor = function() {};

/**
 * @return {number}
 */
Object.prototype.getCornersize = function() {};

/**
 * @param {number} value
 * @return {?}
 */
Object.prototype.setCornersize = function(value) {};

/**
 * @return {string}
 */
Object.prototype.getFill = function() {};

/**
 * @param {string} value
 * @return {?}
 */
Object.prototype.setFill = function(value) {};

/**
 * @return {string}
 */
Object.prototype.getFillRule = function() {};

/**
 * @param {string} value
 * @return {?}
 */
Object.prototype.setFillRule = function(value) {};

/**
 * @return {boolean}
 */
Object.prototype.getFlipX = function() {};

/**
 * @param {boolean} value
 * @return {?}
 */
Object.prototype.setFlipX = function(value) {};

/**
 * @return {boolean}
 */
Object.prototype.getFlipY = function() {};

/**
 * @param {boolean} value
 * @return {?}
 */
Object.prototype.setFlipY = function(value) {};

/**
 * @return {number}
 */
Object.prototype.getHeight = function() {};

/**
 * @param {number} value
 * @return {?}
 */
Object.prototype.setHeight = function(value) {};

/**
 * @return {number}
 */
Object.prototype.getLeft = function() {};

/**
 * @param {number} value
 * @return {?}
 */
Object.prototype.setLeft = function(value) {};

/**
 * @return {number}
 */
Object.prototype.getOpacity = function() {};

/**
 * @param {number} value
 * @return {?}
 */
Object.prototype.setOpacity = function(value) {};

/**
 * @return {string}
 */
Object.prototype.getOverlayFill = function() {};

/**
 * @param {string} value
 * @return {?}
 */
Object.prototype.setOverlayFill = function(value) {};

/**
 * @return {number}
 */
Object.prototype.getScaleX = function() {};

/**
 * @param {number} value
 * @return {?}
 */
Object.prototype.setScaleX = function(value) {};

/**
 * @return {number}
 */
Object.prototype.getScaleY = function() {};

/**
 * @param {number} value
 * @return {?}
 */
Object.prototype.setScaleY = function(value) {};

/**
 * Sets shadow of an object
 * Sets shadow of an object
 * @param {?|string=} options
 * @return {?}
 */
Object.prototype.setShadow = function(options) {};

/**
 * @return {?}
 */
Object.prototype.getShadow = function() {};

/**
 * @return {number}
 */
Object.prototype.getTop = function() {};

/**
 * @param {number} value
 * @return {?}
 */
Object.prototype.setTop = function(value) {};

/**
 * @return {number}
 */
Object.prototype.getWidth = function() {};

/**
 * @param {number} value
 * @return {?}
 */
Object.prototype.setWidth = function(value) {};

/**
 * Sets object's properties from options
 * @param {?} options
 * @return {void}
 */
Object.prototype.setOptions = function(options) {};

/**
 * Transforms context when rendering an object
 * @param {!CanvasRenderingContext2D} ctx
 * @param {boolean} fromLeft
 * @return {void}
 */
Object.prototype.transform = function(ctx, fromLeft) {};

/**
 * Returns an object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Object.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns (dataless) object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Object.prototype.toDatalessObject = function(propertiesToInclude) {};

/**
 * Returns a string representation of an instance
 * @return {string}
 */
Object.prototype.toString = function() {};

/**
 * Basic getter
 * @param {string} property
 * @return {?}
 */
Object.prototype.get = function(property) {};

/**
 * Sets property to a given value.
 * When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls.
 * If you need to update those, call `setCoords()`.
 * Sets property to a given value.
 * When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls.
 * If you need to update those, call `setCoords()`.
 * @param {string|?} key
 * @param {?=} value
 * @return {?}
 */
Object.prototype.set = function(key, value) {};

/**
 * Toggles specified property from `true` to `false` or from `false` to `true`
 * @param {string} property
 * @return {?}
 */
Object.prototype.toggle = function(property) {};

/**
 * Sets sourcePath of an object
 * Sets sourcePath of an object
 * @param {string} value
 * @return {?}
 */
Object.prototype.setSourcePath = function(value) {};

/**
 * Retrieves viewportTransform from Object's canvas if possible
 * @return {boolean}
 */
Object.prototype.getViewportTransform = function() {};

/**
 * Renders an object on a specified context
 * @param {!CanvasRenderingContext2D} ctx
 * @param {boolean=} noTransform
 * @return {void}
 */
Object.prototype.render = function(ctx, noTransform) {};

/**
 * Clones an instance
 * @param {!Function} callback
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Object.prototype.clone = function(callback, propertiesToInclude) {};

/**
 * Creates an instance of fabric.Image out of an object
 * @param {?} callback
 * @return {?}
 */
Object.prototype.cloneAsImage = function(callback) {};

/**
 * Converts an object into a data-url-like string
 * @param {?} options Options object
 * @return {string}
 */
Object.prototype.toDataURL = function(options) {};

/**
 * Returns true if specified type is identical to the type of an instance
 * @param {string} type
 * @return {boolean}
 */
Object.prototype.isType = function(type) {};

/**
 * Returns complexity of an instance
 * @return {number}
 */
Object.prototype.complexity = function() {};

/**
 * Returns a JSON representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Object.prototype.toJSON = function(propertiesToInclude) {};

/**
 * Sets gradient (fill or stroke) of an object
 * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
 * @param {string} property
 * @param {?} options
 * @return {?}
 */
Object.prototype.setGradient = function(property, options) {};

/**
 * Sets pattern fill of an object
 * @param {?} options
 * @return {?}
 */
Object.prototype.setPatternFill = function(options) {};

/**
 * Sets "color" of an instance (alias of `set('fill', )`)
 * @param {string} color
 * @return {?}
 */
Object.prototype.setColor = function(color) {};

/**
 * Sets "angle" of an instance
 * @param {number} angle
 * @return {?}
 */
Object.prototype.rotate = function(angle) {};

/**
 * Centers object horizontally on canvas to which it was added last.
 * You might need to call `setCoords` on an object after centering, to update controls area.
 * @return {void}
 */
Object.prototype.centerH = function() {};

/**
 * Centers object vertically on canvas to which it was added last.
 * You might need to call `setCoords` on an object after centering, to update controls area.
 * @return {void}
 */
Object.prototype.centerV = function() {};

/**
 * Centers object vertically and horizontally on canvas to which is was added last
 * You might need to call `setCoords` on an object after centering, to update controls area.
 * @return {void}
 */
Object.prototype.center = function() {};

/**
 * Removes object from canvas to which it was added last
 * @return {?}
 */
Object.prototype.remove = function() {};

/**
 * Returns coordinates of a pointer relative to an object
 * @param {!Event} e
 * @param {?} pointer
 * @return {?}
 */
Object.prototype.getLocalPointer = function(e, pointer) {};

/**
 * Returns styles-string for svg-export
 * @return {string}
 */
Object.prototype.getSvgStyles = function() {};

/**
 * Returns transform-string for svg-export
 * @return {string}
 */
Object.prototype.getSvgTransform = function() {};

/**
 * Returns transform-string for svg-export from the transform matrix of single elements
 * @return {string}
 */
Object.prototype.getSvgTransformMatrix = function() {};

/**
 * Returns true if object state (one of its state properties) was changed
 * @return {boolean}
 */
Object.prototype.hasStateChanged = function() {};

/**
 * Saves state of an object
 * @param {?=} options
 * @return {?}
 */
Object.prototype.saveState = function(options) {};

/**
 * Setups state of an object
 * @return {?}
 */
Object.prototype.setupState = function() {};

/**
 * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
 * @return {?}
 */
Object.prototype.straighten = function() {};

/**
 * Same as straighten but with animation
 * @param {?} callbacks
 * @return {?}
 */
Object.prototype.fxStraighten = function(callbacks) {};

/**
 * Moves an object up in stack of drawn objects
 * @param {boolean=} intersecting
 * @return {?}
 */
Object.prototype.bringForward = function(intersecting) {};

/**
 * Moves an object to the top of the stack of drawn objects
 * @return {?}
 */
Object.prototype.bringToFront = function() {};

/**
 * Moves an object down in stack of drawn objects
 * @param {boolean=} intersecting
 * @return {?}
 */
Object.prototype.sendBackwards = function(intersecting) {};

/**
 * Moves an object to the bottom of the stack of drawn objects
 * @return {?}
 */
Object.prototype.sendToBack = function() {};

/**
 * Moves an object to specified level in stack of drawn objects
 * @param {number} index
 * @return {?}
 */
Object.prototype.moveTo = function(index) {};

/**
 * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
 * @param {?} point
 * @param {string} originX
 * @param {string} originY
 * @return {?}
 */
Object.prototype.translateToCenterPoint = function(point, originX, originY) {};

/**
 * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
 * @param {?} center
 * @param {string} originX
 * @param {string} originY
 * @return {?}
 */
Object.prototype.translateToOriginPoint = function(center, originX, originY) {};

/**
 * Returns the real center coordinates of the object
 * @return {?}
 */
Object.prototype.getCenterPoint = function() {};

/**
 * Returns the coordinates of the object as if it has a different origin
 * @return {?}
 */
Object.prototype.getPointByOrigin = function() {};

/**
 * Returns the point in local coordinates
 * @param {?} point
 * @param {string} originX
 * @param {string} originY
 * @return {?}
 */
Object.prototype.toLocalPoint = function(point, originX, originY) {};

/**
 * Sets the position of the object taking into consideration the object's origin
 * @param {?} pos
 * @param {string} originX
 * @param {string} originY
 * @return {void}
 */
Object.prototype.setPositionByOrigin = function(pos, originX, originY) {};

/**
 * @param {string} to
 * @return {void}
 */
Object.prototype.adjustPosition = function(to) {};

/**
 * -
 * Draws borders of an object's bounding box.
 * Requires public properties: width, height
 * Requires public options: padding, borderColor
 * @param {!CanvasRenderingContext2D} context
 * @return {?}
 */
Object.prototype.drawBorders = function(context) {};

/**
 * Draws corners of an object's bounding box.
 * Requires public properties: width, height
 * Requires public options: cornerSize, padding
 * @param {!CanvasRenderingContext2D} context
 * @return {?}
 */
Object.prototype.drawCorners = function(context) {};

/**
 * Returns true if the specified control is visible, false otherwise.
 * @param {string} controlName
 * @return {boolean}
 */
Object.prototype.isControlVisible = function(controlName) {};

/**
 * Sets the visibility of the specified control.
 * @param {string} controlName
 * @param {boolean} visible
 * @return {?}
 */
Object.prototype.setControlVisible = function(controlName, visible) {};

/**
 * Sets the visibility state of object controls.
 * @param {?=} options
 * @return {?}
 */
Object.prototype.setControlsVisibility = function(options) {};

/**
 * Sets corner position coordinates based on current angle, width and height
 * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords
 * @return {?}
 */
Object.prototype.setCoords = function() {};

/**
 * Returns coordinates of object's bounding rectangle (left, top, width, height)
 * @return {?}
 */
Object.prototype.getBoundingRect = function() {};

/**
 * Checks if object is fully contained within area of another object
 * @param {?} other
 * @return {boolean}
 */
Object.prototype.isContainedWithinObject = function(other) {};

/**
 * Checks if object is fully contained within area formed by 2 points
 * @param {?} pointTL
 * @param {?} pointBR
 * @return {boolean}
 */
Object.prototype.isContainedWithinRect = function(pointTL, pointBR) {};

/**
 * Checks if point is inside the object
 * @param {?} point
 * @return {boolean}
 */
Object.prototype.containsPoint = function(point) {};

/**
 * Scales an object (equally by x and y)
 * @param {number} value
 * @return {?}
 */
Object.prototype.scale = function(value) {};

/**
 * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
 * @param {number} value
 * @return {?}
 */
Object.prototype.scaleToHeight = function(value) {};

/**
 * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
 * @param {number} value
 * @return {?}
 */
Object.prototype.scaleToWidth = function(value) {};

/**
 * Checks if object intersects with another object
 * @param {?} other
 * @return {boolean}
 */
Object.prototype.intersectsWithObject = function(other) {};

/**
 * Checks if object intersects with an area formed by 2 points
 * @param {?} pointTL
 * @param {?} pointBR
 * @return {boolean}
 */
Object.prototype.intersectsWithRect = function(pointTL, pointBR) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function IPathOptions() {}
 /** @type {!Array<?>} */
IPathOptions.prototype.path;
 /** @type {number} */
IPathOptions.prototype.minX;
 /** @type {number} */
IPathOptions.prototype.minY;
/**
 * @extends {IPathOptions}
 * @record
 * @struct
 */
function IPath() {}

/**
 * @param {!Array<?>=} path
 * @param {?=} options
 * @return {?}
 */
IPath.prototype.initialize = function(path, options) {};

/**
 * Returns number representation of an instance complexity
 * @return {number}
 */
IPath.prototype.complexity = function() {};

/**
 * Renders path on a specified context
 * @param {!CanvasRenderingContext2D} ctx
 * @param {boolean} noTransform
 * @return {void}
 */
IPath.prototype.render = function(ctx, noTransform) {};

/**
 * Returns dataless object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
IPath.prototype.toDatalessObject = function(propertiesToInclude) {};

/**
 * Returns object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
IPath.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns string representation of an instance
 * @return {string}
 */
IPath.prototype.toString = function() {};

/**
 * Returns svg representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
IPath.prototype.toSVG = function(reviver) {};

/**
 * Creates an instance of fabric.Path from an SVG <path> element
 * @param {!SVGElement} element
 * @param {?} callback
 * @param {?=} options
 * @return {void}
 */
IPath.fromElement = function(element, callback, options) {};

/**
 * Creates an instance of fabric.Path from an object
 * @param {?} object
 * @param {?} callback
 * @return {void}
 */
IPath.fromObject = function(object, callback) {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!Array<?>} paths
 * @param {?=} options
 */
function PathGroup(paths, options) {}

/**
 * @param {!Array<?>} paths
 * @param {?=} options
 * @return {void}
 */
PathGroup.prototype.initialize = function(paths, options) {};

/**
 * Returns number representation of object's complexity
 * @return {number}
 */
PathGroup.prototype.complexity = function() {};

/**
 * Returns true if all paths in this group are of same color
 * @return {boolean}
 */
PathGroup.prototype.isSameColor = function() {};

/**
 * Renders this group on a specified context
 * @param {!CanvasRenderingContext2D} ctx
 * @return {void}
 */
PathGroup.prototype.render = function(ctx) {};

/**
 * Returns dataless object representation of this path group
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
PathGroup.prototype.toDatalessObject = function(propertiesToInclude) {};

/**
 * Returns object representation of this path group
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
PathGroup.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns a string representation of this path group
 * @return {string}
 */
PathGroup.prototype.toString = function() {};

/**
 * Returns svg representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
PathGroup.prototype.toSVG = function(reviver) {};

/**
 * Returns all paths in this path group
 * @return {!Array<?>}
 */
PathGroup.prototype.getObjects = function() {};

/**
 * Creates fabric.PathGroup instance from an object representation
 * \@memberOf fabric.PathGroup
 * @param {?} object
 * @param {?=} callback
 * @return {?|void}
 */
PathGroup.fromObject = function(object, callback) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function IPolygonOptions() {}
 /** @type {!Array<?>} */
IPolygonOptions.prototype.points;
 /** @type {number} */
IPolygonOptions.prototype.minX;
 /** @type {number} */
IPolygonOptions.prototype.minY;
/**
 * @extends {IPolygonOptions}
 * @record
 * @struct
 */
function Polygon() {}
 /** @type {!Array<string>} */
Polygon.ATTRIBUTE_NAMES;

/**
 * Returns complexity of an instance
 * @return {number}
 */
Polygon.prototype.complexity = function() {};

/**
 * Returns object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Polygon.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns svg representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Polygon.prototype.toSVG = function(reviver) {};

/**
 * Returns Polygon instance from an SVG element
 * @param {!SVGElement} element
 * @param {?=} options
 * @return {?}
 */
Polygon.fromElement = function(element, options) {};

/**
 * Returns fabric.Polygon instance from an object representation
 * @param {?} object
 * @return {?}
 */
Polygon.fromObject = function(object) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function IPolylineOptions() {}
 /** @type {!Array<?>} */
IPolylineOptions.prototype.points;
 /** @type {number} */
IPolylineOptions.prototype.minX;
 /** @type {number} */
IPolylineOptions.prototype.minY;
/**
 * @extends {IPolylineOptions}
 * @record
 * @struct
 */
function Polyline() {}
 /** @type {!Array<string>} */
Polyline.ATTRIBUTE_NAMES;

/**
 * @param {!Array<?>} points
 * @param {?=} options
 * @return {void}
 */
Polyline.prototype.initialize = function(points, options) {};

/**
 * Returns complexity of an instance
 * @return {number}
 */
Polyline.prototype.complexity = function() {};

/**
 * Returns object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Polyline.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns SVG representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Polyline.prototype.toSVG = function(reviver) {};

/**
 * Returns Polyline  instance from an SVG element
 * @param {!SVGElement} element
 * @param {?=} options
 * @return {?}
 */
Polyline.fromElement = function(element, options) {};

/**
 * Returns fabric.Polyline instance from an object representation
 * @param {?} object
 * @return {?}
 */
Polyline.fromObject = function(object) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function IRectOptions() {}
 /** @type {number} */
IRectOptions.prototype.x;
 /** @type {number} */
IRectOptions.prototype.y;
 /** @type {number} */
IRectOptions.prototype.rx;
 /** @type {number} */
IRectOptions.prototype.ry;
/**
 * @extends {IRectOptions}
 * @record
 * @struct
 */
function Rect() {}
 /** @type {!Array<string>} */
Rect.ATTRIBUTE_NAMES;

/**
 * @param {!Array<number>=} points
 * @param {?=} options
 * @return {?}
 */
Rect.prototype.initialize = function(points, options) {};

/**
 * Returns complexity of an instance
 * @return {number}
 */
Rect.prototype.complexity = function() {};

/**
 * Returns object representation of an instance
 * @param {!Array<?>} propertiesToInclude
 * @return {?}
 */
Rect.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns svg representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Rect.prototype.toSVG = function(reviver) {};

/**
 * Returns Rect instance from an SVG element
 * @param {!SVGElement} element
 * @param {?=} options
 * @return {?}
 */
Rect.fromElement = function(element, options) {};

/**
 * Returns Rect instance from an object representation
 * @param {?} object
 * @return {?}
 */
Rect.fromObject = function(object) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function ITextOptions() {}
 /** @type {number} */
ITextOptions.prototype.fontSize;
 /** @type {(string|number)} */
ITextOptions.prototype.fontWeight;
 /** @type {string} */
ITextOptions.prototype.fontFamily;
 /** @type {string} */
ITextOptions.prototype.textDecoration;
 /** @type {string} */
ITextOptions.prototype.textAlign;
 /** @type {string} */
ITextOptions.prototype.fontStyle;
 /** @type {number} */
ITextOptions.prototype.lineHeight;
 /** @type {string} */
ITextOptions.prototype.stroke;
 /** @type {(string|?)} */
ITextOptions.prototype.shadow;
 /** @type {string} */
ITextOptions.prototype.textBackgroundColor;
 /** @type {string} */
ITextOptions.prototype.path;
 /** @type {boolean} */
ITextOptions.prototype.useNative;
 /** @type {string} */
ITextOptions.prototype.text;
/**
 * @extends {ITextOptions}
 * @record
 * @struct
 */
function Text() {}
 /** @type {!Array<string>} */
Text.ATTRIBUTE_NAMES;
 /** @type {number} */
Text.DEFAULT_SVG_FONT_SIZE;

/**
 * Returns complexity of an instance
 * @return {number}
 */
Text.prototype.complexity = function() {};

/**
 * Returns string representation of an instance
 * @return {string}
 */
Text.prototype.toString = function() {};

/**
 * Renders text instance on a specified context
 * @param {!CanvasRenderingContext2D} ctx
 * @param {boolean} noTransform
 * @return {void}
 */
Text.prototype.render = function(ctx, noTransform) {};

/**
 * Returns object representation of an instance
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
Text.prototype.toObject = function(propertiesToInclude) {};

/**
 * Returns SVG representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Text.prototype.toSVG = function(reviver) {};

/**
 * Retrieves object's fontSize
 * @return {number}
 */
Text.prototype.getFontSize = function() {};

/**
 * Sets object's fontSize
 * @param {number} fontSize
 * @return {?}
 */
Text.prototype.setFontSize = function(fontSize) {};

/**
 * Retrieves object's fontWeight
 * @return {(string|number)}
 */
Text.prototype.getFontWeight = function() {};

/**
 * Sets object's fontWeight
 * @param {(string|number)} fontWeight
 * @return {?}
 */
Text.prototype.setFontWeight = function(fontWeight) {};

/**
 * Retrieves object's fontFamily
 * @return {string}
 */
Text.prototype.getFontFamily = function() {};

/**
 * Sets object's fontFamily
 * @param {string} fontFamily
 * @return {?}
 */
Text.prototype.setFontFamily = function(fontFamily) {};

/**
 * Retrieves object's text
 * @return {string}
 */
Text.prototype.getText = function() {};

/**
 * Sets object's text
 * @param {string} text
 * @return {?}
 */
Text.prototype.setText = function(text) {};

/**
 * Retrieves object's textDecoration
 * @return {string}
 */
Text.prototype.getTextDecoration = function() {};

/**
 * Sets object's textDecoration
 * @param {string} textDecoration
 * @return {?}
 */
Text.prototype.setTextDecoration = function(textDecoration) {};

/**
 * Retrieves object's fontStyle
 * @return {string}
 */
Text.prototype.getFontStyle = function() {};

/**
 * Sets object's fontStyle
 * @param {string} fontStyle
 * @return {?}
 */
Text.prototype.setFontStyle = function(fontStyle) {};

/**
 * Retrieves object's lineHeight
 * @return {number}
 */
Text.prototype.getLineHeight = function() {};

/**
 * Sets object's lineHeight
 * @param {number} lineHeight
 * @return {?}
 */
Text.prototype.setLineHeight = function(lineHeight) {};

/**
 * Retrieves object's textAlign
 * @return {string}
 */
Text.prototype.getTextAlign = function() {};

/**
 * Sets object's textAlign
 * @param {string} textAlign
 * @return {?}
 */
Text.prototype.setTextAlign = function(textAlign) {};

/**
 * Retrieves object's textBackgroundColor
 * @return {string}
 */
Text.prototype.getTextBackgroundColor = function() {};

/**
 * Sets object's textBackgroundColor
 * @param {string} textBackgroundColor
 * @return {?}
 */
Text.prototype.setTextBackgroundColor = function(textBackgroundColor) {};

/**
 * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
 * @param {!SVGElement} element
 * @param {?=} options
 * @return {?}
 */
Text.fromElement = function(element, options) {};

/**
 * Returns fabric.Text instance from an object representation
 * @param {?} object
 * @return {?}
 */
Text.fromObject = function(object) {};
/**
 * @extends {IObjectOptions}
 * @extends {ITextOptions}
 * @record
 * @struct
 */
function IITextOptions() {}
 /** @type {number} */
IITextOptions.prototype.selectionStart;
 /** @type {number} */
IITextOptions.prototype.selectionEnd;
 /** @type {string} */
IITextOptions.prototype.selectionColor;
 /** @type {boolean} */
IITextOptions.prototype.isEditing;
 /** @type {boolean} */
IITextOptions.prototype.editable;
 /** @type {string} */
IITextOptions.prototype.editingBorderColor;
 /** @type {number} */
IITextOptions.prototype.cursorWidth;
 /** @type {string} */
IITextOptions.prototype.cursorColor;
 /** @type {number} */
IITextOptions.prototype.cursorDelay;
 /** @type {number} */
IITextOptions.prototype.cursorDuration;
 /** @type {?} */
IITextOptions.prototype.styles;
 /** @type {boolean} */
IITextOptions.prototype.caching;
/**
 * @extends {IITextOptions}
 * @record
 * @struct
 */
function IText() {}

/**
 * Returns true if object has no styling
 * @return {boolean}
 */
IText.prototype.isEmptyStyles = function() {};

/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param {boolean} noTransform
 * @return {void}
 */
IText.prototype.render = function(ctx, noTransform) {};

/**
 * Returns object representation of an instance
 * \@method toObject
 * @param {!Array<?>=} propertiesToInclude
 * @return {?}
 */
IText.prototype.toObject = function(propertiesToInclude) {};

/**
 * @param {string} value
 * @return {?}
 */
IText.prototype.setText = function(value) {};

/**
 * Sets selection start (left boundary of a selection)
 * @param {number} index
 * @return {void}
 */
IText.prototype.setSelectionStart = function(index) {};

/**
 * Sets selection end (right boundary of a selection)
 * @param {number} index
 * @return {void}
 */
IText.prototype.setSelectionEnd = function(index) {};

/**
 * Gets style of a current selection/cursor (at the start position)
 * @param {number} startIndex
 * @param {number} endIndex
 * @return {?}
 */
IText.prototype.getSelectionStyles = function(startIndex, endIndex) {};

/**
 * Sets style of a current selection
 * \@chainable
 * @param {?} styles
 * @return {?}
 */
IText.prototype.setSelectionStyles = function(styles) {};

/**
 * Renders cursor or selection (depending on what exists)
 * @return {void}
 */
IText.prototype.renderCursorOrSelection = function() {};

/**
 * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
 * @param {number=} selectionStart
 * @return {void}
 */
IText.prototype.get2DCursorLocation = function(selectionStart) {};

/**
 * Returns complete style of char at the current cursor
 * @param {number} lineIndex
 * @param {number} charIndex
 * @return {?}
 */
IText.prototype.getCurrentCharStyle = function(lineIndex, charIndex) {};

/**
 * Returns fontSize of char at the current cursor
 * @param {number} lineIndex
 * @param {number} charIndex
 * @return {number}
 */
IText.prototype.getCurrentCharFontSize = function(lineIndex, charIndex) {};

/**
 * Returns color (fill) of char at the current cursor
 * @param {number} lineIndex
 * @param {number} charIndex
 * @return {string}
 */
IText.prototype.getCurrentCharColor = function(lineIndex, charIndex) {};

/**
 * Renders cursor
 * @param {?} boundaries
 * @return {void}
 */
IText.prototype.renderCursor = function(boundaries) {};

/**
 * Renders text selection
 * @param {!Array<string>} chars
 * @param {?} boundaries
 * @return {void}
 */
IText.prototype.renderSelection = function(chars, boundaries) {};

/**
 * Initializes all the interactive behavior of IText
 * @return {void}
 */
IText.prototype.initBehavior = function() {};

/**
 * Initializes "selected" event handler
 * @return {void}
 */
IText.prototype.initSelectedHandler = function() {};

/**
 * Initializes "added" event handler
 * @return {void}
 */
IText.prototype.initAddedHandler = function() {};

/**
 * @return {void}
 */
IText.prototype.initRemovedHandler = function() {};

/**
 * Initializes delayed cursor
 * @param {boolean} restart
 * @return {void}
 */
IText.prototype.initDelayedCursor = function(restart) {};

/**
 * Aborts cursor animation and clears all timeouts
 * @return {void}
 */
IText.prototype.abortCursorAnimation = function() {};

/**
 * Selects entire text
 * @return {void}
 */
IText.prototype.selectAll = function() {};

/**
 * Returns selected text
 * @return {string}
 */
IText.prototype.getSelectedText = function() {};

/**
 * Find new selection index representing start of current word according to current selection index
 * @param {number} startFrom
 * @return {number}
 */
IText.prototype.findWordBoundaryLeft = function(startFrom) {};

/**
 * Find new selection index representing end of current word according to current selection index
 * @param {number} startFrom
 * @return {number}
 */
IText.prototype.findWordBoundaryRight = function(startFrom) {};

/**
 * Find new selection index representing start of current line according to current selection index
 * @param {number} startFrom
 * @return {number}
 */
IText.prototype.findLineBoundaryLeft = function(startFrom) {};

/**
 * Find new selection index representing end of current line according to current selection index
 * @param {number} startFrom
 * @return {number}
 */
IText.prototype.findLineBoundaryRight = function(startFrom) {};

/**
 * Returns number of newlines in selected text
 * @return {number}
 */
IText.prototype.getNumNewLinesInSelectedText = function() {};

/**
 * Finds index corresponding to beginning or end of a word
 * @param {number} selectionStart
 * @param {number} direction
 * @return {number}
 */
IText.prototype.searchWordBoundary = function(selectionStart, direction) {};

/**
 * Selects a word based on the index
 * @param {number} selectionStart
 * @return {void}
 */
IText.prototype.selectWord = function(selectionStart) {};

/**
 * Selects a line based on the index
 * @param {number} selectionStart
 * @return {void}
 */
IText.prototype.selectLine = function(selectionStart) {};

/**
 * Enters editing state
 * @return {?}
 */
IText.prototype.enterEditing = function() {};

/**
 * Initializes "mousemove" event handler
 * @return {void}
 */
IText.prototype.initMouseMoveHandler = function() {};

/**
 * Exits from editing state
 * \@chainable
 * @return {?}
 */
IText.prototype.exitEditing = function() {};

/**
 * Inserts a character where cursor is (replacing selection if one exists)
 * @param {string} _chars
 * @param {boolean=} useCopiedStyle
 * @return {void}
 */
IText.prototype.insertChars = function(_chars, useCopiedStyle) {};

/**
 * Inserts new style object
 * @param {number} lineIndex
 * @param {number} charIndex
 * @param {boolean} isEndOfLine
 * @return {void}
 */
IText.prototype.insertNewlineStyleObject = function(lineIndex, charIndex, isEndOfLine) {};

/**
 * Inserts style object for a given line/char index
 * @param {number} lineIndex
 * @param {number} charIndex
 * @param {boolean} isEndOfLine
 * @return {void}
 */
IText.prototype.insertCharStyleObject = function(lineIndex, charIndex, isEndOfLine) {};

/**
 * Inserts style object(s)
 * @param {string} _chars
 * @param {boolean} isEndOfLine
 * @param {boolean=} useCopiedStyle
 * @return {void}
 */
IText.prototype.insertStyleObjects = function(_chars, isEndOfLine, useCopiedStyle) {};

/**
 * Shifts line styles up or down
 * @param {number} lineIndex
 * @param {number} offset
 * @return {void}
 */
IText.prototype.shiftLineStyles = function(lineIndex, offset) {};

/**
 * Removes style object
 * @param {boolean} isBeginningOfLine
 * @param {number=} index
 * @return {void}
 */
IText.prototype.removeStyleObject = function(isBeginningOfLine, index) {};

/**
 * Inserts new line
 * @return {void}
 */
IText.prototype.insertNewline = function() {};

/**
 * Returns fabric.IText instance from an object representation
 * @param {?} object
 * @return {?}
 */
IText.fromObject = function(object) {};
/**
 * @extends {IObjectOptions}
 * @record
 * @struct
 */
function ITriangleOptions() {}

/**
 * @constructor
 * @struct
 * Constructor
 * @param {?=} options
 */
function Triangle(options) {}

/**
 * Returns complexity of an instance
 * @return {number}
 */
Triangle.prototype.complexity = function() {};

/**
 * Returns SVG representation of an instance
 * @param {!Function=} reviver
 * @return {string}
 */
Triangle.prototype.toSVG = function(reviver) {};

/**
 * Returns Triangle instance from an object representation
 * @param {?} object
 * @return {?}
 */
Triangle.fromObject = function(object) {};
/**
 * @record
 * @struct
 */
function IAllFilters() {}
 /** @type {?} */
IAllFilters.prototype.BaseFilter;
 /** @type {?} */
IAllFilters.prototype.Blend;
 /** @type {?} */
IAllFilters.prototype.Brightness;
 /** @type {?} */
IAllFilters.prototype.Convolute;
 /** @type {?} */
IAllFilters.prototype.GradientTransparency;
 /** @type {?} */
IAllFilters.prototype.Grayscale;
 /** @type {?} */
IAllFilters.prototype.Invert;
 /** @type {?} */
IAllFilters.prototype.Mask;
 /** @type {?} */
IAllFilters.prototype.Multiply;
 /** @type {?} */
IAllFilters.prototype.Noise;
 /** @type {?} */
IAllFilters.prototype.Pixelate;
 /** @type {?} */
IAllFilters.prototype.RemoveWhite;
 /** @type {?} */
IAllFilters.prototype.Resize;
 /** @type {?} */
IAllFilters.prototype.Sepia2;
 /** @type {?} */
IAllFilters.prototype.Sepia;
 /** @type {?} */
IAllFilters.prototype.Tint;
/**
 * @record
 * @struct
 */
function IBaseFilter() {}

/**
 * Sets filter's properties from options
 * @param {?=} options
 * @return {void}
 */
IBaseFilter.prototype.setOptions = function(options) {};

/**
 * Returns object representation of an instance
 * @return {?}
 */
IBaseFilter.prototype.toObject = function() {};

/**
 * Returns a JSON representation of an instance
 * @return {string}
 */
IBaseFilter.prototype.toJSON = function() {};
/**
 * @extends {IBaseFilter}
 * @record
 * @struct
 */
function IBlendFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IBlendFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @extends {IBaseFilter}
 * @record
 * @struct
 */
function IBrightnessFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IBrightnessFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @extends {IBaseFilter}
 * @record
 * @struct
 */
function IConvoluteFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IConvoluteFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function IGradientTransparencyFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IGradientTransparencyFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function IGrayscaleFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IGrayscaleFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function IInvertFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IInvertFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function IMaskFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IMaskFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function IMultiplyFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IMultiplyFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function INoiseFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
INoiseFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function IPixelateFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IPixelateFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function IRemoveWhiteFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IRemoveWhiteFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function IResizeFilter() {}
 /** @type {string} */
IResizeFilter.prototype.resizeType;
 /** @type {number} */
IResizeFilter.prototype.scaleX;
 /** @type {number} */
IResizeFilter.prototype.scaleY;
 /** @type {number} */
IResizeFilter.prototype.lanczosLobes;

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
IResizeFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function ISepiaFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
ISepiaFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function ISepia2Filter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
ISepia2Filter.prototype.applyTo = function(canvasEl) {};
/**
 * @record
 * @struct
 */
function ITintFilter() {}

/**
 * Applies filter to canvas element
 * @param {!HTMLCanvasElement} canvasEl
 * @return {void}
 */
ITintFilter.prototype.applyTo = function(canvasEl) {};
/**
 * @constructor
 * @struct
 */
function BaseBrush() {}
 /** @type {string} */
BaseBrush.prototype.color;
 /** @type {number} */
BaseBrush.prototype.width;
 /** @type {(string|?)} */
BaseBrush.prototype.shadow;
 /** @type {string} */
BaseBrush.prototype.strokeLineCap;
 /** @type {string} */
BaseBrush.prototype.strokeLineJoin;
 /** @type {!Array<?>} */
BaseBrush.prototype.strokeDashArray;

/**
 * Sets shadow of an object
 * @param {?} options
 * @return {?}
 */
BaseBrush.prototype.setShadow = function(options) {};
/**
 * @constructor
 * @struct
 */
function CircleBrush() {}
 /** @type {number} */
CircleBrush.prototype.width;

/**
 * Invoked inside on mouse down and mouse move
 * @param {?} pointer
 * @return {void}
 */
CircleBrush.prototype.drawDot = function(pointer) {};

/**
 * @param {?} pointer
 * @return {?}
 */
CircleBrush.prototype.addPoint = function(pointer) {};
/**
 * @constructor
 * @struct
 */
function SprayBrush() {}
 /** @type {number} */
SprayBrush.prototype.width;
 /** @type {number} */
SprayBrush.prototype.density;
 /** @type {number} */
SprayBrush.prototype.dotWidth;
 /** @type {number} */
SprayBrush.prototype.dotWidthVariance;
 /** @type {boolean} */
SprayBrush.prototype.randomOpacity;
 /** @type {boolean} */
SprayBrush.prototype.optimizeOverlapping;

/**
 * @param {?} pointer
 * @return {void}
 */
SprayBrush.prototype.addSprayChunk = function(pointer) {};
/**
 * @constructor
 * @struct
 */
function PatternBrush() {}

/**
 * @return {!HTMLCanvasElement}
 */
PatternBrush.prototype.getPatternSrc = function() {};

/**
 * @return {string}
 */
PatternBrush.prototype.getPatternSrcFunction = function() {};

/**
 * Creates "pattern" instance property
 * @return {?}
 */
PatternBrush.prototype.getPattern = function() {};

/**
 * Creates path
 * @param {string} pathData
 * @return {?}
 */
PatternBrush.prototype.createPath = function(pathData) {};
/**
 * @constructor
 * @struct
 */
function PencilBrush() {}

/**
 * Converts points to SVG path
 * @param {!Array<?>} points
 * @param {number=} minX
 * @param {number=} minY
 * @return {!Array<string>}
 */
PencilBrush.prototype.convertPointsToSVGPath = function(points, minX, minY) {};

/**
 * Creates fabric.Path object to add on canvas
 * @param {string} pathData
 * @return {?}
 */
PencilBrush.prototype.createPath = function(pathData) {};
/**
 * @record
 * @struct
 */
function IUtilAnimationOptions() {}
 /** @type {number} */
IUtilAnimationOptions.prototype.startValue;
 /** @type {number} */
IUtilAnimationOptions.prototype.endValue;
 /** @type {number} */
IUtilAnimationOptions.prototype.byValue;
 /** @type {number} */
IUtilAnimationOptions.prototype.duration;
 /** @type {!Function} */
IUtilAnimationOptions.prototype.onChange;
 /** @type {!Function} */
IUtilAnimationOptions.prototype.onComplete;
 /** @type {!Function} */
IUtilAnimationOptions.prototype.easing;
/**
 * @record
 * @struct
 */
function IUtilAnimation() {}

/**
 * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
 * @param {?=} options
 * @return {void}
 */
IUtilAnimation.prototype.animate = function(options) {};

/**
 * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
 * @param {!Function} callback
 * @return {void}
 */
IUtilAnimation.prototype.requestAnimFrame = function(callback) {};

/** @typedef {?} */
var IUtilAminEaseFunction;
/**
 * @record
 * @struct
 */
function IUtilAnimEase() {}
 /** @type {?} */
IUtilAnimEase.prototype.easeInBack;
 /** @type {?} */
IUtilAnimEase.prototype.easeInBounce;
 /** @type {?} */
IUtilAnimEase.prototype.easeInCirc;
 /** @type {?} */
IUtilAnimEase.prototype.easeInCubic;
 /** @type {?} */
IUtilAnimEase.prototype.easeInElastic;
 /** @type {?} */
IUtilAnimEase.prototype.easeInExpo;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutBack;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutBounce;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutCirc;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutCubic;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutElastic;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutExpo;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutQuad;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutQuart;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutQuint;
 /** @type {?} */
IUtilAnimEase.prototype.easeInOutSine;
 /** @type {?} */
IUtilAnimEase.prototype.easeInQuad;
 /** @type {?} */
IUtilAnimEase.prototype.easeInQuart;
 /** @type {?} */
IUtilAnimEase.prototype.easeInQuint;
 /** @type {?} */
IUtilAnimEase.prototype.easeInSine;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutBack;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutBounce;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutCirc;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutCubic;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutElastic;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutExpo;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutQuad;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutQuart;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutQuint;
 /** @type {?} */
IUtilAnimEase.prototype.easeOutSine;
/**
 * @record
 * @struct
 */
function IUtilArc() {}

/**
 * Draws arc
 * @param {!CanvasRenderingContext2D} ctx
 * @param {number} fx
 * @param {number} fy
 * @param {!Array<number>} coords
 * @return {void}
 */
IUtilArc.prototype.drawArc = function(ctx, fx, fy, coords) {};

/**
 * Calculate bounding box of a elliptic-arc
 * @param {number} fx
 * @param {number} fy
 * @param {number} rx
 * @param {number} ry
 * @param {number} rot
 * @param {number} large
 * @param {number} sweep
 * @param {number} tx
 * @param {number} ty
 * @return {!Array<?>}
 */
IUtilArc.prototype.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {};

/**
 * Calculate bounding box of a beziercurve
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @return {!Array<?>}
 */
IUtilArc.prototype.getBoundsOfCurve = function(x0, y0, x1, y1, x2, y2, x3, y3) {};
/**
 * @record
 * @struct
 */
function IUtilDomEvent() {}

/**
 * Cross-browser wrapper for getting event's coordinates
 * @param {!Event} event
 * @param {!HTMLCanvasElement} upperCanvasEl
 * @return {?}
 */
IUtilDomEvent.prototype.getPointer = function(event, upperCanvasEl) {};

/**
 * Adds an event listener to an element
 * @param {!HTMLElement} element
 * @param {string} eventName
 * @param {!Function} handler
 * @return {void}
 */
IUtilDomEvent.prototype.addListener = function(element, eventName, handler) {};

/**
 * Removes an event listener from an element
 * @param {!HTMLElement} element
 * @param {string} eventName
 * @param {!Function} handler
 * @return {void}
 */
IUtilDomEvent.prototype.removeListener = function(element, eventName, handler) {};
/**
 * @record
 * @struct
 */
function IUtilDomMisc() {}

/**
 * Takes id and returns an element with that id (if one exists in a document)
 * @param {(string|!HTMLElement)} id
 * @return {!HTMLElement}
 */
IUtilDomMisc.prototype.getById = function(id) {};

/**
 * Converts an array-like object (e.g. arguments or NodeList) to an array
 * @param {?} arrayLike
 * @return {!Array<?>}
 */
IUtilDomMisc.prototype.toArray = function(arrayLike) {};

/**
 * Creates specified element with specified attributes
 * \@memberOf fabric.util
 * @param {string} tagName
 * @param {?=} attributes
 * @return {!HTMLElement}
 */
IUtilDomMisc.prototype.makeElement = function(tagName, attributes) {};

/**
 * Adds class to an element
 * @param {!HTMLElement} element
 * @param {string} classname
 * @return {void}
 */
IUtilDomMisc.prototype.addClass = function(element, classname) {};

/**
 * Wraps element with another element
 * @param {!HTMLElement} element
 * @param {(string|!HTMLElement)} wrapper
 * @param {?=} attributes
 * @return {!HTMLElement}
 */
IUtilDomMisc.prototype.wrapElement = function(element, wrapper, attributes) {};

/**
 * Returns element scroll offsets
 * @param {!HTMLElement} element
 * @param {!HTMLElement} upperCanvasEl
 * @return {?}
 */
IUtilDomMisc.prototype.getScrollLeftTop = function(element, upperCanvasEl) {};

/**
 * Returns offset for a given element
 * @param {!HTMLElement} element
 * @return {?}
 */
IUtilDomMisc.prototype.getElementOffset = function(element) {};

/**
 * Returns style attribute value of a given element
 * @param {!HTMLElement} elment
 * @param {string} attr
 * @return {string}
 */
IUtilDomMisc.prototype.getElementStyle = function(elment, attr) {};

/**
 * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
 * \@memberOf fabric.util
 * @param {string} url
 * @param {!Function} callback
 * @return {void}
 */
IUtilDomMisc.prototype.getScript = function(url, callback) {};

/**
 * Makes element unselectable
 * @param {!HTMLElement} element
 * @return {!HTMLElement}
 */
IUtilDomMisc.prototype.makeElementUnselectable = function(element) {};

/**
 * Makes element selectable
 * @param {!HTMLElement} element
 * @return {!HTMLElement}
 */
IUtilDomMisc.prototype.makeElementSelectable = function(element) {};
/**
 * @record
 * @struct
 */
function IUtilDomRequest() {}

/**
 * Cross-browser abstraction for sending XMLHttpRequest
 * @param {string} url
 * @param {?=} options
 * @return {!XMLHttpRequest}
 */
IUtilDomRequest.prototype.request = function(url, options) {};
/**
 * @record
 * @struct
 */
function IUtilDomStyle() {}

/**
 * Cross-browser wrapper for setting element's style
 * @param {!HTMLElement} element
 * @param {?} styles
 * @return {!HTMLElement}
 */
IUtilDomStyle.prototype.setStyle = function(element, styles) {};
/**
 * @record
 * @struct
 */
function IUtilArray() {}

/**
 * Invokes method on all items in a given array
 * @param {!Array<?>} array
 * @param {string} method
 * @return {!Array<?>}
 */
IUtilArray.prototype.invoke = function(array, method) {};

/**
 * Finds minimum value in array (not necessarily "first" one)
 * @param {!Array<?>} array
 * @param {string} byProperty
 * @return {?}
 */
IUtilArray.prototype.min = function(array, byProperty) {};

/**
 * Finds maximum value in array (not necessarily "first" one)
 * @param {!Array<?>} array
 * @param {string} byProperty
 * @return {?}
 */
IUtilArray.prototype.max = function(array, byProperty) {};
/**
 * @record
 * @struct
 */
function IUtilClass() {}

/**
 * Helper for creation of "classes".
 *                  (be careful modifying objects defined here as this would affect all instances)
 * Helper for creation of "classes".
 *                  (be careful modifying objects defined here as this would affect all instances)
 * @param {!Function|?=} parent_or_properties
 * @param {?=} properties
 * @return {void}
 */
IUtilClass.prototype.createClass = function(parent_or_properties, properties) {};
/**
 * @record
 * @struct
 */
function IUtilObject() {}

/**
 * Copies all enumerable properties of one object to another
 * @param {?} destination
 * @param {?} source
 * @return {?}
 */
IUtilObject.prototype.extend = function(destination, source) {};

/**
 * Creates an empty object and copies all enumerable properties of another object to it
 * \@memberOf fabric.util.object
 * @param {?} object
 * @return {?}
 */
IUtilObject.prototype.clone = function(object) {};
/**
 * @record
 * @struct
 */
function IUtilString() {}

/**
 * Camelizes a string
 * @param {string} string
 * @return {string}
 */
IUtilString.prototype.camelize = function(string) {};

/**
 * Capitalizes a string
 * and other letters stay untouched, if false first letter is capitalized
 * and other letters are converted to lowercase.
 * @param {string} string
 * @param {boolean} firstLetterOnly
 * @return {string}
 */
IUtilString.prototype.capitalize = function(string, firstLetterOnly) {};

/**
 * Escapes XML in a string
 * @param {string} string
 * @return {string}
 */
IUtilString.prototype.escapeXml = function(string) {};
/**
 * @record
 * @struct
 */
function IUtilMisc() {}

/**
 * Removes value from an array.
 * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
 * @param {!Array<?>} array
 * @param {?} value
 * @return {!Array<?>}
 */
IUtilMisc.prototype.removeFromArray = function(array, value) {};

/**
 * Returns random number between 2 specified ones.
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
IUtilMisc.prototype.getRandomInt = function(min, max) {};

/**
 * Transforms degrees to radians.
 * @param {number} degrees
 * @return {number}
 */
IUtilMisc.prototype.degreesToRadians = function(degrees) {};

/**
 * Transforms radians to degrees.
 * \@memberOf fabric.util
 * @param {number} radians
 * @return {number}
 */
IUtilMisc.prototype.radiansToDegrees = function(radians) {};

/**
 * Rotates `point` around `origin` with `radians`
 * @param {?} point
 * @param {?} origin
 * @param {number} radians
 * @return {?}
 */
IUtilMisc.prototype.rotatePoint = function(point, origin, radians) {};

/**
 * Apply transform t to point p
 * @param {?} p
 * @param {!Array<?>} t
 * @param {boolean=} ignoreOffset
 * @return {?}
 */
IUtilMisc.prototype.transformPoint = function(p, t, ignoreOffset) {};

/**
 * Invert transformation t
 * @param {!Array<?>} t
 * @return {!Array<?>}
 */
IUtilMisc.prototype.invertTransform = function(t) {};

/**
 * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
 * @param {number} number
 * @param {number} fractionDigits
 * @return {number}
 */
IUtilMisc.prototype.toFixed = function(number, fractionDigits) {};

/**
 * Converts from attribute value to pixel value if applicable.
 * Returns converted pixels or original value not converted.
 * @param {(string|number)} value
 * @param {number=} fontSize
 * @return {(string|number)}
 */
IUtilMisc.prototype.parseUnit = function(value, fontSize) {};

/**
 * Function which always returns `false`.
 * @return {boolean}
 */
IUtilMisc.prototype.falseFunction = function() {};

/**
 * Returns klass "Class" object of given namespace
 * @param {string} type
 * @param {string} namespace
 * @return {?}
 */
IUtilMisc.prototype.getKlass = function(type, namespace) {};

/**
 * Returns object of given namespace
 * @param {string} namespace
 * @return {?}
 */
IUtilMisc.prototype.resolveNamespace = function(namespace) {};

/**
 * Loads image element from given url and passes it to a callback
 * @param {string} url
 * @param {?} callback
 * @param {?=} context
 * @param {boolean=} crossOrigin
 * @return {void}
 */
IUtilMisc.prototype.loadImage = function(url, callback, context, crossOrigin) {};

/**
 * Creates corresponding fabric instances from their object representations
 * @param {!Array<?>} objects
 * @param {!Function} callback
 * @param {string} namespace
 * @param {!Function=} reviver
 * @return {void}
 */
IUtilMisc.prototype.enlivenObjects = function(objects, callback, namespace, reviver) {};

/**
 * Groups SVG elements (usually those retrieved from SVG document)
 * @param {!Array<?>} elements
 * @param {?=} options
 * @param {?=} path
 * @return {?}
 */
IUtilMisc.prototype.groupSVGElements = function(elements, options, path) {};

/**
 * Populates an object with properties of another object
 * @param {?} source
 * @param {?} destination
 * @param {?} properties
 * @return {void}
 */
IUtilMisc.prototype.populateWithProperties = function(source, destination, properties) {};

/**
 * Draws a dashed line between two points
 * This method is used to draw dashed line around selection area.
 * @param {!CanvasRenderingContext2D} ctx
 * @param {number} x
 * @param {number} y
 * @param {number} x2
 * @param {number} y2
 * @param {!Array<?>} da
 * @return {void}
 */
IUtilMisc.prototype.drawDashedLine = function(ctx, x, y, x2, y2, da) {};

/**
 * Creates canvas element and initializes it via excanvas if necessary
 * when not given, element is created implicitly
 * @param {!HTMLCanvasElement=} canvasEl
 * @return {!HTMLCanvasElement}
 */
IUtilMisc.prototype.createCanvasElement = function(canvasEl) {};

/**
 * Creates image element (works on client and node)
 * @return {!HTMLImageElement}
 */
IUtilMisc.prototype.createImage = function() {};

/**
 * Creates accessors (getXXX, setXXX) for a "class", based on "stateProperties" array
 * @param {?} klass
 * @return {?}
 */
IUtilMisc.prototype.createAccessors = function(klass) {};

/**
 * @param {?} receiver
 * @param {!CanvasRenderingContext2D} ctx
 * @return {void}
 */
IUtilMisc.prototype.clipContext = function(receiver, ctx) {};

/**
 * Multiply matrix A by matrix B to nest transformations
 * @param {!Array<?>} a
 * @param {!Array<?>} b
 * @return {!Array<?>}
 */
IUtilMisc.prototype.multiplyTransformMatrices = function(a, b) {};

/**
 * Returns string representation of function body
 * @param {!Function} fn
 * @return {string}
 */
IUtilMisc.prototype.getFunctionBody = function(fn) {};

/**
 * Returns true if context has transparent pixel
 * at specified location (taking tolerance into account)
 * @param {!CanvasRenderingContext2D} ctx
 * @param {number} x
 * @param {number} y
 * @param {number} tolerance
 * @return {boolean}
 */
IUtilMisc.prototype.isTransparent = function(ctx, x, y, tolerance) {};
 /** @type {?} */
var util;
/**
 * @extends {IUtilAnimation}
 * @extends {IUtilArc}
 * @extends {IObservable}
 * @extends {IUtilDomEvent}
 * @extends {IUtilDomMisc}
 * @extends {IUtilDomRequest}
 * @extends {IUtilDomStyle}
 * @extends {IUtilClass}
 * @extends {IUtilMisc}
 * @record
 * @struct
 */
function IUtil() {}
 /** @type {?} */
IUtil.prototype.ease;
 /** @type {?} */
IUtil.prototype.array;
 /** @type {?} */
IUtil.prototype.object;
 /** @type {?} */
IUtil.prototype.string;
