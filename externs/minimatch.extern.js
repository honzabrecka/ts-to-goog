/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/minimatch/index.d.ts:

/**
 * Tests a path against the pattern using the options.
 * @param {string} target
 * @param {string} pattern
 * @param {!M.IOptions=} options
 * @return {boolean}
 */
function M(target, pattern, options) {}

/**
 * Match against the list of files, in the style of fnmatch or glob.
 * If nothing is matched, and options.nonull is set,
 * then return a list containing the pattern itself.
 * @param {!Array<string>} list
 * @param {string} pattern
 * @param {!M.IOptions=} options
 * @return {!Array<string>}
 */
M.match = function(list, pattern, options) {};

/**
 * Returns a function that tests its supplied argument, suitable for use with Array.filter
 * @param {string} pattern
 * @param {!M.IOptions=} options
 * @return {function(string, number, !Array<string>): boolean}
 */
M.filter = function(pattern, options) {};

/**
 * Make a regular expression object from the pattern.
 * @param {string} pattern
 * @param {!M.IOptions=} options
 * @return {!RegExp}
 */
M.makeRe = function(pattern, options) {};
 /** @type {!M.IMinimatchStatic} */
M.Minimatch;
/**
 * @record
 * @struct
 */
M.IOptions = function() {};
 /** @type {boolean} */
M.IOptions.prototype.debug;
 /** @type {boolean} */
M.IOptions.prototype.nobrace;
 /** @type {boolean} */
M.IOptions.prototype.noglobstar;
 /** @type {boolean} */
M.IOptions.prototype.dot;
 /** @type {boolean} */
M.IOptions.prototype.noext;
 /** @type {boolean} */
M.IOptions.prototype.nocase;
 /** @type {boolean} */
M.IOptions.prototype.nonull;
 /** @type {boolean} */
M.IOptions.prototype.matchBase;
 /** @type {boolean} */
M.IOptions.prototype.nocomment;
 /** @type {boolean} */
M.IOptions.prototype.nonegate;
 /** @type {boolean} */
M.IOptions.prototype.flipNegate;
/**
 * @record
 * @struct
 */
M.IMinimatchStatic = function() {};

/* TODO: ConstructSignature: M */
 /** @type {!M.IMinimatch} */
M.IMinimatchStatic.prototype.prototype;
/**
 * @record
 * @struct
 */
M.IMinimatch = function() {};
 /** @type {string} */
M.IMinimatch.prototype.pattern;
 /** @type {!M.IOptions} */
M.IMinimatch.prototype.options;
 /** @type {!Array<!Array<?>>} */
M.IMinimatch.prototype.set;
 /** @type {!RegExp} */
M.IMinimatch.prototype.regexp;
 /** @type {boolean} */
M.IMinimatch.prototype.negate;
 /** @type {boolean} */
M.IMinimatch.prototype.comment;
 /** @type {boolean} */
M.IMinimatch.prototype.empty;

/**
 * Generate the regexp member if necessary, and return it.
 * Will return false if the pattern is invalid.
 * @return {!RegExp}
 */
M.IMinimatch.prototype.makeRe = function() {};

/**
 * Return true if the filename matches the pattern, or false otherwise.
 * @param {string} fname
 * @return {boolean}
 */
M.IMinimatch.prototype.match = function(fname) {};

/**
 * Take a /-split filename, and match it against a single row in the regExpSet.
 * This method is mainly for internal use, but is exposed so that it can be used
 * by a glob-walker that needs to avoid excessive filesystem calls.
 * @param {!Array<string>} files
 * @param {!Array<string>} pattern
 * @param {boolean} partial
 * @return {boolean}
 */
M.IMinimatch.prototype.matchOne = function(files, pattern, partial) {};

/**
 * Deprecated. For internal use.
 * 
 * @return {void}
 */
M.IMinimatch.prototype.debug = function() {};

/**
 * Deprecated. For internal use.
 * 
 * @return {void}
 */
M.IMinimatch.prototype.make = function() {};

/**
 * Deprecated. For internal use.
 * 
 * @return {void}
 */
M.IMinimatch.prototype.parseNegate = function() {};

/**
 * Deprecated. For internal use.
 * 
 * @param {string} pattern
 * @param {!M.IOptions} options
 * @return {void}
 */
M.IMinimatch.prototype.braceExpand = function(pattern, options) {};

/**
 * Deprecated. For internal use.
 * 
 * @param {string} pattern
 * @param {boolean=} isSub
 * @return {void}
 */
M.IMinimatch.prototype.parse = function(pattern, isSub) {};

/* TODO: ExportAssignment in  */
