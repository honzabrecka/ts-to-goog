/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bignum/index.d.ts:

/* TODO: ExportAssignment in  */

/**
 * @constructor
 * @struct
 * Create a new BigNum from n.
 * Create a new BigNum from n and a base.
 * @param {(number|!BigNum)|string} n
 * @param {number=} base
 */
function BigNum(n, base) {}

/**
 * Create a new BigNum from a Buffer.
 * 
 * The default options are: {endian: 'big', size: 1}.
 * @param {?} buffer
 * @param {!BigNum.BufferOptions=} options
 * @return {!BigNum}
 */
BigNum.fromBuffer = function(buffer, options) {};

/**
 * Generate a probable prime of length bits.
 * 
 * If safe is true, it will be a "safe" prime of the form p=2p'+1 where p' is also prime.
 * @param {number} bits
 * @param {boolean=} safe
 * @return {!BigNum}
 */
BigNum.prime = function(bits, safe) {};

/**
 * Return true if num is identified as a BigNum instance. Otherwise, return false.
 * @param {?} num
 * @return {boolean}
 */
BigNum.isBigNum = function(num) {};

/**
 * Print out the BigNum instance in the requested base as a string. Default: base 10
 * @param {number=} base
 * @return {string}
 */
BigNum.prototype.toString = function(base) {};

/**
 * Turn a BigNum into a Number.
 * 
 * If the BigNum is too big you'll lose precision or you'll get ±Infinity.
 * @return {number}
 */
BigNum.prototype.toNumber = function() {};

/**
 * Return a new Buffer with the data from the BigNum.
 * 
 * The default options are: {endian: 'big', size: 1}.
 * @param {!BigNum.BufferOptions=} options
 * @return {?}
 */
BigNum.prototype.toBuffer = function(options) {};

/**
 * Return a new BigNum containing the instance value plus n.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.add = function(n) {};

/**
 * Return a new BigNum containing the instance value minus n.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.sub = function(n) {};

/**
 * Return a new BigNum containing the instance value multiplied by n.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.mul = function(n) {};

/**
 * Return a new BigNum containing the instance value integrally divided by n.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.div = function(n) {};

/**
 * Return a new BigNum with the absolute value of the instance.
 * @return {!BigNum}
 */
BigNum.prototype.abs = function() {};

/**
 * Return a new BigNum with the negative of the instance value.
 * @return {!BigNum}
 */
BigNum.prototype.neg = function() {};

/**
 * Compare the instance value to n.
 * 
 * Return a positive integer if > n, a negative integer if < n, and 0 if == n.
 * @param {(string|number|!BigNum)} n
 * @return {number}
 */
BigNum.prototype.cmp = function(n) {};

/**
 * Return a boolean: whether the instance value is greater than n (> n).
 * @param {(string|number|!BigNum)} n
 * @return {boolean}
 */
BigNum.prototype.gt = function(n) {};

/**
 * Return a boolean: whether the instance value is greater than or equal to n (>= n).
 * @param {(string|number|!BigNum)} n
 * @return {boolean}
 */
BigNum.prototype.ge = function(n) {};

/**
 * Return a boolean: whether the instance value is equal to n (== n).
 * @param {(string|number|!BigNum)} n
 * @return {boolean}
 */
BigNum.prototype.eq = function(n) {};

/**
 * Return a boolean: whether the instance value is less than n (< n).
 * @param {(string|number|!BigNum)} n
 * @return {boolean}
 */
BigNum.prototype.lt = function(n) {};

/**
 * Return a boolean: whether the instance value is less than or equal to n (<= n).
 * @param {(string|number|!BigNum)} n
 * @return {boolean}
 */
BigNum.prototype.le = function(n) {};

/**
 * Return a new BigNum with the instance value bitwise AND (&)-ed with n.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.and = function(n) {};

/**
 * Return a new BigNum with the instance value bitwise inclusive-OR (|)-ed with n.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.or = function(n) {};

/**
 * Return a new BigNum with the instance value bitwise exclusive-OR (^)-ed with n.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.xor = function(n) {};

/**
 * Return a new BigNum with the instance value modulo n.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.mod = function(n) {};

/**
 * Return a new BigNum with the instance value raised to the nth power.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.pow = function(n) {};

/**
 * Return a new BigNum with the instance value raised to the nth power modulo m.
 * @param {(string|number|!BigNum)} n
 * @param {(string|number|!BigNum)} m
 * @return {!BigNum}
 */
BigNum.prototype.powm = function(n, m) {};

/**
 * Compute the multiplicative inverse modulo m.
 * @param {(string|number|!BigNum)} m
 * @return {!BigNum}
 */
BigNum.prototype.invertm = function(m) {};

/**
 * If upperBound is supplied, return a random BigNum between the instance value and upperBound - 1, inclusive.
 * Otherwise, return a random BigNum between 0 and the instance value - 1, inclusive.
 * @param {(string|number|!BigNum)=} upperBound
 * @return {!BigNum}
 */
BigNum.prototype.rand = function(upperBound) {};

/**
 * Return whether the BigNum is:
 *  - certainly prime (true)
 *  - probably prime ('maybe')
 *  - certainly composite (false)
 * @return {(string|boolean)}
 */
BigNum.prototype.probPrime = function() {};

/**
 * Return a new BigNum that is the 2^n multiple. Equivalent of the << operator.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.shiftLeft = function(n) {};

/**
 * Return a new BigNum of the value integer divided by 2^n. Equivalent of the >> operator.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.prototype.shiftRight = function(n) {};

/**
 * Return the greatest common divisor of the current BigNum with n as a new BigNum.
 * @param {!BigNum} n
 * @return {!BigNum}
 */
BigNum.prototype.gcd = function(n) {};

/**
 * Return the Jacobi symbol (or Legendre symbol if n is prime) of the current BigNum (= a) over n.
 * Note that n must be odd and >= 3. 0 <= a < n.
 * 
 * Returns -1 or 1 as an int (NOT a BigNum). Throws an error on failure.
 * @param {!BigNum} n
 * @return {number}
 */
BigNum.prototype.jacobi = function(n) {};

/**
 * Return the number of bits used to represent the current BigNum.
 * @return {number}
 */
BigNum.prototype.bitLength = function() {};

/** @typedef {(string|number|!BigNum)} */
BigNum.BigNumCompatible;
/**
 * @record
 * @struct
 */
BigNum.BufferOptions = function() {};
 /** @type {(string|number)} */
BigNum.BufferOptions.prototype.endian;
 /** @type {(string|number)} */
BigNum.BufferOptions.prototype.size;

/**
 * Turn a BigNum into a Number.
 * 
 * If the BigNum is too big you'll lose precision or you'll get ±Infinity.
 * @param {(string|number|!BigNum)} n
 * @return {number}
 */
BigNum.toNumber = function(n) {};

/**
 * Return a new Buffer with the data from the BigNum.
 * 
 * The default options are: {endian: 'big', size: 1}.
 * @param {(string|number|!BigNum)} n
 * @param {!BigNum.BufferOptions=} options
 * @return {?}
 */
BigNum.toBuffer = function(n, options) {};

/**
 * Return a new BigNum containing the instance value plus n.
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {!BigNum}
 */
BigNum.add = function(left, right) {};

/**
 * Return a new BigNum containing the instance value minus n.
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {!BigNum}
 */
BigNum.sub = function(left, right) {};

/**
 * Return a new BigNum containing the instance value multiplied by n.
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {!BigNum}
 */
BigNum.mul = function(left, right) {};

/**
 * Return a new BigNum containing the instance value integrally divided by n.
 * @param {(string|number|!BigNum)} dividend
 * @param {(string|number|!BigNum)} divisor
 * @return {!BigNum}
 */
BigNum.div = function(dividend, divisor) {};

/**
 * Return a new BigNum with the absolute value of the instance.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.abs = function(n) {};

/**
 * Return a new BigNum with the negative of the instance value.
 * @param {(string|number|!BigNum)} n
 * @return {!BigNum}
 */
BigNum.neg = function(n) {};

/**
 * Compare the instance value to n.
 * 
 * Return a positive integer if > n, a negative integer if < n, and 0 if == n.
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {number}
 */
BigNum.cmp = function(left, right) {};

/**
 * Return a boolean: whether the instance value is greater than n (> n).
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {boolean}
 */
BigNum.gt = function(left, right) {};

/**
 * Return a boolean: whether the instance value is greater than or equal to n (>= n).
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {boolean}
 */
BigNum.ge = function(left, right) {};

/**
 * Return a boolean: whether the instance value is equal to n (== n).
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {boolean}
 */
BigNum.eq = function(left, right) {};

/**
 * Return a boolean: whether the instance value is less than n (< n).
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {boolean}
 */
BigNum.lt = function(left, right) {};

/**
 * Return a boolean: whether the instance value is less than or equal to n (<= n).
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {boolean}
 */
BigNum.le = function(left, right) {};

/**
 * Return a new BigNum with the instance value bitwise AND (&)-ed with n.
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {!BigNum}
 */
BigNum.and = function(left, right) {};

/**
 * Return a new BigNum with the instance value bitwise inclusive-OR (|)-ed with n.
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {!BigNum}
 */
BigNum.or = function(left, right) {};

/**
 * Return a new BigNum with the instance value bitwise exclusive-OR (^)-ed with n.
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {!BigNum}
 */
BigNum.xor = function(left, right) {};

/**
 * Return a new BigNum with the instance value modulo n.
 * @param {(string|number|!BigNum)} left
 * @param {(string|number|!BigNum)} right
 * @return {!BigNum}
 */
BigNum.mod = function(left, right) {};

/**
 * Return a new BigNum with the instance value raised to the nth power.
 * @param {(string|number|!BigNum)} base
 * @param {(string|number|!BigNum)} exponent
 * @return {!BigNum}
 */
BigNum.pow = function(base, exponent) {};

/**
 * Return a new BigNum with the instance value raised to the nth power modulo m.
 * @param {(string|number|!BigNum)} base
 * @param {(string|number|!BigNum)} exponent
 * @param {(string|number|!BigNum)} m
 * @return {!BigNum}
 */
BigNum.powm = function(base, exponent, m) {};

/**
 * Compute the multiplicative inverse modulo m.
 * @param {(string|number|!BigNum)} n
 * @param {(string|number|!BigNum)} m
 * @return {!BigNum}
 */
BigNum.invertm = function(n, m) {};

/**
 * If upperBound is supplied, return a random BigNum between the instance value and upperBound - 1, inclusive.
 * Otherwise, return a random BigNum between 0 and the instance value - 1, inclusive.
 * @param {(string|number|!BigNum)} n
 * @param {(string|number|!BigNum)=} upperBound
 * @return {!BigNum}
 */
BigNum.rand = function(n, upperBound) {};

/**
 * Return whether the BigNum is:
 *  - certainly prime (true)
 *  - probably prime ('maybe')
 *  - certainly composite (false)
 * @param {(string|number|!BigNum)} n
 * @return {(string|boolean)}
 */
BigNum.probPrime = function(n) {};

/**
 * Return a new BigNum that is the 2^bits multiple. Equivalent of the << operator.
 * @param {(string|number|!BigNum)} n
 * @param {(string|number|!BigNum)} bits
 * @return {!BigNum}
 */
BigNum.shiftLeft = function(n, bits) {};

/**
 * Return a new BigNum of the value integer divided by 2^bits. Equivalent of the >> operator.
 * @param {(string|number|!BigNum)} n
 * @param {(string|number|!BigNum)} bits
 * @return {!BigNum}
 */
BigNum.shiftRight = function(n, bits) {};

/**
 * Return the greatest common divisor of the current BigNum with n as a new BigNum.
 * @param {(string|number|!BigNum)} left
 * @param {!BigNum} right
 * @return {!BigNum}
 */
BigNum.gcd = function(left, right) {};

/**
 * Return the Jacobi symbol (or Legendre symbol if n is prime) of the current BigNum (= a) over n.
 * Note that n must be odd and >= 3. 0 <= a < n.
 * 
 * Returns -1 or 1 as an int (NOT a BigNum). Throws an error on failure.
 * @param {(string|number|!BigNum)} a
 * @param {!BigNum} n
 * @return {number}
 */
BigNum.jacobi = function(a, n) {};

/**
 * Return the number of bits used to represent the current BigNum.
 * @param {(string|number|!BigNum)} n
 * @return {number}
 */
BigNum.bitLength = function(n) {};
