/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/react-native/index.d.ts:

/** @typedef {?} */
var MeasureOnSuccessCallback;

/** @typedef {?} */
var MeasureInWindowOnSuccessCallback;

/** @typedef {?} */
var MeasureLayoutOnSuccessCallback;
/**
 * @record
 * @struct
 */
function EventSubscription() {}
 /** @type {string} */
EventSubscription.prototype.eventType;
 /** @type {number} */
EventSubscription.prototype.key;
 /** @type {?} */
EventSubscription.prototype.subscriber;

/* TODO: ConstructSignature:  */

/**
 * Removes this subscription from the subscriber that controls it.
 * @return {void}
 */
EventSubscription.prototype.remove = function() {};
/**
 * @record
 * @struct
 */
function EventSubscriptionVendor() {}

/**
 * @return {?}
 */
EventSubscriptionVendor.prototype.constructor = function() {};

/**
 * Adds a subscription keyed by an event type.
 * 
 * @param {string} eventType
 * @param {?} subscription
 * @return {?}
 */
EventSubscriptionVendor.prototype.addSubscription = function(eventType, subscription) {};

/**
 * Removes a bulk set of the subscriptions.
 * 
 *   registered supscriptions to remove, if null remove all subscriptions.
 * @param {string=} eventType
 * @return {void}
 */
EventSubscriptionVendor.prototype.removeAllSubscriptions = function(eventType) {};

/**
 * Removes a specific subscription. Instead of calling this function, call
 * `subscription.remove()` directly.
 * 
 * @param {?} subscription
 * @return {void}
 */
EventSubscriptionVendor.prototype.removeSubscription = function(subscription) {};

/**
 * Returns the array of subscriptions that are currently registered for the
 * given event type.
 * 
 * Note: This array can be potentially sparse as subscriptions are deleted
 * from it when they are removed.
 * 
 * @param {string} eventType
 * @return {!Array<?>}
 */
EventSubscriptionVendor.prototype.getSubscriptionsForType = function(eventType) {};
/**
 * @extends {EventSubscription}
 * @record
 * @struct
 */
function EmitterSubscription() {}
 /** @type {?} */
EmitterSubscription.prototype.emitter;
 /** @type {?} */
EmitterSubscription.prototype.listener;
 /** @type {?} */
EmitterSubscription.prototype.context;

/* TODO: ConstructSignature:  */

/**
 * Removes this subscription from the emitter that registered it.
 * Note: we're overriding the `remove()` method of EventSubscription here
 * but deliberately not calling `super.remove()` as the responsibility
 * for removing the subscription lies with the EventEmitter.
 * @return {void}
 */
EmitterSubscription.prototype.remove = function() {};
/**
 * @record
 * @struct
 */
function EventEmitterListener() {}

/**
 * Adds a listener to be invoked when events of the specified type are
 * emitted. An optional calling context may be provided. The data arguments
 * emitted will be passed to the listener function.
 * 
 *   emitted
 *   listener
 * @param {string} eventType
 * @param {?} listener
 * @param {?=} context
 * @return {?}
 */
EventEmitterListener.prototype.addListener = function(eventType, listener, context) {};
/**
 * @extends {EventEmitterListener}
 * @record
 * @struct
 */
function EventEmitter() {}

/* TODO: ConstructSignature:  */

/**
 * Similar to addListener, except that the listener is removed after it is
 * invoked once.
 * 
 *   specified event is emitted
 *   listener
 * @param {string} eventType
 * @param {?} listener
 * @param {?} context
 * @return {?}
 */
EventEmitter.prototype.once = function(eventType, listener, context) {};

/**
 * Removes all of the registered listeners, including those registered as
 * listener maps.
 * 
 *   listeners to remove
 * @param {string=} eventType
 * @return {void}
 */
EventEmitter.prototype.removeAllListeners = function(eventType) {};

/**
 * Provides an API that can be called during an eventing cycle to remove the
 * last listener that was invoked. This allows a developer to provide an event
 * object that can remove the listener (or listener map) during the
 * invocation.
 * 
 * If it is called when not inside of an emitting cycle it will throw.
 * 
 * @throws {Error} When called not during an eventing cycle
 * 
 * \@example 
 *   var subscription = emitter.addListenerMap({
 *     someEvent: function(data, event) {
 *       console.log(data);
 *       emitter.removeCurrentListener();
 *     }
 *   });
 * 
 *   emitter.emit('someEvent', 'abc'); // logs 'abc'
 *   emitter.emit('someEvent', 'def'); // does not log anything
 * @return {void}
 */
EventEmitter.prototype.removeCurrentListener = function() {};

/**
 * Removes a specific subscription. Called by the `remove()` method of the
 * subscription itself to ensure any necessary cleanup is performed.
 * @param {?} subscription
 * @return {void}
 */
EventEmitter.prototype.removeSubscription = function(subscription) {};

/**
 * Returns an array of listeners that are currently registered for the given
 * event.
 * 
 * @param {string} eventType
 * @return {!Array<?>}
 */
EventEmitter.prototype.listeners = function(eventType) {};

/**
 * Emits an event of the given type with the given data. All handlers of that
 * particular type will be notified.
 * 
 * 
 * \@example 
 *   emitter.addListener('someEvent', function(message) {
 *     console.log(message);
 *   });
 * 
 *   emitter.emit('someEvent', 'abc'); // logs 'abc'
 * @param {string} eventType
 * @param {...?} params
 * @return {void}
 */
EventEmitter.prototype.emit = function(eventType, params) {};

/**
 * Removes the given listener for event of specific type.
 * 
 *   emitted
 * 
 * \@example 
 *   emitter.removeListener('someEvent', function(message) {
 *     console.log(message);
 *   }); // removes the listener if already registered
 * 
 * @param {string} eventType
 * @param {?} listener
 * @return {void}
 */
EventEmitter.prototype.removeListener = function(eventType, listener) {};
/**
 * @record
 * @struct
 */
function NativeMethodsMixinStatic() {}
 /** @type {?} */
NativeMethodsMixinStatic.prototype.refs;

/**
 * Determines the location on screen, width, and height of the given view and
 * returns the values via an async callback. If successful, the callback will
 * be called with the following arguments:
 * 
 *  - x
 *  - y
 *  - width
 *  - height
 *  - pageX
 *  - pageY
 * 
 * Note that these measurements are not available until after the rendering
 * has been completed in native. If you need the measurements as soon as
 * possible, consider using the [`onLayout`
 * prop](docs/view.html#onlayout) instead.
 * @param {?} callback
 * @return {void}
 */
NativeMethodsMixinStatic.prototype.measure = function(callback) {};

/**
 * Determines the location of the given view in the window and returns the
 * values via an async callback. If the React root view is embedded in
 * another native view, this will give you the absolute coordinates. If
 * successful, the callback will be called with the following
 * arguments:
 * 
 *  - x
 *  - y
 *  - width
 *  - height
 * 
 * Note that these measurements are not available until after the rendering
 * has been completed in native.
 * @param {?} callback
 * @return {void}
 */
NativeMethodsMixinStatic.prototype.measureInWindow = function(callback) {};

/**
 * Like [`measure()`](#measure), but measures the view relative an ancestor,
 * specified as `relativeToNativeNode`. This means that the returned x, y
 * are relative to the origin x, y of the ancestor view.
 * 
 * As always, to obtain a native node handle for a component, you can use
 * `React.findNodeHandle(component)`.
 * @param {number} relativeToNativeNode
 * @param {?} onSuccess
 * @param {?} onFail
 * @return {void}
 */
NativeMethodsMixinStatic.prototype.measureLayout = function(relativeToNativeNode, onSuccess, onFail) {};

/**
 * This function sends props straight to native. They will not participate in
 * future diff process - this means that if you do not include them in the
 * next render, they will remain active (see [Direct
 * Manipulation](docs/direct-manipulation.html)).
 * @param {!Object} nativeProps
 * @return {void}
 */
NativeMethodsMixinStatic.prototype.setNativeProps = function(nativeProps) {};

/**
 * Requests focus for the given input or view. The exact behavior triggered
 * will depend on the platform and type of view.
 * @return {void}
 */
NativeMethodsMixinStatic.prototype.focus = function() {};

/**
 * Removes focus from an input or view. This is the opposite of `focus()`.
 * @return {void}
 */
NativeMethodsMixinStatic.prototype.blur = function() {};

/**
 * @template P
 * @param {(string|!React.ComponentClass<?>|!React.StatelessComponent<?>)} type
 * @param {?=} props
 * @param {...(string|number|boolean|!Object|!React.ReactElement<?>|!Array<(string|number|boolean|!Array<?>|!React.ReactElement<?>)>)} children
 * @return {!React.ReactElement<?>}
 */
function createElement(type, props, children) {}

/** @typedef {?} */
var Runnable;
/**
 * @record
 * @struct
 */
function NativeSyntheticEvent() {}
 /** @type {boolean} */
NativeSyntheticEvent.prototype.bubbles;
 /** @type {boolean} */
NativeSyntheticEvent.prototype.cancelable;
 /** @type {!EventTarget} */
NativeSyntheticEvent.prototype.currentTarget;
 /** @type {boolean} */
NativeSyntheticEvent.prototype.defaultPrevented;
 /** @type {number} */
NativeSyntheticEvent.prototype.eventPhase;
 /** @type {boolean} */
NativeSyntheticEvent.prototype.isTrusted;
 /** @type {?} */
NativeSyntheticEvent.prototype.nativeEvent;
 /** @type {!EventTarget} */
NativeSyntheticEvent.prototype.target;
 /** @type {!Date} */
NativeSyntheticEvent.prototype.timeStamp;
 /** @type {string} */
NativeSyntheticEvent.prototype.type;

/**
 * @return {void}
 */
NativeSyntheticEvent.prototype.preventDefault = function() {};

/**
 * @return {void}
 */
NativeSyntheticEvent.prototype.stopPropagation = function() {};
/**
 * @record
 * @struct
 */
function NativeTouchEvent() {}
 /** @type {!Array<?>} */
NativeTouchEvent.prototype.changedTouches;
 /** @type {string} */
NativeTouchEvent.prototype.identifier;
 /** @type {number} */
NativeTouchEvent.prototype.locationX;
 /** @type {number} */
NativeTouchEvent.prototype.locationY;
 /** @type {number} */
NativeTouchEvent.prototype.pageX;
 /** @type {number} */
NativeTouchEvent.prototype.pageY;
 /** @type {string} */
NativeTouchEvent.prototype.target;
 /** @type {number} */
NativeTouchEvent.prototype.timestamp;
 /** @type {!Array<?>} */
NativeTouchEvent.prototype.touches;
/**
 * @extends {NativeSyntheticEvent}
 * @record
 * @struct
 */
function GestureResponderEvent() {}
/**
 * @record
 * @struct
 */
function PointProperties() {}
 /** @type {number} */
PointProperties.prototype.x;
 /** @type {number} */
PointProperties.prototype.y;
/**
 * @record
 * @struct
 */
function Insets() {}
 /** @type {number} */
Insets.prototype.top;
 /** @type {number} */
Insets.prototype.left;
 /** @type {number} */
Insets.prototype.bottom;
 /** @type {number} */
Insets.prototype.right;
/**
 * @record
 * @struct
 */
function Touchable() {}
 /** @type {?} */
Touchable.prototype.onTouchStart;
 /** @type {?} */
Touchable.prototype.onTouchMove;
 /** @type {?} */
Touchable.prototype.onTouchEnd;
 /** @type {?} */
Touchable.prototype.onTouchCancel;
 /** @type {?} */
Touchable.prototype.onTouchEndCapture;

/** @typedef {?} */
var ComponentProvider;

/** @typedef {?} */
var AppConfig;
/**
 * @constructor
 * @struct
 */
function AppRegistry() {}

/**
 * @param {!Array<?>} config
 * @return {void}
 */
AppRegistry.registerConfig = function(config) {};

/**
 * @param {string} appKey
 * @param {?} getComponentFunc
 * @return {string}
 */
AppRegistry.registerComponent = function(appKey, getComponentFunc) {};

/**
 * @param {string} appKey
 * @param {?} func
 * @return {string}
 */
AppRegistry.registerRunnable = function(appKey, func) {};

/**
 * @return {!Array<string>}
 */
AppRegistry.getAppKeys = function() {};

/**
 * @param {number} rootTag
 * @return {void}
 */
AppRegistry.unmountApplicationComponentAtRootTag = function(rootTag) {};

/**
 * @param {string} appKey
 * @param {?} appParameters
 * @return {void}
 */
AppRegistry.runApplication = function(appKey, appParameters) {};
/**
 * @record
 * @struct
 */
function LayoutAnimationTypes() {}
 /** @type {string} */
LayoutAnimationTypes.prototype.spring;
 /** @type {string} */
LayoutAnimationTypes.prototype.linear;
 /** @type {string} */
LayoutAnimationTypes.prototype.easeInEaseOut;
 /** @type {string} */
LayoutAnimationTypes.prototype.easeIn;
 /** @type {string} */
LayoutAnimationTypes.prototype.easeOut;
/**
 * @record
 * @struct
 */
function LayoutAnimationProperties() {}
 /** @type {string} */
LayoutAnimationProperties.prototype.opacity;
 /** @type {string} */
LayoutAnimationProperties.prototype.scaleXY;
/**
 * @record
 * @struct
 */
function LayoutAnimationAnim() {}
 /** @type {number} */
LayoutAnimationAnim.prototype.duration;
 /** @type {number} */
LayoutAnimationAnim.prototype.delay;
 /** @type {number} */
LayoutAnimationAnim.prototype.springDamping;
 /** @type {number} */
LayoutAnimationAnim.prototype.initialVelocity;
 /** @type {string} */
LayoutAnimationAnim.prototype.type;
 /** @type {string} */
LayoutAnimationAnim.prototype.property;
/**
 * @record
 * @struct
 */
function LayoutAnimationConfig() {}
 /** @type {number} */
LayoutAnimationConfig.prototype.duration;
 /** @type {?} */
LayoutAnimationConfig.prototype.create;
 /** @type {?} */
LayoutAnimationConfig.prototype.update;
 /** @type {?} */
LayoutAnimationConfig.prototype.delete;
/**
 * @record
 * @struct
 */
function LayoutAnimationStatic() {}
 /** @type {?} */
LayoutAnimationStatic.prototype.configureNext;
 /** @type {?} */
LayoutAnimationStatic.prototype.create;
 /** @type {?} */
LayoutAnimationStatic.prototype.Types;
 /** @type {?} */
LayoutAnimationStatic.prototype.Properties;
 /** @type {?} */
LayoutAnimationStatic.prototype.configChecker;
 /** @type {?} */
LayoutAnimationStatic.prototype.Presets;
 /** @type {?} */
LayoutAnimationStatic.prototype.easeInEaseOut;
 /** @type {?} */
LayoutAnimationStatic.prototype.linear;
 /** @type {?} */
LayoutAnimationStatic.prototype.spring;

/** @typedef {string} */
var FlexAlignType;
/**
 * @record
 * @struct
 */
function FlexStyle() {}
 /** @type {string} */
FlexStyle.prototype.alignContent;
 /** @type {string} */
FlexStyle.prototype.alignItems;
 /** @type {string} */
FlexStyle.prototype.alignSelf;
 /** @type {number} */
FlexStyle.prototype.aspectRatio;
 /** @type {number} */
FlexStyle.prototype.borderBottomWidth;
 /** @type {number} */
FlexStyle.prototype.borderLeftWidth;
 /** @type {number} */
FlexStyle.prototype.borderRightWidth;
 /** @type {number} */
FlexStyle.prototype.borderTopWidth;
 /** @type {number} */
FlexStyle.prototype.borderWidth;
 /** @type {(string|number)} */
FlexStyle.prototype.bottom;
 /** @type {number} */
FlexStyle.prototype.flex;
 /** @type {(string|number)} */
FlexStyle.prototype.flexBasis;
 /** @type {string} */
FlexStyle.prototype.flexDirection;
 /** @type {number} */
FlexStyle.prototype.flexGrow;
 /** @type {number} */
FlexStyle.prototype.flexShrink;
 /** @type {string} */
FlexStyle.prototype.flexWrap;
 /** @type {(string|number)} */
FlexStyle.prototype.height;
 /** @type {string} */
FlexStyle.prototype.justifyContent;
 /** @type {(string|number)} */
FlexStyle.prototype.left;
 /** @type {(string|number)} */
FlexStyle.prototype.margin;
 /** @type {(string|number)} */
FlexStyle.prototype.marginBottom;
 /** @type {(string|number)} */
FlexStyle.prototype.marginHorizontal;
 /** @type {(string|number)} */
FlexStyle.prototype.marginLeft;
 /** @type {(string|number)} */
FlexStyle.prototype.marginRight;
 /** @type {(string|number)} */
FlexStyle.prototype.marginTop;
 /** @type {(string|number)} */
FlexStyle.prototype.marginVertical;
 /** @type {(string|number)} */
FlexStyle.prototype.maxHeight;
 /** @type {(string|number)} */
FlexStyle.prototype.maxWidth;
 /** @type {(string|number)} */
FlexStyle.prototype.minHeight;
 /** @type {(string|number)} */
FlexStyle.prototype.minWidth;
 /** @type {string} */
FlexStyle.prototype.overflow;
 /** @type {(string|number)} */
FlexStyle.prototype.padding;
 /** @type {(string|number)} */
FlexStyle.prototype.paddingBottom;
 /** @type {(string|number)} */
FlexStyle.prototype.paddingHorizontal;
 /** @type {(string|number)} */
FlexStyle.prototype.paddingLeft;
 /** @type {(string|number)} */
FlexStyle.prototype.paddingRight;
 /** @type {(string|number)} */
FlexStyle.prototype.paddingTop;
 /** @type {(string|number)} */
FlexStyle.prototype.paddingVertical;
 /** @type {string} */
FlexStyle.prototype.position;
 /** @type {(string|number)} */
FlexStyle.prototype.right;
 /** @type {(string|number)} */
FlexStyle.prototype.top;
 /** @type {(string|number)} */
FlexStyle.prototype.width;
 /** @type {number} */
FlexStyle.prototype.zIndex;
 /** @type {string} */
FlexStyle.prototype.direction;
/**
 * @record
 * @struct
 */
function ShadowPropTypesIOSStatic() {}
 /** @type {string} */
ShadowPropTypesIOSStatic.prototype.shadowColor;
 /** @type {?} */
ShadowPropTypesIOSStatic.prototype.shadowOffset;
 /** @type {number} */
ShadowPropTypesIOSStatic.prototype.shadowOpacity;
 /** @type {number} */
ShadowPropTypesIOSStatic.prototype.shadowRadius;

/** @typedef {?} */
var GetCurrentPositionOptions;

/** @typedef {?} */
var WatchPositionOptions;

/** @typedef {?} */
var GeolocationReturnType;
/**
 * @record
 * @struct
 */
function PerpectiveTransform() {}
 /** @type {number} */
PerpectiveTransform.prototype.perspective;
/**
 * @record
 * @struct
 */
function RotateTransform() {}
 /** @type {string} */
RotateTransform.prototype.rotate;
/**
 * @record
 * @struct
 */
function RotateXTransform() {}
 /** @type {string} */
RotateXTransform.prototype.rotateX;
/**
 * @record
 * @struct
 */
function RotateYTransform() {}
 /** @type {string} */
RotateYTransform.prototype.rotateY;
/**
 * @record
 * @struct
 */
function RotateZTransform() {}
 /** @type {string} */
RotateZTransform.prototype.rotateZ;
/**
 * @record
 * @struct
 */
function ScaleTransform() {}
 /** @type {number} */
ScaleTransform.prototype.scale;
/**
 * @record
 * @struct
 */
function ScaleXTransform() {}
 /** @type {number} */
ScaleXTransform.prototype.scaleX;
/**
 * @record
 * @struct
 */
function ScaleYTransform() {}
 /** @type {number} */
ScaleYTransform.prototype.scaleY;
/**
 * @record
 * @struct
 */
function TranslateXTransform() {}
 /** @type {number} */
TranslateXTransform.prototype.translateX;
/**
 * @record
 * @struct
 */
function TranslateYTransform() {}
 /** @type {number} */
TranslateYTransform.prototype.translateY;
/**
 * @record
 * @struct
 */
function SkewXTransform() {}
 /** @type {string} */
SkewXTransform.prototype.skewX;
/**
 * @record
 * @struct
 */
function SkewYTransform() {}
 /** @type {string} */
SkewYTransform.prototype.skewY;
/**
 * @record
 * @struct
 */
function TransformsStyle() {}
 /** @type {!Array<?>} */
TransformsStyle.prototype.transform;
 /** @type {!Array<number>} */
TransformsStyle.prototype.transformMatrix;
 /** @type {number} */
TransformsStyle.prototype.rotation;
 /** @type {number} */
TransformsStyle.prototype.scaleX;
 /** @type {number} */
TransformsStyle.prototype.scaleY;
 /** @type {number} */
TransformsStyle.prototype.translateX;
 /** @type {number} */
TransformsStyle.prototype.translateY;
/**
 * @record
 * @struct
 */
function StyleSheetProperties() {}
 /** @type {number} */
StyleSheetProperties.prototype.hairlineWidth;

/**
 * @template T
 * @param {?} style
 * @return {?}
 */
StyleSheetProperties.prototype.flatten = function(style) {};
/**
 * @record
 * @struct
 */
function LayoutRectangle() {}
 /** @type {number} */
LayoutRectangle.prototype.x;
 /** @type {number} */
LayoutRectangle.prototype.y;
 /** @type {number} */
LayoutRectangle.prototype.width;
 /** @type {number} */
LayoutRectangle.prototype.height;
/**
 * @record
 * @struct
 */
function LayoutChangeEvent() {}
 /** @type {?} */
LayoutChangeEvent.prototype.nativeEvent;
/**
 * @extends {ViewStyle}
 * @record
 * @struct
 */
function TextStyleIOS() {}
 /** @type {number} */
TextStyleIOS.prototype.letterSpacing;
 /** @type {string} */
TextStyleIOS.prototype.textDecorationColor;
 /** @type {string} */
TextStyleIOS.prototype.textDecorationStyle;
 /** @type {string} */
TextStyleIOS.prototype.writingDirection;
/**
 * @extends {ViewStyle}
 * @record
 * @struct
 */
function TextStyleAndroid() {}
 /** @type {string} */
TextStyleAndroid.prototype.textAlignVertical;
 /** @type {boolean} */
TextStyleAndroid.prototype.includeFontPadding;
/**
 * @extends {TextStyleIOS}
 * @extends {TextStyleAndroid}
 * @extends {ViewStyle}
 * @record
 * @struct
 */
function TextStyle() {}
 /** @type {string} */
TextStyle.prototype.color;
 /** @type {string} */
TextStyle.prototype.fontFamily;
 /** @type {number} */
TextStyle.prototype.fontSize;
 /** @type {string} */
TextStyle.prototype.fontStyle;
 /** @type {string} */
TextStyle.prototype.fontWeight;
 /** @type {number} */
TextStyle.prototype.letterSpacing;
 /** @type {number} */
TextStyle.prototype.lineHeight;
 /** @type {string} */
TextStyle.prototype.textAlign;
 /** @type {string} */
TextStyle.prototype.textDecorationLine;
 /** @type {string} */
TextStyle.prototype.textDecorationStyle;
 /** @type {string} */
TextStyle.prototype.textDecorationColor;
 /** @type {string} */
TextStyle.prototype.textShadowColor;
 /** @type {?} */
TextStyle.prototype.textShadowOffset;
 /** @type {number} */
TextStyle.prototype.textShadowRadius;
 /** @type {string} */
TextStyle.prototype.testID;
/**
 * @record
 * @struct
 */
function TextPropertiesIOS() {}
 /** @type {boolean} */
TextPropertiesIOS.prototype.allowFontScaling;
 /** @type {boolean} */
TextPropertiesIOS.prototype.adjustsFontSizeToFit;
 /** @type {number} */
TextPropertiesIOS.prototype.minimumFontScale;
 /** @type {boolean} */
TextPropertiesIOS.prototype.suppressHighlighting;
/**
 * @record
 * @struct
 */
function TextPropertiesAndroid() {}
 /** @type {boolean} */
TextPropertiesAndroid.prototype.selectable;
 /** @type {string} */
TextPropertiesAndroid.prototype.selectionColor;
 /** @type {string} */
TextPropertiesAndroid.prototype.textBreakStrategy;
/**
 * @extends {TextPropertiesIOS}
 * @extends {TextPropertiesAndroid}
 * @record
 * @struct
 */
function TextProperties() {}
 /** @type {boolean} */
TextProperties.prototype.accessible;
 /** @type {string} */
TextProperties.prototype.ellipsizeMode;
 /** @type {string} */
TextProperties.prototype.lineBreakMode;
 /** @type {number} */
TextProperties.prototype.numberOfLines;
 /** @type {?} */
TextProperties.prototype.onLayout;
 /** @type {?} */
TextProperties.prototype.onPress;
 /** @type {?} */
TextProperties.prototype.onLongPress;
 /** @type {(boolean|?)} */
TextProperties.prototype.style;
 /** @type {string} */
TextProperties.prototype.testID;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function TextStatic() {}

/** @typedef {string} */
var DataDetectorTypes;
/**
 * @extends {EventEmitter}
 * @record
 * @struct
 */
function DocumentSelectionState() {}

/* TODO: ConstructSignature:  */

/**
 * Apply an update to the state. If either offset value has changed,
 * set the values and emit the `change` event. Otherwise no-op.
 * 
 * @param {number} anchor
 * @param {number} focus
 * @return {void}
 */
DocumentSelectionState.prototype.update = function(anchor, focus) {};

/**
 * Given a max text length, constrain our selection offsets to ensure
 * that the selection remains strictly within the text range.
 * 
 * @param {number} maxLength
 * @return {void}
 */
DocumentSelectionState.prototype.constrainLength = function(maxLength) {};

/**
 * @return {void}
 */
DocumentSelectionState.prototype.focus = function() {};

/**
 * @return {void}
 */
DocumentSelectionState.prototype.blur = function() {};

/**
 * @return {boolean}
 */
DocumentSelectionState.prototype.hasFocus = function() {};

/**
 * @return {boolean}
 */
DocumentSelectionState.prototype.isCollapsed = function() {};

/**
 * @return {boolean}
 */
DocumentSelectionState.prototype.isBackward = function() {};

/**
 * @return {number}
 */
DocumentSelectionState.prototype.getAnchorOffset = function() {};

/**
 * @return {number}
 */
DocumentSelectionState.prototype.getFocusOffset = function() {};

/**
 * @return {number}
 */
DocumentSelectionState.prototype.getStartOffset = function() {};

/**
 * @return {number}
 */
DocumentSelectionState.prototype.getEndOffset = function() {};

/**
 * @param {number} start
 * @param {number} end
 * @return {boolean}
 */
DocumentSelectionState.prototype.overlaps = function(start, end) {};
/**
 * @record
 * @struct
 */
function TextInputIOSProperties() {}
 /** @type {string} */
TextInputIOSProperties.prototype.clearButtonMode;
 /** @type {boolean} */
TextInputIOSProperties.prototype.clearTextOnFocus;
 /** @type {(string|!Array<string>)} */
TextInputIOSProperties.prototype.dataDetectorTypes;
 /** @type {boolean} */
TextInputIOSProperties.prototype.enablesReturnKeyAutomatically;
 /** @type {string} */
TextInputIOSProperties.prototype.keyboardAppearance;
 /** @type {?} */
TextInputIOSProperties.prototype.onKeyPress;
 /** @type {?} */
TextInputIOSProperties.prototype.selectionState;
 /** @type {boolean} */
TextInputIOSProperties.prototype.spellCheck;
/**
 * @record
 * @struct
 */
function TextInputAndroidProperties() {}
 /** @type {boolean} */
TextInputAndroidProperties.prototype.disableFullscreenUI;
 /** @type {string} */
TextInputAndroidProperties.prototype.inlineImageLeft;
 /** @type {number} */
TextInputAndroidProperties.prototype.inlineImagePadding;
 /** @type {number} */
TextInputAndroidProperties.prototype.numberOfLines;
 /** @type {string} */
TextInputAndroidProperties.prototype.returnKeyLabel;
 /** @type {string} */
TextInputAndroidProperties.prototype.textBreakStrategy;
 /** @type {string} */
TextInputAndroidProperties.prototype.underlineColorAndroid;

/** @typedef {string} */
var KeyboardType;

/** @typedef {string} */
var KeyboardTypeIOS;

/** @typedef {string} */
var ReturnKeyType;

/** @typedef {string} */
var ReturnKeyTypeAndroid;

/** @typedef {string} */
var ReturnKeyTypeIOS;
/**
 * @extends {ViewProperties}
 * @extends {TextInputIOSProperties}
 * @extends {TextInputAndroidProperties}
 * @record
 * @struct
 */
function TextInputProperties() {}
 /** @type {string} */
TextInputProperties.prototype.autoCapitalize;
 /** @type {boolean} */
TextInputProperties.prototype.autoCorrect;
 /** @type {boolean} */
TextInputProperties.prototype.autoFocus;
 /** @type {boolean} */
TextInputProperties.prototype.blurOnSubmit;
 /** @type {string} */
TextInputProperties.prototype.defaultValue;
 /** @type {boolean} */
TextInputProperties.prototype.editable;
 /** @type {string} */
TextInputProperties.prototype.keyboardType;
 /** @type {number} */
TextInputProperties.prototype.maxLength;
 /** @type {boolean} */
TextInputProperties.prototype.multiline;
 /** @type {?} */
TextInputProperties.prototype.onBlur;
 /** @type {?} */
TextInputProperties.prototype.onChange;
 /** @type {?} */
TextInputProperties.prototype.onChangeText;
 /** @type {?} */
TextInputProperties.prototype.onContentSizeChange;
 /** @type {?} */
TextInputProperties.prototype.onEndEditing;
 /** @type {?} */
TextInputProperties.prototype.onFocus;
 /** @type {?} */
TextInputProperties.prototype.onSelectionChange;
 /** @type {?} */
TextInputProperties.prototype.onSubmitEditing;
 /** @type {string} */
TextInputProperties.prototype.placeholder;
 /** @type {string} */
TextInputProperties.prototype.placeholderTextColor;
 /** @type {string} */
TextInputProperties.prototype.returnKeyType;
 /** @type {boolean} */
TextInputProperties.prototype.secureTextEntry;
 /** @type {boolean} */
TextInputProperties.prototype.selectTextOnFocus;
 /** @type {?} */
TextInputProperties.prototype.selection;
 /** @type {string} */
TextInputProperties.prototype.selectionColor;
 /** @type {(boolean|?)} */
TextInputProperties.prototype.style;
 /** @type {string} */
TextInputProperties.prototype.testID;
 /** @type {string} */
TextInputProperties.prototype.value;
/**
 * @record
 * @struct
 */
function TextInputState() {}

/**
 * Returns the ID of the currently focused text field, if one exists
 * If no text field is focused it returns null
 * @return {number}
 */
TextInputState.prototype.currentlyFocusedField = function() {};

/**
 * Focuses the specified text field
 * noop if the text field was already focused
 * @param {number=} textFieldID
 * @return {void}
 */
TextInputState.prototype.focusTextInput = function(textFieldID) {};

/**
 * Unfocuses the specified text field
 * noop if it wasn't focused
 * @param {number=} textFieldID
 * @return {void}
 */
TextInputState.prototype.blurTextInput = function(textFieldID) {};
/**
 * @extends {NativeMethodsMixin}
 * @extends {TimerMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function TextInputStatic() {}
 /** @type {?} */
TextInputStatic.prototype.State;
 /** @type {?} */
TextInputStatic.prototype.isFocused;
 /** @type {?} */
TextInputStatic.prototype.clear;

/** @typedef {?} */
var ToolbarAndroidAction;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function ToolbarAndroidProperties() {}
 /** @type {!Array<?>} */
ToolbarAndroidProperties.prototype.actions;
 /** @type {number} */
ToolbarAndroidProperties.prototype.contentInsetEnd;
 /** @type {number} */
ToolbarAndroidProperties.prototype.contentInsetStart;
 /** @type {?} */
ToolbarAndroidProperties.prototype.logo;
 /** @type {?} */
ToolbarAndroidProperties.prototype.navIcon;
 /** @type {?} */
ToolbarAndroidProperties.prototype.onActionSelected;
 /** @type {?} */
ToolbarAndroidProperties.prototype.onIconClicked;
 /** @type {?} */
ToolbarAndroidProperties.prototype.overflowIcon;
 /** @type {boolean} */
ToolbarAndroidProperties.prototype.rtl;
 /** @type {string} */
ToolbarAndroidProperties.prototype.subtitle;
 /** @type {string} */
ToolbarAndroidProperties.prototype.subtitleColor;
 /** @type {string} */
ToolbarAndroidProperties.prototype.testID;
 /** @type {string} */
ToolbarAndroidProperties.prototype.title;
 /** @type {string} */
ToolbarAndroidProperties.prototype.titleColor;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function ToolbarAndroidStatic() {}
/**
 * @record
 * @struct
 */
function GestureResponderHandlers() {}
 /** @type {?} */
GestureResponderHandlers.prototype.onStartShouldSetResponder;
 /** @type {?} */
GestureResponderHandlers.prototype.onMoveShouldSetResponder;
 /** @type {?} */
GestureResponderHandlers.prototype.onResponderEnd;
 /** @type {?} */
GestureResponderHandlers.prototype.onResponderGrant;
 /** @type {?} */
GestureResponderHandlers.prototype.onResponderReject;
 /** @type {?} */
GestureResponderHandlers.prototype.onResponderMove;
 /** @type {?} */
GestureResponderHandlers.prototype.onResponderRelease;
 /** @type {?} */
GestureResponderHandlers.prototype.onResponderStart;
 /** @type {?} */
GestureResponderHandlers.prototype.onResponderTerminationRequest;
 /** @type {?} */
GestureResponderHandlers.prototype.onResponderTerminate;
 /** @type {?} */
GestureResponderHandlers.prototype.onStartShouldSetResponderCapture;
 /** @type {?} */
GestureResponderHandlers.prototype.onMoveShouldSetResponderCapture;
/**
 * @extends {FlexStyle}
 * @extends {TransformsStyle}
 * @record
 * @struct
 */
function ViewStyle() {}
 /** @type {string} */
ViewStyle.prototype.backfaceVisibility;
 /** @type {string} */
ViewStyle.prototype.backgroundColor;
 /** @type {string} */
ViewStyle.prototype.borderBottomColor;
 /** @type {number} */
ViewStyle.prototype.borderBottomLeftRadius;
 /** @type {number} */
ViewStyle.prototype.borderBottomRightRadius;
 /** @type {number} */
ViewStyle.prototype.borderBottomWidth;
 /** @type {string} */
ViewStyle.prototype.borderColor;
 /** @type {string} */
ViewStyle.prototype.borderLeftColor;
 /** @type {number} */
ViewStyle.prototype.borderRadius;
 /** @type {string} */
ViewStyle.prototype.borderRightColor;
 /** @type {number} */
ViewStyle.prototype.borderRightWidth;
 /** @type {string} */
ViewStyle.prototype.borderStyle;
 /** @type {string} */
ViewStyle.prototype.borderTopColor;
 /** @type {number} */
ViewStyle.prototype.borderTopLeftRadius;
 /** @type {number} */
ViewStyle.prototype.borderTopRightRadius;
 /** @type {number} */
ViewStyle.prototype.borderTopWidth;
 /** @type {number} */
ViewStyle.prototype.opacity;
 /** @type {string} */
ViewStyle.prototype.overflow;
 /** @type {string} */
ViewStyle.prototype.shadowColor;
 /** @type {?} */
ViewStyle.prototype.shadowOffset;
 /** @type {number} */
ViewStyle.prototype.shadowOpacity;
 /** @type {number} */
ViewStyle.prototype.shadowRadius;
 /** @type {number} */
ViewStyle.prototype.elevation;
 /** @type {string} */
ViewStyle.prototype.testID;
/**
 * @record
 * @struct
 */
function ViewPropertiesIOS() {}
 /** @type {(string|!Array<string>)} */
ViewPropertiesIOS.prototype.accessibilityTraits;
 /** @type {boolean} */
ViewPropertiesIOS.prototype.shouldRasterizeIOS;
/**
 * @record
 * @struct
 */
function ViewPropertiesAndroid() {}
 /** @type {string} */
ViewPropertiesAndroid.prototype.accessibilityComponentType;
 /** @type {string} */
ViewPropertiesAndroid.prototype.accessibilityLiveRegion;
 /** @type {boolean} */
ViewPropertiesAndroid.prototype.collapsable;
 /** @type {string} */
ViewPropertiesAndroid.prototype.importantForAccessibility;
 /** @type {boolean} */
ViewPropertiesAndroid.prototype.needsOffscreenAlphaCompositing;
 /** @type {boolean} */
ViewPropertiesAndroid.prototype.renderToHardwareTextureAndroid;

/** @typedef {boolean} */
var Falsy;
/**
 * @record
 * @struct
 */
function RecursiveArray() {}

/** @typedef {?} */
var RegisteredStyle;

/** @typedef {(boolean|?)} */
var StyleProp;
/**
 * @extends {ViewPropertiesAndroid}
 * @extends {ViewPropertiesIOS}
 * @extends {GestureResponderHandlers}
 * @extends {Touchable}
 * @record
 * @struct
 */
function ViewProperties() {}
 /** @type {string} */
ViewProperties.prototype.accessibilityLabel;
 /** @type {boolean} */
ViewProperties.prototype.accessible;
 /** @type {?} */
ViewProperties.prototype.hitSlop;
 /** @type {?} */
ViewProperties.prototype.onAcccessibilityTap;
 /** @type {?} */
ViewProperties.prototype.onLayout;
 /** @type {?} */
ViewProperties.prototype.onMagicTap;
 /** @type {string} */
ViewProperties.prototype.pointerEvents;
 /** @type {boolean} */
ViewProperties.prototype.removeClippedSubviews;
 /** @type {(boolean|?)} */
ViewProperties.prototype.style;
 /** @type {string} */
ViewProperties.prototype.testID;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function ViewStatic() {}
 /** @type {!Array<?>} */
ViewStatic.prototype.AccessibilityTraits;
 /** @type {!Array<?>} */
ViewStatic.prototype.AccessibilityComponentType;
 /** @type {boolean} */
ViewStatic.prototype.forceTouchAvailable;
/**
 * @record
 * @struct
 */
function ViewPagerAndroidOnPageScrollEventData() {}
 /** @type {number} */
ViewPagerAndroidOnPageScrollEventData.prototype.position;
 /** @type {number} */
ViewPagerAndroidOnPageScrollEventData.prototype.offset;
/**
 * @record
 * @struct
 */
function ViewPagerAndroidOnPageSelectedEventData() {}
 /** @type {number} */
ViewPagerAndroidOnPageSelectedEventData.prototype.position;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function ViewPagerAndroidProperties() {}
 /** @type {number} */
ViewPagerAndroidProperties.prototype.initialPage;
 /** @type {boolean} */
ViewPagerAndroidProperties.prototype.scrollEnabled;
 /** @type {?} */
ViewPagerAndroidProperties.prototype.onPageScroll;
 /** @type {?} */
ViewPagerAndroidProperties.prototype.onPageSelected;
 /** @type {?} */
ViewPagerAndroidProperties.prototype.onPageScrollStateChanged;
 /** @type {string} */
ViewPagerAndroidProperties.prototype.keyboardDismissMode;
 /** @type {number} */
ViewPagerAndroidProperties.prototype.pageMargin;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function ViewPagerAndroidStatic() {}

/**
 * A helper function to scroll to a specific page in the ViewPager.
 * The transition between pages will be animated.
 * @param {number} selectedPage
 * @return {void}
 */
ViewPagerAndroidStatic.prototype.setPage = function(selectedPage) {};

/**
 * A helper function to scroll to a specific page in the ViewPager.
 * The transition between pages will *not* be animated.
 * @param {number} selectedPage
 * @return {void}
 */
ViewPagerAndroidStatic.prototype.setPageWithoutAnimation = function(selectedPage) {};
/**
 * @extends {TimerMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function KeyboardAvoidingViewStatic() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function KeyboardAvoidingViewProps() {}
 /** @type {string} */
KeyboardAvoidingViewProps.prototype.behavior;
 /** @type {(boolean|?)} */
KeyboardAvoidingViewProps.prototype.contentContainerStyle;
 /** @type {number} */
KeyboardAvoidingViewProps.prototype.keyboardVerticalOffset;
/**
 * @record
 * @struct
 */
function NavState() {}
 /** @type {string} */
NavState.prototype.url;
 /** @type {string} */
NavState.prototype.title;
 /** @type {boolean} */
NavState.prototype.loading;
 /** @type {boolean} */
NavState.prototype.canGoBack;
 /** @type {boolean} */
NavState.prototype.canGoForward;

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function WebViewMessageEventData() {}
 /** @type {string} */
WebViewMessageEventData.prototype.data;
/**
 * @record
 * @struct
 */
function WebViewPropertiesAndroid() {}
 /** @type {boolean} */
WebViewPropertiesAndroid.prototype.javaScriptEnabled;
 /** @type {boolean} */
WebViewPropertiesAndroid.prototype.domStorageEnabled;
 /** @type {string} */
WebViewPropertiesAndroid.prototype.userAgent;
/**
 * @record
 * @struct
 */
function WebViewIOSLoadRequestEvent() {}
 /** @type {number} */
WebViewIOSLoadRequestEvent.prototype.target;
 /** @type {boolean} */
WebViewIOSLoadRequestEvent.prototype.canGoBack;
 /** @type {number} */
WebViewIOSLoadRequestEvent.prototype.lockIdentifier;
 /** @type {boolean} */
WebViewIOSLoadRequestEvent.prototype.loading;
 /** @type {string} */
WebViewIOSLoadRequestEvent.prototype.title;
 /** @type {boolean} */
WebViewIOSLoadRequestEvent.prototype.canGoForward;
 /** @type {string} */
WebViewIOSLoadRequestEvent.prototype.navigationType;
 /** @type {string} */
WebViewIOSLoadRequestEvent.prototype.url;
/**
 * @record
 * @struct
 */
function WebViewPropertiesIOS() {}
 /** @type {boolean} */
WebViewPropertiesIOS.prototype.allowsInlineMediaPlayback;
 /** @type {boolean} */
WebViewPropertiesIOS.prototype.bounces;
 /** @type {(string|!Array<string>)} */
WebViewPropertiesIOS.prototype.dataDetectorTypes;
 /** @type {(number|string)} */
WebViewPropertiesIOS.prototype.decelerationRate;
 /** @type {?} */
WebViewPropertiesIOS.prototype.onShouldStartLoadWithRequest;
 /** @type {boolean} */
WebViewPropertiesIOS.prototype.scrollEnabled;
/**
 * @record
 * @struct
 */
function WebViewUriSource() {}
 /** @type {string} */
WebViewUriSource.prototype.uri;
 /** @type {string} */
WebViewUriSource.prototype.method;
 /** @type {?} */
WebViewUriSource.prototype.headers;
 /** @type {string} */
WebViewUriSource.prototype.body;
/**
 * @record
 * @struct
 */
function WebViewHtmlSource() {}
 /** @type {string} */
WebViewHtmlSource.prototype.html;
 /** @type {string} */
WebViewHtmlSource.prototype.baseUrl;
/**
 * @extends {ViewProperties}
 * @extends {WebViewPropertiesAndroid}
 * @extends {WebViewPropertiesIOS}
 * @record
 * @struct
 */
function WebViewProperties() {}
 /** @type {boolean} */
WebViewProperties.prototype.automaticallyAdjustContentInsets;
 /** @type {?} */
WebViewProperties.prototype.contentInset;
 /** @type {string} */
WebViewProperties.prototype.html;
 /** @type {string} */
WebViewProperties.prototype.injectedJavaScript;
 /** @type {?} */
WebViewProperties.prototype.onError;
 /** @type {?} */
WebViewProperties.prototype.onLoad;
 /** @type {?} */
WebViewProperties.prototype.onLoadEnd;
 /** @type {?} */
WebViewProperties.prototype.onLoadStart;
 /** @type {?} */
WebViewProperties.prototype.onMessage;
 /** @type {?} */
WebViewProperties.prototype.onNavigationStateChange;
 /** @type {?} */
WebViewProperties.prototype.renderError;
 /** @type {?} */
WebViewProperties.prototype.renderLoading;
 /** @type {boolean} */
WebViewProperties.prototype.startInLoadingState;
 /** @type {(boolean|?)} */
WebViewProperties.prototype.style;
 /** @type {string} */
WebViewProperties.prototype.url;
 /** @type {(number|?)} */
WebViewProperties.prototype.source;
 /** @type {boolean} */
WebViewProperties.prototype.mediaPlaybackRequiresUserAction;
 /** @type {boolean} */
WebViewProperties.prototype.scalesPageToFit;
/**
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function WebViewStatic() {}
 /** @type {?} */
WebViewStatic.prototype.goBack;
 /** @type {?} */
WebViewStatic.prototype.goForward;
 /** @type {?} */
WebViewStatic.prototype.postMessage;
 /** @type {?} */
WebViewStatic.prototype.reload;
 /** @type {?} */
WebViewStatic.prototype.getWebViewHandle;

/**
 * Stop loading the current page.
 * @return {void}
 */
WebViewStatic.prototype.stopLoading = function() {};
/**
 * @record
 * @struct
 */
function NativeSegmentedControlIOSChangeEvent() {}
 /** @type {string} */
NativeSegmentedControlIOSChangeEvent.prototype.value;
 /** @type {number} */
NativeSegmentedControlIOSChangeEvent.prototype.selectedSegmentIndex;
 /** @type {number} */
NativeSegmentedControlIOSChangeEvent.prototype.target;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function SegmentedControlIOSProperties() {}
 /** @type {boolean} */
SegmentedControlIOSProperties.prototype.enabled;
 /** @type {boolean} */
SegmentedControlIOSProperties.prototype.momentary;
 /** @type {?} */
SegmentedControlIOSProperties.prototype.onChange;
 /** @type {?} */
SegmentedControlIOSProperties.prototype.onValueChange;
 /** @type {number} */
SegmentedControlIOSProperties.prototype.selectedIndex;
 /** @type {string} */
SegmentedControlIOSProperties.prototype.tintColor;
 /** @type {!Array<string>} */
SegmentedControlIOSProperties.prototype.values;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function SegmentedControlIOSStatic() {}
/**
 * @record
 * @struct
 */
function NavigatorIOSProperties() {}
 /** @type {string} */
NavigatorIOSProperties.prototype.barTintColor;
 /** @type {?} */
NavigatorIOSProperties.prototype.initialRoute;
 /** @type {(boolean|?)} */
NavigatorIOSProperties.prototype.itemWrapperStyle;
 /** @type {boolean} */
NavigatorIOSProperties.prototype.interactivePopGestureEnabled;
 /** @type {boolean} */
NavigatorIOSProperties.prototype.navigationBarHidden;
 /** @type {boolean} */
NavigatorIOSProperties.prototype.shadowHidden;
 /** @type {string} */
NavigatorIOSProperties.prototype.tintColor;
 /** @type {string} */
NavigatorIOSProperties.prototype.titleTextColor;
 /** @type {boolean} */
NavigatorIOSProperties.prototype.translucent;
 /** @type {(boolean|?)} */
NavigatorIOSProperties.prototype.style;
/**
 * @record
 * @struct
 */
function NavigationIOS() {}
 /** @type {?} */
NavigationIOS.prototype.push;
 /** @type {?} */
NavigationIOS.prototype.pop;
 /** @type {?} */
NavigationIOS.prototype.popN;
 /** @type {?} */
NavigationIOS.prototype.replace;
 /** @type {?} */
NavigationIOS.prototype.replacePrevious;
 /** @type {?} */
NavigationIOS.prototype.replacePreviousAndPop;
 /** @type {?} */
NavigationIOS.prototype.resetTo;

/**
 * Go back to the item for a particular route object
 * @param {?} route
 * @return {void}
 */
NavigationIOS.prototype.popToRoute = function(route) {};

/**
 * Go back to the top item
 * @return {void}
 */
NavigationIOS.prototype.popToTop = function() {};
/**
 * @extends {NavigationIOS}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function NavigatorIOSStatic() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function ActivityIndicatorProperties() {}
 /** @type {boolean} */
ActivityIndicatorProperties.prototype.animating;
 /** @type {string} */
ActivityIndicatorProperties.prototype.color;
 /** @type {boolean} */
ActivityIndicatorProperties.prototype.hidesWhenStopped;
 /** @type {(number|string)} */
ActivityIndicatorProperties.prototype.size;
 /** @type {(boolean|?)} */
ActivityIndicatorProperties.prototype.style;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function ActivityIndicatorStatic() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function ActivityIndicatorIOSProperties() {}
 /** @type {boolean} */
ActivityIndicatorIOSProperties.prototype.animating;
 /** @type {string} */
ActivityIndicatorIOSProperties.prototype.color;
 /** @type {boolean} */
ActivityIndicatorIOSProperties.prototype.hidesWhenStopped;
 /** @type {?} */
ActivityIndicatorIOSProperties.prototype.onLayout;
 /** @type {string} */
ActivityIndicatorIOSProperties.prototype.size;
 /** @type {(boolean|?)} */
ActivityIndicatorIOSProperties.prototype.style;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function ActivityIndicatorIOSStatic() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function DatePickerIOSProperties() {}
 /** @type {!Date} */
DatePickerIOSProperties.prototype.date;
 /** @type {!Date} */
DatePickerIOSProperties.prototype.maximumDate;
 /** @type {!Date} */
DatePickerIOSProperties.prototype.minimumDate;
 /** @type {number} */
DatePickerIOSProperties.prototype.minuteInterval;
 /** @type {string} */
DatePickerIOSProperties.prototype.mode;
 /** @type {?} */
DatePickerIOSProperties.prototype.onDateChange;
 /** @type {number} */
DatePickerIOSProperties.prototype.timeZoneOffsetInMinutes;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function DatePickerIOSStatic() {}
/**
 * @extends {NativeSyntheticEvent}
 * @record
 * @struct
 */
function DrawerSlideEvent() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function DrawerLayoutAndroidProperties() {}
 /** @type {string} */
DrawerLayoutAndroidProperties.prototype.drawerBackgroundColor;
 /** @type {string} */
DrawerLayoutAndroidProperties.prototype.drawerLockMode;
 /** @type {number} */
DrawerLayoutAndroidProperties.prototype.drawerPosition;
 /** @type {number} */
DrawerLayoutAndroidProperties.prototype.drawerWidth;
 /** @type {string} */
DrawerLayoutAndroidProperties.prototype.keyboardDismissMode;
 /** @type {?} */
DrawerLayoutAndroidProperties.prototype.onDrawerClose;
 /** @type {?} */
DrawerLayoutAndroidProperties.prototype.onDrawerOpen;
 /** @type {?} */
DrawerLayoutAndroidProperties.prototype.onDrawerSlide;
 /** @type {?} */
DrawerLayoutAndroidProperties.prototype.onDrawerStateChanged;
 /** @type {?} */
DrawerLayoutAndroidProperties.prototype.renderNavigationView;
 /** @type {string} */
DrawerLayoutAndroidProperties.prototype.statusBarBackgroundColor;
/**
 * @record
 * @struct
 */
function DrawerPosition() {}
 /** @type {number} */
DrawerPosition.prototype.Left;
 /** @type {number} */
DrawerPosition.prototype.Right;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function DrawerLayoutAndroidStatic() {}
 /** @type {?} */
DrawerLayoutAndroidStatic.prototype.positions;

/**
 * Opens the drawer.
 * @return {void}
 */
DrawerLayoutAndroidStatic.prototype.openDrawer = function() {};

/**
 * Closes the drawer.
 * @return {void}
 */
DrawerLayoutAndroidStatic.prototype.closeDrawer = function() {};
/**
 * @record
 * @struct
 */
function PickerIOSItemProperties() {}
 /** @type {(string|number)} */
PickerIOSItemProperties.prototype.value;
 /** @type {string} */
PickerIOSItemProperties.prototype.label;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function PickerIOSItemStatic() {}
/**
 * @record
 * @struct
 */
function PickerItemProperties() {}
 /** @type {string} */
PickerItemProperties.prototype.testID;
 /** @type {string} */
PickerItemProperties.prototype.color;
 /** @type {string} */
PickerItemProperties.prototype.label;
 /** @type {?} */
PickerItemProperties.prototype.value;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function PickerItem() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function PickerPropertiesIOS() {}
 /** @type {(boolean|?)} */
PickerPropertiesIOS.prototype.itemStyle;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function PickerPropertiesAndroid() {}
 /** @type {boolean} */
PickerPropertiesAndroid.prototype.enabled;
 /** @type {string} */
PickerPropertiesAndroid.prototype.mode;
 /** @type {string} */
PickerPropertiesAndroid.prototype.prompt;
/**
 * @extends {PickerPropertiesIOS}
 * @extends {PickerPropertiesAndroid}
 * @record
 * @struct
 */
function PickerProperties() {}
 /** @type {?} */
PickerProperties.prototype.onValueChange;
 /** @type {?} */
PickerProperties.prototype.selectedValue;
 /** @type {(boolean|?)} */
PickerProperties.prototype.style;
 /** @type {string} */
PickerProperties.prototype.testId;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function PickerStatic() {}
 /** @type {string} */
PickerStatic.prototype.MODE_DIALOG;
 /** @type {string} */
PickerStatic.prototype.MODE_DROPDOWN;
 /** @type {?} */
PickerStatic.prototype.Item;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function PickerIOSProperties() {}
 /** @type {(boolean|?)} */
PickerIOSProperties.prototype.itemStyle;
 /** @type {?} */
PickerIOSProperties.prototype.onValueChange;
 /** @type {(string|number)} */
PickerIOSProperties.prototype.selectedValue;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function PickerIOSStatic() {}
 /** @type {?} */
PickerIOSStatic.prototype.Item;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function ProgressBarAndroidProperties() {}
 /** @type {string} */
ProgressBarAndroidProperties.prototype.styleAttr;
 /** @type {boolean} */
ProgressBarAndroidProperties.prototype.indeterminate;
 /** @type {number} */
ProgressBarAndroidProperties.prototype.progress;
 /** @type {string} */
ProgressBarAndroidProperties.prototype.color;
 /** @type {string} */
ProgressBarAndroidProperties.prototype.testID;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function ProgressBarAndroidStatic() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function ProgressViewIOSProperties() {}
 /** @type {string} */
ProgressViewIOSProperties.prototype.progressViewStyle;
 /** @type {number} */
ProgressViewIOSProperties.prototype.progress;
 /** @type {string} */
ProgressViewIOSProperties.prototype.progressTintColor;
 /** @type {string} */
ProgressViewIOSProperties.prototype.trackTintColor;
 /** @type {(?|!Array<?>)} */
ProgressViewIOSProperties.prototype.progressImage;
 /** @type {(?|!Array<?>)} */
ProgressViewIOSProperties.prototype.trackImage;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function ProgressViewIOSStatic() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function RefreshControlPropertiesIOS() {}
 /** @type {string} */
RefreshControlPropertiesIOS.prototype.tintColor;
 /** @type {string} */
RefreshControlPropertiesIOS.prototype.title;
 /** @type {string} */
RefreshControlPropertiesIOS.prototype.titleColor;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function RefreshControlPropertiesAndroid() {}
 /** @type {!Array<string>} */
RefreshControlPropertiesAndroid.prototype.colors;
 /** @type {boolean} */
RefreshControlPropertiesAndroid.prototype.enabled;
 /** @type {string} */
RefreshControlPropertiesAndroid.prototype.progressBackgroundColor;
 /** @type {number} */
RefreshControlPropertiesAndroid.prototype.size;
 /** @type {number} */
RefreshControlPropertiesAndroid.prototype.progressViewOffset;
/**
 * @extends {RefreshControlPropertiesIOS}
 * @extends {RefreshControlPropertiesAndroid}
 * @record
 * @struct
 */
function RefreshControlProperties() {}
 /** @type {?} */
RefreshControlProperties.prototype.onRefresh;
 /** @type {boolean} */
RefreshControlProperties.prototype.refreshing;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function RefreshControlStatic() {}
 /** @type {!Object} */
RefreshControlStatic.prototype.SIZE;
/**
 * @extends {ScrollViewProperties}
 * @record
 * @struct
 */
function RecyclerViewBackedScrollViewProperties() {}
/**
 * @extends {ScrollResponderMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function RecyclerViewBackedScrollViewStatic() {}

/**
 * A helper function to scroll to a specific point  in the scrollview.
 * This is currently used to help focus on child textviews, but can also
 * be used to quickly scroll to any element we want to focus. Syntax:
 * 
 * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
 * 
 * Note: The weird argument signature is due to the fact that, for historical reasons,
 * the function also accepts separate arguments as as alternative to the options object.
 * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
 * @param {(number|?)=} y
 * @param {number=} x
 * @param {boolean=} animated
 * @return {void}
 */
RecyclerViewBackedScrollViewStatic.prototype.scrollTo = function(y, x, animated) {};

/**
 * Returns a reference to the underlying scroll responder, which supports
 * operations like `scrollTo`. All ScrollView-like components should
 * implement this method so that they can be composed while providing access
 * to the underlying scroll responder's methods.
 * @return {!JSX.Element}
 */
RecyclerViewBackedScrollViewStatic.prototype.getScrollResponder = function() {};
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function SliderPropertiesAndroid() {}
 /** @type {string} */
SliderPropertiesAndroid.prototype.thumbTintColor;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function SliderPropertiesIOS() {}
 /** @type {?} */
SliderPropertiesIOS.prototype.maximumTrackImage;
 /** @type {?} */
SliderPropertiesIOS.prototype.minimumTrackImage;
 /** @type {?} */
SliderPropertiesIOS.prototype.thumbImage;
 /** @type {?} */
SliderPropertiesIOS.prototype.trackImage;
/**
 * @extends {SliderPropertiesIOS}
 * @extends {SliderPropertiesAndroid}
 * @record
 * @struct
 */
function SliderProperties() {}
 /** @type {boolean} */
SliderProperties.prototype.disabled;
 /** @type {string} */
SliderProperties.prototype.maximumTrackTintColor;
 /** @type {number} */
SliderProperties.prototype.maximumValue;
 /** @type {string} */
SliderProperties.prototype.minimumTrackTintColor;
 /** @type {number} */
SliderProperties.prototype.minimumValue;
 /** @type {?} */
SliderProperties.prototype.onSlidingComplete;
 /** @type {?} */
SliderProperties.prototype.onValueChange;
 /** @type {number} */
SliderProperties.prototype.step;
 /** @type {(boolean|?)} */
SliderProperties.prototype.style;
 /** @type {string} */
SliderProperties.prototype.testID;
 /** @type {number} */
SliderProperties.prototype.value;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function SliderStatic() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function SwitchIOSProperties() {}
 /** @type {boolean} */
SwitchIOSProperties.prototype.disabled;
 /** @type {string} */
SwitchIOSProperties.prototype.onTintColor;
 /** @type {?} */
SwitchIOSProperties.prototype.onValueChange;
 /** @type {string} */
SwitchIOSProperties.prototype.thumbTintColor;
 /** @type {string} */
SwitchIOSProperties.prototype.tintColor;
 /** @type {boolean} */
SwitchIOSProperties.prototype.value;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function SwitchIOSStatic() {}

/** @typedef {string} */
var ImageResizeMode;
/**
 * @record
 * @struct
 */
function ImageResizeModeStatic() {}
 /** @type {string} */
ImageResizeModeStatic.prototype.contain;
 /** @type {string} */
ImageResizeModeStatic.prototype.cover;
 /** @type {string} */
ImageResizeModeStatic.prototype.stretch;
 /** @type {string} */
ImageResizeModeStatic.prototype.center;
 /** @type {string} */
ImageResizeModeStatic.prototype.repeat;
/**
 * @record
 * @struct
 */
function ShadowStyleIOS() {}
 /** @type {string} */
ShadowStyleIOS.prototype.shadowColor;
 /** @type {?} */
ShadowStyleIOS.prototype.shadowOffset;
 /** @type {number} */
ShadowStyleIOS.prototype.shadowOpacity;
 /** @type {number} */
ShadowStyleIOS.prototype.shadowRadius;
/**
 * @extends {FlexStyle}
 * @extends {TransformsStyle}
 * @extends {ShadowStyleIOS}
 * @record
 * @struct
 */
function ImageStyle() {}
 /** @type {string} */
ImageStyle.prototype.resizeMode;
 /** @type {string} */
ImageStyle.prototype.backfaceVisibility;
 /** @type {number} */
ImageStyle.prototype.borderBottomLeftRadius;
 /** @type {number} */
ImageStyle.prototype.borderBottomRightRadius;
 /** @type {string} */
ImageStyle.prototype.backgroundColor;
 /** @type {string} */
ImageStyle.prototype.borderColor;
 /** @type {number} */
ImageStyle.prototype.borderWidth;
 /** @type {number} */
ImageStyle.prototype.borderRadius;
 /** @type {number} */
ImageStyle.prototype.borderTopLeftRadius;
 /** @type {number} */
ImageStyle.prototype.borderTopRightRadius;
 /** @type {string} */
ImageStyle.prototype.overflow;
 /** @type {string} */
ImageStyle.prototype.overlayColor;
 /** @type {string} */
ImageStyle.prototype.tintColor;
 /** @type {number} */
ImageStyle.prototype.opacity;
/**
 * @record
 * @struct
 */
function ImageURISource() {}
 /** @type {string} */
ImageURISource.prototype.uri;
 /** @type {string} */
ImageURISource.prototype.bundle;
 /** @type {string} */
ImageURISource.prototype.method;
 /** @type {?} */
ImageURISource.prototype.headers;
 /** @type {string} */
ImageURISource.prototype.cache;
 /** @type {string} */
ImageURISource.prototype.body;
 /** @type {number} */
ImageURISource.prototype.width;
 /** @type {number} */
ImageURISource.prototype.height;
 /** @type {number} */
ImageURISource.prototype.scale;
/**
 * @record
 * @struct
 */
function ImagePropertiesIOS() {}
 /** @type {string} */
ImagePropertiesIOS.prototype.accessibilityLabel;
 /** @type {boolean} */
ImagePropertiesIOS.prototype.accessible;
 /** @type {number} */
ImagePropertiesIOS.prototype.blurRadius;
 /** @type {?} */
ImagePropertiesIOS.prototype.capInsets;
 /** @type {(number|?)} */
ImagePropertiesIOS.prototype.defaultSource;
 /** @type {?} */
ImagePropertiesIOS.prototype.onProgress;
 /** @type {?} */
ImagePropertiesIOS.prototype.onPartialLoad;
/**
 * @record
 * @struct
 */
function ImagePropertiesAndroid() {}
 /** @type {string} */
ImagePropertiesAndroid.prototype.resizeMethod;
/**
 * @extends {ImagePropertiesIOS}
 * @extends {ImagePropertiesAndroid}
 * @record
 * @struct
 */
function ImageProperties() {}
 /** @type {?} */
ImageProperties.prototype.onLayout;
 /** @type {?} */
ImageProperties.prototype.onError;
 /** @type {?} */
ImageProperties.prototype.onLoad;
 /** @type {?} */
ImageProperties.prototype.onLoadEnd;
 /** @type {?} */
ImageProperties.prototype.onLoadStart;
 /** @type {boolean} */
ImageProperties.prototype.progressiveRenderingEnabled;
 /** @type {string} */
ImageProperties.prototype.resizeMode;
 /** @type {string} */
ImageProperties.prototype.resizeMethod;
 /** @type {(?|!Array<?>)} */
ImageProperties.prototype.source;
 /** @type {?} */
ImageProperties.prototype.loadingIndicatorSource;
 /** @type {(boolean|?)} */
ImageProperties.prototype.style;
 /** @type {string} */
ImageProperties.prototype.testID;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function ImageStatic() {}
 /** @type {string} */
ImageStatic.prototype.resizeMode;

/**
 * @param {string} uri
 * @param {?} success
 * @param {?} failure
 * @return {?}
 */
ImageStatic.prototype.getSize = function(uri, success, failure) {};

/**
 * @param {string} url
 * @return {?}
 */
ImageStatic.prototype.prefetch = function(url) {};

/**
 * @param {number} requestId
 * @return {void}
 */
ImageStatic.prototype.abortPrefetch = function(requestId) {};

/**
 * @param {!Array<string>} urls
 * @return {!Promise<!Map<string, string>>}
 */
ImageStatic.prototype.queryCache = function(urls) {};
/**
 * @record
 * @struct
 */
function ViewToken() {}
 /** @type {?} */
ViewToken.prototype.item;
 /** @type {string} */
ViewToken.prototype.key;
 /** @type {number} */
ViewToken.prototype.index;
 /** @type {boolean} */
ViewToken.prototype.isViewable;
 /** @type {?} */
ViewToken.prototype.section;
/**
 * @record
 * @struct
 */
function ViewabilityConfig() {}
 /** @type {number} */
ViewabilityConfig.prototype.minimumViewTime;
 /** @type {number} */
ViewabilityConfig.prototype.viewAreaCoveragePercentThreshold;
 /** @type {number} */
ViewabilityConfig.prototype.itemVisiblePercentThreshold;
 /** @type {boolean} */
ViewabilityConfig.prototype.waitForInteraction;
/**
 * @record
 * @struct
 */
function ListRenderItemInfo() {}
 /** @type {?} */
ListRenderItemInfo.prototype.item;
 /** @type {number} */
ListRenderItemInfo.prototype.index;
 /** @type {?} */
ListRenderItemInfo.prototype.separators;

/** @typedef {?} */
var ListRenderItem;
/**
 * @extends {VirtualizedListProperties}
 * @record
 * @struct
 */
function FlatListProperties() {}
 /** @type {(!React.ComponentClass<?>|!React.StatelessComponent<?>)} */
FlatListProperties.prototype.ItemSeparatorComponent;
 /** @type {(!React.ComponentClass<?>|!React.ReactElement<?>|?)} */
FlatListProperties.prototype.ListEmptyComponent;
 /** @type {(!React.ComponentClass<?>|!React.ReactElement<?>|?)} */
FlatListProperties.prototype.ListFooterComponent;
 /** @type {(!React.ComponentClass<?>|!React.ReactElement<?>|?)} */
FlatListProperties.prototype.ListHeaderComponent;
 /** @type {(boolean|?)} */
FlatListProperties.prototype.columnWrapperStyle;
 /** @type {(boolean|string)} */
FlatListProperties.prototype.keyboardShouldPersistTaps;
 /** @type {!ReadonlyArray<?>} */
FlatListProperties.prototype.data;
 /** @type {?} */
FlatListProperties.prototype.extraData;
 /** @type {?} */
FlatListProperties.prototype.getItemLayout;
 /** @type {boolean} */
FlatListProperties.prototype.horizontal;
 /** @type {number} */
FlatListProperties.prototype.initialNumToRender;
 /** @type {number} */
FlatListProperties.prototype.initialScrollIndex;
 /** @type {?} */
FlatListProperties.prototype.keyExtractor;
 /** @type {boolean} */
FlatListProperties.prototype.legacyImplementation;
 /** @type {number} */
FlatListProperties.prototype.numColumns;
 /** @type {?} */
FlatListProperties.prototype.onEndReached;
 /** @type {number} */
FlatListProperties.prototype.onEndReachedThreshold;
 /** @type {?} */
FlatListProperties.prototype.onRefresh;
 /** @type {?} */
FlatListProperties.prototype.onViewableItemsChanged;
 /** @type {boolean} */
FlatListProperties.prototype.refreshing;
 /** @type {?} */
FlatListProperties.prototype.renderItem;
 /** @type {?} */
FlatListProperties.prototype.viewabilityConfig;
 /** @type {boolean} */
FlatListProperties.prototype.removeClippedSubviews;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function FlatListStatic() {}
 /** @type {?} */
FlatListStatic.prototype.getMetrics;
 /** @type {?} */
FlatListStatic.prototype.scrollToEnd;
 /** @type {?} */
FlatListStatic.prototype.scrollToIndex;
 /** @type {?} */
FlatListStatic.prototype.scrollToItem;
 /** @type {?} */
FlatListStatic.prototype.scrollToOffset;
 /** @type {?} */
FlatListStatic.prototype.recordInteraction;
/**
 * @record
 * @struct
 */
function SectionBase() {}
 /** @type {!Array<?>} */
SectionBase.prototype.data;
 /** @type {string} */
SectionBase.prototype.key;
 /** @type {?} */
SectionBase.prototype.renderItem;
 /** @type {!React.ComponentClass<?>} */
SectionBase.prototype.ItemSeparatorComponent;
 /** @type {?} */
SectionBase.prototype.keyExtractor;
/**
 * @extends {SectionBase}
 * @record
 * @struct
 */
function SectionListData() {}

/* TODO: IndexSignature:  */
/**
 * @extends {ScrollViewProperties}
 * @record
 * @struct
 */
function SectionListProperties() {}
 /** @type {!React.ComponentClass<?>} */
SectionListProperties.prototype.ItemSeparatorComponent;
 /** @type {(!React.ComponentClass<?>|!React.ReactElement<?>|?)} */
SectionListProperties.prototype.ListEmptyComponent;
 /** @type {(!React.ComponentClass<?>|?)} */
SectionListProperties.prototype.ListFooterComponent;
 /** @type {(!React.ComponentClass<?>|?)} */
SectionListProperties.prototype.ListHeaderComponent;
 /** @type {!React.ComponentClass<?>} */
SectionListProperties.prototype.SectionSeparatorComponent;
 /** @type {?} */
SectionListProperties.prototype.extraData;
 /** @type {number} */
SectionListProperties.prototype.initialNumToRender;
 /** @type {?} */
SectionListProperties.prototype.keyExtractor;
 /** @type {?} */
SectionListProperties.prototype.onRefresh;
 /** @type {boolean} */
SectionListProperties.prototype.refreshing;
 /** @type {?} */
SectionListProperties.prototype.renderItem;
 /** @type {?} */
SectionListProperties.prototype.renderSectionHeader;
 /** @type {?} */
SectionListProperties.prototype.renderSectionFooter;
 /** @type {!Array<?>} */
SectionListProperties.prototype.sections;
 /** @type {?} */
SectionListProperties.prototype.renderScrollComponent;
 /** @type {boolean} */
SectionListProperties.prototype.removeClippedSubviews;
 /** @type {boolean} */
SectionListProperties.prototype.stickySectionHeadersEnabled;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function SectionListStatic() {}
/**
 * @extends {ScrollViewProperties}
 * @record
 * @struct
 */
function VirtualizedListProperties() {}
 /** @type {(!React.ComponentClass<?>|!React.ReactElement<?>|?)} */
VirtualizedListProperties.prototype.ListEmptyComponent;
 /** @type {(!React.ComponentClass<?>|!React.ReactElement<?>|?)} */
VirtualizedListProperties.prototype.ListFooterComponent;
 /** @type {(!React.ComponentClass<?>|!React.ReactElement<?>|?)} */
VirtualizedListProperties.prototype.ListHeaderComponent;
 /** @type {?} */
VirtualizedListProperties.prototype.data;
 /** @type {boolean} */
VirtualizedListProperties.prototype.debug;
 /** @type {boolean} */
VirtualizedListProperties.prototype.disableVirtualization;
 /** @type {?} */
VirtualizedListProperties.prototype.extraData;
 /** @type {?} */
VirtualizedListProperties.prototype.getItem;
 /** @type {?} */
VirtualizedListProperties.prototype.getItemCount;
 /** @type {?} */
VirtualizedListProperties.prototype.getItemLayout;
 /** @type {boolean} */
VirtualizedListProperties.prototype.horizontal;
 /** @type {number} */
VirtualizedListProperties.prototype.initialNumToRender;
 /** @type {number} */
VirtualizedListProperties.prototype.initialScrollIndex;
 /** @type {boolean} */
VirtualizedListProperties.prototype.inverted;
 /** @type {?} */
VirtualizedListProperties.prototype.keyExtractor;
 /** @type {number} */
VirtualizedListProperties.prototype.maxToRenderPerBatch;
 /** @type {?} */
VirtualizedListProperties.prototype.onEndReached;
 /** @type {number} */
VirtualizedListProperties.prototype.onEndReachedThreshold;
 /** @type {?} */
VirtualizedListProperties.prototype.onLayout;
 /** @type {?} */
VirtualizedListProperties.prototype.onRefresh;
 /** @type {?} */
VirtualizedListProperties.prototype.onViewableItemsChanged;
 /** @type {number} */
VirtualizedListProperties.prototype.progressViewOffset;
 /** @type {boolean} */
VirtualizedListProperties.prototype.refreshing;
 /** @type {boolean} */
VirtualizedListProperties.prototype.removeClippedSubviews;
 /** @type {?} */
VirtualizedListProperties.prototype.renderItem;
 /** @type {?} */
VirtualizedListProperties.prototype.renderScrollComponent;
 /** @type {number} */
VirtualizedListProperties.prototype.updateCellsBatchingPeriod;
 /** @type {?} */
VirtualizedListProperties.prototype.viewabilityConfig;
 /** @type {number} */
VirtualizedListProperties.prototype.windowSize;
/**
 * @extends {ScrollViewProperties}
 * @record
 * @struct
 */
function ListViewProperties() {}
 /** @type {?} */
ListViewProperties.prototype.dataSource;
 /** @type {boolean} */
ListViewProperties.prototype.enableEmptySections;
 /** @type {number} */
ListViewProperties.prototype.initialListSize;
 /** @type {?} */
ListViewProperties.prototype.onChangeVisibleRows;
 /** @type {?} */
ListViewProperties.prototype.onEndReached;
 /** @type {number} */
ListViewProperties.prototype.onEndReachedThreshold;
 /** @type {number} */
ListViewProperties.prototype.pageSize;
 /** @type {boolean} */
ListViewProperties.prototype.removeClippedSubviews;
 /** @type {?} */
ListViewProperties.prototype.renderFooter;
 /** @type {?} */
ListViewProperties.prototype.renderHeader;
 /** @type {?} */
ListViewProperties.prototype.renderRow;
 /** @type {?} */
ListViewProperties.prototype.renderScrollComponent;
 /** @type {?} */
ListViewProperties.prototype.renderSectionHeader;
 /** @type {?} */
ListViewProperties.prototype.renderSeparator;
 /** @type {number} */
ListViewProperties.prototype.scrollRenderAheadDistance;
 /** @type {!Array<number>} */
ListViewProperties.prototype.stickyHeaderIndices;
 /** @type {boolean} */
ListViewProperties.prototype.stickySectionHeadersEnabled;
/**
 * @record
 * @struct
 */
function TimerMixin() {}
 /** @type {?} */
TimerMixin.prototype.setTimeout;
 /** @type {function(number): void} */
TimerMixin.prototype.clearTimeout;
 /** @type {?} */
TimerMixin.prototype.setInterval;
 /** @type {function(number): void} */
TimerMixin.prototype.clearInterval;
 /** @type {?} */
TimerMixin.prototype.setImmediate;
 /** @type {function(number): void} */
TimerMixin.prototype.clearImmediate;
 /** @type {function(!FrameRequestCallback): number} */
TimerMixin.prototype.requestAnimationFrame;
 /** @type {function(number): void} */
TimerMixin.prototype.cancelAnimationFrame;
/**
 * @extends {ScrollResponderMixin}
 * @extends {TimerMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function ListViewStatic() {}
 /** @type {?} */
ListViewStatic.prototype.DataSource;
 /** @type {?} */
ListViewStatic.prototype.getMetrics;
 /** @type {?} */
ListViewStatic.prototype.getScrollResponder;
 /** @type {?} */
ListViewStatic.prototype.scrollTo;
/**
 * @record
 * @struct
 */
function MapViewAnnotation() {}
 /** @type {number} */
MapViewAnnotation.prototype.latitude;
 /** @type {number} */
MapViewAnnotation.prototype.longitude;
 /** @type {boolean} */
MapViewAnnotation.prototype.animateDrop;
 /** @type {boolean} */
MapViewAnnotation.prototype.draggable;
 /** @type {?} */
MapViewAnnotation.prototype.onDragStateChange;
 /** @type {?} */
MapViewAnnotation.prototype.onFocus;
 /** @type {?} */
MapViewAnnotation.prototype.onBlur;
 /** @type {string} */
MapViewAnnotation.prototype.title;
 /** @type {string} */
MapViewAnnotation.prototype.subtitle;
 /** @type {!React.ReactElement<?>} */
MapViewAnnotation.prototype.leftCalloutView;
 /** @type {!React.ReactElement<?>} */
MapViewAnnotation.prototype.rightCalloutView;
 /** @type {!React.ReactElement<?>} */
MapViewAnnotation.prototype.detailCalloutView;
 /** @type {string} */
MapViewAnnotation.prototype.tintColor;
 /** @type {?} */
MapViewAnnotation.prototype.image;
 /** @type {!React.ReactElement<?>} */
MapViewAnnotation.prototype.view;
 /** @type {boolean} */
MapViewAnnotation.prototype.hasLeftCallout;
 /** @type {boolean} */
MapViewAnnotation.prototype.hasRightCallout;
 /** @type {?} */
MapViewAnnotation.prototype.onLeftCalloutPress;
 /** @type {?} */
MapViewAnnotation.prototype.onRightCalloutPress;
 /** @type {string} */
MapViewAnnotation.prototype.id;
/**
 * @record
 * @struct
 */
function MapViewRegion() {}
 /** @type {number} */
MapViewRegion.prototype.latitude;
 /** @type {number} */
MapViewRegion.prototype.longitude;
 /** @type {number} */
MapViewRegion.prototype.latitudeDelta;
 /** @type {number} */
MapViewRegion.prototype.longitudeDelta;
/**
 * @record
 * @struct
 */
function MapViewOverlay() {}
 /** @type {!Array<?>} */
MapViewOverlay.prototype.coordinates;
 /** @type {number} */
MapViewOverlay.prototype.lineWidth;
 /** @type {string} */
MapViewOverlay.prototype.strokeColor;
 /** @type {string} */
MapViewOverlay.prototype.fillColor;
 /** @type {string} */
MapViewOverlay.prototype.id;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function MapViewProperties() {}
 /** @type {boolean} */
MapViewProperties.prototype.showsPointsOfInterest;
 /** @type {!Array<?>} */
MapViewProperties.prototype.annotations;
 /** @type {boolean} */
MapViewProperties.prototype.followUserLocation;
 /** @type {?} */
MapViewProperties.prototype.legalLabelInsets;
 /** @type {string} */
MapViewProperties.prototype.mapType;
 /** @type {number} */
MapViewProperties.prototype.maxDelta;
 /** @type {number} */
MapViewProperties.prototype.minDelta;
 /** @type {!Array<?>} */
MapViewProperties.prototype.overlays;
 /** @type {boolean} */
MapViewProperties.prototype.showsCompass;
 /** @type {?} */
MapViewProperties.prototype.onAnnotationPress;
 /** @type {?} */
MapViewProperties.prototype.onRegionChange;
 /** @type {?} */
MapViewProperties.prototype.onRegionChangeComplete;
 /** @type {boolean} */
MapViewProperties.prototype.pitchEnabled;
 /** @type {?} */
MapViewProperties.prototype.region;
 /** @type {boolean} */
MapViewProperties.prototype.rotateEnabled;
 /** @type {boolean} */
MapViewProperties.prototype.scrollEnabled;
 /** @type {boolean} */
MapViewProperties.prototype.showsUserLocation;
 /** @type {(boolean|?)} */
MapViewProperties.prototype.style;
 /** @type {boolean} */
MapViewProperties.prototype.zoomEnabled;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function MapViewStatic() {}
 /** @type {?} */
MapViewStatic.prototype.PinColors;
/**
 * @record
 * @struct
 */
function ModalProperties() {}
 /** @type {boolean} */
ModalProperties.prototype.animated;
 /** @type {string} */
ModalProperties.prototype.animationType;
 /** @type {boolean} */
ModalProperties.prototype.transparent;
 /** @type {boolean} */
ModalProperties.prototype.visible;
 /** @type {?} */
ModalProperties.prototype.onRequestClose;
 /** @type {?} */
ModalProperties.prototype.onShow;
 /** @type {!Array<string>} */
ModalProperties.prototype.supportedOrientations;
 /** @type {?} */
ModalProperties.prototype.onOrientationChange;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function ModalStatic() {}
/**
 * @record
 * @struct
 */
function TouchableMixin() {}

/**
 * Invoked when the item should be highlighted. Mixers should implement this
 * to visually distinguish the `VisualRect` so that the user knows that
 * releasing a touch will result in a "selection" (analog to click).
 * @param {!Event} e
 * @return {void}
 */
TouchableMixin.prototype.touchableHandleActivePressIn = function(e) {};

/**
 * Invoked when the item is "active" (in that it is still eligible to become
 * a "select") but the touch has left the `PressRect`. Usually the mixer will
 * want to unhighlight the `VisualRect`. If the user (while pressing) moves
 * back into the `PressRect` `touchableHandleActivePressIn` will be invoked
 * again and the mixer should probably highlight the `VisualRect` again. This
 * event will not fire on an `touchEnd/mouseUp` event, only move events while
 * the user is depressing the mouse/touch.
 * @param {!Event} e
 * @return {void}
 */
TouchableMixin.prototype.touchableHandleActivePressOut = function(e) {};

/**
 * Invoked when the item is "selected" - meaning the interaction ended by
 * letting up while the item was either in the state
 * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.
 * @param {!Event} e
 * @return {void}
 */
TouchableMixin.prototype.touchableHandlePress = function(e) {};

/**
 * Invoked when the item is long pressed - meaning the interaction ended by
 * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If
 * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will
 * be called as it normally is. If `touchableHandleLongPress` is provided, by
 * default any `touchableHandlePress` callback will not be invoked. To
 * override this default behavior, override `touchableLongPressCancelsPress`
 * to return false. As a result, `touchableHandlePress` will be called when
 * lifting up, even if `touchableHandleLongPress` has also been called.
 * @param {!Event} e
 * @return {void}
 */
TouchableMixin.prototype.touchableHandleLongPress = function(e) {};

/**
 * Returns the amount to extend the `HitRect` into the `PressRect`. Positive
 * numbers mean the size expands outwards.
 * @return {?}
 */
TouchableMixin.prototype.touchableGetPressRectOffset = function() {};

/**
 * Returns the number of millis to wait before triggering a highlight.
 * @return {number}
 */
TouchableMixin.prototype.touchableGetHighlightDelayMS = function() {};

/**
 * @return {number}
 */
TouchableMixin.prototype.touchableGetLongPressDelayMS = function() {};

/**
 * @return {number}
 */
TouchableMixin.prototype.touchableGetPressOutDelayMS = function() {};

/**
 * @return {?}
 */
TouchableMixin.prototype.touchableGetHitSlop = function() {};
/**
 * @record
 * @struct
 */
function TouchableWithoutFeedbackAndroidProperties() {}
 /** @type {string} */
TouchableWithoutFeedbackAndroidProperties.prototype.accessibilityComponentType;

/** @typedef {string} */
var ViewAccessibilityTraits;
/**
 * @record
 * @struct
 */
function TouchableWithoutFeedbackIOSProperties() {}
 /** @type {(string|!Array<string>)} */
TouchableWithoutFeedbackIOSProperties.prototype.accessibilityTraits;
/**
 * @extends {TouchableWithoutFeedbackAndroidProperties}
 * @extends {TouchableWithoutFeedbackIOSProperties}
 * @record
 * @struct
 */
function TouchableWithoutFeedbackProperties() {}
 /** @type {string} */
TouchableWithoutFeedbackProperties.prototype.accessibilityLabel;
 /** @type {boolean} */
TouchableWithoutFeedbackProperties.prototype.accessible;
 /** @type {number} */
TouchableWithoutFeedbackProperties.prototype.delayLongPress;
 /** @type {number} */
TouchableWithoutFeedbackProperties.prototype.delayPressIn;
 /** @type {number} */
TouchableWithoutFeedbackProperties.prototype.delayPressOut;
 /** @type {boolean} */
TouchableWithoutFeedbackProperties.prototype.disabled;
 /** @type {?} */
TouchableWithoutFeedbackProperties.prototype.hitSlop;
 /** @type {?} */
TouchableWithoutFeedbackProperties.prototype.onLayout;
 /** @type {?} */
TouchableWithoutFeedbackProperties.prototype.onLongPress;
 /** @type {?} */
TouchableWithoutFeedbackProperties.prototype.onPress;
 /** @type {?} */
TouchableWithoutFeedbackProperties.prototype.onPressIn;
 /** @type {?} */
TouchableWithoutFeedbackProperties.prototype.onPressOut;
 /** @type {(boolean|?)} */
TouchableWithoutFeedbackProperties.prototype.style;
 /** @type {?} */
TouchableWithoutFeedbackProperties.prototype.pressRetentionOffset;
 /** @type {string} */
TouchableWithoutFeedbackProperties.prototype.testID;
/**
 * @extends {TouchableWithoutFeedbackProperties}
 * @record
 * @struct
 */
function TouchableWithoutFeedbackProps() {}
/**
 * @extends {TimerMixin}
 * @extends {TouchableMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function TouchableWithoutFeedbackStatic() {}
/**
 * @extends {TouchableWithoutFeedbackProperties}
 * @record
 * @struct
 */
function TouchableHighlightProperties() {}
 /** @type {number} */
TouchableHighlightProperties.prototype.activeOpacity;
 /** @type {?} */
TouchableHighlightProperties.prototype.onHideUnderlay;
 /** @type {?} */
TouchableHighlightProperties.prototype.onShowUnderlay;
 /** @type {(boolean|?)} */
TouchableHighlightProperties.prototype.style;
 /** @type {string} */
TouchableHighlightProperties.prototype.underlayColor;
/**
 * @extends {NativeMethodsMixin}
 * @extends {TimerMixin}
 * @extends {TouchableMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function TouchableHighlightStatic() {}
/**
 * @extends {TouchableWithoutFeedbackProperties}
 * @record
 * @struct
 */
function TouchableOpacityProperties() {}
 /** @type {number} */
TouchableOpacityProperties.prototype.activeOpacity;
/**
 * @extends {TimerMixin}
 * @extends {TouchableMixin}
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function TouchableOpacityStatic() {}
 /** @type {?} */
TouchableOpacityStatic.prototype.setOpacityTo;
/**
 * @record
 * @struct
 */
function BaseBackgroundPropType() {}
 /** @type {string} */
BaseBackgroundPropType.prototype.type;
/**
 * @extends {BaseBackgroundPropType}
 * @record
 * @struct
 */
function RippleBackgroundPropType() {}
 /** @type {string} */
RippleBackgroundPropType.prototype.type;
 /** @type {number} */
RippleBackgroundPropType.prototype.color;
 /** @type {boolean} */
RippleBackgroundPropType.prototype.borderless;
/**
 * @extends {BaseBackgroundPropType}
 * @record
 * @struct
 */
function ThemeAttributeBackgroundPropType() {}
 /** @type {string} */
ThemeAttributeBackgroundPropType.prototype.type;
 /** @type {string} */
ThemeAttributeBackgroundPropType.prototype.attribute;

/** @typedef {?} */
var BackgroundPropType;
/**
 * @extends {TouchableWithoutFeedbackProperties}
 * @record
 * @struct
 */
function TouchableNativeFeedbackProperties() {}
 /** @type {?} */
TouchableNativeFeedbackProperties.prototype.background;
 /** @type {boolean} */
TouchableNativeFeedbackProperties.prototype.useForeground;
/**
 * @extends {TouchableMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function TouchableNativeFeedbackStatic() {}

/**
 * Creates an object that represents android theme's default background for
 * selectable elements (?android:attr/selectableItemBackground).
 * @return {?}
 */
TouchableNativeFeedbackStatic.prototype.SelectableBackground = function() {};

/**
 * Creates an object that represent android theme's default background for borderless
 * selectable elements (?android:attr/selectableItemBackgroundBorderless).
 * Available on android API level 21+.
 * @return {?}
 */
TouchableNativeFeedbackStatic.prototype.SelectableBackgroundBorderless = function() {};

/**
 * Creates an object that represents ripple drawable with specified color (as a
 * string). If property `borderless` evaluates to true the ripple will
 * render outside of the view bounds (see native actionbar buttons as an
 * example of that behavior). This background type is available on Android
 * API level 21+.
 * 
 * @param {string} color The ripple color
 * @param {boolean=} borderless If the ripple can render outside it's bounds
 * @return {?}
 */
TouchableNativeFeedbackStatic.prototype.Ripple = function(color, borderless) {};
/**
 * @record
 * @struct
 */
function LeftToRightGesture() {}
 /** @type {boolean} */
LeftToRightGesture.prototype.isDetachable;
 /** @type {number} */
LeftToRightGesture.prototype.gestureDetectMovement;
 /** @type {number} */
LeftToRightGesture.prototype.notMoving;
 /** @type {number} */
LeftToRightGesture.prototype.directionRatio;
 /** @type {number} */
LeftToRightGesture.prototype.snapVelocity;
 /** @type {number} */
LeftToRightGesture.prototype.edgeHitWidth;
 /** @type {number} */
LeftToRightGesture.prototype.stillCompletionRatio;
 /** @type {?} */
LeftToRightGesture.prototype.fullDistance;
 /** @type {string} */
LeftToRightGesture.prototype.direction;
/**
 * @extends {LeftToRightGesture}
 * @record
 * @struct
 */
function JumpGesture() {}
 /** @type {?} */
JumpGesture.prototype.overswipe;
/**
 * @record
 * @struct
 */
function SceneConfig() {}
 /** @type {?} */
SceneConfig.prototype.gestures;
 /** @type {number} */
SceneConfig.prototype.springFriction;
 /** @type {number} */
SceneConfig.prototype.springTension;
 /** @type {number} */
SceneConfig.prototype.defaultTransitionVelocity;
 /** @type {?} */
SceneConfig.prototype.animationInterpolators;
/**
 * @extends {SceneConfig}
 * @record
 * @struct
 */
function JumpSceneConfig() {}
 /** @type {?} */
JumpSceneConfig.prototype.gestures;
/**
 * @record
 * @struct
 */
function SceneConfigs() {}
 /** @type {?} */
SceneConfigs.prototype.PushFromRight;
 /** @type {?} */
SceneConfigs.prototype.PushFromLeft;
 /** @type {?} */
SceneConfigs.prototype.FloatFromRight;
 /** @type {?} */
SceneConfigs.prototype.FloatFromLeft;
 /** @type {?} */
SceneConfigs.prototype.FloatFromBottom;
 /** @type {?} */
SceneConfigs.prototype.FloatFromBottomAndroid;
 /** @type {?} */
SceneConfigs.prototype.FadeAndroid;
 /** @type {?} */
SceneConfigs.prototype.HorizontalSwipeJump;
 /** @type {?} */
SceneConfigs.prototype.HorizontalSwipeJumpFromRight;
 /** @type {?} */
SceneConfigs.prototype.VerticalUpSwipeJump;
 /** @type {?} */
SceneConfigs.prototype.VerticalDownSwipeJump;
/**
 * @record
 * @struct
 */
function Route() {}
 /** @type {(!React.ComponentClass<?>|!React.StatelessComponent<?>)} */
Route.prototype.component;
 /** @type {string} */
Route.prototype.id;
 /** @type {string} */
Route.prototype.title;
 /** @type {!Object} */
Route.prototype.passProps;

/* TODO: IndexSignature:  */
 /** @type {string} */
Route.prototype.backButtonTitle;
 /** @type {string} */
Route.prototype.content;
 /** @type {string} */
Route.prototype.message;
 /** @type {number} */
Route.prototype.index;
 /** @type {?} */
Route.prototype.onRightButtonPress;
 /** @type {string} */
Route.prototype.rightButtonTitle;
 /** @type {?} */
Route.prototype.sceneConfig;
 /** @type {?} */
Route.prototype.wrapperStyle;
/**
 * @record
 * @struct
 */
function NavigatorProperties() {}
 /** @type {?} */
NavigatorProperties.prototype.configureScene;
 /** @type {?} */
NavigatorProperties.prototype.initialRoute;
 /** @type {!Array<?>} */
NavigatorProperties.prototype.initialRouteStack;
 /** @type {!React.ReactElement<?>} */
NavigatorProperties.prototype.navigationBar;
 /** @type {?} */
NavigatorProperties.prototype.navigator;
 /** @type {?} */
NavigatorProperties.prototype.onDidFocus;
 /** @type {?} */
NavigatorProperties.prototype.onWillFocus;
 /** @type {?} */
NavigatorProperties.prototype.renderScene;
 /** @type {(boolean|?)} */
NavigatorProperties.prototype.sceneStyle;
/**
 * @record
 * @struct
 */
function NavigationContext() {}
 /** @type {?} */
NavigationContext.prototype.parent;
 /** @type {?} */
NavigationContext.prototype.top;
 /** @type {?} */
NavigationContext.prototype.currentRoute;

/**
 * @param {?} childContext
 * @return {void}
 */
NavigationContext.prototype.appendChild = function(childContext) {};

/**
 * @param {string} eventType
 * @param {?} listener
 * @param {boolean=} useCapture
 * @return {?}
 */
NavigationContext.prototype.addListener = function(eventType, listener, useCapture) {};

/**
 * @param {string} eventType
 * @param {?} data
 * @param {?=} didEmitCallback
 * @return {void}
 */
NavigationContext.prototype.emit = function(eventType, data, didEmitCallback) {};

/**
 * @return {void}
 */
NavigationContext.prototype.dispose = function() {};
/**
 * @record
 * @struct
 */
function InteractionMixin() {}

/**
 * @return {number}
 */
InteractionMixin.prototype.createInteractionHandle = function() {};

/**
 * @param {number} clearHandle
 * @return {void}
 */
InteractionMixin.prototype.clearInteractionHandle = function(clearHandle) {};

/**
 * Schedule work for after all interactions have completed.
 * 
 * @param {?} callback
 * @return {void}
 */
InteractionMixin.prototype.runAfterInteractions = function(callback) {};
/**
 * @record
 * @struct
 */
function SubscribableMixin() {}

/**
 * Special form of calling `addListener` that *guarantees* that a
 * subscription *must* be tied to a component instance, and therefore will
 * be cleaned up when the component is unmounted. It is impossible to create
 * the subscription and pass it in - this method must be the one to create
 * the subscription and therefore can guarantee it is retained in a way that
 * will be cleaned up.
 * 
 * @param {?} eventEmitter
 * @param {string} eventType
 * @param {?} listener
 * @param {?} context
 * @return {void}
 */
SubscribableMixin.prototype.addListenerOn = function(eventEmitter, eventType, listener, context) {};
/**
 * @extends {TimerMixin}
 * @extends {InteractionMixin}
 * @extends {SubscribableMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function NavigatorStatic() {}
 /** @type {?} */
NavigatorStatic.prototype.SceneConfigs;
 /** @type {?} */
NavigatorStatic.prototype.NavigationBar;
 /** @type {?} */
NavigatorStatic.prototype.BreadcrumbNavigationBar;
 /** @type {?} */
NavigatorStatic.prototype.navigationContext;

/**
 * returns the current list of routes
 * @return {!Array<?>}
 */
NavigatorStatic.prototype.getCurrentRoutes = function() {};

/**
 * Jump backward without unmounting the current scen
 * @return {void}
 */
NavigatorStatic.prototype.jumpBack = function() {};

/**
 * Jump forward to the next scene in the route stack
 * @return {void}
 */
NavigatorStatic.prototype.jumpForward = function() {};

/**
 * Transition to an existing scene without unmounting
 * @param {?} route
 * @return {void}
 */
NavigatorStatic.prototype.jumpTo = function(route) {};

/**
 * Navigate forward to a new scene, squashing any scenes that you could jumpForward to
 * @param {?} route
 * @return {void}
 */
NavigatorStatic.prototype.push = function(route) {};

/**
 * Transition back and unmount the current scene
 * @return {void}
 */
NavigatorStatic.prototype.pop = function() {};

/**
 * Go back N scenes at once. When N=1, behavior matches `pop()`.
 * When N is invalid(negative or bigger than current routes count), do nothing.
 * @param {number} n
 * @return {void}
 */
NavigatorStatic.prototype.popN = function(n) {};

/**
 * Replace the current scene with a new route
 * @param {?} route
 * @return {void}
 */
NavigatorStatic.prototype.replace = function(route) {};

/**
 * Replace a scene as specified by an index
 * @param {?} route
 * @param {number} index
 * @return {void}
 */
NavigatorStatic.prototype.replaceAtIndex = function(route, index) {};

/**
 *  Replace the previous scene
 * @param {?} route
 * @return {void}
 */
NavigatorStatic.prototype.replacePrevious = function(route) {};

/**
 * Reset every scene with an array of routes
 * @param {!Array<?>} routes
 * @return {void}
 */
NavigatorStatic.prototype.immediatelyResetRouteStack = function(routes) {};

/**
 * Pop to a particular scene, as specified by its route. All scenes after it will be unmounted
 * @param {?} route
 * @return {void}
 */
NavigatorStatic.prototype.popToRoute = function(route) {};

/**
 * Pop to the first scene in the stack, unmounting every other scene
 * @return {void}
 */
NavigatorStatic.prototype.popToTop = function() {};

/**
 *  Replace the previous scene and pop to it.
 * @param {?} route
 * @return {void}
 */
NavigatorStatic.prototype.replacePreviousAndPop = function(route) {};

/**
 * Navigate to a new scene and reset route stack.
 * @param {?} route
 * @return {void}
 */
NavigatorStatic.prototype.resetTo = function(route) {};
/**
 * @record
 * @struct
 */
NavigatorStatic.NavState = function() {};
 /** @type {!Array<?>} */
NavigatorStatic.NavState.prototype.routeStack;
 /** @type {number} */
NavigatorStatic.NavState.prototype.presentedIndex;
/**
 * @record
 * @struct
 */
NavigatorStatic.NavigationBarStyle = function() {};
 /** @type {?} */
NavigatorStatic.NavigationBarStyle.prototype.General;
 /** @type {?} */
NavigatorStatic.NavigationBarStyle.prototype.Interpolators;
 /** @type {?} */
NavigatorStatic.NavigationBarStyle.prototype.Stages;
/**
 * @record
 * @struct
 */
NavigatorStatic.NavigationBarRouteMapper = function() {};
 /** @type {?} */
NavigatorStatic.NavigationBarRouteMapper.prototype.Title;
 /** @type {?} */
NavigatorStatic.NavigationBarRouteMapper.prototype.LeftButton;
 /** @type {?} */
NavigatorStatic.NavigationBarRouteMapper.prototype.RightButton;
/**
 * @record
 * @struct
 */
NavigatorStatic.NavigationBarProperties = function() {};
 /** @type {?} */
NavigatorStatic.NavigationBarProperties.prototype.navigator;
 /** @type {?} */
NavigatorStatic.NavigationBarProperties.prototype.routeMapper;
 /** @type {?} */
NavigatorStatic.NavigationBarProperties.prototype.navState;
 /** @type {?} */
NavigatorStatic.NavigationBarProperties.prototype.navigationStyles;
 /** @type {(boolean|?)} */
NavigatorStatic.NavigationBarProperties.prototype.style;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
NavigatorStatic.NavigationBarStatic = function() {};
 /** @type {?} */
NavigatorStatic.NavigationBarStatic.prototype.Styles;
 /** @type {?} */
NavigatorStatic.NavigationBarStatic.prototype.StylesAndroid;
 /** @type {?} */
NavigatorStatic.NavigationBarStatic.prototype.StylesIOS;

/**
 * Stop transtion, immediately resets the cached state and re-render the
 * whole view.
 * @return {void}
 */
NavigatorStatic.NavigationBarStatic.prototype.immediatelyRefresh = function() {};

/** @typedef {?} */
NavigatorStatic.NavigationBar;
 /** @type {?} */
NavigatorStatic.NavigationBar;
/**
 * @record
 * @struct
 */
NavigatorStatic.BreadcrumbNavigationBarStyle = function() {};
/**
 * @record
 * @struct
 */
NavigatorStatic.BreadcrumbNavigationBarRouteMapper = function() {};
 /** @type {?} */
NavigatorStatic.BreadcrumbNavigationBarRouteMapper.prototype.rightContentForRoute;
 /** @type {?} */
NavigatorStatic.BreadcrumbNavigationBarRouteMapper.prototype.titleContentForRoute;
 /** @type {?} */
NavigatorStatic.BreadcrumbNavigationBarRouteMapper.prototype.iconForRoute;
 /** @type {?} */
NavigatorStatic.BreadcrumbNavigationBarRouteMapper.prototype.separatorForRoute;
/**
 * @record
 * @struct
 */
NavigatorStatic.BreadcrumbNavigationBarProperties = function() {};
 /** @type {?} */
NavigatorStatic.BreadcrumbNavigationBarProperties.prototype.navigator;
 /** @type {?} */
NavigatorStatic.BreadcrumbNavigationBarProperties.prototype.routeMapper;
 /** @type {?} */
NavigatorStatic.BreadcrumbNavigationBarProperties.prototype.navState;
 /** @type {(boolean|?)} */
NavigatorStatic.BreadcrumbNavigationBarProperties.prototype.style;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
NavigatorStatic.BreadcrumbNavigationBarStatic = function() {};
 /** @type {?} */
NavigatorStatic.BreadcrumbNavigationBarStatic.prototype.Styles;

/**
 * @return {void}
 */
NavigatorStatic.BreadcrumbNavigationBarStatic.prototype.immediatelyRefresh = function() {};

/** @typedef {?} */
NavigatorStatic.BreadcrumbNavigationBar;
 /** @type {?} */
NavigatorStatic.BreadcrumbNavigationBar;
/** @const */
var StyleSheet = {};

/** @typedef {?} */
StyleSheet.NamedStyles;

/**
 * Creates a StyleSheet style reference from the given object.
 * @template T
 * @param {?} styles
 * @return {?}
 */
StyleSheet.create = function(styles) {};

/**
 * Flattens an array of style objects, into one aggregated style object.
 * Alternatively, this method can be used to lookup IDs, returned by
 * StyleSheet.register.
 * 
 * > **NOTE**: Exercise caution as abusing this can tax you in terms of
 * > optimizations.
 * >
 * > IDs enable optimizations through the bridge and memory in general. Refering
 * > to style objects directly will deprive you of these optimizations.
 * 
 * Example:
 * ```
 * var styles = StyleSheet.create({
 *   listItem: {
 *     flex: 1,
 *     fontSize: 16,
 *     color: 'white'
 *   },
 *   selectedListItem: {
 *     color: 'green'
 *   }
 * });
 * 
 * StyleSheet.flatten([styles.listItem, styles.selectedListItem])
 * // returns { flex: 1, fontSize: 16, color: 'green' }
 * ```
 * Alternative use:
 * ```
 * StyleSheet.flatten(styles.listItem);
 * // return { flex: 1, fontSize: 16, color: 'white' }
 * // Simply styles.listItem would return its ID (number)
 * ```
 * This method internally uses `StyleSheetRegistry.getStyleByID(style)`
 * to resolve style objects represented by IDs. Thus, an array of style
 * objects (instances of StyleSheet.create), are individually resolved to,
 * their respective objects, merged as one and then returned. This also explains
 * the alternative use.
 * @template T
 * @param {?|(boolean|?)=} style
 * @return {?}
 */
StyleSheet.flatten = function(style) {};
 /** @type {number} */
StyleSheet.hairlineWidth;
/**
 * @record
 * @struct
 */
StyleSheet.AbsoluteFillStyle = function() {};
 /** @type {string} */
StyleSheet.AbsoluteFillStyle.prototype.position;
 /** @type {number} */
StyleSheet.AbsoluteFillStyle.prototype.left;
 /** @type {number} */
StyleSheet.AbsoluteFillStyle.prototype.right;
 /** @type {number} */
StyleSheet.AbsoluteFillStyle.prototype.top;
 /** @type {number} */
StyleSheet.AbsoluteFillStyle.prototype.bottom;
 /** @type {?} */
StyleSheet.absoluteFillObject;
 /** @type {?} */
StyleSheet.absoluteFill;
/**
 * @record
 * @struct
 */
function RelayProfiler() {}

/**
 * @param {string} name
 * @param {?} handler
 * @return {void}
 */
RelayProfiler.prototype.attachProfileHandler = function(name, handler) {};

/**
 * @param {string} name
 * @param {?} handler
 * @return {void}
 */
RelayProfiler.prototype.attachAggregateHandler = function(name, handler) {};
/**
 * @record
 * @struct
 */
function SystraceStatic() {}

/**
 * @param {boolean} enabled
 * @return {void}
 */
SystraceStatic.prototype.setEnabled = function(enabled) {};

/**
 * beginEvent/endEvent for starting and then ending a profile within the same call stack frame
 * 
 * @param {?=} profileName
 * @param {?=} args
 * @return {void}
 */
SystraceStatic.prototype.beginEvent = function(profileName, args) {};

/**
 * @return {void}
 */
SystraceStatic.prototype.endEvent = function() {};

/**
 * beginAsyncEvent/endAsyncEvent for starting and then ending a profile where the end can either
 * occur on another thread or out of the current stack frame, eg await
 * the returned cookie variable should be used as input into the endAsyncEvent call to end the profile
 * 
 * @param {?=} profileName
 * @return {?}
 */
SystraceStatic.prototype.beginAsyncEvent = function(profileName) {};

/**
 * @param {?=} profileName
 * @param {?=} cookie
 * @return {void}
 */
SystraceStatic.prototype.endAsyncEvent = function(profileName, cookie) {};

/**
 * counterEvent registers the value to the profileName on the systrace timeline
 * 
 * @param {?=} profileName
 * @param {?=} value
 * @return {void}
 */
SystraceStatic.prototype.counterEvent = function(profileName, value) {};

/**
 * Relay profiles use await calls, so likely occur out of current stack frame
 * therefore async variant of profiling is used
 * 
 * @param {?} relayProfiler
 * @return {void}
 */
SystraceStatic.prototype.attachToRelayProfiler = function(relayProfiler) {};

/**
 * @return {void}
 */
SystraceStatic.prototype.swizzleJSON = function() {};

/**
 * Measures multiple methods of a class. For example, you can do:
 * Systrace.measureMethods(JSON, 'JSON', ['parse', 'stringify']);
 * 
 * @param {?} object
 * @param {string} objectName
 * @param {!Array<string>} methodNames Map from method names to method display names.
 * @return {void}
 */
SystraceStatic.prototype.measureMethods = function(object, objectName, methodNames) {};

/**
 * Returns an profiled version of the input function. For example, you can:
 * JSON.parse = Systrace.measure('JSON', 'parse', JSON.parse);
 * 
 * @template T
 * @param {string} objName
 * @param {string} fnName
 * @param {?} func
 * @return {?}
 */
SystraceStatic.prototype.measure = function(objName, fnName, func) {};
/**
 * @record
 * @struct
 */
function DataSourceAssetCallback() {}
 /** @type {?} */
DataSourceAssetCallback.prototype.rowHasChanged;
 /** @type {?} */
DataSourceAssetCallback.prototype.sectionHeaderHasChanged;
 /** @type {?} */
DataSourceAssetCallback.prototype.getRowData;
 /** @type {?} */
DataSourceAssetCallback.prototype.getSectionHeaderData;
/**
 * @record
 * @struct
 */
function ListViewDataSource() {}

/* TODO: ConstructSignature:  */

/**
 * Clones this `ListViewDataSource` with the specified `dataBlob` and
 * `rowIdentities`. The `dataBlob` is just an aribitrary blob of data. At
 * construction an extractor to get the interesting informatoin was defined
 * (or the default was used).
 * 
 * The `rowIdentities` is is a 2D array of identifiers for rows.
 * ie. [['a1', 'a2'], ['b1', 'b2', 'b3'], ...].  If not provided, it's
 * assumed that the keys of the section data are the row identities.
 * 
 * Note: This function does NOT clone the data in this data source. It simply
 * passes the functions defined at construction to a new data source with
 * the data specified. If you wish to maintain the existing data you must
 * handle merging of old and new data separately and then pass that into
 * this function as the `dataBlob`.
 * @template T
 * @param {(!Array<?>|?)} dataBlob
 * @param {!Array<(string|number)>=} rowIdentities
 * @return {?}
 */
ListViewDataSource.prototype.cloneWithRows = function(dataBlob, rowIdentities) {};

/**
 * This performs the same function as the `cloneWithRows` function but here
 * you also specify what your `sectionIdentities` are. If you don't care
 * about sections you should safely be able to use `cloneWithRows`.
 * 
 * `sectionIdentities` is an array of identifiers for  sections.
 * ie. ['s1', 's2', ...].  If not provided, it's assumed that the
 * keys of dataBlob are the section identities.
 * 
 * Note: this returns a new object!
 * @param {(!Array<?>|?)} dataBlob
 * @param {!Array<(string|number)>=} sectionIdentities
 * @param {!Array<!Array<(string|number)>>=} rowIdentities
 * @return {?}
 */
ListViewDataSource.prototype.cloneWithRowsAndSections = function(dataBlob, sectionIdentities, rowIdentities) {};

/**
 * @return {number}
 */
ListViewDataSource.prototype.getRowCount = function() {};

/**
 * @return {number}
 */
ListViewDataSource.prototype.getRowAndSectionCount = function() {};

/**
 * Returns if the row is dirtied and needs to be rerendered
 * @param {number} sectionIndex
 * @param {number} rowIndex
 * @return {boolean}
 */
ListViewDataSource.prototype.rowShouldUpdate = function(sectionIndex, rowIndex) {};

/**
 * Gets the data required to render the row.
 * @param {number} sectionIndex
 * @param {number} rowIndex
 * @return {?}
 */
ListViewDataSource.prototype.getRowData = function(sectionIndex, rowIndex) {};

/**
 * Gets the rowID at index provided if the dataSource arrays were flattened,
 * or null of out of range indexes.
 * @param {number} index
 * @return {string}
 */
ListViewDataSource.prototype.getRowIDForFlatIndex = function(index) {};

/**
 * Gets the sectionID at index provided if the dataSource arrays were flattened,
 * or null for out of range indexes.
 * @param {number} index
 * @return {string}
 */
ListViewDataSource.prototype.getSectionIDForFlatIndex = function(index) {};

/**
 * Returns an array containing the number of rows in each section
 * @return {!Array<number>}
 */
ListViewDataSource.prototype.getSectionLengths = function() {};

/**
 * Returns if the section header is dirtied and needs to be rerendered
 * @param {number} sectionIndex
 * @return {boolean}
 */
ListViewDataSource.prototype.sectionHeaderShouldUpdate = function(sectionIndex) {};

/**
 * Gets the data required to render the section header
 * @param {number} sectionIndex
 * @return {?}
 */
ListViewDataSource.prototype.getSectionHeaderData = function(sectionIndex) {};
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function TabBarItemProperties() {}
 /** @type {(string|number)} */
TabBarItemProperties.prototype.badge;
 /** @type {string} */
TabBarItemProperties.prototype.badgeColor;
 /** @type {?} */
TabBarItemProperties.prototype.icon;
 /** @type {?} */
TabBarItemProperties.prototype.onPress;
 /** @type {boolean} */
TabBarItemProperties.prototype.renderAsOriginal;
 /** @type {boolean} */
TabBarItemProperties.prototype.selected;
 /** @type {?} */
TabBarItemProperties.prototype.selectedIcon;
 /** @type {(boolean|?)} */
TabBarItemProperties.prototype.style;
 /** @type {string} */
TabBarItemProperties.prototype.systemIcon;
 /** @type {string} */
TabBarItemProperties.prototype.title;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function TabBarItemStatic() {}
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function TabBarIOSProperties() {}
 /** @type {string} */
TabBarIOSProperties.prototype.barTintColor;
 /** @type {string} */
TabBarIOSProperties.prototype.itemPositioning;
 /** @type {string} */
TabBarIOSProperties.prototype.tintColor;
 /** @type {boolean} */
TabBarIOSProperties.prototype.translucent;
 /** @type {string} */
TabBarIOSProperties.prototype.unselectedTintColor;
 /** @type {string} */
TabBarIOSProperties.prototype.unselectedItemTintColor;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function TabBarIOSStatic() {}
 /** @type {?} */
TabBarIOSStatic.prototype.Item;
/**
 * @record
 * @struct
 */
function PixelRatioStatic() {}

/**
 * @return {number}
 */
PixelRatioStatic.prototype.get = function() {};

/**
 * @return {number}
 */
PixelRatioStatic.prototype.getFontScale = function() {};

/**
 * Converts a layout size (dp) to pixel size (px).
 * Guaranteed to return an integer number.
 * @param {number} layoutSize
 * @return {number}
 */
PixelRatioStatic.prototype.getPixelSizeForLayoutSize = function(layoutSize) {};

/**
 * Rounds a layout size (dp) to the nearest layout size that
 * corresponds to an integer number of pixels. For example,
 * on a device with a PixelRatio of 3,
 * PixelRatio.roundToNearestPixel(8.4) = 8.33,
 * which corresponds to exactly (8.33 * 3) = 25 pixels.
 * @param {number} layoutSize
 * @return {number}
 */
PixelRatioStatic.prototype.roundToNearestPixel = function(layoutSize) {};

/**
 * No-op for iOS, but used on the web. Should not be documented. [sic]
 * @return {void}
 */
PixelRatioStatic.prototype.startDetecting = function() {};

/** @typedef {string} */
var PlatformOSType;
/**
 * @record
 * @struct
 */
function PlatformStatic() {}
 /** @type {string} */
PlatformStatic.prototype.OS;
 /** @type {number} */
PlatformStatic.prototype.Version;

/**
 * @see https://facebook.github.io/react-native/docs/platform-specific-code.html#content
 * @template T
 * @param {?} specifics
 * @return {?}
 */
PlatformStatic.prototype.select = function(specifics) {};
/**
 * @extends {EventEmitter}
 * @record
 * @struct
 */
function DeviceEventEmitterStatic() {}
 /** @type {?} */
DeviceEventEmitterStatic.prototype.sharedSubscriber;

/* TODO: ConstructSignature:  */

/**
 * @template T
 * @param {string} type
 * @param {?} listener
 * @param {?=} context
 * @return {?}
 */
DeviceEventEmitterStatic.prototype.addListener = function(type, listener, context) {};
/**
 * @record
 * @struct
 */
function ScaledSize() {}
 /** @type {number} */
ScaledSize.prototype.width;
 /** @type {number} */
ScaledSize.prototype.height;
 /** @type {number} */
ScaledSize.prototype.scale;
 /** @type {number} */
ScaledSize.prototype.fontScale;
/**
 * @record
 * @struct
 */
function Dimensions() {}

/**
 * Initial dimensions are set before runApplication is called so they
 * should be available before any other require's are run, but may be
 * updated later.
 * Note: Although dimensions are available immediately, they may
 * change (e.g due to device rotation) so any rendering logic or
 * styles that depend on these constants should try to call this
 * function on every render, rather than caching the value (for
 * example, using inline styles rather than setting a value in a
 * StyleSheet).
 * Example: var {height, width} = Dimensions.get('window');
 * @param {string} dim
 * @return {?}
 */
Dimensions.prototype.get = function(dim) {};

/**
 * This should only be called from native code by sending the didUpdateDimensions event.
 * @param {?} dims
 * @return {void}
 */
Dimensions.prototype.set = function(dims) {};

/**
 * Add an event listener for dimension changes
 * 
 * @param {string} type
 * @param {?} handler
 * @return {void}
 */
Dimensions.prototype.addEventListener = function(type, handler) {};

/**
 * Remove an event listener
 * 
 * @param {string} type
 * @param {?} handler
 * @return {void}
 */
Dimensions.prototype.removeEventListener = function(type, handler) {};

/** @typedef {?} */
var SimpleTask;

/** @typedef {?} */
var PromiseTask;

/** @typedef {number} */
var Handle;
/**
 * @extends {EventEmitterListener}
 * @record
 * @struct
 */
function InteractionManagerStatic() {}
 /** @type {?} */
InteractionManagerStatic.prototype.Events;

/**
 * Schedule a function to run after all interactions have completed.
 * Returns a cancellable
 * @param {?=} task
 * @return {?}
 */
InteractionManagerStatic.prototype.runAfterInteractions = function(task) {};

/**
 * Notify manager that an interaction has started.
 * @return {number}
 */
InteractionManagerStatic.prototype.createInteractionHandle = function() {};

/**
 * Notify manager that an interaction has completed.
 * @param {number} handle
 * @return {void}
 */
InteractionManagerStatic.prototype.clearInteractionHandle = function(handle) {};

/**
 * A positive number will use setTimeout to schedule any tasks after
 * the eventLoopRunningTime hits the deadline value, otherwise all
 * tasks will be executed in one setImmediate batch (default).
 * @param {number} deadline
 * @return {void}
 */
InteractionManagerStatic.prototype.setDeadline = function(deadline) {};
/**
 * @extends {FlexStyle}
 * @extends {TransformsStyle}
 * @record
 * @struct
 */
function ScrollViewStyle() {}
 /** @type {string} */
ScrollViewStyle.prototype.backfaceVisibility;
 /** @type {string} */
ScrollViewStyle.prototype.backgroundColor;
 /** @type {string} */
ScrollViewStyle.prototype.borderColor;
 /** @type {string} */
ScrollViewStyle.prototype.borderTopColor;
 /** @type {string} */
ScrollViewStyle.prototype.borderRightColor;
 /** @type {string} */
ScrollViewStyle.prototype.borderBottomColor;
 /** @type {string} */
ScrollViewStyle.prototype.borderLeftColor;
 /** @type {number} */
ScrollViewStyle.prototype.borderRadius;
 /** @type {number} */
ScrollViewStyle.prototype.borderTopLeftRadius;
 /** @type {number} */
ScrollViewStyle.prototype.borderTopRightRadius;
 /** @type {number} */
ScrollViewStyle.prototype.borderBottomLeftRadius;
 /** @type {number} */
ScrollViewStyle.prototype.borderBottomRightRadius;
 /** @type {string} */
ScrollViewStyle.prototype.borderStyle;
 /** @type {number} */
ScrollViewStyle.prototype.borderWidth;
 /** @type {number} */
ScrollViewStyle.prototype.borderTopWidth;
 /** @type {number} */
ScrollViewStyle.prototype.borderRightWidth;
 /** @type {number} */
ScrollViewStyle.prototype.borderBottomWidth;
 /** @type {number} */
ScrollViewStyle.prototype.borderLeftWidth;
 /** @type {number} */
ScrollViewStyle.prototype.opacity;
 /** @type {string} */
ScrollViewStyle.prototype.overflow;
 /** @type {string} */
ScrollViewStyle.prototype.shadowColor;
 /** @type {?} */
ScrollViewStyle.prototype.shadowOffset;
 /** @type {number} */
ScrollViewStyle.prototype.shadowOpacity;
 /** @type {number} */
ScrollViewStyle.prototype.shadowRadius;
 /** @type {number} */
ScrollViewStyle.prototype.elevation;
/**
 * @extends {SubscribableMixin}
 * @record
 * @struct
 */
function ScrollResponderMixin() {}

/**
 * Invoke this from an `onScroll` event.
 * @return {boolean}
 */
ScrollResponderMixin.prototype.scrollResponderHandleScrollShouldSetResponder = function() {};

/**
 * Merely touch starting is not sufficient for a scroll view to become the
 * responder. Being the "responder" means that the very next touch move/end
 * event will result in an action/movement.
 * 
 * Invoke this from an `onStartShouldSetResponder` event.
 * 
 * `onStartShouldSetResponder` is used when the next move/end will trigger
 * some UI movement/action, but when you want to yield priority to views
 * nested inside of the view.
 * 
 * There may be some cases where scroll views actually should return `true`
 * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
 * that gives priority to nested views.
 * 
 * - If a single tap on the scroll view triggers an action such as
 *   recentering a map style view yet wants to give priority to interaction
 *   views inside (such as dropped pins or labels), then we would return true
 *   from this method when there is a single touch.
 * 
 * - Similar to the previous case, if a two finger "tap" should trigger a
 *   zoom, we would check the `touches` count, and if `>= 2`, we would return
 *   true.
 * 
 * @return {boolean}
 */
ScrollResponderMixin.prototype.scrollResponderHandleStartShouldSetResponder = function() {};

/**
 * There are times when the scroll view wants to become the responder
 * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
 * that *doesn't* give priority to nested views (hence the capture phase):
 * 
 * - Currently animating.
 * - Tapping anywhere that is not the focused input, while the keyboard is
 *   up (which should dismiss the keyboard).
 * 
 * Invoke this from an `onStartShouldSetResponderCapture` event.
 * @param {!Event} e
 * @return {boolean}
 */
ScrollResponderMixin.prototype.scrollResponderHandleStartShouldSetResponderCapture = function(e) {};

/**
 * Invoke this from an `onResponderReject` event.
 * 
 * Some other element is not yielding its role as responder. Normally, we'd
 * just disable the `UIScrollView`, but a touch has already began on it, the
 * `UIScrollView` will not accept being disabled after that. The easiest
 * solution for now is to accept the limitation of disallowing this
 * altogether. To improve this, find a way to disable the `UIScrollView` after
 * a touch has already started.
 * @return {?}
 */
ScrollResponderMixin.prototype.scrollResponderHandleResponderReject = function() {};

/**
 * We will allow the scroll view to give up its lock iff it acquired the lock
 * during an animation. This is a very useful default that happens to satisfy
 * many common user experiences.
 * 
 * - Stop a scroll on the left edge, then turn that into an outer view's
 *   backswipe.
 * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
 *   view dismiss.
 * - However, without catching the scroll view mid-bounce (while it is
 *   motionless), if you drag far enough for the scroll view to become
 *   responder (and therefore drag the scroll view a bit), any backswipe
 *   navigation of a swipe gesture higher in the view hierarchy, should be
 *   rejected.
 * @return {boolean}
 */
ScrollResponderMixin.prototype.scrollResponderHandleTerminationRequest = function() {};

/**
 * Invoke this from an `onTouchEnd` event.
 * 
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleTouchEnd = function(e) {};

/**
 * Invoke this from an `onResponderRelease` event.
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleResponderRelease = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleScroll = function(e) {};

/**
 * Invoke this from an `onResponderGrant` event.
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleResponderGrant = function(e) {};

/**
 * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
 * animation, and there's not an easy way to distinguish a drag vs. stopping
 * momentum.
 * 
 * Invoke this from an `onScrollBeginDrag` event.
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleScrollBeginDrag = function(e) {};

/**
 * Invoke this from an `onScrollEndDrag` event.
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleScrollEndDrag = function(e) {};

/**
 * Invoke this from an `onMomentumScrollBegin` event.
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleMomentumScrollBegin = function(e) {};

/**
 * Invoke this from an `onMomentumScrollEnd` event.
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleMomentumScrollEnd = function(e) {};

/**
 * Invoke this from an `onTouchStart` event.
 * 
 * Since we know that the `SimpleEventPlugin` occurs later in the plugin
 * order, after `ResponderEventPlugin`, we can detect that we were *not*
 * permitted to be the responder (presumably because a contained view became
 * responder). The `onResponderReject` won't fire in that case - it only
 * fires when a *current* responder rejects our request.
 * 
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleTouchStart = function(e) {};

/**
 * Invoke this from an `onTouchMove` event.
 * 
 * Since we know that the `SimpleEventPlugin` occurs later in the plugin
 * order, after `ResponderEventPlugin`, we can detect that we were *not*
 * permitted to be the responder (presumably because a contained view became
 * responder). The `onResponderReject` won't fire in that case - it only
 * fires when a *current* responder rejects our request.
 * 
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderHandleTouchMove = function(e) {};

/**
 * A helper function for this class that lets us quickly determine if the
 * view is currently animating. This is particularly useful to know when
 * a touch has just started or ended.
 * @return {boolean}
 */
ScrollResponderMixin.prototype.scrollResponderIsAnimating = function() {};

/**
 * Returns the node that represents native view that can be scrolled.
 * Components can pass what node to use by defining a `getScrollableNode`
 * function otherwise `this` is used.
 * @return {?}
 */
ScrollResponderMixin.prototype.scrollResponderGetScrollableNode = function() {};

/**
 * A helper function to scroll to a specific point  in the scrollview.
 * This is currently used to help focus on child textviews, but can also
 * be used to quickly scroll to any element we want to focus. Syntax:
 * 
 * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
 * 
 * Note: The weird argument signature is due to the fact that, for historical reasons,
 * the function also accepts separate arguments as as alternative to the options object.
 * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
 * @param {(number|?)=} x
 * @param {number=} y
 * @param {boolean=} animated
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderScrollTo = function(x, y, animated) {};

/**
 * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
 * {x: number; y: number; width: number; height: number; animated: boolean = true}
 * 
 * \@platform ios
 * @param {?} rect
 * @param {boolean=} animated
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderZoomTo = function(rect, animated) {};

/**
 * This method should be used as the callback to onFocus in a TextInputs'
 * parent view. Note that any module using this mixin needs to return
 * the parent view's ref in getScrollViewRef() in order to use this method.
 *        Default is 0.
 *        down to make it meet the keyboard's top. Default is false.
 * @param {?} nodeHandle
 * @param {number=} additionalOffset
 * @param {boolean=} preventNegativeScrollOffset
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderScrollNativeHandleToKeyboard = function(nodeHandle, additionalOffset, preventNegativeScrollOffset) {};

/**
 * The calculations performed here assume the scroll view takes up the entire
 * screen - even if has some content inset. We then measure the offsets of the
 * keyboard, and compensate both for the scroll view's "contentInset".
 * 
 * @param {number} left
 * @param {number} top
 * @param {number} width
 * @param {number} height
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderInputMeasureAndScrollToKeyboard = function(left, top, width, height) {};

/**
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderTextInputFocusError = function(e) {};

/**
 * `componentWillMount` is the closest thing to a  standard "constructor" for
 * React components.
 * 
 * The `keyboardWillShow` is called before input focus.
 * @return {void}
 */
ScrollResponderMixin.prototype.componentWillMount = function() {};

/**
 * Warning, this may be called several times for a single keyboard opening.
 * It's best to store the information in this method and then take any action
 * at a later point (either in `keyboardDidShow` or other).
 * 
 * Here's the order that events occur in:
 * - focus
 * - willShow {startCoordinates, endCoordinates} several times
 * - didShow several times
 * - blur
 * - willHide {startCoordinates, endCoordinates} several times
 * - didHide several times
 * 
 * The `ScrollResponder` providesModule callbacks for each of these events.
 * Even though any user could have easily listened to keyboard events
 * themselves, using these `props` callbacks ensures that ordering of events
 * is consistent - and not dependent on the order that the keyboard events are
 * subscribed to. This matters when telling the scroll view to scroll to where
 * the keyboard is headed - the scroll responder better have been notified of
 * the keyboard destination before being instructed to scroll to where the
 * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
 * will work.
 * 
 * WARNING: These callbacks will fire even if a keyboard is displayed in a
 * different navigation pane. Filter out the events to determine if they are
 * relevant to you. (For example, only if you receive these callbacks after
 * you had explicitly focused a node etc).
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderKeyboardWillShow = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderKeyboardWillHide = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderKeyboardDidShow = function(e) {};

/**
 * @param {!Event} e
 * @return {void}
 */
ScrollResponderMixin.prototype.scrollResponderKeyboardDidHide = function(e) {};
/**
 * @record
 * @struct
 */
function ScrollViewPropertiesIOS() {}
 /** @type {boolean} */
ScrollViewPropertiesIOS.prototype.alwaysBounceHorizontal;
 /** @type {boolean} */
ScrollViewPropertiesIOS.prototype.alwaysBounceVertical;
 /** @type {boolean} */
ScrollViewPropertiesIOS.prototype.automaticallyAdjustContentInsets;
 /** @type {boolean} */
ScrollViewPropertiesIOS.prototype.bounces;
 /** @type {boolean} */
ScrollViewPropertiesIOS.prototype.bouncesZoom;
 /** @type {boolean} */
ScrollViewPropertiesIOS.prototype.canCancelContentTouches;
 /** @type {boolean} */
ScrollViewPropertiesIOS.prototype.centerContent;
 /** @type {?} */
ScrollViewPropertiesIOS.prototype.contentInset;
 /** @type {?} */
ScrollViewPropertiesIOS.prototype.contentOffset;
 /** @type {(number|string)} */
ScrollViewPropertiesIOS.prototype.decelerationRate;
 /** @type {boolean} */
ScrollViewPropertiesIOS.prototype.directionalLockEnabled;
 /** @type {string} */
ScrollViewPropertiesIOS.prototype.indicatorStyle;
 /** @type {number} */
ScrollViewPropertiesIOS.prototype.maximumZoomScale;
 /** @type {number} */
ScrollViewPropertiesIOS.prototype.minimumZoomScale;
 /** @type {?} */
ScrollViewPropertiesIOS.prototype.onScrollAnimationEnd;
 /** @type {number} */
ScrollViewPropertiesIOS.prototype.scrollEventThrottle;
 /** @type {?} */
ScrollViewPropertiesIOS.prototype.scrollIndicatorInsets;
 /** @type {boolean} */
ScrollViewPropertiesIOS.prototype.scrollsToTop;
 /** @type {string} */
ScrollViewPropertiesIOS.prototype.snapToAlignment;
 /** @type {number} */
ScrollViewPropertiesIOS.prototype.snapToInterval;
 /** @type {!Array<number>} */
ScrollViewPropertiesIOS.prototype.stickyHeaderIndices;
 /** @type {number} */
ScrollViewPropertiesIOS.prototype.zoomScale;
/**
 * @record
 * @struct
 */
function ScrollViewPropertiesAndroid() {}
 /** @type {string} */
ScrollViewPropertiesAndroid.prototype.endFillColor;
 /** @type {string} */
ScrollViewPropertiesAndroid.prototype.scrollPerfTag;
 /** @type {string} */
ScrollViewPropertiesAndroid.prototype.overScrollMode;
/**
 * @extends {ViewProperties}
 * @extends {ScrollViewPropertiesIOS}
 * @extends {ScrollViewPropertiesAndroid}
 * @extends {Touchable}
 * @record
 * @struct
 */
function ScrollViewProperties() {}
 /** @type {(boolean|?)} */
ScrollViewProperties.prototype.contentContainerStyle;
 /** @type {boolean} */
ScrollViewProperties.prototype.horizontal;
 /** @type {string} */
ScrollViewProperties.prototype.keyboardDismissMode;
 /** @type {(boolean|string)} */
ScrollViewProperties.prototype.keyboardShouldPersistTaps;
 /** @type {?} */
ScrollViewProperties.prototype.onContentSizeChange;
 /** @type {?} */
ScrollViewProperties.prototype.onScroll;
 /** @type {?} */
ScrollViewProperties.prototype.onScrollBeginDrag;
 /** @type {?} */
ScrollViewProperties.prototype.onScrollEndDrag;
 /** @type {?} */
ScrollViewProperties.prototype.onMomentumScrollEnd;
 /** @type {?} */
ScrollViewProperties.prototype.onMomentumScrollBegin;
 /** @type {boolean} */
ScrollViewProperties.prototype.pagingEnabled;
 /** @type {boolean} */
ScrollViewProperties.prototype.scrollEnabled;
 /** @type {boolean} */
ScrollViewProperties.prototype.removeClippedSubviews;
 /** @type {boolean} */
ScrollViewProperties.prototype.showsHorizontalScrollIndicator;
 /** @type {boolean} */
ScrollViewProperties.prototype.showsVerticalScrollIndicator;
 /** @type {(boolean|?)} */
ScrollViewProperties.prototype.style;
 /** @type {!React.ReactElement<?>} */
ScrollViewProperties.prototype.refreshControl;
/**
 * @extends {ScrollViewProperties}
 * @record
 * @struct
 */
function ScrollViewProps() {}
/**
 * @extends {ScrollResponderMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function ScrollViewStatic() {}
 /** @type {?} */
ScrollViewStatic.prototype.scrollWithoutAnimationTo;

/**
 * Scrolls to a given x, y offset, either immediately or with a smooth animation.
 * Syntax:
 * 
 * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
 * 
 * Note: The weird argument signature is due to the fact that, for historical reasons,
 * the function also accepts separate arguments as as alternative to the options object.
 * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
 * @param {(number|?)=} y
 * @param {number=} x
 * @param {boolean=} animated
 * @return {void}
 */
ScrollViewStatic.prototype.scrollTo = function(y, x, animated) {};

/**
 * A helper function that scrolls to the end of the scrollview;
 * If this is a vertical ScrollView, it scrolls to the bottom.
 * If this is a horizontal ScrollView scrolls to the right.
 * 
 * The options object has an animated prop, that enables the scrolling animation or not.
 * The animated prop defaults to true
 * @param {?=} options
 * @return {void}
 */
ScrollViewStatic.prototype.scrollToEnd = function(options) {};

/**
 * Returns a reference to the underlying scroll responder, which supports
 * operations like `scrollTo`. All ScrollView-like components should
 * implement this method so that they can be composed while providing access
 * to the underlying scroll responder's methods.
 * @return {!JSX.Element}
 */
ScrollViewStatic.prototype.getScrollResponder = function() {};

/**
 * @return {?}
 */
ScrollViewStatic.prototype.getScrollableNode = function() {};

/**
 * @return {?}
 */
ScrollViewStatic.prototype.getInnerViewNode = function() {};
/**
 * @record
 * @struct
 */
function NativeScrollRectangle() {}
 /** @type {number} */
NativeScrollRectangle.prototype.left;
 /** @type {number} */
NativeScrollRectangle.prototype.top;
 /** @type {number} */
NativeScrollRectangle.prototype.bottom;
 /** @type {number} */
NativeScrollRectangle.prototype.right;
/**
 * @record
 * @struct
 */
function NativeScrollPoint() {}
 /** @type {number} */
NativeScrollPoint.prototype.x;
 /** @type {number} */
NativeScrollPoint.prototype.y;
/**
 * @record
 * @struct
 */
function NativeScrollSize() {}
 /** @type {number} */
NativeScrollSize.prototype.height;
 /** @type {number} */
NativeScrollSize.prototype.width;
/**
 * @record
 * @struct
 */
function NativeScrollEvent() {}
 /** @type {?} */
NativeScrollEvent.prototype.contentInset;
 /** @type {?} */
NativeScrollEvent.prototype.contentOffset;
 /** @type {?} */
NativeScrollEvent.prototype.contentSize;
 /** @type {?} */
NativeScrollEvent.prototype.layoutMeasurement;
 /** @type {number} */
NativeScrollEvent.prototype.zoomScale;
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function SnapshotViewIOSProperties() {}
 /** @type {string} */
SnapshotViewIOSProperties.prototype.testIdentifier;

/**
 * @return {?}
 */
SnapshotViewIOSProperties.prototype.onSnapshotReady = function() {};
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function SnapshotViewIOSStatic() {}
/**
 * @record
 * @struct
 */
function SwipeableListViewDataSource() {}

/**
 * @param {?} dataBlob
 * @param {!Array<string>=} sectionIdentities
 * @param {!Array<!Array<string>>=} rowIdentities
 * @return {?}
 */
SwipeableListViewDataSource.prototype.cloneWithRowsAndSections = function(dataBlob, sectionIdentities, rowIdentities) {};

/**
 * @return {?}
 */
SwipeableListViewDataSource.prototype.getDataSource = function() {};

/**
 * @return {string}
 */
SwipeableListViewDataSource.prototype.getOpenRowID = function() {};

/**
 * @return {string}
 */
SwipeableListViewDataSource.prototype.getFirstRowID = function() {};

/**
 * @param {string} rowID
 * @return {?}
 */
SwipeableListViewDataSource.prototype.setOpenRowID = function(rowID) {};
/**
 * @record
 * @struct
 */
function SwipeableListViewProps() {}
 /** @type {boolean} */
SwipeableListViewProps.prototype.bounceFirstRowOnMount;
 /** @type {?} */
SwipeableListViewProps.prototype.dataSource;
 /** @type {number} */
SwipeableListViewProps.prototype.maxSwipeDistance;
 /** @type {?} */
SwipeableListViewProps.prototype.renderRow;

/**
 * @param {?} rowData
 * @param {(string|number)} sectionID
 * @param {(string|number)} rowID
 * @return {!React.ReactElement<?>}
 */
SwipeableListViewProps.prototype.renderQuickActions = function(rowData, sectionID, rowID) {};
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function SwipeableListViewStatic() {}

/**
 * @return {?}
 */
SwipeableListViewStatic.prototype.getNewDataSource = function() {};
/**
 * @record
 * @struct
 */
function ActionSheetIOSOptions() {}
 /** @type {string} */
ActionSheetIOSOptions.prototype.title;
 /** @type {!Array<string>} */
ActionSheetIOSOptions.prototype.options;
 /** @type {number} */
ActionSheetIOSOptions.prototype.cancelButtonIndex;
 /** @type {number} */
ActionSheetIOSOptions.prototype.destructiveButtonIndex;
 /** @type {string} */
ActionSheetIOSOptions.prototype.message;
/**
 * @record
 * @struct
 */
function ShareActionSheetIOSOptions() {}
 /** @type {string} */
ShareActionSheetIOSOptions.prototype.message;
 /** @type {string} */
ShareActionSheetIOSOptions.prototype.url;
 /** @type {string} */
ShareActionSheetIOSOptions.prototype.subject;
 /** @type {!Array<string>} */
ShareActionSheetIOSOptions.prototype.excludedActivityTypes;
/**
 * @record
 * @struct
 */
function ActionSheetIOSStatic() {}
 /** @type {?} */
ActionSheetIOSStatic.prototype.showActionSheetWithOptions;
 /** @type {?} */
ActionSheetIOSStatic.prototype.showShareActionSheetWithOptions;

/** @typedef {?} */
var ShareContent;

/** @typedef {?} */
var ShareOptions;
/**
 * @record
 * @struct
 */
function ShareStatic() {}
 /** @type {string} */
ShareStatic.prototype.sharedAction;
 /** @type {string} */
ShareStatic.prototype.dismissedAction;

/**
 * Open a dialog to share text content.
 * 
 * In iOS, Returns a Promise which will be invoked an object containing `action`, `activityType`.
 * If the user dismissed the dialog, the Promise will still be resolved with action being `Share.dismissedAction`
 * and all the other keys being undefined.
 * 
 * In Android, Returns a Promise which always be resolved with action being `Share.sharedAction`.
 * 
 * ### Content
 * 
 *  - `message` - a message to share
 *  - `title` - title of the message
 * 
 * #### iOS
 * 
 *  - `url` - an URL to share
 * 
 * At least one of URL and message is required.
 * 
 * ### Options
 * 
 * #### iOS
 * 
 * - `excludedActivityTypes`
 * - `tintColor`
 * 
 * #### Android
 * 
 * - `dialogTitle`
 * 
 * @param {?} content
 * @param {?=} options
 * @return {!Promise<!Object>}
 */
ShareStatic.prototype.share = function(content, options) {};
/**
 * @record
 * @struct
 */
function AlertButton() {}
 /** @type {string} */
AlertButton.prototype.text;
 /** @type {?} */
AlertButton.prototype.onPress;
 /** @type {string} */
AlertButton.prototype.style;
/**
 * @record
 * @struct
 */
function AlertOptions() {}
 /** @type {boolean} */
AlertOptions.prototype.cancelable;
 /** @type {?} */
AlertOptions.prototype.onDismiss;
/**
 * @record
 * @struct
 */
function AlertStatic() {}
 /** @type {?} */
AlertStatic.prototype.alert;
/**
 * @record
 * @struct
 */
function AlertAndroidStatic() {}
 /** @type {?} */
AlertAndroidStatic.prototype.alert;
/**
 * @record
 * @struct
 */
function AdSupportIOSStatic() {}
 /** @type {?} */
AdSupportIOSStatic.prototype.getAdvertisingId;
 /** @type {?} */
AdSupportIOSStatic.prototype.getAdvertisingTrackingEnabled;
/**
 * @record
 * @struct
 */
function AlertIOSButton() {}
 /** @type {string} */
AlertIOSButton.prototype.text;
 /** @type {?} */
AlertIOSButton.prototype.onPress;
 /** @type {string} */
AlertIOSButton.prototype.style;

/** @typedef {string} */
var AlertType;
/**
 * @record
 * @struct
 */
function AlertIOSStatic() {}
 /** @type {?} */
AlertIOSStatic.prototype.alert;
 /** @type {?} */
AlertIOSStatic.prototype.prompt;

/** @typedef {string} */
var AppStateEvent;

/** @typedef {string} */
var AppStateStatus;
/**
 * @record
 * @struct
 */
function AppStateStatic() {}
 /** @type {string} */
AppStateStatic.prototype.currentState;

/**
 * Add a handler to AppState changes by listening to the change event
 * type and providing the handler
 * @param {string} type
 * @param {?} listener
 * @return {void}
 */
AppStateStatic.prototype.addEventListener = function(type, listener) {};

/**
 * Remove a handler by passing the change event type and the handler
 * @param {string} type
 * @param {?} listener
 * @return {void}
 */
AppStateStatic.prototype.removeEventListener = function(type, listener) {};
/**
 * @record
 * @struct
 */
function AsyncStorageStatic() {}

/**
 * Fetches key and passes the result to callback, along with an Error if there is any.
 * @param {string} key
 * @param {?=} callback
 * @return {!Promise<string>}
 */
AsyncStorageStatic.prototype.getItem = function(key, callback) {};

/**
 * Sets value for key and calls callback on completion, along with an Error if there is any
 * @param {string} key
 * @param {string} value
 * @param {?=} callback
 * @return {!Promise<void>}
 */
AsyncStorageStatic.prototype.setItem = function(key, value, callback) {};

/**
 * @param {string} key
 * @param {?=} callback
 * @return {!Promise<void>}
 */
AsyncStorageStatic.prototype.removeItem = function(key, callback) {};

/**
 * Merges existing value with input value, assuming they are stringified json. Returns a Promise object.
 * Not supported by all native implementation
 * @param {string} key
 * @param {string} value
 * @param {?=} callback
 * @return {!Promise<void>}
 */
AsyncStorageStatic.prototype.mergeItem = function(key, value, callback) {};

/**
 * Erases all AsyncStorage for all clients, libraries, etc. You probably don't want to call this.
 * Use removeItem or multiRemove to clear only your own keys instead.
 * @param {?=} callback
 * @return {!Promise<void>}
 */
AsyncStorageStatic.prototype.clear = function(callback) {};

/**
 * Gets all keys known to the app, for all callers, libraries, etc
 * @param {?=} callback
 * @return {!Promise<!Array<string>>}
 */
AsyncStorageStatic.prototype.getAllKeys = function(callback) {};

/**
 * multiGet invokes callback with an array of key-value pair arrays that matches the input format of multiSet
 * @param {!Array<string>} keys
 * @param {?=} callback
 * @return {!Promise<!Array<!Array<?>>>}
 */
AsyncStorageStatic.prototype.multiGet = function(keys, callback) {};

/**
 * multiSet and multiMerge take arrays of key-value array pairs that match the output of multiGet,
 * 
 * multiSet([['k1', 'val1'], ['k2', 'val2']], cb);
 * @param {!Array<!Array<string>>} keyValuePairs
 * @param {?=} callback
 * @return {!Promise<void>}
 */
AsyncStorageStatic.prototype.multiSet = function(keyValuePairs, callback) {};

/**
 * Delete all the keys in the keys array.
 * @param {!Array<string>} keys
 * @param {?=} callback
 * @return {!Promise<void>}
 */
AsyncStorageStatic.prototype.multiRemove = function(keys, callback) {};

/**
 * Merges existing values with input values, assuming they are stringified json.
 * Returns a Promise object.
 * 
 * Not supported by all native implementations.
 * @param {!Array<!Array<string>>} keyValuePairs
 * @param {?=} callback
 * @return {!Promise<void>}
 */
AsyncStorageStatic.prototype.multiMerge = function(keyValuePairs, callback) {};

/** @typedef {string} */
var BackPressEventName;
/**
 * @record
 * @struct
 */
function BackAndroidStatic() {}

/**
 * @return {void}
 */
BackAndroidStatic.prototype.exitApp = function() {};

/**
 * @param {string} eventName
 * @param {?} handler
 * @return {void}
 */
BackAndroidStatic.prototype.addEventListener = function(eventName, handler) {};

/**
 * @param {string} eventName
 * @param {?} handler
 * @return {void}
 */
BackAndroidStatic.prototype.removeEventListener = function(eventName, handler) {};
/**
 * @record
 * @struct
 */
function BackHandlerStatic() {}

/**
 * @return {void}
 */
BackHandlerStatic.prototype.exitApp = function() {};

/**
 * @param {string} eventName
 * @param {?} handler
 * @return {void}
 */
BackHandlerStatic.prototype.addEventListener = function(eventName, handler) {};

/**
 * @param {string} eventName
 * @param {?} handler
 * @return {void}
 */
BackHandlerStatic.prototype.removeEventListener = function(eventName, handler) {};
/**
 * @record
 * @struct
 */
function ButtonProperties() {}
 /** @type {string} */
ButtonProperties.prototype.title;
 /** @type {?} */
ButtonProperties.prototype.onPress;
 /** @type {string} */
ButtonProperties.prototype.color;
 /** @type {string} */
ButtonProperties.prototype.accessibilityLabel;
 /** @type {boolean} */
ButtonProperties.prototype.disabled;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function ButtonStatic() {}

/** @typedef {string} */
var CameraRollGroupType;

/** @typedef {string} */
var CameraRollAssetType;
/**
 * @record
 * @struct
 */
function CameraRollFetchParams() {}
 /** @type {number} */
CameraRollFetchParams.prototype.first;
 /** @type {string} */
CameraRollFetchParams.prototype.after;
 /** @type {string} */
CameraRollFetchParams.prototype.groupTypes;
 /** @type {string} */
CameraRollFetchParams.prototype.groupName;
 /** @type {string} */
CameraRollFetchParams.prototype.assetType;
/**
 * @record
 * @struct
 */
function CameraRollNodeInfo() {}
 /** @type {?} */
CameraRollNodeInfo.prototype.image;
 /** @type {string} */
CameraRollNodeInfo.prototype.group_name;
 /** @type {number} */
CameraRollNodeInfo.prototype.timestamp;
 /** @type {?} */
CameraRollNodeInfo.prototype.location;
/**
 * @record
 * @struct
 */
function CameraRollEdgeInfo() {}
 /** @type {?} */
CameraRollEdgeInfo.prototype.node;
/**
 * @record
 * @struct
 */
function CameraRollAssetInfo() {}
 /** @type {!Array<?>} */
CameraRollAssetInfo.prototype.edges;
 /** @type {?} */
CameraRollAssetInfo.prototype.page_info;
/**
 * @record
 * @struct
 */
function GetPhotosParamType() {}
 /** @type {number} */
GetPhotosParamType.prototype.first;
 /** @type {string} */
GetPhotosParamType.prototype.after;
 /** @type {string} */
GetPhotosParamType.prototype.groupTypes;
 /** @type {string} */
GetPhotosParamType.prototype.groupName;
 /** @type {string} */
GetPhotosParamType.prototype.assetType;
 /** @type {!Array<string>} */
GetPhotosParamType.prototype.mimeTypes;
/**
 * @record
 * @struct
 */
function GetPhotosReturnType() {}
 /** @type {!Array<?>} */
GetPhotosReturnType.prototype.edges;
 /** @type {?} */
GetPhotosReturnType.prototype.page_info;
/**
 * @record
 * @struct
 */
function CameraRollStatic() {}
 /** @type {!Array<string>} */
CameraRollStatic.prototype.GroupTypesOptions;
 /** @type {!Array<string>} */
CameraRollStatic.prototype.AssetTypeOptions;

/**
 * Saves the image to the camera roll / gallery.
 * 
 * \@tag On Android, this is a local URI, such as "file:///sdcard/img.png".
 * On iOS, the tag can be one of the following:
 *      local URI
 *      assets-library tag
 *      a tag not maching any of the above, which means the image data will be stored in memory (and consume memory as long as the process is alive)
 * 
 * @deprecated use saveToCameraRoll instead
 * @param {string} tag
 * @return {!Promise<string>}
 */
CameraRollStatic.prototype.saveImageWithTag = function(tag) {};

/**
 * Saves the photo or video to the camera roll / gallery.
 * 
 * On Android, the tag must be a local image or video URI, such as `"file:///sdcard/img.png"`.
 * 
 * On iOS, the tag can be any image URI (including local, remote asset-library and base64 data URIs)
 * or a local video file URI (remote or data URIs are not supported for saving video at this time).
 * 
 * If the tag has a file extension of .mov or .mp4, it will be inferred as a video. Otherwise
 * it will be treated as a photo. To override the automatic choice, you can pass an optional
 * `type` parameter that must be one of 'photo' or 'video'.
 * 
 * Returns a Promise which will resolve with the new URI.
 * Saves the photo or video to the camera roll / gallery.
 * 
 * On Android, the tag must be a local image or video URI, such as `"file:///sdcard/img.png"`.
 * 
 * On iOS, the tag can be any image URI (including local, remote asset-library and base64 data URIs)
 * or a local video file URI (remote or data URIs are not supported for saving video at this time).
 * 
 * If the tag has a file extension of .mov or .mp4, it will be inferred as a video. Otherwise
 * it will be treated as a photo. To override the automatic choice, you can pass an optional
 * `type` parameter that must be one of 'photo' or 'video'.
 * 
 * Returns a Promise which will resolve with the new URI.
 * @param {string} tag
 * @param {string=} type
 * @return {!Promise<string>}
 */
CameraRollStatic.prototype.saveToCameraRoll = function(tag, type) {};

/**
 * Invokes callback with photo identifier objects from the local camera roll of the device matching shape defined by getPhotosReturnChecker.
 * 
 * @param {?} params
 * @return {!Promise<?>}
 */
CameraRollStatic.prototype.getPhotos = function(params) {};
/**
 * @record
 * @struct
 */
function ClipboardStatic() {}

/**
 * @return {!Promise<string>}
 */
ClipboardStatic.prototype.getString = function() {};

/**
 * @param {string} content
 * @return {void}
 */
ClipboardStatic.prototype.setString = function(content) {};
/**
 * @record
 * @struct
 */
function DatePickerAndroidOpenOption() {}
 /** @type {(number|!Date)} */
DatePickerAndroidOpenOption.prototype.date;
 /** @type {(number|!Date)} */
DatePickerAndroidOpenOption.prototype.minDate;
 /** @type {(number|!Date)} */
DatePickerAndroidOpenOption.prototype.maxDate;
 /** @type {string} */
DatePickerAndroidOpenOption.prototype.mode;
/**
 * @record
 * @struct
 */
function DatePickerAndroidOpenReturn() {}
 /** @type {string} */
DatePickerAndroidOpenReturn.prototype.action;
 /** @type {number} */
DatePickerAndroidOpenReturn.prototype.year;
 /** @type {number} */
DatePickerAndroidOpenReturn.prototype.month;
 /** @type {number} */
DatePickerAndroidOpenReturn.prototype.day;
/**
 * @record
 * @struct
 */
function DatePickerAndroidStatic() {}
 /** @type {string} */
DatePickerAndroidStatic.prototype.dateSetAction;
 /** @type {string} */
DatePickerAndroidStatic.prototype.dismissedAction;

/**
 * @param {?=} options
 * @return {!Promise<?>}
 */
DatePickerAndroidStatic.prototype.open = function(options) {};
/**
 * @record
 * @struct
 */
function FetchableListenable() {}
 /** @type {?} */
FetchableListenable.prototype.fetch;
 /** @type {?} */
FetchableListenable.prototype.addEventListener;
 /** @type {?} */
FetchableListenable.prototype.removeEventListener;
/**
 * @record
 * @struct
 */
function IntentAndroidStatic() {}

/**
 * Starts a corresponding external activity for the given URL.
 * For example, if the URL is "https://www.facebook.com", the system browser will be opened, or the "choose application" dialog will be shown.
 * You can use other URLs, like a location (e.g. "geo:37.484847,-122.148386"), a contact, or any other URL that can be opened with {\@code Intent.ACTION_VIEW}.
 * NOTE: This method will fail if the system doesn't know how to open the specified URL. If you're passing in a non-http(s) URL, it's best to check {\@code canOpenURL} first.
 * NOTE: For web URLs, the protocol ("http://", "https://") must be set accordingly!
 * @deprecated
 * @param {string} url
 * @return {void}
 */
IntentAndroidStatic.prototype.openURL = function(url) {};

/**
 * Determine whether or not an installed app can handle a given URL.
 * You can use other URLs, like a location (e.g. "geo:37.484847,-122.148386"), a contact, or any other URL that can be opened with {\@code Intent.ACTION_VIEW}.
 * NOTE: For web URLs, the protocol ("http://", "https://") must be set accordingly!
 * @deprecated
 * @param {string} url
 * @param {?} callback
 * @return {void}
 */
IntentAndroidStatic.prototype.canOpenURL = function(url, callback) {};

/**
 * If the app launch was triggered by an app link with {\@code Intent.ACTION_VIEW}, it will give the link url, otherwise it will give null
 * Refer http://developer.android.com/training/app-indexing/deep-linking.html#handling-intents
 * @deprecated
 * @param {?} callback
 * @return {void}
 */
IntentAndroidStatic.prototype.getInitialURL = function(callback) {};
/**
 * @record
 * @struct
 */
function LinkingStatic() {}

/**
 * Add a handler to Linking changes by listening to the `url` event type
 * and providing the handler
 * @param {string} type
 * @param {?} handler
 * @return {void}
 */
LinkingStatic.prototype.addEventListener = function(type, handler) {};

/**
 * Remove a handler by passing the `url` event type and the handler
 * @param {string} type
 * @param {?} handler
 * @return {void}
 */
LinkingStatic.prototype.removeEventListener = function(type, handler) {};

/**
 * Try to open the given url with any of the installed apps.
 * You can use other URLs, like a location (e.g. "geo:37.484847,-122.148386"), a contact, or any other URL that can be opened with the installed apps.
 * NOTE: This method will fail if the system doesn't know how to open the specified URL. If you're passing in a non-http(s) URL, it's best to check {\@code canOpenURL} first.
 * NOTE: For web URLs, the protocol ("http://", "https://") must be set accordingly!
 * @param {string} url
 * @return {!Promise<?>}
 */
LinkingStatic.prototype.openURL = function(url) {};

/**
 * Determine whether or not an installed app can handle a given URL.
 * NOTE: For web URLs, the protocol ("http://", "https://") must be set accordingly!
 * NOTE: As of iOS 9, your app needs to provide the LSApplicationQueriesSchemes key inside Info.plist.
 * @param {string} url
 * @return {!Promise<boolean>}
 */
LinkingStatic.prototype.canOpenURL = function(url) {};

/**
 * If the app launch was triggered by an app link with, it will give the link url, otherwise it will give null
 * NOTE: To support deep linking on Android, refer http://developer.android.com/training/app-indexing/deep-linking.html#handling-intents
 * @return {!Promise<string>}
 */
LinkingStatic.prototype.getInitialURL = function() {};
/**
 * @record
 * @struct
 */
function LinkingIOSStatic() {}

/**
 * Add a handler to LinkingIOS changes by listening to the url event type and providing the handler
 * @deprecated
 * @param {string} type
 * @param {?} handler
 * @return {void}
 */
LinkingIOSStatic.prototype.addEventListener = function(type, handler) {};

/**
 * Remove a handler by passing the url event type and the handler
 * @deprecated
 * @param {string} type
 * @param {?} handler
 * @return {void}
 */
LinkingIOSStatic.prototype.removeEventListener = function(type, handler) {};

/**
 * Try to open the given url with any of the installed apps.
 * @deprecated
 * @param {string} url
 * @return {void}
 */
LinkingIOSStatic.prototype.openURL = function(url) {};

/**
 * Determine whether or not an installed app can handle a given URL. The callback function will be called with bool supported as the only argument
 * NOTE: As of iOS 9, your app needs to provide the LSApplicationQueriesSchemes key inside Info.plist.
 * @deprecated
 * @param {string} url
 * @param {?} callback
 * @return {void}
 */
LinkingIOSStatic.prototype.canOpenURL = function(url, callback) {};

/**
 * If the app launch was triggered by an app link, it will pop the link url, otherwise it will return null
 * @deprecated
 * @return {string}
 */
LinkingIOSStatic.prototype.popInitialURL = function() {};

/** @typedef {string} */
var NetInfoReturnType;
/**
 * @extends {FetchableListenable}
 * @record
 * @struct
 */
function NetInfoStatic() {}
 /** @type {?} */
NetInfoStatic.prototype.isConnected;
 /** @type {!Promise<boolean>} */
NetInfoStatic.prototype.isConnectionExpensive;
/**
 * @record
 * @struct
 */
function PanResponderGestureState() {}
 /** @type {number} */
PanResponderGestureState.prototype.stateID;
 /** @type {number} */
PanResponderGestureState.prototype.moveX;
 /** @type {number} */
PanResponderGestureState.prototype.moveY;
 /** @type {number} */
PanResponderGestureState.prototype.x0;
 /** @type {number} */
PanResponderGestureState.prototype.y0;
 /** @type {number} */
PanResponderGestureState.prototype.dx;
 /** @type {number} */
PanResponderGestureState.prototype.dy;
 /** @type {number} */
PanResponderGestureState.prototype.vx;
 /** @type {number} */
PanResponderGestureState.prototype.vy;
 /** @type {number} */
PanResponderGestureState.prototype.numberActiveTouches;
 /** @type {number} */
PanResponderGestureState.prototype._accountsForMovesUpTo;
/**
 * @record
 * @struct
 */
function PanResponderCallbacks() {}
 /** @type {?} */
PanResponderCallbacks.prototype.onMoveShouldSetPanResponder;
 /** @type {?} */
PanResponderCallbacks.prototype.onStartShouldSetPanResponder;
 /** @type {?} */
PanResponderCallbacks.prototype.onPanResponderGrant;
 /** @type {?} */
PanResponderCallbacks.prototype.onPanResponderMove;
 /** @type {?} */
PanResponderCallbacks.prototype.onPanResponderRelease;
 /** @type {?} */
PanResponderCallbacks.prototype.onPanResponderTerminate;
 /** @type {?} */
PanResponderCallbacks.prototype.onMoveShouldSetPanResponderCapture;
 /** @type {?} */
PanResponderCallbacks.prototype.onStartShouldSetPanResponderCapture;
 /** @type {?} */
PanResponderCallbacks.prototype.onPanResponderReject;
 /** @type {?} */
PanResponderCallbacks.prototype.onPanResponderStart;
 /** @type {?} */
PanResponderCallbacks.prototype.onPanResponderEnd;
 /** @type {?} */
PanResponderCallbacks.prototype.onPanResponderTerminationRequest;
 /** @type {?} */
PanResponderCallbacks.prototype.onShouldBlockNativeResponder;
/**
 * @record
 * @struct
 */
function PanResponderInstance() {}
 /** @type {?} */
PanResponderInstance.prototype.panHandlers;
/**
 * @record
 * @struct
 */
function PanResponderStatic() {}

/**
 * that provide not only the typical `ResponderSyntheticEvent`, but also the
 * `PanResponder` gesture state.  Simply replace the word `Responder` with
 * `PanResponder` in each of the typical `onResponder*` callbacks. For
 * example, the `config` object would look like:
 * 
 *  - `onMoveShouldSetPanResponder: (e, gestureState) => {...}`
 *  - `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`
 *  - `onStartShouldSetPanResponder: (e, gestureState) => {...}`
 *  - `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`
 *  - `onPanResponderReject: (e, gestureState) => {...}`
 *  - `onPanResponderGrant: (e, gestureState) => {...}`
 *  - `onPanResponderStart: (e, gestureState) => {...}`
 *  - `onPanResponderEnd: (e, gestureState) => {...}`
 *  - `onPanResponderRelease: (e, gestureState) => {...}`
 *  - `onPanResponderMove: (e, gestureState) => {...}`
 *  - `onPanResponderTerminate: (e, gestureState) => {...}`
 *  - `onPanResponderTerminationRequest: (e, gestureState) => {...}`
 *  - `onShouldBlockNativeResponder: (e, gestureState) => {...}`
 * 
 *  In general, for events that have capture equivalents, we update the
 *  gestureState once in the capture phase and can use it in the bubble phase
 *  as well.
 * 
 *  Be careful with onStartShould* callbacks. They only reflect updated
 *  `gestureState` for start/end events that bubble/capture to the Node.
 *  Once the node is the responder, you can rely on every start/end event
 *  being processed by the gesture and `gestureState` being updated
 *  accordingly. (numberActiveTouches) may not be totally accurate unless you
 *  are the responder.
 * @param {?} config
 * @return {?}
 */
PanResponderStatic.prototype.create = function(config) {};
/**
 * @record
 * @struct
 */
function Rationale() {}
 /** @type {string} */
Rationale.prototype.title;
 /** @type {string} */
Rationale.prototype.message;

/** @typedef {string} */
var Permission;

/** @typedef {string} */
var PermissionStatus;
/**
 * @record
 * @struct
 */
function PermissionsAndroidStatic() {}
 /** @type {?} */
PermissionsAndroidStatic.prototype.RESULTS;
 /** @type {?} */
PermissionsAndroidStatic.prototype.PERMISSIONS;

/* TODO: ConstructSignature:  */

/**
 * Deprecated
 * @param {string} permission
 * @return {!Promise<boolean>}
 */
PermissionsAndroidStatic.prototype.checkPermission = function(permission) {};

/**
 * Returns a promise resolving to a boolean value as to whether the specified
 * permissions has been granted
 * @param {string} permission
 * @return {!Promise<boolean>}
 */
PermissionsAndroidStatic.prototype.check = function(permission) {};

/**
 * Deprecated
 * @param {string} permission
 * @param {?=} rationale
 * @return {!Promise<boolean>}
 */
PermissionsAndroidStatic.prototype.requestPermission = function(permission, rationale) {};

/**
 * Prompts the user to enable a permission and returns a promise resolving to a
 * string value indicating whether the user allowed or denied the request
 * 
 * If the optional rationale argument is included (which is an object with a
 * title and message), this function checks with the OS whether it is necessary
 * to show a dialog explaining why the permission is needed
 * (https://developer.android.com/training/permissions/requesting.html#explain)
 * and then shows the system permission dialog
 * @param {string} permission
 * @param {?=} rationale
 * @return {!Promise<string>}
 */
PermissionsAndroidStatic.prototype.request = function(permission, rationale) {};

/**
 * Prompts the user to enable multiple permissions in the same dialog and
 * returns an object with the permissions as keys and strings as values
 * indicating whether the user allowed or denied the request
 * @param {!Array<string>} permissions
 * @return {!Promise<?>}
 */
PermissionsAndroidStatic.prototype.requestMultiple = function(permissions) {};
/**
 * @record
 * @struct
 */
function PushNotificationPermissions() {}
 /** @type {boolean} */
PushNotificationPermissions.prototype.alert;
 /** @type {boolean} */
PushNotificationPermissions.prototype.badge;
 /** @type {boolean} */
PushNotificationPermissions.prototype.sound;
/**
 * @record
 * @struct
 */
function PushNotification() {}

/**
 * An alias for `getAlert` to get the notification's main message string
 * @return {(string|!Object)}
 */
PushNotification.prototype.getMessage = function() {};

/**
 * Gets the sound string from the `aps` object
 * @return {string}
 */
PushNotification.prototype.getSound = function() {};

/**
 * Gets the notification's main message from the `aps` object
 * @return {(string|!Object)}
 */
PushNotification.prototype.getAlert = function() {};

/**
 * Gets the badge count number from the `aps` object
 * @return {number}
 */
PushNotification.prototype.getBadgeCount = function() {};

/**
 * Gets the data object on the notif
 * @return {!Object}
 */
PushNotification.prototype.getData = function() {};

/** @typedef {?} */
var PresentLocalNotificationDetails;

/** @typedef {?} */
var ScheduleLocalNotificationDetails;

/** @typedef {string} */
var PushNotificationEventName;
/**
 * @record
 * @struct
 */
function PushNotificationIOSStatic() {}

/**
 * Schedules the localNotification for immediate presentation.
 * details is an object containing:
 * alertBody : The message displayed in the notification alert.
 * alertAction : The "action" displayed beneath an actionable notification. Defaults to "view";
 * soundName : The sound played when the notification is fired (optional).
 * category : The category of this notification, required for actionable notifications (optional).
 * userInfo : An optional object containing additional notification data.
 * applicationIconBadgeNumber (optional) : The number to display as the app's icon badge. The default value of this property is 0, which means that no badge is displayed.
 * @param {?} details
 * @return {void}
 */
PushNotificationIOSStatic.prototype.presentLocalNotification = function(details) {};

/**
 * Schedules the localNotification for future presentation.
 * details is an object containing:
 * fireDate : The date and time when the system should deliver the notification.
 * alertBody : The message displayed in the notification alert.
 * alertAction : The "action" displayed beneath an actionable notification. Defaults to "view";
 * soundName : The sound played when the notification is fired (optional).
 * category : The category of this notification, required for actionable notifications (optional).
 * userInfo : An optional object containing additional notification data.
 * applicationIconBadgeNumber (optional) : The number to display as the app's icon badge. Setting the number to 0 removes the icon badge.
 * @param {?} details
 * @return {void}
 */
PushNotificationIOSStatic.prototype.scheduleLocalNotification = function(details) {};

/**
 * Cancels all scheduled localNotifications
 * @return {void}
 */
PushNotificationIOSStatic.prototype.cancelAllLocalNotifications = function() {};

/**
 * Cancel local notifications.
 * Optionally restricts the set of canceled notifications to those notifications whose userInfo fields match the corresponding fields in the userInfo argument.
 * @param {!Object} userInfo
 * @return {void}
 */
PushNotificationIOSStatic.prototype.cancelLocalNotifications = function(userInfo) {};

/**
 * Sets the badge number for the app icon on the home screen
 * @param {number} number
 * @return {void}
 */
PushNotificationIOSStatic.prototype.setApplicationIconBadgeNumber = function(number) {};

/**
 * Gets the current badge number for the app icon on the home screen
 * @param {?} callback
 * @return {void}
 */
PushNotificationIOSStatic.prototype.getApplicationIconBadgeNumber = function(callback) {};

/**
 * Gets the local notifications that are currently scheduled.
 * @param {?} callback
 * @return {void}
 */
PushNotificationIOSStatic.prototype.getScheduledLocalNotifications = function(callback) {};

/**
 * Attaches a listener to remote notifications while the app is running in the
 * foreground or the background.
 * 
 * The handler will get be invoked with an instance of `PushNotificationIOS`
 * 
 * The type MUST be 'notification'
 * @param {string} type
 * @param {?} handler
 * @return {void}
 */
PushNotificationIOSStatic.prototype.addEventListener = function(type, handler) {};

/**
 * Removes the event listener. Do this in `componentWillUnmount` to prevent
 * memory leaks
 * @param {string} type
 * @param {?} handler
 * @return {void}
 */
PushNotificationIOSStatic.prototype.removeEventListener = function(type, handler) {};

/**
 * Requests all notification permissions from iOS, prompting the user's
 * dialog box.
 * Requests all notification permissions from iOS, prompting the user's
 * dialog box.
 * @param {!Array<?>|?=} permissions
 * @return {void|!Promise<?>}
 */
PushNotificationIOSStatic.prototype.requestPermissions = function(permissions) {};

/**
 * Unregister for all remote notifications received via Apple Push
 * Notification service.
 * You should call this method in rare circumstances only, such as when
 * a new version of the app removes support for all types of remote
 * notifications. Users can temporarily prevent apps from receiving
 * remote notifications through the Notifications section of the
 * Settings app. Apps unregistered through this method can always
 * re-register.
 * @return {void}
 */
PushNotificationIOSStatic.prototype.abandonPermissions = function() {};

/**
 * See what push permissions are currently enabled. `callback` will be
 * invoked with a `permissions` object:
 * 
 *  - `alert` :boolean
 *  - `badge` :boolean
 *  - `sound` :boolean
 * @param {?} callback
 * @return {void}
 */
PushNotificationIOSStatic.prototype.checkPermissions = function(callback) {};

/**
 * This method returns a promise that resolves to either the notification
 * object if the app was launched by a push notification, or `null` otherwise.
 * @return {!Promise<?>}
 */
PushNotificationIOSStatic.prototype.getInitialNotification = function() {};
/**
 * @record
 * @struct
 */
function SettingsStatic() {}

/**
 * @param {string} key
 * @return {?}
 */
SettingsStatic.prototype.get = function(key) {};

/**
 * @param {!Object} settings
 * @return {void}
 */
SettingsStatic.prototype.set = function(settings) {};

/**
 * @param {(string|!Array<string>)} keys
 * @param {?} callback
 * @return {number}
 */
SettingsStatic.prototype.watchKeys = function(keys, callback) {};

/**
 * @param {number} watchId
 * @return {void}
 */
SettingsStatic.prototype.clearWatch = function(watchId) {};

/** @typedef {string} */
var StatusBarStyle;

/** @typedef {string} */
var StatusBarAnimation;
/**
 * @record
 * @struct
 */
function StatusBarPropertiesIOS() {}
 /** @type {string} */
StatusBarPropertiesIOS.prototype.barStyle;
 /** @type {boolean} */
StatusBarPropertiesIOS.prototype.networkActivityIndicatorVisible;
 /** @type {string} */
StatusBarPropertiesIOS.prototype.showHideTransition;
/**
 * @record
 * @struct
 */
function StatusBarPropertiesAndroid() {}
 /** @type {string} */
StatusBarPropertiesAndroid.prototype.backgroundColor;
 /** @type {boolean} */
StatusBarPropertiesAndroid.prototype.translucent;
/**
 * @extends {StatusBarPropertiesIOS}
 * @extends {StatusBarPropertiesAndroid}
 * @record
 * @struct
 */
function StatusBarProperties() {}
 /** @type {boolean} */
StatusBarProperties.prototype.animated;
 /** @type {boolean} */
StatusBarProperties.prototype.hidden;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function StatusBarStatic() {}
 /** @type {number} */
StatusBarStatic.prototype.currentHeight;
 /** @type {?} */
StatusBarStatic.prototype.setHidden;
 /** @type {?} */
StatusBarStatic.prototype.setBarStyle;
 /** @type {?} */
StatusBarStatic.prototype.setNetworkActivityIndicatorVisible;
 /** @type {?} */
StatusBarStatic.prototype.setBackgroundColor;
 /** @type {?} */
StatusBarStatic.prototype.setTranslucent;
/**
 * @record
 * @struct
 */
function StatusBarIOSStatic() {}

/** @typedef {?} */
var TimePickerAndroidOpenOptions;
/**
 * @record
 * @struct
 */
function TimePickerAndroidStatic() {}
 /** @type {string} */
TimePickerAndroidStatic.prototype.timeSetAction;
 /** @type {string} */
TimePickerAndroidStatic.prototype.dismissedAction;

/**
 * Opens the standard Android time picker dialog.
 * 
 * The available keys for the `options` object are:
 *   * `hour` (0-23) - the hour to show, defaults to the current time
 *   * `minute` (0-59) - the minute to show, defaults to the current time
 *   * `is24Hour` (boolean) - If `true`, the picker uses the 24-hour format. If `false`,
 *     the picker shows an AM/PM chooser. If undefined, the default for the current locale
 *     is used.
 * 
 * Returns a Promise which will be invoked an object containing `action`, `hour` (0-23),
 * `minute` (0-59) if the user picked a time. If the user dismissed the dialog, the Promise will
 * still be resolved with action being `TimePickerAndroid.dismissedAction` and all the other keys
 * being undefined. **Always** check whether the `action` before reading the values.
 * @param {?} options
 * @return {!Promise<?>}
 */
TimePickerAndroidStatic.prototype.open = function(options) {};
/**
 * @record
 * @struct
 */
function ToastAndroidStatic() {}
 /** @type {number} */
ToastAndroidStatic.prototype.SHORT;
 /** @type {number} */
ToastAndroidStatic.prototype.LONG;
 /** @type {number} */
ToastAndroidStatic.prototype.TOP;
 /** @type {number} */
ToastAndroidStatic.prototype.BOTTOM;
 /** @type {number} */
ToastAndroidStatic.prototype.CENTER;

/**
 * String message: A string with the text to toast
 * int duration: The duration of the toast.
 * May be ToastAndroid.SHORT or ToastAndroid.LONG
 * @param {string} message
 * @param {number} duration
 * @return {void}
 */
ToastAndroidStatic.prototype.show = function(message, duration) {};

/**
 * `gravity` may be ToastAndroid.TOP, ToastAndroid.BOTTOM, ToastAndroid.CENTER
 * @param {string} message
 * @param {number} duration
 * @param {number} gravity
 * @return {void}
 */
ToastAndroidStatic.prototype.showWithGravity = function(message, duration, gravity) {};
/**
 * @record
 * @struct
 */
function UIManagerStatic() {}
 /** @type {?} */
UIManagerStatic.prototype.takeSnapshot;

/**
 * Determines the location on screen, width, and height of the given view and
 * returns the values via an async callback. If successful, the callback will
 * be called with the following arguments:
 * 
 *  - x
 *  - y
 *  - width
 *  - height
 *  - pageX
 *  - pageY
 * 
 * Note that these measurements are not available until after the rendering
 * has been completed in native. If you need the measurements as soon as
 * possible, consider using the [`onLayout`
 * prop](docs/view.html#onlayout) instead.
 * @param {number} node
 * @param {?} callback
 * @return {void}
 */
UIManagerStatic.prototype.measure = function(node, callback) {};

/**
 * Determines the location of the given view in the window and returns the
 * values via an async callback. If the React root view is embedded in
 * another native view, this will give you the absolute coordinates. If
 * successful, the callback will be called with the following
 * arguments:
 * 
 *  - x
 *  - y
 *  - width
 *  - height
 * 
 * Note that these measurements are not available until after the rendering
 * has been completed in native.
 * @param {number} node
 * @param {?} callback
 * @return {void}
 */
UIManagerStatic.prototype.measureInWindow = function(node, callback) {};

/**
 * Like [`measure()`](#measure), but measures the view relative an ancestor,
 * specified as `relativeToNativeNode`. This means that the returned x, y
 * are relative to the origin x, y of the ancestor view.
 * 
 * As always, to obtain a native node handle for a component, you can use
 * `React.findNodeHandle(component)`.
 * @param {number} node
 * @param {number} relativeToNativeNode
 * @param {?} onFail
 * @param {?} onSuccess
 * @return {void}
 */
UIManagerStatic.prototype.measureLayout = function(node, relativeToNativeNode, onFail, onSuccess) {};

/**
 * Automatically animates views to their new positions when the
 * next layout happens.
 * 
 * A common way to use this API is to call it before calling `setState`.
 * 
 * Note that in order to get this to work on **Android** you need to set the following flags via `UIManager`:
 * 
 *     UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);
 * @param {boolean} value
 * @return {void}
 */
UIManagerStatic.prototype.setLayoutAnimationEnabledExperimental = function(value) {};
/**
 * @extends {ViewProperties}
 * @record
 * @struct
 */
function SwitchPropertiesIOS() {}
 /** @type {string} */
SwitchPropertiesIOS.prototype.onTintColor;
 /** @type {string} */
SwitchPropertiesIOS.prototype.thumbTintColor;
 /** @type {string} */
SwitchPropertiesIOS.prototype.tintColor;
/**
 * @extends {SwitchPropertiesIOS}
 * @record
 * @struct
 */
function SwitchProperties() {}
 /** @type {boolean} */
SwitchProperties.prototype.disabled;
 /** @type {?} */
SwitchProperties.prototype.onValueChange;
 /** @type {string} */
SwitchProperties.prototype.testID;
 /** @type {boolean} */
SwitchProperties.prototype.value;
 /** @type {(boolean|?)} */
SwitchProperties.prototype.style;
/**
 * @extends {NativeMethodsMixin}
 * @extends {React.ClassicComponentClass}
 * @record
 * @struct
 */
function SwitchStatic() {}
/**
 * @record
 * @struct
 */
function VibrationIOSStatic() {}

/**
 * @deprecated
 * @return {void}
 */
VibrationIOSStatic.prototype.vibrate = function() {};
/**
 * @record
 * @struct
 */
function VibrationStatic() {}

/**
 * @param {(number|!Array<number>)} pattern
 * @param {boolean} repeat
 * @return {void}
 */
VibrationStatic.prototype.vibrate = function(pattern, repeat) {};

/**
 * Stop vibration
 * @return {void}
 */
VibrationStatic.prototype.cancel = function() {};

/** @typedef {?} */
var EasingFunction;
/**
 * @record
 * @struct
 */
function EasingStatic() {}
 /** @type {?} */
EasingStatic.prototype.step0;
 /** @type {?} */
EasingStatic.prototype.step1;
 /** @type {?} */
EasingStatic.prototype.linear;
 /** @type {?} */
EasingStatic.prototype.ease;
 /** @type {?} */
EasingStatic.prototype.quad;
 /** @type {?} */
EasingStatic.prototype.cubic;
 /** @type {?} */
EasingStatic.prototype.poly;
 /** @type {?} */
EasingStatic.prototype.sin;
 /** @type {?} */
EasingStatic.prototype.circle;
 /** @type {?} */
EasingStatic.prototype.exp;
 /** @type {?} */
EasingStatic.prototype.bounce;

/**
 * @param {number} bounciness
 * @return {?}
 */
EasingStatic.prototype.elastic = function(bounciness) {};

/**
 * @param {number} s
 * @return {?}
 */
EasingStatic.prototype.back = function(s) {};

/**
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @return {?}
 */
EasingStatic.prototype.bezier = function(x1, y1, x2, y2) {};

/**
 * @param {?} easing
 * @return {?}
 */
EasingStatic.prototype.in = function(easing) {};

/**
 * @param {?} easing
 * @return {?}
 */
EasingStatic.prototype.out = function(easing) {};

/**
 * @param {?} easing
 * @return {?}
 */
EasingStatic.prototype.inOut = function(easing) {};
/** @const */
var Animated = {};

/** @typedef {?} */
Animated.AnimatedValue;

/** @typedef {?} */
Animated.AnimatedValueXY;

/** @typedef {?} */
Animated.Base;
/**
 * @constructor
 * @struct
 */
Animated.Animated = function() {};
/**
 * @constructor
 * @struct
 */
Animated.AnimatedWithChildren = function() {};
/**
 * @constructor
 * @struct
 */
Animated.AnimatedInterpolation = function() {};

/**
 * @param {?} config
 * @return {?}
 */
Animated.AnimatedInterpolation.prototype.interpolate = function(config) {};

/** @typedef {string} */
Animated.ExtrapolateType;

/** @typedef {?} */
Animated.InterpolationConfigType;

/** @typedef {?} */
Animated.ValueListenerCallback;

/**
 * @constructor
 * @struct
 * @param {number} value
 */
Animated.Value = function(value) {};

/**
 * Directly set the value.  This will stop any animations running on the value
 * and update all the bound properties.
 * @param {number} value
 * @return {void}
 */
Animated.Value.prototype.setValue = function(value) {};

/**
 * Sets an offset that is applied on top of whatever value is set, whether via
 * `setValue`, an animation, or `Animated.event`.  Useful for compensating
 * things like the start of a pan gesture.
 * @param {number} offset
 * @return {void}
 */
Animated.Value.prototype.setOffset = function(offset) {};

/**
 * Merges the offset value into the base value and resets the offset to zero.
 * The final output of the value is unchanged.
 * @return {void}
 */
Animated.Value.prototype.flattenOffset = function() {};

/**
 * Adds an asynchronous listener to the value so you can observe updates from
 * animations.  This is useful because there is no way to
 * synchronously read the value because it might be driven natively.
 * @param {?} callback
 * @return {string}
 */
Animated.Value.prototype.addListener = function(callback) {};

/**
 * @param {string} id
 * @return {void}
 */
Animated.Value.prototype.removeListener = function(id) {};

/**
 * @return {void}
 */
Animated.Value.prototype.removeAllListeners = function() {};

/**
 * Stops any running animation or tracking.  `callback` is invoked with the
 * final value after stopping the animation, which is useful for updating
 * state to match the animation position with layout.
 * @param {?=} callback
 * @return {void}
 */
Animated.Value.prototype.stopAnimation = function(callback) {};

/**
 * Interpolates the value before updating the property, e.g. mapping 0-1 to
 * 0-10.
 * @param {?} config
 * @return {?}
 */
Animated.Value.prototype.interpolate = function(config) {};

/** @typedef {?} */
Animated.ValueXYListenerCallback;

/**
 * @constructor
 * @struct
 * @param {?=} valueIn
 */
Animated.ValueXY = function(valueIn) {};
 /** @type {?} */
Animated.ValueXY.prototype.x;
 /** @type {?} */
Animated.ValueXY.prototype.y;

/**
 * @param {?} value
 * @return {void}
 */
Animated.ValueXY.prototype.setValue = function(value) {};

/**
 * @param {?} offset
 * @return {void}
 */
Animated.ValueXY.prototype.setOffset = function(offset) {};

/**
 * @return {void}
 */
Animated.ValueXY.prototype.flattenOffset = function() {};

/**
 * @param {?=} callback
 * @return {void}
 */
Animated.ValueXY.prototype.stopAnimation = function(callback) {};

/**
 * @param {?} callback
 * @return {string}
 */
Animated.ValueXY.prototype.addListener = function(callback) {};

/**
 * @param {string} id
 * @return {void}
 */
Animated.ValueXY.prototype.removeListener = function(id) {};

/**
 * Converts `{x, y}` into `{left, top}` for use in style, e.g.
 * 
 * ```javascript
 *  style={this.state.anim.getLayout()}
 * ```
 * @return {?}
 */
Animated.ValueXY.prototype.getLayout = function() {};

/**
 * Converts `{x, y}` into a useable translation transform, e.g.
 * 
 * ```javascript
 *  style={{
 *    transform: this.state.anim.getTranslateTransform()
 *  }}
 * ```
 * @return {!Array<?>}
 */
Animated.ValueXY.prototype.getTranslateTransform = function() {};

/** @typedef {?} */
Animated.EndResult;

/** @typedef {?} */
Animated.EndCallback;
/**
 * @record
 * @struct
 */
Animated.CompositeAnimation = function() {};
 /** @type {?} */
Animated.CompositeAnimation.prototype.start;
 /** @type {?} */
Animated.CompositeAnimation.prototype.stop;
/**
 * @record
 * @struct
 */
Animated.AnimationConfig = function() {};
 /** @type {boolean} */
Animated.AnimationConfig.prototype.isInteraction;
 /** @type {boolean} */
Animated.AnimationConfig.prototype.useNativeDriver;

/**
 * Animates a value from an initial velocity to zero based on a decay
 * coefficient.
 * @param {?} value
 * @param {?} config
 * @return {?}
 */
Animated.decay = function(value, config) {};
/**
 * @extends {Animated.AnimationConfig}
 * @record
 * @struct
 */
Animated.DecayAnimationConfig = function() {};
 /** @type {(number|?)} */
Animated.DecayAnimationConfig.prototype.velocity;
 /** @type {number} */
Animated.DecayAnimationConfig.prototype.deceleration;
 /** @type {?} */
Animated.timing;
/**
 * @extends {Animated.AnimationConfig}
 * @record
 * @struct
 */
Animated.TimingAnimationConfig = function() {};
 /** @type {(number|?)} */
Animated.TimingAnimationConfig.prototype.toValue;
 /** @type {?} */
Animated.TimingAnimationConfig.prototype.easing;
 /** @type {number} */
Animated.TimingAnimationConfig.prototype.duration;
 /** @type {number} */
Animated.TimingAnimationConfig.prototype.delay;
/**
 * @extends {Animated.AnimationConfig}
 * @record
 * @struct
 */
Animated.SpringAnimationConfig = function() {};
 /** @type {(number|?)} */
Animated.SpringAnimationConfig.prototype.toValue;
 /** @type {boolean} */
Animated.SpringAnimationConfig.prototype.overshootClamping;
 /** @type {number} */
Animated.SpringAnimationConfig.prototype.restDisplacementThreshold;
 /** @type {number} */
Animated.SpringAnimationConfig.prototype.restSpeedThreshold;
 /** @type {(number|?)} */
Animated.SpringAnimationConfig.prototype.velocity;
 /** @type {number} */
Animated.SpringAnimationConfig.prototype.bounciness;
 /** @type {number} */
Animated.SpringAnimationConfig.prototype.speed;
 /** @type {number} */
Animated.SpringAnimationConfig.prototype.tension;
 /** @type {number} */
Animated.SpringAnimationConfig.prototype.friction;

/**
 * Creates a new Animated value composed from two Animated values added
 * together.
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Animated.add = function(a, b) {};
/**
 * @constructor
 * @struct
 */
Animated.AnimatedAddition = function() {};

/**
 * Creates a new Animated value composed by dividing the first Animated
 * value by the second Animated value.
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Animated.divide = function(a, b) {};
/**
 * @constructor
 * @struct
 */
Animated.AnimatedDivision = function() {};

/**
 * Creates a new Animated value composed from two Animated values multiplied
 * together.
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
Animated.multiply = function(a, b) {};
/**
 * @constructor
 * @struct
 */
Animated.AnimatedMultiplication = function() {};

/**
 * Creates a new Animated value that is the (non-negative) modulo of the
 * provided Animated value
 * @param {?} a
 * @param {number} modulus
 * @return {?}
 */
Animated.modulo = function(a, modulus) {};
/**
 * @constructor
 * @struct
 */
Animated.AnimatedModulo = function() {};

/**
 * Create a new Animated value that is limited between 2 values. It uses the
 * difference between the last value so even if the value is far from the bounds
 * it will start changing when the value starts getting closer again.
 * (`value = clamp(value + diff, min, max)`).
 * 
 * This is useful with scroll events, for example, to show the navbar when
 * scrolling up and to hide it when scrolling down.
 * @param {?} a
 * @param {number} min
 * @param {number} max
 * @return {?}
 */
Animated.diffClamp = function(a, min, max) {};
/**
 * @constructor
 * @struct
 */
Animated.AnimatedDiffClamp = function() {};

/**
 * Starts an animation after the given delay.
 * @param {number} time
 * @return {?}
 */
Animated.delay = function(time) {};

/**
 * Starts an array of animations in order, waiting for each to complete
 * before starting the next.  If the current running animation is stopped, no
 * following animations will be started.
 * @param {!Array<?>} animations
 * @return {?}
 */
Animated.sequence = function(animations) {};

/**
 * Array of animations may run in parallel (overlap), but are started in
 * sequence with successive delays.  Nice for doing trailing effects.
 * @param {number} time
 * @param {!Array<?>} animations
 * @return {?}
 */
Animated.stagger = function(time, animations) {};

/**
 * Spring animation based on Rebound and Origami.  Tracks velocity state to
 * create fluid motions as the `toValue` updates, and can be chained together.
 * @param {?} value
 * @param {?} config
 * @return {?}
 */
Animated.spring = function(value, config) {};

/** @typedef {?} */
Animated.ParallelConfig;

/**
 * Starts an array of animations all at the same time.  By default, if one
 * of the animations is stopped, they will all be stopped.  You can override
 * this with the `stopTogether` flag.
 * @param {!Array<?>} animations
 * @param {?=} config
 * @return {?}
 */
Animated.parallel = function(animations, config) {};

/** @typedef {?} */
Animated.Mapping;
/**
 * @record
 * @struct
 */
Animated.EventConfig = function() {};
 /** @type {?} */
Animated.EventConfig.prototype.listener;
 /** @type {boolean} */
Animated.EventConfig.prototype.useNativeDriver;

/**
 *  Takes an array of mappings and extracts values from each arg accordingly,
 *  then calls `setValue` on the mapped outputs.  e.g.
 * 
 * ```javascript
 *  onScroll={Animated.event(
 *    [{nativeEvent: {contentOffset: {x: this._scrollX}}}]
 *    {listener},          // Optional async listener
 *  )
 *  ...
 *  onPanResponderMove: Animated.event([
 *    null,                // raw event arg ignored
 *    {dx: this._panX},    // gestureState arg
 *  ]),
 * ```
 * @param {!Array<?>} argMapping
 * @param {?=} config
 * @return {?}
 */
Animated.event = function(argMapping, config) {};

/**
 * Make any React component Animatable.  Used to create `Animated.View`, etc.
 * @param {?} component
 * @return {?}
 */
Animated.createAnimatedComponent = function(component) {};
 /** @type {?} */
Animated.View;
 /** @type {?} */
Animated.Image;
 /** @type {?} */
Animated.Text;
/**
 * @record
 * @struct
 */
function I18nManagerStatic() {}
 /** @type {boolean} */
I18nManagerStatic.prototype.isRTL;
 /** @type {?} */
I18nManagerStatic.prototype.allowRTL;
 /** @type {?} */
I18nManagerStatic.prototype.forceRTL;
/**
 * @record
 * @struct
 */
function GeolocationStatic() {}

/**
 * @param {?} geo_success
 * @param {?=} geo_error
 * @param {?=} geo_options
 * @return {void}
 */
GeolocationStatic.prototype.getCurrentPosition = function(geo_success, geo_error, geo_options) {};

/**
 * @param {?} success
 * @param {?=} error
 * @param {?=} options
 * @return {void}
 */
GeolocationStatic.prototype.watchPosition = function(success, error, options) {};

/**
 * @param {number} watchID
 * @return {void}
 */
GeolocationStatic.prototype.clearWatch = function(watchID) {};

/**
 * @return {void}
 */
GeolocationStatic.prototype.stopObserving = function() {};
/**
 * @record
 * @struct
 */
function OpenCameraDialogOptions() {}
 /** @type {boolean} */
OpenCameraDialogOptions.prototype.videoMode;
/**
 * @record
 * @struct
 */
function OpenSelectDialogOptions() {}
 /** @type {boolean} */
OpenSelectDialogOptions.prototype.showImages;
 /** @type {boolean} */
OpenSelectDialogOptions.prototype.showVideos;

/** @typedef {!Array<?>} */
var ImagePickerResult;
/**
 * @record
 * @struct
 */
function ImagePickerIOSStatic() {}

/**
 * @param {?} callback
 * @return {void}
 */
ImagePickerIOSStatic.prototype.canRecordVideos = function(callback) {};

/**
 * @param {?} callback
 * @return {void}
 */
ImagePickerIOSStatic.prototype.canUseCamera = function(callback) {};

/**
 * @param {?} config
 * @param {?} successCallback
 * @param {?} cancelCallback
 * @return {void}
 */
ImagePickerIOSStatic.prototype.openCameraDialog = function(config, successCallback, cancelCallback) {};

/**
 * @param {?} config
 * @param {?} successCallback
 * @param {?} cancelCallback
 * @return {void}
 */
ImagePickerIOSStatic.prototype.openSelectDialog = function(config, successCallback, cancelCallback) {};
/**
 * @record
 * @struct
 */
function ImageStoreStatic() {}

/**
 * Check if the ImageStore contains image data for the specified URI.
 * \@platform ios
 * @param {string} uri
 * @param {?} callback
 * @return {void}
 */
ImageStoreStatic.prototype.hasImageForTag = function(uri, callback) {};

/**
 * Delete an image from the ImageStore. Images are stored in memory and
 * must be manually removed when you are finished with them, otherwise they
 * will continue to use up RAM until the app is terminated. It is safe to
 * call `removeImageForTag()` without first calling `hasImageForTag()`, it
 * will simply fail silently.
 * \@platform ios
 * @param {string} uri
 * @return {void}
 */
ImageStoreStatic.prototype.removeImageForTag = function(uri) {};

/**
 * Stores a base64-encoded image in the ImageStore, and returns a URI that
 * can be used to access or display the image later. Images are stored in
 * memory only, and must be manually deleted when you are finished with
 * them by calling `removeImageForTag()`.
 * 
 * Note that it is very inefficient to transfer large quantities of binary
 * data between JS and native code, so you should avoid calling this more
 * than necessary.
 * \@platform ios
 * @param {string} base64ImageData
 * @param {?} success
 * @param {?} failure
 * @return {void}
 */
ImageStoreStatic.prototype.addImageFromBase64 = function(base64ImageData, success, failure) {};

/**
 * Retrieves the base64-encoded data for an image in the ImageStore. If the
 * specified URI does not match an image in the store, the failure callback
 * will be called.
 * 
 * Note that it is very inefficient to transfer large quantities of binary
 * data between JS and native code, so you should avoid calling this more
 * than necessary. To display an image in the ImageStore, you can just pass
 * the URI to an `<Image/>` component; there is no need to retrieve the
 * base64 data.
 * @param {string} uri
 * @param {?} success
 * @param {?} failure
 * @return {void}
 */
ImageStoreStatic.prototype.getBase64ForTag = function(uri, success, failure) {};

/** @typedef {?} */
var fetch;
 /** @type {?} */
var fetch;

/** @typedef {?} */
var timedScheduler;

/** @typedef {?} */
var setTimeout;

/** @typedef {?} */
var setInterval;

/** @typedef {?} */
var setImmediate;

/** @typedef {?} */
var requestAnimationFrame;

/** @typedef {?} */
var schedulerCanceller;

/** @typedef {?} */
var clearTimeout;

/** @typedef {?} */
var clearInterval;

/** @typedef {?} */
var clearImmediate;

/** @typedef {?} */
var cancelAnimationFrame;
/**
 * @record
 * @struct
 */
function TabsReducerStatic() {}

/**
 * @param {number} index
 * @return {?}
 */
TabsReducerStatic.prototype.JumpToAction = function(index) {};

/** @typedef {?} */
var TabsReducerFunction;
/**
 * @record
 * @struct
 */
function NavigationTab() {}
 /** @type {string} */
NavigationTab.prototype.key;
/**
 * @record
 * @struct
 */
function NavigationAction() {}
 /** @type {string} */
NavigationAction.prototype.type;
/**
 * @record
 * @struct
 */
function NavigationRoute() {}
 /** @type {string} */
NavigationRoute.prototype.key;
 /** @type {string} */
NavigationRoute.prototype.title;
/**
 * @extends {NavigationRoute}
 * @record
 * @struct
 */
function NavigationState() {}
 /** @type {number} */
NavigationState.prototype.index;
 /** @type {!Array<?>} */
NavigationState.prototype.routes;

/** @typedef {?} */
var NavigationRenderer;
/**
 * @extends {NavigationSceneRendererProps}
 * @record
 * @struct
 */
function SubViewProps() {}

/**
 * @return {void}
 */
SubViewProps.prototype.onNavigateBack = function() {};

/** @typedef {?} */
var SubViewRenderer;
/**
 * @extends {NavigationSceneRendererProps}
 * @record
 * @struct
 */
function NavigationHeaderProps() {}
 /** @type {?} */
NavigationHeaderProps.prototype.renderLeftComponent;
 /** @type {?} */
NavigationHeaderProps.prototype.renderRightComponent;
 /** @type {?} */
NavigationHeaderProps.prototype.renderTitleComponent;
 /** @type {(boolean|?)} */
NavigationHeaderProps.prototype.style;
 /** @type {?} */
NavigationHeaderProps.prototype.viewProps;
 /** @type {(number|?)} */
NavigationHeaderProps.prototype.statusBarHeight;

/**
 * @return {void}
 */
NavigationHeaderProps.prototype.onNavigateBack = function() {};
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function NavigationHeaderStatic() {}
 /** @type {?} */
NavigationHeaderStatic.prototype.Title;
 /** @type {number} */
NavigationHeaderStatic.prototype.HEIGHT;
/**
 * @record
 * @struct
 */
function NavigationHeaderTitleProps() {}
 /** @type {!JSX.Element} */
NavigationHeaderTitleProps.prototype.children;
 /** @type {(boolean|?)} */
NavigationHeaderTitleProps.prototype.style;
 /** @type {(boolean|?)} */
NavigationHeaderTitleProps.prototype.textStyle;
 /** @type {?} */
NavigationHeaderTitleProps.prototype.viewProps;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function NavigationHeaderTitleStatic() {}
/**
 * @record
 * @struct
 */
function NavigationCardStackProps() {}
 /** @type {(boolean|?)} */
NavigationCardStackProps.prototype.cardStyle;
 /** @type {?} */
NavigationCardStackProps.prototype.cardStyleInterpolator;
 /** @type {string} */
NavigationCardStackProps.prototype.direction;
 /** @type {number} */
NavigationCardStackProps.prototype.gestureResponseDistance;
 /** @type {boolean} */
NavigationCardStackProps.prototype.enableGestures;
 /** @type {?} */
NavigationCardStackProps.prototype.navigationState;
 /** @type {?} */
NavigationCardStackProps.prototype.onNavigateBack;
 /** @type {?} */
NavigationCardStackProps.prototype.renderHeader;
 /** @type {?} */
NavigationCardStackProps.prototype.renderScene;
 /** @type {(boolean|?)} */
NavigationCardStackProps.prototype.style;

/** @typedef {?} */
var NavigationAnimatedValue;

/** @typedef {string} */
var NavigationGestureDirection;

/** @typedef {?} */
var NavigationLayout;

/** @typedef {?} */
var NavigationScene;
/**
 * @record
 * @struct
 */
function NavigationSceneRendererProps() {}
 /** @type {?} */
NavigationSceneRendererProps.prototype.layout;
 /** @type {?} */
NavigationSceneRendererProps.prototype.navigationState;
 /** @type {?} */
NavigationSceneRendererProps.prototype.position;
 /** @type {?} */
NavigationSceneRendererProps.prototype.progress;
 /** @type {!Array<?>} */
NavigationSceneRendererProps.prototype.scenes;
 /** @type {?} */
NavigationSceneRendererProps.prototype.scene;
 /** @type {number} */
NavigationSceneRendererProps.prototype.gestureResponseDistance;
/**
 * @extends {React.StatelessComponent}
 * @record
 * @struct
 */
function NavigationSceneRenderer() {}
/**
 * @record
 * @struct
 */
function NavigationPropTypes() {}
 /** @type {?} */
NavigationPropTypes.prototype.SceneRendererProps;
 /** @type {?} */
NavigationPropTypes.prototype.SceneRenderer;
 /** @type {?} */
NavigationPropTypes.prototype.action;
 /** @type {?} */
NavigationPropTypes.prototype.navigationState;
 /** @type {?} */
NavigationPropTypes.prototype.navigationRoute;
 /** @type {?} */
NavigationPropTypes.prototype.panHandlers;

/**
 * @param {?} props
 * @return {?}
 */
NavigationPropTypes.prototype.extractSceneRendererProps = function(props) {};
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function NavigationCardProps() {}
 /** @type {?} */
NavigationCardProps.prototype.onComponentRef;
 /** @type {?} */
NavigationCardProps.prototype.onNavigateBack;
 /** @type {?} */
NavigationCardProps.prototype.panHandlers;
 /** @type {string} */
NavigationCardProps.prototype.pointerEvents;
 /** @type {?} */
NavigationCardProps.prototype.renderScene;
 /** @type {(boolean|?)} */
NavigationCardProps.prototype.style;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function NavigationCardStackStatic() {}
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function NavigationCardStatic() {}
/**
 * @record
 * @struct
 */
function NavigationStateUtils() {}

/**
 * @param {?} state
 * @param {string} key
 * @return {?}
 */
NavigationStateUtils.prototype.get = function(state, key) {};

/**
 * @param {?} state
 * @param {string} key
 * @return {number}
 */
NavigationStateUtils.prototype.indexOf = function(state, key) {};

/**
 * @param {?} state
 * @param {string} key
 * @return {boolean}
 */
NavigationStateUtils.prototype.has = function(state, key) {};

/**
 * @param {?} state
 * @param {?} route
 * @return {?}
 */
NavigationStateUtils.prototype.push = function(state, route) {};

/**
 * @param {?} state
 * @return {?}
 */
NavigationStateUtils.prototype.pop = function(state) {};

/**
 * @param {?} state
 * @param {number} index
 * @return {?}
 */
NavigationStateUtils.prototype.jumpToIndex = function(state, index) {};

/**
 * @param {?} state
 * @param {string} key
 * @return {?}
 */
NavigationStateUtils.prototype.jumpTo = function(state, key) {};

/**
 * @param {?} state
 * @return {?}
 */
NavigationStateUtils.prototype.back = function(state) {};

/**
 * @param {?} state
 * @return {?}
 */
NavigationStateUtils.prototype.forward = function(state) {};

/**
 * @param {?} state
 * @param {string} key
 * @param {?} route
 * @return {?}
 */
NavigationStateUtils.prototype.replaceAt = function(state, key, route) {};

/**
 * @param {?} state
 * @param {number} index
 * @param {?} route
 * @return {?}
 */
NavigationStateUtils.prototype.replaceAtIndex = function(state, index, route) {};

/**
 * @param {?} state
 * @param {!Array<?>} routes
 * @param {number=} index
 * @return {?}
 */
NavigationStateUtils.prototype.reset = function(state, routes, index) {};

/** @typedef {?} */
var NavigationTransitionProps;

/** @typedef {?} */
var NavigationTransitionSpec;
/**
 * @record
 * @struct
 */
function NavigationTransitionerProps() {}
 /** @type {?} */
NavigationTransitionerProps.prototype.configureTransition;
 /** @type {?} */
NavigationTransitionerProps.prototype.navigationState;
 /** @type {?} */
NavigationTransitionerProps.prototype.onTransitionEnd;
 /** @type {?} */
NavigationTransitionerProps.prototype.onTransitionStart;
 /** @type {?} */
NavigationTransitionerProps.prototype.render;
 /** @type {?} */
NavigationTransitionerProps.prototype.style;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function NavigationTransitioner() {}
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function NavigationCard() {}
/**
 * @record
 * @struct
 */
function NavigationExperimentalStatic() {}
 /** @type {?} */
NavigationExperimentalStatic.prototype.StateUtils;
 /** @type {?} */
NavigationExperimentalStatic.prototype.Transitioner;
 /** @type {?} */
NavigationExperimentalStatic.prototype.Card;
 /** @type {?} */
NavigationExperimentalStatic.prototype.CardStack;
 /** @type {?} */
NavigationExperimentalStatic.prototype.Header;
 /** @type {?} */
NavigationExperimentalStatic.prototype.PropTypes;
/**
 * @record
 * @struct
 */
function NativeEventSubscription() {}

/**
 * Call this method to un-subscribe from a native-event
 * @return {void}
 */
NativeEventSubscription.prototype.remove = function() {};

/** @typedef {?} */
var RCTNativeAppEventEmitter;
/**
 * @record
 * @struct
 */
function ImageCropData() {}
 /** @type {?} */
ImageCropData.prototype.offset;
 /** @type {?} */
ImageCropData.prototype.size;
 /** @type {?} */
ImageCropData.prototype.displaySize;
 /** @type {string} */
ImageCropData.prototype.resizeMode;
/**
 * @record
 * @struct
 */
function ImageEditorStatic() {}

/**
 * Crop the image specified by the URI param. If URI points to a remote
 * image, it will be downloaded automatically. If the image cannot be
 * loaded/downloaded, the failure callback will be called.
 * 
 * If the cropping process is successful, the resultant cropped image
 * will be stored in the ImageStore, and the URI returned in the success
 * callback will point to the image in the store. Remember to delete the
 * cropped image from the ImageStore when you are done with it.
 * @param {string} uri
 * @param {?} cropData
 * @param {?} success
 * @param {?} failure
 * @return {void}
 */
ImageEditorStatic.prototype.cropImage = function(uri, cropData, success, failure) {};
/**
 * @record
 * @struct
 */
function ARTShapeProps() {}
 /** @type {string} */
ARTShapeProps.prototype.d;
 /** @type {number} */
ARTShapeProps.prototype.strokeWidth;
 /** @type {!Array<number>} */
ARTShapeProps.prototype.strokeDash;
 /** @type {string} */
ARTShapeProps.prototype.stroke;
/**
 * @record
 * @struct
 */
function ARTSurfaceProps() {}
 /** @type {(boolean|?)} */
ARTSurfaceProps.prototype.style;
 /** @type {number} */
ARTSurfaceProps.prototype.width;
 /** @type {number} */
ARTSurfaceProps.prototype.height;
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function ShapeStatic() {}
/**
 * @extends {React.ComponentClass}
 * @record
 * @struct
 */
function SurfaceStatic() {}
/**
 * @record
 * @struct
 */
function ARTStatic() {}
 /** @type {?} */
ARTStatic.prototype.Shape;
 /** @type {?} */
ARTStatic.prototype.Surface;
/**
 * @record
 * @struct
 */
function KeyboardStatic() {}
 /** @type {?} */
KeyboardStatic.prototype.dismiss;
 /** @type {?} */
var ART;

/** @typedef {?} */
var ART;
 /** @type {?} */
var ActivityIndicator;

/** @typedef {?} */
var ActivityIndicator;
 /** @type {?} */
var ActivityIndicatorIOS;

/** @typedef {?} */
var ActivityIndicatorIOS;
 /** @type {?} */
var DatePickerIOS;

/** @typedef {?} */
var DatePickerIOS;
 /** @type {?} */
var DrawerLayoutAndroid;

/** @typedef {?} */
var DrawerLayoutAndroid;
 /** @type {?} */
var Image;

/** @typedef {?} */
var Image;
 /** @type {?} */
var ImageBackground;

/** @typedef {?} */
var ImageBackground;
 /** @type {?} */
var ImagePickerIOS;

/** @typedef {?} */
var ImagePickerIOS;
 /** @type {?} */
var FlatList;

/** @typedef {?} */
var FlatList;
 /** @type {?} */
var LayoutAnimation;

/** @typedef {?} */
var LayoutAnimation;
 /** @type {?} */
var ListView;

/** @typedef {?} */
var ListView;
 /** @type {?} */
var MapView;

/** @typedef {?} */
var MapView;
 /** @type {?} */
var Modal;

/** @typedef {?} */
var Modal;
 /** @type {?} */
var Navigator;

/** @typedef {?} */
var Navigator;
 /** @type {?} */
var NavigatorIOS;

/** @typedef {?} */
var NavigatorIOS;
 /** @type {?} */
var Picker;

/** @typedef {?} */
var Picker;
 /** @type {?} */
var PickerIOS;

/** @typedef {?} */
var PickerIOS;
 /** @type {?} */
var ProgressBarAndroid;

/** @typedef {?} */
var ProgressBarAndroid;
 /** @type {?} */
var ProgressViewIOS;

/** @typedef {?} */
var ProgressViewIOS;
 /** @type {?} */
var RefreshControl;

/** @typedef {?} */
var RefreshControl;
 /** @type {?} */
var RecyclerViewBackedScrollView;

/** @typedef {?} */
var RecyclerViewBackedScrollView;
 /** @type {?} */
var SegmentedControlIOS;

/** @typedef {?} */
var SegmentedControlIOS;
 /** @type {?} */
var Slider;

/** @typedef {?} */
var Slider;
 /** @type {?} */
var SliderIOS;

/** @typedef {?} */
var SliderIOS;
 /** @type {?} */
var StatusBar;

/** @typedef {?} */
var StatusBar;
 /** @type {?} */
var ScrollView;

/** @typedef {?} */
var ScrollView;
 /** @type {?} */
var SectionList;

/** @typedef {?} */
var SectionList;
 /** @type {?} */
var SnapshotViewIOS;

/** @typedef {?} */
var SnapshotViewIOS;
 /** @type {?} */
var Systrace;

/** @typedef {?} */
var Systrace;
 /** @type {?} */
var SwipeableListView;

/** @typedef {?} */
var SwipeableListView;
 /** @type {?} */
var Switch;

/** @typedef {?} */
var Switch;
 /** @type {?} */
var SwitchIOS;

/** @typedef {?} */
var SwitchIOS;
 /** @type {?} */
var TabBarIOS;

/** @typedef {?} */
var TabBarIOS;
 /** @type {?} */
var Text;

/** @typedef {?} */
var Text;
 /** @type {?} */
var TextInput;

/** @typedef {?} */
var TextInput;
 /** @type {?} */
var ToolbarAndroid;

/** @typedef {?} */
var ToolbarAndroid;
 /** @type {?} */
var TouchableHighlight;

/** @typedef {?} */
var TouchableHighlight;
 /** @type {?} */
var TouchableNativeFeedback;

/** @typedef {?} */
var TouchableNativeFeedback;
 /** @type {?} */
var TouchableOpacity;

/** @typedef {?} */
var TouchableOpacity;
 /** @type {?} */
var TouchableWithoutFeedback;

/** @typedef {?} */
var TouchableWithoutFeedback;
 /** @type {?} */
var View;

/** @typedef {?} */
var View;
 /** @type {?} */
var ViewPagerAndroid;

/** @typedef {?} */
var ViewPagerAndroid;
 /** @type {?} */
var WebView;

/** @typedef {?} */
var WebView;
 /** @type {?} */
var ActionSheetIOS;

/** @typedef {?} */
var ActionSheetIOS;
 /** @type {?} */
var Share;

/** @typedef {?} */
var Share;
 /** @type {?} */
var AdSupportIOS;

/** @typedef {?} */
var AdSupportIOS;
 /** @type {?} */
var Alert;

/** @typedef {?} */
var Alert;
 /** @type {?} */
var AlertAndroid;

/** @typedef {?} */
var AlertAndroid;
 /** @type {?} */
var AlertIOS;

/** @typedef {?} */
var AlertIOS;
 /** @type {?} */
var AppState;

/** @typedef {?} */
var AppState;
 /** @type {?} */
var AppStateIOS;

/** @typedef {?} */
var AppStateIOS;
 /** @type {?} */
var AsyncStorage;

/** @typedef {?} */
var AsyncStorage;
 /** @type {?} */
var BackAndroid;

/** @typedef {?} */
var BackAndroid;
 /** @type {?} */
var BackHandler;

/** @typedef {?} */
var BackHandler;
 /** @type {?} */
var Button;

/** @typedef {?} */
var Button;
 /** @type {?} */
var CameraRoll;

/** @typedef {?} */
var CameraRoll;
 /** @type {?} */
var Clipboard;

/** @typedef {?} */
var Clipboard;
 /** @type {?} */
var DatePickerAndroid;

/** @typedef {?} */
var DatePickerAndroid;
 /** @type {?} */
var Geolocation;

/** @typedef {?} */
var Geolocation;
 /** @type {?} */
var I18nManager;

/** @typedef {?} */
var I18nManager;
 /** @type {?} */
var ImageEditor;

/** @typedef {?} */
var ImageEditor;
 /** @type {?} */
var ImageStore;

/** @typedef {?} */
var ImageStore;
 /** @type {?} */
var InteractionManager;
 /** @type {?} */
var IntentAndroid;

/** @typedef {?} */
var IntentAndroid;
 /** @type {?} */
var Keyboard;
 /** @type {?} */
var KeyboardAvoidingView;

/** @typedef {?} */
var KeyboardAvoidingView;
 /** @type {?} */
var Linking;

/** @typedef {?} */
var Linking;
 /** @type {?} */
var LinkingIOS;

/** @typedef {?} */
var LinkingIOS;
 /** @type {?} */
var NativeMethodsMixin;

/** @typedef {?} */
var NativeMethodsMixin;
 /** @type {?} */
var NativeComponent;

/** @typedef {?} */
var NativeComponent;
 /** @type {?} */
var NetInfo;

/** @typedef {?} */
var NetInfo;
 /** @type {?} */
var PanResponder;

/** @typedef {?} */
var PanResponder;
 /** @type {?} */
var PermissionsAndroid;

/** @typedef {?} */
var PermissionsAndroid;
 /** @type {?} */
var PushNotificationIOS;

/** @typedef {?} */
var PushNotificationIOS;
 /** @type {?} */
var Settings;

/** @typedef {?} */
var Settings;
 /** @type {?} */
var StatusBarIOS;

/** @typedef {?} */
var StatusBarIOS;
 /** @type {?} */
var TimePickerAndroid;

/** @typedef {?} */
var TimePickerAndroid;
 /** @type {?} */
var ToastAndroid;

/** @typedef {?} */
var ToastAndroid;
 /** @type {?} */
var UIManager;

/** @typedef {?} */
var UIManager;
 /** @type {?} */
var VibrationIOS;

/** @typedef {?} */
var VibrationIOS;
 /** @type {?} */
var Vibration;

/** @typedef {?} */
var Vibration;
 /** @type {?} */
var Dimensions;
 /** @type {?} */
var ShadowPropTypesIOS;

/** @typedef {?} */
var NavigationExperimental;
 /** @type {?} */
var NavigationExperimental;

/** @typedef {?} */
var Easing;
 /** @type {?} */
var Easing;
 /** @type {?} */
var DeviceEventEmitter;
/**
 * @extends {EventEmitter}
 * @record
 * @struct
 */
function NativeEventEmitter() {}
 /** @type {?} */
var NativeEventEmitter;
 /** @type {?} */
var NativeAppEventEmitter;
/**
 * @record
 * @struct
 */
function NativeModulesStatic() {}
 /** @type {?} */
var NativeModules;
 /** @type {?} */
var Platform;
 /** @type {?} */
var PixelRatio;
/**
 * @record
 * @struct
 */
function ComponentInterface() {}
 /** @type {string} */
ComponentInterface.prototype.name;
 /** @type {string} */
ComponentInterface.prototype.displayName;
 /** @type {?} */
ComponentInterface.prototype.propTypes;

/**
 * Used to create React components that directly wrap native component
 * implementations.  Config information is extracted from data exported from the
 * UIManager module.  You should also wrap the native component in a
 * hand-written component with full propTypes definitions and other
 * documentation - pass the hand-written component in as `componentInterface` to
 * verify all the native props are documented via `propTypes`.
 * 
 * If some native props shouldn't be exposed in the wrapper interface, you can
 * pass null for `componentInterface` and call `verifyPropTypes` directly
 * with `nativePropsToIgnore`;
 * 
 * Common types are lined up with the appropriate prop differs with
 * `TypeToDifferMap`.  Non-scalar types not in the map default to `deepDiffer`.
 * @template P
 * @param {string} viewName
 * @param {?=} componentInterface
 * @param {?=} extraConfig
 * @return {!React.ComponentClass<?>}
 */
function requireNativeComponent(viewName, componentInterface, extraConfig) {}

/**
 * @param {(number|!React.ComponentClass<?>|!React.Component<?, ?>)} componentOrHandle
 * @return {number}
 */
function findNodeHandle(componentOrHandle) {}

/**
 * @param {?} color
 * @return {number}
 */
function processColor(color) {}

/**
 * @param {?} target
 * @param {...?} sources
 * @return {?}
 */
function __spread(target, sources) {}

/** @typedef {?} */
var ErrorHandlerCallback;
/**
 * @record
 * @struct
 */
function ErrorUtils() {}
 /** @type {?} */
ErrorUtils.prototype.setGlobalHandler;
 /** @type {?} */
ErrorUtils.prototype.getGlobalHandler;
/**
 * @record
 * @struct
 */
function GlobalStatic() {}
 /** @type {!Object} */
GlobalStatic.prototype.originalXMLHttpRequest;
 /** @type {!Object} */
GlobalStatic.prototype.XMLHttpRequest;
 /** @type {number} */
GlobalStatic.prototype.__BUNDLE_START_TIME__;
 /** @type {?} */
GlobalStatic.prototype.ErrorUtils;

/**
 * Accepts a function as its only argument and calls that function before the next repaint.
 * It is an essential building block for animations that underlies all of the JavaScript-based animation APIs.
 * In general, you shouldn't need to call this yourself - the animation API's will manage frame updates for you.
 * @see https://facebook.github.io/react-native/docs/animations.html#requestanimationframe
 * @param {?} fn
 * @return {void}
 */
GlobalStatic.prototype.requestAnimationFrame = function(fn) {};
/** @const */
var addons = {};
/**
 * @record
 * @struct
 */
addons.TestModuleStatic = function() {};
 /** @type {?} */
addons.TestModuleStatic.prototype.verifySnapshot;
 /** @type {?} */
addons.TestModuleStatic.prototype.markTestPassed;
 /** @type {?} */
addons.TestModuleStatic.prototype.markTestCompleted;
 /** @type {?} */
addons.TestModule;

/** @typedef {?} */
addons.TestModule;
 /** @type {!React.Requireable<?>} */
var ColorPropType;
 /** @type {!React.Requireable<?>} */
var EdgeInsetsPropType;
 /** @type {!React.Requireable<?>} */
var PointPropType;

/**
 * @param {string} name
 * @return {?}
 */
function require(name) {}
 /** @type {boolean} */
var __DEV__;
