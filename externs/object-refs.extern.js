/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/object-refs/index.d.ts:

/* TODO: ExportAssignment in  */

/**
 * @constructor
 * @struct
 * Creates a new references object defining two inversly related
 * attribute descriptors a and b.
 * 
 * @param {!Refs.AttributeDescriptor} a
 * @param {!Refs.AttributeDescriptor} b
 */
function Refs(a, b) {}

/**
 * Binds one side of a bi-directional reference to a target object.
 * @param {?} target
 * @param {(string|!Refs.AttributeDescriptor)} property
 * @return {void}
 */
Refs.prototype.bind = function(target, property) {};

/**
 * @param {?} target
 * @param {(string|!Refs.AttributeDescriptor)} property
 * @return {void}
 */
Refs.prototype.ensureBound = function(target, property) {};

/**
 * @param {?} target
 * @param {!Refs.AttributeDescriptor} property
 * @return {?}
 */
Refs.prototype.ensureRefsCollection = function(target, property) {};

/**
 * @param {?} target
 * @param {(string|!Refs.AttributeDescriptor)} property
 * @param {?} value
 * @return {void}
 */
Refs.prototype.set = function(target, property, value) {};

/**
 * @param {?} target
 * @param {(string|!Refs.AttributeDescriptor)} property
 * @param {?} value
 * @return {void}
 */
Refs.prototype.unset = function(target, property, value) {};
/**
 * @record
 * @struct
 */
Refs.AttributeDescriptor = function() {};
 /** @type {string} */
Refs.AttributeDescriptor.prototype.name;
 /** @type {boolean} */
Refs.AttributeDescriptor.prototype.collection;
 /** @type {boolean} */
Refs.AttributeDescriptor.prototype.enumerable;
/** @const */
Refs.Collection = {};

/**
 * Extends a collection with Refs aware methods
 * @param {!Array<?>} collection
 * @param {!Refs} refs
 * @param {(string|!Refs.AttributeDescriptor)} property
 * @param {?} target
 * @return {?}
 */
Refs.Collection.extend = function(collection, refs, property, target) {};

/**
 * @param {!Array<?>} collection
 * @return {boolean}
 */
Refs.Collection.isExtended = function(collection) {};
