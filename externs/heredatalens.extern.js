/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/heredatalens/index.d.ts:
/** @const */
H.datalens = {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.datalens.Service.Options=} options {H.datalens.Service.Options=} - Overrides the configuration from the H.service.Platform instance
 */
H.datalens.Service = function(options) {};

/**
 * This method makes an HTTP request to the Data Lens REST API.
 * It makes any CRUD request (GET, PUT, POST, DELETE).
 * This method can be used when implementing a custom provider or implementing data management.
 * Otherwise existing providers are used to get data from the Data Lens REST API.
 * @param {string} method {string} - Any HTTP method (GET, PUT, POST, etc.)
 * @param {string} endpoint {string} - The REST API endpoint
 * @param {?=} params {any=} - URL parameters
 * @param {?=} body {any=} - The payload of the request
 * @param {function(?): void=} onResult {function(any)=} - Callback called on a successful request with response data
 * @param {function(?): void=} onError {function(Error)=} - Callback called on an unsuccessful request with the Error object
 * @return {!Promise<?>}
 */
H.datalens.Service.prototype.request = function(method, endpoint, params, body, onResult, onError) {};

/**
 * This method fetches query data for a given query ID.
 * This method can be used when implementing a custom provider.
 * Otherwise existing providers are used to get data from the Data Lens REST API.
 * @param {string} queryId {string} - The ID of the Data Lens REST API query
 * @param {?=} params {any=} - Query dynamic parameters
 * @param {function(?): void=} onResult {function(any)=} - Callback called on a successful request with response data
 * @param {function(?): void=} onError {function(Error)=} - Callback called on an unsuccessful request with the Error object
 * @return {!Promise<?>}
 */
H.datalens.Service.prototype.fetchQueryData = function(queryId, params, onResult, onError) {};

/**
 * This method fetches statistical data for the Data Lens query (eg minimum and maximum values for the query metric).
 * It can be used to define visualization boundaries, scales and legends.
 * @param {string} queryId {string} - The ID of the Data Lens REST API query
 * @param {?} statsQuery {any} - A JSON object which defines a statistics query for the Data Lens query
 * @param {function(?): void=} onResult {function(any)=} - Callback called on a successful request with response data
 * @param {function(?): void=} onError {function(Error)=} - Callback called on an unsuccessful request with the Error object
 * @return {!Promise<?>}
 */
H.datalens.Service.prototype.fetchQueryStats = function(queryId, statsQuery, onResult, onError) {};

/**
 * This method fetches a layer of geometries (eg buildings or administrative boundaries).
 * @param {string} layerName {string} - The name of the layer
 * @param {?=} params {any=} - URL parameters (eg bounding box)
 * @param {function(?): void=} onResult {function(any)=} - Callback called on a successful request with response data
 * @param {function(?): void=} onError {function(Error)=} - Callback called on an unsuccessful request with the Error object
 * @return {!Promise<?>}
 */
H.datalens.Service.prototype.fetchLayer = function(layerName, params, onResult, onError) {};

/**
 * This method fetches vector tile data from the layer.
 * @param {string} layerName {string}
 * @param {number} x {H.datalens.QueryTileProvider.X} - Tile columns
 * @param {number} y {H.datalens.QueryTileProvider.Y} - Tile row
 * @param {number} z {H.datalens.QueryTileProvider.Zoom} - zoom level
 * @param {?=} params {any=} - URL parameters (eg bounding box)
 * @param {function(?): void=} onResult {function(any)=} - Callback called on a successful request with response data
 * @param {function(?): void=} onError {function(Error)=} - Callback called on an unsuccessful request with the Error object
 * @return {!Promise<!Uint8Array>}
 */
H.datalens.Service.prototype.fetchLayerTile = function(layerName, x, y, z, params, onResult, onError) {};

/**
 * Sets the access and refresh tokens used to authenticate all requests against the Data Lens REST API.
 * Use this method to implement custom authentication to the Data Lens REST API.
 * @param {string} accessToken {string} - The token used to authenticate all requests
 * @param {string} refreshToken {string} - The token used to fetch a new access token after the previous access token has expired.
 * When refreshToken is provided, Service will automatically update the expired accessToken.
 * @return {void}
 */
H.datalens.Service.prototype.setTokens = function(accessToken, refreshToken) {};

/**
 * This method implements H.service.IConfigurable interface. It is called by the H.service.Platform instance.
 * @param {string} appId {string} - The appId
 * @param {string} appCode {string} - The appCode
 * @param {boolean} useHTTPS {boolean} - A flag to use HTTPS or not
 * @param {boolean} useCIT {boolean} - A flag to use the staging server (CIT) or not
 * @param {!H.service.Url=} baseUrl {H.service.Url=} - The base URL for all requests to the Data Lens REST API
 * @return {!H.datalens.Service}
 */
H.datalens.Service.prototype.configure = function(appId, appCode, useHTTPS, useCIT, baseUrl) {};
/**
 * @record
 * @struct
 */
H.datalens.Service.Options = function() {};
 /** @type {string} */
H.datalens.Service.Options.prototype.subDomain;
 /** @type {string} */
H.datalens.Service.Options.prototype.version;
 /** @type {string} */
H.datalens.Service.Options.prototype.access_token;
 /** @type {string} */
H.datalens.Service.Options.prototype.refresh_token;
 /** @type {!Array<string>} */
H.datalens.Service.Options.prototype.domainSharding;
 /** @type {string} */
H.datalens.Service.Options.prototype.baseUrl;
/**
 * @record
 * @struct
 */
H.datalens.Service.Data = function() {};
 /** @type {!Array<string>} */
H.datalens.Service.Data.prototype.columns;
 /** @type {!Array<?>} */
H.datalens.Service.Data.prototype.rows;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.datalens.Service.Data=} data {H.datalens.Service.Data=} - JSON object
 * @param {!H.map.provider.Provider.Options=} options {H.map.provider.Provider.Options=} - Configures data accessibility parameters
 */
H.datalens.Provider = function(data, options) {};

/**
 * Updates the provider data. When data is updated, the update event is triggered so that the consuming layers are redrawn.
 * @param {!H.datalens.Service.Data} data {H.datalens.Service.Data} - JSON object
 * @return {void}
 */
H.datalens.Provider.prototype.setData = function(data) {};

/**
 * Retrieves the provider data.
 * @return {!H.datalens.Service.Data}
 */
H.datalens.Provider.prototype.getData = function() {};

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.datalens.Service.Data} data
 * @param {!H.datalens.QueryProvider.Options=} options {H.datalens.QueryProvider.Options=} - Configures source query and data accessibility parameters
 */
H.datalens.QueryProvider = function(data, options) {};

/**
 * Updates the query ID to be used in the next call of the Data Lens REST API.
 * Note that new data will be fetched only after the reload method is called.
 * @param {string} queryId {string}
 * @return {void}
 */
H.datalens.QueryProvider.prototype.setQueryId = function(queryId) {};

/**
 * Updates the query's dynamic parameters to be used in the next call of the Data Lens REST API.
 * Note that new data will be fetched only after the reload method is called.
 * This method is normally used when updating your visualization.
 * @param {?} queryParams {any|null} - Query dynamic parameters
 * @return {void}
 */
H.datalens.QueryProvider.prototype.setQueryParams = function(queryParams) {};

/**
 * Fetches new data from the Data Lens REST API.
 * When data is fetched, the update event is triggered so that the consuming layers are redrawn.
 * @return {void}
 */
H.datalens.QueryProvider.prototype.reload = function() {};

/**
 * Updates the provider data.
 * When data is updated, the update event is triggered so that the consuming layers are redrawn.
 * @param {!H.datalens.Service.Data} data {H.datalens.Service.Data} - JSON object
 * @return {void}
 */
H.datalens.QueryProvider.prototype.setData = function(data) {};

/**
 * Retrieves the provider data.
 * @return {!H.datalens.Service.Data}
 */
H.datalens.QueryProvider.prototype.getData = function() {};
/**
 * @record
 * @struct
 */
H.datalens.QueryProvider.Options = function() {};
 /** @type {string} */
H.datalens.QueryProvider.Options.prototype.queryId;
 /** @type {?} */
H.datalens.QueryProvider.Options.prototype.queryParams;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.datalens.Service} service {H.datalens.Service} - Data Lens REST API service
 * @param {!H.datalens.QueryTileProvider.Options} options {H.datalens.QueryTileProvider.Options} - Configures source query and data accessibility parameters
 */
H.datalens.QueryTileProvider = function(service, options) {};

/**
 * Updates the query ID to be used in the next call of the Data Lens REST API.
 * Note that new data will be fetched only after the reload method is called.
 * @param {string} queryId {string}
 * @return {void}
 */
H.datalens.QueryTileProvider.prototype.setQueryId = function(queryId) {};

/**
 * Updates the query's dynamic parameters to be used in the next call of the Data Lens REST API.
 * Note that new data will be fetched only after the reload method is called. This method is normally used when updating your visualization.
 * @param {?} queryParams {any|null}
 * @return {void}
 */
H.datalens.QueryTileProvider.prototype.setQueryParams = function(queryParams) {};

/**
 * Updates the names of the dynamic parameters that defines tiles. This method is only needed when the query ID is updated.
 * Note that new data will be fetched only after the reload method is called.
 * @param {!H.datalens.QueryTileProvider.TileParamNames} tileParamNames {H.datalens.QueryTileProvider.TileParamNames} - Names of the URI parameters that control the x/y/z of a tiled query
 * @return {void}
 */
H.datalens.QueryTileProvider.prototype.setTileParamNames = function(tileParamNames) {};
/**
 * @record
 * @struct
 */
H.datalens.QueryTileProvider.TileParamNames = function() {};
 /** @type {string} */
H.datalens.QueryTileProvider.TileParamNames.prototype.x;
 /** @type {string} */
H.datalens.QueryTileProvider.TileParamNames.prototype.y;
 /** @type {string} */
H.datalens.QueryTileProvider.TileParamNames.prototype.z;
/**
 * @record
 * @struct
 */
H.datalens.QueryTileProvider.Options = function() {};
 /** @type {!H.datalens.QueryTileProvider.TileParamNames} */
H.datalens.QueryTileProvider.Options.prototype.tileParamNames;
 /** @type {string} */
H.datalens.QueryTileProvider.Options.prototype.queryId;
 /** @type {string} */
H.datalens.QueryTileProvider.Options.prototype.queryParams;

/** @typedef {number} */
H.datalens.QueryTileProvider.X;

/** @typedef {number} */
H.datalens.QueryTileProvider.Y;

/** @typedef {number} */
H.datalens.QueryTileProvider.Zoom;

/**
 * @constructor
 * @struct
 * Constructor
 */
H.datalens.RasterLayer = function() {};
 /** @type {?} */
H.datalens.RasterLayer.defaultDataToRows;

/**
 * Force re-rendering of the layer.
 * In the case where the callbacks passed to the layer options are not pure functions, you can call this method to force re-rendering.
 * @return {void}
 */
H.datalens.RasterLayer.prototype.redraw = function() {};

/**
 * This is a default implementation of renderTile callback. This method represents each point as a black 1x1 pixel square.
 * @param {!Array<!H.datalens.RasterLayer.TilePoint>} points {Array<H.datalens.RasterLayer.TilePoint>} - Input data points within a tile
 * @param {!HTMLCanvasElement} canvas {HTMLCanvasElement} - The target canvas
 * @return {void}
 */
H.datalens.RasterLayer.defaultRenderTile = function(points, canvas) {};
/**
 * @record
 * @struct
 */
H.datalens.RasterLayer.Options = function() {};

/**
 * @param {!H.datalens.Service.Data} data
 * @param {number} x
 * @param {number} y
 * @param {number} zoom
 * @return {!Array<number>}
 */
H.datalens.RasterLayer.Options.prototype.dataToRows = function(data, x, y, zoom) {};

/**
 * @param {number} row
 * @param {number} x
 * @param {number} y
 * @return {!H.datalens.RasterLayer.TilePoint}
 */
H.datalens.RasterLayer.Options.prototype.rowToTilePoint = function(row, x, y) {};

/**
 * @param {number} zoom
 * @return {number}
 */
H.datalens.RasterLayer.Options.prototype.buffer = function(zoom) {};

/**
 * @param {!Array<!H.datalens.RasterLayer.TilePoint>} points
 * @param {!HTMLCanvasElement} canvas
 * @param {number} zoom
 * @return {void}
 */
H.datalens.RasterLayer.Options.prototype.renderTile = function(points, canvas, zoom) {};
/**
 * @record
 * @struct
 */
H.datalens.RasterLayer.TilePoint = function() {};
 /** @type {number} */
H.datalens.RasterLayer.TilePoint.prototype.x;
 /** @type {number} */
H.datalens.RasterLayer.TilePoint.prototype.y;
 /** @type {number} */
H.datalens.RasterLayer.TilePoint.prototype.data;

/** @typedef {number} */
H.datalens.RasterLayer.X;

/** @typedef {number} */
H.datalens.RasterLayer.Y;

/** @typedef {number} */
H.datalens.RasterLayer.Row;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.datalens.QueryTileProvider} provider {H.datalens.QueryTileProvider} - Source of tiled data
 * @param {!H.datalens.HeatmapLayer.Options} options {H.datalens.HeatmapLayer.Options} - Configuration for data processing and rendering
 */
H.datalens.HeatmapLayer = function(provider, options) {};
 /** @type {function(!H.datalens.Service.Data, number, number, number): !Array<!H.datalens.HeatmapLayer.Row>} */
H.datalens.HeatmapLayer.defaultDataToRows;
 /** @type {H.datalens.HeatmapLayer.InputScale} */
H.datalens.HeatmapLayer.inputScale;
 /** @type {H.datalens.HeatmapLayer.Aggregation} */
H.datalens.HeatmapLayer.aggregation;

/**
 * @param {number} zoom {number} - zoom level
 * @return {!H.datalens.HeatmapLayer.Options}
 */
H.datalens.HeatmapLayer.prototype.getOptionsPerZoom = function(zoom) {};

/**
 * Removes listeners, and references to memory consuming objects, from this layer. Call this method when you no longer need the layer.
 * @return {void}
 */
H.datalens.HeatmapLayer.prototype.dispose = function() {};

/**
 * Force re-rendering of the layer. In the case where the callbacks passed to the layer options are not pure functions, you can call this method to force re-rendering.
 * @return {void}
 */
H.datalens.HeatmapLayer.prototype.redraw = function() {};
/**
 * @record
 * @struct
 */
H.datalens.HeatmapLayer.Options = function() {};
 /** @type {(number|!H.datalens.HeatmapLayer.BandwidthStop|!Array<!H.datalens.HeatmapLayer.BandwidthStop>|function(): void)} */
H.datalens.HeatmapLayer.Options.prototype.bandwidth;
 /** @type {H.datalens.HeatmapLayer.Aggregation} */
H.datalens.HeatmapLayer.Options.prototype.aggregation;
 /** @type {H.datalens.HeatmapLayer.InputScale} */
H.datalens.HeatmapLayer.Options.prototype.inputScale;

/**
 * @param {!H.datalens.Service.Data} data
 * @param {number} x
 * @param {number} y
 * @param {number} zoom
 * @return {!Array<!H.datalens.HeatmapLayer.Row>}
 */
H.datalens.HeatmapLayer.Options.prototype.dataToRows = function(data, x, y, zoom) {};

/**
 * @param {!H.datalens.HeatmapLayer.Row} row
 * @param {number} x
 * @param {number} y
 * @return {!H.datalens.HeatmapLayer.TilePoint}
 */
H.datalens.HeatmapLayer.Options.prototype.rowToTilePoint = function(row, x, y) {};

/**
 * @param {number} zoom
 * @return {!Array<number>}
 */
H.datalens.HeatmapLayer.Options.prototype.valueRange = function(zoom) {};

/**
 * @param {number} zoom
 * @return {!Array<number>}
 */
H.datalens.HeatmapLayer.Options.prototype.countRange = function(zoom) {};

/**
 * @param {number} scale
 * @return {string}
 */
H.datalens.HeatmapLayer.Options.prototype.colorScale = function(scale) {};

/**
 * @param {number} scale
 * @return {number}
 */
H.datalens.HeatmapLayer.Options.prototype.alphaScale = function(scale) {};

/** @typedef {number} */
H.datalens.HeatmapLayer.X;

/** @typedef {number} */
H.datalens.HeatmapLayer.Y;
/**
 * @record
 * @struct
 */
H.datalens.HeatmapLayer.Row = function() {};
 /** @type {number} */
H.datalens.HeatmapLayer.Row.prototype.tx;
 /** @type {number} */
H.datalens.HeatmapLayer.Row.prototype.ty;
 /** @type {number} */
H.datalens.HeatmapLayer.Row.prototype.count;

/** @typedef {number} */
H.datalens.HeatmapLayer.Bandwidth;
/**
 * @record
 * @struct
 */
H.datalens.HeatmapLayer.BandwidthStop = function() {};
 /** @type {number} */
H.datalens.HeatmapLayer.BandwidthStop.prototype.zoom;
 /** @type {number} */
H.datalens.HeatmapLayer.BandwidthStop.prototype.value;
 /** @type {number} */
H.datalens.HeatmapLayer.BandwidthStop.prototype.zoomIncrementFactor;

/** @typedef {function(): void} */
H.datalens.HeatmapLayer.BandwidthCallback;
/**
 * @record
 * @struct
 */
H.datalens.HeatmapLayer.TilePoint = function() {};
 /** @type {number} */
H.datalens.HeatmapLayer.TilePoint.prototype.x;
 /** @type {number} */
H.datalens.HeatmapLayer.TilePoint.prototype.y;
 /** @type {number} */
H.datalens.HeatmapLayer.TilePoint.prototype.value;
 /** @type {number} */
H.datalens.HeatmapLayer.TilePoint.prototype.count;
 /** @type {!H.datalens.HeatmapLayer.Row} */
H.datalens.HeatmapLayer.TilePoint.prototype.data;

/** @const */
H.datalens.HeatmapLayer.Aggregation = {};
/** @const {number} */
H.datalens.HeatmapLayer.Aggregation.SUM;
/** @const {number} */
H.datalens.HeatmapLayer.Aggregation.AVERAGE;

/** @const */
H.datalens.HeatmapLayer.InputScale = {};
/** @const {number} */
H.datalens.HeatmapLayer.InputScale.DB;
/** @const {number} */
H.datalens.HeatmapLayer.InputScale.LINEAR;
/** @const {number} */
H.datalens.HeatmapLayer.InputScale.LOG;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {(!H.datalens.Provider|!H.datalens.QueryProvider|!H.datalens.QueryTileProvider|!H.map.provider.RemoteTileProvider)} provider {H.map.provider.RemoteTileProvider | H.datalens.Provider | H.datalens.QueryProvider | H.datalens.QueryTileProvider} - Data source (tiled or not)
 * @param {!H.datalens.ObjectLayer.Options} options {H.datalens.ObjectLayer.Options} - Defines data processing, clustering and data-driven styling
 */
H.datalens.ObjectLayer = function(provider, options) {};

/**
 * Default value for dataToRows callback option. It represents each row as an object where property names correspond to data column names.
 * \@property data {H.datalens.Service.Data}
 * @param {!H.datalens.Service.Data} data
 * @return {!Array<!H.datalens.ObjectLayer.Row>}
 */
H.datalens.ObjectLayer.defaultDataToRows = function(data) {};

/**
 * A factory method for data-driven icons. The method allows you to build an icon from SVG markup or JsonML object. Provides caching of icons with the same markup.
 * @param {(string|!Array<?>)} svg {string | Array} - SVG presented as markup or JsonML Array
 * @param {!H.map.Icon.Options=} options {H.map.Icon.Options=} - Icon options (eg size and anchor). Note that the default anchor is in the middle.
 * @return {!H.map.Icon}
 */
H.datalens.ObjectLayer.createIcon = function(svg, options) {};

/**
 * Returns cache of icons created with the createIcon method. Can be used to clean the icon cache.
 * @return {!H.util.Cache}
 */
H.datalens.ObjectLayer.getIconCache = function() {};

/**
 * Force re-rendering of the layer. In the case where the callbacks passed to the layer options are not pure functions, you can call this method to force re-rendering.
 * @return {void}
 */
H.datalens.ObjectLayer.prototype.redraw = function() {};

/**
 * Recalculates the style and applies it to the map object based on the new StyleState
 * @param {!H.map.Object} any
 * @param {?} state {H.datalens.ObjectLayer.StyleState} - New state
 * @return {void}
 */
H.datalens.ObjectLayer.prototype.updateObjectStyle = function(any, state) {};
/**
 * @record
 * @struct
 */
H.datalens.ObjectLayer.Options = function() {};
 /** @type {?} */
H.datalens.ObjectLayer.Options.prototype.dataDomains;
 /** @type {!H.datalens.ObjectLayer.Clustering} */
H.datalens.ObjectLayer.Options.prototype.clustering;

/**
 * @param {!H.datalens.Service.Data} data
 * @return {!Array<!H.datalens.ObjectLayer.Row>}
 */
H.datalens.ObjectLayer.Options.prototype.dataToRows = function(data) {};

/**
 * @param {!H.datalens.ObjectLayer.Row} row
 * @param {number} z
 * @return {!H.map.Object}
 */
H.datalens.ObjectLayer.Options.prototype.rowToMapObject = function(row, z) {};

/**
 * @param {!H.datalens.ObjectLayer.Row} row
 * @param {number} z
 * @param {?} styleState
 * @return {!H.datalens.ObjectLayer.ObjectStyleOptions}
 */
H.datalens.ObjectLayer.Options.prototype.rowToStyle = function(row, z, styleState) {};
/**
 * @record
 * @struct
 */
H.datalens.ObjectLayer.Clustering = function() {};

/**
 * @param {!H.datalens.ObjectLayer.Row} row
 * @return {!H.clustering.DataPoint}
 */
H.datalens.ObjectLayer.Clustering.prototype.rowToDataPoint = function(row) {};

/**
 * @param {number} zoom
 * @return {!H.clustering.Provider.ClusteringOptions}
 */
H.datalens.ObjectLayer.Clustering.prototype.options = function(zoom) {};
/**
 * @record
 * @struct
 */
H.datalens.ObjectLayer.Row = function() {};
 /** @type {number} */
H.datalens.ObjectLayer.Row.prototype.lat;
 /** @type {number} */
H.datalens.ObjectLayer.Row.prototype.lng;

/**
 * @return {!H.geo.Point}
 */
H.datalens.ObjectLayer.Row.prototype.getPosition = function() {};

/**
 * @return {boolean}
 */
H.datalens.ObjectLayer.Row.prototype.isCluster = function() {};

/** @typedef {?} */
H.datalens.ObjectLayer.StyleState;
/**
 * @record
 * @struct
 */
H.datalens.ObjectLayer.ObjectStyleOptions = function() {};
 /** @type {!H.map.Icon} */
H.datalens.ObjectLayer.ObjectStyleOptions.prototype.icon;
 /** @type {!H.map.SpatialStyle.Options} */
H.datalens.ObjectLayer.ObjectStyleOptions.prototype.style;
 /** @type {!H.map.ArrowStyle.Options} */
H.datalens.ObjectLayer.ObjectStyleOptions.prototype.arrows;
 /** @type {number} */
H.datalens.ObjectLayer.ObjectStyleOptions.prototype.zIndex;

/** @typedef {?} */
H.datalens.ObjectLayer.DataDomains;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.datalens.RawDataProvider.Options} options {H.datalens.RawDataProvider.Options} - Configures options
 */
H.datalens.RawDataProvider = function(options) {};

/**
 * Updates the data url. Note that new data will be fetched only after the reload method is called.
 * @param {string} dataUrl {string}
 * @return {void}
 */
H.datalens.RawDataProvider.prototype.setDataUrl = function(dataUrl) {};
/**
 * @record
 * @struct
 */
H.datalens.RawDataProvider.Options = function() {};
 /** @type {string} */
H.datalens.RawDataProvider.Options.prototype.dataUrl;

/**
 * @param {?} obj
 * @return {!Array<?>}
 */
H.datalens.RawDataProvider.Options.prototype.dataToFeatures = function(obj) {};

/**
 * @param {!Array<?>} features
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @param {?} tileSize
 * @param {!H.datalens.RawDataProvider.Helpers} helpers
 * @return {!Array<!H.datalens.ObjectLayer.Row>}
 */
H.datalens.RawDataProvider.Options.prototype.featuresToRows = function(features, x, y, z, tileSize, helpers) {};

/** @typedef {?} */
H.datalens.RawDataProvider.Feature;

/** @typedef {?} */
H.datalens.RawDataProvider.TileSize;
/**
 * @record
 * @struct
 */
H.datalens.RawDataProvider.Helpers = function() {};

/**
 * @param {number} latitude
 * @param {number} longitude
 * @param {number} z
 * @param {?} tileSize
 * @return {!Array<?>}
 */
H.datalens.RawDataProvider.Helpers.prototype.latLngToPixel = function(latitude, longitude, z, tileSize) {};

/**
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @param {?} tileSize
 * @return {!Array<?>}
 */
H.datalens.RawDataProvider.Helpers.prototype.pixelToLatLng = function(x, y, z, tileSize) {};

/**
 * @param {?} obj
 * @return {!Array<?>}
 */
H.datalens.RawDataProvider.Helpers.prototype.parseCSV = function(obj) {};

/** @typedef {!Array<?>} */
H.datalens.RawDataProvider.GeoCoordinates;

/** @typedef {number} */
H.datalens.RawDataProvider.Latitude;

/** @typedef {number} */
H.datalens.RawDataProvider.Longitude;

/** @typedef {!Array<?>} */
H.datalens.RawDataProvider.PixelCoordinates;

/** @typedef {number} */
H.datalens.RawDataProvider.PX;

/** @typedef {number} */
H.datalens.RawDataProvider.PY;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.datalens.Provider} dataProvider {H.datalens.Provider} - Source of tiled data (pass in null if data come from feature properties)
 * @param {!H.datalens.SpatialTileProvider} spatialProvider {H.datalens.SpatialTileProvider} - Source of geometry data
 * @param {!H.datalens.SpatialLayer.Options} options {H.datalens.SpatialLayer.Options} - Configuration for data processing and rendering
 */
H.datalens.SpatialLayer = function(dataProvider, spatialProvider, options) {};
 /** @type {?} */
H.datalens.SpatialLayer.DEFAULT_STATE;
 /** @type {?} */
H.datalens.SpatialLayer.Spatial;
 /** @type {?} */
H.datalens.SpatialLayer.defaultDataToRows;

/**
 * Forces re-rendering of the layer. When the callbacks passed to the layer options are not pure functions, you can call this method to force re-rendering.
 * @return {void}
 */
H.datalens.SpatialLayer.prototype.redraw = function() {};

/**
 * This method changes the state of a map object; for example, style on mouse event.
 * @param {!H.map.Object} spatial
 * @param {?} state
 * @return {void}
 */
H.datalens.SpatialLayer.prototype.updateSpatialStyle = function(spatial, state) {};
/**
 * @record
 * @struct
 */
H.datalens.SpatialLayer.Options = function() {};
 /** @type {?} */
H.datalens.SpatialLayer.Options.prototype.transformFeature;

/**
 * @param {!H.datalens.Service.Data} data
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {!Array<?>}
 */
H.datalens.SpatialLayer.Options.prototype.dataToRows = function(data, x, y, z) {};

/**
 * @param {?} row
 * @return {string}
 */
H.datalens.SpatialLayer.Options.prototype.rowToSpatialId = function(row) {};

/**
 * @param {?} feature
 * @return {string}
 */
H.datalens.SpatialLayer.Options.prototype.featureToSpatialId = function(feature) {};

/**
 * @param {?} row
 * @param {number} z
 * @param {?} styleState
 * @return {?}
 */
H.datalens.SpatialLayer.Options.prototype.rowToStyle = function(row, z, styleState) {};

/**
 * @param {number} z
 * @param {?} styleState
 * @return {?}
 */
H.datalens.SpatialLayer.Options.prototype.defaultStyle = function(z, styleState) {};

/** @typedef {?} */
H.datalens.SpatialLayer.StyleState;

/** @typedef {?} */
H.datalens.SpatialLayer.Row;

/** @typedef {?} */
H.datalens.SpatialLayer.Feature;

/** @typedef {?} */
H.datalens.SpatialLayer.transformFeature;

/**
 * @constructor
 * @struct
 * Constructor
 * @param {!H.datalens.Service} service {H.datalens.Service} - Data Lens REST API service
 * @param {!H.datalens.SpatialTileProvider.Options} options {H.datalens.SpatialTileProvider.Options} - Configures layer name
 */
H.datalens.SpatialTileProvider = function(service, options) {};
 /** @type {?} */
H.datalens.SpatialTileProvider.VectorTile;

/**
 * Updates the layer name to be used in the next call of the Data Lens REST API. Note that new data will be fetched only after the reload method is called.
 * @param {string} layerName
 * @return {void}
 */
H.datalens.SpatialTileProvider.prototype.setLayerName = function(layerName) {};

/**
 * Updates the query's dynamic parameters to be used in the next call of the Data Lens REST API. Note that new data will be fetched only after the reload method is called.
 * This method is normally used when updating your visualization.
 * @param {?} queryParams
 * @return {void}
 */
H.datalens.SpatialTileProvider.prototype.setQueryParams = function(queryParams) {};
/**
 * @record
 * @struct
 */
H.datalens.SpatialTileProvider.Options = function() {};
 /** @type {string} */
H.datalens.SpatialTileProvider.Options.prototype.layerName;
 /** @type {?} */
H.datalens.SpatialTileProvider.Options.prototype.queryParams;
