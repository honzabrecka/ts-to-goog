/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/azure/index.d.ts:

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/**
 * @constructor
 * @struct
 * Creates a new TableService object.
 * Uses the AZURE_STORAGE_ACCOUNT and AZURE_STORAGE_ACCESS_KEY environment variables.
 * 
 * Creates a new TableService object.
 * Uses a connectionString to connect
 * 
 * Creates a new TableService object.
 * Uses a storage account and an access key.
 * 
 * @param {string=} connectionString_or_storageAccount
 * @param {string=} storageAccessKey
 * @param {string=} host
 * @param {string=} authenticationProvider
 */
function TableService(connectionString_or_storageAccount, storageAccessKey, host, authenticationProvider) {}
 /** @type {string} */
TableService.incorrectTableNameErr;
 /** @type {string} */
TableService.incorrectCallbackErr;
 /** @type {string} */
TableService.incorrectTableQuery;
 /** @type {string} */
TableService.incorrectPartitionErr;

/**
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.getServiceProperties = function(callback_or_options, callback) {};

/**
 * @param {?} serviceProperties
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.setServiceProperties = function(serviceProperties, callback_or_options, callback) {};

/**
 * @param {string} table
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.getTable = function(table, callback_or_options, callback) {};

/**
 * @param {string} table
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.createTable = function(table, callback_or_options, callback) {};

/**
 * @param {string} table
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.createTableIfNotExists = function(table, callback_or_options, callback) {};

/**
 * @param {string} table
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.deleteTable = function(table, callback_or_options, callback) {};

/**
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.queryTables = function(callback_or_options, callback) {};

/**
 * @param {string} table
 * @param {string} partitionKey
 * @param {string} rowKey
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.queryEntity = function(table, partitionKey, rowKey, callback_or_options, callback) {};

/**
 * @param {!TableQuery} tableQuery
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.queryEntities = function(tableQuery, callback_or_options, callback) {};

/**
 * @param {string} tableName
 * @param {?} entityDescriptor
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.insertEntity = function(tableName, entityDescriptor, callback_or_options, callback) {};

/**
 * @param {string} tableName
 * @param {?} entityDescriptor
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.insertOrReplaceEntity = function(tableName, entityDescriptor, callback_or_options, callback) {};

/**
 * @param {string} tableName
 * @param {?} entityDescriptor
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.updateEntity = function(tableName, entityDescriptor, callback_or_options, callback) {};

/**
 * @param {string} tableName
 * @param {?} entityDescriptor
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.mergeEntity = function(tableName, entityDescriptor, callback_or_options, callback) {};

/**
 * @param {string} tableName
 * @param {?} entityDescriptor
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.insertOrMergeEntity = function(tableName, entityDescriptor, callback_or_options, callback) {};

/**
 * @param {string} tableName
 * @param {?} entityDescriptor
 * @param {?=} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
TableService.prototype.deleteEntity = function(tableName, entityDescriptor, callback_or_options, callback) {};

/**
 * @constructor
 * @struct
 * Creates a new BlobService object.
 * Uses the AZURE_STORAGE_ACCOUNT and AZURE_STORAGE_ACCESS_KEY environment variables.
 * 
 * Creates a new BlobService object.
 * Uses a connectionString to connect
 * 
 * Creates a new BlobService object.
 * Uses a storage account and an access key.
 * 
 * @param {string=} connectionString_or_storageAccount
 * @param {string=} storageAccessKey
 * @param {string=} host
 * @param {string=} sasToken
 */
function BlobService(connectionString_or_storageAccount, storageAccessKey, host, sasToken) {}
 /** @type {number} */
BlobService.prototype.singleBlobPutThresholdInBytes;
 /** @type {number} */
BlobService.prototype.parallelOperationThreadCount;
 /** @type {?} */
BlobService.prototype.SpeedSummary;

/**
 * Gets the properties of a storage account�s Blob service, including Azure Storage Analytics.
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.getServiceProperties = function(callback_or_options, callback) {};

/**
 * Sets the properties of a storage account�s Blob service, including Azure Storage Analytics.
 * You can also use this operation to set the default request version for all incoming requests that do not have a version specified.
 * @param {?} serviceProperties
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.setServiceProperties = function(serviceProperties, callback_or_options, callback) {};

/**
 * Lists a segment containing a collection of container items under the specified account.
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.listContainers = function(callback_or_options, callback) {};

/**
 * Creates a new container under the specified account.
 * If a container with the same name already exists, the operation fails.
 * @param {string} container
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.createContainer = function(container, callback_or_options, callback) {};

/**
 * Creates a new container under the specified account if the container does not exists.
 * @param {string} container
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.createContainerIfNotExists = function(container, callback_or_options, callback) {};

/**
 * Retrieves a container and its properties from a specified account.
 * @param {string} container
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.getContainerProperties = function(container, callback_or_options, callback) {};

/**
 * Returns all user-defined metadata for the container.
 * @param {string} container
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.getContainerMetadata = function(container, callback_or_options, callback) {};

/**
 * Sets the container's metadata.
 * @param {string} container
 * @param {?} metadata
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.setContainerMetadata = function(container, metadata, callback_or_options, callback) {};

/**
 * Gets the container's ACL.
 * @param {string} container
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.getContainerAcl = function(container, callback_or_options, callback) {};

/**
 * Updates the container's ACL.
 * @param {string} container
 * @param {string} publicAccessLevel
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.setContainerAcl = function(container, publicAccessLevel, callback_or_options, callback) {};

/**
 * Marks the specified container for deletion.
 * The container and any blobs contained within it are later deleted during garbage collection.
 * @param {string} container
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.deleteContainer = function(container, callback_or_options, callback) {};

/**
 * Lists all of the blobs in the given container.
 * @param {string} container
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.listBlobs = function(container, callback_or_options, callback) {};

/**
 * Returns all user-defined metadata, standard HTTP properties, and system properties for the blob.
 * It does not return or modify the content of the blob.
 * @param {string} container
 * @param {string} blob
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.getBlobProperties = function(container, blob, callback_or_options, callback) {};

/**
 * Sets user-defined properties for the specified blob or snapshot.
 * It does not return or modify the content of the blob.
 * @param {string} container
 * @param {string} blob
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.setBlobProperties = function(container, blob, callback_or_options, callback) {};

/**
 * Sets user-defined metadata for the specified blob or snapshot as one or more name-value pairs 
 * It does not return or modify the content of the blob.
 * @param {string} container
 * @param {string} blob
 * @param {?} metadata
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.setBlobMetadata = function(container, blob, metadata, callback_or_options, callback) {};

/**
 * Provides a stream to read from a blob.
 * @param {string} container
 * @param {string} blob
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {!internal.Readable}
 */
BlobService.prototype.getBlob = function(container, blob, callback_or_options, callback) {};

/**
 * Downloads a blob into a file.
 * @param {string} container
 * @param {string} blob
 * @param {string} localFileName
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.getBlobToFile = function(container, blob, localFileName, callback_or_options, callback) {};

/**
 * Downloads a blob into a stream.
 * @param {string} container
 * @param {string} blob
 * @param {!internal.Writable} stream
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.getBlobToStream = function(container, blob, stream, callback_or_options, callback) {};

/**
 * Downloads a blob into a text string.
 * @param {string} container
 * @param {string} blob
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.getBlobToText = function(container, blob, callback_or_options, callback) {};

/**
 * Marks the specified blob or snapshot for deletion. The blob is later deleted during garbage collection.
 * If a blob has snapshots, you must delete them when deleting the blob. Using the deleteSnapshots option, you can choose either to delete both the blob and its snapshots, 
 * or to delete only the snapshots but not the blob itself. If the blob has snapshots, you must include the deleteSnapshots option or the blob service will return an error
 * and nothing will be deleted. 
 * If you are deleting a specific snapshot using the snapshotId option, the deleteSnapshots option must NOT be included.
 * @param {string} container
 * @param {string} blob
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.deleteBlob = function(container, blob, callback_or_options, callback) {};

/**
 * Creates a read-only snapshot of a blob.
 * @param {string} container
 * @param {string} blob
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.createBlobSnapshot = function(container, blob, callback_or_options, callback) {};

/**
 * Starts to copy a blob to a destination within the storage account. The Copy Blob operation copies the entire committed blob.
 * @param {string} sourceUri
 * @param {string} targetContainer
 * @param {string} targetBlob
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.copyBlob = function(sourceUri, targetContainer, targetBlob, callback_or_options, callback) {};

/**
 * Creates a read-only snapshot of a blob.
 * @param {string} container
 * @param {string} blob
 * @param {string} copyId
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.abortCopyBlob = function(container, blob, copyId, callback_or_options, callback) {};

/**
 * Retrieves a shared access signature token.
 * @param {string} container
 * @param {string} blob
 * @param {?} sharedAccessPolicy
 * @return {?}
 */
BlobService.prototype.generateSharedAccessSignature = function(container, blob, sharedAccessPolicy) {};

/**
 * Retrieves a blob or container URL.
 * @param {string} container
 * @param {string=} blob
 * @param {?=} sharedAccessPolicy
 * @return {string}
 */
BlobService.prototype.getBlobUrl = function(container, blob, sharedAccessPolicy) {};

/**
 * Uploads a blob.
 * @param {string} container
 * @param {string} blob
 * @param {string} blobType
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {!internal.Writable}
 */
BlobService.prototype.createBlob = function(container, blob, blobType, callback_or_options, callback) {};

/**
 * Creates a page blob of the specified length.
 * @param {string} container
 * @param {string} blob
 * @param {number} length
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.createPageBlob = function(container, blob, length, callback_or_options, callback) {};

/**
 * Updates a page blob from a stream.
 * @param {string} container
 * @param {string} blob
 * @param {!internal.Readable} readStream
 * @param {number} rangeStart
 * @param {number} rangeEnd
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.createBlobPagesFromStream = function(container, blob, readStream, rangeStart, rangeEnd, callback_or_options, callback) {};

/**
 * Updates a page blob from a text string.
 * @param {string} container
 * @param {string} blob
 * @param {string} text
 * @param {number} rangeStart
 * @param {number} rangeEnd
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.createBlobPagesFromText = function(container, blob, text, rangeStart, rangeEnd, callback_or_options, callback) {};

/**
 * Lists page ranges.
 * Lists all of the page ranges by default, or only the page ranges over a specific range of bytes if rangeStart and rangeEnd are specified.
 * @param {string} container
 * @param {string} blob
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.listBlobRegions = function(container, blob, callback_or_options, callback) {};

/**
 * Clears a range of pages.
 * @param {string} container
 * @param {string} blob
 * @param {number} rangeStart
 * @param {number} rangeEnd
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.clearBlobPages = function(container, blob, rangeStart, rangeEnd, callback_or_options, callback) {};

/**
 * Resizes a page blob.
 * @param {string} container
 * @param {string} blob
 * @param {number} size
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.resizePageBlob = function(container, blob, size, callback_or_options, callback) {};

/**
 * Sets the page blob's sequence number.
 * @param {string} container
 * @param {string} blob
 * @param {string} sequenceNumberAction
 * @param {string} sequenceNumber
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.setPageBlobSequenceNumber = function(container, blob, sequenceNumberAction, sequenceNumber, callback_or_options, callback) {};

/**
 * Uploads a block blob from file.
 * @param {string} container
 * @param {string} blob
 * @param {string} localFileName
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {!SpeedSummary}
 */
BlobService.prototype.putBlockBlobFromFile = function(container, blob, localFileName, callback_or_options, callback) {};

/**
 * @param {string} container
 * @param {string} blob
 * @param {string} localFileName
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {!SpeedSummary}
 */
BlobService.prototype.createBlockBlobFromFile = function(container, blob, localFileName, callback_or_options, callback) {};

/**
 * Uploads a block blob from a stream.
 * @param {string} container
 * @param {string} blob
 * @param {!internal.Stream} stream
 * @param {number} streamLength
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {!SpeedSummary}
 */
BlobService.prototype.putBlockBlobFromStream = function(container, blob, stream, streamLength, callback_or_options, callback) {};

/**
 * @param {string} container
 * @param {string} blob
 * @param {!internal.Stream} stream
 * @param {number} streamLength
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {!SpeedSummary}
 */
BlobService.prototype.createBlockBlobFromStream = function(container, blob, stream, streamLength, callback_or_options, callback) {};

/**
 * Uploads a block blob from a text string.
 * @param {string} container
 * @param {string} blob
 * @param {string} text
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {!SpeedSummary}
 */
BlobService.prototype.createBlockBlobFromText = function(container, blob, text, callback_or_options, callback) {};

/**
 * Creates a new block to be committed as part of a blob.
 * @param {string} blockId
 * @param {string} container
 * @param {string} blob
 * @param {!internal.Stream} readStream
 * @param {number} streamLength
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.createBlobBlockFromStream = function(blockId, container, blob, readStream, streamLength, callback_or_options, callback) {};

/**
 * Creates a new block to be committed as part of a blob.
 * @param {string} blockId
 * @param {string} container
 * @param {string} blob
 * @param {string} text
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.createBlobBlockFromText = function(blockId, container, blob, text, callback_or_options, callback) {};

/**
 * Writes a blob by specifying the list of block IDs that make up the blob.
 * In order to be written as part of a blob, a block must have been successfully written to the server in a prior
 * createBlock operation.
 * @param {string} container
 * @param {string} blob
 * @param {?} blockList
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.commitBlobBlocks = function(container, blob, blockList, callback_or_options, callback) {};

/**
 * Retrieves the list of blocks that have been uploaded as part of a block blob.
 * @param {string} container
 * @param {string} blob
 * @param {string} blockListType
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.listBlobBlocks = function(container, blob, blockListType, callback_or_options, callback) {};

/**
 * Generate a random block id prefix.
 * @return {string}
 */
BlobService.prototype.generateBlockIdPrefix = function() {};

/**
 * Get a block id according to prefix and block number.
 * @param {string} prefix
 * @param {number} number
 * @return {string}
 */
BlobService.prototype.getBlockId = function(prefix, number) {};

/**
 * Acquires a new lease. 
 * If container and blob are specified, acquires a blob lease. 
 * Otherwise, if only container is specified and blob is null, acquires a container lease.
 * @param {string} container
 * @param {string} blob
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.acquireLease = function(container, blob, callback_or_options, callback) {};

/**
 * Renews an existing lease.
 * If container and blob are specified, renews the blob lease.
 * Otherwise, if only container is specified and blob is null, renews the container lease.
 * @param {string} container
 * @param {string} blob
 * @param {string} leaseId
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.renewLease = function(container, blob, leaseId, callback_or_options, callback) {};

/**
 * Releases the lease.
 * If container and blob are specified, releases the blob lease.
 * Otherwise, if only container is specified and blob is null, releases the container lease.
 * @param {string} container
 * @param {string} blob
 * @param {string} leaseId
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.releaseLease = function(container, blob, leaseId, callback_or_options, callback) {};

/**
 * Breaks the lease but ensures that another client cannot acquire a new lease until the current lease period has expired.
 * If container and blob are specified, breaks the blob lease.
 * Otherwise, if only container is specified and blob is null, breaks the container lease.
 * @param {string} container
 * @param {string} blob
 * @param {string} leaseId
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
BlobService.prototype.breakLease = function(container, blob, leaseId, callback_or_options, callback) {};

/**
 * @constructor
 * @struct
 * Creates a new BlobService object.
 * Uses the AZURE_STORAGE_ACCOUNT and AZURE_STORAGE_ACCESS_KEY environment variables.
 * 
 * Creates a new BlobService object.
 * Uses a connectionString to connect
 * 
 * Creates a new BlobService object.
 * Uses a storage account and an access key.
 * 
 * @param {string=} connectionString_or_storageAccount
 * @param {string=} storageAccessKey
 * @param {string=} host
 * @param {string=} sasToken
 */
function QueueService(connectionString_or_storageAccount, storageAccessKey, host, sasToken) {}
 /** @type {!SharedKey} */
QueueService.prototype.authenticationProvider;

/**
 * Gets the properties of a storage account�s Blob service, including Azure Storage Analytics.
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.getServiceProperties = function(callback_or_options, callback) {};

/**
 * Sets the properties of a storage account�s Blob service, including Azure Storage Analytics.
 * You can also use this operation to set the default request version for all incoming requests that do not have a version specified.
 * @param {?} serviceProperties
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.setServiceProperties = function(serviceProperties, callback_or_options, callback) {};

/**
 * Lists all queues under the given account.
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.listQueues = function(callback_or_options, callback) {};

/**
 * Creates a new queue under the given account.
 * @param {string} queue
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.createQueue = function(queue, callback_or_options, callback) {};

/**
 * Creates a new queue under the given account if it doesn't exist.
 * @param {string} queue
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.createQueueIfNotExists = function(queue, callback_or_options, callback) {};

/**
 * Permanently deletes the specified queue.
 * @param {string} queue
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.deleteQueue = function(queue, callback_or_options, callback) {};

/**
 * Returns queue properties, including user-defined metadata.
 * @param {string} queue
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.getQueueMetadata = function(queue, callback_or_options, callback) {};

/**
 * Sets user-defined metadata on the specified queue. Metadata is associated with the queue as name-value pairs.
 * @param {string} queue
 * @param {?} metadata
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.setQueueMetadata = function(queue, metadata, callback_or_options, callback) {};

/**
 * Adds a new message to the back of the message queue. A visibility timeout can also be specified to make the message
 * invisible until the visibility timeout expires. A message must be in a format that can be included in an XML request
 * with UTF-8 encoding. The encoded message can be up to 64KB in size for versions 2011-08-18 and newer, or 8KB in size
 * for previous versions.
 * @param {string} queue
 * @param {string} messageText
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.createMessage = function(queue, messageText, callback_or_options, callback) {};

/**
 * Retrieves a message from the queue and makes it invisible to other consumers.
 * @param {string} queue
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.getMessages = function(queue, callback_or_options, callback) {};

/**
 * Retrieves a message from the front of the queue, without changing the message visibility.
 * @param {string} queue
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.peekMessages = function(queue, callback_or_options, callback) {};

/**
 * Deletes a specified message from the queue.
 * @param {string} queue
 * @param {string} messageId
 * @param {string} popreceipt
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.deleteMessage = function(queue, messageId, popreceipt, callback_or_options, callback) {};

/**
 * Clears all messages from the queue.
 * @param {string} queue
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.clearMessages = function(queue, callback_or_options, callback) {};

/**
 * Deletes a specified message from the queue.
 * @param {string} queue
 * @param {string} messageId
 * @param {string} popreceipt
 * @param {number} visibilitytimeout
 * @param {?} callback_or_options
 * @param {?=} callback
 * @return {void}
 */
QueueService.prototype.updateMessage = function(queue, messageId, popreceipt, visibilitytimeout, callback_or_options, callback) {};
/**
 * @constructor
 * @struct
 */
function ServiceBusService() {}
/**
 * @constructor
 * @struct
 */
function SqlService() {}
/**
 * @constructor
 * @struct
 */
function ServiceManagementService() {}
/**
 * @constructor
 * @struct
 */
function SqlManagementService() {}

/**
 * @param {string=} connectionString_or_storageAccount
 * @param {string=} storageAccessKey
 * @param {string=} host
 * @param {string=} authenticationProvider
 * @return {!TableService}
 */
function createTableService(connectionString_or_storageAccount, storageAccessKey, host, authenticationProvider) {}

/**
 * @param {string=} connectionString_or_storageAccount
 * @param {string=} storageAccessKey
 * @param {string=} host
 * @param {string=} authenticationProvider
 * @return {!BlobService}
 */
function createBlobService(connectionString_or_storageAccount, storageAccessKey, host, authenticationProvider) {}

/**
 * @param {string=} connectionString_or_storageAccount
 * @param {string=} storageAccessKey
 * @param {string=} host
 * @param {string=} authenticationProvider
 * @return {!QueueService}
 */
function createQueueService(connectionString_or_storageAccount, storageAccessKey, host, authenticationProvider) {}

/**
 * @param {string=} connectionString_or_namespace
 * @param {string=} accessKey
 * @param {string=} issuer
 * @param {string=} acsNamespace
 * @param {string=} host
 * @param {string=} authenticationProvider
 * @return {!ServiceBusService}
 */
function createServiceBusService(connectionString_or_namespace, accessKey, issuer, acsNamespace, host, authenticationProvider) {}

/**
 * @param {string} serverName
 * @param {string} administratorLogin
 * @param {string} administratorLoginPassword
 * @param {string=} host
 * @param {string=} acsHost
 * @param {string=} authenticationProvider
 * @return {!SqlService}
 */
function createSqlService(serverName, administratorLogin, administratorLoginPassword, host, acsHost, authenticationProvider) {}

/**
 * @param {string} subscriptionId
 * @param {string} authentication
 * @param {string} hostOptions
 * @return {!ServiceManagementService}
 */
function createServiceManagementService(subscriptionId, authentication, hostOptions) {}

/**
 * @param {string} subscriptionId
 * @param {string} authentication
 * @param {string} hostOptions
 * @return {!SqlManagementService}
 */
function createSqlManagementService(subscriptionId, authentication, hostOptions) {}
/**
 * @record
 * @struct
 */
function RoleEnvironmentInterface() {}
 /** @type {string} */
RoleEnvironmentInterface.prototype.incorrectCallbackErr;
 /** @type {string} */
RoleEnvironmentInterface.prototype.clientId;
 /** @type {string} */
RoleEnvironmentInterface.prototype.VersionEndpointFixedPath;
 /** @type {?} */
RoleEnvironmentInterface.prototype.EnvironmentVariables;

/**
 * Returns a RoleInstance object that represents the role instance
 * in which this code is currently executing.
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.getCurrentRoleInstance = function(callback) {};

/**
 * Returns the deployment ID that uniquely identifies the deployment in
 * which this role instance is running.
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.getDeploymentId = function(callback) {};

/**
 * Indicates whether the role instance is running in the Microsoft Azure
 * environment.  It is good practice to enclose any code that uses 
 * service runtime in the isAvailable callback.
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.isAvailable = function(callback) {};

/**
 * Indicates whether the role instance is running in the development fabric.
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.isEmulated = function(callback) {};

/**
 * Returns the set of Role objects defined for your service.
 * Roles are defined in the service definition file.
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.getRoles = function(callback) {};

/**
 * Retrieves the settings in the service configuration file.
 * 
 * A role's configuration settings are defined in the service definition file.
 * Values for configuration settings are set in the service configuration file.
 * For more information on configuration settings, see the [Service Definition Schema](http://msdn.microsoft.com/en-us/library/windowsazure/ee758711.aspx)
 * and [Service Configuration Schema](http://msdn.microsoft.com/en-us/library/windowsazure/ee758710.aspx).
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.getConfigurationSettings = function(callback) {};

/**
 * Retrieves the set of named local storage resources, along with the path.
 * For example, the DiagnosticStore resource which is defined for every role
 * provides a location for runtime diagnostics and logs.
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.getLocalResources = function(callback) {};

/**
 * Requests that the current role instance be stopped and restarted.
 * 
 * Before the role instance is recycled, the Microsoft Azure load balancer takes the role instance out of rotation.
 * This ensures that no new requests are routed to the instance while it is restarting.
 * 
 * A call to `RequestRecycle` initiates the normal shutdown cycle. Microsoft Azure raises the
 * `Stopping` event and calls the `OnStop` method so that you can run the necessary code to
 * prepare the instance to be recycled.
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.requestRecycle = function(callback) {};

/**
 * Sets the status of the role instance.
 * 
 * An instance may indicate that it is in one of two states: Ready or Busy. If an instance's state is Ready, it is
 * prepared to receive requests from the load balancer. If the instance's state is Busy, it will not receive
 * requests from the load balancer.
 * @param {string} roleInstanceStatus
 * @param {!Date} expirationUtc
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.setStatus = function(roleInstanceStatus, expirationUtc, callback) {};

/**
 * Clears the status of the role instance.
 * An instance may indicate that it has completed communicating status by calling this method.
 * @param {?} callback
 * @return {void}
 */
RoleEnvironmentInterface.prototype.clearStatus = function(callback) {};
 /** @type {?} */
var RoleEnvironment;

/**
 * @constructor
 * @struct
 */
function WebResource() {}
 /** @type {boolean} */
WebResource.prototype.rawResponse;
 /** @type {?} */
WebResource.prototype.queryString;

/**
 * @param {string} path
 * @return {!WebResource}
 */
WebResource.prototype.get = function(path) {};

/**
 * @param {string} path
 * @return {!WebResource}
 */
WebResource.prototype.put = function(path) {};

/**
 * @param {string} path
 * @return {!WebResource}
 */
WebResource.prototype.post = function(path) {};

/**
 * @param {string} path
 * @return {!WebResource}
 */
WebResource.prototype.merge = function(path) {};

/**
 * @param {string} path
 * @return {!WebResource}
 */
WebResource.prototype.head = function(path) {};

/**
 * @param {string} path
 * @return {!WebResource}
 */
WebResource.prototype.del = function(path) {};

/**
 * @param {string} name
 * @param {string} value
 * @return {!WebResource}
 */
WebResource.prototype.withProperty = function(name, value) {};

/**
 * @param {boolean} rawResponse
 * @return {!WebResource}
 */
WebResource.prototype.withRawResponse = function(rawResponse) {};

/**
 * @param {boolean} headersOnly
 * @return {!WebResource}
 */
WebResource.prototype.withHeadersOnly = function(headersOnly) {};

/**
 * @param {string} name
 * @param {string} value
 * @param {string} defaultValue
 * @return {!WebResource}
 */
WebResource.prototype.withQueryOption = function(name, value, defaultValue) {};

/**
 * @param {?} queryOptions
 * @return {!WebResource}
 */
WebResource.prototype.withQueryOptions = function(queryOptions) {};

/**
 * @param {string} name
 * @param {string} value
 * @return {!WebResource}
 */
WebResource.prototype.withHeader = function(name, value) {};

/**
 * @param {?} headers
 * @return {!WebResource}
 */
WebResource.prototype.withHeaders = function(headers) {};

/**
 * @param {?} body
 * @return {!WebResource}
 */
WebResource.prototype.withBody = function(body) {};

/**
 * @param {?} metadata
 * @return {!WebResource}
 */
WebResource.prototype.addOptionalMetadataHeaders = function(metadata) {};

/**
 * @param {number} statusCode
 * @return {boolean}
 */
WebResource.prototype.validResponse = function(statusCode) {};

/**
 * @param {!internal.Stream} inputStream
 * @param {!internal.Stream} destStream
 * @return {!internal.Stream}
 */
WebResource.prototype.pipeInput = function(inputStream, destStream) {};

/**
 * @constructor
 * @struct
 * @param {string} host
 * @param {?} authenticationProvider
 */
function ServiceClient(host, authenticationProvider) {}
 /** @type {?} */
ServiceClient.EnvironmentVariables;
 /** @type {string} */
ServiceClient.DEVSTORE_STORAGE_ACCOUNT;
 /** @type {string} */
ServiceClient.DEVSTORE_STORAGE_ACCESS_KEY;
 /** @type {string} */
ServiceClient.DEVSTORE_BLOB_HOST;
 /** @type {string} */
ServiceClient.DEVSTORE_QUEUE_HOST;
 /** @type {string} */
ServiceClient.DEVSTORE_TABLE_HOST;
 /** @type {string} */
ServiceClient.CLOUD_BLOB_HOST;
 /** @type {string} */
ServiceClient.CLOUD_QUEUE_HOST;
 /** @type {string} */
ServiceClient.CLOUD_TABLE_HOST;
 /** @type {string} */
ServiceClient.CLOUD_SERVICEBUS_HOST;
 /** @type {string} */
ServiceClient.CLOUD_ACCESS_CONTROL_HOST;
 /** @type {string} */
ServiceClient.CLOUD_SERVICE_MANAGEMENT_HOST;
 /** @type {string} */
ServiceClient.CLOUD_DATABASE_HOST;
 /** @type {string} */
ServiceClient.DEFAULT_SERVICEBUS_ISSUER;
 /** @type {string} */
ServiceClient.DEFAULT_WRAP_NAMESPACE_SUFFIX;
 /** @type {string} */
ServiceClient.DEFAULT_PROTOCOL;

/**
 * @param {string} host
 * @return {void}
 */
ServiceClient.prototype.setHost = function(host) {};

/**
 * @param {!WebResource} webResource
 * @param {string} outputData
 * @param {?} options
 * @param {!Function} callback
 * @return {void}
 */
ServiceClient.prototype.performRequest = function(webResource, outputData, options, callback) {};

/**
 * @param {!WebResource} webResource
 * @param {?} outputStream
 * @param {?} options
 * @param {!Function} callback
 * @return {void}
 */
ServiceClient.prototype.performRequestOutputStream = function(webResource, outputStream, options, callback) {};

/**
 * @param {!WebResource} webResource
 * @param {string} outputData
 * @param {?} inputStream
 * @param {?} options
 * @param {!Function} callback
 * @return {void}
 */
ServiceClient.prototype.performRequestInputStream = function(webResource, outputData, inputStream, options, callback) {};

/**
 * @param {?} newFilter
 * @return {!ServiceClient}
 */
ServiceClient.prototype.withFilter = function(newFilter) {};

/**
 * @param {?} headers
 * @return {?}
 */
ServiceClient.prototype.parseMetadataHeaders = function(headers) {};

/**
 * @return {boolean}
 */
ServiceClient.prototype.isEmulated = function() {};

/**
 * @param {string} proxyUrl
 * @param {number} proxyPort
 * @return {void}
 */
ServiceClient.prototype.setProxy = function(proxyUrl, proxyPort) {};

/**
 * @constructor
 * @struct
 * @param {string} storageAccount
 * @param {string} storageAccessKey
 * @param {string} host
 * @param {boolean} usePathstyleUri
 * @param {?} authenticationProvider
 */
function BatchServiceClient(storageAccount, storageAccessKey, host, usePathstyleUri, authenticationProvider) {}
 /** @type {!Array<?>} */
BatchServiceClient.prototype.operations;

/**
 * @return {void}
 */
BatchServiceClient.prototype.beginBatch = function() {};

/**
 * @return {boolean}
 */
BatchServiceClient.prototype.isInBatch = function() {};

/**
 * @return {void}
 */
BatchServiceClient.prototype.rollback = function() {};

/**
 * @return {boolean}
 */
BatchServiceClient.prototype.hasOperations = function() {};

/**
 * @param {!WebResource} webResource
 * @param {?} outputData
 * @return {void}
 */
BatchServiceClient.prototype.addOperation = function(webResource, outputData) {};

/**
 * @param {function(?, !Array<?>, ?): void|?} callback_or_options
 * @param {function(?, !Array<?>, ?): void=} callback
 * @return {void}
 */
BatchServiceClient.prototype.commitBatch = function(callback_or_options, callback) {};

/**
 * @param {?} responseObject
 * @param {!Array<?>} requestOperations
 * @return {!Array<?>}
 */
BatchServiceClient.prototype.processResponse = function(responseObject, requestOperations) {};

/**
 * @param {!WebResource} webResource
 * @param {string} rawResponse
 * @return {?}
 */
BatchServiceClient.prototype.processOperation = function(webResource, rawResponse) {};
/**
 * @constructor
 * @struct
 */
function ServiceManagementClient() {}
/**
 * @constructor
 * @struct
 */
function TableQuery() {}

/**
 * @param {...string} fields
 * @return {!TableQuery}
 */
TableQuery.select = function(fields) {};

/**
 * @param {string} table
 * @return {!TableQuery}
 */
TableQuery.prototype.from = function(table) {};

/**
 * @param {string} partitionKey
 * @param {string} rowKey
 * @return {!TableQuery}
 */
TableQuery.prototype.whereKeys = function(partitionKey, rowKey) {};

/**
 * @param {string} partitionKey
 * @param {string} rowKey
 * @return {!TableQuery}
 */
TableQuery.prototype.whereNextKeys = function(partitionKey, rowKey) {};

/**
 * @param {string} condition
 * @param {...string} values
 * @return {!TableQuery}
 */
TableQuery.prototype.where = function(condition, values) {};

/**
 * @param {string} condition
 * @param {...string} args
 * @return {!TableQuery}
 */
TableQuery.prototype.and = function(condition, args) {};

/**
 * @param {string} condition
 * @param {...string} args
 * @return {!TableQuery}
 */
TableQuery.prototype.or = function(condition, args) {};

/**
 * @param {number} integer
 * @return {!TableQuery}
 */
TableQuery.prototype.top = function(integer) {};

/**
 * @return {?}
 */
TableQuery.prototype.toQueryObject = function() {};

/**
 * @return {string}
 */
TableQuery.prototype.toPath = function() {};

/**
 * @constructor
 * @struct
 * @param {string=} container
 * @param {string=} blob
 */
function BlobResult(container, blob) {}
 /** @type {string} */
BlobResult.prototype.blob;
 /** @type {string} */
BlobResult.prototype.container;
 /** @type {string} */
BlobResult.prototype.etag;
 /** @type {string} */
BlobResult.prototype.lastModified;
 /** @type {string} */
BlobResult.prototype.contentType;
 /** @type {string} */
BlobResult.prototype.contentEncoding;
 /** @type {string} */
BlobResult.prototype.contentLanguage;
 /** @type {string} */
BlobResult.prototype.contentMD5;
 /** @type {string} */
BlobResult.prototype.cacheControl;
 /** @type {string} */
BlobResult.prototype.contentRange;
 /** @type {string} */
BlobResult.prototype.contentTypeHeader;
 /** @type {string} */
BlobResult.prototype.contentEncodingHeader;
 /** @type {string} */
BlobResult.prototype.contentLanguageHeader;
 /** @type {string} */
BlobResult.prototype.contentMD5Header;
 /** @type {string} */
BlobResult.prototype.cacheControlHeader;
 /** @type {number} */
BlobResult.prototype.contentLength;
 /** @type {number} */
BlobResult.prototype.contentLengthHeader;
 /** @type {string} */
BlobResult.prototype.contentDisposition;
 /** @type {string} */
BlobResult.prototype.contentDispositionHeader;
 /** @type {string} */
BlobResult.prototype.range;
 /** @type {string} */
BlobResult.prototype.rangeHeader;
 /** @type {string} */
BlobResult.prototype.getContentMd5;
 /** @type {string} */
BlobResult.prototype.acceptRanges;
 /** @type {string} */
BlobResult.prototype.blobType;
 /** @type {string} */
BlobResult.prototype.leaseStatus;
 /** @type {string} */
BlobResult.prototype.leaseId;
 /** @type {string} */
BlobResult.prototype.leaseDuration;
 /** @type {string} */
BlobResult.prototype.leaseState;
 /** @type {string} */
BlobResult.prototype.sequenceNumber;
 /** @type {string} */
BlobResult.prototype.copyStatus;
 /** @type {string} */
BlobResult.prototype.copyCompletionTime;
 /** @type {string} */
BlobResult.prototype.copyStatusDescription;
 /** @type {string} */
BlobResult.prototype.copyId;
 /** @type {number} */
BlobResult.prototype.copyProgress;
 /** @type {string} */
BlobResult.prototype.requestId;
 /** @type {?} */
BlobResult.prototype.metadata;

/**
 * @param {?} blobXml
 * @return {!BlobResult}
 */
BlobResult.parse = function(blobXml) {};

/**
 * @param {!WebResource} webResource
 * @param {!BlobResult} blob
 * @return {void}
 */
BlobResult.setHeadersFromBlob = function(webResource, blob) {};

/**
 * @param {?} headers
 * @return {void}
 */
BlobResult.prototype.getPropertiesFromHeaders = function(headers) {};

/**
 * @constructor
 * @struct
 * @param {string=} name
 * @param {string=} publicAccessLevel
 */
function ContainerResult(name, publicAccessLevel) {}
 /** @type {string} */
ContainerResult.prototype.name;
 /** @type {string} */
ContainerResult.prototype.publicAccessLevel;
 /** @type {string} */
ContainerResult.prototype.etag;
 /** @type {string} */
ContainerResult.prototype.lastModified;
 /** @type {string} */
ContainerResult.prototype.leaseStatus;
 /** @type {string} */
ContainerResult.prototype.leaseDuration;
 /** @type {string} */
ContainerResult.prototype.leaseState;
 /** @type {string} */
ContainerResult.prototype.requestId;
 /** @type {?} */
ContainerResult.prototype.metadata;
 /** @type {!Array<?>} */
ContainerResult.prototype.signedIdentifiers;

/**
 * @param {?} containerXml
 * @return {!ContainerResult}
 */
ContainerResult.parse = function(containerXml) {};

/**
 * @param {?} headers
 * @return {void}
 */
ContainerResult.prototype.getPropertiesFromHeaders = function(headers) {};

/**
 * @constructor
 * @struct
 * @param {string=} container
 * @param {string=} blob
 * @param {string=} id
 * @param {string=} time
 */
function LeaseResult(container, blob, id, time) {}
 /** @type {string} */
LeaseResult.prototype.container;
 /** @type {string} */
LeaseResult.prototype.blob;
 /** @type {string} */
LeaseResult.prototype.id;
 /** @type {string} */
LeaseResult.prototype.time;
 /** @type {string} */
LeaseResult.prototype.etag;
 /** @type {string} */
LeaseResult.prototype.lastModified;

/**
 * @param {?} header
 * @return {void}
 */
LeaseResult.prototype.getPropertiesFromHeaders = function(header) {};

/**
 * @constructor
 * @struct
 * @param {string=} name
 * @param {?=} metadata
 */
function QueueResult(name, metadata) {}
 /** @type {string} */
QueueResult.prototype.name;
 /** @type {?} */
QueueResult.prototype.metadata;
 /** @type {number} */
QueueResult.prototype.approximatemessagecount;

/**
 * @param {?} messageXml
 * @return {!QueueResult}
 */
QueueResult.parse = function(messageXml) {};

/**
 * @param {?} headers
 * @return {void}
 */
QueueResult.prototype.getPropertiesFromHeaders = function(headers) {};

/**
 * @constructor
 * @struct
 * @param {string=} queue
 * @param {string=} messageid
 * @param {string=} popreceipt
 * @param {?=} metadata
 */
function QueueMessageResult(queue, messageid, popreceipt, metadata) {}
 /** @type {string} */
QueueMessageResult.prototype.queue;
 /** @type {string} */
QueueMessageResult.prototype.insertiontime;
 /** @type {string} */
QueueMessageResult.prototype.expirationtime;
 /** @type {string} */
QueueMessageResult.prototype.timenextvisible;
 /** @type {string} */
QueueMessageResult.prototype.messagetext;
 /** @type {string} */
QueueMessageResult.prototype.dequeuecount;
 /** @type {string} */
QueueMessageResult.prototype.messageid;
 /** @type {string} */
QueueMessageResult.prototype.popreceipt;
 /** @type {?} */
QueueMessageResult.prototype.metadata;

/**
 * @param {string} messageJs
 * @return {string}
 */
QueueMessageResult.serialize = function(messageJs) {};

/**
 * @param {?} messageXml
 * @return {!QueueMessageResult}
 */
QueueMessageResult.parse = function(messageXml) {};

/**
 * @param {?} headers
 * @return {void}
 */
QueueMessageResult.prototype.getPropertiesFromHeaders = function(headers) {};

/**
 * @constructor
 * @struct
 * @param {string} name
 */
function SpeedSummary(name) {}
 /** @type {string} */
SpeedSummary.prototype.name;
 /** @type {number} */
SpeedSummary.prototype.totalSize;
 /** @type {number} */
SpeedSummary.prototype.completeSize;
 /** @type {!Date} */
SpeedSummary.prototype._startTime;
 /** @type {number} */
SpeedSummary.prototype._timeWindowInSeconds;
 /** @type {number} */
SpeedSummary.prototype._timeWindow;
 /** @type {number} */
SpeedSummary.prototype._totalWindowSize;
 /** @type {!Array<number>} */
SpeedSummary.prototype._speedTracks;
 /** @type {number} */
SpeedSummary.prototype._speedTrackPtr;

/**
 * Get running seconds
 * @param {boolean=} humanReadable
 * @return {string|number}
 */
SpeedSummary.prototype.getElapsedSeconds = function(humanReadable) {};

/**
 * Get complete percentage
 * @param {number=} len
 * @return {number}
 */
SpeedSummary.prototype.getCompletePercent = function(len) {};

/**
 * Get average upload/download speed
 * @param {boolean=} humanReadable
 * @return {string|number}
 */
SpeedSummary.prototype.getAverageSpeed = function(humanReadable) {};

/**
 * Get internal speed
 * Get auto increment function
 * @param {boolean|number=} humanReadable_or_size
 * @return {string|number|function(!Error, ?): void}
 */
SpeedSummary.prototype.getSpeed = function(humanReadable_or_size) {};

/**
 * Get total size
 * @param {boolean=} humanReadable
 * @return {string|number}
 */
SpeedSummary.prototype.getTotalSize = function(humanReadable) {};

/**
 * Get completed data size
 * @param {boolean=} humanReadable
 * @return {string|number}
 */
SpeedSummary.prototype.getCompleteSize = function(humanReadable) {};
/** @const */
var Constants = {};
/**
 * @record
 * @struct
 */
function Filter() {}

/**
 * @param {?} requestOptions
 * @param {!Function} next
 * @return {void}
 */
Filter.prototype.handle = function(requestOptions, next) {};

/**
 * @constructor
 * @struct
 * @param {number=} retryCount
 * @param {number=} retryInterval
 */
function LinearRetryPolicyFilter(retryCount, retryInterval) {}
 /** @type {number} */
LinearRetryPolicyFilter.prototype.retryCount;
 /** @type {number} */
LinearRetryPolicyFilter.prototype.retryInterval;

/**
 * @param {?} requestOptions
 * @param {!Function} next
 * @return {void}
 */
LinearRetryPolicyFilter.prototype.handle = function(requestOptions, next) {};

/**
 * @constructor
 * @struct
 * @param {number=} retryCount
 * @param {number=} retryInterval
 * @param {number=} minRetryInterval
 * @param {number=} maxRetryInterval
 */
function ExponentialRetryPolicyFilter(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {}
 /** @type {number} */
ExponentialRetryPolicyFilter.prototype.retryCount;
 /** @type {number} */
ExponentialRetryPolicyFilter.prototype.retryInterval;
 /** @type {number} */
ExponentialRetryPolicyFilter.prototype.minRetryInterval;
 /** @type {number} */
ExponentialRetryPolicyFilter.prototype.maxRetryInterval;

/**
 * @param {?} requestOptions
 * @param {!Function} next
 * @return {void}
 */
ExponentialRetryPolicyFilter.prototype.handle = function(requestOptions, next) {};
/**
 * @constructor
 * @struct
 */
function HmacSha256Sign() {}

/**
 * @constructor
 * @struct
 * @param {string} storageAccount
 * @param {string} storageAccessKey
 * @param {!Array<string>} permissionSet
 */
function SharedAccessSignature(storageAccount, storageAccessKey, permissionSet) {}
 /** @type {string} */
SharedAccessSignature.prototype.storageAccount;
 /** @type {string} */
SharedAccessSignature.prototype.storageAccessKey;
 /** @type {!Array<string>} */
SharedAccessSignature.prototype.permissionSet;
 /** @type {!HmacSha256Sign} */
SharedAccessSignature.prototype.signer;

/**
 * Generates the query string for a shared access signature signing.
 * @param {string} path
 * @param {?} queryString
 * @param {string} resourceType
 * @param {?} sharedAccessPolicy
 * @return {?}
 */
SharedAccessSignature.prototype.generateSignedQueryString = function(path, queryString, resourceType, sharedAccessPolicy) {};

/**
 * Signs a request with the signature header.
 * @param {!WebResource} webResource
 * @param {?} callback
 * @return {void}
 */
SharedAccessSignature.prototype.signRequest = function(webResource, callback) {};

/**
 * Generates the shared access signature for a resource.
 * @param {string} path
 * @param {string} resourceType
 * @param {?} sharedAccessPolicy
 * @return {string}
 */
SharedAccessSignature.prototype._generateSignature = function(path, resourceType, sharedAccessPolicy) {};

/**
 * Generates the query string for a shared access signature signing.
 * @param {string} sharedAccessSignature
 * @param {!WebResource} webResource
 * @param {string} resourceType
 * @param {!Array<string>} requiredPermissions
 * @return {string}
 */
SharedAccessSignature.prototype._permissionMatchesRequest = function(sharedAccessSignature, webResource, resourceType, requiredPermissions) {};

/**
 * @constructor
 * @struct
 * @param {string} storageAccount
 * @param {string} storageAccessKey
 * @param {boolean} usePathStyleUri
 */
function SharedKey(storageAccount, storageAccessKey, usePathStyleUri) {}
 /** @type {string} */
SharedKey.prototype.storageAccount;
 /** @type {string} */
SharedKey.prototype.storageAccessKey;
 /** @type {string} */
SharedKey.prototype.usePathStyleUri;
 /** @type {!HmacSha256Sign} */
SharedKey.prototype.signer;

/**
 * Signs a request with the Authentication header.
 * @param {!WebResource} webResource
 * @param {?} callback
 * @return {void}
 */
SharedKey.prototype.signRequest = function(webResource, callback) {};

/**
 * Retrieves the webresource's canonicalized resource string.
 * @param {!WebResource} webResource
 * @return {string}
 */
SharedKey.prototype._getCanonicalizedResource = function(webResource) {};

/**
 * Constructs the Canonicalized Headers string.
 * 
 * To construct the CanonicalizedHeaders portion of the signature string,
 * follow these steps: 1. Retrieve all headers for the resource that begin
 * with x-ms-, including the x-ms-date header. 2. Convert each HTTP header
 * name to lowercase. 3. Sort the headers lexicographically by header name,
 * in ascending order. Each header may appear only once in the
 * string. 4. Unfold the string by replacing any breaking white space with a
 * single space. 5. Trim any white space around the colon in the header. 6.
 * Finally, append a new line character to each canonicalized header in the
 * resulting list. Construct the CanonicalizedHeaders string by
 * concatenating all headers in this list into a single string.
 * @param {!WebResource} webResource
 * @return {string}
 */
SharedKey.prototype._getCanonicalizedHeaders = function(webResource) {};

/**
 * @constructor
 * @struct
 * @param {string} storageAccount
 * @param {string} storageAccessKey
 * @param {boolean} usePathStyleUri
 */
function SharedKeyLite(storageAccount, storageAccessKey, usePathStyleUri) {}
 /** @type {string} */
SharedKeyLite.prototype.storageAccount;
 /** @type {string} */
SharedKeyLite.prototype.storageAccessKey;
 /** @type {string} */
SharedKeyLite.prototype.usePathStyleUri;
 /** @type {!HmacSha256Sign} */
SharedKeyLite.prototype.signer;

/**
 * Signs a request with the Authentication header.
 * @param {!WebResource} webResource
 * @param {?} callback
 * @return {void}
 */
SharedKeyLite.prototype.signRequest = function(webResource, callback) {};

/**
 * Retrieves the webresource's canonicalized resource string.
 * @param {!WebResource} webResource
 * @return {string}
 */
SharedKeyLite.prototype._getCanonicalizedResource = function(webResource) {};

/**
 * Constructs the Canonicalized Headers string.
 * 
 * To construct the CanonicalizedHeaders portion of the signature string,
 * follow these steps: 1. Retrieve all headers for the resource that begin
 * with x-ms-, including the x-ms-date header. 2. Convert each HTTP header
 * name to lowercase. 3. Sort the headers lexicographically by header name,
 * in ascending order. Each header may appear only once in the
 * string. 4. Unfold the string by replacing any breaking white space with a
 * single space. 5. Trim any white space around the colon in the header. 6.
 * Finally, append a new line character to each canonicalized header in the
 * resulting list. Construct the CanonicalizedHeaders string by
 * concatenating all headers in this list into a single string.
 * @param {!WebResource} webResource
 * @return {string}
 */
SharedKeyLite.prototype._getCanonicalizedHeaders = function(webResource) {};

/**
 * @constructor
 * @struct
 * @param {string} storageAccount
 * @param {string} storageAccessKey
 * @param {boolean} usePathStyleUri
 */
function SharedKeyTable(storageAccount, storageAccessKey, usePathStyleUri) {}
 /** @type {string} */
SharedKeyTable.prototype.storageAccount;
 /** @type {string} */
SharedKeyTable.prototype.storageAccessKey;
 /** @type {string} */
SharedKeyTable.prototype.usePathStyleUri;
 /** @type {!HmacSha256Sign} */
SharedKeyTable.prototype.signer;

/**
 * Signs a request with the Authentication header.
 * @param {!WebResource} webResource
 * @param {?} callback
 * @return {void}
 */
SharedKeyTable.prototype.signRequest = function(webResource, callback) {};

/**
 * Retrieves the webresource's canonicalized resource string.
 * @param {!WebResource} webResource
 * @return {string}
 */
SharedKeyTable.prototype._getCanonicalizedResource = function(webResource) {};

/**
 * @constructor
 * @struct
 * @param {string} storageAccount
 * @param {string} storageAccessKey
 * @param {boolean} usePathStyleUri
 */
function SharedKeyLiteTable(storageAccount, storageAccessKey, usePathStyleUri) {}
 /** @type {string} */
SharedKeyLiteTable.prototype.torageAccount;
 /** @type {string} */
SharedKeyLiteTable.prototype.storageAccessKey;
 /** @type {string} */
SharedKeyLiteTable.prototype.usePathStyleUri;
 /** @type {!HmacSha256Sign} */
SharedKeyLiteTable.prototype.signer;

/**
 * Signs a request with the Authentication header.
 * @param {!WebResource} webResource
 * @param {?} callback
 * @return {void}
 */
SharedKeyLiteTable.prototype.signRequest = function(webResource, callback) {};

/**
 * Retrieves the webresource's canonicalized resource string.
 * @param {!WebResource} webResource
 * @return {string}
 */
SharedKeyLiteTable.prototype._getCanonicalizedResource = function(webResource) {};
/** @const */
var ISO8061Date = {};

/**
 * Formats a date into an iso 8061 string.
 * @param {!Date} date
 * @return {string}
 */
ISO8061Date.format = function(date) {};

/**
 * Parses an ISO 8061 date string into a date object.
 * @param {string} stringDateTime
 * @return {!Date}
 */
ISO8061Date.parse = function(stringDateTime) {};
/**
 * @constructor
 * @struct
 */
function Logger() {}
 /** @type {string} */
Logger.prototype.level;
 /** @type {function(string, string): void} */
Logger.prototype.loggerFunction;
 /** @type {{EMERGENCY: string, ALERT: string, CRITICAL: string, ERROR: string, WARNING: string, NOTICE: string, INFO: string, DEBUG: string}} */
Logger.LogLevels;
 /** @type {!Array<string>} */
Logger.logPriority;

/**
 * @param {string} level
 * @param {string} message
 * @return {void}
 */
Logger.prototype.log = function(level, message) {};

/**
 * @param {string} message
 * @return {void}
 */
Logger.prototype.emergency = function(message) {};

/**
 * @param {string} message
 * @return {void}
 */
Logger.prototype.alert = function(message) {};

/**
 * @param {string} message
 * @return {void}
 */
Logger.prototype.critical = function(message) {};

/**
 * @param {string} message
 * @return {void}
 */
Logger.prototype.error = function(message) {};

/**
 * @param {string} message
 * @return {void}
 */
Logger.prototype.warning = function(message) {};

/**
 * @param {string} message
 * @return {void}
 */
Logger.prototype.notice = function(message) {};

/**
 * @param {string} message
 * @return {void}
 */
Logger.prototype.info = function(message) {};

/**
 * @param {string} message
 * @return {void}
 */
Logger.prototype.debug = function(message) {};

/**
 * @param {string} level
 * @param {string} message
 * @return {void}
 */
Logger.prototype.defaultLoggerFunction = function(level, message) {};

/**
 * @constructor
 * @struct
 * @param {string} connectionString
 */
function ConnectionStringParser(connectionString) {}
 /** @type {string} */
ConnectionStringParser.prototype._value;
 /** @type {number} */
ConnectionStringParser.prototype._pos;
 /** @type {string} */
ConnectionStringParser.prototype._state;

/**
 * @param {?} options
 * @return {?}
 */
ConnectionStringParser.prototype._parse = function(options) {};

/**
 * @return {string}
 */
ConnectionStringParser.prototype._extractKey = function() {};

/**
 * @param {string} quote
 * @return {string}
 */
ConnectionStringParser.prototype._extractString = function(quote) {};

/**
 * @return {string}
 */
ConnectionStringParser.prototype._extractValue = function() {};

/**
 * @return {void}
 */
ConnectionStringParser.prototype._skipWhitespaces = function() {};

/**
 * @param {string} operator
 * @return {void}
 */
ConnectionStringParser.prototype._skipOperator = function(operator) {};

/**
 * @param {string} connectionString
 * @return {?}
 */
ConnectionStringParser.parse = function(connectionString) {};
/** @const */
var ServiceSettings = {};
 /** @type {string} */
ServiceSettings.DEFAULT_PROTOCOL;

/**
 * @constructor
 * @struct
 * @param {string=} message
 * @param {?=} constr
 */
ServiceSettings.NoMatchError = function(message, constr) {};
 /** @type {string} */
ServiceSettings.NoMatchError.prototype.name;
 /** @type {string} */
ServiceSettings.NoMatchError.prototype.message;
 /** @type {?} */
ServiceSettings.NoMatchError.prototype.constr;

/**
 * Throws an exception if the connection string format does not match any of the
 * available formats.
 * @param {string} connectionString
 * @return {void}
 */
ServiceSettings.noMatchConnectionString = function(connectionString) {};

/**
 * Throws an exception if the settings dont match any of the available formats.
 * @param {?} settings
 * @return {void}
 */
ServiceSettings.noMatchSettings = function(settings) {};

/**
 * Parses the connection string and then validate that the parsed keys belong to
 * the validSettingKeys
 * @param {string} connectionString
 * @param {!Array<string>} validKeys
 * @return {!Array<string>}
 */
ServiceSettings.parseAndValidateKeys = function(connectionString, validKeys) {};

/**
 * Creates an anonymous function that acts as predicate to perform a validation.
 * @param {?} requirements
 * @param {boolean} isRequired
 * @param {boolean} atLeastOne
 * @return {?}
 */
ServiceSettings.getValidator = function(requirements, isRequired, atLeastOne) {};

/**
 * Creates a setting value condition that validates it is one of the passed valid values.
 * @param {string} name
 * @return {!Array<string>}
 */
ServiceSettings.setting = function(name) {};

/**
 * Creates an "at least one" predicate for the provided list of requirements.
 * @param {...?} args
 * @return {?}
 */
ServiceSettings.atLeastOne = function(args) {};

/**
 * Creates an optional predicate for the provided list of requirements.
 * @param {...?} args
 * @return {?}
 */
ServiceSettings.optional = function(args) {};

/**
 * Creates an required predicate for the provided list of requirements.
 * @param {...?} args
 * @return {?}
 */
ServiceSettings.allRequired = function(args) {};

/**
 * Creates a setting value condition using the passed predicate.
 * @param {string} name
 * @param {!Function} predicate
 * @return {!Array<?>}
 */
ServiceSettings.settingWithFunc = function(name, predicate) {};

/**
 * Tests to see if a given list of settings matches a set of filters exactly.
 * @param {?} settings
 * @return {boolean}
 */
ServiceSettings.matchedSpecification = function(settings) {};

/**
 * Tests to see if a given list of settings matches a set of filters exactly.
 * @param {string} uri
 * @return {!Url}
 */
ServiceSettings.parseHost = function(uri) {};

/**
 * @constructor
 * @struct
 * @param {string} name
 * @param {string} key
 * @param {string} blobEndpointUri
 * @param {string} queueEndpointUri
 * @param {string} tableEndpointUri
 * @param {boolean} usePathStyleUri
 */
function StorageServiceSettings(name, key, blobEndpointUri, queueEndpointUri, tableEndpointUri, usePathStyleUri) {}
 /** @type {string} */
StorageServiceSettings.prototype._name;
 /** @type {string} */
StorageServiceSettings.prototype._key;
 /** @type {string} */
StorageServiceSettings.prototype._blobEndpointUri;
 /** @type {string} */
StorageServiceSettings.prototype._queueEndpointUri;
 /** @type {string} */
StorageServiceSettings.prototype._tableEndpointUri;
 /** @type {boolean} */
StorageServiceSettings.prototype._usePathStyleUri;

/**
 * Returns a StorageServiceSettings with development storage credentials using
 * the specified proxy Uri.
 * @param {string=} proxy
 * @return {!StorageServiceSettings}
 */
StorageServiceSettings._getDevelopmentStorageAccount = function(proxy) {};

/**
 * Gets a StorageServiceSettings object that references the development storage
 * account.
 * @return {!StorageServiceSettings}
 */
StorageServiceSettings.getDevelopmentStorageAccountSettings = function() {};

/**
 * Gets the default service endpoint using the specified protocol and account
 * name.
 * @param {?} settings
 * @param {string} dns
 * @return {string}
 */
StorageServiceSettings._getDefaultServiceEndpoint = function(settings, dns) {};

/**
 * Creates StorageServiceSettings object given endpoints uri.
 * @param {?} settings
 * @param {string} blobEndpointUri
 * @param {string} queueEndpointUri
 * @param {string} tableEndpointUri
 * @return {!StorageServiceSettings}
 */
StorageServiceSettings._createStorageServiceSettings = function(settings, blobEndpointUri, queueEndpointUri, tableEndpointUri) {};

/**
 * Creates a ServiceBusSettings object from a set of settings.
 * @param {?} settings
 * @return {!StorageServiceSettings}
 */
StorageServiceSettings.createFromSettings = function(settings) {};

/**
 * Creates a StorageServiceSettings object from the given connection string.
 * @param {string} connectionString
 * @return {!StorageServiceSettings}
 */
StorageServiceSettings.createFromConnectionString = function(connectionString) {};

/**
 * @param {string} storageAccount
 * @param {string} storageAccessKey
 * @param {string} host
 * @return {!StorageServiceSettings}
 */
StorageServiceSettings.createExplicitlyOrFromEnvironment = function(storageAccount, storageAccessKey, host) {};

/**
 * @param {string} storageAccount
 * @param {string} storageAccessKey
 * @param {string} parsedHost
 * @return {boolean}
 */
StorageServiceSettings.isDevelopmentStorage = function(storageAccount, storageAccessKey, parsedHost) {};

/**
 * @param {?} config
 * @return {!StorageServiceSettings}
 */
StorageServiceSettings.createFromConfig = function(config) {};

/**
 * @param {?} config
 * @return {void}
 */
StorageServiceSettings.customizeConfig = function(config) {};
/**
 * @constructor
 * @struct
 */
function ServiceBusSettings() {}
/**
 * @constructor
 * @struct
 */
function ServiceManagementSettinsg() {}
/** @const */
var Validate = {};

/**
 * Checks if the given uri is valid or not.
 * @param {string} uri
 * @return {boolean}
 */
Validate.isValidUri = function(uri) {};

/**
 * Validates that a clusterCreationObject is properly formed.
 * @param {?} clusterCreationObject
 * @param {?=} callback
 * @return {void}
 */
Validate.isValidHDInsightCreationObject = function(clusterCreationObject, callback) {};

/**
 * @param {string} uuid
 * @param {?=} callback
 * @return {void}
 */
Validate.isValidUuid = function(uuid, callback) {};

/**
 * Creates a anonymous function that check if a given key is base 64 encoded.
 * @param {string} key
 * @return {boolean}
 */
Validate.isBase64Encoded = function(key) {};

/**
 * Validates a function.
 * @param {?} functionObject
 * @param {string} functionName
 * @return {void}
 */
Validate.isValidFunction = function(functionObject, functionName) {};

/**
 * Validates that a Service Bus namespace name
 * is legally allowable. Does not check availability.
 * @param {string} name
 * @param {?=} callback
 * @return {boolean}
 */
Validate.namespaceNameIsValid = function(name, callback) {};

/**
 * Validates a container name.
 * @param {string} containerName
 * @param {?=} callback
 * @return {boolean}
 */
Validate.containerNameIsValid = function(containerName, callback) {};

/**
 * Validates a blob name.
 * @param {string} containerName
 * @param {string} blob
 * @param {?=} callback
 * @return {boolean}
 */
Validate.blobNameIsValid = function(containerName, blob, callback) {};

/**
 * Validates a table name.
 * @param {string} tableName
 * @param {?=} callback
 * @return {boolean}
 */
Validate.tableNameIsValid = function(tableName, callback) {};

/**
 * Validates a queue name.
 * @param {string} queueName
 * @param {?=} callback
 * @return {boolean}
 */
Validate.queueNameIsValid = function(queueName, callback) {};

/**
 * @param {number} rangeStart
 * @param {number} rangeEnd
 * @param {number} writeBlockSizeInBytes
 * @param {?=} callback
 * @return {boolean}
 */
Validate.pageRangesAreValid = function(rangeStart, rangeEnd, writeBlockSizeInBytes, callback) {};

/**
 * @param {string} functionName
 * @param {!Function} validationRules
 * @return {boolean}
 */
Validate.validateArgs = function(functionName, validationRules) {};
/** @const */
var date = {};

/**
 * Generates a Date object which is in the given days from now.
 * @param {number} days
 * @return {!Date}
 */
date.daysFromNow = function(days) {};

/**
 * Generates a Date object which is in the given hours from now.
 * @param {number} hours
 * @return {!Date}
 */
date.hoursFromNow = function(hours) {};

/**
 * Generates a Date object which is in the given minutes from now.
 * @param {number} minutes
 * @return {!Date}
 */
date.minutesFromNow = function(minutes) {};

/**
 * Generates a Date object which is in the given seconds from now.
 * @param {number} seconds
 * @return {!Date}
 */
date.secondsFromNow = function(seconds) {};
/**
 * @record
 * @struct
 */
function WebResponse() {}
 /** @type {boolean} */
WebResponse.prototype.isSuccessful;
 /** @type {number} */
WebResponse.prototype.statusCode;
 /** @type {?} */
WebResponse.prototype.body;
 /** @type {?} */
WebResponse.prototype.headers;
 /** @type {?} */
WebResponse.prototype.md5;
/**
 * @record
 * @struct
 */
function SimpleCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function ErrorCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function StorageCallbackVoid() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function StorageCallback() {}

/* TODO: CallSignature:  */
/**
 * @extends {StorageCallback}
 * @record
 * @struct
 */
function StorageServiceStatsCallback() {}
/**
 * @extends {StorageCallback}
 * @record
 * @struct
 */
function StorageServicePropertiesCallback() {}
/**
 * @record
 * @struct
 */
function TimeoutIntervalOptions() {}
 /** @type {string} */
TimeoutIntervalOptions.prototype.locationMode;
 /** @type {number} */
TimeoutIntervalOptions.prototype.timeoutIntervalInMs;
 /** @type {number} */
TimeoutIntervalOptions.prototype.maximumExecutionTimeInMs;
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function MetadataOptions() {}
 /** @type {?} */
MetadataOptions.prototype.metadata;
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function StorageAclOptions() {}
 /** @type {string} */
StorageAclOptions.prototype.leaseId;
 /** @type {!Array<?>} */
StorageAclOptions.prototype.signedIdentifiers;
/**
 * @record
 * @struct
 */
function Dictionary() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function StorageServiceProperties() {}
 /** @type {?} */
StorageServiceProperties.prototype.Logging;
 /** @type {?} */
StorageServiceProperties.prototype.Metrics;
 /** @type {string} */
StorageServiceProperties.prototype.DefaultServiceVersion;
/**
 * @record
 * @struct
 */
function StorageServiceStats() {}
 /** @type {?} */
StorageServiceStats.prototype.GeoReplication;
/**
 * @record
 * @struct
 */
function SignedIdentifier() {}
 /** @type {string} */
SignedIdentifier.prototype.Id;
 /** @type {?} */
SignedIdentifier.prototype.AccessPolicy;
/**
 * @record
 * @struct
 */
function StorageMetadata() {}

/* TODO: IndexSignature:  */
/**
 * @record
 * @struct
 */
function ContinuationToken() {}
 /** @type {string} */
ContinuationToken.prototype.nextMarker;
 /** @type {string} */
ContinuationToken.prototype.targetLocation;
/**
 * @record
 * @struct
 */
function SharedAccessPolicy() {}
 /** @type {string} */
SharedAccessPolicy.prototype.Id;
 /** @type {?} */
SharedAccessPolicy.prototype.AccessPolicy;
/**
 * @record
 * @struct
 */
function TableRequestCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function CreateTableIfNotExistsCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function DeleteTableCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function QueryTablesCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function QueryResultContinuation() {}
 /** @type {!TableService} */
QueryResultContinuation.prototype.tableService;
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function QueryTablesOptions() {}
 /** @type {string} */
QueryTablesOptions.prototype.nextTableName;
/**
 * @record
 * @struct
 */
function TableResult() {}
 /** @type {string} */
TableResult.prototype.TableName;
/**
 * @record
 * @struct
 */
function QueryEntityCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function QueryEntitiesCallback() {}

/* TODO: CallSignature:  */
/**
 * @extends {QueryResultContinuation}
 * @record
 * @struct
 */
function QueryEntitiesResultContinuation() {}
 /** @type {!TableQuery} */
QueryEntitiesResultContinuation.prototype.tableQuery;
 /** @type {string} */
QueryEntitiesResultContinuation.prototype.nextPartitionKey;
 /** @type {string} */
QueryEntitiesResultContinuation.prototype.nextRowKey;

/**
 * @param {?=} callback
 * @return {void}
 */
QueryEntitiesResultContinuation.prototype.getNextPage = function(callback) {};

/**
 * @return {boolean}
 */
QueryEntitiesResultContinuation.prototype.hasNextPage = function() {};
/**
 * @record
 * @struct
 */
function ModifyEntityCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function DeleteEntityCallback() {}

/* TODO: CallSignature:  */
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function UpdateEntityOptions() {}
 /** @type {boolean} */
UpdateEntityOptions.prototype.checkEtag;
/**
 * @record
 * @struct
 */
function Entity() {}
 /** @type {string} */
Entity.prototype.PartitionKey;
 /** @type {string} */
Entity.prototype.RowKey;
 /** @type {!Date} */
Entity.prototype.Timestamp;
 /** @type {string} */
Entity.prototype.etag;

/* TODO: IndexSignature:  */
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function LeaseIdOptions() {}
 /** @type {string} */
LeaseIdOptions.prototype.leaseId;
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function AccessConditionsOptions() {}
 /** @type {?} */
AccessConditionsOptions.prototype.accessConditions;
/**
 * @extends {LeaseIdOptions}
 * @record
 * @struct
 */
function LeaseAccessConditionsOptions() {}
 /** @type {?} */
LeaseAccessConditionsOptions.prototype.accessConditions;
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function ListContainersOptions() {}
 /** @type {string} */
ListContainersOptions.prototype.prefix;
 /** @type {number} */
ListContainersOptions.prototype.maxresults;
 /** @type {string} */
ListContainersOptions.prototype.marker;
 /** @type {string} */
ListContainersOptions.prototype.include;
/**
 * @record
 * @struct
 */
function ListContainersCallback() {}

/* TODO: CallSignature:  */
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function CreateContainerOptions() {}
 /** @type {?} */
CreateContainerOptions.prototype.metadata;
 /** @type {string} */
CreateContainerOptions.prototype.publicAccessLevel;
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function GetContainerPropertiesOptions() {}
 /** @type {string} */
GetContainerPropertiesOptions.prototype.leaseId;
/**
 * @extends {GetContainerPropertiesOptions}
 * @record
 * @struct
 */
function GetContainerMetadataOptions() {}
 /** @type {?} */
GetContainerMetadataOptions.prototype.accessConditions;
/**
 * @extends {ListContainersOptions}
 * @record
 * @struct
 */
function ListBlobsOptions() {}
 /** @type {string} */
ListBlobsOptions.prototype.prefix;
 /** @type {string} */
ListBlobsOptions.prototype.delimiter;
/**
 * @record
 * @struct
 */
function ListBlobsCallback() {}

/* TODO: CallSignature:  */
/**
 * @extends {LeaseAccessConditionsOptions}
 * @record
 * @struct
 */
function GetBlobPropertiesOptions() {}
 /** @type {string} */
GetBlobPropertiesOptions.prototype.snapshotId;
/**
 * @extends {LeaseAccessConditionsOptions}
 * @record
 * @struct
 */
function SetBlobPropertiesOptions() {}
 /** @type {string} */
SetBlobPropertiesOptions.prototype.contentType;
 /** @type {string} */
SetBlobPropertiesOptions.prototype.contentEncoding;
 /** @type {string} */
SetBlobPropertiesOptions.prototype.contentLanguage;
 /** @type {string} */
SetBlobPropertiesOptions.prototype.contentMD5;
 /** @type {string} */
SetBlobPropertiesOptions.prototype.cacheControl;
 /** @type {string} */
SetBlobPropertiesOptions.prototype.contentDisposition;
/**
 * @extends {GetBlobPropertiesOptions}
 * @record
 * @struct
 */
function ReadBlobOptions() {}
 /** @type {string} */
ReadBlobOptions.prototype.rangeStart;
 /** @type {string} */
ReadBlobOptions.prototype.rangeEnd;
 /** @type {boolean} */
ReadBlobOptions.prototype.useTransactionalMD5;
 /** @type {boolean} */
ReadBlobOptions.prototype.disableContentMD5Validation;
/**
 * @record
 * @struct
 */
function GetBlobToTextCallback() {}

/* TODO: CallSignature:  */
/**
 * @extends {GetBlobPropertiesOptions}
 * @record
 * @struct
 */
function DeleteBlobOptions() {}
 /** @type {string} */
DeleteBlobOptions.prototype.deleteSnapshots;
/**
 * @extends {GetBlobPropertiesOptions}
 * @record
 * @struct
 */
function BlobSnapshotOptions() {}
 /** @type {?} */
BlobSnapshotOptions.prototype.metadata;
/**
 * @extends {BlobSnapshotOptions}
 * @record
 * @struct
 */
function CopyBlobOptions() {}
 /** @type {string} */
CopyBlobOptions.prototype.sourceLeaseId;
 /** @type {?} */
CopyBlobOptions.prototype.sourceAccessConditions;
/**
 * @extends {SetBlobPropertiesOptions}
 * @record
 * @struct
 */
function UploadBlobOptions() {}
 /** @type {?} */
UploadBlobOptions.prototype.metadata;
 /** @type {!SpeedSummary} */
UploadBlobOptions.prototype.speedSummary;
 /** @type {number} */
UploadBlobOptions.prototype.parallelOperationThreadCount;
 /** @type {boolean} */
UploadBlobOptions.prototype.storeBlobContentMD5;
 /** @type {boolean} */
UploadBlobOptions.prototype.useTransactionalMD5;
/**
 * @extends {LeaseAccessConditionsOptions}
 * @record
 * @struct
 */
function CreatePagesOptions() {}
 /** @type {string} */
CreatePagesOptions.prototype.contentMD5;
 /** @type {boolean} */
CreatePagesOptions.prototype.useTransactionalMD5;
/**
 * @extends {LeaseIdOptions}
 * @record
 * @struct
 */
function PageRangeOptions() {}
 /** @type {string} */
PageRangeOptions.prototype.snapshotId;
 /** @type {number} */
PageRangeOptions.prototype.rangeStart;
 /** @type {number} */
PageRangeOptions.prototype.rangeEnd;
/**
 * @extends {UploadBlobOptions}
 * @record
 * @struct
 */
function UploadBlockBlobOptions() {}
 /** @type {string} */
UploadBlockBlobOptions.prototype.blockIdPrefix;
/**
 * @extends {LeaseAccessConditionsOptions}
 * @record
 * @struct
 */
function CreateBlockOptions() {}
 /** @type {string} */
CreateBlockOptions.prototype.contentMD5;
 /** @type {boolean} */
CreateBlockOptions.prototype.useTransactionalMD5;
/**
 * @extends {AccessConditionsOptions}
 * @record
 * @struct
 */
function LeaseOptions() {}
 /** @type {string} */
LeaseOptions.prototype.leaseDuration;
 /** @type {string} */
LeaseOptions.prototype.proposedLeaseId;
/**
 * @extends {AccessConditionsOptions}
 * @record
 * @struct
 */
function BreakLeaseOptions() {}
 /** @type {number} */
BreakLeaseOptions.prototype.leaseBreakPeriod;
/**
 * @record
 * @struct
 */
function SharedAccessSignatureResult() {}
 /** @type {string} */
SharedAccessSignatureResult.prototype.baseUrl;
 /** @type {string} */
SharedAccessSignatureResult.prototype.path;
 /** @type {?} */
SharedAccessSignatureResult.prototype.queryString;
 /** @type {?} */
SharedAccessSignatureResult.prototype.url;
/**
 * @record
 * @struct
 */
function BlobHeaders() {}
 /** @type {string} */
BlobHeaders.prototype.cacheControl;
 /** @type {string} */
BlobHeaders.prototype.contentType;
 /** @type {string} */
BlobHeaders.prototype.contentEncoding;
 /** @type {string} */
BlobHeaders.prototype.contentLanguage;
 /** @type {string} */
BlobHeaders.prototype.contentDisposition;
/**
 * @record
 * @struct
 */
function PageRange() {}
 /** @type {number} */
PageRange.prototype.start;
 /** @type {number} */
PageRange.prototype.end;
/**
 * @record
 * @struct
 */
function BlockList() {}
 /** @type {!Array<string>} */
BlockList.prototype.LatestBlocks;
 /** @type {!Array<string>} */
BlockList.prototype.CommittedBlocks;
 /** @type {!Array<string>} */
BlockList.prototype.UncommittedBlocks;
/**
 * @record
 * @struct
 */
function StorageAccessCondition() {}

/* TODO: PropertySignature: "If-Modified-Since" */

/* TODO: PropertySignature: "If-Unmodified-Since" */

/* TODO: PropertySignature: "If-Match" */

/* TODO: PropertySignature: "If-None-Match" */
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function ListQueuesOptions() {}
 /** @type {string} */
ListQueuesOptions.prototype.prefix;
 /** @type {number} */
ListQueuesOptions.prototype.maxresults;
 /** @type {string} */
ListQueuesOptions.prototype.marker;
 /** @type {string} */
ListQueuesOptions.prototype.include;
/**
 * @record
 * @struct
 */
function ListQueuesCallback() {}

/* TODO: CallSignature:  */
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function CreateQueueMessageOptions() {}
 /** @type {number} */
CreateQueueMessageOptions.prototype.messagettl;
 /** @type {number} */
CreateQueueMessageOptions.prototype.visibilitytimeout;
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function PeekQueueMessagesOptions() {}
 /** @type {number} */
PeekQueueMessagesOptions.prototype.numofmessages;
/**
 * @extends {PeekQueueMessagesOptions}
 * @record
 * @struct
 */
function GetQueueMessagesOptions() {}
 /** @type {boolean} */
GetQueueMessagesOptions.prototype.peekonly;
 /** @type {number} */
GetQueueMessagesOptions.prototype.visibilitytimeout;
/**
 * @extends {TimeoutIntervalOptions}
 * @record
 * @struct
 */
function UpdateQueueMessagesOptions() {}
 /** @type {string} */
UpdateQueueMessagesOptions.prototype.messagetext;
/**
 * @record
 * @struct
 */
function Role() {}
 /** @type {string} */
Role.prototype.name;
 /** @type {?} */
Role.prototype.instances;
/**
 * @record
 * @struct
 */
function RoleInstance() {}
 /** @type {string} */
RoleInstance.prototype.id;
 /** @type {string} */
RoleInstance.prototype.faultDomain;
 /** @type {string} */
RoleInstance.prototype.updateDomain;
 /** @type {?} */
RoleInstance.prototype.endpoints;
/**
 * @record
 * @struct
 */
function RoleInstanceEndpoint() {}
 /** @type {string} */
RoleInstanceEndpoint.prototype.protocol;
 /** @type {string} */
RoleInstanceEndpoint.prototype.address;
 /** @type {number} */
RoleInstanceEndpoint.prototype.port;
/**
 * @record
 * @struct
 */
function RoleLocalResource() {}
 /** @type {string} */
RoleLocalResource.prototype.name;
 /** @type {string} */
RoleLocalResource.prototype.path;
 /** @type {number} */
RoleLocalResource.prototype.maximumSizeInMegabytes;
/**
 * @record
 * @struct
 */
function ConnectionStringParseOptions() {}
 /** @type {boolean} */
ConnectionStringParseOptions.prototype.skipLowerCase;
/**
 * @record
 * @struct
 */
function ClusterCreationOptions() {}
 /** @type {string} */
ClusterCreationOptions.prototype.name;
 /** @type {string} */
ClusterCreationOptions.prototype.location;
 /** @type {string} */
ClusterCreationOptions.prototype.defaultStorageAccountName;
 /** @type {string} */
ClusterCreationOptions.prototype.defaultStorageAccountKey;
 /** @type {string} */
ClusterCreationOptions.prototype.defaultStorageContainer;
 /** @type {string} */
ClusterCreationOptions.prototype.user;
 /** @type {string} */
ClusterCreationOptions.prototype.password;
 /** @type {number} */
ClusterCreationOptions.prototype.nodes;
 /** @type {!Array<?>} */
ClusterCreationOptions.prototype.additionalStorageAccounts;
 /** @type {?} */
ClusterCreationOptions.prototype.oozieMetastore;
 /** @type {?} */
ClusterCreationOptions.prototype.hiveMetastore;
/**
 * @record
 * @struct
 */
function Requirement() {}
 /** @type {string} */
Requirement.prototype.SettingName;
 /** @type {!Function} */
Requirement.prototype.SettingPredicate;
/**
 * @record
 * @struct
 */
function ValidatorFunction() {}

/* TODO: CallSignature:  */

/**
 * @constructor
 * @struct
 * @param {string} storageAccount
 * @param {string} storageAccessKey
 * @param {string} host
 * @param {boolean} usePathStyleUri
 * @param {?} authenticationProvider
 */
function StorageServiceClient(storageAccount, storageAccessKey, host, usePathStyleUri, authenticationProvider) {}
 /** @type {string} */
StorageServiceClient.incorrectStorageAccountErr;
 /** @type {string} */
StorageServiceClient.incorrectStorageAccessKeyErr;
 /** @type {string} */
StorageServiceClient.prototype.apiVersion;
 /** @type {string} */
StorageServiceClient.prototype.usePathStyleUri;

/**
 * @param {string=} connectionString_or_storageAccount
 * @param {string=} storageAccessKey
 * @param {string=} host
 * @return {!StorageServiceSettings}
 */
StorageServiceClient.getStorageSettings = function(connectionString_or_storageAccount, storageAccessKey, host) {};

/**
 * @return {boolean}
 */
function isEmulated() {}
