/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/ssh2/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ImportEqualsDeclaration in  */

/* TODO: ExportDeclaration in  */
/**
 * @record
 * @struct
 */
function Channel() {}
 /** @type {boolean} */
Channel.prototype.allowHalfOpen;
 /** @type {?} */
Channel.prototype.stdin;
 /** @type {?} */
Channel.prototype.stdout;
 /** @type {(!internal.Readable|!internal.Writable)} */
Channel.prototype.stderr;
 /** @type {boolean} */
Channel.prototype.server;
 /** @type {string} */
Channel.prototype.type;
 /** @type {string} */
Channel.prototype.subtype;

/**
 * Sends EOF to the remote side.
 * 
 * Returns false if you should wait for the continue event before sending any more traffic.
 * @return {boolean}
 */
Channel.prototype.eof = function() {};

/**
 * Closes the channel on both sides.
 * 
 * Returns false if you should wait for the continue event before sending any more traffic.
 * @return {boolean}
 */
Channel.prototype.close = function() {};

/**
 * Shuts down the channel on this side.
 * @return {void}
 */
Channel.prototype.destroy = function() {};
/**
 * @extends {Channel}
 * @record
 * @struct
 */
function ClientChannel() {}
 /** @type {!internal.Readable} */
ClientChannel.prototype.stderr;
 /** @type {boolean} */
ClientChannel.prototype.server;

/**
 * Lets the server know that the local terminal window has been resized.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number} rows
 * @param {number} cols
 * @param {number} height
 * @param {number} width
 * @return {boolean}
 */
ClientChannel.prototype.setWindow = function(rows, cols, height, width) {};

/**
 * Sends a POSIX signal to the current process on the server. Valid signal names are:
 * 'ABRT', 'ALRM', 'FPE', 'HUP', 'ILL', 'INT', 'KILL', 'PIPE', 'QUIT', 'SEGV', 'TERM',
 * 'USR1', and 'USR2'.
 * 
 * Some server implementations may ignore this request if they do not support signals.
 * 
 * Note: If you are trying to send SIGINT and you find `signal()` doesn't work, try writing
 * `'\x03'` to the Channel stream instead.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} signalName
 * @return {boolean}
 */
ClientChannel.prototype.signal = function(signalName) {};

/**
 * Emitted once the channel is completely closed on both the client and the server.
 * An `exit` event *may* (the SSH2 spec says it is optional) be emitted when the process
 * finishes. If the process finished normally, the process's return value is passed to
 * the `exit` callback.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
ClientChannel.prototype.on = function(event, listener) {};
/**
 * @extends {Channel}
 * @record
 * @struct
 */
function ServerChannel() {}
 /** @type {!internal.Writable} */
ServerChannel.prototype.stderr;
 /** @type {boolean} */
ServerChannel.prototype.server;

/**
 * Sends an exit status code to the client.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * Sends an exit signal to the client.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {number|string} exitCode_or_name
 * @param {boolean=} coreDumped
 * @param {string=} msg
 * @return {boolean}
 */
ServerChannel.prototype.exit = function(exitCode_or_name, coreDumped, msg) {};

/**
 * Emitted once the channel is completely closed on both the client and the server.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
ServerChannel.prototype.on = function(event, listener) {};

/**
 * @constructor
 * @struct
 * Creates and returns a new Client instance.
 */
function Client() {}

/**
 * Emitted when a notice was sent by the server upon connection.
 * Emitted when authentication was successful.
 * Emitted when an incoming forwarded TCP connection is being requested.
 * 
 * Calling `accept()` accepts the connection and returns a `Channel` object.
 * Calling `reject()` rejects the connection and no further action is needed.
 * Emitted when an incoming X11 connection is being requested.
 * 
 * Calling `accept()` accepts the connection and returns a `Channel` object.
 * Calling `reject()` rejects the connection and no further action is needed.
 * Emitted when the server is asking for replies to the given `prompts` for keyboard-
 * interactive user authentication.
 * 
 * * `name` is generally what you'd use as a window title (for GUI apps).
 * * `prompts` is an array of `Prompt` objects.
 * 
 * The answers for all prompts must be provided as an array of strings and passed to
 * `finish` when you are ready to continue.
 * 
 * NOTE: It's possible for the server to come back and ask more questions.
 * Emitted when the server has requested that the user's password be changed, if using
 * password-based user authentication.
 * 
 * Call `done` with the new password.
 * Emitted when more requests/data can be sent to the server (after a `Client` method
 * returned `false`).
 * Emitted when an error occurred.
 * Emitted when the socket was disconnected.
 * Emitted when the socket was closed.
 * Emitted when the socket has timed out.
 * Emitted when the socket has connected.
 * Emitted when the server responds with a greeting message.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
Client.prototype.on = function(event, listener) {};

/**
 * Attempts a connection to a server.
 * @param {?} config
 * @return {void}
 */
Client.prototype.connect = function(config) {};

/**
 * Executes a command on the server.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * Executes a command on the server.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * @param {string} command The command to execute.
 * @param {?} options_or_callback Options for the command. / The callback to execute when the command has completed.
 * @param {?=} callback The callback to execute when the command has completed.
 * @return {boolean}
 */
Client.prototype.exec = function(command, options_or_callback, callback) {};

/**
 * Starts an interactive shell session on the server.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * Starts an interactive shell session on the server.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * Starts an interactive shell session on the server.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * Starts an interactive shell session on the server.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * @param {(boolean|?)|?} window_or_options_or_callback Either an object containing containing pseudo-tty settings, `false` to suppress creation of a pseudo-tty. / Options for the command. / The callback to execute when the channel has been created.
 * @param {?=} options_or_callback Options for the command. / The callback to execute when the channel has been created.
 * @param {?=} callback The callback to execute when the channel has been created.
 * @return {boolean}
 */
Client.prototype.shell = function(window_or_options_or_callback, options_or_callback, callback) {};

/**
 * Bind to `remoteAddr` on `remotePort` on the server and forward incoming TCP connections.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * @param {string} remoteAddr The remote address to bind on the server. The following lists several special values for `remoteAddr` and their respective bindings:
 * 
 *   | address       | description
 *   |:--------------|:-----------
 *   | `''`          | Listen on all protocol families supported by the server
 *   | `'0.0.0.0'`   | Listen on all IPv4 addresses
 *   | `'::'`        | Listen on all IPv6 addresses
 *   | `'localhost'` | Listen on the loopback interface for all protocol families
 *   | `'127.0.0.1'` | Listen on the loopback interfaces for IPv4
 *   | `'::1'`       | Listen on the loopback interfaces for IPv6
 * 
 * @param {number} remotePort The remote port to bind on the server. If this value is `0`, the actual bound port is provided to `callback`.
 * @param {?=} callback An optional callback that is invoked when the remote address is bound.
 * @return {boolean}
 */
Client.prototype.forwardIn = function(remoteAddr, remotePort, callback) {};

/**
 * Unbind from `remoteAddr` on `remotePort` on the server and stop forwarding incoming TCP
 * connections. Until `callback` is called, more connections may still come in.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * @param {string} remoteAddr The remote address to unbind on the server.
 * @param {number} remotePort The remote port to unbind on the server.
 * @param {?=} callback An optional callback that is invoked when the remote address is unbound.
 * @return {boolean}
 */
Client.prototype.unforwardIn = function(remoteAddr, remotePort, callback) {};

/**
 * Open a connection with `srcIP` and `srcPort` as the originating address and port and
 * `dstIP` and `dstPort` as the remote destination address and port.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * @param {string} srcIP The originating address.
 * @param {number} srcPort The originating port.
 * @param {string} dstIP The destination address.
 * @param {number} dstPort The destination port.
 * @param {?} callback The callback that is invoked when the address is bound.
 * @return {boolean}
 */
Client.prototype.forwardOut = function(srcIP, srcPort, dstIP, dstPort, callback) {};

/**
 * Starts an SFTP session.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * @param {?} callback The callback that is invoked when the SFTP session has started.
 * @return {boolean}
 */
Client.prototype.sftp = function(callback) {};

/**
 * Invokes `subsystem` on the server.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * @param {string} subsystem The subsystem to start on the server.
 * @param {?} callback The callback that is invoked when the subsystem has started.
 * @return {boolean}
 */
Client.prototype.subsys = function(subsystem, callback) {};

/**
 * Disconnects the socket.
 * @return {void}
 */
Client.prototype.end = function() {};

/**
 * Destroys the socket.
 * @return {void}
 */
Client.prototype.destroy = function() {};

/**
 * OpenSSH extension that sends a request to reject any new sessions (e.g. exec, shell,
 * sftp, subsys) for this connection.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?=} callback
 * @return {boolean}
 */
Client.prototype.openssh_noMoreSessions = function(callback) {};

/**
 * OpenSSH extension that binds to a UNIX domain socket at `socketPath` on the server and
 * forwards incoming connections.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} socketPath
 * @param {?=} callback
 * @return {boolean}
 */
Client.prototype.openssh_forwardInStreamLocal = function(socketPath, callback) {};

/**
 * OpenSSH extension that unbinds from a UNIX domain socket at `socketPath` on the server
 * and stops forwarding incoming connections.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} socketPath
 * @param {?=} callback
 * @return {boolean}
 */
Client.prototype.openssh_unforwardInStreamLocal = function(socketPath, callback) {};

/**
 * OpenSSH extension that opens a connection to a UNIX domain socket at `socketPath` on
 * the server.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} socketPath
 * @param {?=} callback
 * @return {boolean}
 */
Client.prototype.openssh_forwardOutStreamLocal = function(socketPath, callback) {};
/**
 * @record
 * @struct
 */
function ConnectConfig() {}
 /** @type {string} */
ConnectConfig.prototype.host;
 /** @type {number} */
ConnectConfig.prototype.port;
 /** @type {boolean} */
ConnectConfig.prototype.forceIPv4;
 /** @type {boolean} */
ConnectConfig.prototype.forceIPv6;
 /** @type {string} */
ConnectConfig.prototype.hostHash;
 /** @type {?} */
ConnectConfig.prototype.hostVerifier;
 /** @type {string} */
ConnectConfig.prototype.username;
 /** @type {string} */
ConnectConfig.prototype.password;
 /** @type {string} */
ConnectConfig.prototype.agent;
 /** @type {(string|?)} */
ConnectConfig.prototype.privateKey;
 /** @type {string} */
ConnectConfig.prototype.passphrase;
 /** @type {string} */
ConnectConfig.prototype.localHostname;
 /** @type {string} */
ConnectConfig.prototype.localUsername;
 /** @type {boolean} */
ConnectConfig.prototype.tryKeyboard;
 /** @type {number} */
ConnectConfig.prototype.keepaliveInterval;
 /** @type {number} */
ConnectConfig.prototype.keepaliveCountMax;
 /** @type {number} */
ConnectConfig.prototype.readyTimeout;
 /** @type {boolean} */
ConnectConfig.prototype.strictVendor;
 /** @type {!NodeJS.ReadableStream} */
ConnectConfig.prototype.sock;
 /** @type {boolean} */
ConnectConfig.prototype.agentForward;
 /** @type {?} */
ConnectConfig.prototype.algorithms;
 /** @type {?} */
ConnectConfig.prototype.debug;
/**
 * @record
 * @struct
 */
function TcpConnectionDetails() {}
 /** @type {string} */
TcpConnectionDetails.prototype.srcIP;
 /** @type {number} */
TcpConnectionDetails.prototype.srcPort;
 /** @type {string} */
TcpConnectionDetails.prototype.destIP;
 /** @type {number} */
TcpConnectionDetails.prototype.destPort;
/**
 * @record
 * @struct
 */
function X11Details() {}
 /** @type {string} */
X11Details.prototype.srcIP;
 /** @type {number} */
X11Details.prototype.srcPort;
/**
 * @record
 * @struct
 */
function ClientErrorExtensions() {}
 /** @type {string} */
ClientErrorExtensions.prototype.level;
 /** @type {string} */
ClientErrorExtensions.prototype.description;
/**
 * @record
 * @struct
 */
function ExecOptions() {}
 /** @type {?} */
ExecOptions.prototype.env;
 /** @type {(boolean|?)} */
ExecOptions.prototype.pty;
 /** @type {(number|boolean|?)} */
ExecOptions.prototype.x11;
/**
 * @record
 * @struct
 */
function ShellOptions() {}
 /** @type {(number|boolean|?)} */
ShellOptions.prototype.x11;
/**
 * @record
 * @struct
 */
function X11Options() {}
 /** @type {boolean} */
X11Options.prototype.single;
 /** @type {number} */
X11Options.prototype.screen;
/**
 * @record
 * @struct
 */
function PseudoTtyOptions() {}
 /** @type {number} */
PseudoTtyOptions.prototype.rows;
 /** @type {number} */
PseudoTtyOptions.prototype.cols;
 /** @type {number} */
PseudoTtyOptions.prototype.height;
 /** @type {number} */
PseudoTtyOptions.prototype.width;
 /** @type {string} */
PseudoTtyOptions.prototype.term;

/**
 * @constructor
 * @struct
 * Creates and returns a new Server instance.
 * 
 * @param {?} config Server configuration properties.
 * @param {?=} connectionListener if supplied, is added as a connection listener.
 */
function Server(config, connectionListener) {}
 /** @type {number} */
Server.KEEPALIVE_INTERVAL;
 /** @type {number} */
Server.KEEPALIVE_CLIENT_INTERVAL;
 /** @type {number} */
Server.KEEPALIVE_CLIENT_COUNT_MAX;

/**
 * Emitted when a new client has connected.
 * Emitted when an error occurs.
 * Emitted when the server has been bound after calling `server.listen()`.
 * Emitted when the server closes. Note that if connections exist, this event is not emitted until all connections are ended.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
Server.prototype.on = function(event, listener) {};

/**
 * Creates and returns a new Server instance.
 * 
 * @param {?} config Server configuration properties.
 * @param {?=} connectionListener if supplied, is added as a connection listener.
 * @return {?}
 */
Server.createServer = function(config, connectionListener) {};

/**
 * Start a local socket server listening for connections on the given `path`.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * Start a local socket server listening for connections on the given `path`.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * This will cause the server to accept connections on the specified handle, but it is
 * presumed that the file descriptor or handle has already been bound to a port or domain
 * socket.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * This will cause the server to accept connections on the specified handle, but it is
 * presumed that the file descriptor or handle has already been bound to a port or domain
 * socket.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * This will cause the server to accept connections using the specified options.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * Begin accepting connections on the specified port and hostname.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * Begin accepting connections on the specified port and hostname.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * Begin accepting connections on the specified port.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * Begin accepting connections on the specified port.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * Begin accepting connections on a random port.
 * 
 * This function is asynchronous. When the server has been bound, `listening` event will be emitted.
 * 
 * @param {string|(!Server|?)|!ListenOptions|number|?=} path_or_handle_or_options_or_port_or_callback A UNIX domain socket path. / Either a server or socket (anything with an underlying `_handle` member), or an `{fd: number}` object. / Connection options. / The port on which to start listening. If this value is `undefined` or `0`,
 *          the operating system will define a random port which can be retrieved later
 *          using `server.address().port`. / An optional callback to add to the `listening` event of the server.
 * @param {number|?|string=} backlog_or_callback_or_hostname The maximum length of the queue of pending connections. / An optional callback to add to the `listening` event of the server. / The hostname to bind. If `hostname` is omitted, the server will accept
 *          conections on any IPv6 address (`::`) when IPv6 is availble, or any IPv4
 *          address (`0.0.0.0`) otherwise.
 * @param {?|number=} callback_or_backlog An optional callback to add to the `listening` event of the server. / The maximum length of the queue of pending connections.
 * @param {?=} callback An optional callback to add to the `listening` event of the server.
 * @return {?}
 */
Server.prototype.listen = function(path_or_handle_or_options_or_port_or_callback, backlog_or_callback_or_hostname, callback_or_backlog, callback) {};

/**
 * Returns the bound address, the address family name, and port of the server as reported
 * by the operating system.
 * @return {?}
 */
Server.prototype.address = function() {};

/**
 * Asynchronously get the number of concurrent connections on the server.
 * @param {?} callback
 * @return {void}
 */
Server.prototype.getConnections = function(callback) {};

/**
 * Stops the server from accepting new connections and keeps existing connections. This
 * function is asynchronous, the server is finally closed when all connections are ended
 * and the server emits a 'close' event.
 * 
 * @param {?=} callback Optional callback that will be called once the `close` event occurs.
 *      Unlike that event, it will be called with an `Error` as its only argument if the
 *      server was not open when it was closed.
 * @return {?}
 */
Server.prototype.close = function(callback) {};

/**
 * Opposite of `unref`, calling `ref` on a previously unrefd server will not let the
 * program exit if it's the only server left (the default behavior). If the server is
 * refd calling `ref` again will have no effect.
 * @return {void}
 */
Server.prototype.ref = function() {};

/**
 * Calling `unref` on a server will allow the program to exit if this is the only active
 * server in the event system. If the server is already unrefd calling `unref` again
 * will have no effect.
 * @return {void}
 */
Server.prototype.unref = function() {};
/**
 * @record
 * @struct
 */
function ServerConfig() {}
 /** @type {!Array<(string|?)>} */
ServerConfig.prototype.hostKeys;
 /** @type {?} */
ServerConfig.prototype.algorithms;
 /** @type {string} */
ServerConfig.prototype.banner;
 /** @type {string} */
ServerConfig.prototype.ident;
 /** @type {number} */
ServerConfig.prototype.highWaterMark;
 /** @type {number} */
ServerConfig.prototype.maxPacketSize;
 /** @type {?} */
ServerConfig.prototype.debug;
/**
 * @record
 * @struct
 */
function EncryptedPrivateKey() {}
 /** @type {(string|?)} */
EncryptedPrivateKey.prototype.key;
 /** @type {string} */
EncryptedPrivateKey.prototype.passphrase;
/**
 * @record
 * @struct
 */
function ClientInfo() {}
 /** @type {string} */
ClientInfo.prototype.ip;
 /** @type {?} */
ClientInfo.prototype.header;
/**
 * @record
 * @struct
 */
function Connection() {}
 /** @type {boolean} */
Connection.prototype.noMoreSessions;
 /** @type {boolean} */
Connection.prototype.authenticated;

/**
 * Emitted when the client has requested authentication.
 * Emitted when the client has been successfully authenticated.
 * Emitted when the client has requested a new session.
 * Sessions are used to start interactive shells, execute commands, request X11 forwarding, etc.
 * Emitted when the client has requested an outbound (TCP) connection.
 * Emitted when the client has requested a connection to a UNIX domain socket.
 * Emitted when the client has sent a global request for name.
 * If info.bindPort === 0, you should pass the chosen port to accept so that the client will know what port was bound.
 * Emitted when the client has sent a global request for name.
 * Emitted when the client has sent a global request for name.
 * If info.bindPort === 0, you should pass the chosen port to accept so that the client will know what port was bound.
 * Emitted when the client has finished rekeying (either client or server initiated).
 * Emitted when more requests/data can be sent to the client (after a Connection method returned false).
 * Emitted when an error occurrs.
 * Emitted when the socket has disconnected.
 * Emitted when the client socket was closed.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
Connection.prototype.on = function(event, listener) {};

/**
 * Closes the client connection.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @return {boolean}
 */
Connection.prototype.end = function() {};

/**
 * Alert the client of an incoming X11 client connection from `originAddr` on port `originPort`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} originAddr
 * @param {number} originPort
 * @param {?} callback
 * @return {boolean}
 */
Connection.prototype.x11 = function(originAddr, originPort, callback) {};

/**
 * Alert the client of an incoming TCP connection on `boundAddr` on port `boundPort` from
 * `remoteAddr` on port `remotePort`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} boundAddr
 * @param {number} boundPort
 * @param {string} remoteAddr
 * @param {number} remotePort
 * @param {?} callback
 * @return {boolean}
 */
Connection.prototype.forwardOut = function(boundAddr, boundPort, remoteAddr, remotePort, callback) {};

/**
 * Initiates a rekeying with the client.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * 
 * @param {?=} callback An optional callback added as a one-time handler for the `rekey` event.
 * @return {boolean}
 */
Connection.prototype.rekey = function(callback) {};

/**
 * Alert the client of an incoming UNIX domain socket connection on socketPath.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} socketPath
 * @param {?} callback
 * @return {boolean}
 */
Connection.prototype.openssh_forwardOutStreamLocal = function(socketPath, callback) {};
/**
 * @record
 * @struct
 */
function AuthContextBase() {}
 /** @type {string} */
AuthContextBase.prototype.username;
 /** @type {string} */
AuthContextBase.prototype.service;
 /** @type {string} */
AuthContextBase.prototype.method;

/**
 * Accepts the authentication request.
 * @return {void}
 */
AuthContextBase.prototype.accept = function() {};

/**
 * Rejects the authentication request.
 * Rejects the authentication request.
 * Rejects the authentication request.
 * @param {boolean|!Array<string>=} isPartialSuccess_or_authMethodsLeft
 * @param {boolean=} isPartialSuccess
 * @return {void}
 */
AuthContextBase.prototype.reject = function(isPartialSuccess_or_authMethodsLeft, isPartialSuccess) {};

/**
 * Emitted when the client aborts the authentication request.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
AuthContextBase.prototype.on = function(event, listener) {};
/**
 * @extends {AuthContextBase}
 * @record
 * @struct
 */
function KeyboardAuthContext() {}
 /** @type {string} */
KeyboardAuthContext.prototype.method;
 /** @type {!Array<string>} */
KeyboardAuthContext.prototype.submethods;

/**
 * Send prompts to the client.
 * Send prompts to the client.
 * Send prompts to the client.
 * @param {(string|?|!Array<(string|?)>)} prompts The prompts to send to the client.
 * @param {?|string} callback_or_title A callback to call with the responses from the client. / The title for the prompt.
 * @param {?|string=} callback_or_instructions A callback to call with the responses from the client. / Instructions for the client.
 * @param {?=} callback A callback to call with the responses from the client.
 * @return {void}
 */
KeyboardAuthContext.prototype.prompt = function(prompts, callback_or_title, callback_or_instructions, callback) {};
/**
 * @extends {AuthContextBase}
 * @record
 * @struct
 */
function PublicKeyAuthContext() {}
 /** @type {string} */
PublicKeyAuthContext.prototype.method;
 /** @type {?} */
PublicKeyAuthContext.prototype.key;
 /** @type {?} */
PublicKeyAuthContext.prototype.signature;
 /** @type {string} */
PublicKeyAuthContext.prototype.sigAlgo;
 /** @type {?} */
PublicKeyAuthContext.prototype.blob;
/**
 * @record
 * @struct
 */
function PublicKey() {}
 /** @type {string} */
PublicKey.prototype.algo;
 /** @type {?} */
PublicKey.prototype.data;
/**
 * @extends {AuthContextBase}
 * @record
 * @struct
 */
function HostbasedAuthContext() {}
 /** @type {string} */
HostbasedAuthContext.prototype.method;
 /** @type {?} */
HostbasedAuthContext.prototype.key;
 /** @type {?} */
HostbasedAuthContext.prototype.signature;
 /** @type {string} */
HostbasedAuthContext.prototype.sigAlgo;
 /** @type {?} */
HostbasedAuthContext.prototype.blob;
 /** @type {string} */
HostbasedAuthContext.prototype.localHostname;
 /** @type {string} */
HostbasedAuthContext.prototype.localUsername;
/**
 * @extends {AuthContextBase}
 * @record
 * @struct
 */
function PasswordAuthContext() {}
 /** @type {string} */
PasswordAuthContext.prototype.method;
 /** @type {string} */
PasswordAuthContext.prototype.password;
/**
 * @extends {AuthContextBase}
 * @record
 * @struct
 */
function NoneAuthContext() {}
 /** @type {string} */
NoneAuthContext.prototype.method;

/** @typedef {?} */
var AuthContext;
/**
 * @record
 * @struct
 */
function TcpipRequestInfo() {}
 /** @type {string} */
TcpipRequestInfo.prototype.srcIP;
 /** @type {number} */
TcpipRequestInfo.prototype.srcPort;
 /** @type {string} */
TcpipRequestInfo.prototype.destIP;
 /** @type {number} */
TcpipRequestInfo.prototype.destPort;
/**
 * @record
 * @struct
 */
function SocketRequestInfo() {}
 /** @type {string} */
SocketRequestInfo.prototype.socketPath;
/**
 * @record
 * @struct
 */
function TcpipBindInfo() {}
 /** @type {string} */
TcpipBindInfo.prototype.bindAddr;
 /** @type {number} */
TcpipBindInfo.prototype.bindPort;
/**
 * @record
 * @struct
 */
function SocketBindInfo() {}
 /** @type {string} */
SocketBindInfo.prototype.socketPath;
/**
 * @record
 * @struct
 */
function Session() {}

/**
 * Emitted when the client requested allocation of a pseudo-TTY for this session.
 * Emitted when the client reported a change in window dimensions during this session.
 * Emitted when the client requested X11 forwarding.
 * Emitted when the client requested an environment variable to be set for this session.
 * Emitted when the client has sent a POSIX signal.
 * Emitted when the client has requested incoming ssh-agent requests be forwarded to them.
 * Emitted when the client has requested an interactive shell.
 * Emitted when the client has requested execution of a command string.
 * Emitted when the client has requested the SFTP subsystem.
 * Emitted when the client has requested an arbitrary subsystem.
 * Emitted when the session has closed.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
Session.prototype.on = function(event, listener) {};
/**
 * @record
 * @struct
 */
function PseudoTtyInfo() {}
 /** @type {number} */
PseudoTtyInfo.prototype.cols;
 /** @type {number} */
PseudoTtyInfo.prototype.rows;
 /** @type {number} */
PseudoTtyInfo.prototype.width;
 /** @type {number} */
PseudoTtyInfo.prototype.height;
 /** @type {?} */
PseudoTtyInfo.prototype.modes;
/**
 * @record
 * @struct
 */
function TerminalModes() {}

/* TODO: IndexSignature:  */
 /** @type {number} */
TerminalModes.prototype.VINTR;
 /** @type {number} */
TerminalModes.prototype.VQUIT;
 /** @type {number} */
TerminalModes.prototype.VERASE;
 /** @type {number} */
TerminalModes.prototype.VKILL;
 /** @type {number} */
TerminalModes.prototype.VEOF;
 /** @type {number} */
TerminalModes.prototype.VEOL;
 /** @type {number} */
TerminalModes.prototype.VEOL2;
 /** @type {number} */
TerminalModes.prototype.VSTART;
 /** @type {number} */
TerminalModes.prototype.VSTOP;
 /** @type {number} */
TerminalModes.prototype.VSUSP;
 /** @type {number} */
TerminalModes.prototype.VDSUSP;
 /** @type {number} */
TerminalModes.prototype.VREPRINT;
 /** @type {number} */
TerminalModes.prototype.VWERASE;
 /** @type {number} */
TerminalModes.prototype.VLNEXT;
 /** @type {number} */
TerminalModes.prototype.VFLUSH;
 /** @type {number} */
TerminalModes.prototype.VSWTCH;
 /** @type {number} */
TerminalModes.prototype.VSTATUS;
 /** @type {number} */
TerminalModes.prototype.VDISCARD;
 /** @type {number} */
TerminalModes.prototype.IGNPAR;
 /** @type {number} */
TerminalModes.prototype.PARMRK;
 /** @type {number} */
TerminalModes.prototype.INPCK;
 /** @type {number} */
TerminalModes.prototype.ISTRIP;
 /** @type {number} */
TerminalModes.prototype.INLCR;
 /** @type {number} */
TerminalModes.prototype.IGNCR;
 /** @type {number} */
TerminalModes.prototype.ICRNL;
 /** @type {number} */
TerminalModes.prototype.IUCLC;
 /** @type {number} */
TerminalModes.prototype.IXON;
 /** @type {number} */
TerminalModes.prototype.IXANY;
 /** @type {number} */
TerminalModes.prototype.IXOFF;
 /** @type {number} */
TerminalModes.prototype.IMAXBEL;
 /** @type {number} */
TerminalModes.prototype.ISIG;
 /** @type {number} */
TerminalModes.prototype.ICANON;
 /** @type {number} */
TerminalModes.prototype.XCASE;
 /** @type {number} */
TerminalModes.prototype.ECHO;
 /** @type {number} */
TerminalModes.prototype.ECHOE;
 /** @type {number} */
TerminalModes.prototype.ECHOK;
 /** @type {number} */
TerminalModes.prototype.ECHONL;
 /** @type {number} */
TerminalModes.prototype.NOFLSH;
 /** @type {number} */
TerminalModes.prototype.TOSTOP;
 /** @type {number} */
TerminalModes.prototype.IEXTEN;
 /** @type {number} */
TerminalModes.prototype.ECHOCTL;
 /** @type {number} */
TerminalModes.prototype.ECHOKE;
 /** @type {number} */
TerminalModes.prototype.PENDIN;
 /** @type {number} */
TerminalModes.prototype.OPOST;
 /** @type {number} */
TerminalModes.prototype.OLCUC;
 /** @type {number} */
TerminalModes.prototype.ONLCR;
 /** @type {number} */
TerminalModes.prototype.OCRNL;
 /** @type {number} */
TerminalModes.prototype.ONOCR;
 /** @type {number} */
TerminalModes.prototype.ONLRET;
 /** @type {number} */
TerminalModes.prototype.CS7;
 /** @type {number} */
TerminalModes.prototype.CS8;
 /** @type {number} */
TerminalModes.prototype.PARENB;
 /** @type {number} */
TerminalModes.prototype.PARODD;
 /** @type {number} */
TerminalModes.prototype.TTY_OP_ISPEED;
 /** @type {number} */
TerminalModes.prototype.TTY_OP_OSPEED;
/**
 * @record
 * @struct
 */
function WindowChangeInfo() {}
 /** @type {number} */
WindowChangeInfo.prototype.cols;
 /** @type {number} */
WindowChangeInfo.prototype.rows;
 /** @type {number} */
WindowChangeInfo.prototype.width;
 /** @type {number} */
WindowChangeInfo.prototype.height;
/**
 * @record
 * @struct
 */
function X11Info() {}
 /** @type {boolean} */
X11Info.prototype.single;
 /** @type {string} */
X11Info.prototype.protocol;
 /** @type {string} */
X11Info.prototype.cookie;
 /** @type {number} */
X11Info.prototype.screen;
/**
 * @record
 * @struct
 */
function SetEnvInfo() {}
 /** @type {string} */
SetEnvInfo.prototype.key;
 /** @type {string} */
SetEnvInfo.prototype.value;
/**
 * @record
 * @struct
 */
function SignalInfo() {}
 /** @type {string} */
SignalInfo.prototype.name;
/**
 * @record
 * @struct
 */
function ExecInfo() {}
 /** @type {string} */
ExecInfo.prototype.command;
/**
 * @record
 * @struct
 */
function SubsystemInfo() {}
 /** @type {string} */
SubsystemInfo.prototype.name;
/**
 * @record
 * @struct
 */
function SFTPWrapper() {}

/**
 * (Client-only)
 * Downloads a file at `remotePath` to `localPath` using parallel reads for faster throughput.
 * (Client-only)
 * Downloads a file at `remotePath` to `localPath` using parallel reads for faster throughput.
 * @param {string} remotePath
 * @param {string} localPath
 * @param {?} options_or_callback
 * @param {?=} callback
 * @return {void}
 */
SFTPWrapper.prototype.fastGet = function(remotePath, localPath, options_or_callback, callback) {};

/**
 * (Client-only)
 * Uploads a file from `localPath` to `remotePath` using parallel reads for faster throughput.
 * (Client-only)
 * Uploads a file from `localPath` to `remotePath` using parallel reads for faster throughput.
 * @param {string} localPath
 * @param {string} remotePath
 * @param {?} options_or_callback
 * @param {?=} callback
 * @return {void}
 */
SFTPWrapper.prototype.fastPut = function(localPath, remotePath, options_or_callback, callback) {};

/**
 * (Client-only)
 * Returns a new readable stream for `path`.
 * @param {string} path
 * @param {?=} options
 * @return {!internal.Readable}
 */
SFTPWrapper.prototype.createReadStream = function(path, options) {};

/**
 * (Client-only)
 * Returns a new writable stream for `path`.
 * @param {string} path
 * @param {?=} options
 * @return {!internal.Writable}
 */
SFTPWrapper.prototype.createWriteStream = function(path, options) {};

/**
 * (Client-only)
 * Opens a file `filename` for `mode` with optional `attributes`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * (Client-only)
 * Opens a file `filename` for `mode`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} filename
 * @param {string} mode
 * @param {?} attributes_or_callback
 * @param {?=} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.open = function(filename, mode, attributes_or_callback, callback) {};

/**
 * (Client-only)
 * Closes the resource associated with `handle` given by `open()` or `opendir()`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.close = function(handle, callback) {};

/**
 * (Client-only)
 * Reads `length` bytes from the resource associated with `handle` starting at `position`
 * and stores the bytes in `buffer` starting at `offset`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} buffer
 * @param {number} offset
 * @param {number} length
 * @param {number} position
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.read = function(handle, buffer, offset, length, position, callback) {};

/**
 * (Client-only)
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} buffer
 * @param {number} offset
 * @param {number} length
 * @param {number} position
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.write = function(handle, buffer, offset, length, position, callback) {};

/**
 * (Client-only)
 * Retrieves attributes for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.fstat = function(handle, callback) {};

/**
 * (Client-only)
 * Sets the attributes defined in `attributes` for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} attributes
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.fsetstat = function(handle, attributes, callback) {};

/**
 * (Client-only)
 * Sets the access time and modified time for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {(number|!Date)} atime
 * @param {(number|!Date)} mtime
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.futimes = function(handle, atime, mtime, callback) {};

/**
 * (Client-only)
 * Sets the owner for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {number} uid
 * @param {number} gid
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.fchown = function(handle, uid, gid, callback) {};

/**
 * (Client-only)
 * Sets the mode for the resource associated with `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {(string|number)} mode
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.fchmod = function(handle, mode, callback) {};

/**
 * (Client-only)
 * Opens a directory `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.opendir = function(path, callback) {};

/**
 * (Client-only)
 * Retrieves a directory listing.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {(string|?)} location
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.readdir = function(location, callback) {};

/**
 * (Client-only)
 * Removes the file/symlink at `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.unlink = function(path, callback) {};

/**
 * (Client-only)
 * Renames/moves `srcPath` to `destPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} srcPath
 * @param {string} destPath
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.rename = function(srcPath, destPath, callback) {};

/**
 * (Client-only)
 * Creates a new directory `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * (Client-only)
 * Creates a new directory `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} attributes_or_callback
 * @param {?=} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.mkdir = function(path, attributes_or_callback, callback) {};

/**
 * (Client-only)
 * Removes the directory at `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.rmdir = function(path, callback) {};

/**
 * (Client-only)
 * Retrieves attributes for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.stat = function(path, callback) {};

/**
 * (Client-only)
 * Retrieves attributes for `path`. If `path` is a symlink, the link itself is stat'ed
 * instead of the resource it refers to.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.lstat = function(path, callback) {};

/**
 * (Client-only)
 * Sets the attributes defined in `attributes` for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} attributes
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.setstat = function(path, attributes, callback) {};

/**
 * (Client-only)
 * Sets the access time and modified time for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {(number|!Date)} atime
 * @param {(number|!Date)} mtime
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.utimes = function(path, atime, mtime, callback) {};

/**
 * (Client-only)
 * Sets the owner for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {number} uid
 * @param {number} gid
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.chown = function(path, uid, gid, callback) {};

/**
 * (Client-only)
 * Sets the mode for `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {(string|number)} mode
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.chmod = function(path, mode, callback) {};

/**
 * (Client-only)
 * Retrieves the target for a symlink at `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.readlink = function(path, callback) {};

/**
 * (Client-only)
 * Creates a symlink at `linkPath` to `targetPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} targetPath
 * @param {string} linkPath
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.symlink = function(targetPath, linkPath, callback) {};

/**
 * (Client-only)
 * Resolves `path` to an absolute path.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.realpath = function(path, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX rename(3) from `srcPath` to `destPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} srcPath
 * @param {string} destPath
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.ext_openssh_rename = function(srcPath, destPath, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX statvfs(2) on `path`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} path
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.ext_openssh_statvfs = function(path, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX fstatvfs(2) on open handle `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.ext_openssh_fstatvfs = function(handle, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX link(2) to create a hard link to `targetPath` at `linkPath`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {string} targetPath
 * @param {string} linkPath
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.ext_openssh_hardlink = function(targetPath, linkPath, callback) {};

/**
 * (Client-only, OpenSSH extension)
 * Performs POSIX fsync(3) on the open handle `handle`.
 * 
 * Returns `false` if you should wait for the `continue` event before sending any more traffic.
 * @param {?} handle
 * @param {?} callback
 * @return {boolean}
 */
SFTPWrapper.prototype.ext_openssh_fsync = function(handle, callback) {};

/**
 * Ends the stream.
 * @return {void}
 */
SFTPWrapper.prototype.end = function() {};

/**
 * Emitted when an error occurred.
 * Emitted when the session has ended.
 * Emitted when the session has closed.
 * Emitted when more requests/data can be sent to the stream.
 * @param {string|(string|symbol)} event
 * @param {?|!Function} listener
 * @return {?}
 */
SFTPWrapper.prototype.on = function(event, listener) {};
