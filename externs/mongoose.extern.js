/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/mongoose/index.d.ts:
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "mongoose"
/** @const */
tsickle_declare_module.mongoose = {};

/* TODO: ImportEqualsDeclaration in tsickle_declare_module.mongoose */

/* TODO: ImportEqualsDeclaration in tsickle_declare_module.mongoose */

/* TODO: ImportEqualsDeclaration in tsickle_declare_module.mongoose */

/* TODO: ImportEqualsDeclaration in tsickle_declare_module.mongoose */
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.NativeBuffer = function() {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.NativeDate = function() {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.NativeError = function() {};
 /** @type {?} */
tsickle_declare_module.mongoose.DocumentProvider;
 /** @type {function(new: (?), !Array<?>): ?} */
tsickle_declare_module.mongoose.Mongoose;

/** @typedef {?} */
tsickle_declare_module.mongoose.Mongoose;
 /** @type {?} */
tsickle_declare_module.mongoose.SchemaTypes;
 /** @type {!Object} */
tsickle_declare_module.mongoose.STATES;
 /** @type {!Connection} */
tsickle_declare_module.mongoose.connection;
 /** @type {?} */
tsickle_declare_module.mongoose.mongo;
 /** @type {string} */
tsickle_declare_module.mongoose.version;

/**
 * Opens the default mongoose connection.
 * Options passed take precedence over options included in connection strings.
 * @param {string} uris
 * @param {!ConnectionOptions|function(?): void=} options_or_callback
 * @param {function(?): void=} callback
 * @return {?} pseudo-promise wrapper around this
 */
tsickle_declare_module.mongoose.connect = function(uris, options_or_callback, callback) {};

/**
 * Creates a Connection instance.
 * Each connection instance maps to a single database. This method is helpful
 *   when mangaging multiple db connections.
 * @param {string=} uri_or_host
 * @param {!ConnectionOptions|string=} options_or_database_name
 * @param {number=} port
 * @param {!ConnectionOptions=} options
 * @return {!Connection} the created Connection object
 */
tsickle_declare_module.mongoose.createConnection = function(uri_or_host, options_or_database_name, port, options) {};

/**
 * Disconnects all connections.
 * @param {function(?): void=} fn called after all connection close.
 * @return {?} pseudo-promise wrapper around this
 */
tsickle_declare_module.mongoose.disconnect = function(fn) {};

/**
 * Gets mongoose options
 * @param {string} key
 * @return {?}
 */
tsickle_declare_module.mongoose.get = function(key) {};

/**
 * Defines a model or retrieves it.
 * Models defined on the mongoose instance are available to all connection
 *   created by the same mongoose instance.
 * @template T, U
 * @param {string} name model name
 * @param {!Schema=} schema
 * @param {string=} collection (optional, induced from model name)
 * @param {boolean=} skipInit whether to skip initialization (defaults to false)
 * @return {?<T>|U}
 */
tsickle_declare_module.mongoose.model = function(name, schema, collection, skipInit) {};

/**
 * Returns an array of model names created on this instance of Mongoose.
 * Does not include names of models created using connection.model().
 * @return {!Array<string>}
 */
tsickle_declare_module.mongoose.modelNames = function() {};

/**
 * Declares a global plugin executed on all Schemas.
 * Equivalent to calling .plugin(fn) on each Schema you create.
 * @param {!Function} fn plugin callback
 * @param {!Object=} opts optional options
 * @return {?}
 */
tsickle_declare_module.mongoose.plugin = function(fn, opts) {};

/**
 * Sets mongoose options
 * @param {string} key
 * @param {?} value
 * @return {void}
 */
tsickle_declare_module.mongoose.set = function(key, value) {};

/** @typedef {?} */
tsickle_declare_module.mongoose.MongooseThenable;

/**
 * @constructor
 * @struct
 * The Mongoose CastError constructor
 * @param {string} type The name of the type
 * @param {?} value The value that failed to cast
 * @param {string} path The path a.b.c in the doc where this cast error occurred
 * @param {!NativeError=} reason The original error that was thrown
 */
tsickle_declare_module.mongoose.CastError = function(type, value, path, reason) {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.QueryStream = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.QueryStream.prototype.paused;
 /** @type {boolean} */
tsickle_declare_module.mongoose.QueryStream.prototype.readable;

/**
 * Provides a Node.js 0.8 style ReadStream interface for Queries.
 * \@event data emits a single Mongoose document
 * \@event error emits when an error occurs during streaming. This will emit before the close event.
 * \@event close emits when the stream reaches the end of the cursor or an error occurs, or the stream
 *   is manually destroyed. After this event, no more events are emitted.
 * @param {!Query<?>} query
 * @param {?=} options
 * @return {!QueryStream}
 */
tsickle_declare_module.mongoose.QueryStream.prototype.constructor = function(query, options) {};

/**
 * Destroys the stream, closing the underlying cursor, which emits the close event.
 * No more events will be emitted after the close event.
 * @param {!NativeError=} err
 * @return {void}
 */
tsickle_declare_module.mongoose.QueryStream.prototype.destroy = function(err) {};

/**
 * Pauses this stream.
 * @return {void}
 */
tsickle_declare_module.mongoose.QueryStream.prototype.pause = function() {};

/**
 * Pipes this query stream into another stream. This method is inherited from NodeJS Streams.
 * @template T
 * @param {T} destination
 * @param {{end: boolean}=} options
 * @return {T}
 */
tsickle_declare_module.mongoose.QueryStream.prototype.pipe = function(destination, options) {};

/**
 * Resumes this stream.
 * @return {void}
 */
tsickle_declare_module.mongoose.QueryStream.prototype.resume = function() {};

/**
 * @constructor
 * @struct
 * For practical reasons, a Connection equals a Db.
 * \@event connecting Emitted when connection.{open,openSet}() is executed on this connection.
 * \@event connected Emitted when this connection successfully connects to the db. May be emitted multiple times in reconnected scenarios.
 * \@event open Emitted after we connected and onOpen is executed on all of this connections models.
 * \@event disconnecting Emitted when connection.close() was executed.
 * \@event disconnected Emitted after getting disconnected from the db.
 * \@event close Emitted after we disconnected and onClose executed on all of this connections models.
 * \@event reconnected Emitted after we connected and subsequently disconnected, followed by successfully another successfull connection.
 * \@event error Emitted when an error occurs on this connection.
 * \@event fullsetup Emitted in a replica-set scenario, when primary and at least one seconaries specified in the connection string are connected.
 * \@event all Emitted in a replica-set scenario, when all nodes specified in the connection string are connected.
 * @param {?} base a mongoose instance
 */
tsickle_declare_module.mongoose.ConnectionBase = function(base) {};
 /** @type {!Object} */
tsickle_declare_module.mongoose.ConnectionBase.prototype.config;
 /** @type {?} */
tsickle_declare_module.mongoose.ConnectionBase.prototype.db;
 /** @type {!Object<string,?>} */
tsickle_declare_module.mongoose.ConnectionBase.prototype.collections;
 /** @type {number} */
tsickle_declare_module.mongoose.ConnectionBase.prototype.readyState;

/**
 * Opens the connection to MongoDB.
 * @param {string} connection_string
 * @param {string=} database database name
 * @param {number=} port database port
 * @param {!ConnectionOpenOptions=} options Mongoose forces the db option forceServerObjectId false and cannot be overridden.
 *   Mongoose defaults the server auto_reconnect options to true which can be overridden.
 *   See the node-mongodb-native driver instance for options that it understands.
 *   Options passed take precedence over options included in connection strings.
 * @param {function(?): void=} callback
 * @return {?}
 */
tsickle_declare_module.mongoose.ConnectionBase.prototype.open = function(connection_string, database, port, options, callback) {};

/**
 * Helper for dropDatabase()
 * @param {function(?): void=} callback
 * @return {!Promise<void>}
 */
tsickle_declare_module.mongoose.ConnectionBase.prototype.dropDatabase = function(callback) {};

/**
 * Opens the connection to a replica set.
 * @param {string} uris comma-separated mongodb:// URIs
 * @param {string=} database database name if not included in uris
 * @param {!ConnectionOpenSetOptions=} options passed to the internal driver
 * @param {function(?): void=} callback
 * @return {?}
 */
tsickle_declare_module.mongoose.ConnectionBase.prototype.openSet = function(uris, database, options, callback) {};

/**
 * Closes the connection
 * @param {function(?): void=} callback
 * @return {!Promise<void>}
 */
tsickle_declare_module.mongoose.ConnectionBase.prototype.close = function(callback) {};

/**
 * Retrieves a collection, creating it if not cached.
 * Not typically needed by applications. Just talk to your collection through your model.
 * @param {string} name name of the collection
 * @param {!Object=} options optional collection options
 * @return {?}
 */
tsickle_declare_module.mongoose.ConnectionBase.prototype.collection = function(name, options) {};

/**
 * Defines or retrieves a model.
 * When no collection argument is passed, Mongoose produces a collection name by passing
 * the model name to the utils.toCollectionName method. This method pluralizes the name.
 * If you don't like this behavior, either pass a collection name or set your schemas
 * collection name option.
 * @template T, U
 * @param {string} name the model name
 * @param {!Schema=} schema a schema. necessary when defining a model
 * @param {string=} collection name of mongodb collection (optional) if not given it will be induced from model name
 * @return {?<T>|U} The compiled model
 */
tsickle_declare_module.mongoose.ConnectionBase.prototype.model = function(name, schema, collection) {};

/**
 * Returns an array of model names created on this connection.
 * @return {!Array<string>}
 */
tsickle_declare_module.mongoose.ConnectionBase.prototype.modelNames = function() {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ConnectionOptionsBase = function() {};
 /** @type {?} */
tsickle_declare_module.mongoose.ConnectionOptionsBase.prototype.db;
 /** @type {?} */
tsickle_declare_module.mongoose.ConnectionOptionsBase.prototype.server;
 /** @type {?} */
tsickle_declare_module.mongoose.ConnectionOptionsBase.prototype.replset;
 /** @type {string} */
tsickle_declare_module.mongoose.ConnectionOptionsBase.prototype.user;
 /** @type {string} */
tsickle_declare_module.mongoose.ConnectionOptionsBase.prototype.pass;
 /** @type {?} */
tsickle_declare_module.mongoose.ConnectionOptionsBase.prototype.auth;
/**
 * @extends {ConnectionOptionsBase}
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ConnectionOpenOptions = function() {};
 /** @type {{autoIndex: boolean}} */
tsickle_declare_module.mongoose.ConnectionOpenOptions.prototype.config;
/**
 * @extends {ConnectionOptionsBase}
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ConnectionOpenSetOptions = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.ConnectionOpenSetOptions.prototype.mongos;
 /** @type {?} */
tsickle_declare_module.mongoose.ConnectionOpenSetOptions.prototype.promiseLibrary;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ConnectionOpenSetOptions.prototype.useMongoClient;
/**
 * @extends {ConnectionOpenOptions}
 * @extends {ConnectionOpenSetOptions}
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ConnectionOptions = function() {};
 /** @type {?} */
tsickle_declare_module.mongoose.Collection;

/* TODO: ConstructSignature: tsickle_declare_module.mongoose */

/**
 * Formatter for debug print args
 * @param {?} arg
 * @return {string}
 */
tsickle_declare_module.mongoose.Collection.prototype.$format = function(arg) {};

/**
 * Debug print helper
 * @param {?} name
 * @param {?} i
 * @param {!Array<?>} args
 * @return {void}
 */
tsickle_declare_module.mongoose.Collection.prototype.$print = function(name, i, args) {};

/**
 * Retreives information about this collections indexes.
 * @return {?}
 */
tsickle_declare_module.mongoose.Collection.prototype.getIndexes = function() {};
/**
 * @extends {ConnectionBase}
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.Connection = function() {};
 /** @type {!Object} */
tsickle_declare_module.mongoose.Connection.STATES;

/**
 * Switches to a different database using the same connection pool.
 * @param {string} name The database name
 * @return {!Connection} New Connection Object
 */
tsickle_declare_module.mongoose.Connection.prototype.useDb = function(name) {};
/**
 * @extends {Error}
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.ValidationError = function() {};

/**
 * Console.log helper
 * @return {string}
 */
tsickle_declare_module.mongoose.ValidationError.prototype.toString = function() {};

/**
 * @constructor
 * @struct
 * MongooseError constructor
 * @param {string} msg Error message
 */
tsickle_declare_module.mongoose.Error = function(msg) {};
 /** @type {!Object} */
tsickle_declare_module.mongoose.Error.messages;
 /** @type {!Object} */
tsickle_declare_module.mongoose.Error.Messages;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.QueryCursor = function() {};

/**
 * A QueryCursor is a concurrency primitive for processing query results
 * one document at a time. A QueryCursor fulfills the Node.js streams3 API,
 * in addition to several other mechanisms for loading documents from MongoDB
 * one at a time.
 * Unless you're an advanced user, do not instantiate this class directly.
 * Use Query#cursor() instead.
 * \@event cursor Emitted when the cursor is created
 * \@event error Emitted when an error occurred
 * \@event data Emitted when the stream is flowing and the next doc is ready
 * \@event end Emitted when the stream is exhausted
 * @param {!Query<T>} query
 * @param {!Object} options query options passed to .find()
 * @return {!QueryCursor}
 */
tsickle_declare_module.mongoose.QueryCursor.prototype.constructor = function(query, options) {};

/**
 * Marks this cursor as closed. Will stop streaming and subsequent calls to next() will error.
 * @param {function(?, ?): void=} callback
 * @return {!Promise<?>}
 */
tsickle_declare_module.mongoose.QueryCursor.prototype.close = function(callback) {};

/**
 * Execute fn for every document in the cursor. If fn returns a promise,
 * will wait for the promise to resolve before iterating on to the next one.
 * Returns a promise that resolves when done.
 * @param {function(T): ?} fn
 * @param {function(?): void=} callback executed when all docs have been processed
 * @return {!Promise<T>}
 */
tsickle_declare_module.mongoose.QueryCursor.prototype.eachAsync = function(fn, callback) {};

/**
 * Registers a transform function which subsequently maps documents retrieved
 * via the streams interface or .next()
 * @param {function(T): T} fn
 * @return {mongoose.QueryCursor}
 */
tsickle_declare_module.mongoose.QueryCursor.prototype.map = function(fn) {};

/**
 * Get the next document from this cursor. Will return null when there are
 * no documents left.
 * @param {function(?, T): void=} callback
 * @return {!Promise<?>}
 */
tsickle_declare_module.mongoose.QueryCursor.prototype.next = function(callback) {};

/**
 * @constructor
 * @struct
 * This is what mongoose uses to define virtual attributes via Schema.prototype.virtual.
 * @param {!Object} options
 * @param {string} name
 */
tsickle_declare_module.mongoose.VirtualType = function(options, name) {};

/**
 * Applies getters to value using optional scope.
 * @param {!Object} value
 * @param {!Object} scope
 * @return {?}
 */
tsickle_declare_module.mongoose.VirtualType.prototype.applyGetters = function(value, scope) {};

/**
 * Applies setters to value using optional scope.
 * @param {!Object} value
 * @param {!Object} scope
 * @return {?}
 */
tsickle_declare_module.mongoose.VirtualType.prototype.applySetters = function(value, scope) {};

/**
 * Defines a getter.
 * @param {!Function} fn
 * @return {mongoose.VirtualType}
 */
tsickle_declare_module.mongoose.VirtualType.prototype.get = function(fn) {};

/**
 * Defines a setter.
 * @param {!Function} fn
 * @return {mongoose.VirtualType}
 */
tsickle_declare_module.mongoose.VirtualType.prototype.set = function(fn) {};

/**
 * @constructor
 * @struct
 * Schema constructor.
 * When nesting schemas, (children in the example above), always declare
 * the child schema first before passing it into its parent.
 * \@event init Emitted after the schema is compiled into a Model.
 * @param {!SchemaDefinition=} definition
 * @param {!SchemaOptions=} options
 */
tsickle_declare_module.mongoose.Schema = function(definition, options) {};
 /** @type {!Array<string>} */
tsickle_declare_module.mongoose.Schema.indexTypes;
 /** @type {!Object} */
tsickle_declare_module.mongoose.Schema.reserved;
 /** @type {?} */
tsickle_declare_module.mongoose.Schema.prototype.methods;
 /** @type {?} */
tsickle_declare_module.mongoose.Schema.prototype.statics;
 /** @type {?} */
tsickle_declare_module.mongoose.Schema.prototype.obj;

/**
 * Adds key path / schema type pairs to this schema.
 * @param {!SchemaDefinition} obj
 * @param {string=} prefix
 * @return {void}
 */
tsickle_declare_module.mongoose.Schema.prototype.add = function(obj, prefix) {};

/**
 * Iterates the schemas paths similar to Array.forEach.
 * @param {function(string, !SchemaType): void} fn callback function
 * @return {mongoose.Schema} this
 */
tsickle_declare_module.mongoose.Schema.prototype.eachPath = function(fn) {};

/**
 * Gets a schema option.
 * @param {string} key option name
 * @return {?}
 */
tsickle_declare_module.mongoose.Schema.prototype.get = function(key) {};

/**
 * Defines an index (most likely compound) for this schema.
 * @param {!Object} fields
 * @param {?=} options Options to pass to MongoDB driver's createIndex() function
 * @return {mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.index = function(fields, options) {};

/**
 * Compiles indexes from fields and schema-level indexes
 * @return {!Array<?>}
 */
tsickle_declare_module.mongoose.Schema.prototype.indexes = function() {};

/**
 * Loads an ES6 class into a schema. Maps setters + getters, static methods, and
 * instance methods to schema virtuals, statics, and methods.
 * @param {!Function} model
 * @return {mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.loadClass = function(model) {};

/**
 * Adds an instance method to documents constructed from Models compiled from this schema.
 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.
 * @param {string|!Object<string,!Function>} method_or_methodObj
 * @param {!Function=} fn
 * @return {mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.method = function(method_or_methodObj, fn) {};

/**
 * Gets/sets schema paths.
 * Sets a path (if arity 2)
 * Gets a path (if arity 1)
 * @param {string} path
 * @param {?=} constructor
 * @return {!SchemaType|mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.path = function(path, constructor) {};

/**
 * Returns the pathType of path for this schema.
 * @param {string} path
 * @return {string} whether it is a real, virtual, nested, or ad-hoc/undefined path.
 */
tsickle_declare_module.mongoose.Schema.prototype.pathType = function(path) {};

/**
 * Registers a plugin for this schema.
 * @param {function(!Schema, !Object): void} plugin callback
 * @param {!Object=} opts
 * @return {mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.plugin = function(plugin, opts) {};

/**
 * Defines a post hook for the document
 * Post hooks fire on the event emitted from document instances of Models compiled
 *   from this schema.
 * @template T
 * @param {string} method name of the method to hook
 * @param {function(?, T, function(!NativeError): void): void|function(T, function(!NativeError): void): void} fn callback
 * @return {mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.post = function(method, fn) {};

/**
 * Defines a pre hook for the document.
 * @param {string} method
 * @param {boolean|function(function(!NativeError): void): void} parallel_or_fn
 * @param {function(function(!NativeError): void, function(): void): void|function(!Error): void=} fn_or_errorCb
 * @param {function(!Error): void=} errorCb
 * @return {mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.pre = function(method, parallel_or_fn, fn_or_errorCb, errorCb) {};

/**
 * Adds a method call to the queue.
 * @param {string} name name of the document method to call later
 * @param {!Array<?>} args arguments to pass to the method
 * @return {mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.queue = function(name, args) {};

/**
 * Removes the given path (or [paths]).
 * @param {(string|!Array<string>)} path
 * @return {void}
 */
tsickle_declare_module.mongoose.Schema.prototype.remove = function(path) {};

/**
 * @param {boolean=} invalidate refresh the cache
 * @return {!Array<string>} an Array of path strings that are required by this schema.
 */
tsickle_declare_module.mongoose.Schema.prototype.requiredPaths = function(invalidate) {};

/**
 * Sets/gets a schema option.
 * @param {string} key option name
 * @param {?=} value
 * @return {?|mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.set = function(key, value) {};

/**
 * Adds static "class" methods to Models compiled from this schema.
 * @param {string|!Object<string,!Function>} name_or_nameObj
 * @param {!Function=} fn
 * @return {mongoose.Schema}
 */
tsickle_declare_module.mongoose.Schema.prototype.static = function(name_or_nameObj, fn) {};

/**
 * Creates a virtual type with the given name.
 * @param {string} name
 * @param {!Object=} options
 * @return {!VirtualType}
 */
tsickle_declare_module.mongoose.Schema.prototype.virtual = function(name, options) {};

/**
 * Returns the virtual type with the given name.
 * @param {string} name
 * @return {!VirtualType}
 */
tsickle_declare_module.mongoose.Schema.prototype.virtualpath = function(name) {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SchemaOptions = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.autoIndex;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.bufferCommands;
 /** @type {(number|boolean|{size: number, max: number, autoIndexId: boolean})} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.capped;
 /** @type {string} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.collection;
 /** @type {string} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.discriminatorKey;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.emitIndexErrors;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.id;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype._id;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.minimize;
 /** @type {string} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.read;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.safe;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.shardKey;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.strict;
 /** @type {!Object} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.toJSON;
 /** @type {!Object} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.toObject;
 /** @type {string} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.typeKey;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.useNestedStrict;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.validateBeforeSave;
 /** @type {(string|boolean)} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.versionKey;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.retainKeyOrder;
 /** @type {!Object} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.skipVersioning;
 /** @type {!Object} */
tsickle_declare_module.mongoose.SchemaOptions.prototype.timestamps;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SchemaDefinition = function() {};

/* TODO: IndexSignature: tsickle_declare_module.mongoose */
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SchemaTypeOpts = function() {};
 /** @type {T} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.type;
 /** @type {(T|!SchemaTypeOpts.DefaultFn<T>)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.default;
 /** @type {function(T, mongoose.SchemaTypeOpts): (!Object|T)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.get;
 /** @type {(string|boolean|!SchemaTypeOpts.IndexOpts)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.index;
 /** @type {(string|boolean|!Object|!SchemaTypeOpts.RequiredFn<T>|!Array<?>)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.required;
 /** @type {(boolean|!Object)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.select;
 /** @type {function(T, mongoose.SchemaTypeOpts): (!Object|T)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.set;
 /** @type {(boolean|!Object)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.sparse;
 /** @type {(boolean|!Object)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.text;
 /** @type {(!Object|!RegExp|!Array<?>|!SchemaTypeOpts.ValidateFn<T>|!SchemaTypeOpts.ValidateOpts|!Array<!SchemaTypeOpts.ValidateOpts>)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.validate;
 /** @type {(boolean|!Object)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.unique;
 /** @type {(!Object|!Array<T>|!SchemaTypeOpts.EnumOpts<T>)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.enum;
 /** @type {(boolean|!Object)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.lowercase;
 /** @type {(!Object|!RegExp|!Array<?>)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.match;
 /** @type {(number|!Object|!Array<?>)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.maxlength;
 /** @type {(number|!Object|!Array<?>)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.minlength;
 /** @type {(boolean|!Object)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.trim;
 /** @type {(boolean|!Object)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.uppercase;
 /** @type {(number|!Object|!Array<?>|!Date)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.min;
 /** @type {(number|!Object|!Array<?>|!Date)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.max;
 /** @type {(string|number|!Object)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.expires;
 /** @type {(boolean|!Object)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.prototype.auto;

/* TODO: IndexSignature: tsickle_declare_module.mongoose */
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SchemaTypeOpts.DefaultFn = function() {};

/* TODO: CallSignature: tsickle_declare_module.mongoose.SchemaTypeOpts */
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SchemaTypeOpts.RequiredFn = function() {};

/* TODO: CallSignature: tsickle_declare_module.mongoose.SchemaTypeOpts */
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SchemaTypeOpts.ValidateFn = function() {};

/* TODO: CallSignature: tsickle_declare_module.mongoose.SchemaTypeOpts */
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SchemaTypeOpts.ValidateOpts = function() {};
 /** @type {(!Function|!RegExp)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.ValidateOpts.prototype.validator;
 /** @type {string} */
tsickle_declare_module.mongoose.SchemaTypeOpts.ValidateOpts.prototype.msg;
 /** @type {string} */
tsickle_declare_module.mongoose.SchemaTypeOpts.ValidateOpts.prototype.type;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SchemaTypeOpts.EnumOpts = function() {};
 /** @type {!Array<T>} */
tsickle_declare_module.mongoose.SchemaTypeOpts.EnumOpts.prototype.values;
 /** @type {string} */
tsickle_declare_module.mongoose.SchemaTypeOpts.EnumOpts.prototype.message;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SchemaTypeOpts.IndexOpts = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaTypeOpts.IndexOpts.prototype.background;
 /** @type {(string|number)} */
tsickle_declare_module.mongoose.SchemaTypeOpts.IndexOpts.prototype.expires;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaTypeOpts.IndexOpts.prototype.sparse;
 /** @type {string} */
tsickle_declare_module.mongoose.SchemaTypeOpts.IndexOpts.prototype.type;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SchemaTypeOpts.IndexOpts.prototype.unique;
/**
 * @extends {MongooseDocumentOptionals}
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.MongooseDocument = function() {};
 /** @type {!Object} */
tsickle_declare_module.mongoose.MongooseDocument.prototype.errors;
 /** @type {?} */
tsickle_declare_module.mongoose.MongooseDocument.prototype._id;
 /** @type {boolean} */
tsickle_declare_module.mongoose.MongooseDocument.prototype.isNew;
 /** @type {!Schema} */
tsickle_declare_module.mongoose.MongooseDocument.prototype.schema;

/**
 * Checks if a path is set to its default.
 * @param {string=} path
 * @return {boolean}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.$isDefault = function(path) {};

/**
 * Takes a populated field and returns it to its unpopulated state.
 * If the path was not populated, this is a no-op.
 * @param {string} path
 * @return {void}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.depopulate = function(path) {};

/**
 * Returns true if the Document stores the same data as doc.
 * Documents are considered equal when they have matching _ids, unless neither document
 * has an _id, in which case this function falls back to usin deepEqual().
 * @param {!MongooseDocument} doc a document to compare
 * @return {boolean}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.equals = function(doc) {};

/**
 * Explicitly executes population and returns a promise.
 * Useful for ES2015 integration.
 * @return {!Promise<mongoose.MongooseDocument>} promise that resolves to the document when population is done
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.execPopulate = function() {};

/**
 * Returns the value of a path.
 * @param {string} path
 * @param {?=} type optionally specify a type for on-the-fly attributes
 * @return {?}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.get = function(path, type) {};

/**
 * Initializes the document without setters or marking anything modified.
 * Called internally after a document is returned from mongodb.
 * @param {!MongooseDocument} doc document returned by mongo
 * @param {function(): void|!Object=} fn_or_opts callback
 * @param {function(): void=} fn
 * @return {mongoose.MongooseDocument}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.init = function(doc, fn_or_opts, fn) {};

/**
 * Helper for console.log
 * @param {!Object=} options
 * @return {?}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.inspect = function(options) {};

/**
 * Marks a path as invalid, causing validation to fail.
 * The errorMsg argument will become the message of the ValidationError.
 * The value argument (if passed) will be available through the ValidationError.value property.
 * @param {string} path the field to invalidate
 * @param {(string|!NativeError)} errorMsg the error which states the reason path was invalid
 * @param {?} value optional invalid value
 * @param {string=} kind optional kind property for the error
 * @return {(boolean|!ValidationError)} the current ValidationError, with all currently invalidated paths
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.invalidate = function(path, errorMsg, value, kind) {};

/**
 * Returns true if path was directly set and modified, else false.
 * @param {string} path
 * @return {boolean}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.isDirectModified = function(path) {};

/**
 * Checks if path was initialized
 * @param {string} path
 * @return {boolean}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.isInit = function(path) {};

/**
 * Returns true if this document was modified, else false.
 * If path is given, checks if a path or any full path containing path as part of its path
 * chain has been modified.
 * @param {string=} path
 * @return {boolean}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.isModified = function(path) {};

/**
 * Checks if path was selected in the source query which initialized this document.
 * @param {string} path
 * @return {boolean}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.isSelected = function(path) {};

/**
 * Marks the path as having pending changes to write to the db.
 * Very helpful when using Mixed types.
 * @param {string} path the path to mark modified
 * @return {void}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.markModified = function(path) {};

/**
 * Returns the list of paths that have been modified.
 * @return {!Array<string>}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.modifiedPaths = function() {};

/**
 * Populates document references, executing the callback when complete.
 * If you want to use promises instead, use this function with
 * execPopulate()
 * Population does not occur unless a callback is passed or you explicitly
 * call execPopulate(). Passing the same path a second time will overwrite
 * the previous path options. See Model.populate() for explaination of options.
 * @param {function(?, mongoose.MongooseDocument): void|string|(!ModelPopulateOptions|!Array<!ModelPopulateOptions>)} callback_or_path_or_options When passed, population is invoked
 * @param {function(?, mongoose.MongooseDocument): void|string=} callback_or_names
 * @param {function(?, mongoose.MongooseDocument): void=} callback
 * @return {mongoose.MongooseDocument}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.populate = function(callback_or_path_or_options, callback_or_names, callback) {};

/**
 * Gets _id(s) used during population of the given path. If the path was not populated, undefined is returned.
 * @param {string} path
 * @return {?}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.populated = function(path) {};

/**
 * Sets the value of a path, or many paths.
 * @param {string|!Object} path_or_value path or object of key/vals to set
 * @param {?=} val the value to set
 * @param {!Object|?=} options_or_type optionally specify options that modify the behavior of the set
 * @param {!Object=} options
 * @return {mongoose.MongooseDocument}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.set = function(path_or_value, val, options_or_type, options) {};

/**
 * The return value of this method is used in calls to JSON.stringify(doc).
 * This method accepts the same options as Document#toObject. To apply the
 * options to every document of your schema by default, set your schemas
 * toJSON option to the same argument.
 * @param {!DocumentToObjectOptions=} options
 * @return {!Object}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.toJSON = function(options) {};

/**
 * Converts this document into a plain javascript object, ready for storage in MongoDB.
 * Buffers are converted to instances of mongodb.Binary for proper storage.
 * @param {!DocumentToObjectOptions=} options
 * @return {!Object}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.toObject = function(options) {};

/**
 * Helper for console.log
 * @return {string}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.toString = function() {};

/**
 * Clears the modified state on the specified path.
 * @param {string} path the path to unmark modified
 * @return {void}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.unmarkModified = function(path) {};

/**
 * Sends an update command with this document _id as the query selector.
 * @param {!Object} doc
 * @param {function(?, ?): void|!ModelUpdateOptions=} callback_or_options
 * @param {function(?, ?): void=} callback
 * @return {!Query<?>}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.update = function(doc, callback_or_options, callback) {};

/**
 * Executes registered validation rules for this document.
 * @param {function(?): void|!Object=} callback_or_optional callback called after validation completes, passing an error if one occurred
 * @param {function(?): void=} callback
 * @return {!Promise<void>}
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.validate = function(callback_or_optional, callback) {};

/**
 * Executes registered validation rules (skipping asynchronous validators) for this document.
 * This method is useful if you need synchronous validation.
 * @param {(string|!Array<string>)=} pathsToValidate only validate the given paths
 * @return {!Error} MongooseError if there are errors during validation, or undefined if there is no error.
 */
tsickle_declare_module.mongoose.MongooseDocument.prototype.validateSync = function(pathsToValidate) {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.MongooseDocumentOptionals = function() {};
 /** @type {string} */
tsickle_declare_module.mongoose.MongooseDocumentOptionals.prototype.id;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.DocumentToObjectOptions = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.DocumentToObjectOptions.prototype.getters;
 /** @type {boolean} */
tsickle_declare_module.mongoose.DocumentToObjectOptions.prototype.virtuals;
 /** @type {boolean} */
tsickle_declare_module.mongoose.DocumentToObjectOptions.prototype.minimize;
 /** @type {function(?, !Object, !Object): ?} */
tsickle_declare_module.mongoose.DocumentToObjectOptions.prototype.transform;
 /** @type {boolean} */
tsickle_declare_module.mongoose.DocumentToObjectOptions.prototype.depopulate;
 /** @type {boolean} */
tsickle_declare_module.mongoose.DocumentToObjectOptions.prototype.versionKey;
 /** @type {boolean} */
tsickle_declare_module.mongoose.DocumentToObjectOptions.prototype.retainKeyOrder;
/** @const */
tsickle_declare_module.mongoose.Types = {};
/**
 * @extends {MongooseDocument}
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.Types.Subdocument = function() {};

/**
 * Returns the top level document of this sub-document.
 * @return {!MongooseDocument}
 */
tsickle_declare_module.mongoose.Types.Subdocument.prototype.ownerDocument = function() {};

/**
 * Null-out this subdoc
 * @param {function(?): void|!Object=} callback_or_options optional callback for compatibility with Document.prototype.remove
 * @param {function(?): void=} callback
 * @return {void}
 */
tsickle_declare_module.mongoose.Types.Subdocument.prototype.remove = function(callback_or_options, callback) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.Types.Array = function() {};

/**
 * Atomically shifts the array at most one time per document save().
 * Calling this mulitple times on an array before saving sends the same command as
 * calling it once. This update is implemented using the MongoDB $pop method which
 * enforces this restriction.
 * @return {T}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.$shift = function() {};

/**
 * Alias of pull
 * @param {...?} args
 * @return {Array}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.remove = function(args) {};

/**
 * Pops the array atomically at most one time per document save().
 * Calling this mulitple times on an array before saving sends the same command as
 * calling it once. This update is implemented using the MongoDB $pop method which
 * enforces this restriction.
 * @return {T}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.$pop = function() {};

/**
 * Adds values to the array if not already present.
 * @param {...?} args
 * @return {!Array<T>} the values that were added
 */
tsickle_declare_module.mongoose.Types.Array.prototype.addToSet = function(args) {};

/**
 * Return the index of obj or -1 if not found.
 * @param {?} obj he item to look for
 * @return {number}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.indexOf = function(obj) {};

/**
 * Helper for console.log
 * @return {?}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.inspect = function() {};

/**
 * Marks the entire array as modified, which if saved, will store it as a $set
 * operation, potentially overwritting any changes that happen between when you
 * retrieved the object and when you save it.
 * @param {...?} args
 * @return {number} new length of the array
 */
tsickle_declare_module.mongoose.Types.Array.prototype.nonAtomicPush = function(args) {};

/**
 * Wraps Array#pop with proper change tracking.
 * marks the entire array as modified which will pass the entire thing to $set
 * potentially overwritting any changes that happen between when you retrieved
 * the object and when you save it.
 * @return {T}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.pop = function() {};

/**
 * Pulls items from the array atomically. Equality is determined by casting
 * the provided value to an embedded document and comparing using
 * the Document.equals() function.
 * @param {...?} args
 * @return {Array}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.pull = function(args) {};

/**
 * Wraps Array#push with proper change tracking.
 * @param {...?} args
 * @return {number} new length of the array
 */
tsickle_declare_module.mongoose.Types.Array.prototype.push = function(args) {};

/**
 * Sets the casted val at index i and marks the array modified.
 * @param {number} i
 * @param {?} val
 * @return {Array}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.set = function(i, val) {};

/**
 * Wraps Array#shift with proper change tracking.
 * Marks the entire array as modified, which if saved, will store it as a $set operation,
 * potentially overwritting any changes that happen between when you retrieved the object
 * and when you save it.
 * @return {T}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.shift = function() {};

/**
 * Wraps Array#splice with proper change tracking and casting.
 * Marks the entire array as modified, which if saved, will store it as a $set operation,
 * potentially overwritting any changes that happen between when you retrieved the object
 * and when you save it.
 * @param {...?} args
 * @return {!Array<T>}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.splice = function(args) {};

/**
 * Returns a native js Array.
 * @param {!Object=} options
 * @return {!Array<T>}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.toObject = function(options) {};

/**
 * Wraps Array#unshift with proper change tracking.
 * Marks the entire array as modified, which if saved, will store it as a $set operation,
 * potentially overwritting any changes that happen between when you retrieved the object
 * and when you save it.
 * @param {...?} args
 * @return {number}
 */
tsickle_declare_module.mongoose.Types.Array.prototype.unshift = function(args) {};
/**
 * @extends {Types.Array}
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.Types.DocumentArray = function() {};

/**
 * Creates a subdocument casted to this schema.
 * This is the same subdocument constructor used for casting.
 * @param {!Object} obj the value to cast to this arrays SubDocument schema
 * @return {T}
 */
tsickle_declare_module.mongoose.Types.DocumentArray.prototype.create = function(obj) {};

/**
 * Searches array items for the first document with a matching _id.
 * @param {(string|number|?|!NativeBuffer)} id
 * @return {T} the subdocument or null if not found.
 */
tsickle_declare_module.mongoose.Types.DocumentArray.prototype.id = function(id) {};

/**
 * Helper for console.log
 * @return {!Array<T>}
 */
tsickle_declare_module.mongoose.Types.DocumentArray.prototype.inspect = function() {};

/**
 * Returns a native js Array of plain js objects
 * @param {!Object=} options optional options to pass to each documents toObject
 *   method call during conversion
 * @return {!Array<T>}
 */
tsickle_declare_module.mongoose.Types.DocumentArray.prototype.toObject = function(options) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.Types.Buffer = function() {};

/**
 * Copies the buffer.
 * Buffer#copy does not mark target as modified so you must copy
 * from a MongooseBuffer for it to work as expected. This is a
 * work around since copy modifies the target, not this.
 * @param {!NativeBuffer} target
 * @param {...?} nodeBufferArgs
 * @return {number}
 */
tsickle_declare_module.mongoose.Types.Buffer.prototype.copy = function(target, nodeBufferArgs) {};

/**
 * Determines if this buffer is equals to other buffer
 * @param {!NativeBuffer} other
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Types.Buffer.prototype.equals = function(other) {};

/**
 * Sets the subtype option and marks the buffer modified.
 * @param {number} subtype
 * @return {void}
 */
tsickle_declare_module.mongoose.Types.Buffer.prototype.subtype = function(subtype) {};

/**
 * Converts this buffer to its Binary type representation.
 * @param {number=} subtype
 * @return {?}
 */
tsickle_declare_module.mongoose.Types.Buffer.prototype.toObject = function(subtype) {};

/**
 * Writes the buffer.
 * @param {string} string
 * @param {...?} nodeBufferArgs
 * @return {number}
 */
tsickle_declare_module.mongoose.Types.Buffer.prototype.write = function(string, nodeBufferArgs) {};
 /** @type {?} */
tsickle_declare_module.mongoose.Types.ObjectId;

/** @typedef {?} */
tsickle_declare_module.mongoose.Types.ObjectIdConstructor;
/**
 * @extends {Decimal128}
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.Types.Decimal128 = function() {};
/**
 * @extends {MongooseDocument}
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.Types.Embedded = function() {};

/**
 * Helper for console.log
 * @return {!Object}
 */
tsickle_declare_module.mongoose.Types.Embedded.prototype.inspect = function() {};

/**
 * Marks a path as invalid, causing validation to fail.
 * @param {string} path the field to invalidate
 * @param {(string|!NativeError)} err error which states the reason path was invalid
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Types.Embedded.prototype.invalidate = function(path, err) {};

/**
 * Returns the top level document of this sub-document.
 * @return {!MongooseDocument}
 */
tsickle_declare_module.mongoose.Types.Embedded.prototype.ownerDocument = function() {};

/**
 * Returns this sub-documents parent document.
 * @return {!MongooseDocument}
 */
tsickle_declare_module.mongoose.Types.Embedded.prototype.parent = function() {};

/**
 * Returns this sub-documents parent array.
 * @return {!Types.DocumentArray<!MongooseDocument>}
 */
tsickle_declare_module.mongoose.Types.Embedded.prototype.parentArray = function() {};

/**
 * Removes the subdocument from its parent array.
 * @param {{noop: boolean}=} options
 * @param {function(?): void=} fn
 * @return {Embedded}
 */
tsickle_declare_module.mongoose.Types.Embedded.prototype.remove = function(options, fn) {};

/**
 * Marks the embedded doc modified.
 * @param {string} path the path which changed
 * @return {void}
 */
tsickle_declare_module.mongoose.Types.Embedded.prototype.markModified = function(path) {};
/**
 * @extends {DocumentQuery}
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.Query = function() {};
/**
 * @extends {mquery}
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.DocumentQuery = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.DocumentQuery.use$geoWithin;

/**
 * Specifies a javascript function or expression to pass to MongoDBs query system.
 * Only use $where when you have a condition that cannot be met using other MongoDB
 * operators like $lt. Be sure to read about all of its caveats before using.
 * @param {(string|!Function)} js javascript string or function
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.$where = function(js) {};

/**
 * Specifies an $all query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {number|string} val_or_path
 * @param {number=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.all = function(val_or_path, val) {};

/**
 * Specifies arguments for a $and condition.
 * @param {!Array<!Object>} array array of conditions
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.and = function(array) {};

/**
 * Specifies the batchSize option. Cannot be used with distinct()
 * @param {number} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.batchSize = function(val) {};

/**
 * Specifies a $box condition
 * @param {!Object|!Array<number>} val_or_lower
 * @param {!Array<number>=} upper
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.box = function(val_or_lower, upper) {};

/**
 * Casts this query to the schema of model, If obj is present, it is cast instead of this query.
 * @param {?} model
 * @param {!Object=} obj
 * @return {!Object}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.cast = function(model, obj) {};

/**
 * Executes the query returning a Promise which will be
 * resolved with either the doc(s) or rejected with the error.
 * Like .then(), but only takes a rejection handler.
 * @template TRes
 * @param {function(?): (void|TRes|!PromiseLike<TRes>)=} reject
 * @return {!Promise<TRes>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.catch = function(reject) {};

/**
 * DEPRECATED Alias for circle
 * Specifies a $center or $centerSphere condition.
 * @deprecated Use circle instead.
 * @param {!Object|string} area_or_path
 * @param {!Object=} area
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.center = function(area_or_path, area) {};

/**
 * DEPRECATED Specifies a $centerSphere condition
 * @deprecated Use circle instead.
 * @param {string|!Object} path_or_val
 * @param {!Object=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.centerSphere = function(path_or_val, val) {};

/**
 * Specifies a $center or $centerSphere condition.
 * @param {!Object|string} area_or_path
 * @param {!Object=} area
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.circle = function(area_or_path, area) {};

/**
 * Adds a collation to this op (MongoDB 3.4 and up)
 * @param {!CollationOptions} value
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.collation = function(value) {};

/**
 * Specifies the comment option. Cannot be used with distinct()
 * @param {string} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.comment = function(val) {};

/**
 * Specifying this query as a count query. Passing a callback executes the query.
 * @param {function(?, number): void|!Object=} callback_or_criteria
 * @param {function(?, number): void=} callback
 * @return {!Query<number>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.count = function(callback_or_criteria, callback) {};

/**
 * Returns a wrapper around a mongodb driver cursor. A Query<T>Cursor exposes a
 * Streams3-compatible interface, as well as a .next() function.
 * @param {!Object=} options
 * @return {!QueryCursor<DocType>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.cursor = function(options) {};

/**
 * Declares or executes a distict() operation. Passing a callback executes the query.
 * @param {function(?, !Array<?>): void|string=} callback_or_field
 * @param {function(?, !Array<?>): void|(!Object|!Query<?>)=} callback_or_criteria
 * @param {function(?, !Array<?>): void=} callback
 * @return {!Query<!Array<?>>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.distinct = function(callback_or_field, callback_or_criteria, callback) {};

/**
 * Specifies an $elemMatch condition
 * @param {function(!Query<?>): void|!Object|(string|!Object|!Function)} criteria_or_path
 * @param {function(!Query<?>): void|!Object=} criteria
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.elemMatch = function(criteria_or_path, criteria) {};

/**
 * Specifies the complementary comparison value for paths specified with where()
 * @param {!Object} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.equals = function(val) {};

/**
 * Executes the query
 * @param {function(?, T): void|(string|!Function)=} callback_or_operation
 * @param {function(?, T): void=} callback
 * @return {!Promise<T>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.exec = function(callback_or_operation, callback) {};

/**
 * Specifies an $exists condition
 * @param {boolean|string=} val_or_path
 * @param {boolean=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.exists = function(val_or_path, val) {};

/**
 * Finds documents. When no callback is passed, the query is not executed. When the
 * query is executed, the result will be an array of documents.
 * @param {function(?, !Array<DocType>): void|!Object=} callback_or_criteria
 * @param {function(?, !Array<DocType>): void=} callback
 * @return {!DocumentQuery<!Array<DocType>, DocType>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.find = function(callback_or_criteria, callback) {};

/**
 * Declares the query a findOne operation. When executed, the first found document is
 * passed to the callback. Passing a callback executes the query. The result of the query
 * is a single document.
 * @param {function(?, DocType): void|!Object=} callback_or_criteria
 * @param {function(?, DocType): void=} callback
 * @return {!DocumentQuery<DocType, DocType>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.findOne = function(callback_or_criteria, callback) {};

/**
 * Issues a mongodb findAndModify remove command.
 * Finds a matching document, removes it, passing the found document (if any) to the
 * callback. Executes immediately if callback is passed.
 * @param {function(?, DocType, ?): void|!Object=} callback_or_conditions
 * @param {function(?, DocType, ?): void|!QueryFindOneAndRemoveOptions=} callback_or_options
 * @param {function(?, DocType, ?): void=} callback
 * @return {!DocumentQuery<DocType, DocType>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.findOneAndRemove = function(callback_or_conditions, callback_or_options, callback) {};

/**
 * Issues a mongodb findAndModify update command.
 * Finds a matching document, updates it according to the update arg, passing any options, and returns
 * the found document (if any) to the callback. The query executes immediately if callback is passed.
 * @param {function(?, DocType): void|!Object|(!Object|!Query<?>)=} callback_or_update_or_query
 * @param {function(?, DocType, ?): void|!Object=} callback_or_update
 * @param {function(?, DocType, ?): void|!QueryFindOneAndUpdateOptions=} callback_or_options
 * @param {function(?, DocType, ?): void=} callback
 * @return {!DocumentQuery<DocType, DocType>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.findOneAndUpdate = function(callback_or_update_or_query, callback_or_update, callback_or_options, callback) {};

/**
 * Specifies a $geometry condition. geometry() must come after either intersects() or within().
 * @param {{type: string, coordinates: !Array<?>}} object Must contain a type property which is a String and a coordinates property which
 *   is an Array. See the examples.
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.geometry = function(object) {};

/**
 * Returns the current query conditions as a JSON object.
 * @return {?} current query conditions
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.getQuery = function() {};

/**
 * Returns the current update operations as a JSON object.
 * @return {?} current update operations
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.getUpdate = function() {};

/**
 * Specifies a $gt query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {number|string} val_or_path
 * @param {number=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.gt = function(val_or_path, val) {};

/**
 * Specifies a $gte query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {number|string} val_or_path
 * @param {number=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.gte = function(val_or_path, val) {};

/**
 * Sets query hints.
 * @param {!Object} val a hint object
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.hint = function(val) {};

/**
 * Specifies an $in query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {!Array<?>|string} val_or_path
 * @param {!Array<?>=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.in = function(val_or_path, val) {};

/**
 * Declares an intersects query for geometry(). MUST be used after where().
 * @param {!Object=} arg
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.intersects = function(arg) {};

/**
 * Sets the lean option.
 * Documents returned from queries with the lean option enabled are plain
 * javascript objects, not MongooseDocuments. They have no save method,
 * getters/setters or other Mongoose magic applied.
 * @param {boolean=} bool defaults to true
 * @return {!Query<!Object>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.lean = function(bool) {};

/**
 * Specifies the maximum number of documents the query will return. Cannot be used with distinct()
 * @param {number} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.limit = function(val) {};

/**
 * Specifies a $lt query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {number|string} val_or_path
 * @param {number=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.lt = function(val_or_path, val) {};

/**
 * Specifies a $lte query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {number|string} val_or_path
 * @param {number=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.lte = function(val_or_path, val) {};

/**
 * Specifies a $maxDistance query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {number|string} val_or_path
 * @param {number=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.maxDistance = function(val_or_path, val) {};

/**
 * @deprecated Alias of maxScan
 * @param {number} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.maxscan = function(val) {};

/**
 * Specifies the maxScan option. Cannot be used with distinct()
 * @param {number} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.maxScan = function(val) {};

/**
 * Merges another Query or conditions object into this one.
 * When a Query is passed, conditions, field selection and options are merged.
 * @param {(!Object|!Query<?>)} source
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.merge = function(source) {};

/**
 * Specifies a $mod condition
 * @param {!Array<number>|string} val_or_path
 * @param {!Array<number>=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.mod = function(val_or_path, val) {};

/**
 * Specifies a $ne query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {?|string} val_or_path
 * @param {?=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.ne = function(val_or_path, val) {};

/**
 * Specifies a $near or $nearSphere condition.
 * @param {!Object|string} val_or_path
 * @param {!Object=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.near = function(val_or_path, val) {};

/**
 * DEPRECATED Specifies a $nearSphere condition
 * @deprecated Use query.near() instead with the spherical option set to true.
 * @param {!Object|string} val_or_path
 * @param {!Object=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.nearSphere = function(val_or_path, val) {};

/**
 * Specifies a $nin query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {!Array<?>|string} val_or_path
 * @param {!Array<?>=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.nin = function(val_or_path, val) {};

/**
 * Specifies arguments for a $nor condition.
 * @param {!Array<!Object>} array array of conditions
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.nor = function(array) {};

/**
 * Specifies arguments for an $or condition.
 * @param {!Array<!Object>} array array of conditions
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.or = function(array) {};

/**
 * Specifies a $polygon condition
 * @param {...!Array<number>|string} coordinatePairs_or_path
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.polygon = function(coordinatePairs_or_path) {};

/**
 * Specifies paths which should be populated with other documents.
 * Paths are populated after the query executes and a response is received. A separate
 * query is then executed for each path specified for population. After a response for
 * each query has also been returned, the results are passed to the callback.
 * @param {(string|!Object)|(!ModelPopulateOptions|!Array<!ModelPopulateOptions>)} path_or_options either the path to populate or an object specifying all parameters
 * @param {(string|!Object)=} select Field selection for the population query
 * @param {?=} model The model you wish to use for population. If not specified, populate
 *   will look up the model by the name in the Schema's ref field.
 * @param {!Object=} match Conditions for the population query
 * @param {!Object=} options Options for the population query (sort, etc)
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.populate = function(path_or_options, select, model, match, options) {};

/**
 * Determines the MongoDB nodes from which to read.
 * \@tags optional tags for this query
 * @param {string} pref one of the listed preference options or aliases
 * @param {!Array<!Object>=} tags
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.read = function(pref, tags) {};

/**
 * Specifies a $regex query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {!RegExp|string} val_or_path
 * @param {!RegExp=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.regex = function(val_or_path, val) {};

/**
 * Declare and/or execute this query as a remove() operation.
 * The operation is only executed when a callback is passed. To force execution without a callback,
 * you must first call remove() and then execute it by using the exec() method.
 * @param {function(?): void|(!Object|!Query<?>)=} callback_or_criteria
 * @param {function(?): void=} callback
 * @return {!Query<?>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.remove = function(callback_or_criteria, callback) {};

/**
 * Specifies which document fields to include or exclude (also known as the query "projection")
 * @param {(string|!Object)} arg
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.select = function(arg) {};

/**
 * Determines if field selection has been made.
 * @return {boolean}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.selected = function() {};

/**
 * Determines if exclusive field selection has been made.
 * @return {boolean}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.selectedExclusively = function() {};

/**
 * Determines if inclusive field selection has been made.
 * @return {boolean}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.selectedInclusively = function() {};

/**
 * Sets query options.
 * @param {!Object} options
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.setOptions = function(options) {};

/**
 * Specifies a $size query condition.
 * When called with one argument, the most recent path passed to where() is used.
 * @param {number|string} val_or_path
 * @param {number=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.size = function(val_or_path, val) {};

/**
 * Specifies the number of documents to skip. Cannot be used with distinct()
 * @param {number} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.skip = function(val) {};

/**
 * DEPRECATED Sets the slaveOk option.
 * @deprecated in MongoDB 2.2 in favor of read preferences.
 * @param {boolean=} v defaults to true
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.slaveOk = function(v) {};

/**
 * Specifies a $slice projection for an array.
 * @param {(number|!Array<number>)|string} val_or_path number/range of elements to slice
 * @param {(number|!Array<number>)=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.slice = function(val_or_path, val) {};

/**
 * Specifies this query as a snapshot query. Cannot be used with distinct()
 * @param {boolean=} v
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.snapshot = function(v) {};

/**
 * Sets the sort order
 * If an object is passed, values allowed are asc, desc, ascending, descending, 1, and -1.
 * If a string is passed, it must be a space delimited list of path names. The
 * sort order of each path is ascending unless the path name is prefixed with -
 * which will be treated as descending.
 * @param {(string|!Object)} arg
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.sort = function(arg) {};

/**
 * Returns a Node.js 0.8 style read stream interface.
 * @param {{transform: !Function}=} options
 * @return {!QueryStream}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.stream = function(options) {};

/**
 * Sets the tailable option (for use with capped collections). Cannot be used with distinct()
 * @param {boolean=} bool defaults to true
 * @param {{numberOfRetries: number, tailableRetryInterval: number}=} opts options to set
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.tailable = function(bool, opts) {};

/**
 * Executes this query and returns a promise
 * @template TRes
 * @param {function(T): (void|TRes|!PromiseLike<TRes>)=} resolve
 * @param {function(?): (void|TRes|!PromiseLike<TRes>)=} reject
 * @return {!Promise<TRes>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.then = function(resolve, reject) {};

/**
 * Converts this query to a customized, reusable query
 * constructor with all arguments and options retained.
 * @template T, Doc
 * @return {function(new: (!Query<T>), !Array<?>): ?|function(new: (!DocumentQuery<T, Doc>), !Array<?>): ?}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.toConstructor = function() {};

/**
 * Declare and/or execute this query as an update() operation.
 * All paths passed that are not $atomic operations will become $set ops.
 * @param {function(?, number): void|!Object=} callback_or_doc_or_criteria
 * @param {function(?, number): void|!Object=} callback_or_doc
 * @param {function(?, number): void|!QueryUpdateOptions=} callback_or_options
 * @param {function(?, number): void=} callback
 * @return {!Query<number>}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.update = function(callback_or_doc_or_criteria, callback_or_doc, callback_or_options, callback) {};

/**
 * Specifies a path for use with chaining.
 * @param {(string|!Object)=} path
 * @param {?=} val
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.where = function(path, val) {};

/**
 * Defines a $within or $geoWithin argument for geo-spatial queries.
 * @param {!Object|!Array<number>=} val_or_coordinate
 * @param {...!Array<number>} coordinatePairs
 * @return {mongoose.DocumentQuery}
 */
tsickle_declare_module.mongoose.DocumentQuery.prototype.within = function(val_or_coordinate, coordinatePairs) {};
/**
 * @constructor
 * @struct
 */
tsickle_declare_module.mongoose.mquery = function() {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.QueryFindOneAndRemoveOptions = function() {};
 /** @type {?} */
tsickle_declare_module.mongoose.QueryFindOneAndRemoveOptions.prototype.sort;
 /** @type {number} */
tsickle_declare_module.mongoose.QueryFindOneAndRemoveOptions.prototype.maxTimeMS;
 /** @type {boolean} */
tsickle_declare_module.mongoose.QueryFindOneAndRemoveOptions.prototype.passRawResult;
/**
 * @extends {QueryFindOneAndRemoveOptions}
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.QueryFindOneAndUpdateOptions = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.QueryFindOneAndUpdateOptions.prototype.new;
 /** @type {boolean} */
tsickle_declare_module.mongoose.QueryFindOneAndUpdateOptions.prototype.upsert;
 /** @type {(string|!Object)} */
tsickle_declare_module.mongoose.QueryFindOneAndUpdateOptions.prototype.fields;
 /** @type {boolean} */
tsickle_declare_module.mongoose.QueryFindOneAndUpdateOptions.prototype.runValidators;
 /** @type {boolean} */
tsickle_declare_module.mongoose.QueryFindOneAndUpdateOptions.prototype.setDefaultsOnInsert;
 /** @type {string} */
tsickle_declare_module.mongoose.QueryFindOneAndUpdateOptions.prototype.context;
/**
 * @extends {ModelUpdateOptions}
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.QueryUpdateOptions = function() {};
 /** @type {string} */
tsickle_declare_module.mongoose.QueryUpdateOptions.prototype.context;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.CollationOptions = function() {};
 /** @type {string} */
tsickle_declare_module.mongoose.CollationOptions.prototype.locale;
 /** @type {boolean} */
tsickle_declare_module.mongoose.CollationOptions.prototype.caseLevel;
 /** @type {string} */
tsickle_declare_module.mongoose.CollationOptions.prototype.caseFirst;
 /** @type {number} */
tsickle_declare_module.mongoose.CollationOptions.prototype.strength;
 /** @type {boolean} */
tsickle_declare_module.mongoose.CollationOptions.prototype.numericOrdering;
 /** @type {string} */
tsickle_declare_module.mongoose.CollationOptions.prototype.alternate;
 /** @type {string} */
tsickle_declare_module.mongoose.CollationOptions.prototype.maxVariable;
 /** @type {boolean} */
tsickle_declare_module.mongoose.CollationOptions.prototype.backwards;
/** @const */
tsickle_declare_module.mongoose.Schema.Types = {};

/**
 * @constructor
 * @struct
 * Array SchemaType constructor
 * @param {string} key
 * @param {!SchemaType=} cast
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.Array = function(key, cast, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.Array.schemaName;

/**
 * Check if the given value satisfies a required validator. The given value
 * must be not null nor undefined, and have a non-zero length.
 * @template T
 * @param {T} value
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Schema.Types.Array.prototype.checkRequired = function(value) {};

/**
 * @constructor
 * @struct
 * String SchemaType constructor.
 * @param {string} key
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.String = function(key, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.String.schemaName;

/**
 * Check if the given value satisfies a required validator.
 * @param {?} value
 * @param {!MongooseDocument} doc
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Schema.Types.String.prototype.checkRequired = function(value, doc) {};

/**
 * Adds an enum validator
 * @param {(string|!Object|!Array<string>)} args enumeration values
 * @return {String}
 */
tsickle_declare_module.mongoose.Schema.Types.String.prototype.enum = function(args) {};

/**
 * Adds a lowercase setter.
 * @return {String}
 */
tsickle_declare_module.mongoose.Schema.Types.String.prototype.lowercase = function() {};

/**
 * Sets a regexp validator. Any value that does not pass regExp.test(val) will fail validation.
 * @param {!RegExp} regExp regular expression to test against
 * @param {string=} message optional custom error message
 * @return {String}
 */
tsickle_declare_module.mongoose.Schema.Types.String.prototype.match = function(regExp, message) {};

/**
 * Sets a maximum length validator.
 * @param {number} value maximum string length
 * @param {string=} message optional custom error message
 * @return {String}
 */
tsickle_declare_module.mongoose.Schema.Types.String.prototype.maxlength = function(value, message) {};

/**
 * Sets a minimum length validator.
 * @param {number} value minimum string length
 * @param {string=} message optional custom error message
 * @return {String}
 */
tsickle_declare_module.mongoose.Schema.Types.String.prototype.minlength = function(value, message) {};

/**
 * Adds a trim setter. The string value will be trimmed when set.
 * @return {String}
 */
tsickle_declare_module.mongoose.Schema.Types.String.prototype.trim = function() {};

/**
 * Adds an uppercase setter.
 * @return {String}
 */
tsickle_declare_module.mongoose.Schema.Types.String.prototype.uppercase = function() {};

/**
 * @constructor
 * @struct
 * SubdocsArray SchemaType constructor
 * @param {string} key
 * @param {!Schema} schema
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.DocumentArray = function(key, schema, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.DocumentArray.schemaName;

/**
 * @constructor
 * @struct
 * Number SchemaType constructor.
 * @param {string} key
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.Number = function(key, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.Number.schemaName;

/**
 * Check if the given value satisfies a required validator.
 * @param {?} value
 * @param {!MongooseDocument} doc
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Schema.Types.Number.prototype.checkRequired = function(value, doc) {};

/**
 * Sets a maximum number validator.
 * @param {number} maximum number
 * @param {string=} message optional custom error message
 * @return {Number}
 */
tsickle_declare_module.mongoose.Schema.Types.Number.prototype.max = function(maximum, message) {};

/**
 * Sets a minimum number validator.
 * @param {number} value minimum number
 * @param {string=} message optional custom error message
 * @return {Number}
 */
tsickle_declare_module.mongoose.Schema.Types.Number.prototype.min = function(value, message) {};

/**
 * @constructor
 * @struct
 * Date SchemaType constructor.
 * @param {string} key
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.Date = function(key, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.Date.schemaName;

/**
 * Check if the given value satisfies a required validator. To satisfy
 * a required validator, the given value must be an instance of Date.
 * @param {?} value
 * @param {!MongooseDocument} doc
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Schema.Types.Date.prototype.checkRequired = function(value, doc) {};

/**
 * Declares a TTL index (rounded to the nearest second) for Date types only.
 * @param {(string|number)} when
 * @return {Date}
 */
tsickle_declare_module.mongoose.Schema.Types.Date.prototype.expires = function(when) {};

/**
 * Sets a maximum date validator.
 * @param {!NativeDate} maximum date
 * @param {string=} message optional custom error message
 * @return {Date}
 */
tsickle_declare_module.mongoose.Schema.Types.Date.prototype.max = function(maximum, message) {};

/**
 * Sets a minimum date validator.
 * @param {!NativeDate} value minimum date
 * @param {string=} message optional custom error message
 * @return {Date}
 */
tsickle_declare_module.mongoose.Schema.Types.Date.prototype.min = function(value, message) {};

/**
 * @constructor
 * @struct
 * Buffer SchemaType constructor
 * @param {string} key
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.Buffer = function(key, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.Buffer.schemaName;

/**
 * Check if the given value satisfies a required validator. To satisfy a
 * required validator, a buffer must not be null or undefined and have
 * non-zero length.
 * @param {?} value
 * @param {!MongooseDocument} doc
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Schema.Types.Buffer.prototype.checkRequired = function(value, doc) {};

/**
 * @constructor
 * @struct
 * Boolean SchemaType constructor.
 * @param {string} path
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.Boolean = function(path, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.Boolean.schemaName;

/**
 * Check if the given value satisfies a required validator. For a
 * boolean to satisfy a required validator, it must be strictly
 * equal to true or to false.
 * @param {?} value
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Schema.Types.Boolean.prototype.checkRequired = function(value) {};

/**
 * @constructor
 * @struct
 * ObjectId SchemaType constructor.
 * @param {string} key
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.ObjectId = function(key, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.ObjectId.schemaName;

/**
 * Adds an auto-generated ObjectId default if turnOn is true.
 * @param {boolean} turnOn auto generated ObjectId defaults
 * @return {ObjectId}
 */
tsickle_declare_module.mongoose.Schema.Types.ObjectId.prototype.auto = function(turnOn) {};

/**
 * Check if the given value satisfies a required validator.
 * @param {?} value
 * @param {!MongooseDocument} doc
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Schema.Types.ObjectId.prototype.checkRequired = function(value, doc) {};

/**
 * @constructor
 * @struct
 * Decimal128 SchemaType constructor.
 * @param {string} key
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.Decimal128 = function(key, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.Decimal128.schemaName;

/**
 * Check if the given value satisfies a required validator.
 * @param {?} value
 * @param {!MongooseDocument} doc
 * @return {boolean}
 */
tsickle_declare_module.mongoose.Schema.Types.Decimal128.prototype.checkRequired = function(value, doc) {};

/**
 * @constructor
 * @struct
 * Mixed SchemaType constructor.
 * @param {string} path
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.Mixed = function(path, options) {};
 /** @type {string} */
tsickle_declare_module.mongoose.Schema.Types.Mixed.schemaName;

/**
 * @constructor
 * @struct
 * Sub-schema schematype constructor
 * @param {!Schema} schema
 * @param {string} key
 * @param {!Object=} options
 */
tsickle_declare_module.mongoose.Schema.Types.Embedded = function(schema, key, options) {};

/**
 * @constructor
 * @struct
 * Aggregate constructor used for building aggregation pipelines.
 * Returned when calling Model.aggregate().
 * @param {(!Object|!Array<?>)=} ops aggregation operator(s) or operator array
 * @param {...?} args
 */
tsickle_declare_module.mongoose.Aggregate = function(ops, args) {};

/**
 * Adds a cursor flag
 * @param {string} flag
 * @param {boolean} value
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.addCursorFlag = function(flag, value) {};

/**
 * Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0)
 * @param {boolean} value Should tell server it can use hard drive to store data during aggregation.
 * @param {!Array<?>=} tags optional tags for this query
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.allowDiskUse = function(value, tags) {};

/**
 * Appends new operators to this aggregate pipeline
 * @param {...!Object} ops operator(s) to append
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.append = function(ops) {};

/**
 * Adds a collation.
 * @param {!CollationOptions} options
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.collation = function(options) {};

/**
 * Sets the cursor option option for the aggregation query (ignored for < 2.6.0).
 * Note the different syntax below: .exec() returns a cursor object, and no callback
 * is necessary.
 * @param {!Object} options set the cursor batch size
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.cursor = function(options) {};

/**
 * Executes the aggregate pipeline on the currently bound Model.
 * @param {function(?, T): void=} callback
 * @return {?}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.exec = function(callback) {};

/**
 * Execute the aggregation with explain
 * @param {function(?, T): void=} callback
 * @return {!Promise<T>}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.explain = function(callback) {};

/**
 * Appends a new custom $group operator to this aggregate pipeline.
 * @param {!Object} arg $group operator contents
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.group = function(arg) {};

/**
 * Appends a new $limit operator to this aggregate pipeline.
 * @param {number} num maximum number of records to pass to the next stage
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.limit = function(num) {};

/**
 * Appends new custom $lookup operator(s) to this aggregate pipeline.
 * @param {!Object} options to $lookup as described in the above link
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.lookup = function(options) {};

/**
 * Appends a new custom $match operator to this aggregate pipeline.
 * @param {!Object} arg $match operator contents
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.match = function(arg) {};

/**
 * Binds this aggregate to a model.
 * @param {?} model the model to which the aggregate is to be bound
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.model = function(model) {};

/**
 * Appends a new $geoNear operator to this aggregate pipeline.
 * MUST be used as the first operator in the pipeline.
 * @param {!Object} parameters
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.near = function(parameters) {};

/**
 * Appends a new $project operator to this aggregate pipeline.
 * Mongoose query selection syntax is also supported.
 * @param {(string|!Object)} arg field specification
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.project = function(arg) {};

/**
 * Sets the readPreference option for the aggregation query.
 * @param {string} pref one of the listed preference options or their aliases
 * @param {!Array<!Object>=} tags optional tags for this query
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.read = function(pref, tags) {};

/**
 * Appends new custom $sample operator(s) to this aggregate pipeline.
 * @param {number} size number of random documents to pick
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.sample = function(size) {};

/**
 * Appends a new $skip operator to this aggregate pipeline.
 * @param {number} num number of records to skip before next stage
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.skip = function(num) {};

/**
 * Appends a new $sort operator to this aggregate pipeline.
 * If an object is passed, values allowed are asc, desc, ascending, descending, 1, and -1.
 * If a string is passed, it must be a space delimited list of path names. The sort order
 * of each path is ascending unless the path name is prefixed with - which will be treated
 * as descending.
 * @param {(string|!Object)} arg
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.sort = function(arg) {};

/**
 * Provides promise for aggregate.
 * @template TRes
 * @param {function(T): (void|TRes|!PromiseLike<TRes>)=} resolve
 * @param {function(?): (void|TRes|!PromiseLike<TRes>)=} reject
 * @return {!Promise<TRes>}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.then = function(resolve, reject) {};

/**
 * Appends new custom $unwind operator(s) to this aggregate pipeline.
 * Note that the $unwind operator requires the path name to start with '$'.
 * Mongoose will prepend '$' if the specified field doesn't start '$'.
 * Appends new custom $unwind operator(s) to this aggregate pipeline
 * new in mongodb 3.2
 * @param {...string|{path: string, includeArrayIndex: string, preserveNullAndEmptyArrays: boolean}} fields_or_opts the field(s) to unwind
 * @return {mongoose.Aggregate}
 */
tsickle_declare_module.mongoose.Aggregate.prototype.unwind = function(fields_or_opts) {};

/**
 * @constructor
 * @struct
 * SchemaType constructor
 * @param {string} path
 * @param {!Object=} options
 * @param {string=} instance
 */
tsickle_declare_module.mongoose.SchemaType = function(path, options, instance) {};

/**
 * Sets a default value for this SchemaType.
 * Defaults can be either functions which return the value to use as the
 * default or the literal value itself. Either way, the value will be cast
 * based on its schema type before being set during document creation.
 * @param {?} val the default value
 * @return {?}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.default = function(val) {};

/**
 * Adds a getter to this schematype.
 * @param {!Function} fn
 * @return {mongoose.SchemaType}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.get = function(fn) {};

/**
 * Declares the index options for this schematype.
 * Indexes are created in the background by default. Specify background: false to override.
 * @param {(string|boolean|!Object)} options
 * @return {mongoose.SchemaType}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.index = function(options) {};

/**
 * Adds a required validator to this SchemaType. The validator gets added
 * to the front of this SchemaType's validators array using unshift().
 * @param {boolean} required enable/disable the validator
 * @param {string=} message optional custom error message
 * @return {mongoose.SchemaType}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.required = function(required, message) {};

/**
 * Sets default select() behavior for this path.
 * @param {boolean} val
 * @return {mongoose.SchemaType}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.select = function(val) {};

/**
 * Adds a setter to this schematype.
 * @param {!Function} fn
 * @return {mongoose.SchemaType}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.set = function(fn) {};

/**
 * Declares a sparse index.
 * @param {boolean} bool
 * @return {mongoose.SchemaType}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.sparse = function(bool) {};

/**
 * Declares a full text index.
 * @param {boolean} bool
 * @return {mongoose.SchemaType}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.text = function(bool) {};

/**
 * Declares an unique index.
 * @param {boolean} bool
 * @return {mongoose.SchemaType}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.unique = function(bool) {};

/**
 * Adds validator(s) for this document path.
 * Validators always receive the value to validate as their first argument
 * and must return Boolean. Returning false means validation failed.
 * @param {(!Object|!Function|!RegExp)} obj validator
 * @param {string=} errorMsg optional error message
 * @param {string=} type optional validator type
 * @return {mongoose.SchemaType}
 */
tsickle_declare_module.mongoose.SchemaType.prototype.validate = function(obj, errorMsg, type) {};
 /** @type {?} */
tsickle_declare_module.mongoose.Promise;
 /** @type {?} */
tsickle_declare_module.mongoose.PromiseProvider;
 /** @type {?<?>} */
tsickle_declare_module.mongoose.Model;

/* TODO: ConstructSignature: tsickle_declare_module.mongoose */

/**
 * Finds a single document by its _id field. findById(id) is almost*
 * equivalent to findOne({ _id: id }). findById() triggers findOne hooks.
 * @param {(string|number|!Object)} id value of _id to query by
 * @param {function(?, T): void|!Object=} callback_or_projection
 * @param {function(?, T): void|!Object=} callback_or_options
 * @param {function(?, T): void=} callback
 * @return {!DocumentQuery<T, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.findById = function(id, callback_or_projection, callback_or_options, callback) {};

/**
 * @param {string} name
 * @return {?}
 */
tsickle_declare_module.mongoose.Model.prototype.model = function(name) {};

/**
 * Creates a Query and specifies a $where condition.
 * @param {(string|!Function)} argument is a javascript string or anonymous function
 * @return {!DocumentQuery<T, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.$where = function(argument) {};

/**
 * Performs aggregations on the models collection.
 * If a callback is passed, the aggregate is executed and a Promise is returned.
 * If a callback is not passed, the aggregate itself is returned.
 * @param {...!Object} aggregations_or_aggregationsWithCallback
 * @return {!Aggregate<!Array<!Object>>|!Promise<!Array<!Object>>}
 */
tsickle_declare_module.mongoose.Model.prototype.aggregate = function(aggregations_or_aggregationsWithCallback) {};

/**
 * Counts number of matching documents in a database collection.
 * @param {!Object} conditions
 * @param {function(?, number): void=} callback
 * @return {!Query<number>}
 */
tsickle_declare_module.mongoose.Model.prototype.count = function(conditions, callback) {};

/**
 * Shortcut for saving one or more documents to the database. MyModel.create(docs)
 * does new MyModel(doc).save() for every doc in docs.
 * Triggers the save() hook.
 * @param {...!Array<?>|!Object} docs_or_docsWithCallback
 * @return {!Promise<!Array<T>>|!Promise<T>}
 */
tsickle_declare_module.mongoose.Model.prototype.create = function(docs_or_docsWithCallback) {};

/**
 * Adds a discriminator type.
 * @template U
 * @param {string} name discriminator model name
 * @param {!Schema} schema discriminator model schema
 * @return {?<U>}
 */
tsickle_declare_module.mongoose.Model.prototype.discriminator = function(name, schema) {};

/**
 * Creates a Query for a distinct operation. Passing a callback immediately executes the query.
 * @param {string} field
 * @param {function(?, !Array<?>): void|!Object=} callback_or_conditions
 * @param {function(?, !Array<?>): void=} callback
 * @return {!Query<!Array<?>>}
 */
tsickle_declare_module.mongoose.Model.prototype.distinct = function(field, callback_or_conditions, callback) {};

/**
 * Sends ensureIndex commands to mongo for each index declared in the schema.
 * @param {function(?): void|!Object=} callback_or_options
 * @param {function(?): void=} callback
 * @return {!Promise<void>}
 */
tsickle_declare_module.mongoose.Model.prototype.ensureIndexes = function(callback_or_options, callback) {};

/**
 * Finds documents.
 * @param {function(?, !Array<T>): void|!Object=} callback_or_conditions
 * @param {function(?, !Array<T>): void|!Object=} callback_or_projection
 * @param {function(?, !Array<T>): void|!Object=} callback_or_options
 * @param {function(?, !Array<T>): void=} callback
 * @return {!DocumentQuery<!Array<T>, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.find = function(callback_or_conditions, callback_or_projection, callback_or_options, callback) {};

/**
 * Issue a mongodb findAndModify remove command by a document's _id field.
 * findByIdAndRemove(id, ...) is equivalent to findOneAndRemove({ _id: id }, ...).
 * Finds a matching document, removes it, passing the found document (if any) to the callback.
 * Executes immediately if callback is passed, else a Query object is returned.
 * @param {(string|number|!Object)=} id
 * @param {function(?, T): void|{sort: !Object, select: !Object}=} callback_or_options
 * @param {function(?, T): void=} callback
 * @return {!DocumentQuery<T, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.findByIdAndRemove = function(id, callback_or_options, callback) {};

/**
 * Issues a mongodb findAndModify update command by a document's _id field. findByIdAndUpdate(id, ...)
 * is equivalent to findOneAndUpdate({ _id: id }, ...).
 * @param {(string|number|!Object)=} id
 * @param {!Object=} update
 * @param {function(?, T): void|!ModelFindByIdAndUpdateOptions=} callback_or_options
 * @param {function(?, T): void=} callback
 * @return {!DocumentQuery<T, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.findByIdAndUpdate = function(id, update, callback_or_options, callback) {};

/**
 * Finds one document.
 * The conditions are cast to their respective SchemaTypes before the command is sent.
 * @param {!Object=} conditions
 * @param {function(?, T): void|!Object=} callback_or_projection
 * @param {function(?, T): void|!Object=} callback_or_options
 * @param {function(?, T): void=} callback
 * @return {!DocumentQuery<T, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.findOne = function(conditions, callback_or_projection, callback_or_options, callback) {};

/**
 * Issue a mongodb findAndModify remove command.
 * Finds a matching document, removes it, passing the found document (if any) to the callback.
 * Executes immediately if callback is passed else a Query object is returned.
 * @param {!Object=} conditions
 * @param {function(?, T): void|{sort: !Object, maxTimeMS: number, select: !Object}=} callback_or_options
 * @param {function(?, T): void=} callback
 * @return {!DocumentQuery<T, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.findOneAndRemove = function(conditions, callback_or_options, callback) {};

/**
 * Issues a mongodb findAndModify update command.
 * Finds a matching document, updates it according to the update arg, passing any options,
 * and returns the found document (if any) to the callback. The query executes immediately
 * if callback is passed else a Query object is returned.
 * @param {!Object=} conditions
 * @param {!Object=} update
 * @param {function(?, T, ?): void|!ModelFindOneAndUpdateOptions=} callback_or_options
 * @param {function(?, T, ?): void=} callback
 * @return {!DocumentQuery<T, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.findOneAndUpdate = function(conditions, update, callback_or_options, callback) {};

/**
 * geoNear support for Mongoose
 * @param {(!Array<number>|{type: string, coordinates: !Array<number>})} point
 * @param {?} options for the qurery
 * @param {function(?, !Array<T>, ?): void=} callback optional callback for the query
 * @return {!DocumentQuery<!Array<T>, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.geoNear = function(point, options, callback) {};

/**
 * Implements $geoSearch functionality for Mongoose
 * @param {!Object} conditions an object that specifies the match condition (required)
 * @param {{near: !Array<number>, maxDistance: number, limit: number, lean: boolean}} options for the geoSearch, some (near, maxDistance) are required
 * @param {function(?, !Array<T>): void=} callback optional callback
 * @return {!DocumentQuery<!Array<T>, T>}
 */
tsickle_declare_module.mongoose.Model.prototype.geoSearch = function(conditions, options, callback) {};

/**
 * Shortcut for creating a new Document from existing raw data,
 * pre-saved in the DB. The document returned has no paths marked
 * as modified initially.
 * @param {!Object} obj
 * @return {T}
 */
tsickle_declare_module.mongoose.Model.prototype.hydrate = function(obj) {};

/**
 * Shortcut for validating an array of documents and inserting them into
 * MongoDB if they're all valid. This function is faster than .create()
 * because it only sends one operation to the server, rather than one for each
 * document.
 * This function does not trigger save middleware.
 * @param {...!Array<?>|?|!Object} docs_or_doc_or_docsWithCallback
 * @return {!Promise<!Array<T>>|!Promise<T>}
 */
tsickle_declare_module.mongoose.Model.prototype.insertMany = function(docs_or_doc_or_docsWithCallback) {};

/**
 * Executes a mapReduce command.
 * @template Key, Value
 * @param {!ModelMapReduceOption<T, Key, Value>} o an object specifying map-reduce options
 * @param {function(?, ?): void=} callback
 * @return {!Promise<?>}
 */
tsickle_declare_module.mongoose.Model.prototype.mapReduce = function(o, callback) {};

/**
 * Populates document references.
 * @template T
 * @param {!Array<!Object>|!Object} docs Either a single document or array of documents to populate.
 * @param {(!ModelPopulateOptions|!Array<!ModelPopulateOptions>)} options A hash of key/val (path, options) used for population.
 * @param {function(?, !Array<T>): void|function(?, T): void=} callback Optional callback, executed upon completion. Receives err and the doc(s).
 * @return {!Promise<!Array<T>>|!Promise<T>}
 */
tsickle_declare_module.mongoose.Model.prototype.populate = function(docs, options, callback) {};

/**
 * Removes documents from the collection.
 * @param {!Object} conditions
 * @param {function(?): void=} callback
 * @return {!Query<void>}
 */
tsickle_declare_module.mongoose.Model.prototype.remove = function(conditions, callback) {};

/**
 * Updates documents in the database without returning them.
 * All update values are cast to their appropriate SchemaTypes before being sent.
 * @param {!Object} conditions
 * @param {!Object} doc
 * @param {function(?, ?): void|!ModelUpdateOptions=} callback_or_options
 * @param {function(?, ?): void=} callback
 * @return {!Query<?>}
 */
tsickle_declare_module.mongoose.Model.prototype.update = function(conditions, doc, callback_or_options, callback) {};

/**
 * Creates a Query, applies the passed conditions, and returns the Query.
 * @param {string} path
 * @param {!Object=} val
 * @return {!Query<?>}
 */
tsickle_declare_module.mongoose.Model.prototype.where = function(path, val) {};
/**
 * @extends {ModelProperties}
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.Document = function() {};
 /** @type {number} */
tsickle_declare_module.mongoose.Document.prototype.__v;

/**
 * Signal that we desire an increment of this documents version.
 * @return {mongoose.Document}
 */
tsickle_declare_module.mongoose.Document.prototype.increment = function() {};

/**
 * Returns another Model instance.
 * @param {string} name model name
 * @return {?<mongoose.Document>}
 */
tsickle_declare_module.mongoose.Document.prototype.model = function(name) {};

/**
 * Removes this document from the db.
 * @param {function(?, mongoose.Document): void=} fn optional callback
 * @return {!Promise<mongoose.Document>}
 */
tsickle_declare_module.mongoose.Document.prototype.remove = function(fn) {};

/**
 * Saves this document.
 * @param {!SaveOptions|function(?, mongoose.Document, number): void=} options_or_fn options optional options
 * @param {function(?, mongoose.Document, number): void=} fn optional callback
 * @return {!Promise<mongoose.Document>}
 */
tsickle_declare_module.mongoose.Document.prototype.save = function(options_or_fn, fn) {};
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.SaveOptions = function() {};
 /** @type {(boolean|!WriteConcern)} */
tsickle_declare_module.mongoose.SaveOptions.prototype.safe;
 /** @type {boolean} */
tsickle_declare_module.mongoose.SaveOptions.prototype.validateBeforeSave;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.WriteConcern = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.WriteConcern.prototype.j;
 /** @type {(number|string|!TagSet)} */
tsickle_declare_module.mongoose.WriteConcern.prototype.w;
 /** @type {number} */
tsickle_declare_module.mongoose.WriteConcern.prototype.wtimeout;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.TagSet = function() {};

/* TODO: IndexSignature: tsickle_declare_module.mongoose */
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ModelProperties = function() {};
 /** @type {?} */
tsickle_declare_module.mongoose.ModelProperties.prototype.base;
 /** @type {!String} */
tsickle_declare_module.mongoose.ModelProperties.prototype.baseModelName;
 /** @type {?} */
tsickle_declare_module.mongoose.ModelProperties.prototype.collection;
 /** @type {!Connection} */
tsickle_declare_module.mongoose.ModelProperties.prototype.db;
 /** @type {?} */
tsickle_declare_module.mongoose.ModelProperties.prototype.discriminators;
 /** @type {string} */
tsickle_declare_module.mongoose.ModelProperties.prototype.modelName;
 /** @type {!Schema} */
tsickle_declare_module.mongoose.ModelProperties.prototype.schema;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ModelFindByIdAndUpdateOptions = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelFindByIdAndUpdateOptions.prototype.new;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelFindByIdAndUpdateOptions.prototype.upsert;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelFindByIdAndUpdateOptions.prototype.runValidators;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelFindByIdAndUpdateOptions.prototype.setDefaultsOnInsert;
 /** @type {!Object} */
tsickle_declare_module.mongoose.ModelFindByIdAndUpdateOptions.prototype.sort;
 /** @type {!Object} */
tsickle_declare_module.mongoose.ModelFindByIdAndUpdateOptions.prototype.select;
/**
 * @extends {ModelFindByIdAndUpdateOptions}
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ModelFindOneAndUpdateOptions = function() {};
 /** @type {(string|!Object)} */
tsickle_declare_module.mongoose.ModelFindOneAndUpdateOptions.prototype.fields;
 /** @type {number} */
tsickle_declare_module.mongoose.ModelFindOneAndUpdateOptions.prototype.maxTimeMS;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelFindOneAndUpdateOptions.prototype.passRawResult;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ModelPopulateOptions = function() {};
 /** @type {string} */
tsickle_declare_module.mongoose.ModelPopulateOptions.prototype.path;
 /** @type {?} */
tsickle_declare_module.mongoose.ModelPopulateOptions.prototype.select;
 /** @type {!Object} */
tsickle_declare_module.mongoose.ModelPopulateOptions.prototype.match;
 /** @type {string} */
tsickle_declare_module.mongoose.ModelPopulateOptions.prototype.model;
 /** @type {!Object} */
tsickle_declare_module.mongoose.ModelPopulateOptions.prototype.options;
 /** @type {(!ModelPopulateOptions|!Array<!ModelPopulateOptions>)} */
tsickle_declare_module.mongoose.ModelPopulateOptions.prototype.populate;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ModelUpdateOptions = function() {};
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelUpdateOptions.prototype.safe;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelUpdateOptions.prototype.upsert;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelUpdateOptions.prototype.multi;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelUpdateOptions.prototype.runValidators;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelUpdateOptions.prototype.setDefaultsOnInsert;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelUpdateOptions.prototype.strict;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelUpdateOptions.prototype.overwrite;

/* TODO: IndexSignature: tsickle_declare_module.mongoose */
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.ModelMapReduceOption = function() {};
 /** @type {(string|!Function)} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.map;
 /** @type {function(Key, !Array<T>): Val} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.reduce;
 /** @type {!Object} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.query;
 /** @type {!Object} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.sort;
 /** @type {number} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.limit;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.keeptemp;
 /** @type {function(Key, Val): Val} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.finalize;
 /** @type {!Object} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.scope;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.jsMode;
 /** @type {boolean} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.verbose;
 /** @type {string} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.readPreference;
 /** @type {{inline: number, replace: string, reduce: string, merge: string}} */
tsickle_declare_module.mongoose.ModelMapReduceOption.prototype.out;
/**
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.MapReduceResult = function() {};
 /** @type {Key} */
tsickle_declare_module.mongoose.MapReduceResult.prototype._id;
 /** @type {Val} */
tsickle_declare_module.mongoose.MapReduceResult.prototype.value;
/**
 * @extends {Collection}
 * @record
 * @struct
 */
tsickle_declare_module.mongoose.CollectionBase = function() {};
 /** @type {string} */
tsickle_declare_module.mongoose.CollectionBase.prototype.collectionName;
 /** @type {!Connection} */
tsickle_declare_module.mongoose.CollectionBase.prototype.conn;
 /** @type {string} */
tsickle_declare_module.mongoose.CollectionBase.prototype.name;

/**
 * @param {...?} args
 * @return {?}
 */
tsickle_declare_module.mongoose.CollectionBase.prototype.ensureIndex = function(args) {};

/**
 * @param {...?} args
 * @return {?}
 */
tsickle_declare_module.mongoose.CollectionBase.prototype.findAndModify = function(args) {};

/**
 * @param {...?} args
 * @return {?}
 */
tsickle_declare_module.mongoose.CollectionBase.prototype.getIndexes = function(args) {};
