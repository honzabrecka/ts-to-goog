/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/openlayers v2/index.d.ts:
/** @const */
var OpenLayers = {};
/**
 * @record
 * @struct
 */
OpenLayers.MapOptions = function() {};
 /** @type {string} */
OpenLayers.MapOptions.prototype.projection;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.MapOptions.prototype.maxExtend;
 /** @type {!OpenLayers.LonLat} */
OpenLayers.MapOptions.prototype.center;
/**
 * @record
 * @struct
 */
OpenLayers.DistanceOptions = function() {};
 /** @type {boolean} */
OpenLayers.DistanceOptions.prototype.details;
 /** @type {boolean} */
OpenLayers.DistanceOptions.prototype.edge;
/**
 * @record
 * @struct
 */
OpenLayers.BoundsOptions = function() {};
 /** @type {boolean} */
OpenLayers.BoundsOptions.prototype.inclusive;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.BoundsOptions.prototype.worldBounds;
/**
 * @record
 * @struct
 */
OpenLayers.WrapDateLineOptions = function() {};
 /** @type {number} */
OpenLayers.WrapDateLineOptions.prototype.leftTolerance;
 /** @type {number} */
OpenLayers.WrapDateLineOptions.prototype.rightTolerance;
/**
 * @record
 * @struct
 */
OpenLayers.LayerOptions = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Animation = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.String = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Number = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Function = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Array = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Console = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Event = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Events = function() {};

/**
 * Method: attachToElement
 * 
 * Parameters:
 * element - {HTMLDOMElement} a DOM element to attach browser events to
 * @param {!HTMLElement} element
 * @return {void}
 */
OpenLayers.Events.prototype.attachToElement = function(element) {};

/**
 * APIMethod: on
 * Convenience method for registering listeners with a common scope.
 *     Internally, this method calls <register> as shown in the examples
 *     below.
 * 
 * Example use:
 * (code)
 * // register a single listener for the "loadstart" event
 * events.on({"loadstart": loadStartListener});
 * 
 * // this is equivalent to the following
 * events.register("loadstart", undefined, loadStartListener);
 * 
 * // register multiple listeners to be called with the same `this` object
 * events.on({
 *     "loadstart": loadStartListener,
 *     "loadend": loadEndListener,
 *     scope: object
 * });
 * 
 * // this is equivalent to the following
 * events.register("loadstart", object, loadStartListener);
 * events.register("loadend", object, loadEndListener);
 * (end)
 * 
 * Parameters:
 *  object - {Object}
 * @param {?} object
 * @return {void}
 */
OpenLayers.Events.prototype.on = function(object) {};

/**
 * APIMethod: register
 * Register an event on the events object.
 * 
 * When the event is triggered, the 'func' function will be called, in the
 * context of 'obj'. Imagine we were to register an event, specifying an
 * OpenLayers.Bounds Object as 'obj'. When the event is triggered, the
 * context in the callback function will be our Bounds object. This means
 * that within our callback function, we can access the properties and
 * methods of the Bounds object through the "this" variable. So our
 * callback could execute something like:
 * :    leftStr = "Left: " + this.left;
 * 
 *                   or
 * 
 * :    centerStr = "Center: " + this.getCenterLonLat();
 * 
 * Parameters:
 * type - {String} Name of the event to register
 * obj - {Object} The object to bind the context to for the callback#.
 *     If no object is specified, default is the Events's 'object' property.
 * func - {Function} The callback function. If no callback is
 *     specified, this function does nothing.
 * priority - {Boolean|Object} If true, adds the new listener to the
 *     *front* of the events queue instead of to the end.
 * 
 * Valid options for priority:
 * extension - {Boolean} If true, then the event will be registered as
 *     extension event. Extension events are handled before all other
 *     events.
 * @param {string} type
 * @param {?} obj
 * @param {function(): void} func
 * @param {boolean} priority
 * @return {void}
 */
OpenLayers.Events.prototype.register = function(type, obj, func, priority) {};

/**
 * APIMethod: registerPriority
 * Same as register() but adds the new listener to the *front* of the
 *     events queue instead of to the end.
 * 
 *     TODO: get rid of this in 3.0 - Decide whether listeners should be
 *     called in the order they were registered or in reverse order.
 * 
 * 
 * Parameters:
 * type - {String} Name of the event to register
 * obj - {Object} The object to bind the context to for the callback#.
 *                If no object is specified, default is the Events's
 *                'object' property.
 * func - {Function} The callback function. If no callback is
 *                   specified, this function does nothing.
 * @param {string} type
 * @param {?} obj
 * @param {function(): void} func
 * @return {void}
 */
OpenLayers.Events.prototype.registerPriority = function(type, obj, func) {};

/**
 * APIMethod: un
 * Convenience method for unregistering listeners with a common scope.
 *     Internally, this method calls <unregister> as shown in the examples
 *     below.
 * 
 * Example use:
 * (code)
 * // unregister a single listener for the "loadstart" event
 * events.un({"loadstart": loadStartListener});
 * 
 * // this is equivalent to the following
 * events.unregister("loadstart", undefined, loadStartListener);
 * 
 * // unregister multiple listeners with the same `this` object
 * events.un({
 *     "loadstart": loadStartListener,
 *     "loadend": loadEndListener,
 *     scope: object
 * });
 * 
 * // this is equivalent to the following
 * events.unregister("loadstart", object, loadStartListener);
 * events.unregister("loadend", object, loadEndListener);
 * (end)
 * @param {?} object
 * @return {void}
 */
OpenLayers.Events.prototype.un = function(object) {};

/**
 * APIMethod: unregister
 * 
 * Parameters:
 * type - {String}
 * obj - {Object} If none specified, defaults to this.object
 * func - {Function}
 * @param {string} type
 * @param {?} obj
 * @param {function(): void} func
 * @return {void}
 */
OpenLayers.Events.prototype.unregister = function(type, obj, func) {};

/**
 * Method: remove
 * Remove all listeners for a given event type. If type is not registered,
 *     does nothing.
 * 
 * Parameters:
 * type - {String}
 * @param {string} type
 * @return {void}
 */
OpenLayers.Events.prototype.remove = function(type) {};

/**
 * APIMethod: triggerEvent
 * Trigger a specified registered event.
 * 
 * Parameters:
 * type - {String}
 * evt - {Event || Object} will be passed to the listeners.
 * 
 * Returns:
 * {Boolean} The last listener return.  If a listener returns false, the
 *     chain of listeners will stop getting called.
 * @param {string} type
 * @param {!OpenLayers.Event} evt
 * @return {boolean}
 */
OpenLayers.Events.prototype.triggerEvent = function(type, evt) {};

/**
 * Method: handleBrowserEvent
 * Basically just a wrapper to the triggerEvent() function, but takes
 *     care to set a property 'xy' on the event with the current mouse
 *     position.
 * 
 * Parameters:
 * evt - {Event}
 * @param {!OpenLayers.Event} evt
 * @return {void}
 */
OpenLayers.Events.prototype.handleBrowserEvent = function(evt) {};

/**
 * Method: getMousePosition
 * 
 * Parameters:
 * evt - {Event}
 * 
 * Returns:
 * {<OpenLayers.Pixel>} The current xy coordinate of the mouse, adjusted
 *                      for offsets
 * @param {!OpenLayers.Event} evt
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Events.prototype.getMousePosition = function(evt) {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Feature = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Filter = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Icon = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Kinetic = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Lang = function() {};

/**
 * @constructor
 * @struct
 * Constructor: OpenLayers.Layer
 * 
 * Parameters:
 * name - {String} The layer name
 * options - {Object} Hashtable of extra options to tag onto the layer
 * @param {string} name
 * @param {!OpenLayers.LayerOptions} options
 */
OpenLayers.Layer = function(name, options) {};
 /** @type {string} */
OpenLayers.Layer.prototype.id;
 /** @type {string} */
OpenLayers.Layer.prototype.name;
 /** @type {!HTMLElement} */
OpenLayers.Layer.prototype.div;
 /** @type {number} */
OpenLayers.Layer.prototype.opacity;
 /** @type {boolean} */
OpenLayers.Layer.prototype.alwaysInRange;
 /** @type {!Array<string>} */
OpenLayers.Layer.prototype.RESOLUTION_PROPERTIES;
 /** @type {!OpenLayers.Events} */
OpenLayers.Layer.prototype.events;
 /** @type {!OpenLayers.Map} */
OpenLayers.Layer.prototype.map;
 /** @type {boolean} */
OpenLayers.Layer.prototype.isBaseLayer;
 /** @type {boolean} */
OpenLayers.Layer.prototype.alpha;
 /** @type {boolean} */
OpenLayers.Layer.prototype.displayInLayerSwitcher;
 /** @type {boolean} */
OpenLayers.Layer.prototype.visibility;
 /** @type {string} */
OpenLayers.Layer.prototype.attribution;
 /** @type {boolean} */
OpenLayers.Layer.prototype.inRange;
 /** @type {!OpenLayers.Size} */
OpenLayers.Layer.prototype.imageSize;
 /** @type {!Object} */
OpenLayers.Layer.prototype.options;
 /** @type {!Object} */
OpenLayers.Layer.prototype.eventListeners;
 /** @type {number} */
OpenLayers.Layer.prototype.gutter;
 /** @type {!OpenLayers.Projection} */
OpenLayers.Layer.prototype.projection;
 /** @type {string} */
OpenLayers.Layer.prototype.units;
 /** @type {!Array<?>} */
OpenLayers.Layer.prototype.scales;
 /** @type {!Array<?>} */
OpenLayers.Layer.prototype.resolutions;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.Layer.prototype.maxExtent;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.Layer.prototype.minExtent;
 /** @type {number} */
OpenLayers.Layer.prototype.maxResolution;
 /** @type {number} */
OpenLayers.Layer.prototype.minResolution;
 /** @type {number} */
OpenLayers.Layer.prototype.numZoomLevels;
 /** @type {number} */
OpenLayers.Layer.prototype.minScale;
 /** @type {number} */
OpenLayers.Layer.prototype.maxScale;
 /** @type {boolean} */
OpenLayers.Layer.prototype.displayOutsideMaxExtent;
 /** @type {boolean} */
OpenLayers.Layer.prototype.wrapDateLine;
 /** @type {!Object} */
OpenLayers.Layer.prototype.metadata;
 /** @type {string} */
OpenLayers.Layer.CLASS_NAME;

/**
 * Method: destroy
 * Destroy is a destructor: this is to alleviate cyclic references which
 * the Javascript garbage cleaner can not take care of on its own.
 * 
 * Parameters:
 * setNewBaseLayer - {Boolean} Set a new base layer when this layer has
 * been destroyed. Default is true.
 * @param {boolean=} setNewBaseLayer
 * @return {void}
 */
OpenLayers.Layer.prototype.destroy = function(setNewBaseLayer) {};

/**
 * Method: clone
 * 
 * Parameters:
 * obj - {<OpenLayers.Layer>} The layer to be cloned
 * 
 * Returns:
 * {<OpenLayers.Layer>} An exact clone of this <OpenLayers.Layer>
 * @return {!OpenLayers.Layer}
 */
OpenLayers.Layer.prototype.clone = function() {};

/**
 * Method: getOptions
 * Extracts an object from the layer with the properties that were set as
 * options, but updates them with the values currently set on the
 * instance.
 * 
 * Returns:
 * {Object} the <options> of the layer, representing the current state.
 * @return {!OpenLayers.LayerOptions}
 */
OpenLayers.Layer.prototype.getOptions = function() {};

/**
 * APIMethod: setName
 * Sets the new layer name for this layer. Can trigger a changelayer event
 * on the map.
 * 
 * Parameters:
 * newName - {String} The new name.
 * @param {string} newName
 * @return {void}
 */
OpenLayers.Layer.prototype.setName = function(newName) {};

/**
 * APIMethod: addOptions
 * 
 * Parameters:
 * newOptions - {Object}
 * reinitialize - {Boolean} If set to true, and if resolution options of the
 * current baseLayer were changed, the map will be recentered to make
 * sure that it is displayed with a valid resolution, and a
 * changebaselayer event will be triggered.
 * @param {!OpenLayers.LayerOptions} newOptions
 * @param {boolean} reinitialize
 * @return {void}
 */
OpenLayers.Layer.prototype.addOptions = function(newOptions, reinitialize) {};

/**
 * This function can be implemented by subclasses
 * @return {void}
 */
OpenLayers.Layer.prototype.onMapResize = function() {};

/**
 * APIMethod: redraw
 * Redraws the layer. Returns true if the layer was redrawn, false if not.
 * 
 * Returns:
 * {Boolean} The layer was redrawn.
 * @return {void}
 */
OpenLayers.Layer.prototype.redraw = function() {};

/**
 * Method: moveTo
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * zoomChanged - {Boolean} Tells when zoom has changed, as layers have to
 * do some init work in that case.
 * dragging - {Boolean}
 * @param {!OpenLayers.Bounds} bounds
 * @param {boolean} zoomChanged
 * @param {boolean} dragging
 * @return {void}
 */
OpenLayers.Layer.prototype.moveTo = function(bounds, zoomChanged, dragging) {};

/**
 * Method: moveByPx
 * Move the layer based on pixel vector. To be implemented by subclasses.
 * 
 * Parameters:
 * dx - {Number} The x coord of the displacement vector.
 * dy - {Number} The y coord of the displacement vector.
 * @param {number} dx
 * @param {number} dy
 * @return {void}
 */
OpenLayers.Layer.prototype.moveByPx = function(dx, dy) {};

/**
 * Method: setMap
 * Set the map property for the layer. This is done through an accessor
 * so that subclasses can override this and take special action once
 * they have their map variable set.
 * 
 * Here we take care to bring over any of the necessary default
 * properties from the map.
 * 
 * Parameters:
 * map - {<OpenLayers.Map>}
 * @param {!OpenLayers.Map} map
 * @return {void}
 */
OpenLayers.Layer.prototype.setMap = function(map) {};

/**
 * Method: afterAdd
 * Called at the end of the map.addLayer sequence. At this point, the map
 * will have a base layer. To be overridden by subclasses.
 * @return {void}
 */
OpenLayers.Layer.prototype.afterAdd = function() {};

/**
 * APIMethod: removeMap
 * Just as setMap() allows each layer the possibility to take a
 * personalized action on being added to the map, removeMap() allows
 * each layer to take a personalized action on being removed from it.
 * For now, this will be mostly unused, except for the EventPane layer,
 * which needs this hook so that it can remove the special invisible
 * pane.
 * 
 * Parameters:
 * map - {<OpenLayers.Map>}
 * @param {!OpenLayers.Map} map
 * @return {void}
 */
OpenLayers.Layer.prototype.removeMap = function(map) {};

/**
 * APIMethod: getImageSize
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>} optional tile bounds, can be used
 * by subclasses that have to deal with different tile sizes at the
 * layer extent edges (e.g. Zoomify)
 * 
 * Returns:
 * {<OpenLayers.Size>} The size that the image should be, taking into
 * account gutters.
 * @param {!OpenLayers.Bounds} bounds
 * @return {!OpenLayers.Size}
 */
OpenLayers.Layer.prototype.getImageSize = function(bounds) {};

/**
 * APIMethod: setTileSize
 * Set the tile size based on the map size. This also sets layer.imageSize
 * or use by Tile.Image.
 * 
 * Parameters:
 * size - {<OpenLayers.Size>}
 * @param {!OpenLayers.Size} size
 * @return {void}
 */
OpenLayers.Layer.prototype.setTileSize = function(size) {};

/**
 * APIMethod: getVisibility
 * 
 * Returns:
 * {Boolean} The layer should be displayed (if in range).
 * @return {boolean}
 */
OpenLayers.Layer.prototype.getVisibility = function() {};

/**
 * APIMethod: setVisibility
 * Set the visibility flag for the layer and hide/show & redraw
 * accordingly. Fire event unless otherwise specified
 * 
 * Note that visibility is no longer simply whether or not the layer's
 * style.display is set to "block". Now we store a 'visibility' state
 * property on the layer class, this allows us to remember whether or
 * not we *desire* for a layer to be visible. In the case where the
 * map's resolution is out of the layer's range, this desire may be
 * subverted.
 * 
 * Parameters:
 * visibility - {Boolean} Whether or not to display the layer (if in range)
 * @param {boolean} visibility
 * @return {void}
 */
OpenLayers.Layer.prototype.setVisibility = function(visibility) {};

/**
 * APIMethod: display
 * Hide or show the Layer. This is designed to be used internally, and
 * is not generally the way to enable or disable the layer. For that,
 * use the setVisibility function instead..
 * 
 * Parameters:
 * display - {Boolean}
 * @param {boolean} display
 * @return {void}
 */
OpenLayers.Layer.prototype.display = function(display) {};

/**
 * APIMethod: calculateInRange
 * 
 * Returns:
 * {Boolean} The layer is displayable at the current map's current
 * resolution. Note that if 'alwaysInRange' is true for the layer,
 * this function will always return true.
 * @return {boolean}
 */
OpenLayers.Layer.prototype.calculateInRange = function() {};

/**
 * APIMethod: setIsBaseLayer
 * 
 * Parameters:
 * isBaseLayer - {Boolean}
 * @param {boolean} isBaseLayer
 * @return {void}
 */
OpenLayers.Layer.prototype.setIsBaseLayer = function(isBaseLayer) {};

/**
 * Method: initResolutions
 * This method's responsibility is to set up the 'resolutions' array
 * for the layer -- this array is what the layer will use to interface
 * between the zoom levels of the map and the resolution display
 * of the layer.
 * 
 * The user has several options that determine how the array is set up.
 * 
 * For a detailed explanation, see the following wiki from the
 * openlayers.org homepage:
 * http://trac.openlayers.org/wiki/SettingZoomLevels
 * @return {void}
 */
OpenLayers.Layer.prototype.initResolutions = function() {};

/**
 * Method: resolutionsFromScales
 * Derive resolutions from scales.
 * 
 * Parameters:
 * scales - {Array(Number)} Scales
 * 
 * Returns
 * {Array(Number)} Resolutions
 * @param {!Array<number>} scales
 * @return {!Array<number>}
 */
OpenLayers.Layer.prototype.resolutionsFromScales = function(scales) {};

/**
 * Method: calculateResolutions
 * Calculate resolutions based on the provided properties.
 * 
 * Parameters:
 * props - {Object} Properties
 * 
 * Returns:
 * {Array({Number})} Array of resolutions.
 * @param {!Object} props
 * @return {!Array<number>}
 */
OpenLayers.Layer.prototype.calculateResolutions = function(props) {};

/**
 * APIMethod: getResolution
 * 
 * Returns:
 * {Float} The currently selected resolution of the map, taken from the
 * resolutions array, indexed by current zoom level.
 * @return {number}
 */
OpenLayers.Layer.prototype.getResolution = function() {};

/**
 * APIMethod: getExtent
 * 
 * Returns:
 * {<OpenLayers.Bounds>} A Bounds object which represents the lon/lat
 * bounds of the current viewPort.
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Layer.prototype.getExtent = function() {};

/**
 * APIMethod: getZoomForExtent
 * 
 * Parameters:
 * extent - {<OpenLayers.Bounds>}
 * closest - {Boolean} Find the zoom level that most closely fits the
 * specified bounds. Note that this may result in a zoom that does
 * not exactly contain the entire extent.
 * Default is false.
 * 
 * Returns:
 * {Integer} The index of the zoomLevel (entry in the resolutions array)
 * for the passed-in extent. We do this by calculating the ideal
 * resolution for the given extent (based on the map size) and then
 * calling getZoomForResolution(), passing along the 'closest'
 * parameter.
 * @param {!OpenLayers.Bounds} extent
 * @param {boolean=} closest
 * @return {number}
 */
OpenLayers.Layer.prototype.getZoomForExtent = function(extent, closest) {};

/**
 * Method: getDataExtent
 * Calculates the max extent which includes all of the data for the layer.
 * This function is to be implemented by subclasses.
 * 
 * Returns:
 * {<OpenLayers.Bounds>}
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Layer.prototype.getDataExtent = function() {};

/**
 * APIMethod: getResolutionForZoom
 * 
 * Parameters:
 * zoom - {Float}
 * 
 * Returns:
 * {Float} A suitable resolution for the specified zoom.
 * @param {number} zoom
 * @return {number}
 */
OpenLayers.Layer.prototype.getResolutionForZoom = function(zoom) {};

/**
 * APIMethod: getZoomForResolution
 * 
 * Parameters:
 * resolution - {Float}
 * closest - {Boolean} Find the zoom level that corresponds to the absolute
 * closest resolution, which may result in a zoom whose corresponding
 * resolution is actually smaller than we would have desired (if this
 * is being called from a getZoomForExtent() call, then this means that
 * the returned zoom index might not actually contain the entire
 * extent specified... but it'll be close).
 * Default is false.
 * 
 * Returns:
 * {Integer} The index of the zoomLevel (entry in the resolutions array)
 * that corresponds to the best fit resolution given the passed in
 * value and the 'closest' specification.
 * @param {number} resolution
 * @param {boolean=} closest
 * @return {number}
 */
OpenLayers.Layer.prototype.getZoomForResolution = function(resolution, closest) {};

/**
 * APIMethod: getLonLatFromViewPortPx
 * 
 * Parameters:
 * viewPortPx - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or
 * an object with a 'x'
 * and 'y' properties.
 * 
 * Returns:
 * {<OpenLayers.LonLat>} An OpenLayers.LonLat which is the passed-in
 * view port <OpenLayers.Pixel>, translated into lon/lat by the layer.
 * @param {!OpenLayers.Pixel} viewPortPx
 * @return {!OpenLayers.LonLat}
 */
OpenLayers.Layer.prototype.getLonLatFromViewPortPx = function(viewPortPx) {};

/**
 * APIMethod: getViewPortPxFromLonLat
 * Returns a pixel location given a map location. This method will return
 * fractional pixel values.
 * 
 * Parameters:
 * lonlat - {<OpenLayers.LonLat>|Object} An OpenLayers.LonLat or
 * an object with a 'lon'
 * and 'lat' properties.
 * 
 * Returns:
 * {<OpenLayers.Pixel>} An <OpenLayers.Pixel> which is the passed-in
 * lonlat translated into view port pixels.
 * @param {!OpenLayers.LonLat} lonlat
 * @param {number} resolution
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Layer.prototype.getViewPortPxFromLonLat = function(lonlat, resolution) {};

/**
 * APIMethod: setOpacity
 * Sets the opacity for the entire layer (all images)
 * 
 * Parameters:
 * opacity - {Float}
 * @param {number} opacity
 * @return {void}
 */
OpenLayers.Layer.prototype.setOpacity = function(opacity) {};

/**
 * Method: getZIndex
 * 
 * Returns:
 * {Integer} the z-index of this layer
 * @return {number}
 */
OpenLayers.Layer.prototype.getZIndex = function() {};

/**
 * Method: setZIndex
 * 
 * Parameters:
 * zIndex - {Integer}
 * @param {number} zIndex
 * @return {void}
 */
OpenLayers.Layer.prototype.setZIndex = function(zIndex) {};

/**
 * Method: adjustBounds
 * This function will take a bounds, and if wrapDateLine option is set
 * on the layer, it will return a bounds which is wrapped around the
 * world. We do not wrap for bounds which *cross* the
 * maxExtent.left/right, only bounds which are entirely to the left
 * or entirely to the right.
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * @param {!OpenLayers.Bounds} bounds
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Layer.prototype.adjustBounds = function(bounds) {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Marker = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Popup = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Protocol = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Renderer = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Request = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Rule = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.SingleFile = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Spherical = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Strategy = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Style = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Style2 = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.StyleMap = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Symbolizer = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Tile = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.TileManager = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Tween = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Util = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.WPSClient = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.WPSProcess = function() {};

/**
 * @constructor
 * @struct
 * A Geometry is a description of a geographic object.
 */
OpenLayers.Geometry = function() {};
 /** @type {string} */
OpenLayers.Geometry.prototype.id;
 /** @type {!OpenLayers.Geometry} */
OpenLayers.Geometry.prototype.parent;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.Geometry.prototype.bounds;
 /** @type {string} */
OpenLayers.Geometry.CLASS_NAME;

/**
 * Destroy this geometry.
 * @return {void}
 */
OpenLayers.Geometry.prototype.destroy = function() {};

/**
 * Create a clone of this geometry.  Does not set any non-standard properties of the cloned geometry.
 * @return {!OpenLayers.Geometry}
 */
OpenLayers.Geometry.prototype.clone = function() {};

/**
 * Set the bounds for this Geometry.
 * @param {!OpenLayers.Bounds} bounds
 * @return {void}
 */
OpenLayers.Geometry.prototype.setBounds = function(bounds) {};

/**
 * Nullify this components bounds and that of its parent as well.
 * @return {void}
 */
OpenLayers.Geometry.prototype.clearBounds = function() {};

/**
 * Extend the existing bounds to include the new bounds.
 * If geometry's bounds is not yet set, then set a new Bounds.
 * @param {!OpenLayers.Bounds} newBounds
 * @return {void}
 */
OpenLayers.Geometry.prototype.extendBounds = function(newBounds) {};

/**
 * Get the bounds for this Geometry.  If bounds is not set, it is calculated again, this makes queries faster.
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Geometry.prototype.getBounds = function() {};

/**
 * Calculate the closest distance between two geometries (on the x-y plane).
 * @param {!OpenLayers.Geometry} geometry
 * @param {!Object} options
 * @return {!Object}
 */
OpenLayers.Geometry.prototype.distanceTo = function(geometry, options) {};

/**
 * Return a list of all points in this geometry.
 * @param {boolean} nodes
 * @return {!Array<?>}
 */
OpenLayers.Geometry.prototype.getVertices = function(nodes) {};

/**
 * Return whether or not the geometry is at the specified location
 * @param {!OpenLayers.LonLat} lonlat
 * @param {number=} toleranceLon
 * @param {number=} toleranceLat
 * @return {boolean}
 */
OpenLayers.Geometry.prototype.atPoint = function(lonlat, toleranceLon, toleranceLat) {};

/**
 * Returns the length of the collection by summing its parts
 * @return {number}
 */
OpenLayers.Geometry.prototype.getLength = function() {};

/**
 * Returns the area of the collection by summing its parts
 * @return {number}
 */
OpenLayers.Geometry.prototype.getArea = function() {};

/**
 * Returns a text representation of the geometry. If the WKT format is
 * included in a build, this will be the Well-Known Text
 * representation.
 * @return {string}
 */
OpenLayers.Geometry.prototype.toString = function() {};

/**
 * Calculate the centroid of this geometry.  This method is defined in subclasses.
 * @return {!OpenLayers.Geometry.Point}
 */
OpenLayers.Geometry.prototype.getCentroid = function() {};

/**
 * @constructor
 * @struct
 * This class offers several methods for interacting with a wrapped pro4js projection object.
 * @param {string} projCode
 * @param {?=} options
 */
OpenLayers.Projection = function(projCode, options) {};

/**
 * Get the string SRS code.
 * @return {string}
 */
OpenLayers.Projection.prototype.getCode = function() {};

/**
 * Get the units string for the projection -- returns null if proj4js is not available.
 * @return {string}
 */
OpenLayers.Projection.prototype.getUnits = function() {};

/**
 * Set a custom transform method between two projections.  Use this method in cases where the proj4js lib is not available or where custom projections need to be handled.
 * @param {string} from
 * @param {string} to
 * @param {function(): void} method
 * @return {void}
 */
OpenLayers.Projection.prototype.addTransform = function(from, to, method) {};

/**
 * Transform a point coordinate from one projection to another. Note that the input point is transformed in place.
 * Transform a point coordinate from one projection to another. Note that the input point is transformed in place.
 * @param {!OpenLayers.Geometry.Point|!Object} point
 * @param {!OpenLayers.Projection} source
 * @param {!OpenLayers.Projection} dest
 * @return {!Object}
 */
OpenLayers.Projection.prototype.transform = function(point, source, dest) {};

/**
 * A null transformation useful for defining projection aliases when proj4js is not available:
 * @param {!Object} point
 * @return {!OpenLayers.Function}
 */
OpenLayers.Projection.prototype.nullTransform = function(point) {};

/**
 * @constructor
 * @struct
 * Construct a new bounds object. Coordinates can either be passed as four
 * arguments, or as a single argument.
 * Construct a new bounds object. Coordinates can either be passed as four
 * arguments, or as a single argument.
 * @param {number|!Array<number>} left_or_bounds
 * @param {number=} bottom
 * @param {number=} right
 * @param {number=} top
 */
OpenLayers.Bounds = function(left_or_bounds, bottom, right, top) {};
 /** @type {number} */
OpenLayers.Bounds.prototype.left;
 /** @type {number} */
OpenLayers.Bounds.prototype.bottom;
 /** @type {number} */
OpenLayers.Bounds.prototype.right;
 /** @type {number} */
OpenLayers.Bounds.prototype.top;
 /** @type {string} */
OpenLayers.Bounds.CLASS_NAME;

/**
 * Create a cloned instance of this bounds.
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Bounds.prototype.clone = function() {};

/**
 * Test a two bounds for equivalence.
 * @param {!OpenLayers.Bounds} bounds
 * @return {boolean}
 */
OpenLayers.Bounds.prototype.equals = function(bounds) {};

/**
 * Returns a string representation of the bounds object.
 * @return {string}
 */
OpenLayers.Bounds.prototype.toString = function() {};

/**
 * Returns an array representation of the bounds object.
 * @param {boolean=} reverseAxisOrder
 * @return {!Array<number>}
 */
OpenLayers.Bounds.prototype.toArray = function(reverseAxisOrder) {};

/**
 * Returns a boundingbox-string representation of the bounds object.
 * @param {number=} decimal
 * @param {boolean=} reverseAxisOrder
 * @return {string}
 */
OpenLayers.Bounds.prototype.toBBOX = function(decimal, reverseAxisOrder) {};

/**
 * Create a new polygon geometry based on this bounds.
 * @return {!OpenLayers.Geometry.Polygon}
 */
OpenLayers.Bounds.prototype.toGeometry = function() {};

/**
 * Returns the width of the bounds.
 * @return {number}
 */
OpenLayers.Bounds.prototype.getWidth = function() {};

/**
 * Returns the height of the bounds.
 * @return {number}
 */
OpenLayers.Bounds.prototype.getHeight = function() {};

/**
 *
 * @return {!OpenLayers.Size}
 */
OpenLayers.Bounds.prototype.getSize = function() {};

/**
 * Returns the Pixel object which represents the center of the bounds.
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Bounds.prototype.getCenterPixel = function() {};

/**
 * Returns the LonLat object which represents the center of the bounds.
 * @return {!OpenLayers.LonLat}
 */
OpenLayers.Bounds.prototype.getCenterLonLat = function() {};

/**
 * Scales the bounds around a pixel or lonlat. Note that the new
 * bounds may return non-integer properties, even if a pixel
 * is passed.
 * Scales the bounds around a pixel or lonlat. Note that the new
 * bounds may return non-integer properties, even if a pixel
 * is passed.
 * @param {number} ratio
 * @param {!OpenLayers.Pixel|!OpenLayers.LonLat=} origin
 * @return {void}
 */
OpenLayers.Bounds.prototype.scale = function(ratio, origin) {};

/**
 * Shifts the coordinates of the bound by the given horizontal and vertical
 * deltas.
 * @param {number} x
 * @param {number} y
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Bounds.prototype.add = function(x, y) {};

/**
 * Extend the bounds.
 * Extend the bounds.
 * Extend the bounds.
 * @param {!OpenLayers.LonLat|!OpenLayers.Geometry.Point|!OpenLayers.Bounds} object
 * @return {void}
 */
OpenLayers.Bounds.prototype.extend = function(object) {};

/**
 *
 * @param {number} x
 * @param {number} y
 * @return {void}
 */
OpenLayers.Bounds.prototype.extendXY = function(x, y) {};

/**
 * Returns whether the bounds object contains the given <OpenLayers.LonLat>.
 * Returns whether the bounds object contains the given <OpenLayers.LonLat>.
 * @param {!OpenLayers.LonLat|!Object} ll
 * @param {!OpenLayers.BoundsOptions} options
 * @return {boolean}
 */
OpenLayers.Bounds.prototype.containsLonLat = function(ll, options) {};

/**
 * Returns whether the bounds object contains the given <OpenLayers.Pixel>.
 * @param {!OpenLayers.Pixel} px
 * @param {boolean} inclusive
 * @return {boolean}
 */
OpenLayers.Bounds.prototype.containsPixel = function(px, inclusive) {};

/**
 * Returns whether the bounds object contains the given x and y.
 * @param {number} x
 * @param {number} y
 * @param {boolean=} inclusive
 * @return {boolean}
 */
OpenLayers.Bounds.prototype.contains = function(x, y, inclusive) {};

/**
 * Determine whether the target bounds intersects this bounds. Bounds are
 * considered intersecting if any of their edges intersect or if one
 * bounds contains the other.
 * @param {!OpenLayers.Bounds} bounds
 * @param {!OpenLayers.BoundsOptions} options
 * @return {boolean}
 */
OpenLayers.Bounds.prototype.intersectsBounds = function(bounds, options) {};

/**
 * Returns whether the bounds object contains the given <OpenLayers.Bounds>.
 * @param {!OpenLayers.Bounds} bounds
 * @param {boolean} partial
 * @param {boolean} inclusive
 * @return {boolean}
 */
OpenLayers.Bounds.prototype.containsBounds = function(bounds, partial, inclusive) {};

/**
 * Returns the the quadrant ("br", "tr", "tl", "bl") in which the given
 * <OpenLayers.LonLat> lies.
 * @param {!OpenLayers.LonLat} lonlat
 * @return {string}
 */
OpenLayers.Bounds.prototype.determineQuadrant = function(lonlat) {};

/**
 * Transform the Bounds object from source to dest.
 * @param {!OpenLayers.Projection} source
 * @param {!OpenLayers.Projection} dest
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Bounds.prototype.transform = function(source, dest) {};

/**
 * Wraps the bounds object around the dateline.
 * @param {!OpenLayers.Bounds} maxExtent
 * @param {!OpenLayers.WrapDateLineOptions} options
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Bounds.prototype.wrapDateLine = function(maxExtent, options) {};

/**
 * Alternative constructor that builds a new OpenLayers.Bounds from a
 * parameter string.
 * @param {string} str
 * @param {boolean} reverseAxisOrder
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Bounds.fromString = function(str, reverseAxisOrder) {};

/**
 * Alternative constructor that builds a new OpenLayers.Bounds from an array.
 * @param {!Array<number>} bbox
 * @param {boolean} reverseAxisOrder
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Bounds.fromArray = function(bbox, reverseAxisOrder) {};

/**
 * Alternative constructor that builds a new OpenLayers.Bounds from a size.
 * @param {!OpenLayers.Size} size
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Bounds.fromSize = function(size) {};

/**
 * Get the opposite quadrant for a given quadrant string.
 * @param {string} quadrant
 * @return {string}
 */
OpenLayers.Bounds.oppositeQuadrant = function(quadrant) {};

/**
 * @constructor
 * @struct
 * Create a new map location.  Coordinates can be passed either as two arguments, or as a single argument.
 * Create a new map location.  Coordinates can be passed either as two arguments, or as a single argument.
 * @param {number|!Array<number>} lon_or_lonlat
 * @param {number=} lat
 */
OpenLayers.LonLat = function(lon_or_lonlat, lat) {};

/**
 * Shortened String representation of OpenLayers.LonLat object.
 * @return {string}
 */
OpenLayers.LonLat.prototype.toShortString = function() {};

/**
 * New OpenLayers.LonLat object with the same lon and lat values
 * @return {!OpenLayers.LonLat}
 */
OpenLayers.LonLat.prototype.clone = function() {};

/**
 * A new OpenLayers.LonLat object with the lon and lat passed-in added to this’s.
 * @param {number} lon
 * @param {number} lat
 * @return {!OpenLayers.LonLat}
 */
OpenLayers.LonLat.prototype.add = function(lon, lat) {};

/**
 * Boolean value indicating whether the passed-in OpenLayers.LonLat object has the same lon and lat components as this.  Note: if ll passed in is null, returns false.
 * @param {!OpenLayers.LonLat} ll
 * @return {boolean}
 */
OpenLayers.LonLat.prototype.equals = function(ll) {};

/**
 * Transform the LonLat object from source to dest.  This transformation is in place: if you want a new lonlat, use .clone() first.
 * @param {!OpenLayers.Projection} source
 * @param {!OpenLayers.Projection} dest
 * @return {!OpenLayers.LonLat}
 */
OpenLayers.LonLat.prototype.transform = function(source, dest) {};

/**
 * Returns a copy of this lonlat, but wrapped around the "dateline" (as specified by the borders of maxExtent).
 * @param {!OpenLayers.Bounds} maxExtend
 * @return {!OpenLayers.LonLat}
 */
OpenLayers.LonLat.prototype.wrapDateLine = function(maxExtend) {};

/**
 * @constructor
 * @struct
 * Constructor: OpenLayers.Map
 * Constructor for a new OpenLayers.Map instance. There are two possible
 * ways to call the map constructor. See the examples below.
 * 
 * Parameters:
 * div - {DOMElement|String} The element or id of an element in your page
 * that will contain the map. May be omitted if the <div> option is
 * provided or if you intend to call the <render> method later.
 * options - {Object} Optional object with properties to tag onto the map.
 * 
 * Valid options (in addition to the listed API properties):
 * center - {<OpenLayers.LonLat>|Array} The default initial center of the map.
 * If provided as array, the first value is the x coordinate,
 * and the 2nd value is the y coordinate.
 * Only specify if <layers> is provided.
 * Note that if an ArgParser/Permalink control is present,
 * and the querystring contains coordinates, center will be set
 * by that, and this option will be ignored.
 * zoom - {Number} The initial zoom level for the map. Only specify if
 * <layers> is provided.
 * Note that if an ArgParser/Permalink control is present,
 * and the querystring contains a zoom level, zoom will be set
 * by that, and this option will be ignored.
 * 
 * Examples:
 * (code)
 * // create a map with default options in an element with the id "map1"
 * var map = new OpenLayers.Map("map1");
 * 
 * // create a map with non-default options in an element with id "map2"
 * var options = {
 * projection: "EPSG:3857",
 * maxExtent: new OpenLayers.Bounds(-200000, -200000, 200000, 200000),
 * center: new OpenLayers.LonLat(-12356463.476333, 5621521.4854095)
 * };
 * var map = new OpenLayers.Map("map2", options);
 * 
 * // map with non-default options - same as above but with a single argument,
 * // a restricted extent, and using arrays for bounds and center
 * var map = new OpenLayers.Map({
 * div: "map_id",
 * projection: "EPSG:3857",
 * maxExtent: [-18924313.432222, -15538711.094146, 18924313.432222, 15538711.094146],
 * restrictedExtent: [-13358338.893333, -9608371.5085962, 13358338.893333, 9608371.5085962],
 * center: [-12356463.476333, 5621521.4854095]
 * });
 * 
 * // create a map without a reference to a container - call render later
 * var map = new OpenLayers.Map({
 * projection: "EPSG:3857",
 * maxExtent: new OpenLayers.Bounds(-200000, -200000, 200000, 200000)
 * });
 * (end)
 * @param {!HTMLElement|string} id
 * @param {!OpenLayers.MapOptions=} options
 */
OpenLayers.Map = function(id, options) {};
 /** @type {string} */
OpenLayers.Map.prototype.id;
 /** @type {boolean} */
OpenLayers.Map.prototype.fractionalZoom;
 /** @type {!OpenLayers.Events} */
OpenLayers.Map.prototype.events;
 /** @type {boolean} */
OpenLayers.Map.prototype.allOverlays;
 /** @type {!HTMLElement} */
OpenLayers.Map.prototype.div;
 /** @type {boolean} */
OpenLayers.Map.prototype.dragging;
 /** @type {!OpenLayers.Size} */
OpenLayers.Map.prototype.size;
 /** @type {!HTMLDivElement} */
OpenLayers.Map.prototype.viewPortDiv;
 /** @type {!OpenLayers.LonLat} */
OpenLayers.Map.prototype.layerContainerOrigin;
 /** @type {!HTMLDivElement} */
OpenLayers.Map.prototype.layerContainerDiv;
 /** @type {!Array<!OpenLayers.Layer>} */
OpenLayers.Map.prototype.layers;
 /** @type {!Array<!OpenLayers.Control>} */
OpenLayers.Map.prototype.controls;
 /** @type {!Array<!OpenLayers.Popup>} */
OpenLayers.Map.prototype.popups;
 /** @type {!OpenLayers.Layer} */
OpenLayers.Map.prototype.baseLayer;
 /** @type {!OpenLayers.LonLat} */
OpenLayers.Map.prototype.center;
 /** @type {number} */
OpenLayers.Map.prototype.resolution;
 /** @type {number} */
OpenLayers.Map.prototype.zoom;
 /** @type {number} */
OpenLayers.Map.prototype.panRatio;
 /** @type {!Object} */
OpenLayers.Map.prototype.options;
 /** @type {!OpenLayers.Size} */
OpenLayers.Map.prototype.tileSize;
 /** @type {string} */
OpenLayers.Map.prototype.projection;
 /** @type {string} */
OpenLayers.Map.prototype.units;
 /** @type {!Array<number>} */
OpenLayers.Map.prototype.resolutions;
 /** @type {number} */
OpenLayers.Map.prototype.maxResolution;
 /** @type {number} */
OpenLayers.Map.prototype.minResolution;
 /** @type {number} */
OpenLayers.Map.prototype.maxScale;
 /** @type {number} */
OpenLayers.Map.prototype.minScale;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.Map.prototype.maxExtent;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.Map.prototype.minExtent;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.Map.prototype.restrictedExtent;
 /** @type {number} */
OpenLayers.Map.prototype.numZoomLevels;
 /** @type {string} */
OpenLayers.Map.prototype.theme;
 /** @type {!OpenLayers.Projection} */
OpenLayers.Map.prototype.displayProjection;
 /** @type {boolean} */
OpenLayers.Map.prototype.fallThrough;
 /** @type {boolean} */
OpenLayers.Map.prototype.autoUpdateSize;
 /** @type {!Object} */
OpenLayers.Map.prototype.eventListeners;
 /** @type {!OpenLayers.Tween} */
OpenLayers.Map.prototype.panTween;
 /** @type {function(): void} */
OpenLayers.Map.prototype.panMethod;
 /** @type {number} */
OpenLayers.Map.prototype.panDuration;
 /** @type {!OpenLayers.Tween} */
OpenLayers.Map.prototype.zoomTween;
 /** @type {function(): void} */
OpenLayers.Map.prototype.zoomMethod;
 /** @type {number} */
OpenLayers.Map.prototype.zoomDuration;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.Map.prototype.paddingForPopups;
 /** @type {!Object} */
OpenLayers.Map.prototype.layerContainerOriginPx;
 /** @type {{x: number, y: number}} */
OpenLayers.Map.prototype.minPx;
 /** @type {{x: number, y: number}} */
OpenLayers.Map.prototype.maxPx;
 /** @type {function(): void} */
OpenLayers.Map.prototype.updateSizeDestroy;
 /** @type {string} */
OpenLayers.Map.TILE_WIDTH;
 /** @type {string} */
OpenLayers.Map.TILE_HEIGHT;

/**
 * APIMethod: getViewport
 * Get the DOMElement representing the view port.
 * 
 * Returns:
 * {DOMElement}
 * @return {!HTMLElement}
 */
OpenLayers.Map.prototype.getViewport = function() {};

/**
 * APIMethod: render
 * Render the map to a specified container.
 * 
 * Parameters:
 * div - {String|DOMElement} The container that the map should be rendered
 * to. If different than the current container, the map viewport
 * will be moved from the current to the new container.
 * @param {string|!HTMLElement} div
 * @return {void}
 */
OpenLayers.Map.prototype.render = function(div) {};

/**
 * Method: unloadDestroy
 * Function that is called to destroy the map on page unload. stored here
 * so that if map is manually destroyed, we can unregister this.
 * @return {function(): void}
 */
OpenLayers.Map.prototype.unloadDestroy = function() {};

/**
 * APIMethod: destroy
 * Destroy this map.
 * Note that if you are using an application which removes a container
 * of the map from the DOM, you need to ensure that you destroy the
 * map *before* this happens; otherwise, the page unload handler
 * will fail because the DOM elements that map.destroy() wants
 * to clean up will be gone. (See
 * http://trac.osgeo.org/openlayers/ticket/2277 for more information).
 * This will apply to GeoExt and also to other applications which
 * modify the DOM of the container of the OpenLayers Map.
 * @return {void}
 */
OpenLayers.Map.prototype.destroy = function() {};

/**
 * APIMethod: setOptions
 * Change the map options
 * 
 * Parameters:
 * options - {Object} Hashtable of options to tag to the map
 * @param {!Object} options
 * @return {void}
 */
OpenLayers.Map.prototype.setOptions = function(options) {};

/**
 * APIMethod: getTileSize
 * Get the tile size for the map
 * 
 * Returns:
 * {<OpenLayers.Size>}
 * @return {!OpenLayers.Size}
 */
OpenLayers.Map.prototype.getTileSize = function() {};

/**
 * APIMethod: getBy
 * Get a list of objects given a property and a match item.
 * 
 * Parameters:
 * array - {String} A property on the map whose value is an array.
 * property - {String} A property on each item of the given array.
 * match - {String | Object} A string to match. Can also be a regular
 * expression literal or object. In addition, it can be any object
 * with a method named test. For reqular expressions or other, if
 * match.test(map[array][i][property]) evaluates to true, the item will
 * be included in the array returned. If no items are found, an empty
 * array is returned.
 * 
 * Returns:
 * {Array} An array of items where the given property matches the given
 * criteria.
 * @param {string} array
 * @param {string} property
 * @param {string|!Object} match
 * @return {!Array<?>}
 */
OpenLayers.Map.prototype.getBy = function(array, property, match) {};

/**
 * APIMethod: getLayersBy
 * Get a list of layers with properties matching the given criteria.
 * 
 * Parameters:
 * property - {String} A layer property to be matched.
 * match - {String | Object} A string to match. Can also be a regular
 * expression literal or object. In addition, it can be any object
 * with a method named test. For reqular expressions or other, if
 * match.test(layer[property]) evaluates to true, the layer will be
 * included in the array returned. If no layers are found, an empty
 * array is returned.
 * 
 * Returns:
 * {Array(<OpenLayers.Layer>)} A list of layers matching the given criteria.
 * An empty array is returned if no matches are found.
 * @param {string} property
 * @param {string|!Object} match
 * @return {!Array<!OpenLayers.Layer>}
 */
OpenLayers.Map.prototype.getLayersBy = function(property, match) {};

/**
 * APIMethod: getLayersByName
 * Get a list of layers with names matching the given name.
 * 
 * Parameters:
 * match - {String | Object} A layer name. The name can also be a regular
 * expression literal or object. In addition, it can be any object
 * with a method named test. For reqular expressions or other, if
 * name.test(layer.name) evaluates to true, the layer will be included
 * in the list of layers returned. If no layers are found, an empty
 * array is returned.
 * 
 * Returns:
 * {Array(<OpenLayers.Layer>)} A list of layers matching the given name.
 * An empty array is returned if no matches are found.
 * @param {string|!Object} match
 * @return {!Array<!OpenLayers.Layer>}
 */
OpenLayers.Map.prototype.getLayersByName = function(match) {};

/**
 * APIMethod: getLayersByClass
 * Get a list of layers of a given class (CLASS_NAME).
 * 
 * Parameters:
 * match - {String | Object} A layer class name. The match can also be a
 * regular expression literal or object. In addition, it can be any
 * object with a method named test. For reqular expressions or other,
 * if type.test(layer.CLASS_NAME) evaluates to true, the layer will
 * be included in the list of layers returned. If no layers are
 * found, an empty array is returned.
 * 
 * Returns:
 * {Array(<OpenLayers.Layer>)} A list of layers matching the given class.
 * An empty array is returned if no matches are found.
 * @param {string|!Object} match
 * @return {!Array<!OpenLayers.Layer>}
 */
OpenLayers.Map.prototype.getLayersByClass = function(match) {};

/**
 * APIMethod: getControlsBy
 * Get a list of controls with properties matching the given criteria.
 * 
 * Parameters:
 * property - {String} A control property to be matched.
 * match - {String | Object} A string to match. Can also be a regular
 * expression literal or object. In addition, it can be any object
 * with a method named test. For reqular expressions or other, if
 * match.test(layer[property]) evaluates to true, the layer will be
 * included in the array returned. If no layers are found, an empty
 * array is returned.
 * 
 * Returns:
 * {Array(<OpenLayers.Control>)} A list of controls matching the given
 * criteria. An empty array is returned if no matches are found.
 * @param {string} property
 * @param {string|!Object} match
 * @return {!Array<!OpenLayers.Control>}
 */
OpenLayers.Map.prototype.getControlsBy = function(property, match) {};

/**
 * APIMethod: getControlsByClass
 * Get a list of controls of a given class (CLASS_NAME).
 * 
 * Parameters:
 * match - {String | Object} A control class name. The match can also be a
 * regular expression literal or object. In addition, it can be any
 * object with a method named test. For reqular expressions or other,
 * if type.test(control.CLASS_NAME) evaluates to true, the control will
 * be included in the list of controls returned. If no controls are
 * found, an empty array is returned.
 * 
 * Returns:
 * {Array(<OpenLayers.Control>)} A list of controls matching the given class.
 * An empty array is returned if no matches are found.
 * @param {string|!Object} match
 * @return {!Array<!OpenLayers.Control>}
 */
OpenLayers.Map.prototype.getControlsByClass = function(match) {};

/**
 * APIMethod: getLayer
 * Get a layer based on its id
 * 
 * Parameters:
 * id - {String} A layer id
 * 
 * Returns:
 * {<OpenLayers.Layer>} The Layer with the corresponding id from the map's
 * layer collection, or null if not found.
 * @param {string} id
 * @return {!OpenLayers.Layer}
 */
OpenLayers.Map.prototype.getLayer = function(id) {};

/**
 * Method: setLayerZIndex
 * 
 * Parameters:
 * layer - {<OpenLayers.Layer>}
 * zIdx - {int}
 * @param {!OpenLayers.Layer} layer
 * @param {number} zIdx
 * @return {void}
 */
OpenLayers.Map.prototype.setLayerZIndex = function(layer, zIdx) {};

/**
 * Method: resetLayersZIndex
 * Reset each layer's z-index based on layer's array index
 * @return {void}
 */
OpenLayers.Map.prototype.resetLayersZIndex = function() {};

/**
 * APIMethod: addLayer
 * 
 * Parameters:
 * layer - {<OpenLayers.Layer>}
 * 
 * Returns:
 * {Boolean} True if the layer has been added to the map.
 * @param {!OpenLayers.Layer} layer
 * @return {boolean}
 */
OpenLayers.Map.prototype.addLayer = function(layer) {};

/**
 * APIMethod: addLayers
 * 
 * Parameters:
 * layers - {Array(<OpenLayers.Layer>)}
 * @param {!Array<!OpenLayers.Layer>} layers
 * @return {void}
 */
OpenLayers.Map.prototype.addLayers = function(layers) {};

/**
 * APIMethod: removeLayer
 * Removes a layer from the map by removing its visual element (the
 * layer.div property), then removing it from the map's internal list
 * of layers, setting the layer's map property to null.
 * 
 * a "removelayer" event is triggered.
 * 
 * very worthy of mention is that simply removing a layer from a map
 * will not cause the removal of any popups which may have been created
 * by the layer. this is due to the fact that it was decided at some
 * point that popups would not belong to layers. thus there is no way
 * for us to know here to which layer the popup belongs.
 * 
 * A simple solution to this is simply to call destroy() on the layer.
 * the default OpenLayers.Layer class's destroy() function
 * automatically takes care to remove itself from whatever map it has
 * been attached to.
 * 
 * The correct solution is for the layer itself to register an
 * event-handler on "removelayer" and when it is called, if it
 * recognizes itself as the layer being removed, then it cycles through
 * its own personal list of popups, removing them from the map.
 * 
 * Parameters:
 * layer - {<OpenLayers.Layer>}
 * setNewBaseLayer - {Boolean} Default is true
 * @param {!OpenLayers.Layer} layer
 * @param {boolean=} setNewBaseLayer
 * @return {void}
 */
OpenLayers.Map.prototype.removeLayer = function(layer, setNewBaseLayer) {};

/**
 * APIMethod: getNumLayers
 * 
 * Returns:
 * {Int} The number of layers attached to the map.
 * @return {number}
 */
OpenLayers.Map.prototype.getNumLayers = function() {};

/**
 * APIMethod: getLayerIndex
 * 
 * Parameters:
 * layer - {<OpenLayers.Layer>}
 * 
 * Returns:
 * {Integer} The current (zero-based) index of the given layer in the map's
 * layer stack. Returns -1 if the layer isn't on the map.
 * @param {!OpenLayers.Layer} layer
 * @return {number}
 */
OpenLayers.Map.prototype.getLayerIndex = function(layer) {};

/**
 * APIMethod: setLayerIndex
 * Move the given layer to the specified (zero-based) index in the layer
 * list, changing its z-index in the map display. Use
 * map.getLayerIndex() to find out the current index of a layer. Note
 * that this cannot (or at least should not) be effectively used to
 * raise base layers above overlays.
 * 
 * Parameters:
 * layer - {<OpenLayers.Layer>}
 * idx - {int}
 * @param {!OpenLayers.Layer} layer
 * @param {number} idx
 * @return {void}
 */
OpenLayers.Map.prototype.setLayerIndex = function(layer, idx) {};

/**
 * APIMethod: raiseLayer
 * Change the index of the given layer by delta. If delta is positive,
 * the layer is moved up the map's layer stack; if delta is negative,
 * the layer is moved down. Again, note that this cannot (or at least
 * should not) be effectively used to raise base layers above overlays.
 * 
 * Paremeters:
 * layer - {<OpenLayers.Layer>}
 * delta - {int}
 * @param {!OpenLayers.Layer} layer
 * @param {number} delta
 * @return {void}
 */
OpenLayers.Map.prototype.raiseLayer = function(layer, delta) {};

/**
 * APIMethod: setBaseLayer
 * Allows user to specify one of the currently-loaded layers as the Map's
 * new base layer.
 * 
 * Parameters:
 * newBaseLayer - {<OpenLayers.Layer>}
 * @param {!OpenLayers.Layer} newBaseLayer
 * @return {void}
 */
OpenLayers.Map.prototype.setBaseLayer = function(newBaseLayer) {};

/**
 * APIMethod: addControl
 * Add the passed over control to the map. Optionally
 * position the control at the given pixel.
 * 
 * Parameters:
 * control - {<OpenLayers.Control>}
 * px - {<OpenLayers.Pixel>}
 * @param {!OpenLayers.Control} control
 * @param {!OpenLayers.Pixel} px
 * @return {void}
 */
OpenLayers.Map.prototype.addControl = function(control, px) {};

/**
 * APIMethod: addControls
 * Add all of the passed over controls to the map.
 * You can pass over an optional second array
 * with pixel-objects to position the controls.
 * The indices of the two arrays should match and
 * you can add null as pixel for those controls
 * you want to be autopositioned.
 * 
 * Parameters:
 * controls - {Array(<OpenLayers.Control>)}
 * pixels - {Array(<OpenLayers.Pixel>)}
 * @param {!Array<!OpenLayers.Control>} controls
 * @param {!Array<!OpenLayers.Pixel>} pixels
 * @return {void}
 */
OpenLayers.Map.prototype.addControls = function(controls, pixels) {};

/**
 * Method: addControlToMap
 * 
 * Parameters:
 * 
 * control - {<OpenLayers.Control>}
 * px - {<OpenLayers.Pixel>}
 * @param {!OpenLayers.Control} control
 * @param {!OpenLayers.Pixel} px
 * @return {void}
 */
OpenLayers.Map.prototype.addControlToMap = function(control, px) {};

/**
 * APIMethod: getControl
 * 
 * Parameters:
 * id - {String} ID of the control to return.
 * 
 * Returns:
 * {<OpenLayers.Control>} The control from the map's list of controls
 * which has a matching 'id'. If none found,
 * returns null.
 * @param {string} id
 * @return {!OpenLayers.Control}
 */
OpenLayers.Map.prototype.getControl = function(id) {};

/**
 * APIMethod: removeControl
 * Remove a control from the map. Removes the control both from the map
 * object's internal array of controls, as well as from the map's
 * viewPort (assuming the control was not added outsideViewport)
 * 
 * Parameters:
 * control - {<OpenLayers.Control>} The control to remove.
 * @param {!OpenLayers.Control} control
 * @return {void}
 */
OpenLayers.Map.prototype.removeControl = function(control) {};

/**
 * APIMethod: addPopup
 * 
 * Parameters:
 * popup - {<OpenLayers.Popup>}
 * exclusive - {Boolean} If true, closes all other popups first
 * @param {!OpenLayers.Popup} popup
 * @param {boolean} exclusive
 * @return {void}
 */
OpenLayers.Map.prototype.addPopup = function(popup, exclusive) {};

/**
 * APIMethod: removePopup
 * 
 * Parameters:
 * popup - {<OpenLayers.Popup>}
 * @param {!OpenLayers.Popup} popup
 * @return {void}
 */
OpenLayers.Map.prototype.removePopup = function(popup) {};

/**
 * APIMethod: getSize
 * 
 * Returns:
 * {<OpenLayers.Size>} An <OpenLayers.Size> object that represents the
 * size, in pixels, of the div into which OpenLayers
 * has been loaded.
 * Note - A clone() of this locally cached variable is
 * returned, so as not to allow users to modify it.
 * @return {!OpenLayers.Size}
 */
OpenLayers.Map.prototype.getSize = function() {};

/**
 * APIMethod: updateSize
 * This function should be called by any external code which dynamically
 * changes the size of the map div (because mozilla wont let us catch
 * the "onresize" for an element)
 * @return {void}
 */
OpenLayers.Map.prototype.updateSize = function() {};

/**
 * Method: getCurrentSize
 * 
 * Returns:
 * {<OpenLayers.Size>} A new <OpenLayers.Size> object with the dimensions
 * of the map div
 * @return {!OpenLayers.Size}
 */
OpenLayers.Map.prototype.getCurrentSize = function() {};

/**
 * Method: calculateBounds
 * 
 * Parameters:
 * center - {<OpenLayers.LonLat>} Default is this.getCenter()
 * resolution - {float} Default is this.getResolution()
 * 
 * Returns:
 * {<OpenLayers.Bounds>} A bounds based on resolution, center, and
 * current mapsize.
 * @param {!OpenLayers.LonLat=} center
 * @param {number=} resolution
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Map.prototype.calculateBounds = function(center, resolution) {};

/**
 * APIMethod: getCenter
 * 
 * Returns:
 * {<OpenLayers.LonLat>}
 * @return {!OpenLayers.LonLat}
 */
OpenLayers.Map.prototype.getCenter = function() {};

/**
 * APIMethod: getZoom
 * 
 * Returns:
 * {Integer}
 * @return {number}
 */
OpenLayers.Map.prototype.getZoom = function() {};

/**
 * APIMethod: pan
 * Allows user to pan by a value of screen pixels
 * 
 * Parameters:
 * dx - {Integer}
 * dy - {Integer}
 * options - {Object} Options to configure panning:
 * - *animate* {Boolean} Use panTo instead of setCenter. Default is true.
 * - *dragging* {Boolean} Call setCenter with dragging true. Default is
 * false.
 * @param {number} dx
 * @param {number} dy
 * @param {{animate: boolean, dragging: boolean}=} options
 * @return {void}
 */
OpenLayers.Map.prototype.pan = function(dx, dy, options) {};

/**
 * APIMethod: panTo
 * Allows user to pan to a new lonlat
 * If the new lonlat is in the current extent the map will slide smoothly
 * 
 * Parameters:
 * lonlat - {<OpenLayers.LonLat>}
 * @param {!OpenLayers.LonLat} lonlat
 * @return {void}
 */
OpenLayers.Map.prototype.panTo = function(lonlat) {};

/**
 * APIMethod: setCenter
 * Set the map center (and optionally, the zoom level).
 * 
 * Parameters:
 * lonlat - {<OpenLayers.LonLat>|Array} The new center location.
 * If provided as array, the first value is the x coordinate,
 * and the 2nd value is the y coordinate.
 * zoom - {Integer} Optional zoom level.
 * dragging - {Boolean} Specifies whether or not to trigger
 * movestart/end events
 * forceZoomChange - {Boolean} Specifies whether or not to trigger zoom
 * change events (needed on baseLayer change)
 * @param {!OpenLayers.LonLat|!Array<number>} lonlat
 * @param {number=} zoom
 * @param {boolean=} dragging
 * @param {boolean=} forceZoomChange
 * @return {void}
 */
OpenLayers.Map.prototype.setCenter = function(lonlat, zoom, dragging, forceZoomChange) {};

/**
 * APIMethod: getMinZoom
 * Returns the minimum zoom level for the current map view. If the base
 * layer is configured with <wrapDateLine> set to true, this will be the
 * first zoom level that shows no more than one world width in the current
 * map viewport. Components that rely on this value (e.g. zoom sliders)
 * should also listen to the map's "updatesize" event and call this method
 * in the "updatesize" listener.
 * 
 * Returns:
 * {Number} Minimum zoom level that shows a map not wider than its
 * <baseLayer>'s maxExtent. This is an Integer value, unless the map is
 * configured with <fractionalZoom> set to true.
 * @return {number}
 */
OpenLayers.Map.prototype.getMinZoom = function() {};

/**
 * APIMethod: getProjection
 * This method returns a string representing the projection. In
 * the case of projection support, this will be the srsCode which
 * is loaded -- otherwise it will simply be the string value that
 * was passed to the projection at startup.
 * 
 * Returns:
 * {String} The Projection string from the base layer or null.
 * @return {string}
 */
OpenLayers.Map.prototype.getProjection = function() {};

/**
 * APIMethod: getProjectionObject
 * Returns the projection obect from the baselayer.
 * 
 * Returns:
 * {<OpenLayers.Projection>} The Projection of the base layer.
 * @return {!OpenLayers.Projection}
 */
OpenLayers.Map.prototype.getProjectionObject = function() {};

/**
 * APIMethod: getMaxResolution
 * 
 * Returns:
 * {String} The Map's Maximum Resolution
 * @return {string}
 */
OpenLayers.Map.prototype.getMaxResolution = function() {};

/**
 * APIMethod: getMaxExtent
 * 
 * Parameters:
 * options - {Object}
 * 
 * Allowed Options:
 * restricted - {Boolean} If true, returns restricted extent (if it is
 * available.)
 * 
 * Returns:
 * {<OpenLayers.Bounds>} The maxExtent property as set on the current
 * baselayer, unless the 'restricted' option is set, in which case
 * the 'restrictedExtent' option from the map is returned (if it
 * is set).
 * @param {{restricted: boolean}} options
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Map.prototype.getMaxExtent = function(options) {};

/**
 * APIMethod: getNumZoomLevels
 * 
 * Returns:
 * {Integer} The total number of zoom levels that can be displayed by the
 * current baseLayer.
 * @return {number}
 */
OpenLayers.Map.prototype.getNumZoomLevels = function() {};

/**
 * APIMethod: getExtent
 * 
 * Returns:
 * {<OpenLayers.Bounds>} A Bounds object which represents the lon/lat
 * bounds of the current viewPort.
 * If no baselayer is set, returns null.
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Map.prototype.getExtent = function() {};

/**
 * APIMethod: getResolution
 * 
 * Returns:
 * {Float} The current resolution of the map.
 * If no baselayer is set, returns null.
 * @return {number}
 */
OpenLayers.Map.prototype.getResolution = function() {};

/**
 * APIMethod: getUnits
 * 
 * Returns:
 * {Float} The current units of the map.
 * If no baselayer is set, returns null.
 * @return {number}
 */
OpenLayers.Map.prototype.getUnits = function() {};

/**
 * APIMethod: getScale
 * 
 * Returns:
 * {Float} The current scale denominator of the map.
 * If no baselayer is set, returns null.
 * @return {number}
 */
OpenLayers.Map.prototype.getScale = function() {};

/**
 * APIMethod: getZoomForExtent
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * closest - {Boolean} Find the zoom level that most closely fits the
 * specified bounds. Note that this may result in a zoom that does
 * not exactly contain the entire extent.
 * Default is false.
 * 
 * Returns:
 * {Integer} A suitable zoom level for the specified bounds.
 * If no baselayer is set, returns null.
 * @param {!OpenLayers.Bounds} bounds
 * @param {boolean=} closest
 * @return {number}
 */
OpenLayers.Map.prototype.getZoomForExtent = function(bounds, closest) {};

/**
 * APIMethod: getResolutionForZoom
 * 
 * Parameters:
 * zoom - {Float}
 * 
 * Returns:
 * {Float} A suitable resolution for the specified zoom. If no baselayer
 * is set, returns null.
 * @param {number} zoom
 * @return {number}
 */
OpenLayers.Map.prototype.getResolutionForZoom = function(zoom) {};

/**
 * APIMethod: getZoomForResolution
 * 
 * Parameters:
 * resolution - {Float}
 * closest - {Boolean} Find the zoom level that corresponds to the absolute
 * closest resolution, which may result in a zoom whose corresponding
 * resolution is actually smaller than we would have desired (if this
 * is being called from a getZoomForExtent() call, then this means that
 * the returned zoom index might not actually contain the entire
 * extent specified... but it'll be close).
 * Default is false.
 * 
 * Returns:
 * {Integer} A suitable zoom level for the specified resolution.
 * If no baselayer is set, returns null.
 * @param {number} resolution
 * @param {boolean=} closest
 * @return {number}
 */
OpenLayers.Map.prototype.getZoomForResolution = function(resolution, closest) {};

/**
 * APIMethod: zoomTo
 * Zoom to a specific zoom level. Zooming will be animated unless the map
 * is configured with {zoomMethod: null}. To zoom without animation, use
 * <setCenter> without a lonlat argument.
 * 
 * Parameters:
 * zoom - {Integer}
 * @param {number} zoom
 * @param {!OpenLayers.Pixel} px
 * @return {void}
 */
OpenLayers.Map.prototype.zoomTo = function(zoom, px) {};

/**
 * APIMethod: zoomIn
 * 
 * @return {void}
 */
OpenLayers.Map.prototype.zoomIn = function() {};

/**
 * APIMethod: zoomOut
 * 
 * @return {void}
 */
OpenLayers.Map.prototype.zoomOut = function() {};

/**
 * APIMethod: zoomToExtent
 * Zoom to the passed in bounds, recenter
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>|Array} If provided as an array, the array
 * should consist of four values (left, bottom, right, top).
 * closest - {Boolean} Find the zoom level that most closely fits the
 * specified bounds. Note that this may result in a zoom that does
 * not exactly contain the entire extent.
 * Default is false.
 * 
 * @param {!OpenLayers.Bounds|!Array<number>} bounds
 * @param {boolean=} closest
 * @return {void}
 */
OpenLayers.Map.prototype.zoomToExtent = function(bounds, closest) {};

/**
 * APIMethod: zoomToMaxExtent
 * Zoom to the full extent and recenter.
 * 
 * Parameters:
 * options - {Object}
 * 
 * Allowed Options:
 * restricted - {Boolean} True to zoom to restricted extent if it is
 * set. Defaults to true.
 * @param {{restricted: boolean}=} options
 * @return {void}
 */
OpenLayers.Map.prototype.zoomToMaxExtent = function(options) {};

/**
 * APIMethod: zoomToScale
 * Zoom to a specified scale
 * 
 * Parameters:
 * scale - {float}
 * closest - {Boolean} Find the zoom level that most closely fits the
 * specified scale. Note that this may result in a zoom that does
 * not exactly contain the entire extent.
 * Default is false.
 * 
 * @param {number} scale
 * @param {boolean} closest
 * @return {void}
 */
OpenLayers.Map.prototype.zoomToScale = function(scale, closest) {};

/**
 * APIMethod: getViewPortPxFromLonLat
 * 
 * Parameters:
 * lonlat - {<OpenLayers.LonLat>}
 * 
 * Returns:
 * {<OpenLayers.Pixel>} An OpenLayers.Pixel which is the passed-in
 * <OpenLayers.LonLat>, translated into view port
 * pixels by the current base layer.
 * @param {!OpenLayers.LonLat} lonlat
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Map.prototype.getViewPortPxFromLonLat = function(lonlat) {};

/**
 * APIMethod: getLonLatFromPixel
 * 
 * Parameters:
 * px - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an object with
 * a 'x' and 'y' properties.
 * 
 * Returns:
 * {<OpenLayers.LonLat>} An OpenLayers.LonLat corresponding to the given
 * OpenLayers.Pixel, translated into lon/lat by the
 * current base layer
 * @param {!OpenLayers.Pixel|{x: number, y: number}} px
 * @return {!OpenLayers.LonLat}
 */
OpenLayers.Map.prototype.getLonLatFromPixel = function(px) {};

/**
 * APIMethod: getPixelFromLonLat
 * Returns a pixel location given a map location. The map location is
 * translated to an integer pixel location (in viewport pixel
 * coordinates) by the current base layer.
 * 
 * Parameters:
 * lonlat - {<OpenLayers.LonLat>} A map location.
 * 
 * Returns:
 * {<OpenLayers.Pixel>} An OpenLayers.Pixel corresponding to the
 * <OpenLayers.LonLat> translated into view port pixels by the current
 * base layer.
 * @param {!OpenLayers.LonLat} lonlat
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Map.prototype.getPixelFromLonLat = function(lonlat) {};

/**
 * APIMethod: getViewPortPxFromLayerPx
 * 
 * Parameters:
 * layerPx - {<OpenLayers.Pixel>}
 * 
 * Returns:
 * {<OpenLayers.Pixel>} Layer Pixel translated into ViewPort Pixel
 * coordinates
 * @param {!OpenLayers.Pixel} layerPx
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Map.prototype.getViewPortPxFromLayerPx = function(layerPx) {};

/**
 * APIMethod: getLayerPxFromViewPortPx
 * 
 * Parameters:
 * viewPortPx - {<OpenLayers.Pixel>}
 * 
 * Returns:
 * {<OpenLayers.Pixel>} ViewPort Pixel translated into Layer Pixel
 * coordinates
 * @param {!OpenLayers.Pixel} viewPortPx
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Map.prototype.getLayerPxFromViewPortPx = function(viewPortPx) {};

/**
 * APIMethod: getLayerPxFromLonLat
 * 
 * Parameters:
 * lonlat - {<OpenLayers.LonLat>} lonlat
 * 
 * Returns:
 * {<OpenLayers.Pixel>} An OpenLayers.Pixel which is the passed-in
 * <OpenLayers.LonLat>, translated into layer pixels
 * by the current base layer
 * @param {!OpenLayers.LonLat} lonlat
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Map.prototype.getLayerPxFromLonLat = function(lonlat) {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Class = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Date = function() {};
 /** @type {string} */
OpenLayers.Date.prototype.dateRegEx;

/**
 * APIMethod: toISOString
 * Generates a string representing a date. The format of the string follows
 * the profile of ISO 8601 for date and time on the Internet (see
 * http://tools.ietf.org/html/rfc3339). If the toISOString method is
 * available on the Date prototype, that is used. The toISOString
 * method for Date instances is defined in ECMA-262.
 * 
 * Parameters:
 * date - {Date} A date object.
 * 
 * Returns:
 * {String} A string representing the date (e.g.
 * "2010-08-07T16:58:23.123Z"). If the date does not have a valid time
 * (i.e. isNaN(date.getTime())) this method returns the string "Invalid
 * Date". The ECMA standard says the toISOString method should throw
 * RangeError in this case, but Firefox returns a string instead. For
 * best results, use isNaN(date.getTime()) to determine date validity
 * before generating date strings.
 * @param {!OpenLayers.Date} date
 * @return {string}
 */
OpenLayers.Date.prototype.toISOString = function(date) {};

/**
 * APIMethod: parse
 * Generate a date object from a string. The format for the string follows
 * the profile of ISO 8601 for date and time on the Internet (see
 * http://tools.ietf.org/html/rfc3339). We don't call the native
 * Date.parse because of inconsistency between implmentations. In
 * Chrome, calling Date.parse with a string that doesn't contain any
 * indication of the timezone (e.g. "2011"), the date is interpreted
 * in local time. On Firefox, the assumption is UTC.
 * 
 * Parameters:
 * str - {String} A string representing the date (e.g.
 * "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
 * "2010-08-07T11:58:23.123-06").
 * 
 * Returns:
 * {Date} A date object. If the string could not be parsed, an invalid
 * date is returned (i.e. isNaN(date.getTime())).
 * @param {string} str
 * @return {!OpenLayers.Date}
 */
OpenLayers.Date.prototype.parse = function(str) {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Element = function() {};

/**
 * APIFunction: visible
 * 
 * Parameters:
 * element - {DOMElement}
 * 
 * Returns:
 * {Boolean} Is the element visible?
 * @param {!HTMLElement} element
 * @return {boolean}
 */
OpenLayers.Element.prototype.visible = function(element) {};

/**
 * APIFunction: toggle
 * Toggle the visibility of element(s) passed in
 * 
 * Parameters:
 * element - {DOMElement} Actually user can pass any number of elements
 * @param {!HTMLElement} element
 * @return {void}
 */
OpenLayers.Element.prototype.toggle = function(element) {};

/**
 * APIFunction: remove
 * Remove the specified element from the DOM.
 * 
 * Parameters:
 * element - {DOMElement}
 * @param {!HTMLElement} element
 * @return {void}
 */
OpenLayers.Element.prototype.remove = function(element) {};

/**
 * APIFunction: getHeight
 * 
 * Parameters:
 * element - {DOMElement}
 * 
 * Returns:
 * {Integer} The offset height of the element passed in
 * @param {!HTMLElement} element
 * @return {number}
 */
OpenLayers.Element.prototype.getHeight = function(element) {};

/**
 * Function: hasClass
 * Tests if an element has the given CSS class name.
 * 
 * Parameters:
 * element - {DOMElement} A DOM element node.
 * name - {String} The CSS class name to search for.
 * 
 * Returns:
 * {Boolean} The element has the given class name.
 * @param {!HTMLElement} element
 * @param {string} name
 * @return {boolean}
 */
OpenLayers.Element.prototype.hasClass = function(element, name) {};

/**
 * Function: addClass
 * Add a CSS class name to an element. Safe where element already has
 * the class name.
 * 
 * Parameters:
 * element - {DOMElement} A DOM element node.
 * name - {String} The CSS class name to add.
 * 
 * Returns:
 * {DOMElement} The element.
 * @param {!HTMLElement} element
 * @param {string} name
 * @return {!HTMLElement}
 */
OpenLayers.Element.prototype.addClass = function(element, name) {};

/**
 * Function: removeClass
 * Remove a CSS class name from an element. Safe where element does not
 * have the class name.
 * 
 * Parameters:
 * element - {DOMElement} A DOM element node.
 * name - {String} The CSS class name to remove.
 * 
 * Returns:
 * {DOMElement} The element.
 * @param {!HTMLElement} element
 * @param {string} name
 * @return {!HTMLElement}
 */
OpenLayers.Element.prototype.removeClass = function(element, name) {};

/**
 * Function: toggleClass
 * Remove a CSS class name from an element if it exists. Add the class name
 * if it doesn't exist.
 * 
 * Parameters:
 * element - {DOMElement} A DOM element node.
 * name - {String} The CSS class name to toggle.
 * 
 * Returns:
 * {DOMElement} The element.
 * @param {!HTMLElement} element
 * @param {string} name
 * @return {!HTMLElement}
 */
OpenLayers.Element.prototype.toggleClass = function(element, name) {};

/**
 * APIFunction: getStyle
 * 
 * Parameters:
 * element - {DOMElement}
 * style - {?}
 * 
 * Returns:
 * {?}
 * @param {!HTMLElement} element
 * @param {?} style
 * @return {?}
 */
OpenLayers.Element.prototype.getStyle = function(element, style) {};

/**
 * @constructor
 * @struct
 * Constructor: OpenLayers.Pixel
 * Create a new OpenLayers.Pixel instance
 * 
 * Parameters:
 * x - {Number} The x coordinate
 * y - {Number} The y coordinate
 * 
 * Returns:
 * An instance of OpenLayers.Pixel
 * @param {number} x
 * @param {number} y
 */
OpenLayers.Pixel = function(x, y) {};
 /** @type {number} */
OpenLayers.Pixel.prototype.x;
 /** @type {number} */
OpenLayers.Pixel.prototype.y;
 /** @type {string} */
OpenLayers.Pixel.prototype.CLASS_NAME;

/**
 * APIMethod: clone
 * Return a clone of this pixel object
 * 
 * Returns:
 * {<OpenLayers.Pixel>} A clone pixel
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Pixel.prototype.clone = function() {};

/**
 * APIMethod: equals
 * Determine whether one pixel is equivalent to another
 * 
 * Parameters:
 * px - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an object with
 * a 'x' and 'y' properties.
 * 
 * Returns:
 * {Boolean} The point passed in as parameter is equal to this. Note that
 * if px passed in is null, returns false.
 * @param {!OpenLayers.Pixel|{x: number, y: number}} px
 * @return {boolean}
 */
OpenLayers.Pixel.prototype.equals = function(px) {};

/**
 * APIMethod: distanceTo
 * Returns the distance to the pixel point passed in as a parameter.
 * 
 * Parameters:
 * px - {<OpenLayers.Pixel>}
 * 
 * Returns:
 * {Float} The pixel point passed in as parameter to calculate the
 * distance to.
 * @param {!OpenLayers.Pixel} px
 * @return {number}
 */
OpenLayers.Pixel.prototype.distanceTo = function(px) {};

/**
 * APIMethod: add
 * 
 * Parameters:
 * x - {Integer}
 * y - {Integer}
 * 
 * Returns:
 * {<OpenLayers.Pixel>} A new Pixel with this pixel's x&y augmented by the
 * values passed in.
 * @param {number} x
 * @param {number} y
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Pixel.prototype.add = function(x, y) {};

/**
 * APIMethod: offset
 * 
 * Parameters
 * px - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an object with
 * a 'x' and 'y' properties.
 * 
 * Returns:
 * {<OpenLayers.Pixel>} A new Pixel with this pixel's x&y augmented by the
 * x&y values of the pixel passed in.
 * @param {!OpenLayers.Pixel|{x: number, y: number}} px
 * @return {!OpenLayers.Pixel}
 */
OpenLayers.Pixel.prototype.offset = function(px) {};

/**
 * @constructor
 * @struct
 * Constructor: OpenLayers.Size
 * Create an instance of OpenLayers.Size
 * 
 * Parameters:
 * w - {Number} width
 * h - {Number} height
 * @param {number} w
 * @param {number} h
 */
OpenLayers.Size = function(w, h) {};
 /** @type {number} */
OpenLayers.Size.prototype.w;
 /** @type {number} */
OpenLayers.Size.prototype.h;
 /** @type {string} */
OpenLayers.Size.prototype.CLASS_NAME;

/**
 * Method: toString
 * Return the string representation of a size object
 * 
 * Returns:
 * {String} The string representation of OpenLayers.Size object.
 * (e.g. <i>"w=55,h=66"</i>)
 * @return {string}
 */
OpenLayers.Size.prototype.toString = function() {};

/**
 * APIMethod: clone
 * Create a clone of this size object
 * 
 * Returns:
 * {<OpenLayers.Size>} A new OpenLayers.Size object with the same w and h
 * values
 * @return {!OpenLayers.Size}
 */
OpenLayers.Size.prototype.clone = function() {};

/**
 * 
 * APIMethod: equals
 * Determine where this size is equal to another
 * 
 * Parameters:
 * sz - {<OpenLayers.Size>|Object} An OpenLayers.Size or an object with
 * a 'w' and 'h' properties.
 * 
 * Returns:
 * {Boolean} The passed in size has the same h and w properties as this one.
 * Note that if sz passed in is null, returns false.
 * @param {!OpenLayers.Size} sz
 * @return {boolean}
 */
OpenLayers.Size.prototype.equals = function(sz) {};

/**
 * @constructor
 * @struct
 * Creates a Geometry Collection -- a list of geoms.
 * @param {!Array<!OpenLayers.Geometry>} components
 */
OpenLayers.Geometry.Collection = function(components) {};
 /** @type {!Array<!OpenLayers.Geometry>} */
OpenLayers.Geometry.Collection.prototype.components;
 /** @type {!Array<string>} */
OpenLayers.Geometry.Collection.prototype.componentTypes;
 /** @type {string} */
OpenLayers.Geometry.Collection.CLASS_NAME;

/**
 * Destroy this geometry.
 * @return {void}
 */
OpenLayers.Geometry.Collection.prototype.destroy = function() {};

/**
 * Clone this geometry.
 * @return {!OpenLayers.Geometry.Collection}
 */
OpenLayers.Geometry.Collection.prototype.clone = function() {};

/**
 * Get a string representing the components for this collection
 * @return {string}
 */
OpenLayers.Geometry.Collection.prototype.getComponentsString = function() {};

/**
 * Recalculate the bounds by iterating through the components and
 * calling calling extendBounds() on each item.
 * @return {void}
 */
OpenLayers.Geometry.Collection.prototype.calculateBounds = function() {};

/**
 * Add components to this geometry.
 * @param {!Array<!OpenLayers.Geometry>} components
 * @return {void}
 */
OpenLayers.Geometry.Collection.prototype.addComponents = function(components) {};

/**
 * Add a new component (geometry) to the collection. If this.componentTypes
 * is set, then the component class name must be in the componentTypes array.
 * @param {!OpenLayers.Geometry} component
 * @param {number} index
 * @return {boolean}
 */
OpenLayers.Geometry.Collection.prototype.addComponent = function(component, index) {};

/**
 * Remove components from this geometry.
 * @param {!Array<!OpenLayers.Geometry>} components
 * @return {boolean}
 */
OpenLayers.Geometry.Collection.prototype.removeComponents = function(components) {};

/**
 * Remove a component from this geometry.
 * @param {!OpenLayers.Geometry} component
 * @return {boolean}
 */
OpenLayers.Geometry.Collection.prototype.removeComponent = function(component) {};

/**
 * Calculate the length of this geometry
 * @return {number}
 */
OpenLayers.Geometry.Collection.prototype.getLength = function() {};

/**
 * Calculate the area of this geometry. Note how this function is overridden
 * in <OpenLayers.Geometry.Polygon>.
 * @return {number}
 */
OpenLayers.Geometry.Collection.prototype.getArea = function() {};

/**
 * Calculate the approximate area of the polygon were it projected onto
 * the earth.
 * @param {!OpenLayers.Projection} projection
 * @return {number}
 */
OpenLayers.Geometry.Collection.prototype.getGeodesicArea = function(projection) {};

/**
 * Compute the centroid for this geometry collection.
 * @param {boolean=} weighted
 * @return {!OpenLayers.Geometry.Point}
 */
OpenLayers.Geometry.Collection.prototype.getCentroid = function(weighted) {};

/**
 * Calculate the approximate length of the geometry were it projected onto
 * the earth.
 * @param {!OpenLayers.Projection} projection
 * @return {number}
 */
OpenLayers.Geometry.Collection.prototype.getGeodesicLength = function(projection) {};

/**
 * Moves a geometry by the given displacement along positive x and y axes.
 * This modifies the position of the geometry and clears the cached
 * bounds.
 * @param {number} x
 * @param {number} y
 * @return {void}
 */
OpenLayers.Geometry.Collection.prototype.move = function(x, y) {};

/**
 * Rotate a geometry around some origin
 * @param {number} angle
 * @param {!OpenLayers.Geometry.Point} origin
 * @return {void}
 */
OpenLayers.Geometry.Collection.prototype.rotate = function(angle, origin) {};

/**
 * Resize a geometry relative to some origin. Use this method to apply
 * a uniform scaling to a geometry.
 * @param {number} scale
 * @param {!OpenLayers.Geometry.Point} origin
 * @param {number} ratio
 * @return {!OpenLayers.Geometry}
 */
OpenLayers.Geometry.Collection.prototype.resize = function(scale, origin, ratio) {};

/**
 * Calculate the closest distance between two geometries (on the x-y plane).
 * @param {!OpenLayers.Geometry} geometry
 * @param {!OpenLayers.DistanceOptions} options
 * @return {!Object}
 */
OpenLayers.Geometry.Collection.prototype.distanceTo = function(geometry, options) {};

/**
 * Determine whether another geometry is equivalent to this one. Geometries
 * are considered equivalent if all components have the same coordinates.
 * @param {!OpenLayers.Geometry} geometry
 * @return {boolean}
 */
OpenLayers.Geometry.Collection.prototype.equals = function(geometry) {};

/**
 * Reproject the components geometry from source to dest.
 * @param {!OpenLayers.Projection} source
 * @param {!OpenLayers.Projection} dest
 * @return {!OpenLayers.Geometry}
 */
OpenLayers.Geometry.Collection.prototype.transform = function(source, dest) {};

/**
 * Determine if the input geometry intersects this one.
 * @param {!OpenLayers.Geometry} geometry
 * @return {boolean}
 */
OpenLayers.Geometry.Collection.prototype.intersects = function(geometry) {};

/**
 * Return a list of all points in this geometry.
 * @param {boolean} nodes
 * @return {!Array<?>}
 */
OpenLayers.Geometry.Collection.prototype.getVertices = function(nodes) {};

/**
 * @constructor
 * @struct
 * Construct a point geometry.
 * @param {number} x
 * @param {number} y
 */
OpenLayers.Geometry.Point = function(x, y) {};
 /** @type {number} */
OpenLayers.Geometry.Point.prototype.x;
 /** @type {number} */
OpenLayers.Geometry.Point.prototype.y;

/**
 * Create a clone of this geometry.
 * An exact clone of this OpenLayers.Geometry.Point
 * @param {!OpenLayers.Geometry.Point=} obj
 * @return {!OpenLayers.Geometry|!OpenLayers.Geometry.Point}
 */
OpenLayers.Geometry.Point.prototype.clone = function(obj) {};

/**
 * Calculate the closest distance between two geometries (on the x-y plane).
 * @param {!OpenLayers.Geometry} geometry
 * @param {!OpenLayers.DistanceOptions} options
 * @return {!Object}
 */
OpenLayers.Geometry.Point.prototype.distanceTo = function(geometry, options) {};

/**
 * Determine whether another geometry is equivalent to this one.  Geometries are considered equivalent if all components have the same coordinates.
 * @param {!OpenLayers.Geometry.Point} geom
 * @return {boolean}
 */
OpenLayers.Geometry.Point.prototype.equals = function(geom) {};

/**
 * Moves a geometry by the given displacement along positive x and y axes.  This modifies the position of the geometry and clears the cached bounds.
 * @param {number} x
 * @param {number} y
 * @return {void}
 */
OpenLayers.Geometry.Point.prototype.move = function(x, y) {};

/**
 * Rotate a point around another.
 * @param {number} angle
 * @param {!OpenLayers.Geometry.Point} origin
 * @return {void}
 */
OpenLayers.Geometry.Point.prototype.rotate = function(angle, origin) {};

/**
 * Resize a point relative to some origin.  For points, this has the effect of scaling a vector (from the origin to the point).  This method is more useful on geometry collection subclasses.
 * @param {number} scale
 * @param {!OpenLayers.Geometry.Point} origin
 * @param {number} ratio
 * @return {!OpenLayers.Geometry}
 */
OpenLayers.Geometry.Point.prototype.resize = function(scale, origin, ratio) {};

/**
 * Determine if the input geometry intersects this one.
 * @param {!OpenLayers.Geometry} geometry
 * @return {boolean}
 */
OpenLayers.Geometry.Point.prototype.intersects = function(geometry) {};

/**
 * Translate the x,y properties of the point from source to dest.
 * @param {!OpenLayers.Projection} source
 * @param {!OpenLayers.Projection} dest
 * @return {!OpenLayers.Geometry}
 */
OpenLayers.Geometry.Point.prototype.transform = function(source, dest) {};

/**
 * Return a list of all points in this geometry.
 * @param {boolean} nodes
 * @return {!Array<?>}
 */
OpenLayers.Geometry.Point.prototype.getVertices = function(nodes) {};
/**
 * @extends {OpenLayers.Geometry.MultiPoint}
 * @constructor
 * @struct
 */
OpenLayers.Geometry.Curve = function() {};
/**
 * @extends {OpenLayers.Geometry.Curve}
 * @constructor
 * @struct
 */
OpenLayers.Geometry.LineString = function() {};
/**
 * @extends {OpenLayers.Geometry.LineString}
 * @constructor
 * @struct
 */
OpenLayers.Geometry.LinearRing = function() {};
/**
 * @extends {OpenLayers.Geometry.Collection}
 * @constructor
 * @struct
 */
OpenLayers.Geometry.MultiLineString = function() {};
/**
 * @extends {OpenLayers.Geometry.Collection}
 * @constructor
 * @struct
 */
OpenLayers.Geometry.MultiPoint = function() {};
/**
 * @extends {OpenLayers.Geometry.Collection}
 * @constructor
 * @struct
 */
OpenLayers.Geometry.MultiPolygon = function() {};
/**
 * @extends {OpenLayers.Geometry.Collection}
 * @constructor
 * @struct
 */
OpenLayers.Geometry.Polygon = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.ArgParser = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Attribution = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Button = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.CacheRead = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.CacheWrite = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.DragFeature = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.DragPan = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.DrawFeature = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.EditingToolbar = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Geolocate = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.GetFeature = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Graticule = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.KeyboardDefaults = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.LayerSwitcher = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Measure = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.ModifyFeature = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.MousePosition = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.NavToolbar = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Navigation = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.NavigationHistory = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.OverviewMap = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Pan = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.PanPanel = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.PanZoom = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.PanZoomBar = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Panel = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Permalink = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.PinchZoom = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.SLDSelect = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Scale = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.ScaleLine = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.SelectFeature = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Snapping = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Split = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.TextButtonPanel = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.TouchNavigation = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.TransformFeature = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.UTFGrid = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.WMSGetFeatureInfo = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.WMTSGetFeatureInfo = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.Zoom = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.ZoomBox = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.ZoomIn = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.ZoomOut = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.ZoomPanel = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Control.ZoomToMaxExtent = function() {};
/**
 * @extends {OpenLayers.Class}
 * @constructor
 * @struct
 */
OpenLayers.Events.buttonclick = function() {};
/**
 * @extends {OpenLayers.Class}
 * @constructor
 * @struct
 */
OpenLayers.Events.featureclick = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Feature.Vector = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Filter.Comparison = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Filter.FeatureId = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Filter.Function = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Filter.Logical = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Filter.Spatial = function() {};

/**
 * @constructor
 * @struct
 */
OpenLayers.Format.ArcXML = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.Atom = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.CQL = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.CSWGetDomain = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.CSWGetRecords = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.Context = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.EncodedPolyline = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.Filter = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.GML = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.GPX = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.GeoJSON = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.GeoRSS = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.JSON = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.KML = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.OGCExceptionReport = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.OSM = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.OWSCommon = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.OWSContext = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.QueryStringFilter = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.SLD = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.SOSCapabilities = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.SOSGetFeatureOfInterest = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.SOSGetObservation = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.TMSCapabilities = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.Text = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WCSCapabilities = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WCSDescribeCoverage = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WCSGetCoverage = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WFS = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WFSCapabilities = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WFSDescribeFeatureType = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WFST = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WKT = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WMC = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WMSCapabilities = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WMSDescribeLayer = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WMSGetFeatureInfo = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WMTSCapabilities = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WPSCapabilities = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WPSDescribeProcess = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.WPSExecute = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.XLS = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.XML = function() {};
/**
 * @extends {OpenLayers.Class}
 * @constructor
 * @struct
 */
OpenLayers.Format.ArcXML.Features = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.CSWGetDomain.v2_0_2 = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Format.CSWGetRecords.v2_0_2 = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Box = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Click = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Drag = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Feature = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Hover = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Keyboard = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.MouseWheel = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Path = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Pinch = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Point = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.Polygon = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Handler.RegularPolygon = function() {};
/**
 * @record
 * @struct
 */
OpenLayers.Layer.WMSGetMapParams = function() {};
 /** @type {string} */
OpenLayers.Layer.WMSGetMapParams.prototype.version;
 /** @type {string} */
OpenLayers.Layer.WMSGetMapParams.prototype.exceptions;
 /** @type {string} */
OpenLayers.Layer.WMSGetMapParams.prototype.transparent;
 /** @type {string} */
OpenLayers.Layer.WMSGetMapParams.prototype.format;
 /** @type {string} */
OpenLayers.Layer.WMSGetMapParams.prototype.styles;
 /** @type {string} */
OpenLayers.Layer.WMSGetMapParams.prototype.layers;
 /** @type {string} */
OpenLayers.Layer.WMSGetMapParams.prototype.service;
/**
 * @record
 * @struct
 */
OpenLayers.Layer.WMSOptions = function() {};
 /** @type {number} */
OpenLayers.Layer.WMSOptions.prototype.opacity;
 /** @type {boolean} */
OpenLayers.Layer.WMSOptions.prototype.singleTile;
 /** @type {boolean} */
OpenLayers.Layer.WMSOptions.prototype.isBaseLayer;
 /** @type {boolean} */
OpenLayers.Layer.WMSOptions.prototype.encodeBBOX;
 /** @type {boolean} */
OpenLayers.Layer.WMSOptions.prototype.noMagic;
 /** @type {!Object} */
OpenLayers.Layer.WMSOptions.prototype.yx;
/**
 * @record
 * @struct
 */
OpenLayers.Layer.TileOptions = function() {};
 /** @type {string} */
OpenLayers.Layer.TileOptions.prototype.crossOriginKeyword;
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.ArcGIS93Rest = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.ArcGISCache = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.ArcIMS = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.Bing = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.Boxes = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.EventPane = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.FixedZoomLevels = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.GeoRSS = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.Google = function() {};

/**
 * @constructor
 * @struct
 * Constructor: OpenLayers.Layer.Grid
 * Create a new grid layer
 * 
 * Parameters:
 * name - {String}
 * url - {String}
 * params - {Object}
 * options - {Object} Hashtable of extra options to tag onto the layer
 * @param {string} name
 * @param {string} url
 * @param {!Object} params
 * @param {!Object} options
 */
OpenLayers.Layer.Grid = function(name, url, params, options) {};
 /** @type {!OpenLayers.Size} */
OpenLayers.Layer.Grid.prototype.tileSize;
 /** @type {string} */
OpenLayers.Layer.Grid.prototype.tileOriginCorner;
 /** @type {!OpenLayers.LonLat} */
OpenLayers.Layer.Grid.prototype.tileOrigin;
 /** @type {!Object} */
OpenLayers.Layer.Grid.prototype.tileOptions;
 /** @type {!OpenLayers.Tile} */
OpenLayers.Layer.Grid.prototype.tileClass;
 /** @type {!Array<!Array<!OpenLayers.Tile>>} */
OpenLayers.Layer.Grid.prototype.grid;
 /** @type {boolean} */
OpenLayers.Layer.Grid.prototype.singleTile;
 /** @type {number} */
OpenLayers.Layer.Grid.prototype.ratio;
 /** @type {number} */
OpenLayers.Layer.Grid.prototype.buffer;
 /** @type {string} */
OpenLayers.Layer.Grid.prototype.transitionEffect;
 /** @type {number} */
OpenLayers.Layer.Grid.prototype.numLoadingTiles;
 /** @type {!Array<number>} */
OpenLayers.Layer.Grid.prototype.serverResolutions;
 /** @type {boolean} */
OpenLayers.Layer.Grid.prototype.loading;
 /** @type {!HTMLElement} */
OpenLayers.Layer.Grid.prototype.backBuffer;
 /** @type {number} */
OpenLayers.Layer.Grid.prototype.gridResolution;
 /** @type {number} */
OpenLayers.Layer.Grid.prototype.backBufferResolution;
 /** @type {{lon: number, lat: number}} */
OpenLayers.Layer.Grid.prototype.backBufferLonLat;
 /** @type {number} */
OpenLayers.Layer.Grid.prototype.backBufferTimerId;
 /** @type {number} */
OpenLayers.Layer.Grid.prototype.removeBackBufferDelay;
 /** @type {string} */
OpenLayers.Layer.Grid.prototype.className;
 /** @type {{tilelon: number, tilelat: number, startcol: number, startrow: number}} */
OpenLayers.Layer.Grid.prototype.gridLayout;
 /** @type {number} */
OpenLayers.Layer.Grid.prototype.rowSign;
 /** @type {!Array<string>} */
OpenLayers.Layer.Grid.prototype.transitionendEvents;

/**
 * Method: initProperties
 * Set any properties that depend on the value of singleTile.
 * Currently sets removeBackBufferDelay and className
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.initProperties = function() {};

/**
 * Method: setMap
 * 
 * Parameters:
 * map - {<OpenLayers.Map>} The map.
 * @param {!OpenLayers.Map} map
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.setMap = function(map) {};

/**
 * Method: removeMap
 * Called when the layer is removed from the map.
 * 
 * Parameters:
 * map - {<OpenLayers.Map>} The map.
 * @param {!OpenLayers.Map} map
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.removeMap = function(map) {};

/**
 * APIMethod: destroy
 * Deconstruct the layer and clear the grid.
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.destroy = function() {};

/**
 * Method: clearGrid
 * Go through and remove all tiles from the grid, calling
 * destroy() on each of them to kill circular references
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.clearGrid = function() {};

/**
 * APIMethod: addOptions
 * 
 * Parameters:
 * newOptions - {Object}
 * reinitialize - {Boolean} If set to true, and if resolution options of the
 * current baseLayer were changed, the map will be recentered to make
 * sure that it is displayed with a valid resolution, and a
 * changebaselayer event will be triggered.
 * @param {!Object} newOptions
 * @param {boolean} reinitialize
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.addOptions = function(newOptions, reinitialize) {};

/**
 * APIMethod: clone
 * Create a clone of this layer
 * 
 * Parameters:
 * obj - {Object} Is this ever used?
 * 
 * Returns:
 * {<OpenLayers.Layer.Grid>} An exact clone of this OpenLayers.Layer.Grid
 * @param {!Object=} obj
 * @return {!OpenLayers.Layer.Grid}
 */
OpenLayers.Layer.Grid.prototype.clone = function(obj) {};

/**
 * Method: moveTo
 * This function is called whenever the map is moved. All the moving
 * of actual 'tiles' is done by the map, but moveTo's role is to accept
 * a bounds and make sure the data that that bounds requires is pre-loaded.
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * zoomChanged - {Boolean}
 * dragging - {Boolean}
 * @param {!OpenLayers.Bounds} bounds
 * @param {boolean} zoomChanged
 * @param {boolean} dragging
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.moveTo = function(bounds, zoomChanged, dragging) {};

/**
 * Method: getTileData
 * Given a map location, retrieve a tile and the pixel offset within that
 * tile corresponding to the location. If there is not an existing
 * tile in the grid that covers the given location, null will be
 * returned.
 * 
 * Parameters:
 * loc - {<OpenLayers.LonLat>} map location
 * 
 * Returns:
 * {Object} Object with the following properties: tile ({<OpenLayers.Tile>}),
 * i ({Number} x-pixel offset from top left), and j ({Integer} y-pixel
 * offset from top left).
 * @param {!OpenLayers.LonLat} loc
 * @return {{tile: !OpenLayers.Tile, i: number, j: number}}
 */
OpenLayers.Layer.Grid.prototype.getTileData = function(loc) {};

/**
 * Method: destroyTile
 * 
 * Parameters:
 * tile - {<OpenLayers.Tile>}
 * @param {!OpenLayers.Tile} tile
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.destroyTile = function(tile) {};

/**
 * Method: getServerResolution
 * Return the closest server-supported resolution.
 * 
 * Parameters:
 * resolution - {Number} The base resolution. If undefined the
 * map resolution is used.
 * 
 * Returns:
 * {Number} The closest server resolution value.
 * @param {number} resolution
 * @return {number}
 */
OpenLayers.Layer.Grid.prototype.getServerResolution = function(resolution) {};

/**
 * Method: getServerZoom
 * Return the zoom value corresponding to the best matching server
 * resolution, taking into account <serverResolutions> and <zoomOffset>.
 * 
 * Returns:
 * {Number} The closest server supported zoom. This is not the map zoom
 * level, but an index of the server's resolutions array.
 * @return {number}
 */
OpenLayers.Layer.Grid.prototype.getServerZoom = function() {};

/**
 * Method: applyBackBuffer
 * Create, insert, scale and position a back buffer for the layer.
 * 
 * Parameters:
 * resolution - {Number} The resolution to transition to.
 * @param {number} resolution
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.applyBackBuffer = function(resolution) {};

/**
 * Method: createBackBuffer
 * Create a back buffer.
 * 
 * Returns:
 * {DOMElement} The DOM element for the back buffer, undefined if the
 * grid isn't initialized yet.
 * @return {!HTMLElement}
 */
OpenLayers.Layer.Grid.prototype.createBackBuffer = function() {};

/**
 * Method: removeBackBuffer
 * Remove back buffer from DOM.
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.removeBackBuffer = function() {};

/**
 * Method: moveByPx
 * Move the layer based on pixel vector.
 * 
 * Parameters:
 * dx - {Number}
 * dy - {Number}
 * @param {number} dx
 * @param {number} dy
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.moveByPx = function(dx, dy) {};

/**
 * APIMethod: setTileSize
 * Check if we are in singleTile mode and if so, set the size as a ratio
 * of the map size (as specified by the layer's 'ratio' property).
 * 
 * Parameters:
 * size - {<OpenLayers.Size>}
 * @param {!OpenLayers.Size} size
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.setTileSize = function(size) {};

/**
 * APIMethod: getTilesBounds
 * Return the bounds of the tile grid.
 * 
 * Returns:
 * {<OpenLayers.Bounds>} A Bounds object representing the bounds of all the
 * currently loaded tiles (including those partially or not at all seen
 * onscreen).
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Layer.Grid.prototype.getTilesBounds = function() {};

/**
 * Method: initSingleTile
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * @param {!OpenLayers.Bounds} bounds
 * @return {?}
 */
OpenLayers.Layer.Grid.prototype.initSingleTile = function(bounds) {};

/**
 * Method: calculateGridLayout
 * Generate parameters for the grid layout.
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bound>|Object} OpenLayers.Bounds or an
 * object with a 'left' and 'top' properties.
 * origin - {<OpenLayers.LonLat>|Object} OpenLayers.LonLat or an
 * object with a 'lon' and 'lat' properties.
 * resolution - {Number}
 * 
 * Returns:
 * {Object} Object containing properties tilelon, tilelat, startcol,
 * startrow
 * @param {!OpenLayers.Bounds} bounds
 * @param {!OpenLayers.LonLat} origin
 * @param {number} resolution
 * @return {{tilelon: number, tilelat: number, startcol: number, startrow: number}}
 */
OpenLayers.Layer.Grid.prototype.calculateGridLayout = function(bounds, origin, resolution) {};

/**
 * @return {!OpenLayers.Size}
 */
OpenLayers.Layer.Grid.prototype.getImageSize = function() {};

/**
 * Method: getTileOrigin
 * Determine the origin for aligning the grid of tiles. If a <tileOrigin>
 * property is supplied, that will be returned. Otherwise, the origin
 * will be derived from the layer's <maxExtent> property. In this case,
 * the tile origin will be the corner of the <maxExtent> given by the
 * <tileOriginCorner> property.
 * 
 * Returns:
 * {<OpenLayers.LonLat>} The tile origin.
 * @return {!OpenLayers.LonLat}
 */
OpenLayers.Layer.Grid.prototype.getTileOrigin = function() {};

/**
 * Method: getTileBoundsForGridIndex
 * 
 * Parameters:
 * row - {Number} The row of the grid
 * col - {Number} The column of the grid
 * 
 * Returns:
 * {<OpenLayers.Bounds>} The bounds for the tile at (row, col)
 * @param {number} row
 * @param {number} col
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Layer.Grid.prototype.getTileBoundsForGridIndex = function(row, col) {};

/**
 * Method: initGriddedTiles
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * @param {!OpenLayers.Bounds} bounds
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.initGriddedTiles = function(bounds) {};

/**
 * Method: getMaxExtent
 * Get this layer's maximum extent. (Implemented as a getter for
 * potential specific implementations in sub-classes.)
 * 
 * Returns:
 * {<OpenLayers.Bounds>}
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Layer.Grid.prototype.getMaxExtent = function() {};

/**
 * APIMethod: addTile
 * Create a tile, initialize it, and add it to the layer div.
 * 
 * Parameters
 * bounds - {<OpenLayers.Bounds>}
 * position - {<OpenLayers.Pixel>}
 * 
 * Returns:
 * {<OpenLayers.Tile>} The added OpenLayers.Tile
 * @param {!OpenLayers.Bounds} bounds
 * @param {number} position
 * @return {!OpenLayers.Tile}
 */
OpenLayers.Layer.Grid.prototype.addTile = function(bounds, position) {};

/**
 * Method: addTileMonitoringHooks
 * This function takes a tile as input and adds the appropriate hooks to
 * the tile so that the layer can keep track of the loading tiles.
 * 
 * Parameters:
 * tile - {<OpenLayers.Tile>}
 * @param {!OpenLayers.Tile} tile
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.addTileMonitoringHooks = function(tile) {};

/**
 * Method: removeTileMonitoringHooks
 * This function takes a tile as input and removes the tile hooks
 * that were added in addTileMonitoringHooks()
 * 
 * Parameters:
 * tile - {<OpenLayers.Tile>}
 * @param {!OpenLayers.Tile} tile
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.removeTileMonitoringHooks = function(tile) {};

/**
 * Method: moveGriddedTiles
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.moveGriddedTiles = function() {};

/**
 * Method: shiftRow
 * Shifty grid work
 * 
 * Parameters:
 * prepend - {Boolean} if true, prepend to beginning.
 * if false, then append to end
 * tileSize - {Object} rendered tile size; object with w and h properties
 * @param {boolean} prepend
 * @param {{w: number, h: number}} tileSize
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.shiftRow = function(prepend, tileSize) {};

/**
 * Method: shiftColumn
 * Shift grid work in the other dimension
 * 
 * Parameters:
 * prepend - {Boolean} if true, prepend to beginning.
 * if false, then append to end
 * tileSize - {Object} rendered tile size; object with w and h properties
 * @param {boolean} prepend
 * @param {{w: number, h: number}} tileSize
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.shiftColumn = function(prepend, tileSize) {};

/**
 * Method: removeExcessTiles
 * When the size of the map or the buffer changes, we may need to
 * remove some excess rows and columns.
 * 
 * Parameters:
 * rows - {Integer} Maximum number of rows we want our grid to have.
 * columns - {Integer} Maximum number of columns we want our grid to have.
 * @param {number} rows
 * @param {number} columns
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.removeExcessTiles = function(rows, columns) {};

/**
 * Method: onMapResize
 * For singleTile layers, this will set a new tile size according to the
 * dimensions of the map pane.
 * @return {void}
 */
OpenLayers.Layer.Grid.prototype.onMapResize = function() {};

/**
 * APIMethod: getTileBounds
 * Returns The tile bounds for a layer given a pixel location.
 * 
 * Parameters:
 * viewPortPx - {<OpenLayers.Pixel>} The location in the viewport.
 * 
 * Returns:
 * {<OpenLayers.Bounds>} Bounds of the tile at the given pixel location.
 * @param {!OpenLayers.Pixel} viewPortPx
 * @return {!OpenLayers.Bounds}
 */
OpenLayers.Layer.Grid.prototype.getTileBounds = function(viewPortPx) {};

/**
 * @constructor
 * @struct
 * Constructor: OpenLayers.Layer.HTTPRequest
 * 
 * Parameters:
 * name - {String}
 * url - {Array(String) or String}
 * params - {Object}
 * options - {Object} Hashtable of extra options to tag onto the layer
 * @param {string} name
 * @param {string|!Array<string>} url
 * @param {!Object} params
 * @param {!Object} options
 */
OpenLayers.Layer.HTTPRequest = function(name, url, params, options) {};
 /** @type {number} */
OpenLayers.Layer.HTTPRequest.URL_HASH_FACTOR;
 /** @type {!Array<string>} */
OpenLayers.Layer.HTTPRequest.prototype.url;
 /** @type {!Object} */
OpenLayers.Layer.HTTPRequest.prototype.params;
 /** @type {boolean} */
OpenLayers.Layer.HTTPRequest.prototype.reproject;

/**
 * APIMethod: destroy
 * @return {void}
 */
OpenLayers.Layer.HTTPRequest.prototype.destroy = function() {};

/**
 * APIMethod: clone
 * 
 * Parameters:
 * obj - {Object}
 * 
 * Returns:
 * {<OpenLayers.Layer.HTTPRequest>} An exact clone of this
 * <OpenLayers.Layer.HTTPRequest>
 * @param {!Object=} obj
 * @return {!OpenLayers.Layer.HTTPRequest}
 */
OpenLayers.Layer.HTTPRequest.prototype.clone = function(obj) {};

/**
 * APIMethod: setUrl
 * 
 * Parameters:
 * newUrl - {String}
 * @param {string} newUrl
 * @return {void}
 */
OpenLayers.Layer.HTTPRequest.prototype.setUrl = function(newUrl) {};

/**
 * APIMethod: mergeNewParams
 * 
 * Parameters:
 * newParams - {Object}
 * 
 * Returns:
 * redrawn: {Boolean} whether the layer was actually redrawn.
 * @param {!Object} newParams
 * @return {boolean}
 */
OpenLayers.Layer.HTTPRequest.prototype.mergeNewParams = function(newParams) {};

/**
 * APIMethod: redraw
 * Redraws the layer. Returns true if the layer was redrawn, false if not.
 * 
 * Parameters:
 * force - {Boolean} Force redraw by adding random parameter.
 * 
 * Returns:
 * {Boolean} The layer was redrawn.
 * @param {boolean=} force
 * @return {boolean}
 */
OpenLayers.Layer.HTTPRequest.prototype.redraw = function(force) {};

/**
 * Method: selectUrl
 * selectUrl() implements the standard floating-point multiplicative
 * hash function described by Knuth, and hashes the contents of the
 * given param string into a float between 0 and 1. This float is then
 * scaled to the size of the provided urls array, and used to select
 * a URL.
 * 
 * Parameters:
 * paramString - {String}
 * urls - {Array(String)}
 * 
 * Returns:
 * {String} An entry from the urls array, deterministically selected based
 * on the paramString.
 * @param {string} paramString
 * @param {!Array<string>} urls
 * @return {string}
 */
OpenLayers.Layer.HTTPRequest.prototype.selectUrl = function(paramString, urls) {};

/**
 * Method: getFullRequestString
 * Combine url with layer's params and these newParams.
 * 
 * does checking on the serverPath variable, allowing for cases when it
 * is supplied with trailing ? or &, as well as cases where not.
 * 
 * return in formatted string like this:
 * "server?key1=value1&key2=value2&key3=value3"
 * 
 * WARNING: The altUrl parameter is deprecated and will be removed in 3.0.
 * 
 * Parameters:
 * newParams - {Object}
 * altUrl - {String} Use this as the url instead of the layer's url
 * 
 * Returns:
 * {String}
 * @param {!Object} newParams
 * @param {string} altUrl
 * @return {string}
 */
OpenLayers.Layer.HTTPRequest.prototype.getFullRequestString = function(newParams, altUrl) {};

/**
 * @constructor
 * @struct
 * Constructor: OpenLayers.Layer.Image
 * Create a new image layer
 * 
 * Parameters:
 * name - {String} A name for the layer.
 * url - {String} Relative or absolute path to the image
 * extent - {<OpenLayers.Bounds>} The extent represented by the image
 * size - {<OpenLayers.Size>} The size (in pixels) of the image
 * options - {Object} Hashtable of extra options to tag onto the layer
 * @param {string} name
 * @param {string} url
 * @param {!OpenLayers.Bounds} extent
 * @param {!OpenLayers.Size} size
 * @param {?} options
 */
OpenLayers.Layer.Image = function(name, url, extent, size, options) {};
 /** @type {boolean} */
OpenLayers.Layer.Image.prototype.isBaseLayer;
 /** @type {string} */
OpenLayers.Layer.Image.prototype.url;
 /** @type {!OpenLayers.Bounds} */
OpenLayers.Layer.Image.prototype.extent;
 /** @type {!OpenLayers.Size} */
OpenLayers.Layer.Image.prototype.size;
 /** @type {!OpenLayers.Tile.Image} */
OpenLayers.Layer.Image.prototype.tile;
 /** @type {number} */
OpenLayers.Layer.Image.prototype.aspectRatio;
 /** @type {string} */
OpenLayers.Layer.Image.prototype.CLASS_NAME;

/**
 * Method: destroy
 * Destroy this layer
 * @return {void}
 */
OpenLayers.Layer.Image.prototype.destroy = function() {};

/**
 * Method: clone
 * Create a clone of this layer
 * 
 * Parameters:
 * obj - {Object} An optional layer (is this ever used?)
 * 
 * Returns:
 * {<OpenLayers.Layer.Image>} An exact copy of this layer
 * @param {?=} obj
 * @return {!OpenLayers.Layer.Image}
 */
OpenLayers.Layer.Image.prototype.clone = function(obj) {};

/**
 * APIMethod: setMap
 * 
 * Parameters:
 * map - {<OpenLayers.Map>}
 * @param {!OpenLayers.Map} map
 * @return {void}
 */
OpenLayers.Layer.Image.prototype.setMap = function(map) {};

/**
 * Method: moveTo
 * Create the tile for the image or resize it for the new resolution
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * zoomChanged - {Boolean}
 * dragging - {Boolean}
 * @param {!OpenLayers.Bounds} bounds
 * @param {boolean} zoomChanged
 * @param {boolean} dragging
 * @return {void}
 */
OpenLayers.Layer.Image.prototype.moveTo = function(bounds, zoomChanged, dragging) {};

/**
 * Set the tile size based on the map size.
 * @return {void}
 */
OpenLayers.Layer.Image.prototype.setTileSize = function() {};

/**
 * Method: addTileMonitoringHooks
 * This function takes a tile as input and adds the appropriate hooks to
 * the tile so that the layer can keep track of the loading tiles.
 * 
 * Parameters:
 * tile - {<OpenLayers.Tile>}
 * @param {!OpenLayers.Tile} tile
 * @return {void}
 */
OpenLayers.Layer.Image.prototype.addTileMonitoringHooks = function(tile) {};

/**
 * Method: removeTileMonitoringHooks
 * This function takes a tile as input and removes the tile hooks
 * that were added in <addTileMonitoringHooks>.
 * 
 * Parameters:
 * tile - {<OpenLayers.Tile>}
 * @param {!OpenLayers.Tile} tile
 * @return {void}
 */
OpenLayers.Layer.Image.prototype.removeTileMonitoringHooks = function(tile) {};

/**
 * APIMethod: setUrl
 * 
 * Parameters:
 * newUrl - {String}
 * @param {string} newUrl
 * @return {void}
 */
OpenLayers.Layer.Image.prototype.setUrl = function(newUrl) {};

/**
 * APIMethod: getURL
 * The url we return is always the same (the image itself never changes)
 * so we can ignore the bounds parameter (it will always be the same,
 * anyways)
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * @param {!OpenLayers.Bounds} bounds
 * @return {string}
 */
OpenLayers.Layer.Image.prototype.getURL = function(bounds) {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.KaMap = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.KaMapCache = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.MapGuide = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.MapServer = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.Markers = function() {};

/**
 * @constructor
 * @struct
 * @param {string=} name
 * @param {string=} url
 * @param {!OpenLayers.Layer.TileOptions=} options
 */
OpenLayers.Layer.OSM = function(name, url, options) {};
 /** @type {string} */
OpenLayers.Layer.OSM.prototype.name;
 /** @type {!Array<string>} */
OpenLayers.Layer.OSM.prototype.url;
 /** @type {string} */
OpenLayers.Layer.OSM.prototype.attribution;
 /** @type {boolean} */
OpenLayers.Layer.OSM.prototype.sphericalMercator;
 /** @type {boolean} */
OpenLayers.Layer.OSM.prototype.wrapDateLine;
 /** @type {!OpenLayers.Layer.TileOptions} */
OpenLayers.Layer.OSM.prototype.tileOptions;
 /** @type {string} */
OpenLayers.Layer.OSM.CLASS_NAME;

/**
 * Create a clone of this layer
 * @param {!Object=} obj
 * @return {!OpenLayers.Layer.OSM}
 */
OpenLayers.Layer.OSM.prototype.clone = function(obj) {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.PointGrid = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.PointTrack = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.SphericalMercator = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.TMS = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.Text = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.TileCache = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.UTFGrid = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.Vector = function() {};

/**
 * @constructor
 * @struct
 * Constructor: OpenLayers.Layer.WMS
 * Create a new WMS layer object
 * 
 * Examples:
 * 
 * The code below creates a simple WMS layer using the image/jpeg format.
 * (code)
 * var wms = new OpenLayers.Layer.WMS("NASA Global Mosaic",
 * "http://wms.jpl.nasa.gov/wms.cgi",
 * {layers: "modis,global_mosaic"});
 * (end)
 * Note the 3rd argument (params). Properties added to this object will be
 * added to the WMS GetMap requests used for this layer's tiles. The only
 * mandatory parameter is "layers". Other common WMS params include
 * "transparent", "styles" and "format". Note that the "srs" param will
 * always be ignored. Instead, it will be derived from the baseLayer's or
 * map's projection.
 * 
 * The code below creates a transparent WMS layer with additional options.
 * (code)
 * var wms = new OpenLayers.Layer.WMS("NASA Global Mosaic",
 * "http://wms.jpl.nasa.gov/wms.cgi",
 * {
 * layers: "modis,global_mosaic",
 * transparent: true
 * }, {
 * opacity: 0.5,
 * singleTile: true
 * });
 * (end)
 * Note that by default, a WMS layer is configured as baseLayer. Setting
 * the "transparent" param to true will apply some magic (see <noMagic>).
 * The default image format changes from image/jpeg to image/png, and the
 * layer is not configured as baseLayer.
 * 
 * Parameters:
 * name - {String} A name for the layer
 * url - {String} Base url for the WMS
 * (e.g. http://wms.jpl.nasa.gov/wms.cgi)
 * params - {Object} An object with key/value pairs representing the
 * GetMap query string parameters and parameter values.
 * options - {Object} Hashtable of extra options to tag onto the layer.
 * These options include all properties listed above, plus the ones
 * inherited from superclasses.
 * @param {string} name
 * @param {string} url
 * @param {!OpenLayers.Layer.WMSGetMapParams} params
 * @param {!OpenLayers.Layer.WMSOptions} options
 */
OpenLayers.Layer.WMS = function(name, url, params, options) {};
 /** @type {boolean} */
OpenLayers.Layer.WMS.prototype.isBaseLayer;
 /** @type {boolean} */
OpenLayers.Layer.WMS.prototype.encodeBBOX;
 /** @type {boolean} */
OpenLayers.Layer.WMS.prototype.noMagic;
 /** @type {!Object} */
OpenLayers.Layer.WMS.prototype.yx;
 /** @type {string} */
OpenLayers.Layer.WMS.CLASS_NAME;

/**
 * Create a clone of this layer
 * @return {!OpenLayers.Layer.WMS}
 */
OpenLayers.Layer.WMS.prototype.clone = function() {};

/**
 * Returns true if the axis order is reversed for the WMS version and
 * projection of the layer.
 * @return {boolean}
 */
OpenLayers.Layer.WMS.prototype.reverseAxisOrder = function() {};

/**
 * Return a GetMap query string for this layer
 * @param {!OpenLayers.Bounds} bounds
 * @return {string}
 */
OpenLayers.Layer.WMS.prototype.getURL = function(bounds) {};

/**
 * Catch changeParams and uppercase the new params to be merged in
 * before calling changeParams on the super class.
 * Once params have been changed, the tiles will be reloaded with
 * the new parameters.
 * @param {!Object} newParams
 * @return {boolean}
 */
OpenLayers.Layer.WMS.prototype.mergeNewParams = function(newParams) {};

/**
 * Combine the layer's url with its params and these newParams.
 * 
 * Add the SRS parameter from projection -- this is probably
 * more eloquently done via a setProjection() method, but this
 * works for now and always.
 * @param {!Object} newParams
 * @param {string} altUrl
 * @return {string}
 */
OpenLayers.Layer.WMS.prototype.getFullRequestString = function(newParams, altUrl) {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.WMTS = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.WorldWind = function() {};

/**
 * @constructor
 * @struct
 * Constructor: OpenLayers.Layer.XYZ
 * 
 * Parameters:
 * name - {String}
 * url - {String}
 * options - {Object} Hashtable of extra options to tag onto the layer
 * @param {string} name
 * @param {string} url
 * @param {?=} options
 */
OpenLayers.Layer.XYZ = function(name, url, options) {};
 /** @type {boolean} */
OpenLayers.Layer.XYZ.prototype.isBaseLayer;
 /** @type {boolean} */
OpenLayers.Layer.XYZ.prototype.sphericalMercator;
 /** @type {number} */
OpenLayers.Layer.XYZ.prototype.zoomOffset;
 /** @type {!Array<number>} */
OpenLayers.Layer.XYZ.prototype.serverResolutions;

/**
 * APIMethod: clone
 * Create a clone of this layer
 * 
 * Parameters:
 * obj - {Object} Is this ever used?
 * 
 * Returns:
 * {<OpenLayers.Layer.XYZ>} An exact clone of this OpenLayers.Layer.XYZ
 * @param {?=} obj
 * @return {!OpenLayers.Layer.XYZ}
 */
OpenLayers.Layer.XYZ.prototype.clone = function(obj) {};

/**
 * Method: getURL
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * 
 * Returns:
 * {String} A string with the layer's url and parameters and also the
 * passed-in bounds and appropriate tile size specified as
 * parameters
 * @param {!OpenLayers.Bounds} bounds
 * @return {string}
 */
OpenLayers.Layer.XYZ.prototype.getURL = function(bounds) {};

/**
 * Method: getXYZ
 * Calculates x, y and z for the given bounds.
 * 
 * Parameters:
 * bounds - {<OpenLayers.Bounds>}
 * 
 * Returns:
 * {Object} - an object with x, y and z properties.
 * @param {!OpenLayers.Bounds} bounds
 * @return {{x: number, y: number, z: number}}
 */
OpenLayers.Layer.XYZ.prototype.getXYZ = function(bounds) {};

/**
 * @param {!OpenLayers.Map} map
 * @return {void}
 */
OpenLayers.Layer.XYZ.prototype.setMap = function(map) {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.Zoomify = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.Google.v3 = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Layer.Vector.RootContainer = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Marker.Box = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Popup.Anchored = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Popup.Framed = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Popup.FramedCloud = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Protocol.CSW = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Protocol.HTTP = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Protocol.SOS = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Protocol.Script = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Protocol.WFS = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Protocol.CSW.v2_0_2 = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Protocol.SOS.v1_0_0 = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Protocol.WFS.v2_0_0 = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Renderer.Canvas = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Renderer.Elements = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Renderer.SVG = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Renderer.VML = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Request.XMLHttpRequest = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Strategy.BBOX = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Strategy.Cluster = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Strategy.Filter = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Strategy.Fixed = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Strategy.Paging = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Strategy.Refresh = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Strategy.Save = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Symbolizer.Line = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Symbolizer.Point = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Symbolizer.Polygon = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Symbolizer.Raster = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Symbolizer.Text = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Tile.Image = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Tile.UTFGrid = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Tile.Image.IFrame = function() {};
/**
 * @constructor
 * @struct
 */
OpenLayers.Util.vendorPrefix = function() {};
