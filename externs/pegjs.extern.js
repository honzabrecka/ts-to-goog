/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/pegjs/index.d.ts:
/** @const */
var PEG = {};

/**
 * @param {string} input
 * @return {?}
 */
PEG.parse = function(input) {};
/**
 * @record
 * @struct
 */
PEG.Location = function() {};
 /** @type {number} */
PEG.Location.prototype.line;
 /** @type {number} */
PEG.Location.prototype.column;
 /** @type {number} */
PEG.Location.prototype.offset;
/**
 * @record
 * @struct
 */
PEG.LocationRange = function() {};
 /** @type {!PEG.Location} */
PEG.LocationRange.prototype.start;
 /** @type {!PEG.Location} */
PEG.LocationRange.prototype.end;
/**
 * @constructor
 * @struct
 */
PEG.SyntaxError = function() {};
 /** @type {number} */
PEG.SyntaxError.prototype.line;
 /** @type {number} */
PEG.SyntaxError.prototype.column;
 /** @type {number} */
PEG.SyntaxError.prototype.offset;
 /** @type {!PEG.LocationRange} */
PEG.SyntaxError.prototype.location;
 /** @type {!Array<?>} */
PEG.SyntaxError.prototype.expected;
 /** @type {?} */
PEG.SyntaxError.prototype.found;
 /** @type {string} */
PEG.SyntaxError.prototype.name;
 /** @type {string} */
PEG.SyntaxError.prototype.message;

/** @typedef {!PEG.Location} */
var Location;

/** @typedef {!PEG.LocationRange} */
var LocationRange;
/**
 * @record
 * @struct
 */
function ExpectedItem() {}
 /** @type {string} */
ExpectedItem.prototype.type;
 /** @type {string} */
ExpectedItem.prototype.value;
 /** @type {string} */
ExpectedItem.prototype.description;
/**
 * @record
 * @struct
 */
function PegjsError() {}
 /** @type {string} */
PegjsError.prototype.name;
 /** @type {string} */
PegjsError.prototype.message;
 /** @type {!PEG.LocationRange} */
PegjsError.prototype.location;
 /** @type {?} */
PegjsError.prototype.found;
 /** @type {!Array<?>} */
PegjsError.prototype.expected;
 /** @type {?} */
PegjsError.prototype.stack;

/** @typedef {?} */
var GrammarError;
 /** @type {?} */
var GrammarError;
/**
 * @record
 * @struct
 */
function ParserOptions() {}
 /** @type {string} */
ParserOptions.prototype.startRule;
 /** @type {?} */
ParserOptions.prototype.tracer;
/**
 * @record
 * @struct
 */
function Parser() {}
 /** @type {?} */
Parser.prototype.SyntaxError;

/**
 * @param {string} input
 * @param {?=} options
 * @return {?}
 */
Parser.prototype.parse = function(input, options) {};
/**
 * @record
 * @struct
 */
function BuildOptionsBase() {}
 /** @type {!Array<string>} */
BuildOptionsBase.prototype.allowedStartRules;
 /** @type {boolean} */
BuildOptionsBase.prototype.cache;
 /** @type {string} */
BuildOptionsBase.prototype.optimize;
 /** @type {!Array<?>} */
BuildOptionsBase.prototype.plugins;
 /** @type {boolean} */
BuildOptionsBase.prototype.trace;
/**
 * @extends {BuildOptionsBase}
 * @record
 * @struct
 */
function ParserBuildOptions() {}
 /** @type {string} */
ParserBuildOptions.prototype.output;
/**
 * @extends {BuildOptionsBase}
 * @record
 * @struct
 */
function OutputFormatAmdCommonjs() {}
 /** @type {string} */
OutputFormatAmdCommonjs.prototype.output;
 /** @type {string} */
OutputFormatAmdCommonjs.prototype.format;
 /** @type {?} */
OutputFormatAmdCommonjs.prototype.dependencies;
/**
 * @extends {BuildOptionsBase}
 * @record
 * @struct
 */
function OutputFormatUmd() {}
 /** @type {string} */
OutputFormatUmd.prototype.output;
 /** @type {string} */
OutputFormatUmd.prototype.format;
 /** @type {?} */
OutputFormatUmd.prototype.dependencies;
 /** @type {?} */
OutputFormatUmd.prototype.exportVar;
/**
 * @extends {BuildOptionsBase}
 * @record
 * @struct
 */
function OutputFormatGlobals() {}
 /** @type {string} */
OutputFormatGlobals.prototype.output;
 /** @type {string} */
OutputFormatGlobals.prototype.format;
 /** @type {?} */
OutputFormatGlobals.prototype.exportVar;
/**
 * @extends {BuildOptionsBase}
 * @record
 * @struct
 */
function OutputFormatBare() {}
 /** @type {string} */
OutputFormatBare.prototype.output;
 /** @type {string} */
OutputFormatBare.prototype.format;

/**
 * Returns a generated parser object. It will throw an exception if the grammar is invalid. The exception will contain `message` property with more details about the error.
 * Returns the generated source code as a `string`. It will throw an exception if the grammar is invalid. The exception will contain `message` property with more details about the error.
 * Returns the generated source code as a `string`. It will throw an exception if the grammar is invalid. The exception will contain `message` property with more details about the error.
 * Returns the generated source code as a `string`. It will throw an exception if the grammar is invalid. The exception will contain `message` property with more details about the error.
 * Returns the generated source code as a `string`. It will throw an exception if the grammar is invalid. The exception will contain `message` property with more details about the error.
 * @param {string} grammar
 * @param {?=} options
 * @return {?|string}
 */
function generate(grammar, options) {}
/** @const */
var parser = {};

/** @typedef {?} */
parser.SyntaxError;
 /** @type {?} */
parser.SyntaxError;

/* TODO: NamespaceExportDeclaration in  */
