/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/code/index.d.ts:

/**
 * Generates an assertion object.
 * @template T
 * @param {(?|!Array<?>)} value
 * @param {string=} prefix
 * @return {?}
 */
function expect(value, prefix) {}

/**
 * Makes the test fail with the given message.
 * @param {string} message
 * @return {void}
 */
function fail(message) {}

/**
 * Returns the total number of assertions created using the expect() method.
 * @return {number}
 */
function count() {}

/**
 * Returns an array of the locations where incomplete assertions were declared or null if no incomplete assertions found.
 * @return {!Array<string>}
 */
function incomplete() {}

/**
 * Returns the filename, line number, and column number of where the error was created.
 * @param {!Error=} error
 * @return {?}
 */
function thrownAt(error) {}
 /** @type {?} */
var settings;

/** @typedef {?} */
var AssertionChain;

/** @typedef {?} */
var Assertion;

/** @typedef {?} */
var Expectation;
/**
 * @record
 * @struct
 */
function Grammar() {}
 /** @type {?} */
Grammar.prototype.a;
 /** @type {?} */
Grammar.prototype.an;
 /** @type {?} */
Grammar.prototype.and;
 /** @type {?} */
Grammar.prototype.at;
 /** @type {?} */
Grammar.prototype.be;
 /** @type {?} */
Grammar.prototype.have;
 /** @type {?} */
Grammar.prototype.in;
 /** @type {?} */
Grammar.prototype.to;
/**
 * @record
 * @struct
 */
function Flags() {}
 /** @type {?} */
Flags.prototype.not;
 /** @type {?} */
Flags.prototype.once;
 /** @type {?} */
Flags.prototype.only;
 /** @type {?} */
Flags.prototype.part;
 /** @type {?} */
Flags.prototype.shallow;
/**
 * @record
 * @struct
 */
function Types() {}

/**
 * Asserts that the reference value is an arguments object.
 * @return {?}
 */
Types.prototype.arguments = function() {};

/**
 * Asserts that the reference value is an Array.
 * @return {?}
 */
Types.prototype.array = function() {};

/**
 * Asserts that the reference value is a boolean.
 * @return {?}
 */
Types.prototype.boolean = function() {};

/**
 * Asserts that the reference value is a Buffer.
 * @return {?}
 */
Types.prototype.buffer = function() {};

/**
 * Asserts that the reference value is a Date.
 * @return {?}
 */
Types.prototype.date = function() {};

/**
 * Asserts that the reference value is an error.
 * @param {?=} type
 * @param {(string|!RegExp)=} message
 * @return {?}
 */
Types.prototype.error = function(type, message) {};

/**
 * Asserts that the reference value is a function.
 * @return {?}
 */
Types.prototype.function = function() {};

/**
 * Asserts that the reference value is a number.
 * @return {?}
 */
Types.prototype.number = function() {};

/**
 * Asserts that the reference value is a RegExp.
 * @return {?}
 */
Types.prototype.regexp = function() {};

/**
 * Asserts that the reference value is a string.
 * @return {?}
 */
Types.prototype.string = function() {};

/**
 * Asserts that the reference value is an object (excluding array, buffer, or other native objects).
 * @return {?}
 */
Types.prototype.object = function() {};
/**
 * @record
 * @struct
 */
function Values() {}

/**
 * Asserts that the reference value is true.
 * @return {?}
 */
Values.prototype.true = function() {};

/**
 * Asserts that the reference value is false.
 * @return {?}
 */
Values.prototype.false = function() {};

/**
 * Asserts that the reference value is null.
 * @return {?}
 */
Values.prototype.null = function() {};

/**
 * Asserts that the reference value is undefined.
 * @return {?}
 */
Values.prototype.undefined = function() {};

/**
 * Asserts that the reference value (a string, array, or object) includes the provided values.
 * @param {(string|?|!Array<string>|!Array<?>)} values
 * @return {?}
 */
Values.prototype.include = function(values) {};

/**
 * Asserts that the reference value (a string, array, or object) includes the provided values.
 * @param {(string|?|!Array<string>|!Array<?>)} values
 * @return {?}
 */
Values.prototype.includes = function(values) {};

/**
 * Asserts that the reference value (a string, array, or object) includes the provided values.
 * @param {(string|?|!Array<string>|!Array<?>)} values
 * @return {?}
 */
Values.prototype.contain = function(values) {};

/**
 * Asserts that the reference value (a string, array, or object) includes the provided values.
 * @param {(string|?|!Array<string>|!Array<?>)} values
 * @return {?}
 */
Values.prototype.contains = function(values) {};

/**
 * Asserts that the reference value (a string) starts with the provided value.
 * @param {string} value
 * @return {?}
 */
Values.prototype.startWith = function(value) {};

/**
 * Asserts that the reference value (a string) starts with the provided value.
 * @param {string} value
 * @return {?}
 */
Values.prototype.startsWith = function(value) {};

/**
 * Asserts that the reference value (a string) ends with the provided value.
 * @param {string} value
 * @return {?}
 */
Values.prototype.endWith = function(value) {};

/**
 * Asserts that the reference value (a string) ends with the provided value.
 * @param {string} value
 * @return {?}
 */
Values.prototype.endsWith = function(value) {};

/**
 * Asserts that the reference value exists (not null or undefined).
 * @return {?}
 */
Values.prototype.exist = function() {};

/**
 * Asserts that the reference value exists (not null or undefined).
 * @return {?}
 */
Values.prototype.exists = function() {};

/**
 * Asserts that the reference value has a length property equal to zero or an object with no keys.
 * @return {?}
 */
Values.prototype.empty = function() {};

/**
 * Asserts that the reference value has a length property matching the provided size or an object with the specified number of keys.
 * @param {number} size
 * @return {?}
 */
Values.prototype.length = function(size) {};

/**
 * Asserts that the reference value equals the provided value.
 * @param {?} value
 * @param {?=} options
 * @return {?}
 */
Values.prototype.equal = function(value, options) {};

/**
 * Asserts that the reference value equals the provided value.
 * @param {?} value
 * @param {?=} options
 * @return {?}
 */
Values.prototype.equals = function(value, options) {};

/**
 * Asserts that the reference value is greater than (>) the provided value.
 * @param {?} value
 * @return {?}
 */
Values.prototype.above = function(value) {};

/**
 * Asserts that the reference value is greater than (>) the provided value.
 * @param {?} value
 * @return {?}
 */
Values.prototype.greaterThan = function(value) {};

/**
 * Asserts that the reference value is at least (>=) the provided value.
 * @param {?} value
 * @return {?}
 */
Values.prototype.least = function(value) {};

/**
 * Asserts that the reference value is at least (>=) the provided value.
 * @param {?} value
 * @return {?}
 */
Values.prototype.min = function(value) {};

/**
 * Asserts that the reference value is less than (<) the provided value.
 * @param {?} value
 * @return {?}
 */
Values.prototype.below = function(value) {};

/**
 * Asserts that the reference value is less than (<) the provided value.
 * @param {?} value
 * @return {?}
 */
Values.prototype.lessThan = function(value) {};

/**
 * Asserts that the reference value is at most (<=) the provided value.
 * @param {?} value
 * @return {?}
 */
Values.prototype.most = function(value) {};

/**
 * Asserts that the reference value is at most (<=) the provided value.
 * @param {?} value
 * @return {?}
 */
Values.prototype.max = function(value) {};

/**
 * Asserts that the reference value is within (from <= value <= to) the provided values.
 * @param {?} from
 * @param {?} to
 * @return {?}
 */
Values.prototype.within = function(from, to) {};

/**
 * Asserts that the reference value is within (from <= value <= to) the provided values.
 * @param {?} from
 * @param {?} to
 * @return {?}
 */
Values.prototype.range = function(from, to) {};

/**
 * Asserts that the reference value is between but not equal (from < value < to) the provided values.
 * @param {?} from
 * @param {?} to
 * @return {?}
 */
Values.prototype.between = function(from, to) {};

/**
 * Asserts that the reference value is about the provided value within a delta margin of difference.
 * @param {number} value
 * @param {number} delta
 * @return {?}
 */
Values.prototype.about = function(value, delta) {};

/**
 * Asserts that the reference value has the provided instanceof value.
 * @param {?} type
 * @return {?}
 */
Values.prototype.instanceof = function(type) {};

/**
 * Asserts that the reference value has the provided instanceof value.
 * @param {?} type
 * @return {?}
 */
Values.prototype.instanceOf = function(type) {};

/**
 * Asserts that the reference value's toString() representation matches the provided regular expression.
 * @param {!RegExp} regex
 * @return {?}
 */
Values.prototype.match = function(regex) {};

/**
 * Asserts that the reference value's toString() representation matches the provided regular expression.
 * @param {!RegExp} regex
 * @return {?}
 */
Values.prototype.matches = function(regex) {};

/**
 * Asserts that the reference value satisfies the provided validator function.
 * @param {?} validator
 * @return {?}
 */
Values.prototype.satisfy = function(validator) {};

/**
 * Asserts that the reference value satisfies the provided validator function.
 * @param {?} validator
 * @return {?}
 */
Values.prototype.satisfies = function(validator) {};

/**
 * Asserts that the function reference value throws an exception when called.
 * @param {?=} type
 * @param {(string|!RegExp)=} message
 * @return {?}
 */
Values.prototype.throw = function(type, message) {};

/**
 * Asserts that the function reference value throws an exception when called.
 * @param {?=} type
 * @param {(string|!RegExp)=} message
 * @return {?}
 */
Values.prototype.throws = function(type, message) {};
/**
 * @record
 * @struct
 */
function Settings() {}
 /** @type {boolean} */
Settings.prototype.truncateMessages;
 /** @type {boolean} */
Settings.prototype.comparePrototypes;
/**
 * @record
 * @struct
 */
function CodeError() {}
 /** @type {string} */
CodeError.prototype.filename;
 /** @type {string} */
CodeError.prototype.line;
 /** @type {string} */
CodeError.prototype.column;
