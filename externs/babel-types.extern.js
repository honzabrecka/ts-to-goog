/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/babel-types/index.d.ts:
/**
 * @record
 * @struct
 */
function Comment() {}
 /** @type {string} */
Comment.prototype.value;
 /** @type {number} */
Comment.prototype.start;
 /** @type {number} */
Comment.prototype.end;
 /** @type {?} */
Comment.prototype.loc;
/**
 * @extends {Comment}
 * @record
 * @struct
 */
function CommentBlock() {}
 /** @type {string} */
CommentBlock.prototype.type;
/**
 * @extends {Comment}
 * @record
 * @struct
 */
function CommentLine() {}
 /** @type {string} */
CommentLine.prototype.type;
/**
 * @record
 * @struct
 */
function SourceLocation() {}
 /** @type {?} */
SourceLocation.prototype.start;
 /** @type {?} */
SourceLocation.prototype.end;
/**
 * @record
 * @struct
 */
function Node() {}
 /** @type {string} */
Node.prototype.type;
 /** @type {!Array<?>} */
Node.prototype.leadingComments;
 /** @type {!Array<?>} */
Node.prototype.innerComments;
 /** @type {!Array<?>} */
Node.prototype.trailingComments;
 /** @type {number} */
Node.prototype.start;
 /** @type {number} */
Node.prototype.end;
 /** @type {?} */
Node.prototype.loc;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ArrayExpression() {}
 /** @type {string} */
ArrayExpression.prototype.type;
 /** @type {!Array<?>} */
ArrayExpression.prototype.elements;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function AssignmentExpression() {}
 /** @type {string} */
AssignmentExpression.prototype.type;
 /** @type {string} */
AssignmentExpression.prototype.operator;
 /** @type {?} */
AssignmentExpression.prototype.left;
 /** @type {?} */
AssignmentExpression.prototype.right;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function BinaryExpression() {}
 /** @type {string} */
BinaryExpression.prototype.type;
 /** @type {string} */
BinaryExpression.prototype.operator;
 /** @type {?} */
BinaryExpression.prototype.left;
 /** @type {?} */
BinaryExpression.prototype.right;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function Directive() {}
 /** @type {string} */
Directive.prototype.type;
 /** @type {?} */
Directive.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DirectiveLiteral() {}
 /** @type {string} */
DirectiveLiteral.prototype.type;
 /** @type {string} */
DirectiveLiteral.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function BlockStatement() {}
 /** @type {string} */
BlockStatement.prototype.type;
 /** @type {!Array<?>} */
BlockStatement.prototype.directives;
 /** @type {!Array<?>} */
BlockStatement.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function BreakStatement() {}
 /** @type {string} */
BreakStatement.prototype.type;
 /** @type {?} */
BreakStatement.prototype.label;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function CallExpression() {}
 /** @type {string} */
CallExpression.prototype.type;
 /** @type {?} */
CallExpression.prototype.callee;
 /** @type {!Array<?>} */
CallExpression.prototype.arguments;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function CatchClause() {}
 /** @type {string} */
CatchClause.prototype.type;
 /** @type {?} */
CatchClause.prototype.param;
 /** @type {?} */
CatchClause.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ConditionalExpression() {}
 /** @type {string} */
ConditionalExpression.prototype.type;
 /** @type {?} */
ConditionalExpression.prototype.test;
 /** @type {?} */
ConditionalExpression.prototype.consequent;
 /** @type {?} */
ConditionalExpression.prototype.alternate;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ContinueStatement() {}
 /** @type {string} */
ContinueStatement.prototype.type;
 /** @type {?} */
ContinueStatement.prototype.label;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DebuggerStatement() {}
 /** @type {string} */
DebuggerStatement.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DoWhileStatement() {}
 /** @type {string} */
DoWhileStatement.prototype.type;
 /** @type {?} */
DoWhileStatement.prototype.test;
 /** @type {?} */
DoWhileStatement.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function EmptyStatement() {}
 /** @type {string} */
EmptyStatement.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ExpressionStatement() {}
 /** @type {string} */
ExpressionStatement.prototype.type;
 /** @type {?} */
ExpressionStatement.prototype.expression;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function File() {}
 /** @type {string} */
File.prototype.type;
 /** @type {?} */
File.prototype.program;
 /** @type {!Array<?>} */
File.prototype.comments;
 /** @type {!Array<?>} */
File.prototype.tokens;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ForInStatement() {}
 /** @type {string} */
ForInStatement.prototype.type;
 /** @type {?} */
ForInStatement.prototype.left;
 /** @type {?} */
ForInStatement.prototype.right;
 /** @type {?} */
ForInStatement.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ForStatement() {}
 /** @type {string} */
ForStatement.prototype.type;
 /** @type {?} */
ForStatement.prototype.init;
 /** @type {?} */
ForStatement.prototype.test;
 /** @type {?} */
ForStatement.prototype.update;
 /** @type {?} */
ForStatement.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function FunctionDeclaration() {}
 /** @type {string} */
FunctionDeclaration.prototype.type;
 /** @type {?} */
FunctionDeclaration.prototype.id;
 /** @type {!Array<?>} */
FunctionDeclaration.prototype.params;
 /** @type {?} */
FunctionDeclaration.prototype.body;
 /** @type {boolean} */
FunctionDeclaration.prototype.generator;
 /** @type {boolean} */
FunctionDeclaration.prototype.async;
 /** @type {?} */
FunctionDeclaration.prototype.returnType;
 /** @type {?} */
FunctionDeclaration.prototype.typeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function FunctionExpression() {}
 /** @type {string} */
FunctionExpression.prototype.type;
 /** @type {?} */
FunctionExpression.prototype.id;
 /** @type {!Array<?>} */
FunctionExpression.prototype.params;
 /** @type {?} */
FunctionExpression.prototype.body;
 /** @type {boolean} */
FunctionExpression.prototype.generator;
 /** @type {boolean} */
FunctionExpression.prototype.async;
 /** @type {?} */
FunctionExpression.prototype.returnType;
 /** @type {?} */
FunctionExpression.prototype.typeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function Identifier() {}
 /** @type {string} */
Identifier.prototype.type;
 /** @type {string} */
Identifier.prototype.name;
 /** @type {?} */
Identifier.prototype.typeAnnotation;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function IfStatement() {}
 /** @type {string} */
IfStatement.prototype.type;
 /** @type {?} */
IfStatement.prototype.test;
 /** @type {?} */
IfStatement.prototype.consequent;
 /** @type {?} */
IfStatement.prototype.alternate;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function LabeledStatement() {}
 /** @type {string} */
LabeledStatement.prototype.type;
 /** @type {?} */
LabeledStatement.prototype.label;
 /** @type {?} */
LabeledStatement.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function StringLiteral() {}
 /** @type {string} */
StringLiteral.prototype.type;
 /** @type {string} */
StringLiteral.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function NumericLiteral() {}
 /** @type {string} */
NumericLiteral.prototype.type;
 /** @type {number} */
NumericLiteral.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function NullLiteral() {}
 /** @type {string} */
NullLiteral.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function BooleanLiteral() {}
 /** @type {string} */
BooleanLiteral.prototype.type;
 /** @type {boolean} */
BooleanLiteral.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function RegExpLiteral() {}
 /** @type {string} */
RegExpLiteral.prototype.type;
 /** @type {string} */
RegExpLiteral.prototype.pattern;
 /** @type {string} */
RegExpLiteral.prototype.flags;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function LogicalExpression() {}
 /** @type {string} */
LogicalExpression.prototype.type;
 /** @type {string} */
LogicalExpression.prototype.operator;
 /** @type {?} */
LogicalExpression.prototype.left;
 /** @type {?} */
LogicalExpression.prototype.right;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function MemberExpression() {}
 /** @type {string} */
MemberExpression.prototype.type;
 /** @type {?} */
MemberExpression.prototype.object;
 /** @type {?} */
MemberExpression.prototype.property;
 /** @type {boolean} */
MemberExpression.prototype.computed;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function NewExpression() {}
 /** @type {string} */
NewExpression.prototype.type;
 /** @type {?} */
NewExpression.prototype.callee;
 /** @type {!Array<?>} */
NewExpression.prototype.arguments;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function Program() {}
 /** @type {string} */
Program.prototype.type;
 /** @type {string} */
Program.prototype.sourceType;
 /** @type {!Array<?>} */
Program.prototype.directives;
 /** @type {!Array<?>} */
Program.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ObjectExpression() {}
 /** @type {string} */
ObjectExpression.prototype.type;
 /** @type {!Array<?>} */
ObjectExpression.prototype.properties;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ObjectMethod() {}
 /** @type {string} */
ObjectMethod.prototype.type;
 /** @type {?} */
ObjectMethod.prototype.key;
 /** @type {string} */
ObjectMethod.prototype.kind;
 /** @type {boolean} */
ObjectMethod.prototype.shorthand;
 /** @type {boolean} */
ObjectMethod.prototype.computed;
 /** @type {?} */
ObjectMethod.prototype.value;
 /** @type {!Array<?>} */
ObjectMethod.prototype.decorators;
 /** @type {?} */
ObjectMethod.prototype.id;
 /** @type {!Array<?>} */
ObjectMethod.prototype.params;
 /** @type {?} */
ObjectMethod.prototype.body;
 /** @type {boolean} */
ObjectMethod.prototype.generator;
 /** @type {boolean} */
ObjectMethod.prototype.async;
 /** @type {?} */
ObjectMethod.prototype.returnType;
 /** @type {?} */
ObjectMethod.prototype.typeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ObjectProperty() {}
 /** @type {string} */
ObjectProperty.prototype.type;
 /** @type {?} */
ObjectProperty.prototype.key;
 /** @type {boolean} */
ObjectProperty.prototype.computed;
 /** @type {?} */
ObjectProperty.prototype.value;
 /** @type {!Array<?>} */
ObjectProperty.prototype.decorators;
 /** @type {boolean} */
ObjectProperty.prototype.shorthand;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function RestElement() {}
 /** @type {string} */
RestElement.prototype.type;
 /** @type {?} */
RestElement.prototype.argument;
 /** @type {?} */
RestElement.prototype.typeAnnotation;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ReturnStatement() {}
 /** @type {string} */
ReturnStatement.prototype.type;
 /** @type {?} */
ReturnStatement.prototype.argument;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function SequenceExpression() {}
 /** @type {string} */
SequenceExpression.prototype.type;
 /** @type {!Array<?>} */
SequenceExpression.prototype.expressions;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function SwitchCase() {}
 /** @type {string} */
SwitchCase.prototype.type;
 /** @type {?} */
SwitchCase.prototype.test;
 /** @type {!Array<?>} */
SwitchCase.prototype.consequent;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function SwitchStatement() {}
 /** @type {string} */
SwitchStatement.prototype.type;
 /** @type {?} */
SwitchStatement.prototype.discriminant;
 /** @type {!Array<?>} */
SwitchStatement.prototype.cases;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ThisExpression() {}
 /** @type {string} */
ThisExpression.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ThrowStatement() {}
 /** @type {string} */
ThrowStatement.prototype.type;
 /** @type {?} */
ThrowStatement.prototype.argument;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TryStatement() {}
 /** @type {string} */
TryStatement.prototype.type;
 /** @type {?} */
TryStatement.prototype.block;
 /** @type {?} */
TryStatement.prototype.handler;
 /** @type {?} */
TryStatement.prototype.finalizer;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function UnaryExpression() {}
 /** @type {string} */
UnaryExpression.prototype.type;
 /** @type {string} */
UnaryExpression.prototype.operator;
 /** @type {boolean} */
UnaryExpression.prototype.prefix;
 /** @type {?} */
UnaryExpression.prototype.argument;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function UpdateExpression() {}
 /** @type {string} */
UpdateExpression.prototype.type;
 /** @type {string} */
UpdateExpression.prototype.operator;
 /** @type {boolean} */
UpdateExpression.prototype.prefix;
 /** @type {?} */
UpdateExpression.prototype.argument;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function VariableDeclaration() {}
 /** @type {string} */
VariableDeclaration.prototype.type;
 /** @type {!Array<?>} */
VariableDeclaration.prototype.declarations;
 /** @type {string} */
VariableDeclaration.prototype.kind;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function VariableDeclarator() {}
 /** @type {string} */
VariableDeclarator.prototype.type;
 /** @type {?} */
VariableDeclarator.prototype.id;
 /** @type {?} */
VariableDeclarator.prototype.init;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function WhileStatement() {}
 /** @type {string} */
WhileStatement.prototype.type;
 /** @type {?} */
WhileStatement.prototype.test;
 /** @type {?} */
WhileStatement.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function WithStatement() {}
 /** @type {string} */
WithStatement.prototype.type;
 /** @type {?} */
WithStatement.prototype.object;
 /** @type {?} */
WithStatement.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function AssignmentPattern() {}
 /** @type {string} */
AssignmentPattern.prototype.type;
 /** @type {?} */
AssignmentPattern.prototype.left;
 /** @type {?} */
AssignmentPattern.prototype.right;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ArrayPattern() {}
 /** @type {string} */
ArrayPattern.prototype.type;
 /** @type {!Array<?>} */
ArrayPattern.prototype.elements;
 /** @type {?} */
ArrayPattern.prototype.typeAnnotation;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ArrowFunctionExpression() {}
 /** @type {string} */
ArrowFunctionExpression.prototype.type;
 /** @type {?} */
ArrowFunctionExpression.prototype.id;
 /** @type {!Array<?>} */
ArrowFunctionExpression.prototype.params;
 /** @type {?} */
ArrowFunctionExpression.prototype.body;
 /** @type {boolean} */
ArrowFunctionExpression.prototype.generator;
 /** @type {boolean} */
ArrowFunctionExpression.prototype.async;
 /** @type {boolean} */
ArrowFunctionExpression.prototype.expression;
 /** @type {?} */
ArrowFunctionExpression.prototype.returnType;
 /** @type {?} */
ArrowFunctionExpression.prototype.typeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ClassBody() {}
 /** @type {string} */
ClassBody.prototype.type;
 /** @type {!Array<?>} */
ClassBody.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ClassDeclaration() {}
 /** @type {string} */
ClassDeclaration.prototype.type;
 /** @type {?} */
ClassDeclaration.prototype.id;
 /** @type {?} */
ClassDeclaration.prototype.superClass;
 /** @type {?} */
ClassDeclaration.prototype.body;
 /** @type {!Array<?>} */
ClassDeclaration.prototype.decorators;
 /** @type {!Array<?>} */
ClassDeclaration.prototype.implements;
 /** @type {!Array<?>} */
ClassDeclaration.prototype.mixins;
 /** @type {?} */
ClassDeclaration.prototype.typeParameters;
 /** @type {?} */
ClassDeclaration.prototype.superTypeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ClassExpression() {}
 /** @type {string} */
ClassExpression.prototype.type;
 /** @type {?} */
ClassExpression.prototype.id;
 /** @type {?} */
ClassExpression.prototype.superClass;
 /** @type {?} */
ClassExpression.prototype.body;
 /** @type {!Array<?>} */
ClassExpression.prototype.decorators;
 /** @type {!Array<?>} */
ClassExpression.prototype.implements;
 /** @type {!Array<?>} */
ClassExpression.prototype.mixins;
 /** @type {?} */
ClassExpression.prototype.typeParameters;
 /** @type {?} */
ClassExpression.prototype.superTypeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ExportAllDeclaration() {}
 /** @type {string} */
ExportAllDeclaration.prototype.type;
 /** @type {?} */
ExportAllDeclaration.prototype.source;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ExportDefaultDeclaration() {}
 /** @type {string} */
ExportDefaultDeclaration.prototype.type;
 /** @type {?} */
ExportDefaultDeclaration.prototype.declaration;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ExportNamedDeclaration() {}
 /** @type {string} */
ExportNamedDeclaration.prototype.type;
 /** @type {?} */
ExportNamedDeclaration.prototype.declaration;
 /** @type {!Array<?>} */
ExportNamedDeclaration.prototype.specifiers;
 /** @type {?} */
ExportNamedDeclaration.prototype.source;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ExportSpecifier() {}
 /** @type {string} */
ExportSpecifier.prototype.type;
 /** @type {?} */
ExportSpecifier.prototype.local;
 /** @type {?} */
ExportSpecifier.prototype.imported;
 /** @type {?} */
ExportSpecifier.prototype.exported;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ForOfStatement() {}
 /** @type {string} */
ForOfStatement.prototype.type;
 /** @type {?} */
ForOfStatement.prototype.left;
 /** @type {?} */
ForOfStatement.prototype.right;
 /** @type {?} */
ForOfStatement.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ImportDeclaration() {}
 /** @type {string} */
ImportDeclaration.prototype.type;
 /** @type {!Array<?>} */
ImportDeclaration.prototype.specifiers;
 /** @type {?} */
ImportDeclaration.prototype.source;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ImportDefaultSpecifier() {}
 /** @type {string} */
ImportDefaultSpecifier.prototype.type;
 /** @type {?} */
ImportDefaultSpecifier.prototype.local;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ImportNamespaceSpecifier() {}
 /** @type {string} */
ImportNamespaceSpecifier.prototype.type;
 /** @type {?} */
ImportNamespaceSpecifier.prototype.local;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ImportSpecifier() {}
 /** @type {string} */
ImportSpecifier.prototype.type;
 /** @type {?} */
ImportSpecifier.prototype.local;
 /** @type {?} */
ImportSpecifier.prototype.imported;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function MetaProperty() {}
 /** @type {string} */
MetaProperty.prototype.type;
 /** @type {?} */
MetaProperty.prototype.meta;
 /** @type {?} */
MetaProperty.prototype.property;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ClassMethod() {}
 /** @type {string} */
ClassMethod.prototype.type;
 /** @type {?} */
ClassMethod.prototype.key;
 /** @type {?} */
ClassMethod.prototype.value;
 /** @type {string} */
ClassMethod.prototype.kind;
 /** @type {boolean} */
ClassMethod.prototype.computed;
 /** @type {boolean} */
ClassMethod.prototype.static;
 /** @type {!Array<?>} */
ClassMethod.prototype.decorators;
 /** @type {?} */
ClassMethod.prototype.id;
 /** @type {!Array<?>} */
ClassMethod.prototype.params;
 /** @type {?} */
ClassMethod.prototype.body;
 /** @type {boolean} */
ClassMethod.prototype.generator;
 /** @type {boolean} */
ClassMethod.prototype.async;
 /** @type {boolean} */
ClassMethod.prototype.expression;
 /** @type {?} */
ClassMethod.prototype.returnType;
 /** @type {?} */
ClassMethod.prototype.typeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function AssignmentProperty() {}
 /** @type {string} */
AssignmentProperty.prototype.type;
 /** @type {?} */
AssignmentProperty.prototype.key;
 /** @type {boolean} */
AssignmentProperty.prototype.computed;
 /** @type {?} */
AssignmentProperty.prototype.value;
 /** @type {!Array<?>} */
AssignmentProperty.prototype.decorators;
 /** @type {boolean} */
AssignmentProperty.prototype.shorthand;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ObjectPattern() {}
 /** @type {string} */
ObjectPattern.prototype.type;
 /** @type {!Array<?>} */
ObjectPattern.prototype.properties;
 /** @type {?} */
ObjectPattern.prototype.typeAnnotation;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function SpreadElement() {}
 /** @type {string} */
SpreadElement.prototype.type;
 /** @type {?} */
SpreadElement.prototype.argument;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function Super() {}
 /** @type {string} */
Super.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TaggedTemplateExpression() {}
 /** @type {string} */
TaggedTemplateExpression.prototype.type;
 /** @type {?} */
TaggedTemplateExpression.prototype.tag;
 /** @type {?} */
TaggedTemplateExpression.prototype.quasi;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TemplateElement() {}
 /** @type {string} */
TemplateElement.prototype.type;
 /** @type {boolean} */
TemplateElement.prototype.tail;
 /** @type {?} */
TemplateElement.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TemplateLiteral() {}
 /** @type {string} */
TemplateLiteral.prototype.type;
 /** @type {!Array<?>} */
TemplateLiteral.prototype.quasis;
 /** @type {!Array<?>} */
TemplateLiteral.prototype.expressions;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function YieldExpression() {}
 /** @type {string} */
YieldExpression.prototype.type;
 /** @type {?} */
YieldExpression.prototype.argument;
 /** @type {boolean} */
YieldExpression.prototype.delegate;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function AnyTypeAnnotation() {}
 /** @type {string} */
AnyTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ArrayTypeAnnotation() {}
 /** @type {string} */
ArrayTypeAnnotation.prototype.type;
 /** @type {?} */
ArrayTypeAnnotation.prototype.elementType;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function BooleanTypeAnnotation() {}
 /** @type {string} */
BooleanTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function BooleanLiteralTypeAnnotation() {}
 /** @type {string} */
BooleanLiteralTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function NullLiteralTypeAnnotation() {}
 /** @type {string} */
NullLiteralTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ClassImplements() {}
 /** @type {string} */
ClassImplements.prototype.type;
 /** @type {?} */
ClassImplements.prototype.id;
 /** @type {?} */
ClassImplements.prototype.typeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ClassProperty() {}
 /** @type {string} */
ClassProperty.prototype.type;
 /** @type {?} */
ClassProperty.prototype.key;
 /** @type {?} */
ClassProperty.prototype.value;
 /** @type {!Array<?>} */
ClassProperty.prototype.decorators;
 /** @type {?} */
ClassProperty.prototype.typeAnnotation;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DeclareClass() {}
 /** @type {string} */
DeclareClass.prototype.type;
 /** @type {?} */
DeclareClass.prototype.id;
 /** @type {?} */
DeclareClass.prototype.typeParameters;
 /** @type {!Array<?>} */
DeclareClass.prototype.extends;
 /** @type {?} */
DeclareClass.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DeclareFunction() {}
 /** @type {string} */
DeclareFunction.prototype.type;
 /** @type {?} */
DeclareFunction.prototype.id;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DeclareInterface() {}
 /** @type {string} */
DeclareInterface.prototype.type;
 /** @type {?} */
DeclareInterface.prototype.id;
 /** @type {?} */
DeclareInterface.prototype.typeParameters;
 /** @type {!Array<?>} */
DeclareInterface.prototype.extends;
 /** @type {?} */
DeclareInterface.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DeclareModule() {}
 /** @type {string} */
DeclareModule.prototype.type;
 /** @type {?} */
DeclareModule.prototype.id;
 /** @type {?} */
DeclareModule.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DeclareTypeAlias() {}
 /** @type {string} */
DeclareTypeAlias.prototype.type;
 /** @type {?} */
DeclareTypeAlias.prototype.id;
 /** @type {?} */
DeclareTypeAlias.prototype.typeParameters;
 /** @type {?} */
DeclareTypeAlias.prototype.right;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DeclareVariable() {}
 /** @type {string} */
DeclareVariable.prototype.type;
 /** @type {?} */
DeclareVariable.prototype.id;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ExistentialTypeParam() {}
 /** @type {string} */
ExistentialTypeParam.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function FunctionTypeAnnotation() {}
 /** @type {string} */
FunctionTypeAnnotation.prototype.type;
 /** @type {?} */
FunctionTypeAnnotation.prototype.typeParameters;
 /** @type {!Array<?>} */
FunctionTypeAnnotation.prototype.params;
 /** @type {?} */
FunctionTypeAnnotation.prototype.rest;
 /** @type {?} */
FunctionTypeAnnotation.prototype.returnType;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function FunctionTypeParam() {}
 /** @type {string} */
FunctionTypeParam.prototype.type;
 /** @type {?} */
FunctionTypeParam.prototype.name;
 /** @type {?} */
FunctionTypeParam.prototype.typeAnnotation;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function GenericTypeAnnotation() {}
 /** @type {string} */
GenericTypeAnnotation.prototype.type;
 /** @type {?} */
GenericTypeAnnotation.prototype.id;
 /** @type {?} */
GenericTypeAnnotation.prototype.typeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function InterfaceExtends() {}
 /** @type {string} */
InterfaceExtends.prototype.type;
 /** @type {?} */
InterfaceExtends.prototype.id;
 /** @type {?} */
InterfaceExtends.prototype.typeParameters;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function InterfaceDeclaration() {}
 /** @type {string} */
InterfaceDeclaration.prototype.type;
 /** @type {?} */
InterfaceDeclaration.prototype.id;
 /** @type {?} */
InterfaceDeclaration.prototype.typeParameters;
 /** @type {!Array<?>} */
InterfaceDeclaration.prototype.extends;
 /** @type {!Array<?>} */
InterfaceDeclaration.prototype.mixins;
 /** @type {?} */
InterfaceDeclaration.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function IntersectionTypeAnnotation() {}
 /** @type {string} */
IntersectionTypeAnnotation.prototype.type;
 /** @type {!Array<?>} */
IntersectionTypeAnnotation.prototype.types;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function MixedTypeAnnotation() {}
 /** @type {string} */
MixedTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function NullableTypeAnnotation() {}
 /** @type {string} */
NullableTypeAnnotation.prototype.type;
 /** @type {?} */
NullableTypeAnnotation.prototype.typeAnnotation;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function NumericLiteralTypeAnnotation() {}
 /** @type {string} */
NumericLiteralTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function NumberTypeAnnotation() {}
 /** @type {string} */
NumberTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function StringLiteralTypeAnnotation() {}
 /** @type {string} */
StringLiteralTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function StringTypeAnnotation() {}
 /** @type {string} */
StringTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ThisTypeAnnotation() {}
 /** @type {string} */
ThisTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TupleTypeAnnotation() {}
 /** @type {string} */
TupleTypeAnnotation.prototype.type;
 /** @type {!Array<?>} */
TupleTypeAnnotation.prototype.types;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TypeofTypeAnnotation() {}
 /** @type {string} */
TypeofTypeAnnotation.prototype.type;
 /** @type {?} */
TypeofTypeAnnotation.prototype.argument;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TypeAlias() {}
 /** @type {string} */
TypeAlias.prototype.type;
 /** @type {?} */
TypeAlias.prototype.id;
 /** @type {?} */
TypeAlias.prototype.typeParameters;
 /** @type {?} */
TypeAlias.prototype.right;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TypeAnnotation() {}
 /** @type {string} */
TypeAnnotation.prototype.type;
 /** @type {?} */
TypeAnnotation.prototype.typeAnnotation;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TypeCastExpression() {}
 /** @type {string} */
TypeCastExpression.prototype.type;
 /** @type {?} */
TypeCastExpression.prototype.expression;
 /** @type {?} */
TypeCastExpression.prototype.typeAnnotation;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TypeParameterDeclaration() {}
 /** @type {string} */
TypeParameterDeclaration.prototype.type;
 /** @type {!Array<?>} */
TypeParameterDeclaration.prototype.params;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function TypeParameterInstantiation() {}
 /** @type {string} */
TypeParameterInstantiation.prototype.type;
 /** @type {!Array<?>} */
TypeParameterInstantiation.prototype.params;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ObjectTypeAnnotation() {}
 /** @type {string} */
ObjectTypeAnnotation.prototype.type;
 /** @type {!Array<?>} */
ObjectTypeAnnotation.prototype.properties;
 /** @type {!Array<?>} */
ObjectTypeAnnotation.prototype.indexers;
 /** @type {!Array<?>} */
ObjectTypeAnnotation.prototype.callProperties;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ObjectTypeCallProperty() {}
 /** @type {string} */
ObjectTypeCallProperty.prototype.type;
 /** @type {?} */
ObjectTypeCallProperty.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ObjectTypeIndexer() {}
 /** @type {string} */
ObjectTypeIndexer.prototype.type;
 /** @type {?} */
ObjectTypeIndexer.prototype.id;
 /** @type {?} */
ObjectTypeIndexer.prototype.key;
 /** @type {?} */
ObjectTypeIndexer.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ObjectTypeProperty() {}
 /** @type {string} */
ObjectTypeProperty.prototype.type;
 /** @type {?} */
ObjectTypeProperty.prototype.key;
 /** @type {?} */
ObjectTypeProperty.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function QualifiedTypeIdentifier() {}
 /** @type {string} */
QualifiedTypeIdentifier.prototype.type;
 /** @type {?} */
QualifiedTypeIdentifier.prototype.id;
 /** @type {?} */
QualifiedTypeIdentifier.prototype.qualification;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function UnionTypeAnnotation() {}
 /** @type {string} */
UnionTypeAnnotation.prototype.type;
 /** @type {!Array<?>} */
UnionTypeAnnotation.prototype.types;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function VoidTypeAnnotation() {}
 /** @type {string} */
VoidTypeAnnotation.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXAttribute() {}
 /** @type {string} */
JSXAttribute.prototype.type;
 /** @type {?} */
JSXAttribute.prototype.name;
 /** @type {?} */
JSXAttribute.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXClosingElement() {}
 /** @type {string} */
JSXClosingElement.prototype.type;
 /** @type {?} */
JSXClosingElement.prototype.name;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXElement() {}
 /** @type {string} */
JSXElement.prototype.type;
 /** @type {?} */
JSXElement.prototype.openingElement;
 /** @type {?} */
JSXElement.prototype.closingElement;
 /** @type {!Array<?>} */
JSXElement.prototype.children;
 /** @type {boolean} */
JSXElement.prototype.selfClosing;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXEmptyExpression() {}
 /** @type {string} */
JSXEmptyExpression.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXExpressionContainer() {}
 /** @type {string} */
JSXExpressionContainer.prototype.type;
 /** @type {?} */
JSXExpressionContainer.prototype.expression;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXIdentifier() {}
 /** @type {string} */
JSXIdentifier.prototype.type;
 /** @type {string} */
JSXIdentifier.prototype.name;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXMemberExpression() {}
 /** @type {string} */
JSXMemberExpression.prototype.type;
 /** @type {?} */
JSXMemberExpression.prototype.object;
 /** @type {?} */
JSXMemberExpression.prototype.property;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXNamespacedName() {}
 /** @type {string} */
JSXNamespacedName.prototype.type;
 /** @type {?} */
JSXNamespacedName.prototype.namespace;
 /** @type {?} */
JSXNamespacedName.prototype.name;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXOpeningElement() {}
 /** @type {string} */
JSXOpeningElement.prototype.type;
 /** @type {?} */
JSXOpeningElement.prototype.name;
 /** @type {boolean} */
JSXOpeningElement.prototype.selfClosing;
 /** @type {!Array<?>} */
JSXOpeningElement.prototype.attributes;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXSpreadAttribute() {}
 /** @type {string} */
JSXSpreadAttribute.prototype.type;
 /** @type {?} */
JSXSpreadAttribute.prototype.argument;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function JSXText() {}
 /** @type {string} */
JSXText.prototype.type;
 /** @type {string} */
JSXText.prototype.value;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function Noop() {}
 /** @type {string} */
Noop.prototype.type;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ParenthesizedExpression() {}
 /** @type {string} */
ParenthesizedExpression.prototype.type;
 /** @type {?} */
ParenthesizedExpression.prototype.expression;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function AwaitExpression() {}
 /** @type {string} */
AwaitExpression.prototype.type;
 /** @type {?} */
AwaitExpression.prototype.argument;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function BindExpression() {}
 /** @type {string} */
BindExpression.prototype.type;
 /** @type {?} */
BindExpression.prototype.object;
 /** @type {?} */
BindExpression.prototype.callee;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function Decorator() {}
 /** @type {string} */
Decorator.prototype.type;
 /** @type {?} */
Decorator.prototype.expression;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function DoExpression() {}
 /** @type {string} */
DoExpression.prototype.type;
 /** @type {?} */
DoExpression.prototype.body;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ExportDefaultSpecifier() {}
 /** @type {string} */
ExportDefaultSpecifier.prototype.type;
 /** @type {?} */
ExportDefaultSpecifier.prototype.exported;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function ExportNamespaceSpecifier() {}
 /** @type {string} */
ExportNamespaceSpecifier.prototype.type;
 /** @type {?} */
ExportNamespaceSpecifier.prototype.exported;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function RestProperty() {}
 /** @type {string} */
RestProperty.prototype.type;
 /** @type {?} */
RestProperty.prototype.argument;
/**
 * @extends {Node}
 * @record
 * @struct
 */
function SpreadProperty() {}
 /** @type {string} */
SpreadProperty.prototype.type;
 /** @type {?} */
SpreadProperty.prototype.argument;

/** @typedef {?} */
var Expression;

/** @typedef {?} */
var Binary;

/** @typedef {?} */
var Scopable;

/** @typedef {?} */
var BlockParent;

/** @typedef {?} */
var Block;

/** @typedef {?} */
var Statement;

/** @typedef {?} */
var Terminatorless;

/** @typedef {?} */
var CompletionStatement;

/** @typedef {?} */
var Conditional;

/** @typedef {?} */
var Loop;

/** @typedef {?} */
var While;

/** @typedef {?} */
var ExpressionWrapper;

/** @typedef {?} */
var For;

/** @typedef {?} */
var ForXStatement;

/** @typedef {?} */
var Function;

/** @typedef {?} */
var FunctionParent;

/** @typedef {?} */
var Pureish;

/** @typedef {?} */
var Declaration;

/** @typedef {?} */
var LVal;

/** @typedef {?} */
var Literal;

/** @typedef {?} */
var Immutable;

/** @typedef {?} */
var UserWhitespacable;

/** @typedef {?} */
var Method;

/** @typedef {?} */
var ObjectMember;

/** @typedef {?} */
var Property;

/** @typedef {?} */
var UnaryLike;

/** @typedef {?} */
var Pattern;

/** @typedef {?} */
var Class;

/** @typedef {?} */
var ModuleDeclaration;

/** @typedef {?} */
var ExportDeclaration;

/** @typedef {?} */
var ModuleSpecifier;

/** @typedef {?} */
var Flow;

/** @typedef {?} */
var FlowTypeAnnotation;

/** @typedef {?} */
var FlowBaseAnnotation;

/** @typedef {?} */
var FlowDeclaration;

/** @typedef {?} */
var JSX;

/**
 * @param {!Array<?>=} elements
 * @return {?}
 */
function arrayExpression(elements) {}

/**
 * @param {string=} operator
 * @param {?=} left
 * @param {?=} right
 * @return {?}
 */
function assignmentExpression(operator, left, right) {}

/**
 * @param {string=} operator
 * @param {?=} left
 * @param {?=} right
 * @return {?}
 */
function binaryExpression(operator, left, right) {}

/**
 * @param {?=} value
 * @return {?}
 */
function directive(value) {}

/**
 * @param {string=} value
 * @return {?}
 */
function directiveLiteral(value) {}

/**
 * @param {!Array<?>=} body
 * @param {!Array<?>=} directives
 * @return {?}
 */
function blockStatement(body, directives) {}

/**
 * @param {?=} label
 * @return {?}
 */
function breakStatement(label) {}

/**
 * @param {?=} callee
 * @param {!Array<?>=} _arguments
 * @return {?}
 */
function callExpression(callee, _arguments) {}

/**
 * @param {?=} param
 * @param {?=} body
 * @return {?}
 */
function catchClause(param, body) {}

/**
 * @param {?=} test
 * @param {?=} consequent
 * @param {?=} alternate
 * @return {?}
 */
function conditionalExpression(test, consequent, alternate) {}

/**
 * @param {?=} label
 * @return {?}
 */
function continueStatement(label) {}

/**
 * @return {?}
 */
function debuggerStatement() {}

/**
 * @param {?=} test
 * @param {?=} body
 * @return {?}
 */
function doWhileStatement(test, body) {}

/**
 * @return {?}
 */
function emptyStatement() {}

/**
 * @param {?=} expression
 * @return {?}
 */
function expressionStatement(expression) {}

/**
 * @param {?=} program
 * @param {!Array<?>=} comments
 * @param {!Array<?>=} tokens
 * @return {?}
 */
function file(program, comments, tokens) {}

/**
 * @param {?=} left
 * @param {?=} right
 * @param {?=} body
 * @return {?}
 */
function forInStatement(left, right, body) {}

/**
 * @param {?=} init
 * @param {?=} test
 * @param {?=} update
 * @param {?=} body
 * @return {?}
 */
function forStatement(init, test, update, body) {}

/**
 * @param {?=} id
 * @param {!Array<?>=} params
 * @param {?=} body
 * @param {boolean=} generator
 * @param {boolean=} async
 * @return {?}
 */
function functionDeclaration(id, params, body, generator, async) {}

/**
 * @param {?=} id
 * @param {!Array<?>=} params
 * @param {?=} body
 * @param {boolean=} generator
 * @param {boolean=} async
 * @return {?}
 */
function functionExpression(id, params, body, generator, async) {}

/**
 * @param {string=} name
 * @return {?}
 */
function identifier(name) {}

/**
 * @param {?=} test
 * @param {?=} consequent
 * @param {?=} alternate
 * @return {?}
 */
function ifStatement(test, consequent, alternate) {}

/**
 * @param {?=} label
 * @param {?=} body
 * @return {?}
 */
function labeledStatement(label, body) {}

/**
 * @param {string=} value
 * @return {?}
 */
function stringLiteral(value) {}

/**
 * @param {number=} value
 * @return {?}
 */
function numericLiteral(value) {}

/**
 * @return {?}
 */
function nullLiteral() {}

/**
 * @param {boolean=} value
 * @return {?}
 */
function booleanLiteral(value) {}

/**
 * @param {string=} pattern
 * @param {string=} flags
 * @return {?}
 */
function regExpLiteral(pattern, flags) {}

/**
 * @param {string=} operator
 * @param {?=} left
 * @param {?=} right
 * @return {?}
 */
function logicalExpression(operator, left, right) {}

/**
 * @param {?=} object
 * @param {?=} property
 * @param {boolean=} computed
 * @return {?}
 */
function memberExpression(object, property, computed) {}

/**
 * @param {?=} callee
 * @param {!Array<?>=} _arguments
 * @return {?}
 */
function newExpression(callee, _arguments) {}

/**
 * @param {!Array<?>=} body
 * @param {!Array<?>=} directives
 * @return {?}
 */
function program(body, directives) {}

/**
 * @param {!Array<?>=} properties
 * @return {?}
 */
function objectExpression(properties) {}

/**
 * @param {string=} kind
 * @param {?=} key
 * @param {!Array<?>=} params
 * @param {?=} body
 * @param {boolean=} computed
 * @return {?}
 */
function objectMethod(kind, key, params, body, computed) {}

/**
 * @param {?=} key
 * @param {?=} value
 * @param {boolean=} computed
 * @param {boolean=} shorthand
 * @param {!Array<?>=} decorators
 * @return {?}
 */
function objectProperty(key, value, computed, shorthand, decorators) {}

/**
 * @param {?=} argument
 * @param {?=} typeAnnotation
 * @return {?}
 */
function restElement(argument, typeAnnotation) {}

/**
 * @param {?=} argument
 * @return {?}
 */
function returnStatement(argument) {}

/**
 * @param {!Array<?>=} expressions
 * @return {?}
 */
function sequenceExpression(expressions) {}

/**
 * @param {?=} test
 * @param {!Array<?>=} consequent
 * @return {?}
 */
function switchCase(test, consequent) {}

/**
 * @param {?=} discriminant
 * @param {!Array<?>=} cases
 * @return {?}
 */
function switchStatement(discriminant, cases) {}

/**
 * @return {?}
 */
function thisExpression() {}

/**
 * @param {?=} argument
 * @return {?}
 */
function throwStatement(argument) {}

/**
 * @param {?=} block
 * @param {?=} handler
 * @param {?=} finalizer
 * @return {?}
 */
function tryStatement(block, handler, finalizer) {}

/**
 * @param {string=} operator
 * @param {?=} argument
 * @param {boolean=} prefix
 * @return {?}
 */
function unaryExpression(operator, argument, prefix) {}

/**
 * @param {string=} operator
 * @param {?=} argument
 * @param {boolean=} prefix
 * @return {?}
 */
function updateExpression(operator, argument, prefix) {}

/**
 * @param {string=} kind
 * @param {!Array<?>=} declarations
 * @return {?}
 */
function variableDeclaration(kind, declarations) {}

/**
 * @param {?=} id
 * @param {?=} init
 * @return {?}
 */
function variableDeclarator(id, init) {}

/**
 * @param {?=} test
 * @param {?=} body
 * @return {?}
 */
function whileStatement(test, body) {}

/**
 * @param {?=} object
 * @param {?=} body
 * @return {?}
 */
function withStatement(object, body) {}

/**
 * @param {?=} left
 * @param {?=} right
 * @return {?}
 */
function assignmentPattern(left, right) {}

/**
 * @param {!Array<?>=} elements
 * @param {?=} typeAnnotation
 * @return {?}
 */
function arrayPattern(elements, typeAnnotation) {}

/**
 * @param {!Array<?>=} params
 * @param {?=} body
 * @param {boolean=} async
 * @return {?}
 */
function arrowFunctionExpression(params, body, async) {}

/**
 * @param {!Array<?>=} body
 * @return {?}
 */
function classBody(body) {}

/**
 * @param {?=} id
 * @param {?=} superClass
 * @param {?=} body
 * @param {!Array<?>=} decorators
 * @return {?}
 */
function classDeclaration(id, superClass, body, decorators) {}

/**
 * @param {?=} id
 * @param {?=} superClass
 * @param {?=} body
 * @param {!Array<?>=} decorators
 * @return {?}
 */
function classExpression(id, superClass, body, decorators) {}

/**
 * @param {?=} source
 * @return {?}
 */
function exportAllDeclaration(source) {}

/**
 * @param {?=} declaration
 * @return {?}
 */
function exportDefaultDeclaration(declaration) {}

/**
 * @param {?=} declaration
 * @param {!Array<?>=} specifiers
 * @param {?=} source
 * @return {?}
 */
function exportNamedDeclaration(declaration, specifiers, source) {}

/**
 * @param {?=} local
 * @param {?=} exported
 * @return {?}
 */
function exportSpecifier(local, exported) {}

/**
 * @param {?=} left
 * @param {?=} right
 * @param {?=} body
 * @return {?}
 */
function forOfStatement(left, right, body) {}

/**
 * @param {!Array<?>=} specifiers
 * @param {?=} source
 * @return {?}
 */
function importDeclaration(specifiers, source) {}

/**
 * @param {?=} local
 * @return {?}
 */
function importDefaultSpecifier(local) {}

/**
 * @param {?=} local
 * @return {?}
 */
function importNamespaceSpecifier(local) {}

/**
 * @param {?=} local
 * @param {?=} imported
 * @return {?}
 */
function importSpecifier(local, imported) {}

/**
 * @param {string=} meta
 * @param {string=} property
 * @return {?}
 */
function metaProperty(meta, property) {}

/**
 * @param {string=} kind
 * @param {?=} key
 * @param {!Array<?>=} params
 * @param {?=} body
 * @param {boolean=} computed
 * @param {boolean=} _static
 * @return {?}
 */
function classMethod(kind, key, params, body, computed, _static) {}

/**
 * @param {!Array<?>=} properties
 * @param {?=} typeAnnotation
 * @return {?}
 */
function objectPattern(properties, typeAnnotation) {}

/**
 * @param {?=} argument
 * @return {?}
 */
function spreadElement(argument) {}

/**
 * @param {?=} tag
 * @param {?=} quasi
 * @return {?}
 */
function taggedTemplateExpression(tag, quasi) {}

/**
 * @param {?=} value
 * @param {boolean=} tail
 * @return {?}
 */
function templateElement(value, tail) {}

/**
 * @param {!Array<?>=} quasis
 * @param {!Array<?>=} expressions
 * @return {?}
 */
function templateLiteral(quasis, expressions) {}

/**
 * @param {?=} argument
 * @param {boolean=} delegate
 * @return {?}
 */
function yieldExpression(argument, delegate) {}

/**
 * @return {?}
 */
function anyTypeAnnotation() {}

/**
 * @param {?=} elementType
 * @return {?}
 */
function arrayTypeAnnotation(elementType) {}

/**
 * @return {?}
 */
function booleanTypeAnnotation() {}

/**
 * @return {?}
 */
function booleanLiteralTypeAnnotation() {}

/**
 * @return {?}
 */
function nullLiteralTypeAnnotation() {}

/**
 * @param {?=} id
 * @param {?=} typeParameters
 * @return {?}
 */
function classImplements(id, typeParameters) {}

/**
 * @param {?=} key
 * @param {?=} value
 * @param {?=} typeAnnotation
 * @param {!Array<?>=} decorators
 * @return {?}
 */
function classProperty(key, value, typeAnnotation, decorators) {}

/**
 * @param {?=} id
 * @param {?=} typeParameters
 * @param {!Array<?>=} _extends
 * @param {?=} body
 * @return {?}
 */
function declareClass(id, typeParameters, _extends, body) {}

/**
 * @param {?=} id
 * @return {?}
 */
function declareFunction(id) {}

/**
 * @param {?=} id
 * @param {?=} typeParameters
 * @param {!Array<?>=} _extends
 * @param {?=} body
 * @return {?}
 */
function declareInterface(id, typeParameters, _extends, body) {}

/**
 * @param {?=} id
 * @param {?=} body
 * @return {?}
 */
function declareModule(id, body) {}

/**
 * @param {?=} id
 * @param {?=} typeParameters
 * @param {?=} right
 * @return {?}
 */
function declareTypeAlias(id, typeParameters, right) {}

/**
 * @param {?=} id
 * @return {?}
 */
function declareVariable(id) {}

/**
 * @return {?}
 */
function existentialTypeParam() {}

/**
 * @param {?=} typeParameters
 * @param {!Array<?>=} params
 * @param {?=} rest
 * @param {?=} returnType
 * @return {?}
 */
function functionTypeAnnotation(typeParameters, params, rest, returnType) {}

/**
 * @param {?=} name
 * @param {?=} typeAnnotation
 * @return {?}
 */
function functionTypeParam(name, typeAnnotation) {}

/**
 * @param {?=} id
 * @param {?=} typeParameters
 * @return {?}
 */
function genericTypeAnnotation(id, typeParameters) {}

/**
 * @param {?=} id
 * @param {?=} typeParameters
 * @return {?}
 */
function interfaceExtends(id, typeParameters) {}

/**
 * @param {?=} id
 * @param {?=} typeParameters
 * @param {!Array<?>=} _extends
 * @param {?=} body
 * @return {?}
 */
function interfaceDeclaration(id, typeParameters, _extends, body) {}

/**
 * @param {!Array<?>=} types
 * @return {?}
 */
function intersectionTypeAnnotation(types) {}

/**
 * @return {?}
 */
function mixedTypeAnnotation() {}

/**
 * @param {?=} typeAnnotation
 * @return {?}
 */
function nullableTypeAnnotation(typeAnnotation) {}

/**
 * @return {?}
 */
function numericLiteralTypeAnnotation() {}

/**
 * @return {?}
 */
function numberTypeAnnotation() {}

/**
 * @return {?}
 */
function stringLiteralTypeAnnotation() {}

/**
 * @return {?}
 */
function stringTypeAnnotation() {}

/**
 * @return {?}
 */
function thisTypeAnnotation() {}

/**
 * @param {!Array<?>=} types
 * @return {?}
 */
function tupleTypeAnnotation(types) {}

/**
 * @param {?=} argument
 * @return {?}
 */
function typeofTypeAnnotation(argument) {}

/**
 * @param {?=} id
 * @param {?=} typeParameters
 * @param {?=} right
 * @return {?}
 */
function typeAlias(id, typeParameters, right) {}

/**
 * @param {?=} typeAnnotation
 * @return {?}
 */
function typeAnnotation(typeAnnotation) {}

/**
 * @param {?=} expression
 * @param {?=} typeAnnotation
 * @return {?}
 */
function typeCastExpression(expression, typeAnnotation) {}

/**
 * @param {!Array<?>=} params
 * @return {?}
 */
function typeParameterDeclaration(params) {}

/**
 * @param {!Array<?>=} params
 * @return {?}
 */
function typeParameterInstantiation(params) {}

/**
 * @param {!Array<?>=} properties
 * @param {!Array<?>=} indexers
 * @param {!Array<?>=} callProperties
 * @return {?}
 */
function objectTypeAnnotation(properties, indexers, callProperties) {}

/**
 * @param {?=} value
 * @return {?}
 */
function objectTypeCallProperty(value) {}

/**
 * @param {?=} id
 * @param {?=} key
 * @param {?=} value
 * @return {?}
 */
function objectTypeIndexer(id, key, value) {}

/**
 * @param {?=} key
 * @param {?=} value
 * @return {?}
 */
function objectTypeProperty(key, value) {}

/**
 * @param {?=} id
 * @param {?=} qualification
 * @return {?}
 */
function qualifiedTypeIdentifier(id, qualification) {}

/**
 * @param {!Array<?>=} types
 * @return {?}
 */
function unionTypeAnnotation(types) {}

/**
 * @return {?}
 */
function voidTypeAnnotation() {}

/**
 * @param {?=} name
 * @param {?=} value
 * @return {?}
 */
function jSXAttribute(name, value) {}

/**
 * @param {?=} name
 * @return {?}
 */
function jSXClosingElement(name) {}

/**
 * @param {?=} openingElement
 * @param {?=} closingElement
 * @param {!Array<?>=} children
 * @param {boolean=} selfClosing
 * @return {?}
 */
function jSXElement(openingElement, closingElement, children, selfClosing) {}

/**
 * @return {?}
 */
function jSXEmptyExpression() {}

/**
 * @param {?=} expression
 * @return {?}
 */
function jSXExpressionContainer(expression) {}

/**
 * @param {string=} name
 * @return {?}
 */
function jSXIdentifier(name) {}

/**
 * @param {?=} object
 * @param {?=} property
 * @return {?}
 */
function jSXMemberExpression(object, property) {}

/**
 * @param {?=} namespace
 * @param {?=} name
 * @return {?}
 */
function jSXNamespacedName(namespace, name) {}

/**
 * @param {?=} name
 * @param {!Array<?>=} attributes
 * @param {boolean=} selfClosing
 * @return {?}
 */
function jSXOpeningElement(name, attributes, selfClosing) {}

/**
 * @param {?=} argument
 * @return {?}
 */
function jSXSpreadAttribute(argument) {}

/**
 * @param {string=} value
 * @return {?}
 */
function jSXText(value) {}

/**
 * @return {?}
 */
function noop() {}

/**
 * @param {?=} expression
 * @return {?}
 */
function parenthesizedExpression(expression) {}

/**
 * @param {?=} argument
 * @return {?}
 */
function awaitExpression(argument) {}

/**
 * @param {?=} object
 * @param {?=} callee
 * @return {?}
 */
function bindExpression(object, callee) {}

/**
 * @param {?=} expression
 * @return {?}
 */
function decorator(expression) {}

/**
 * @param {?=} body
 * @return {?}
 */
function doExpression(body) {}

/**
 * @param {?=} exported
 * @return {?}
 */
function exportDefaultSpecifier(exported) {}

/**
 * @param {?=} exported
 * @return {?}
 */
function exportNamespaceSpecifier(exported) {}

/**
 * @param {?=} argument
 * @return {?}
 */
function restProperty(argument) {}

/**
 * @param {?=} argument
 * @return {?}
 */
function spreadProperty(argument) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isArrayExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isAssignmentExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBinaryExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDirective(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDirectiveLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBlockStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBreakStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isCallExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isCatchClause(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isConditionalExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isContinueStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDebuggerStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDoWhileStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isEmptyStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExpressionStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFile(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isForInStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isForStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFunctionDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFunctionExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isIdentifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isIfStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isLabeledStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isStringLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isNumericLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isNullLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBooleanLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isRegExpLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isLogicalExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isMemberExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isNewExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isProgram(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isObjectExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isObjectMethod(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isObjectProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isRestElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isReturnStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isSequenceExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isSwitchCase(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isSwitchStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isThisExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isThrowStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTryStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isUnaryExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isUpdateExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isVariableDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isVariableDeclarator(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isWhileStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isWithStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isAssignmentPattern(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isArrayPattern(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isArrowFunctionExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isClassBody(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isClassDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isClassExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExportAllDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExportDefaultDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExportNamedDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExportSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isForOfStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isImportDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isImportDefaultSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isImportNamespaceSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isImportSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isMetaProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isClassMethod(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isObjectPattern(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isSpreadElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isSuper(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTaggedTemplateExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTemplateElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTemplateLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isYieldExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isAnyTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isArrayTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBooleanTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBooleanLiteralTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isNullLiteralTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isClassImplements(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isClassProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDeclareClass(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDeclareFunction(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDeclareInterface(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDeclareModule(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDeclareTypeAlias(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDeclareVariable(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExistentialTypeParam(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFunctionTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFunctionTypeParam(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isGenericTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isInterfaceExtends(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isInterfaceDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isIntersectionTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isMixedTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isNullableTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isNumericLiteralTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isNumberTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isStringLiteralTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isStringTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isThisTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTupleTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTypeofTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTypeAlias(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTypeCastExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTypeParameterDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTypeParameterInstantiation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isObjectTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isObjectTypeCallProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isObjectTypeIndexer(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isObjectTypeProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isQualifiedTypeIdentifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isUnionTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isVoidTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXAttribute(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXClosingElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXEmptyExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXExpressionContainer(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXIdentifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXMemberExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXNamespacedName(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXOpeningElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXSpreadAttribute(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSXText(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isNoop(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isParenthesizedExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isAwaitExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBindExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDecorator(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDoExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExportDefaultSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExportNamespaceSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isRestProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isSpreadProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBinary(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isScopable(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBlockParent(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBlock(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isTerminatorless(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isCompletionStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isConditional(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isLoop(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isWhile(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExpressionWrapper(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFor(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isForXStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFunction(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFunctionParent(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isPureish(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isLVal(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isImmutable(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isUserWhitespacable(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isMethod(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isObjectMember(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isUnaryLike(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isPattern(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isClass(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isModuleDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isExportDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isModuleSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFlow(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFlowBaseAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isFlowDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isJSX(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isNumberLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isRegexLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isReferencedIdentifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isReferencedMemberExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBindingIdentifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isScope(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isReferenced(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isBlockScoped(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isVar(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isUser(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isGenerated(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {boolean}
 */
function isPure(node, opts) {}
/**
 * @record
 * @struct
 */
function ReactHelpers() {}

/**
 * @param {string=} tagName
 * @return {boolean}
 */
ReactHelpers.prototype.isCompatTag = function(tagName) {};

/**
 * @param {!Object} node
 * @return {!Array<?>}
 */
ReactHelpers.prototype.buildChildren = function(node) {};
 /** @type {?} */
var react;

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertArrayExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertAssignmentExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBinaryExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDirective(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDirectiveLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBlockStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBreakStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertCallExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertCatchClause(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertConditionalExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertContinueStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDebuggerStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDoWhileStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertEmptyStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExpressionStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFile(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertForInStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertForStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFunctionDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFunctionExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertIdentifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertIfStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertLabeledStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertStringLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertNumericLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertNullLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBooleanLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertRegExpLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertLogicalExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertMemberExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertNewExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertProgram(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertObjectExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertObjectMethod(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertObjectProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertRestElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertReturnStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertSequenceExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertSwitchCase(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertSwitchStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertThisExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertThrowStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTryStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertUnaryExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertUpdateExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertVariableDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertVariableDeclarator(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertWhileStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertWithStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertAssignmentPattern(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertArrayPattern(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertArrowFunctionExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertClassBody(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertClassDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertClassExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExportAllDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExportDefaultDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExportNamedDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExportSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertForOfStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertImportDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertImportDefaultSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertImportNamespaceSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertImportSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertMetaProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertClassMethod(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertObjectPattern(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertSpreadElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertSuper(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTaggedTemplateExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTemplateElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTemplateLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertYieldExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertAnyTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertArrayTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBooleanTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBooleanLiteralTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertNullLiteralTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertClassImplements(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertClassProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDeclareClass(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDeclareFunction(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDeclareInterface(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDeclareModule(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDeclareTypeAlias(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDeclareVariable(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExistentialTypeParam(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFunctionTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFunctionTypeParam(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertGenericTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertInterfaceExtends(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertInterfaceDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertIntersectionTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertMixedTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertNullableTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertNumericLiteralTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertNumberTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertStringLiteralTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertStringTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertThisTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTupleTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTypeofTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTypeAlias(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTypeCastExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTypeParameterDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTypeParameterInstantiation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertObjectTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertObjectTypeCallProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertObjectTypeIndexer(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertObjectTypeProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertQualifiedTypeIdentifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertUnionTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertVoidTypeAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXAttribute(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXClosingElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXEmptyExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXExpressionContainer(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXIdentifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXMemberExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXNamespacedName(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXOpeningElement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXSpreadAttribute(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSXText(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertNoop(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertParenthesizedExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertAwaitExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBindExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDecorator(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDoExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExportDefaultSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExportNamespaceSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertRestProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertSpreadProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExpression(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBinary(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertScopable(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBlockParent(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertBlock(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertTerminatorless(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertCompletionStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertConditional(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertLoop(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertWhile(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExpressionWrapper(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFor(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertForXStatement(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFunction(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFunctionParent(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertPureish(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertLVal(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertImmutable(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertUserWhitespacable(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertMethod(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertObjectMember(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertProperty(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertUnaryLike(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertPattern(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertClass(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertModuleDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertExportDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertModuleSpecifier(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFlow(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFlowBaseAnnotation(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertFlowDeclaration(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertJSX(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertNumberLiteral(node, opts) {}

/**
 * @param {!Object} node
 * @param {!Object=} opts
 * @return {void}
 */
function assertRegexLiteral(node, opts) {}
