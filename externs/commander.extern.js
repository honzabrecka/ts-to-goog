/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/commander/index.d.ts:

/**
 * @constructor
 * @struct
 * Initialize a new `Option` with the given `flags` and `description`.
 * 
 * @param {string} flags
 * @param {string=} description
 */
function Option(flags, description) {}
 /** @type {string} */
Option.prototype.flags;
 /** @type {boolean} */
Option.prototype.required;
 /** @type {boolean} */
Option.prototype.optional;
 /** @type {boolean} */
Option.prototype.bool;
 /** @type {string} */
Option.prototype.short;
 /** @type {string} */
Option.prototype.long;
 /** @type {string} */
Option.prototype.description;

/**
 * @constructor
 * @struct
 * Initialize a new `Command`.
 * 
 * @param {string=} name
 */
function Command(name) {}

/* TODO: IndexSignature:  */
 /** @type {!Array<string>} */
Command.prototype.args;

/**
 * Set the program version to `str`.
 * 
 * This method auto-registers the "-V, --version" flag
 * which will print the version number when passed.
 * 
 * @param {string} str
 * @param {string=} flags
 * @return {!Command}
 */
Command.prototype.version = function(str, flags) {};

/**
 * Add command `name`.
 * 
 * The `.action()` callback is invoked when the
 * command `name` is specified via __ARGV__,
 * and the remaining arguments are applied to the
 * function for access.
 * 
 * When the `name` is "*" an un-matched command
 * will be passed as the first arg, followed by
 * the rest of __ARGV__ remaining.
 * 
 * \@example 
 *      program
 *        .version('0.0.1')
 *        .option('-C, --chdir <path>', 'change the working directory')
 *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
 *        .option('-T, --no-tests', 'ignore test hook')
 * 
 *      program
 *        .command('setup')
 *        .description('run remote setup commands')
 *        .action(function() {
 *          console.log('setup');
 *        });
 * 
 *      program
 *        .command('exec <cmd>')
 *        .description('run the given remote command')
 *        .action(function(cmd) {
 *          console.log('exec "%s"', cmd);
 *        });
 * 
 *      program
 *        .command('teardown <dir> [otherDirs...]')
 *        .description('run teardown commands')
 *        .action(function(dir, otherDirs) {
 *          console.log('dir "%s"', dir);
 *          if (otherDirs) {
 *            otherDirs.forEach(function (oDir) {
 *              console.log('dir "%s"', oDir);
 *            });
 *          }
 *        });
 * 
 *      program
 *        .command('*')
 *        .description('deploy the given env')
 *        .action(function(env) {
 *          console.log('deploying "%s"', env);
 *        });
 * 
 *      program.parse(process.argv);
 * 
 * @param {string} name
 * @param {string=} desc
 * @param {!commander.CommandOptions=} opts
 * @return {!Command}
 */
Command.prototype.command = function(name, desc, opts) {};

/**
 * Define argument syntax for the top-level command.
 * 
 * @param {string} desc
 * @return {!Command}
 */
Command.prototype.arguments = function(desc) {};

/**
 * Parse expected `args`.
 * 
 * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
 * 
 * @param {!Array<string>} args
 * @return {!Command}
 */
Command.prototype.parseExpectedArgs = function(args) {};

/**
 * Register callback `fn` for the command.
 * 
 * \@example 
 *      program
 *        .command('help')
 *        .description('display verbose help')
 *        .action(function() {
 *           // output help here
 *        });
 * 
 * @param {function(!Array<?>): void} fn
 * @return {!Command}
 */
Command.prototype.action = function(fn) {};

/**
 * Define option with `flags`, `description` and optional
 * coercion `fn`.
 * 
 * The `flags` string should contain both the short and long flags,
 * separated by comma, a pipe or space. The following are all valid
 * all will output this way when `--help` is used.
 * 
 *    "-p, --pepper"
 *    "-p|--pepper"
 *    "-p --pepper"
 * 
 * \@example 
 *     // simple boolean defaulting to false
 *     program.option('-p, --pepper', 'add pepper');
 * 
 *     --pepper
 *     program.pepper
 *     // => Boolean
 * 
 *     // simple boolean defaulting to true
 *     program.option('-C, --no-cheese', 'remove cheese');
 * 
 *     program.cheese
 *     // => true
 * 
 *     --no-cheese
 *     program.cheese
 *     // => false
 * 
 *     // required argument
 *     program.option('-C, --chdir <path>', 'change the working directory');
 * 
 *     --chdir /tmp
 *     program.chdir
 *     // => "/tmp"
 * 
 *     // optional argument
 *     program.option('-c, --cheese [type]', 'add cheese [marble]');
 * 
 * @param {string} flags
 * @param {string=} description
 * @param {(!RegExp|function(?, ?): void)|?=} fn_or_defaultValue
 * @param {?=} defaultValue
 * @return {!Command}
 */
Command.prototype.option = function(flags, description, fn_or_defaultValue, defaultValue) {};

/**
 * Allow unknown options on the command line.
 * 
 * @param {boolean=} arg
 * @return {!Command}
 */
Command.prototype.allowUnknownOption = function(arg) {};

/**
 * Parse `argv`, settings options and invoking commands when defined.
 * 
 * @param {!Array<string>} argv
 * @return {!Command}
 */
Command.prototype.parse = function(argv) {};

/**
 * Parse options from `argv` returning `argv` void of these options.
 * 
 * @param {!Array<string>} argv
 * @return {!commander.ParseOptionsResult}
 */
Command.prototype.parseOptions = function(argv) {};

/**
 * Return an object containing options as key-value pairs
 * 
 * @return {!Object<string,string>}
 */
Command.prototype.opts = function() {};

/**
 * Set the description to `str`.
 * 
 * @param {string=} str
 * @return {!Command|string}
 */
Command.prototype.description = function(str) {};

/**
 * Set an alias for the command.
 * 
 * @param {string=} alias
 * @return {!Command|string}
 */
Command.prototype.alias = function(alias) {};

/**
 * Set or get the command usage.
 * 
 * @param {string=} str
 * @return {!Command|string}
 */
Command.prototype.usage = function(str) {};

/**
 * Get the name of the command.
 * 
 * @return {string}
 */
Command.prototype.name = function() {};

/**
 * Output help information for this command.
 * 
 * @param {function(): void=} cb
 * @return {void}
 */
Command.prototype.outputHelp = function(cb) {};

/**
 * Output help information and exit.
 * @return {void}
 */
Command.prototype.help = function() {};
/** @const */
var commander = {};
/**
 * @record
 * @struct
 */
commander.CommandOptions = function() {};
 /** @type {boolean} */
commander.CommandOptions.prototype.noHelp;
 /** @type {boolean} */
commander.CommandOptions.prototype.isDefault;
/**
 * @record
 * @struct
 */
commander.ParseOptionsResult = function() {};
 /** @type {!Array<string>} */
commander.ParseOptionsResult.prototype.args;
 /** @type {!Array<string>} */
commander.ParseOptionsResult.prototype.unknown;
/**
 * @record
 * @struct
 */
commander.CommanderStatic = function() {};
 /** @type {?} */
commander.CommanderStatic.prototype.Command;
 /** @type {?} */
commander.CommanderStatic.prototype.Option;
 /** @type {!commander.CommandOptions} */
commander.CommanderStatic.prototype.CommandOptions;
 /** @type {!commander.ParseOptionsResult} */
commander.CommanderStatic.prototype.ParseOptionsResult;
 /** @type {!commander.CommanderStatic} */
var commander;

/* TODO: ExportAssignment in  */
