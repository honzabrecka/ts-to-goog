/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/dhtmlxscheduler/index.d.ts:
/**
 * @record
 * @struct
 */
function SchedulerCallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function SchedulerFilterCallback() {}

/* TODO: CallSignature:  */

/** @typedef {string} */
var SchedulerEventName;
/**
 * @record
 * @struct
 */
function SchedulerTemplates() {}

/**
 * specifies the date in the header of the view
 * @param {!Date} start the start date of the view
 * @param {!Date} end the end date of the view
 * @return {string}
 */
SchedulerTemplates.prototype.agenda_date = function(start, end) {};

/**
 * specifies the text in the second column of the Agenda view
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.agenda_text = function(start, end, event) {};

/**
 * specifies the date in the first column of the Agenda view
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.agenda_time = function(start, end, event) {};

/**
 * specifies the format of dates that are set by means of API methods. Used to parse incoming dates
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.api_date = function(date) {};

/**
 * specifies the format of the date in a cell
 * @param {!Date} date the cell's date
 * @return {string}
 */
SchedulerTemplates.prototype.calendar_date = function(date) {};

/**
 * specifies the date in the header of the calendar
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.calendar_month = function(date) {};

/**
 * specifies the day name in the week sub-header of the view
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.calendar_scale_date = function(date) {};

/**
 * specifies the date format of the lightbox's start and end date inputs
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.calendar_time = function(date) {};

/**
 * specifies the date in the header of the Day and Units views
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.day_date = function(date) {};

/**
 * specifies the date in the sub-header of the Day view
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.day_scale_date = function(date) {};

/**
 * specifies the CSS class that will be applied to the highlighted event's duration on the time scale
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} ev the event's object
 * @return {void}
 */
SchedulerTemplates.prototype.drag_marker_class = function(start, end, ev) {};

/**
 * specifies the content of the highlighted block  on the time scale
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} ev the event's object
 * @return {void}
 */
SchedulerTemplates.prototype.drag_marker_content = function(start, end, ev) {};

/**
 * specifies the date of an event. Applied to one-day events only
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.event_bar_date = function(start, end, event) {};

/**
 * specifies the event's text. Applied to multi-day events only
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event's object
 * @return {string}
 */
SchedulerTemplates.prototype.event_bar_text = function(start, end, event) {};

/**
 * specifies the CSS class that will be applied to the event's container
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} ev the event's object
 * @return {string}
 */
SchedulerTemplates.prototype.event_class = function(start, end, ev) {};

/**
 * specifies the time part of the start and end dates of the event. Mostly used by other templates for presenting time periods
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.event_date = function(date) {};

/**
 * specifies the event's header
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event's object
 * @return {string}
 */
SchedulerTemplates.prototype.event_header = function(start, end, event) {};

/**
 * specifies the event's text
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.event_text = function(start, end, event) {};

/**
 * specifies the items of the Y-Axis
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.hour_scale = function(date) {};

/**
 * specifies the format of requests in the dynamic loading mode
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.load_format = function(date) {};

/**
 * specifies the date in the header of the view
 * @param {!Date} start the start date of the view
 * @param {!Date} end the end date of the view
 * @return {string}
 */
SchedulerTemplates.prototype.map_date = function(start, end) {};

/**
 * specifies the text in the second column of the view
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.map_text = function(start, end, event) {};

/**
 * specifies the date in the first column of the view
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.map_time = function(start, end, event) {};

/**
 * specifies the date of the event in the Google Maps popup marker
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.marker_date = function(start, end, event) {};

/**
 * specifies the text of the event in the Google Maps popup marker
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.marker_text = function(start, end, event) {};

/**
 * specifies the date in the header of the view
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.month_date = function(date) {};

/**
 * specifies the CSS class that will be applied to a day cell
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.month_date_class = function(date) {};

/**
 * specifies the format of the day in a cell
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.month_day = function(date) {};

/**
 * specifies the presentation of the 'View more' link in the cell of the Month view
 * @param {!Date} date the date of a month cell
 * @param {number} count the number of events in the cell
 * @return {string}
 */
SchedulerTemplates.prototype.month_events_link = function(date, count) {};

/**
 * specifies the date format of the X-Axis of the view
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.month_scale_date = function(date) {};

/**
 * specifies the content of the pop-up edit form
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.quick_info_content = function(start, end, event) {};

/**
 * specifies the date of the pop-up edit form
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.quick_info_date = function(start, end, event) {};

/**
 * specifies the title of the pop-up edit form
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.quick_info_title = function(start, end, event) {};

/**
 * specifies the drop-down time selector in the lightbox
 * @return {string}
 */
SchedulerTemplates.prototype.time_picker = function() {};

/**
 * specifies the format of start and end dates displayed in the tooltip
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.tooltip_date_format = function(date) {};

/**
 * specifies the text of tooltips
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.tooltip_text = function(start, end, event) {};

/**
 * specifies the event's text
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @param {!Date} cellDate the date of a day cell that a one-day event or a single occurrence of <br> the recurring event displays in
 * @param {string} pos the position of a single occurrence in the recurring event: 'start' - the first occurrence, 'end' - the last occurrence, 'middle' - for remaining occurrences
 * @return {string}
 */
SchedulerTemplates.prototype.week_agenda_event_text = function(start, end, event, cellDate, pos) {};

/**
 * the date of a day cell of the view
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.week_agenda_scale_date = function(date) {};

/**
 * specifies the date in the header of the view
 * @param {!Date} start the start date of the view
 * @param {!Date} end the end date of the view
 * @return {string}
 */
SchedulerTemplates.prototype.week_date = function(start, end) {};

/**
 * specifies the CSS class that will be applied to a day cell
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.week_date_class = function(start, end, event) {};

/**
 * specifies the date in the sub-header of the view
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.week_scale_date = function(date) {};

/**
 * a string from an XML file is converted into a date object in conformity with this template
 * @param {!Date} date the string which need to be parsed
 * @return {!Date}
 */
SchedulerTemplates.prototype.xml_date = function(date) {};

/**
 * a date object is converted into a string in conformity with this template. Used to send data back to the server
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.xml_format = function(date) {};

/**
 * specifies the date in the header of the view
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.year_date = function(date) {};

/**
 * specifies the month's name in the header of a month block of the view.
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.year_month = function(date) {};

/**
 * specifies the day's name in the sub-header of a month block of the view
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.year_scale_date = function(date) {};

/**
 * specifies the tooltip over a day cell containing some scheduled event(s)
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.year_tooltip = function(start, end, event) {};

/**
 * specifies the lightbox's header
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.lightbox_header = function(start, end, event) {};

/**
 * specifies the date in the header of the view
 * @param {!Date} start the start date of the view
 * @param {!Date} end the end date of the view
 * @return {string}
 */
SchedulerTemplates.prototype.grid_date = function(start, end) {};

/**
 * specifies the format of dates in columns with id='date'
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} ev the event object
 * @return {string}
 */
SchedulerTemplates.prototype.grid_full_date = function(start, end, ev) {};

/**
 * specifies the format of dates in columns with id='start_date' or id='end_date'
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.grid_single_date = function(date) {};

/**
 * specifies the text in the columns
 * @param {string} field_name the column's id
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.grid_field = function(field_name, event) {};

/**
 * specifies the number of scheduled events in a cell of the view
 * @param {!Array<?>} evs an array of objects of events contained in a cell
 * @param {!Date} date the date of a cell
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_cell_value = function(evs, date) {};

/**
 * specifies the CSS class that will be applied to a cell of the view
 * @param {!Array<?>} evs an array of objects of events contained in a cell (defined only in the 'cell' mode)
 * @param {!Date} date the date of a column
 * @param {?} section the section object
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_cell_class = function(evs, date, section) {};

/**
 * specifies the name of a CSS class that will be applied to items of the X-Axis
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_scalex_class = function(date) {};

/**
 * specifies the name of a CSS class that will be applied to items of the second X-Axis
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_second_scalex_class = function(date) {};

/**
 * specifies the name of a CSS class that will be applied to items of the Y-Axis
 * @param {string} key the section's id
 * @param {string} label the section's label
 * @param {?} section the section object that contains the 'key' and 'label' properties
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_scaley_class = function(key, label, section) {};

/**
 * specifies items of the Y-Axis
 * @param {string} key the section's id (key)
 * @param {string} label the section's label
 * @param {?} section the section object containing the 'key' and 'label' properties
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_scale_label = function(key, label, section) {};

/**
 * specifies the tooltip over a day cell containing some scheduled event(s)
 * @param {!Date} start the date when an event is scheduled to begin
 * @param {!Date} end the date when an event is scheduled to be completed
 * @param {?} event the event object
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_tooltip = function(start, end, event) {};

/**
 * specifies the date in the header of the view
 * @param {!Date} date1 the date when an event is scheduled to begin
 * @param {!Date} date2 the date when an event is scheduled to be completed
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_date = function(date1, date2) {};

/**
 * specifies items of the X-Axis
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_scale_date = function(date) {};

/**
 * specifies items of the second X-Axis
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.timeline_second_scale_date = function(date) {};

/**
 * specifies the date in the header of the view
 * @param {!Date} date the date which needs formatting
 * @return {string}
 */
SchedulerTemplates.prototype.units_date = function(date) {};

/**
 * specifies items of the X-Axis
 * @param {string} key the unit's id (key)
 * @param {string} label the unit's label
 * @param {?} unit the unit object containing the 'key' and 'label' properties
 * @return {string}
 */
SchedulerTemplates.prototype.units_scale_text = function(key, label, unit) {};
/**
 * @record
 * @struct
 */
function SchedulerConfigOptions() {}
 /** @type {string} */
SchedulerConfigOptions.prototype.active_link_view;
 /** @type {!Date} */
SchedulerConfigOptions.prototype.agenda_end;
 /** @type {!Date} */
SchedulerConfigOptions.prototype.agenda_start;
 /** @type {(string|boolean)} */
SchedulerConfigOptions.prototype.ajax_error;
 /** @type {(string|boolean)} */
SchedulerConfigOptions.prototype.all_timed;
 /** @type {string} */
SchedulerConfigOptions.prototype.api_date;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.auto_end_date;
 /** @type {!Array<?>} */
SchedulerConfigOptions.prototype.buttons_left;
 /** @type {!Array<?>} */
SchedulerConfigOptions.prototype.buttons_right;
 /** @type {number} */
SchedulerConfigOptions.prototype.cascade_event_count;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.cascade_event_display;
 /** @type {number} */
SchedulerConfigOptions.prototype.cascade_event_margin;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.check_limits;
 /** @type {number} */
SchedulerConfigOptions.prototype.collision_limit;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.container_autoresize;
 /** @type {string} */
SchedulerConfigOptions.prototype.day_date;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.dblclick_create;
 /** @type {string} */
SchedulerConfigOptions.prototype.default_date;
 /** @type {number} */
SchedulerConfigOptions.prototype.delay_render;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.details_on_create;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.details_on_dblclick;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.display_marked_timespans;
 /** @type {string} */
SchedulerConfigOptions.prototype.displayed_event_color;
 /** @type {string} */
SchedulerConfigOptions.prototype.displayed_event_text_color;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.drag_create;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.drag_highlight;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.drag_in;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.drag_lightbox;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.drag_move;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.drag_out;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.drag_resize;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.edit_on_create;
 /** @type {number} */
SchedulerConfigOptions.prototype.event_duration;
 /** @type {number} */
SchedulerConfigOptions.prototype.first_hour;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.fix_tab_position;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.full_day;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.highlight_displayed_event;
 /** @type {string} */
SchedulerConfigOptions.prototype.hour_date;
 /** @type {number} */
SchedulerConfigOptions.prototype.hour_size_px;
 /** @type {!Array<?>} */
SchedulerConfigOptions.prototype.icons_edit;
 /** @type {!Array<?>} */
SchedulerConfigOptions.prototype.icons_select;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.include_end_by;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.key_nav;
 /** @type {number} */
SchedulerConfigOptions.prototype.last_hour;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.left_border;
 /** @type {?} */
SchedulerConfigOptions.prototype.lightbox;
 /** @type {string} */
SchedulerConfigOptions.prototype.lightbox_recurring;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.limit_drag_out;
 /** @type {!Date} */
SchedulerConfigOptions.prototype.limit_end;
 /** @type {!Date} */
SchedulerConfigOptions.prototype.limit_start;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.limit_time_select;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.limit_view;
 /** @type {string} */
SchedulerConfigOptions.prototype.load_date;
 /** @type {!Date} */
SchedulerConfigOptions.prototype.map_end;
 /** @type {?} */
SchedulerConfigOptions.prototype.map_error_position;
 /** @type {number} */
SchedulerConfigOptions.prototype.map_infowindow_max_width;
 /** @type {?} */
SchedulerConfigOptions.prototype.map_initial_position;
 /** @type {number} */
SchedulerConfigOptions.prototype.map_initial_zoom;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.map_resolve_event_location;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.map_resolve_user_location;
 /** @type {!Date} */
SchedulerConfigOptions.prototype.map_start;
 /** @type {?} */
SchedulerConfigOptions.prototype.map_type;
 /** @type {number} */
SchedulerConfigOptions.prototype.map_zoom_after_resolve;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.mark_now;
 /** @type {number} */
SchedulerConfigOptions.prototype.max_month_events;
 /** @type {?} */
SchedulerConfigOptions.prototype.minicalendar;
 /** @type {string} */
SchedulerConfigOptions.prototype.month_date;
 /** @type {string} */
SchedulerConfigOptions.prototype.month_day;
 /** @type {number} */
SchedulerConfigOptions.prototype.month_day_min_height;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.multi_day;
 /** @type {(number|boolean)} */
SchedulerConfigOptions.prototype.multi_day_height_limit;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.multisection;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.multisection_shift_all;
 /** @type {!Date} */
SchedulerConfigOptions.prototype.now_date;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.occurrence_timestamp_in_utc;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.positive_closing;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.preserve_length;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.preserve_scroll;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.prevent_cache;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.quick_info_detached;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.readonly;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.readonly_form;
 /** @type {!Array<?>} */
SchedulerConfigOptions.prototype.recurring_workdays;
 /** @type {string} */
SchedulerConfigOptions.prototype.repeat_date;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.repeat_precise;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.resize_month_events;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.resize_month_timed;
 /** @type {number} */
SchedulerConfigOptions.prototype.scroll_hour;
 /** @type {string} */
SchedulerConfigOptions.prototype.section_delemiter;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.select;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.separate_short_events;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.server_utc;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.show_loading;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.show_quick_info;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.start_on_monday;
 /** @type {number} */
SchedulerConfigOptions.prototype.time_step;
 /** @type {(string|boolean)} */
SchedulerConfigOptions.prototype.touch;
 /** @type {(number|boolean)} */
SchedulerConfigOptions.prototype.touch_drag;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.touch_tip;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.touch_tooltip;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.update_render;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.use_select_menu_space;
 /** @type {string} */
SchedulerConfigOptions.prototype.week_date;
 /** @type {boolean} */
SchedulerConfigOptions.prototype.wide_form;
 /** @type {string} */
SchedulerConfigOptions.prototype.xml_date;
 /** @type {number} */
SchedulerConfigOptions.prototype.year_x;
 /** @type {number} */
SchedulerConfigOptions.prototype.year_y;
/**
 * @record
 * @struct
 */
function SchedulerDateHelpers() {}

/**
 * @param {!Date} origin
 * @param {number} count
 * @param {string} unit
 * @return {!Date}
 */
SchedulerDateHelpers.prototype.add = function(origin, count, unit) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
SchedulerDateHelpers.prototype.copy = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
SchedulerDateHelpers.prototype.date_part = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
SchedulerDateHelpers.prototype.time_part = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
SchedulerDateHelpers.prototype.day_start = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
SchedulerDateHelpers.prototype.month_start = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
SchedulerDateHelpers.prototype.week_start = function(origin) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
SchedulerDateHelpers.prototype.year_start = function(origin) {};

/**
 * @param {!Date} origin
 * @return {number}
 */
SchedulerDateHelpers.prototype.getISOWeek = function(origin) {};

/**
 * @param {!Date} origin
 * @return {number}
 */
SchedulerDateHelpers.prototype.getUTCISOWeek = function(origin) {};

/**
 * @param {string} format
 * @return {?}
 */
SchedulerDateHelpers.prototype.date_to_str = function(format) {};

/**
 * @param {string} format
 * @return {?}
 */
SchedulerDateHelpers.prototype.str_to_date = function(format) {};

/**
 * @param {!Date} origin
 * @return {!Date}
 */
SchedulerDateHelpers.prototype.convert_to_utc = function(origin) {};

/**
 * @param {number} value
 * @return {string}
 */
SchedulerDateHelpers.prototype.to_fixed = function(value) {};
/**
 * @record
 * @struct
 */
function SchedulerHotkeys() {}
 /** @type {number} */
SchedulerHotkeys.prototype.edit_save;
 /** @type {number} */
SchedulerHotkeys.prototype.edit_cancel;
/**
 * @record
 * @struct
 */
function SchedulerLocaleDate() {}
 /** @type {!Array<string>} */
SchedulerLocaleDate.prototype.month_full;
 /** @type {!Array<string>} */
SchedulerLocaleDate.prototype.month_short;
 /** @type {!Array<string>} */
SchedulerLocaleDate.prototype.day_full;
 /** @type {!Array<string>} */
SchedulerLocaleDate.prototype.day_short;
/**
 * @record
 * @struct
 */
function SchedulerLocaleLabels() {}
 /** @type {string} */
SchedulerLocaleLabels.prototype.dhx_cal_today_button;
 /** @type {string} */
SchedulerLocaleLabels.prototype.day_tab;
 /** @type {string} */
SchedulerLocaleLabels.prototype.week_tab;
 /** @type {string} */
SchedulerLocaleLabels.prototype.month_tab;
 /** @type {string} */
SchedulerLocaleLabels.prototype.new_event;
 /** @type {string} */
SchedulerLocaleLabels.prototype.icon_save;
 /** @type {string} */
SchedulerLocaleLabels.prototype.icon_cancel;
 /** @type {string} */
SchedulerLocaleLabels.prototype.icon_details;
 /** @type {string} */
SchedulerLocaleLabels.prototype.icon_edit;
 /** @type {string} */
SchedulerLocaleLabels.prototype.icon_delete;
 /** @type {string} */
SchedulerLocaleLabels.prototype.confirm_closing;
 /** @type {string} */
SchedulerLocaleLabels.prototype.confirm_deleting;
 /** @type {string} */
SchedulerLocaleLabels.prototype.section_description;
 /** @type {string} */
SchedulerLocaleLabels.prototype.section_time;
 /** @type {string} */
SchedulerLocaleLabels.prototype.unit_tab;
/**
 * @record
 * @struct
 */
function SchedulerLocale() {}
 /** @type {!SchedulerLocaleDate} */
SchedulerLocale.prototype.date;
 /** @type {!SchedulerLocaleLabels} */
SchedulerLocale.prototype.labels;
/**
 * @record
 * @struct
 */
function SchedulerSizes() {}
 /** @type {number} */
SchedulerSizes.prototype.bar_height;
 /** @type {number} */
SchedulerSizes.prototype.editor_width;
 /** @type {number} */
SchedulerSizes.prototype.lightbox_additional_height;
 /** @type {number} */
SchedulerSizes.prototype.map_date_width;
 /** @type {number} */
SchedulerSizes.prototype.map_description_width;
 /** @type {number} */
SchedulerSizes.prototype.margin_left;
 /** @type {number} */
SchedulerSizes.prototype.margin_top;
 /** @type {number} */
SchedulerSizes.prototype.menu_width;
 /** @type {number} */
SchedulerSizes.prototype.min_event_height;
 /** @type {number} */
SchedulerSizes.prototype.month_scale_height;
 /** @type {number} */
SchedulerSizes.prototype.nav_height;
 /** @type {number} */
SchedulerSizes.prototype.scale_height;
 /** @type {number} */
SchedulerSizes.prototype.scale_width;
 /** @type {number} */
SchedulerSizes.prototype.scroll_width;
/**
 * @record
 * @struct
 */
function SchedulerEnterprise() {}

/**
 * Creates a new instance of Scheduler
 * @return {!SchedulerStatic}
 */
SchedulerEnterprise.prototype.getSchedulerInstance = function() {};
/**
 * @record
 * @struct
 */
function SchedulerStatic() {}
 /** @type {!SchedulerTemplates} */
SchedulerStatic.prototype.templates;
 /** @type {!SchedulerConfigOptions} */
SchedulerStatic.prototype.config;
 /** @type {!SchedulerDateHelpers} */
SchedulerStatic.prototype.date;
 /** @type {!SchedulerHotkeys} */
SchedulerStatic.prototype.keys;
 /** @type {!String} */
SchedulerStatic.prototype.skin;
 /** @type {!String} */
SchedulerStatic.prototype.version;
 /** @type {!SchedulerSizes} */
SchedulerStatic.prototype.xy;
 /** @type {!SchedulerLocale} */
SchedulerStatic.prototype.locale;
 /** @type {!SchedulerFilterCallback} */
SchedulerStatic.prototype.filter_day;
 /** @type {!SchedulerFilterCallback} */
SchedulerStatic.prototype.filter_week;
 /** @type {!SchedulerFilterCallback} */
SchedulerStatic.prototype.filter_month;
 /** @type {!SchedulerFilterCallback} */
SchedulerStatic.prototype.filter_year;
 /** @type {!SchedulerFilterCallback} */
SchedulerStatic.prototype.filter_agenda;
 /** @type {!SchedulerFilterCallback} */
SchedulerStatic.prototype.filter_timeline;
 /** @type {!SchedulerFilterCallback} */
SchedulerStatic.prototype.filter_units;
 /** @type {!SchedulerFilterCallback} */
SchedulerStatic.prototype.filter_grid;

/**
 * removes all blocking sets from the scheduler
 * removes marking/blocking set by the addMarkedTimespan() and blockTime() methods
 * removes marking/blocking set by the addMarkedTimespan() and blockTime() methods
 * @param {?|string=} config_or_id the timespan's id
 * @return {?|void}
 */
SchedulerStatic.prototype.deleteMarkedTimespan = function(config_or_id) {};

/**
 * adds a new event
 * @param {?} event the event object
 * @return {string}
 */
SchedulerStatic.prototype.addEvent = function(event) {};

/**
 * adds a new event and opens the lightbox to confirm
 * @param {?} event the event object
 * @return {string}
 */
SchedulerStatic.prototype.addEventNow = function(event) {};

/**
 * marks dates, but with certain settings makes blocking (unlike blockTime() allows setting custom styling for the limit)
 * @param {?} config the configuration object of the timespan to mark/block
 * @return {number}
 */
SchedulerStatic.prototype.addMarkedTimespan = function(config) {};

/**
 * adds a section to the currently active view (if the opened view isn't Timeline in the 'Tree' mode - the method will be ignored)
 * @param {?} section the object of the section to add
 * @param {string} parent_id the id of the parent section. Pass 'null' if you are adding a section to the root
 * @return {boolean}
 */
SchedulerStatic.prototype.addSection = function(section, parent_id) {};

/**
 * attaches the handler to an inner event of dhtmlxScheduler
 * @param {string} name the event's name, case-insensitive
 * @param {!SchedulerCallback} handler the handler function
 * @return {string}
 */
SchedulerStatic.prototype.attachEvent = function(name, handler) {};

/**
 * makes the scheduler reflect all data changes in the Backbone model and vice versa
 * @param {?} events the Backbone data collection
 * @return {void}
 */
SchedulerStatic.prototype.backbone = function(events) {};

/**
 * blocks the specified date and applies the default 'dimmed' style to it.
 * @param {(number|!Date)} date a date to block ( if a number is provided, the parameter will be treated as a week <br> day: '0' index refers to Sunday,'6' - to Saturday )
 * @param {!Array<?>} time_points an array <b>[start_minute,end_minute,..,start_minute_N,end_minute_N]</b>, <br> where each pair sets a certain limit range. The array can have any number of <br> such pairs
 * @param {?=} items defines specific items of  view(s) to block
 * @return {void}
 */
SchedulerStatic.prototype.blockTime = function(date, time_points, items) {};

/**
 * calls an inner event
 * @param {string} name the event's name, case-insensitive
 * @param {!Array<?>} params an array of the event-related data
 * @return {boolean}
 */
SchedulerStatic.prototype.callEvent = function(name, params) {};

/**
 * changes the event's id
 * @param {string} id the current event's id
 * @param {string} new_id the new event's id
 * @return {void}
 */
SchedulerStatic.prototype.changeEventId = function(id, new_id) {};

/**
 * checks whether the specified event occurs at the time that has already been occupied by another event(s)
 * @param {?} event the event object
 * @return {boolean}
 */
SchedulerStatic.prototype.checkCollision = function(event) {};

/**
 * checks whether an event has some handler(s) specified
 * @param {string} name the event's name
 * @return {boolean}
 */
SchedulerStatic.prototype.checkEvent = function(name) {};

/**
 * checks whether an event resides in a timespan of a specific type
 * @param {?} event the event object
 * @param {string} timespan the timespan's type
 * @return {boolean}
 */
SchedulerStatic.prototype.checkInMarkedTimespan = function(event, timespan) {};

/**
 * checks whether the specified event takes place at the blocked time period
 * @param {?} event the event object
 * @return {boolean}
 */
SchedulerStatic.prototype.checkLimitViolation = function(event) {};

/**
 * removes all events from the scheduler
 * @return {void}
 */
SchedulerStatic.prototype.clearAll = function() {};

/**
 * closes all sections in the currently active view (if the opened view isn't Timeline in the 'Tree' mode - the method will be ignored)
 * @return {void}
 */
SchedulerStatic.prototype.closeAllSections = function() {};

/**
 * closes the specified section in the currently active view (if the opened view isn't Timeline in the 'Tree' mode - the method will be ignored)
 * @param {string} section_id the section's id
 * @return {void}
 */
SchedulerStatic.prototype.closeSection = function(section_id) {};

/**
 * collapses the expanded scheduler back to the normal size
 * @return {void}
 */
SchedulerStatic.prototype.collapse = function() {};

/**
 * creates the Grid view in the scheduler
 * @param {?} config the configuration object of the Grid view
 * @return {void}
 */
SchedulerStatic.prototype.createGridView = function(config) {};

/**
 * creates the Timeline view in the scheduler
 * @param {?} config the configuration object of the Timeline view
 * @return {void}
 */
SchedulerStatic.prototype.createTimelineView = function(config) {};

/**
 * creates the Units view in the scheduler
 * @param {?} config the configuration object of the Units view
 * @return {void}
 */
SchedulerStatic.prototype.createUnitsView = function(config) {};

/**
 * deletes all sections from  the currently active view (if the opened view isn't Timeline in the 'Tree' mode - the method will be ignored)
 * @return {void}
 */
SchedulerStatic.prototype.deleteAllSections = function() {};

/**
 * deletes the specified event
 * @param {(string|number)} id the event's id
 * @return {void}
 */
SchedulerStatic.prototype.deleteEvent = function(id) {};

/**
 * deletes a section from  the currently active view (if the opened view isn't Timeline in the 'Tree' mode - the method will be ignored)
 * @param {string} section_id the section's id
 * @return {boolean}
 */
SchedulerStatic.prototype.deleteSection = function(section_id) {};

/**
 * destroys previously created mini-calendar
 * @param {?=} name the mini-calendar's object (if not specified, the scheduler attempts <br> to destroy the last created mini calendar)
 * @return {void}
 */
SchedulerStatic.prototype.destroyCalendar = function(name) {};

/**
 * detaches a handler from an event (which was attached before by the attachEvent method)
 * @param {string} id the event's id
 * @return {void}
 */
SchedulerStatic.prototype.detachEvent = function(id) {};

/**
 * opens the inline editor to alter the event's text  (the editor in the event's box)
 * @param {string} id the event's id
 * @return {void}
 */
SchedulerStatic.prototype.edit = function(id) {};

/**
 * closes the inline event editor, if it's currently open
 * @param {string} id the event's id
 * @return {void}
 */
SchedulerStatic.prototype.editStop = function(id) {};

/**
 * closes the lightbox
 * @param {boolean} mode if set to <i>true</i>, the changes, made in the lightbox, will be saved before closing. <br> If - <i>false</i>, the changes will be cancelled.
 * @param {!HTMLElement=} box the HTML container for the lightbox
 * @return {void}
 */
SchedulerStatic.prototype.endLightbox = function(mode, box) {};

/**
 * expands the scheduler to the full screen view
 * @return {void}
 */
SchedulerStatic.prototype.expand = function() {};

/**
 * gives access to the objects of lightbox's sections
 * @param {string} name the name of a lightbox section
 * @return {?}
 */
SchedulerStatic.prototype.formSection = function(name) {};

/**
 * returns the current cursor-pointed date and section (if defined)
 * @param {!Event} e a native event object
 * @return {?}
 */
SchedulerStatic.prototype.getActionData = function(e) {};

/**
 * returns the event object by its id
 * @param {(string|number)} event_id the  event's id
 * @return {?}
 */
SchedulerStatic.prototype.getEvent = function(event_id) {};

/**
 * gets the event's end date
 * @param {(string|number)} id the event's id
 * @return {!Date}
 */
SchedulerStatic.prototype.getEventEndDate = function(id) {};

/**
 * gets the event's start date
 * @param {(string|number)} id the event's id
 * @return {!Date}
 */
SchedulerStatic.prototype.getEventStartDate = function(id) {};

/**
 * gets the event's text
 * @param {(string|number)} id the event's id
 * @return {string}
 */
SchedulerStatic.prototype.getEventText = function(id) {};

/**
 * returns a collection of events which occur during the specified period
 * @param {!Date=} from the start date of the period
 * @param {!Date=} to the end date of the period
 * @return {?}
 */
SchedulerStatic.prototype.getEvents = function(from, to) {};

/**
 * gets the label of a select control in the lightbox
 * @param {string} property the name of a data property that the control is mapped to
 * @param {(string|number)} key the option's id. This parameter is compared with the event's data property <br> to assign the select's option to an event
 * @return {?}
 */
SchedulerStatic.prototype.getLabel = function(property, key) {};

/**
 * gets the lightbox's HTML object element
 * @return {!HTMLElement}
 */
SchedulerStatic.prototype.getLightbox = function() {};

/**
 * returns all occurrences of a recurring event
 * @param {string} id the id of a recurring event
 * @param {number} number the maximum number of occurrences to return (by default, 100)
 * @return {?}
 */
SchedulerStatic.prototype.getRecDates = function(id, number) {};

/**
 * gets the object of the currently displayed event
 * @param {string} id the event's id
 * @return {!HTMLElement}
 */
SchedulerStatic.prototype.getRenderedEvent = function(id) {};

/**
 * gets the object of the specified section in the currently active view (if the opened view isn't Timeline in the 'Tree' mode - the method will be ignored)
 * @param {string} section_id the section's id
 * @return {?}
 */
SchedulerStatic.prototype.getSection = function(section_id) {};

/**
 * gets the current state of the scheduler
 * @return {?}
 */
SchedulerStatic.prototype.getState = function() {};

/**
 * gets the user data associated with the specified event
 * @param {string} id the event's id
 * @param {string} name the user data name
 * @return {?}
 */
SchedulerStatic.prototype.getUserData = function(id, name) {};

/**
 * hides the lightbox modal overlay that blocks interactions with the remaining screen
 * @param {!HTMLElement=} box an element to hide
 * @return {void}
 */
SchedulerStatic.prototype.hideCover = function(box) {};

/**
 * hides the pop-up event form (if it's currently active)
 * @return {void}
 */
SchedulerStatic.prototype.hideQuickInfo = function() {};

/**
 * highlights the event's duration on the time scale
 * @param {?} event the event object
 * @return {void}
 */
SchedulerStatic.prototype.highlightEventPosition = function(event) {};

/**
 * constructor. Initializes a dhtmlxScheduler object
 * @param {(string|!HTMLElement)} container an HTML container ( or its id) where a dhtmlxScheduler object will be initialized
 * @param {!Date=} date the initial date of the scheduler (by default, the current date)
 * @param {string=} view the name of the initial view (by default, "week")
 * @return {void}
 */
SchedulerStatic.prototype.init = function(container, date, view) {};

/**
 * inverts the specified time zones
 * @param {!Array<?>} zones an array **[start_minute,end_minute,..,start_minute_N,end_minute_N]** <br >where each pair sets a certain limit range (in minutes). The array can have any <br> number of such pairs
 * @return {void}
 */
SchedulerStatic.prototype.invertZones = function(zones) {};

/**
 * checks whether the calendar is currently opened in the scheduler
 * @return {(boolean|!HTMLElement)}
 */
SchedulerStatic.prototype.isCalendarVisible = function() {};

/**
 * checks whether the specified event one-day or multi-day
 * @param {?} event the event object
 * @return {boolean}
 */
SchedulerStatic.prototype.isOneDayEvent = function(event) {};

/**
 * checks whether a view with the specified name exists
 * @param {string} name the view name
 * @return {boolean}
 */
SchedulerStatic.prototype.isViewExists = function(name) {};

/**
 * 'says' to change the active date in the mini calendar each time, the active date in the scheduler is changed
 * @param {?} calendar the mini calendar object
 * @param {!SchedulerCallback} shift a function that defines the difference between active dates in the mini-calendar <br> and the scheduler. The function takes the scheduler's date as a parameter and <br> returns the date that should be displayed in the mini calendar
 * @return {void}
 */
SchedulerStatic.prototype.linkCalendar = function(calendar, shift) {};

/**
 * loads data to the scheduler from an external data source
 * @param {string} url the server side url (may be a static file or a server side script which outputs data <br>  as XML)
 * @param {string=} type <i>('json', 'xml', 'ical')</i> the data type. The default value - <i>'xml'</i>
 * @param {!SchedulerCallback=} callback the callback function
 * @return {void}
 */
SchedulerStatic.prototype.load = function(url, type, callback) {};

/**
 * applies a css class to the specified date
 * @param {?} calendar the calendar object
 * @param {!Date} date the date to mark
 * @param {string} css the name of a css class
 * @return {void}
 */
SchedulerStatic.prototype.markCalendar = function(calendar, date, css) {};

/**
 * marks and/or blocks date(s) by applying the default or a custom style to them. Marking is cancelled right after any internal update in the app. Can be used for highlighting
 * @param {?} config the configuration object of the timespan to mark/block
 * @return {void}
 */
SchedulerStatic.prototype.markTimespan = function(config) {};

/**
 * opens all sections in the currently active view (if the opened view isn't Timeline in the 'Tree' mode - the method will be ignored)
 * @return {void}
 */
SchedulerStatic.prototype.openAllSections = function() {};

/**
 * opens the specified section in the currently active view (if the opened view isn't Timeline in the 'Tree' mode - the method will be ignored)
 * @param {string} section_id the section's id
 * @return {void}
 */
SchedulerStatic.prototype.openSection = function(section_id) {};

/**
 * loads data from a client-side resource
 * @param {?} data a string or object which represents data
 * @param {string=} type (<i>'json', 'xml', 'ical'</i>) the data type. The default value - <i>'xml'</i>
 * @return {void}
 */
SchedulerStatic.prototype.parse = function(data, type) {};

/**
 * creates a mini calendar
 * @param {?} config the calendar configuration object
 * @return {void}
 */
SchedulerStatic.prototype.renderCalendar = function(config) {};

/**
 * generates HTML content for a custom event's box
 * @param {!HTMLElement} container the event container
 * @param {?} event the event object
 * @return {boolean}
 */
SchedulerStatic.prototype.renderEvent = function(container, event) {};

/**
 * removes the current lightbox's HTML object element
 * @return {void}
 */
SchedulerStatic.prototype.resetLightbox = function() {};

/**
 * scrolls the specified number of units in the Units view
 * @param {number} step the number of units to scroll (<i>set the positive value to scroll units to the right <br> side,  the negative value - to the left side</i>).
 * @return {void}
 */
SchedulerStatic.prototype.scrollUnit = function(step) {};

/**
 * selects the specified event
 * @param {string} id the event's id
 * @return {void}
 */
SchedulerStatic.prototype.select = function(id) {};

/**
 * returns a list of options
 * @param {string} list_name the name of a list
 * @param {!Array<?>=} options an array of options
 * @return {void}
 */
SchedulerStatic.prototype.serverList = function(list_name, options) {};

/**
 * displays the specified view and date
 * @param {!Date=} date the date to display
 * @param {string=} view the name of a view to display
 * @return {void}
 */
SchedulerStatic.prototype.setCurrentView = function(date, view) {};

/**
 * adds a new event to the scheduler's data pool
 * @param {(string|number)} id the event's id
 * @param {?} event the event object
 * @return {void}
 */
SchedulerStatic.prototype.setEvent = function(id, event) {};

/**
 * sets the event's end date
 * @param {string} id the event's id
 * @param {!Date} date the new end date of the event
 * @return {void}
 */
SchedulerStatic.prototype.setEventEndDate = function(id, date) {};

/**
 * sets the event's start date
 * @param {string} id the event's id
 * @param {!Date} date the new start date of the event
 * @return {void}
 */
SchedulerStatic.prototype.setEventStartDate = function(id, date) {};

/**
 * sets the event's text
 * @param {string} id the event's id
 * @param {string} text the new text of the event
 * @return {void}
 */
SchedulerStatic.prototype.setEventText = function(id, text) {};

/**
 * forces the lightbox to resize
 * @return {void}
 */
SchedulerStatic.prototype.setLightboxSize = function() {};

/**
 * sets the mode that allows loading data by parts (enables the dynamic loading)
 * @param {string} mode the loading mode
 * @return {void}
 */
SchedulerStatic.prototype.setLoadMode = function(mode) {};

/**
 * sets the user data associated with the specified event
 * @param {string} id the event's id
 * @param {string} name the user data name
 * @param {?} value the user data value
 * @return {void}
 */
SchedulerStatic.prototype.setUserData = function(id, name, value) {};

/**
 * shows the lightbox modal overlay that blocks interactions with the remaining screen
 * @param {!HTMLElement=} box an element to hide
 * @return {void}
 */
SchedulerStatic.prototype.showCover = function(box) {};

/**
 * shows and highlights the specified event in the current or specified view
 * @param {string} id the event's id
 * @param {string=} view the view name
 * @return {void}
 */
SchedulerStatic.prototype.showEvent = function(id, view) {};

/**
 * opens the lightbox for the specified event
 * @param {string} id the event's id
 * @return {void}
 */
SchedulerStatic.prototype.showLightbox = function(id) {};

/**
 * displays the pop-up event form for the specified event
 * @param {string} id the event's id
 * @return {void}
 */
SchedulerStatic.prototype.showQuickInfo = function(id) {};

/**
 * shows a custom lightbox in the specified HTML container centered on the screen
 * @param {string} id the event's id
 * @param {!HTMLElement} box the lightbox's HTML container
 * @return {void}
 */
SchedulerStatic.prototype.startLightbox = function(id, box) {};

/**
 * converts scheduler's data to the ICal format
 * @param {string=} header sets the value for the content's header field
 * @return {string}
 */
SchedulerStatic.prototype.toICal = function(header) {};

/**
 * converts scheduler's data into the JSON format
 * @return {string}
 */
SchedulerStatic.prototype.toJSON = function() {};

/**
 * exports the  current view to a PDF document (can be used for printing)
 * @param {string} url the path to the server-side PDF converter
 * @param {string=} mode the color map of the resulting PDF document
 * @return {void}
 */
SchedulerStatic.prototype.toPDF = function(url, mode) {};

/**
 * exports several scheduler's views to a PDF document (can be used for printing)
 * @param {!Date} from the date to start export events from
 * @param {!Date} to the date to export events until
 * @param {string} view the name of a view that the export should be applied to
 * @param {string} path the path to the php file which generates a PDF file (<a href="pdf.md#configuringservice">details</a>)
 * @param {string} color the color map in use
 * @return {void}
 */
SchedulerStatic.prototype.toPDFRange = function(from, to, view, path, color) {};

/**
 * converts scheduler's data into the XML format
 * @return {string}
 */
SchedulerStatic.prototype.toXML = function() {};

/**
 * generates a unique ID (unique inside the current scheduler, not GUID)
 * @return {void}
 */
SchedulerStatic.prototype.uid = function() {};

/**
 * removes blocking set by the blockTime() method
 * @param {?} days (<i>Date, number,array, string</i>) days that should be limited
 * @param {!Array<?>=} zones the period in minutes that should be limited. Can be set to 'fullday' value <br> to limit the entire day
 * @param {?=} sections allows blocking date(s) just for specific items of specific views. BTW, the specified date(s) will be blocked just in the related view(s)
 * @return {void}
 */
SchedulerStatic.prototype.unblockTime = function(days, zones, sections) {};

/**
 * removes a css class from the specified date
 * @param {?} calendar the mini calendar object
 * @param {!Date} date the date to unmark
 * @param {string} css the name of a css class to remove
 * @return {void}
 */
SchedulerStatic.prototype.unmarkCalendar = function(calendar, date, css) {};

/**
 * removes marking/blocking set by the markTimespan() method
 * @param {(!Array<?>|!HTMLElement)} divs a timespan to remove marking/blocking from (or an array of timespans)
 * @return {void}
 */
SchedulerStatic.prototype.unmarkTimespan = function(divs) {};

/**
 * unselects the specified event
 * @param {string=} id the event's id (if not specified, the currently selected event will be unselected)
 * @return {void}
 */
SchedulerStatic.prototype.unselect = function(id) {};

/**
 * displays the specified date in the mini calendar
 * @param {?} calendar the mini calendar object
 * @param {!Date} new_date a new date to display in the mini calendar
 * @return {void}
 */
SchedulerStatic.prototype.updateCalendar = function(calendar, new_date) {};

/**
 * updates the specified collection with new options
 * @param {string} collection the name of the collection to update
 * @param {!Array<?>} options the new values of the collection
 * @return {boolean}
 */
SchedulerStatic.prototype.updateCollection = function(collection, options) {};

/**
 * updates the specified event
 * @param {string} id the event's id
 * @return {void}
 */
SchedulerStatic.prototype.updateEvent = function(id) {};

/**
 * displays the specified view and date (doesn't invoke any events)
 * the function will just refresh the current view if invoked without parameters.
 * @param {!Date=} date the date to set
 * @param {string=} view the view name
 * @return {void}
 */
SchedulerStatic.prototype.updateView = function(date, view) {};
 /** @type {!SchedulerStatic} */
var scheduler;
 /** @type {!SchedulerEnterprise} */
var Scheduler;
