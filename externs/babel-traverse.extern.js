/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/babel-traverse/index.d.ts:

/* TODO: ImportDeclaration in  */

/** @typedef {?} */
var Node;

/**
 * @param {(?|!Array<?>)} parent
 * @param {?=} opts
 * @param {?=} scope
 * @param {?=} state
 * @param {?=} parentPath
 * @return {void}
 */
function traverse(parent, opts, scope, state, parentPath) {}
/**
 * @extends {Visitor}
 * @record
 * @struct
 */
function TraverseOptions() {}
 /** @type {?} */
TraverseOptions.prototype.scope;
 /** @type {boolean} */
TraverseOptions.prototype.noScope;

/**
 * @constructor
 * @struct
 * @param {?} path
 * @param {?=} parentScope
 */
function Scope(path, parentScope) {}
 /** @type {?} */
Scope.prototype.path;
 /** @type {?} */
Scope.prototype.block;
 /** @type {?} */
Scope.prototype.parentBlock;
 /** @type {?} */
Scope.prototype.parent;
 /** @type {?} */
Scope.prototype.hub;
 /** @type {?} */
Scope.prototype.bindings;

/**
 * Traverse node with current scope and path.
 * @param {(?|!Array<?>)} node
 * @param {?=} opts
 * @param {?=} state
 * @return {void}
 */
Scope.prototype.traverse = function(node, opts, state) {};

/**
 * Generate a unique identifier and add it to the current scope.
 * @param {string=} name
 * @return {?}
 */
Scope.prototype.generateDeclaredUidIdentifier = function(name) {};

/**
 * Generate a unique identifier.
 * @param {string=} name
 * @return {?}
 */
Scope.prototype.generateUidIdentifier = function(name) {};

/**
 * Generate a unique `_id1` binding.
 * @param {string=} name
 * @return {string}
 */
Scope.prototype.generateUid = function(name) {};

/**
 * Generate a unique identifier based on a node.
 * @param {?} parent
 * @param {string=} defaultName
 * @return {?}
 */
Scope.prototype.generateUidIdentifierBasedOnNode = function(parent, defaultName) {};

/**
 * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
 * evaluating it wont result in potentially arbitrary code from being ran. The following are
 * whitelisted and determined not to cause side effects:
 * 
 *  - `this` expressions
 *  - `super` expressions
 *  - Bound identifiers
 * @param {?} node
 * @return {boolean}
 */
Scope.prototype.isStatic = function(node) {};

/**
 * Possibly generate a memoised identifier if it is not static and has consequences.
 * @param {?} node
 * @param {boolean=} dontPush
 * @return {?}
 */
Scope.prototype.maybeGenerateMemoised = function(node, dontPush) {};

/**
 * @param {?} local
 * @param {string} kind
 * @param {string} name
 * @param {!Object} id
 * @return {void}
 */
Scope.prototype.checkBlockScopedCollisions = function(local, kind, name, id) {};

/**
 * @param {string} oldName
 * @param {string=} newName
 * @param {?=} block
 * @return {void}
 */
Scope.prototype.rename = function(oldName, newName, block) {};

/**
 * @return {void}
 */
Scope.prototype.dump = function() {};

/**
 * @param {?} node
 * @param {number=} i
 * @return {?}
 */
Scope.prototype.toArray = function(node, i) {};

/**
 * @param {?} path
 * @return {void}
 */
Scope.prototype.registerDeclaration = function(path) {};

/**
 * @return {?}
 */
Scope.prototype.buildUndefinedNode = function() {};

/**
 * @param {?} path
 * @return {void}
 */
Scope.prototype.registerConstantViolation = function(path) {};

/**
 * @param {string} kind
 * @param {?} path
 * @param {?=} bindingPath
 * @return {void}
 */
Scope.prototype.registerBinding = function(kind, path, bindingPath) {};

/**
 * @param {?} node
 * @return {void}
 */
Scope.prototype.addGlobal = function(node) {};

/**
 * @param {string} name
 * @return {boolean}
 */
Scope.prototype.hasUid = function(name) {};

/**
 * @param {string} name
 * @return {boolean}
 */
Scope.prototype.hasGlobal = function(name) {};

/**
 * @param {string} name
 * @return {boolean}
 */
Scope.prototype.hasReference = function(name) {};

/**
 * @param {?} node
 * @param {boolean=} constantsOnly
 * @return {boolean}
 */
Scope.prototype.isPure = function(node, constantsOnly) {};

/**
 * @param {string} key
 * @param {?} val
 * @return {?}
 */
Scope.prototype.setData = function(key, val) {};

/**
 * @param {string} key
 * @return {?}
 */
Scope.prototype.getData = function(key) {};

/**
 * @param {string} key
 * @return {void}
 */
Scope.prototype.removeData = function(key) {};

/**
 * @param {?} opts
 * @return {void}
 */
Scope.prototype.push = function(opts) {};

/**
 * @return {?}
 */
Scope.prototype.getProgramParent = function() {};

/**
 * @return {?}
 */
Scope.prototype.getFunctionParent = function() {};

/**
 * @return {?}
 */
Scope.prototype.getBlockParent = function() {};

/**
 * Walks the scope tree and gathers **all** bindings.
 * @param {...string} kinds
 * @return {!Object}
 */
Scope.prototype.getAllBindings = function(kinds) {};

/**
 * @param {string} name
 * @param {?} node
 * @return {boolean}
 */
Scope.prototype.bindingIdentifierEquals = function(name, node) {};

/**
 * @param {string} name
 * @return {?}
 */
Scope.prototype.getBinding = function(name) {};

/**
 * @param {string} name
 * @return {?}
 */
Scope.prototype.getOwnBinding = function(name) {};

/**
 * @param {string} name
 * @return {?}
 */
Scope.prototype.getBindingIdentifier = function(name) {};

/**
 * @param {string} name
 * @return {?}
 */
Scope.prototype.getOwnBindingIdentifier = function(name) {};

/**
 * @param {string} name
 * @return {boolean}
 */
Scope.prototype.hasOwnBinding = function(name) {};

/**
 * @param {string} name
 * @param {boolean=} noGlobals
 * @return {boolean}
 */
Scope.prototype.hasBinding = function(name, noGlobals) {};

/**
 * @param {string} name
 * @param {boolean=} noGlobals
 * @return {boolean}
 */
Scope.prototype.parentHasBinding = function(name, noGlobals) {};

/**
 * Move a binding of `name` to another `scope`.
 * @param {string} name
 * @param {?} scope
 * @return {void}
 */
Scope.prototype.moveBindingTo = function(name, scope) {};

/**
 * @param {string} name
 * @return {void}
 */
Scope.prototype.removeOwnBinding = function(name) {};

/**
 * @param {string} name
 * @return {void}
 */
Scope.prototype.removeBinding = function(name) {};

/**
 * @constructor
 * @struct
 * @param {?} opts
 */
function Binding(opts) {}
 /** @type {?} */
Binding.prototype.identifier;
 /** @type {?} */
Binding.prototype.scope;
 /** @type {?} */
Binding.prototype.path;
 /** @type {string} */
Binding.prototype.kind;
 /** @type {boolean} */
Binding.prototype.referenced;
 /** @type {number} */
Binding.prototype.references;
 /** @type {!Array<?>} */
Binding.prototype.referencePaths;
 /** @type {boolean} */
Binding.prototype.constant;
 /** @type {!Array<?>} */
Binding.prototype.constantViolations;
/**
 * @extends {VisitNodeObject}
 * @record
 * @struct
 */
function Visitor() {}
 /** @type {?} */
Visitor.prototype.ArrayExpression;
 /** @type {?} */
Visitor.prototype.AssignmentExpression;
 /** @type {?} */
Visitor.prototype.LVal;
 /** @type {?} */
Visitor.prototype.Expression;
 /** @type {?} */
Visitor.prototype.BinaryExpression;
 /** @type {?} */
Visitor.prototype.Directive;
 /** @type {?} */
Visitor.prototype.DirectiveLiteral;
 /** @type {?} */
Visitor.prototype.BlockStatement;
 /** @type {?} */
Visitor.prototype.BreakStatement;
 /** @type {?} */
Visitor.prototype.Identifier;
 /** @type {?} */
Visitor.prototype.CallExpression;
 /** @type {?} */
Visitor.prototype.CatchClause;
 /** @type {?} */
Visitor.prototype.ConditionalExpression;
 /** @type {?} */
Visitor.prototype.ContinueStatement;
 /** @type {?} */
Visitor.prototype.DebuggerStatement;
 /** @type {?} */
Visitor.prototype.DoWhileStatement;
 /** @type {?} */
Visitor.prototype.Statement;
 /** @type {?} */
Visitor.prototype.EmptyStatement;
 /** @type {?} */
Visitor.prototype.ExpressionStatement;
 /** @type {?} */
Visitor.prototype.File;
 /** @type {?} */
Visitor.prototype.Program;
 /** @type {?} */
Visitor.prototype.ForInStatement;
 /** @type {?} */
Visitor.prototype.VariableDeclaration;
 /** @type {?} */
Visitor.prototype.ForStatement;
 /** @type {?} */
Visitor.prototype.FunctionDeclaration;
 /** @type {?} */
Visitor.prototype.FunctionExpression;
 /** @type {?} */
Visitor.prototype.IfStatement;
 /** @type {?} */
Visitor.prototype.LabeledStatement;
 /** @type {?} */
Visitor.prototype.StringLiteral;
 /** @type {?} */
Visitor.prototype.NumericLiteral;
 /** @type {?} */
Visitor.prototype.NullLiteral;
 /** @type {?} */
Visitor.prototype.BooleanLiteral;
 /** @type {?} */
Visitor.prototype.RegExpLiteral;
 /** @type {?} */
Visitor.prototype.LogicalExpression;
 /** @type {?} */
Visitor.prototype.MemberExpression;
 /** @type {?} */
Visitor.prototype.NewExpression;
 /** @type {?} */
Visitor.prototype.ObjectExpression;
 /** @type {?} */
Visitor.prototype.ObjectMethod;
 /** @type {?} */
Visitor.prototype.ObjectProperty;
 /** @type {?} */
Visitor.prototype.RestElement;
 /** @type {?} */
Visitor.prototype.ReturnStatement;
 /** @type {?} */
Visitor.prototype.SequenceExpression;
 /** @type {?} */
Visitor.prototype.SwitchCase;
 /** @type {?} */
Visitor.prototype.SwitchStatement;
 /** @type {?} */
Visitor.prototype.ThisExpression;
 /** @type {?} */
Visitor.prototype.ThrowStatement;
 /** @type {?} */
Visitor.prototype.TryStatement;
 /** @type {?} */
Visitor.prototype.UnaryExpression;
 /** @type {?} */
Visitor.prototype.UpdateExpression;
 /** @type {?} */
Visitor.prototype.VariableDeclarator;
 /** @type {?} */
Visitor.prototype.WhileStatement;
 /** @type {?} */
Visitor.prototype.WithStatement;
 /** @type {?} */
Visitor.prototype.AssignmentPattern;
 /** @type {?} */
Visitor.prototype.ArrayPattern;
 /** @type {?} */
Visitor.prototype.ArrowFunctionExpression;
 /** @type {?} */
Visitor.prototype.ClassBody;
 /** @type {?} */
Visitor.prototype.ClassDeclaration;
 /** @type {?} */
Visitor.prototype.ClassExpression;
 /** @type {?} */
Visitor.prototype.ExportAllDeclaration;
 /** @type {?} */
Visitor.prototype.ExportDefaultDeclaration;
 /** @type {?} */
Visitor.prototype.ExportNamedDeclaration;
 /** @type {?} */
Visitor.prototype.Declaration;
 /** @type {?} */
Visitor.prototype.ExportSpecifier;
 /** @type {?} */
Visitor.prototype.ForOfStatement;
 /** @type {?} */
Visitor.prototype.ImportDeclaration;
 /** @type {?} */
Visitor.prototype.ImportDefaultSpecifier;
 /** @type {?} */
Visitor.prototype.ImportNamespaceSpecifier;
 /** @type {?} */
Visitor.prototype.ImportSpecifier;
 /** @type {?} */
Visitor.prototype.MetaProperty;
 /** @type {?} */
Visitor.prototype.ClassMethod;
 /** @type {?} */
Visitor.prototype.ObjectPattern;
 /** @type {?} */
Visitor.prototype.SpreadElement;
 /** @type {?} */
Visitor.prototype.Super;
 /** @type {?} */
Visitor.prototype.TaggedTemplateExpression;
 /** @type {?} */
Visitor.prototype.TemplateLiteral;
 /** @type {?} */
Visitor.prototype.TemplateElement;
 /** @type {?} */
Visitor.prototype.YieldExpression;
 /** @type {?} */
Visitor.prototype.AnyTypeAnnotation;
 /** @type {?} */
Visitor.prototype.ArrayTypeAnnotation;
 /** @type {?} */
Visitor.prototype.BooleanTypeAnnotation;
 /** @type {?} */
Visitor.prototype.BooleanLiteralTypeAnnotation;
 /** @type {?} */
Visitor.prototype.NullLiteralTypeAnnotation;
 /** @type {?} */
Visitor.prototype.ClassImplements;
 /** @type {?} */
Visitor.prototype.ClassProperty;
 /** @type {?} */
Visitor.prototype.DeclareClass;
 /** @type {?} */
Visitor.prototype.DeclareFunction;
 /** @type {?} */
Visitor.prototype.DeclareInterface;
 /** @type {?} */
Visitor.prototype.DeclareModule;
 /** @type {?} */
Visitor.prototype.DeclareTypeAlias;
 /** @type {?} */
Visitor.prototype.DeclareVariable;
 /** @type {?} */
Visitor.prototype.ExistentialTypeParam;
 /** @type {?} */
Visitor.prototype.FunctionTypeAnnotation;
 /** @type {?} */
Visitor.prototype.FunctionTypeParam;
 /** @type {?} */
Visitor.prototype.GenericTypeAnnotation;
 /** @type {?} */
Visitor.prototype.InterfaceExtends;
 /** @type {?} */
Visitor.prototype.InterfaceDeclaration;
 /** @type {?} */
Visitor.prototype.IntersectionTypeAnnotation;
 /** @type {?} */
Visitor.prototype.MixedTypeAnnotation;
 /** @type {?} */
Visitor.prototype.NullableTypeAnnotation;
 /** @type {?} */
Visitor.prototype.NumericLiteralTypeAnnotation;
 /** @type {?} */
Visitor.prototype.NumberTypeAnnotation;
 /** @type {?} */
Visitor.prototype.StringLiteralTypeAnnotation;
 /** @type {?} */
Visitor.prototype.StringTypeAnnotation;
 /** @type {?} */
Visitor.prototype.ThisTypeAnnotation;
 /** @type {?} */
Visitor.prototype.TupleTypeAnnotation;
 /** @type {?} */
Visitor.prototype.TypeofTypeAnnotation;
 /** @type {?} */
Visitor.prototype.TypeAlias;
 /** @type {?} */
Visitor.prototype.TypeAnnotation;
 /** @type {?} */
Visitor.prototype.TypeCastExpression;
 /** @type {?} */
Visitor.prototype.TypeParameterDeclaration;
 /** @type {?} */
Visitor.prototype.TypeParameterInstantiation;
 /** @type {?} */
Visitor.prototype.ObjectTypeAnnotation;
 /** @type {?} */
Visitor.prototype.ObjectTypeCallProperty;
 /** @type {?} */
Visitor.prototype.ObjectTypeIndexer;
 /** @type {?} */
Visitor.prototype.ObjectTypeProperty;
 /** @type {?} */
Visitor.prototype.QualifiedTypeIdentifier;
 /** @type {?} */
Visitor.prototype.UnionTypeAnnotation;
 /** @type {?} */
Visitor.prototype.VoidTypeAnnotation;
 /** @type {?} */
Visitor.prototype.JSXAttribute;
 /** @type {?} */
Visitor.prototype.JSXIdentifier;
 /** @type {?} */
Visitor.prototype.JSXNamespacedName;
 /** @type {?} */
Visitor.prototype.JSXElement;
 /** @type {?} */
Visitor.prototype.JSXExpressionContainer;
 /** @type {?} */
Visitor.prototype.JSXClosingElement;
 /** @type {?} */
Visitor.prototype.JSXMemberExpression;
 /** @type {?} */
Visitor.prototype.JSXOpeningElement;
 /** @type {?} */
Visitor.prototype.JSXEmptyExpression;
 /** @type {?} */
Visitor.prototype.JSXSpreadAttribute;
 /** @type {?} */
Visitor.prototype.JSXText;
 /** @type {?} */
Visitor.prototype.Noop;
 /** @type {?} */
Visitor.prototype.ParenthesizedExpression;
 /** @type {?} */
Visitor.prototype.AwaitExpression;
 /** @type {?} */
Visitor.prototype.BindExpression;
 /** @type {?} */
Visitor.prototype.Decorator;
 /** @type {?} */
Visitor.prototype.DoExpression;
 /** @type {?} */
Visitor.prototype.ExportDefaultSpecifier;
 /** @type {?} */
Visitor.prototype.ExportNamespaceSpecifier;
 /** @type {?} */
Visitor.prototype.RestProperty;
 /** @type {?} */
Visitor.prototype.SpreadProperty;
 /** @type {?} */
Visitor.prototype.Binary;
 /** @type {?} */
Visitor.prototype.Scopable;
 /** @type {?} */
Visitor.prototype.BlockParent;
 /** @type {?} */
Visitor.prototype.Block;
 /** @type {?} */
Visitor.prototype.Terminatorless;
 /** @type {?} */
Visitor.prototype.CompletionStatement;
 /** @type {?} */
Visitor.prototype.Conditional;
 /** @type {?} */
Visitor.prototype.Loop;
 /** @type {?} */
Visitor.prototype.While;
 /** @type {?} */
Visitor.prototype.ExpressionWrapper;
 /** @type {?} */
Visitor.prototype.For;
 /** @type {?} */
Visitor.prototype.ForXStatement;
 /** @type {?} */
Visitor.prototype.Function;
 /** @type {?} */
Visitor.prototype.FunctionParent;
 /** @type {?} */
Visitor.prototype.Pureish;
 /** @type {?} */
Visitor.prototype.Literal;
 /** @type {?} */
Visitor.prototype.Immutable;
 /** @type {?} */
Visitor.prototype.UserWhitespacable;
 /** @type {?} */
Visitor.prototype.Method;
 /** @type {?} */
Visitor.prototype.ObjectMember;
 /** @type {?} */
Visitor.prototype.Property;
 /** @type {?} */
Visitor.prototype.UnaryLike;
 /** @type {?} */
Visitor.prototype.Pattern;
 /** @type {?} */
Visitor.prototype.Class;
 /** @type {?} */
Visitor.prototype.ModuleDeclaration;
 /** @type {?} */
Visitor.prototype.ExportDeclaration;
 /** @type {?} */
Visitor.prototype.ModuleSpecifier;
 /** @type {?} */
Visitor.prototype.Flow;
 /** @type {?} */
Visitor.prototype.FlowBaseAnnotation;
 /** @type {?} */
Visitor.prototype.FlowDeclaration;
 /** @type {?} */
Visitor.prototype.JSX;
 /** @type {?} */
Visitor.prototype.Scope;

/** @typedef {?} */
var VisitNode;

/** @typedef {?} */
var VisitNodeFunction;
/**
 * @record
 * @struct
 */
function VisitNodeObject() {}

/**
 * @param {?} path
 * @param {?} state
 * @return {void}
 */
VisitNodeObject.prototype.enter = function(path, state) {};

/**
 * @param {?} path
 * @param {?} state
 * @return {void}
 */
VisitNodeObject.prototype.exit = function(path, state) {};

/**
 * @constructor
 * @struct
 * @param {?} hub
 * @param {?} parent
 */
function NodePath(hub, parent) {}
 /** @type {?} */
NodePath.prototype.parent;
 /** @type {?} */
NodePath.prototype.hub;
 /** @type {!Array<?>} */
NodePath.prototype.contexts;
 /** @type {!Object} */
NodePath.prototype.data;
 /** @type {boolean} */
NodePath.prototype.shouldSkip;
 /** @type {boolean} */
NodePath.prototype.shouldStop;
 /** @type {boolean} */
NodePath.prototype.removed;
 /** @type {?} */
NodePath.prototype.state;
 /** @type {!Object} */
NodePath.prototype.opts;
 /** @type {!Object} */
NodePath.prototype.skipKeys;
 /** @type {?} */
NodePath.prototype.parentPath;
 /** @type {?} */
NodePath.prototype.context;
 /** @type {(!Object|!Array<!Object>)} */
NodePath.prototype.container;
 /** @type {string} */
NodePath.prototype.listKey;
 /** @type {boolean} */
NodePath.prototype.inList;
 /** @type {string} */
NodePath.prototype.parentKey;
 /** @type {string} */
NodePath.prototype.key;
 /** @type {?} */
NodePath.prototype.node;
 /** @type {?} */
NodePath.prototype.scope;
 /** @type {string} */
NodePath.prototype.type;
 /** @type {!Object} */
NodePath.prototype.typeAnnotation;

/**
 * @param {?} scope
 * @return {?}
 */
NodePath.prototype.getScope = function(scope) {};

/**
 * @param {string} key
 * @param {?} val
 * @return {?}
 */
NodePath.prototype.setData = function(key, val) {};

/**
 * @param {string} key
 * @param {?=} def
 * @return {?}
 */
NodePath.prototype.getData = function(key, def) {};

/**
 * @template TError
 * @param {string} msg
 * @param {?=} Error
 * @return {?}
 */
NodePath.prototype.buildCodeFrameError = function(msg, Error) {};

/**
 * @param {?} visitor
 * @param {?=} state
 * @return {void}
 */
NodePath.prototype.traverse = function(visitor, state) {};

/**
 * @param {string} key
 * @param {?} node
 * @return {void}
 */
NodePath.prototype.set = function(key, node) {};

/**
 * @return {string}
 */
NodePath.prototype.getPathLocation = function() {};

/**
 * @param {?} buildMessage
 * @return {void}
 */
NodePath.prototype.debug = function(buildMessage) {};

/**
 * Call the provided `callback` with the `NodePath`s of all the parents.
 * When the `callback` returns a truthy value, we return that node path.
 * @param {?} callback
 * @return {?}
 */
NodePath.prototype.findParent = function(callback) {};

/**
 * @param {?} callback
 * @return {?}
 */
NodePath.prototype.find = function(callback) {};

/**
 * Get the parent function of the current path.
 * @return {?}
 */
NodePath.prototype.getFunctionParent = function() {};

/**
 * Walk up the tree until we hit a parent node path in a list.
 * @return {?}
 */
NodePath.prototype.getStatementParent = function() {};

/**
 * Get the deepest common ancestor and then from it, get the earliest relationship path
 * to that ancestor.
 * 
 * Earliest is defined as being "before" all the other nodes in terms of list container
 * position and visiting key.
 * @param {!Array<?>} paths
 * @return {!Array<?>}
 */
NodePath.prototype.getEarliestCommonAncestorFrom = function(paths) {};

/**
 * Get the earliest path in the tree where the provided `paths` intersect.
 * @param {!Array<?>} paths
 * @param {?=} filter
 * @return {?}
 */
NodePath.prototype.getDeepestCommonAncestorFrom = function(paths, filter) {};

/**
 * Build an array of node paths containing the entire ancestry of the current node path.
 * 
 * NOTE: The current node path is included in this.
 * @return {!Array<?>}
 */
NodePath.prototype.getAncestry = function() {};

/**
 * @param {...string} candidateTypes
 * @return {boolean}
 */
NodePath.prototype.inType = function(candidateTypes) {};

/**
 * Infer the type of the current `NodePath`.
 * @return {?}
 */
NodePath.prototype.getTypeAnnotation = function() {};

/**
 * @param {string} baseName
 * @param {boolean=} soft
 * @return {boolean}
 */
NodePath.prototype.isBaseType = function(baseName, soft) {};

/**
 * @param {string} name
 * @return {boolean}
 */
NodePath.prototype.couldBeBaseType = function(name) {};

/**
 * @param {?} right
 * @return {boolean}
 */
NodePath.prototype.baseTypeStrictlyMatches = function(right) {};

/**
 * @param {string} genericName
 * @return {boolean}
 */
NodePath.prototype.isGenericType = function(genericName) {};

/**
 * Replace a node with an array of multiple. This method performs the following steps:
 * 
 *  - Inherit the comments of first provided node with that of the current node.
 *  - Insert the provided nodes after the current node.
 *  - Remove the current node.
 * @param {!Array<?>} nodes
 * @return {void}
 */
NodePath.prototype.replaceWithMultiple = function(nodes) {};

/**
 * Parse a string as an expression and replace the current node with the result.
 * 
 * NOTE: This is typically not a good idea to use. Building source strings when
 * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
 * easier to use, your transforms will be extremely brittle.
 * @param {?} replacement
 * @return {void}
 */
NodePath.prototype.replaceWithSourceString = function(replacement) {};

/**
 * Replace the current node with another.
 * @param {?} replacement
 * @return {void}
 */
NodePath.prototype.replaceWith = function(replacement) {};

/**
 * This method takes an array of statements nodes and then explodes it
 * into expressions. This method retains completion records which is
 * extremely important to retain original semantics.
 * @param {!Array<?>} nodes
 * @return {?}
 */
NodePath.prototype.replaceExpressionWithStatements = function(nodes) {};

/**
 * @param {(?|!Array<?>)} nodes
 * @return {void}
 */
NodePath.prototype.replaceInline = function(nodes) {};

/**
 * Walk the input `node` and statically evaluate if it's truthy.
 * 
 * Returning `true` when we're sure that the expression will evaluate to a
 * truthy value, `false` if we're sure that it will evaluate to a falsy
 * value and `undefined` if we aren't sure. Because of this please do not
 * rely on coercion when using this method and check with === if it's false.
 * @return {boolean}
 */
NodePath.prototype.evaluateTruthy = function() {};

/**
 * Walk the input `node` and statically evaluate it.
 * 
 * Returns an object in the form `{ confident, value }`. `confident` indicates
 * whether or not we had to drop out of evaluating the expression because of
 * hitting an unknown node that we couldn't confidently find the value of.
 * 
 * Example:
 * 
 *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
 *   t.evaluate(parse("!true")) // { confident: true, value: false }
 *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined }
 * @return {?}
 */
NodePath.prototype.evaluate = function() {};

/**
 * Match the current node if it matches the provided `pattern`.
 * 
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 * @param {string} pattern
 * @param {boolean=} allowPartial
 * @return {boolean}
 */
NodePath.prototype.matchesPattern = function(pattern, allowPartial) {};

/**
 * Check whether we have the input `key`. If the `key` references an array then we check
 * if the array has any items, otherwise we just check if it's falsy.
 * @param {string} key
 * @return {boolean}
 */
NodePath.prototype.has = function(key) {};

/**
 * @return {boolean}
 */
NodePath.prototype.isStatic = function() {};

/**
 * Alias of `has`.
 * @param {string} key
 * @return {boolean}
 */
NodePath.prototype.is = function(key) {};

/**
 * Opposite of `has`.
 * @param {string} key
 * @return {boolean}
 */
NodePath.prototype.isnt = function(key) {};

/**
 * Check whether the path node `key` strict equals `value`.
 * @param {string} key
 * @param {?} value
 * @return {boolean}
 */
NodePath.prototype.equals = function(key, value) {};

/**
 * Check the type against our stored internal type of the node. This is handy when a node has
 * been removed yet we still internally know the type and need it to calculate node replacement.
 * @param {string} type
 * @return {boolean}
 */
NodePath.prototype.isNodeType = function(type) {};

/**
 * This checks whether or not we're in one of the following positions:
 * 
 *   for (KEY in right);
 *   for (KEY;;);
 * 
 * This is because these spots allow VariableDeclarations AND normal expressions so we need
 * to tell the path replacement that it's ok to replace this with an expression.
 * @return {boolean}
 */
NodePath.prototype.canHaveVariableDeclarationOrExpression = function() {};

/**
 * This checks whether we are swapping an arrow function's body between an
 * expression and a block statement (or vice versa).
 * 
 * This is because arrow functions may implicitly return an expression, which
 * is the same as containing a block statement.
 * @param {?} replacement
 * @return {boolean}
 */
NodePath.prototype.canSwapBetweenExpressionAndStatement = function(replacement) {};

/**
 * Check whether the current path references a completion record
 * @param {boolean=} allowInsideFunction
 * @return {boolean}
 */
NodePath.prototype.isCompletionRecord = function(allowInsideFunction) {};

/**
 * Check whether or not the current `key` allows either a single statement or block statement
 * so we can explode it if necessary.
 * @return {boolean}
 */
NodePath.prototype.isStatementOrBlock = function() {};

/**
 * Check if the currently assigned path references the `importName` of `moduleSource`.
 * @param {string} moduleSource
 * @param {string} importName
 * @return {boolean}
 */
NodePath.prototype.referencesImport = function(moduleSource, importName) {};

/**
 * Get the source code associated with this node.
 * @return {string}
 */
NodePath.prototype.getSource = function() {};

/**
 * @param {string} key
 * @return {boolean}
 */
NodePath.prototype.call = function(key) {};

/**
 * @return {boolean}
 */
NodePath.prototype.isBlacklisted = function() {};

/**
 * @return {boolean}
 */
NodePath.prototype.visit = function() {};

/**
 * @return {void}
 */
NodePath.prototype.skip = function() {};

/**
 * @param {string} key
 * @return {void}
 */
NodePath.prototype.skipKey = function(key) {};

/**
 * @return {void}
 */
NodePath.prototype.stop = function() {};

/**
 * @return {void}
 */
NodePath.prototype.setScope = function() {};

/**
 * @param {?} context
 * @return {?}
 */
NodePath.prototype.setContext = function(context) {};

/**
 * @return {void}
 */
NodePath.prototype.popContext = function() {};

/**
 * @param {?} context
 * @return {void}
 */
NodePath.prototype.pushContext = function(context) {};

/**
 * @return {void}
 */
NodePath.prototype.remove = function() {};

/**
 * Insert the provided nodes before the current one.
 * @param {(?|!Array<?>)} nodes
 * @return {?}
 */
NodePath.prototype.insertBefore = function(nodes) {};

/**
 * Insert the provided nodes after the current one. When inserting nodes after an
 * expression, ensure that the completion record is correct by pushing the current node.
 * @param {(?|!Array<?>)} nodes
 * @return {?}
 */
NodePath.prototype.insertAfter = function(nodes) {};

/**
 * Update all sibling node paths after `fromIndex` by `incrementBy`.
 * @param {number} fromIndex
 * @param {number} incrementBy
 * @return {void}
 */
NodePath.prototype.updateSiblingKeys = function(fromIndex, incrementBy) {};

/**
 * Hoist the current node to the highest scope possible and return a UID referencing it.
 * @param {?} scope
 * @return {void}
 */
NodePath.prototype.hoist = function(scope) {};

/**
 * @return {?}
 */
NodePath.prototype.getOpposite = function() {};

/**
 * @return {!Array<?>}
 */
NodePath.prototype.getCompletionRecords = function() {};

/**
 * @param {string} key
 * @return {?}
 */
NodePath.prototype.getSibling = function(key) {};

/**
 * @param {string} key
 * @param {(boolean|?)=} context
 * @return {?}
 */
NodePath.prototype.get = function(key, context) {};

/**
 * @param {boolean=} duplicates
 * @return {!Array<?>}
 */
NodePath.prototype.getBindingIdentifiers = function(duplicates) {};

/**
 * @param {boolean=} duplicates
 * @return {!Array<?>}
 */
NodePath.prototype.getOuterBindingIdentifiers = function(duplicates) {};

/**
 * Share comments amongst siblings.
 * @return {void}
 */
NodePath.prototype.shareCommentsWithSiblings = function() {};

/**
 * @param {string} type
 * @param {string} content
 * @param {boolean=} line
 * @return {void}
 */
NodePath.prototype.addComment = function(type, content, line) {};

/**
 * Give node `comments` of the specified `type`.
 * @param {string} type
 * @param {!Array<?>} comments
 * @return {void}
 */
NodePath.prototype.addComments = function(type, comments) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isArrayExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isAssignmentExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBinaryExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDirective = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDirectiveLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBlockStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBreakStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isCallExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isCatchClause = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isConditionalExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isContinueStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDebuggerStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDoWhileStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isEmptyStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExpressionStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFile = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isForInStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isForStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFunctionDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFunctionExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isIdentifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isIfStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isLabeledStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isStringLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isNumericLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isNullLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBooleanLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isRegExpLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isLogicalExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isMemberExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isNewExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isProgram = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isObjectExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isObjectMethod = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isObjectProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isRestElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isReturnStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isSequenceExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isSwitchCase = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isSwitchStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isThisExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isThrowStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTryStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isUnaryExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isUpdateExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isVariableDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isVariableDeclarator = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isWhileStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isWithStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isAssignmentPattern = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isArrayPattern = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isArrowFunctionExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isClassBody = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isClassDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isClassExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExportAllDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExportDefaultDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExportNamedDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExportSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isForOfStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isImportDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isImportDefaultSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isImportNamespaceSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isImportSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isMetaProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isClassMethod = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isObjectPattern = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isSpreadElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isSuper = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTaggedTemplateExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTemplateElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTemplateLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isYieldExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isAnyTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isArrayTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBooleanTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBooleanLiteralTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isNullLiteralTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isClassImplements = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isClassProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDeclareClass = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDeclareFunction = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDeclareInterface = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDeclareModule = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDeclareTypeAlias = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDeclareVariable = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExistentialTypeParam = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFunctionTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFunctionTypeParam = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isGenericTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isInterfaceExtends = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isInterfaceDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isIntersectionTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isMixedTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isNullableTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isNumericLiteralTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isNumberTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isStringLiteralTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isStringTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isThisTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTupleTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTypeofTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTypeAlias = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTypeCastExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTypeParameterDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTypeParameterInstantiation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isObjectTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isObjectTypeCallProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isObjectTypeIndexer = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isObjectTypeProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isQualifiedTypeIdentifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isUnionTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isVoidTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXAttribute = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXClosingElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXEmptyExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXExpressionContainer = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXIdentifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXMemberExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXNamespacedName = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXOpeningElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXSpreadAttribute = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSXText = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isNoop = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isParenthesizedExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isAwaitExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBindExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDecorator = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDoExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExportDefaultSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExportNamespaceSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isRestProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isSpreadProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBinary = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isScopable = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBlockParent = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBlock = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isTerminatorless = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isCompletionStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isConditional = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isLoop = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isWhile = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExpressionWrapper = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFor = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isForXStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFunction = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFunctionParent = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isPureish = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isLVal = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isImmutable = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isUserWhitespacable = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isMethod = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isObjectMember = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isUnaryLike = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isPattern = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isClass = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isModuleDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isExportDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isModuleSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFlow = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFlowBaseAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isFlowDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isJSX = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isNumberLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isRegexLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isReferencedIdentifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isReferencedMemberExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBindingIdentifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isScope = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isReferenced = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isBlockScoped = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isVar = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isUser = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isGenerated = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {boolean}
 */
NodePath.prototype.isPure = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertArrayExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertAssignmentExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBinaryExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDirective = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDirectiveLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBlockStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBreakStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertCallExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertCatchClause = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertConditionalExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertContinueStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDebuggerStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDoWhileStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertEmptyStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExpressionStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFile = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertForInStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertForStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFunctionDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFunctionExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertIdentifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertIfStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertLabeledStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertStringLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertNumericLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertNullLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBooleanLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertRegExpLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertLogicalExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertMemberExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertNewExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertProgram = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertObjectExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertObjectMethod = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertObjectProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertRestElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertReturnStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertSequenceExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertSwitchCase = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertSwitchStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertThisExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertThrowStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTryStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertUnaryExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertUpdateExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertVariableDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertVariableDeclarator = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertWhileStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertWithStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertAssignmentPattern = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertArrayPattern = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertArrowFunctionExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertClassBody = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertClassDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertClassExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExportAllDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExportDefaultDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExportNamedDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExportSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertForOfStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertImportDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertImportDefaultSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertImportNamespaceSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertImportSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertMetaProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertClassMethod = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertObjectPattern = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertSpreadElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertSuper = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTaggedTemplateExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTemplateElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTemplateLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertYieldExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertAnyTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertArrayTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBooleanTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBooleanLiteralTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertNullLiteralTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertClassImplements = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertClassProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDeclareClass = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDeclareFunction = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDeclareInterface = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDeclareModule = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDeclareTypeAlias = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDeclareVariable = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExistentialTypeParam = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFunctionTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFunctionTypeParam = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertGenericTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertInterfaceExtends = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertInterfaceDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertIntersectionTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertMixedTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertNullableTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertNumericLiteralTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertNumberTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertStringLiteralTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertStringTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertThisTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTupleTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTypeofTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTypeAlias = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTypeCastExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTypeParameterDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTypeParameterInstantiation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertObjectTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertObjectTypeCallProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertObjectTypeIndexer = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertObjectTypeProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertQualifiedTypeIdentifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertUnionTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertVoidTypeAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXAttribute = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXClosingElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXEmptyExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXExpressionContainer = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXIdentifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXMemberExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXNamespacedName = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXOpeningElement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXSpreadAttribute = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSXText = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertNoop = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertParenthesizedExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertAwaitExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBindExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDecorator = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDoExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExportDefaultSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExportNamespaceSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertRestProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertSpreadProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExpression = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBinary = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertScopable = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBlockParent = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertBlock = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertTerminatorless = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertCompletionStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertConditional = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertLoop = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertWhile = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExpressionWrapper = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFor = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertForXStatement = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFunction = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFunctionParent = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertPureish = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertLVal = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertImmutable = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertUserWhitespacable = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertMethod = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertObjectMember = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertProperty = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertUnaryLike = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertPattern = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertClass = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertModuleDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertExportDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertModuleSpecifier = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFlow = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFlowBaseAnnotation = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertFlowDeclaration = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertJSX = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertNumberLiteral = function(opts) {};

/**
 * @param {!Object=} opts
 * @return {void}
 */
NodePath.prototype.assertRegexLiteral = function(opts) {};

/**
 * @constructor
 * @struct
 * @param {?} file
 * @param {?} options
 */
function Hub(file, options) {}
 /** @type {?} */
Hub.prototype.file;
 /** @type {?} */
Hub.prototype.options;
/**
 * @record
 * @struct
 */
function TraversalContext() {}
 /** @type {?} */
TraversalContext.prototype.parentPath;
 /** @type {?} */
TraversalContext.prototype.scope;
 /** @type {?} */
TraversalContext.prototype.state;
 /** @type {?} */
TraversalContext.prototype.opts;
