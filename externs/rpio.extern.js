/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/rpio/index.d.ts:
 /** @type {!Rpio} */
var rpio;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "rpio"
/** @const */
tsickle_declare_module.rpio = {};

/* TODO: ExportAssignment in tsickle_declare_module.rpio */
/**
 * @record
 * @struct
 */
function Rpio() {}
 /** @type {number} */
Rpio.prototype.HIGH;
 /** @type {number} */
Rpio.prototype.LOW;
 /** @type {number} */
Rpio.prototype.INPUT;
 /** @type {number} */
Rpio.prototype.OUTPUT;
 /** @type {number} */
Rpio.prototype.PWM;
 /** @type {number} */
Rpio.prototype.PULL_OFF;
 /** @type {number} */
Rpio.prototype.PULL_DOWN;
 /** @type {number} */
Rpio.prototype.PULL_UP;
 /** @type {number} */
Rpio.prototype.PAD_GROUP_0_27;
 /** @type {number} */
Rpio.prototype.PAD_GROUP_28_45;
 /** @type {number} */
Rpio.prototype.PAD_GROUP_46_53;
 /** @type {number} */
Rpio.prototype.PAD_SLEW_UNLIMITED;
 /** @type {number} */
Rpio.prototype.PAD_HYSTERESIS;
 /** @type {number} */
Rpio.prototype.PAD_DRIVE_2mA;
 /** @type {number} */
Rpio.prototype.PAD_DRIVE_4mA;
 /** @type {number} */
Rpio.prototype.PAD_DRIVE_6mA;
 /** @type {number} */
Rpio.prototype.PAD_DRIVE_8mA;
 /** @type {number} */
Rpio.prototype.PAD_DRIVE_10mA;
 /** @type {number} */
Rpio.prototype.PAD_DRIVE_12mA;
 /** @type {number} */
Rpio.prototype.PAD_DRIVE_14mA;
 /** @type {number} */
Rpio.prototype.PAD_DRIVE_16mA;
 /** @type {number} */
Rpio.prototype.POLL_LOW;
 /** @type {number} */
Rpio.prototype.POLL_HIGH;
 /** @type {number} */
Rpio.prototype.POLL_BOTH;

/**
 * Initialise the bcm2835 library. This will be called automatically by .open() using the default option values if not called explicitly.
 * @param {!RPIO.Options} options
 * @return {void}
 */
Rpio.prototype.init = function(options) {};

/**
 * Open a pin for input or output. Valid modes are:
 * INPUT: pin is input (read-only).
 * OUTPUT: pin is output (read-write).
 * PWM: configure pin for hardware PWM.
 * 
 * For input pins, option can be used to configure the internal pullup or pulldown resistors using options as described in the .pud() documentation below.
 * 
 * For output pins, option defines the initial isMotionDetected of the pin, rather than having to issue a separate .write() call. This can be critical for devices which must have a stable value, rather than relying on the initial floating value when a pin is enabled for output but hasn't yet been configured with a value.
 * @param {number} pin
 * @param {number} mode
 * @param {number=} options
 * @return {void}
 */
Rpio.prototype.open = function(pin, mode, options) {};

/**
 * Switch a pin that has already been opened in one mode to a different mode.
 * This is provided primarily for performance reasons, as it avoids some of the setup work done by .open().
 * @param {number} pin
 * @param {number} mode
 * @return {void}
 */
Rpio.prototype.mode = function(pin, mode) {};

/**
 * Read the current value of pin, returning either 1 (high) or 0 (low).
 * @param {number} pin
 * @return {number}
 */
Rpio.prototype.read = function(pin) {};

/**
 * Read length bits from pin into buffer as fast as possible. If length isn't specified it defaults to buffer.length.
 * @param {number} pin
 * @param {?} buffer
 * @param {number=} length
 * @return {void}
 */
Rpio.prototype.readbuf = function(pin, buffer, length) {};

/**
 * Set the specified pin either high or low, using either the HIGH/LOW constants, or simply 1 or 0.
 * @param {number} pin
 * @param {number} value
 * @return {void}
 */
Rpio.prototype.write = function(pin, value) {};

/**
 * Write length bits to pin from buffer as fast as possible. If length isn't specified it defaults to buffer.length.
 * @param {number} pin
 * @param {?} buffer
 * @param {number=} length
 * @return {void}
 */
Rpio.prototype.writebuf = function(pin, buffer, length) {};

/**
 * Read the current isMotionDetected of the GPIO pad control for the specified GPIO group. On current models of Raspberry Pi there are three groups with corresponding defines:
 * PAD_GROUP_0_27: GPIO0 - GPIO27. Use this for the main GPIO header.
 * PAD_GROUP_28_45: GPIO28 - GPIO45. Use this to configure the P5 header.
 * PAD_GROUP_46_53: GPIO46 - GPIO53. Internal, you probably won't need this.
 * 
 * The value returned will be a bit mask of the following defines:
 * PAD_SLEW_UNLIMITED: 0x10. Slew rate unlimited if set.
 * PAD_HYSTERESIS: 0x08. Hysteresis is enabled if set.
 * 
 * The bottom three bits determine the drive current:
 * PAD_DRIVE_2mA: 0b000
 * PAD_DRIVE_4mA: 0b001
 * PAD_DRIVE_6mA: 0b010
 * PAD_DRIVE_8mA: 0b011
 * PAD_DRIVE_10mA: 0b100
 * PAD_DRIVE_12mA: 0b101
 * PAD_DRIVE_14mA: 0b110
 * PAD_DRIVE_16mA: 0b111
 * 
 * \@note Note that the pad control registers are not available via /dev/gpiomem, so you will need to use .init({gpiomem: false}) and run as root.
 * @param {number} group
 * @return {number}
 */
Rpio.prototype.readpad = function(group) {};

/**
 * Write control settings to the pad control for group. Uses the same defines as above for .readpad().
 * @param {number} group
 * @param {number} control
 * @return {void}
 */
Rpio.prototype.writepad = function(group, control) {};

/**
 * Configure the pin's internal pullup or pulldown resistors, using the following isMotionDetected constants:
 * PULL_OFF: disable configured resistors.
 * PULL_DOWN: enable the pulldown resistor.
 * PULL_UP: enable the pullup resistor.
 * 
 * @param {number} pin
 * @param {number} state
 * @return {void}
 */
Rpio.prototype.pud = function(pin, state) {};

/**
 * Watch pin for changes and execute the callback cb() on events. cb() takes a single argument, the pin which triggered the callback.
 * 
 * The optional direction argument can be used to watch for specific events:
 * POLL_LOW: poll for falling edge transitions to low.
 * POLL_HIGH: poll for rising edge transitions to high.
 * POLL_BOTH: poll for both transitions (the default).
 * 
 * Due to hardware/kernel limitations we can only poll for changes, and the event detection only says that an event occurred, not which one. The poll interval is a 1ms setInterval() and transitions could come in between detecting the event and reading the value. Therefore this interface is only useful for events which transition slower than approximately 1kHz.
 * 
 * To stop watching for pin changes, call .poll() again, setting the callback to null.
 * @param {number} pin
 * @param {!RPIO.CallbackFunction} cb
 * @param {number=} direction
 * @return {void}
 */
Rpio.prototype.poll = function(pin, cb, direction) {};

/**
 * Reset pin to INPUT and clear any pullup/pulldown resistors and poll events.
 * @param {number} pin
 * @return {void}
 */
Rpio.prototype.close = function(pin) {};

/**
 * Assign pins 3 and 5 to i²c use. Until .i2cEnd() is called they won't be available for GPIO use.
 * 
 * The pin assignments are:
 * Pin 3: SDA (Serial Data)
 * Pin 5: SCL (Serial Clock)
 * @return {void}
 */
Rpio.prototype.i2cBegin = function() {};

/**
 * Configure the slave address. This is between 0 - 0x7f, and it can be helpful to
 * run the i2cdetect program to figure out where your devices are if you are unsure.
 * @param {number} address
 * @return {void}
 */
Rpio.prototype.i2cSetSlaveAddress = function(address) {};

/**
 * Set the baud rate - directly set the speed in hertz.
 * @param {number} baudRate
 * @return {void}
 */
Rpio.prototype.i2cSetBaudRate = function(baudRate) {};

/**
 * Read from the i²c slave.
 * Function takes a buffer and optional length argument, defaulting to the length of the buffer if not specified.
 * @param {?} buffer
 * @param {number=} length
 * @return {void}
 */
Rpio.prototype.i2cRead = function(buffer, length) {};

/**
 * Write to the i²c slave.
 * Function takes a buffer and optional length argument, defaulting to the length of the buffer if not specified.
 * @param {?} biffer
 * @param {number=} length
 * @return {void}
 */
Rpio.prototype.i2cWrite = function(biffer, length) {};

/**
 * Set the baud rate - based on a divisor of the base 250MHz rate.
 * @param {number} clockDivider
 * @return {void}
 */
Rpio.prototype.i2cSetClockDivider = function(clockDivider) {};

/**
 * Turn off the i²c interface and return the pins to GPIO.
 * @return {void}
 */
Rpio.prototype.i2cEnd = function() {};

/**
 * Set the PWM refresh rate.
 * @param {number} clockDivider
 * @return {void}
 */
Rpio.prototype.pwmSetClockDivider = function(clockDivider) {};

/**
 * Set the PWM range for a pin. This determines the maximum pulse width.
 * @param {number} pin
 * @param {number} range
 * @return {void}
 */
Rpio.prototype.pwmSetRange = function(pin, range) {};

/**
 * Set the PWM width for a pin.
 * @param {number} pin
 * @param {number} data
 * @return {void}
 */
Rpio.prototype.pwmSetData = function(pin, data) {};

/**
 * Switch pins 119, 21, 23, 24 and 25 (GPIO7-GPIO11) to SPI mode
 * 
 *  Pin | Function
 * -----|----------
 *   19 |   MOSI
 *   21 |   MISO
 *   23 |   SCLK
 *   24 |   CE0
 *   25 |   CE1
 * @return {void}
 */
Rpio.prototype.spiBegin = function() {};

/**
 * Choose which of the chip select / chip enable pins to control.
 * 
 *  Value | Pin
 *  ------|---------------------
 *    0   | SPI_CE0 (24 / GPIO8)
 *    1   | SPI_CE1 (25 / GPIO7)
 *    2   | Both
 * 
 * @param {number} cePin
 * @return {void}
 */
Rpio.prototype.spiChipSelect = function(cePin) {};

/**
 * Commonly chip enable (CE) pins are active low, and this is the default.
 * If your device's CE pin is active high, use spiSetCSPolarity() to change the polarity.
 * @param {number} cePin
 * @param {number} polarity
 * @return {void}
 */
Rpio.prototype.spiSetCSPolarity = function(cePin, polarity) {};

/**
 * Set the SPI clock speed with.
 * @param {number} clockDivider
 * @return {void}
 */
Rpio.prototype.spiSetClockDivider = function(clockDivider) {};

/**
 * Transfer data. Data is sent and received in 8-bit chunks via buffers which should be the same size.
 * @param {?} txBuffer
 * @param {?} rxBuffer
 * @param {number} txLength
 * @return {void}
 */
Rpio.prototype.spiTransfer = function(txBuffer, rxBuffer, txLength) {};

/**
 * Send data and do not care about the data coming back.
 * @param {?} txBuffer
 * @param {number} txLength
 * @return {void}
 */
Rpio.prototype.spiWrite = function(txBuffer, txLength) {};

/**
 * Release the pins back to general purpose use.
 * @return {void}
 */
Rpio.prototype.spiEnd = function() {};

/**
 * Sleep for n seconds.
 * @param {number} n
 * @return {void}
 */
Rpio.prototype.sleep = function(n) {};

/**
 * Sleep for n milliseconds.
 * @param {number} n
 * @return {void}
 */
Rpio.prototype.msleep = function(n) {};

/**
 * Sleep for n microseconds.
 * @param {number} n
 * @return {void}
 */
Rpio.prototype.usleep = function(n) {};
/** @const */
var RPIO = {};
/**
 * @record
 * @struct
 */
RPIO.Options = function() {};
 /** @type {boolean} */
RPIO.Options.prototype.gpiomem;
 /** @type {string} */
RPIO.Options.prototype.mapping;
/**
 * @record
 * @struct
 */
RPIO.CallbackFunction = function() {};

/* TODO: CallSignature: RPIO */
