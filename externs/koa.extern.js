/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/koa/index.d.ts:

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */

/* TODO: ImportDeclaration in  */
/**
 * @record
 * @struct
 */
function ContextDelegatedRequest() {}
 /** @type {?} */
ContextDelegatedRequest.prototype.header;
 /** @type {?} */
ContextDelegatedRequest.prototype.headers;
 /** @type {string} */
ContextDelegatedRequest.prototype.url;
 /** @type {string} */
ContextDelegatedRequest.prototype.origin;
 /** @type {string} */
ContextDelegatedRequest.prototype.href;
 /** @type {string} */
ContextDelegatedRequest.prototype.method;
 /** @type {string} */
ContextDelegatedRequest.prototype.path;
 /** @type {?} */
ContextDelegatedRequest.prototype.query;
 /** @type {string} */
ContextDelegatedRequest.prototype.querystring;
 /** @type {string} */
ContextDelegatedRequest.prototype.search;
 /** @type {string} */
ContextDelegatedRequest.prototype.host;
 /** @type {string} */
ContextDelegatedRequest.prototype.hostname;
 /** @type {boolean} */
ContextDelegatedRequest.prototype.fresh;
 /** @type {boolean} */
ContextDelegatedRequest.prototype.stale;
 /** @type {boolean} */
ContextDelegatedRequest.prototype.idempotent;
 /** @type {?} */
ContextDelegatedRequest.prototype.socket;
 /** @type {string} */
ContextDelegatedRequest.prototype.protocol;
 /** @type {boolean} */
ContextDelegatedRequest.prototype.secure;
 /** @type {!Array<string>} */
ContextDelegatedRequest.prototype.ips;
 /** @type {!Array<string>} */
ContextDelegatedRequest.prototype.subdomains;

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 * 
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 * 
 * Examples:
 * 
 *     // Accept: text/html
 *     this.accepts('html');
 *     // => "html"
 * 
 *     // Accept: text/*, application/json
 *     this.accepts('html');
 *     // => "html"
 *     this.accepts('text/html');
 *     // => "text/html"
 *     this.accepts('json', 'text');
 *     // => "json"
 *     this.accepts('application/json');
 *     // => "application/json"
 * 
 *     // Accept: text/*, application/json
 *     this.accepts('image/png');
 *     this.accepts('png');
 *     // => undefined
 * 
 *     // Accept: text/*;q=.5, application/json
 *     this.accepts(['html', 'json']);
 *     this.accepts('html', 'json');
 *     // => "json"
 * @param {...string|!Array<string>} types
 * @return {(boolean|!Array<string>)|(string|boolean)}
 */
ContextDelegatedRequest.prototype.accepts = function(types) {};

/**
 * Return accepted encodings or best fit based on `encodings`.
 * 
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 * 
 *     ['gzip', 'deflate']
 * @param {...string|!Array<string>} encodings
 * @return {(boolean|!Array<string>)|(string|boolean)}
 */
ContextDelegatedRequest.prototype.acceptsEncodings = function(encodings) {};

/**
 * Return accepted charsets or best fit based on `charsets`.
 * 
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 * 
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 * @param {...string|!Array<string>} charsets
 * @return {(boolean|!Array<string>)|(string|boolean)}
 */
ContextDelegatedRequest.prototype.acceptsCharsets = function(charsets) {};

/**
 * Return accepted languages or best fit based on `langs`.
 * 
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 * 
 *     ['es', 'pt', 'en']
 * @param {...string|!Array<string>} langs
 * @return {(boolean|!Array<string>)|(string|boolean)}
 */
ContextDelegatedRequest.prototype.acceptsLanguages = function(langs) {};

/**
 * @param {...string|!Array<string>} types
 * @return {(string|boolean)}
 */
ContextDelegatedRequest.prototype.is = function(types) {};

/**
 * Return request header.
 * 
 * The `Referrer` header field is special-cased,
 * both `Referrer` and `Referer` are interchangeable.
 * 
 * Examples:
 * 
 *     this.get('Content-Type');
 *     // => "text/plain"
 * 
 *     this.get('content-type');
 *     // => "text/plain"
 * 
 *     this.get('Something');
 *     // => undefined
 * @param {string} field
 * @return {string}
 */
ContextDelegatedRequest.prototype.get = function(field) {};
/**
 * @record
 * @struct
 */
function ContextDelegatedResponse() {}
 /** @type {number} */
ContextDelegatedResponse.prototype.status;
 /** @type {string} */
ContextDelegatedResponse.prototype.message;
 /** @type {?} */
ContextDelegatedResponse.prototype.body;
 /** @type {number} */
ContextDelegatedResponse.prototype.length;
 /** @type {boolean} */
ContextDelegatedResponse.prototype.headerSent;
 /** @type {string} */
ContextDelegatedResponse.prototype.type;
 /** @type {!Date} */
ContextDelegatedResponse.prototype.lastModified;
 /** @type {string} */
ContextDelegatedResponse.prototype.etag;
 /** @type {boolean} */
ContextDelegatedResponse.prototype.writable;

/**
 * Vary on `field`.
 * @param {string} field
 * @return {void}
 */
ContextDelegatedResponse.prototype.vary = function(field) {};

/**
 * Perform a 302 redirect to `url`.
 * 
 * The string "back" is special-cased
 * to provide Referrer support, when Referrer
 * is not present `alt` or "/" is used.
 * 
 * Examples:
 * 
 *    this.redirect('back');
 *    this.redirect('back', '/index.html');
 *    this.redirect('/login');
 *    this.redirect('http://google.com');
 * @param {string} url
 * @param {string=} alt
 * @return {void}
 */
ContextDelegatedResponse.prototype.redirect = function(url, alt) {};

/**
 * Set Content-Disposition header to "attachment" with optional `filename`.
 * @param {string} filename
 * @return {void}
 */
ContextDelegatedResponse.prototype.attachment = function(filename) {};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 * 
 * Examples:
 * 
 *    this.set('Foo', ['bar', 'baz']);
 *    this.set('Accept', 'application/json');
 *    this.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 * @param {!Object<string,string>|string} field
 * @param {(string|!Array<string>)=} val
 * @return {void}
 */
ContextDelegatedResponse.prototype.set = function(field, val) {};

/**
 * Append additional header `field` with value `val`.
 * 
 * Examples:
 * 
 * ```
 * this.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
 * this.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 * this.append('Warning', '199 Miscellaneous warning');
 * ```
 * @param {string} field
 * @param {(string|!Array<string>)} val
 * @return {void}
 */
ContextDelegatedResponse.prototype.append = function(field, val) {};

/**
 * Remove header `field`.
 * @param {string} field
 * @return {void}
 */
ContextDelegatedResponse.prototype.remove = function(field) {};

/**
 * Flush any set headers, and begin the body
 * @return {void}
 */
ContextDelegatedResponse.prototype.flushHeaders = function() {};

/**
 * @constructor
 * @struct
 */
function Application() {}
 /** @type {boolean} */
Application.prototype.proxy;
 /** @type {!Array<function(!Application.Context, function(): !Promise<?>): ?>} */
Application.prototype.middleware;
 /** @type {number} */
Application.prototype.subdomainOffset;
 /** @type {string} */
Application.prototype.env;
 /** @type {!Application.BaseContext} */
Application.prototype.context;
 /** @type {!Application.BaseRequest} */
Application.prototype.request;
 /** @type {!Application.BaseResponse} */
Application.prototype.response;
 /** @type {boolean} */
Application.prototype.silent;
 /** @type {(!Array<string>|?)} */
Application.prototype.keys;

/**
 * Shorthand for:
 * 
 *    http.createServer(app.callback()).listen(...)
 * @param {number|string|!ListenOptions|?=} port_or_path_or_options_or_handle
 * @param {string|number|function(): void=} hostname_or_backlog_or_listeningListener
 * @param {number|function(): void=} backlog_or_listeningListener
 * @param {function(): void=} listeningListener
 * @return {!Server}
 */
Application.prototype.listen = function(port_or_path_or_options_or_handle, hostname_or_backlog_or_listeningListener, backlog_or_listeningListener, listeningListener) {};

/**
 * Return JSON representation.
 * We only bother showing settings.
 * @return {?}
 */
Application.prototype.inspect = function() {};

/**
 * Return JSON representation.
 * We only bother showing settings.
 * @return {?}
 */
Application.prototype.toJSON = function() {};

/**
 * Use the given middleware `fn`.
 * 
 * Old-style middleware will be converted.
 * @param {function(!Application.Context, function(): !Promise<?>): ?} middleware
 * @return {Application}
 */
Application.prototype.use = function(middleware) {};

/**
 * Return a request handler callback
 * for node's native http server.
 * @return {function(!IncomingMessage, !ServerResponse): void}
 */
Application.prototype.callback = function() {};

/**
 * Initialize a new context.
 * 
 * \@api private
 * @param {!IncomingMessage} req
 * @param {!ServerResponse} res
 * @return {!Application.Context}
 */
Application.prototype.createContext = function(req, res) {};

/**
 * Default error handler.
 * 
 * \@api private
 * @param {!Error} err
 * @return {void}
 */
Application.prototype.onerror = function(err) {};

/** @typedef {function(!Application.Context, function(): !Promise<?>): ?} */
Application.Middleware;
/**
 * @extends {ContextDelegatedRequest}
 * @record
 * @struct
 */
Application.BaseRequest = function() {};
 /** @type {string} */
Application.BaseRequest.prototype.charset;
 /** @type {number} */
Application.BaseRequest.prototype.length;
 /** @type {string} */
Application.BaseRequest.prototype.type;

/**
 * Inspect implementation.
 * @return {?}
 */
Application.BaseRequest.prototype.inspect = function() {};

/**
 * Return JSON representation.
 * @return {?}
 */
Application.BaseRequest.prototype.toJSON = function() {};
/**
 * @extends {ContextDelegatedResponse}
 * @record
 * @struct
 */
Application.BaseResponse = function() {};
 /** @type {?} */
Application.BaseResponse.prototype.socket;
 /** @type {?} */
Application.BaseResponse.prototype.header;
 /** @type {?} */
Application.BaseResponse.prototype.headers;

/**
 * @param {...string|!Array<string>} types
 * @return {string}
 */
Application.BaseResponse.prototype.is = function(types) {};

/**
 * Return response header.
 * 
 * Examples:
 * 
 *     this.get('Content-Type');
 *     // => "text/plain"
 * 
 *     this.get('content-type');
 *     // => "text/plain"
 * @param {string} field
 * @return {string}
 */
Application.BaseResponse.prototype.get = function(field) {};

/**
 * Inspect implementation.
 * @return {?}
 */
Application.BaseResponse.prototype.inspect = function() {};

/**
 * Return JSON representation.
 * @return {?}
 */
Application.BaseResponse.prototype.toJSON = function() {};
/**
 * @extends {ContextDelegatedRequest}
 * @extends {ContextDelegatedResponse}
 * @record
 * @struct
 */
Application.BaseContext = function() {};
 /** @type {function(?, number, string, !Object): void} */
Application.BaseContext.prototype.assert;

/**
 * util.inspect() implementation, which
 * just returns the JSON output.
 * @return {?}
 */
Application.BaseContext.prototype.inspect = function() {};

/**
 * Return JSON representation.
 * 
 * Here we explicitly invoke .toJSON() on each
 * object, as iteration will otherwise fail due
 * to the getters and cause utilities such as
 * clone() to fail.
 * @return {?}
 */
Application.BaseContext.prototype.toJSON = function() {};

/**
 * Throw an error with `msg` and optional `status`
 * defaulting to 500. Note that these are user-level
 * errors, and the message may be exposed to the client.
 * 
 *    this.throw(403)
 *    this.throw('name required', 400)
 *    this.throw(400, 'name required')
 *    this.throw('something exploded')
 *    this.throw(new Error('invalid'), 400);
 *    this.throw(400, new Error('invalid'));
 * 
 * See: https://github.com/jshttp/http-errors
 * @param {...string|number|(string|number|!Object)} message_or_status_or_properties
 * @return {?}
 */
Application.BaseContext.prototype.throw = function(message_or_status_or_properties) {};

/**
 * Default error handling.
 * @param {!Error} err
 * @return {void}
 */
Application.BaseContext.prototype.onerror = function(err) {};
/**
 * @extends {Application.BaseRequest}
 * @record
 * @struct
 */
Application.Request = function() {};
 /** @type {!Application} */
Application.Request.prototype.app;
 /** @type {!IncomingMessage} */
Application.Request.prototype.req;
 /** @type {!ServerResponse} */
Application.Request.prototype.res;
 /** @type {!Application.Context} */
Application.Request.prototype.ctx;
 /** @type {!Application.Response} */
Application.Request.prototype.response;
 /** @type {string} */
Application.Request.prototype.originalUrl;
 /** @type {string} */
Application.Request.prototype.ip;
 /** @type {!accepts.Accepts} */
Application.Request.prototype.accept;
/**
 * @extends {Application.BaseResponse}
 * @record
 * @struct
 */
Application.Response = function() {};
 /** @type {!Application} */
Application.Response.prototype.app;
 /** @type {!IncomingMessage} */
Application.Response.prototype.req;
 /** @type {!ServerResponse} */
Application.Response.prototype.res;
 /** @type {!Application.Context} */
Application.Response.prototype.ctx;
 /** @type {!Application.Request} */
Application.Response.prototype.request;
/**
 * @extends {Application.BaseContext}
 * @record
 * @struct
 */
Application.Context = function() {};
 /** @type {!Application} */
Application.Context.prototype.app;
 /** @type {!Application.Request} */
Application.Context.prototype.request;
 /** @type {!Application.Response} */
Application.Context.prototype.response;
 /** @type {!IncomingMessage} */
Application.Context.prototype.req;
 /** @type {!ServerResponse} */
Application.Context.prototype.res;
 /** @type {string} */
Application.Context.prototype.originalUrl;
 /** @type {?} */
Application.Context.prototype.cookies;
 /** @type {!accepts.Accepts} */
Application.Context.prototype.accept;
 /** @type {?} */
Application.Context.prototype.state;
 /** @type {boolean} */
Application.Context.prototype.respond;

/* TODO: ExportAssignment in  */
