/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/multiplexjs/index.d.ts:
 /** @type {!multiplex.MultiplexStatic} */
var multiplex;
/** @const */
var tsickle_declare_module = {};
// Derived from: declare module "multiplexjs"
/** @const */
tsickle_declare_module.multiplexjs = {};

/* TODO: ExportAssignment in tsickle_declare_module.multiplexjs */

/* TODO: ImportEqualsDeclaration in  */
/**
 * @record
 * @struct
 */
multiplex.Iterable = function() {};

/**
 * @return {!multiplex.Iterator<T>}
 */
multiplex.Iterable.prototype"@@iterator" = function() {};
/**
 * @record
 * @struct
 */
multiplex.Iterator = function() {};

/**
 * @return {!multiplex.IteratorResult<T>}
 */
multiplex.Iterator.prototype.next = function() {};

/**
 * @param {?=} value
 * @return {!multiplex.IteratorResult<T>}
 */
multiplex.Iterator.prototype.return = function(value) {};

/**
 * @param {?=} e
 * @return {!multiplex.IteratorResult<T>}
 */
multiplex.Iterator.prototype.throw = function(e) {};
/**
 * @record
 * @struct
 */
multiplex.IteratorResult = function() {};
 /** @type {boolean} */
multiplex.IteratorResult.prototype.done;
 /** @type {T} */
multiplex.IteratorResult.prototype.value;
/**
 * @record
 * @struct
 */
multiplex.Enumerator = function() {};
 /** @type {T} */
multiplex.Enumerator.prototype.current;

/**
 * Advances the enumerator to the next element of the collection.
 * @return {boolean}
 */
multiplex.Enumerator.prototype.next = function() {};
/**
 * @record
 * @struct
 */
multiplex.EnumeratorConstructor = function() {};

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Iterable}
 * @record
 * @struct
 */
multiplex.Enumerable = function() {};

/**
 * Returns an enumerator that iterates through the collection.
 * @return {!multiplex.Enumerator<T>}
 */
multiplex.Enumerable.prototype.getEnumerator = function() {};
/**
 * @record
 * @struct
 */
multiplex.EnumerableConstructor = function() {};

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/**
 * Returns an empty Enumerable.
 * @template T
 * @return {!multiplex.Enumerable<T>}
 */
multiplex.EnumerableConstructor.prototype.empty = function() {};

/**
 * Detects if an object is Enumerable.
 * @param {?} obj An object to check its Enumerability.
 * @return {boolean}
 */
multiplex.EnumerableConstructor.prototype.is = function(obj) {};

/**
 * Generates a sequence of integral numbers within a specified range.
 * @param {number} start The value of the first integer in the sequence.
 * @param {number} count The number of sequential integers to generate.
 * @return {!multiplex.Enumerable<number>}
 */
multiplex.EnumerableConstructor.prototype.range = function(start, count) {};

/**
 * Generates a sequence that contains one repeated value.
 * @template T
 * @param {T} element The value to be repeated.
 * @param {number} count The number of times to repeat the value in the generated sequence.
 * @return {!multiplex.Enumerable<T>}
 */
multiplex.EnumerableConstructor.prototype.repeat = function(element, count) {};
/**
 * @record
 * @struct
 */
multiplex.Comparer = function() {};

/**
 * Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
 * returns An integer that indicates the relative values of x and y, as shown in the following table:
 * Less than zero x is less than y.
 * Zero x equals y.
 * Greater than zero x is greater than y..
 * @param {T} x The first object to compare.
 * @param {T} y The second object to compare.
 * @return {number}
 */
multiplex.Comparer.prototype.compare = function(x, y) {};
/**
 * @record
 * @struct
 */
multiplex.ComparerConstructor = function() {};
 /** @type {!multiplex.Comparer<?>} */
multiplex.ComparerConstructor.prototype.defaultComparer;

/**
 * Creates a comparer by using the specified comparison.
 * @template T
 * @param {function(T, T): number} comparison The comparison to use.
 * @return {!multiplex.Comparer<T>}
 */
multiplex.ComparerConstructor.prototype.create = function(comparison) {};
/**
 * @record
 * @struct
 */
multiplex.EqualityComparer = function() {};

/**
 * Determines whether the specified objects are equal.
 * @param {T} x The first object of type Object to compare.
 * @param {T} y The second object of type Object to compare.
 * @return {boolean}
 */
multiplex.EqualityComparer.prototype.equals = function(x, y) {};

/**
 * Returns a hash code for the specified object.
 * @param {T} obj The Object for which a hash code is to be returned.
 * @return {number}
 */
multiplex.EqualityComparer.prototype.hash = function(obj) {};
/**
 * @record
 * @struct
 */
multiplex.EqualityComparerConstructor = function() {};
 /** @type {!multiplex.EqualityComparer<?>} */
multiplex.EqualityComparerConstructor.prototype.defaultComparer;

/**
 * Creates an EqualityComparer by using the specified equality and hashCodeProvider.
 * @template T
 * @param {function(T): number} hashCodeProvider The hashCodeProvider to use for a hash code is to be returned.
 * @param {function(T, T): boolean} equality The equality function.
 * @return {!multiplex.EqualityComparer<T>}
 */
multiplex.EqualityComparerConstructor.prototype.create = function(hashCodeProvider, equality) {};
/**
 * @extends {multiplex.Enumerable}
 * @record
 * @struct
 */
multiplex.Collection = function() {};

/**
 * Gets the number of elements contained in the Collection.
 * @return {number}
 */
multiplex.Collection.prototype.count = function() {};

/**
 * Copies the Collection to an existing one-dimensional Array, starting at the specified array index.
 * @param {!Array<T>} array The one-dimensional Array that is the destination of the elements copied from Dictionary keys.
 * @param {number} arrayIndex The zero-based index in array at which copying begins.
 * @return {void}
 */
multiplex.Collection.prototype.copyTo = function(array, arrayIndex) {};
/**
 * @record
 * @struct
 */
multiplex.CollectionConstructor = function() {};

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.ReadOnlyCollection = function() {};

/* TODO: IndexSignature: multiplex */

/**
 * Gets the element at the specified index.
 * @param {number} index The zero-based index of the element to get.
 * @return {T}
 */
multiplex.ReadOnlyCollection.prototype.get = function(index) {};

/**
 * Determines whether the ReadOnlyCollection contains a specific value.
 * @param {T} item The object to locate in the ReadOnlyCollection.
 * @return {boolean}
 */
multiplex.ReadOnlyCollection.prototype.contains = function(item) {};

/**
 * Searches for the specified object and returns the zero-based index of the first occurrence within the entire ReadOnlyCollection.
 * @param {T} item The object to locate in the ReadOnlyCollection.
 * @return {number}
 */
multiplex.ReadOnlyCollection.prototype.indexOf = function(item) {};
/**
 * @record
 * @struct
 */
multiplex.ReadOnlyCollectionConstructor = function() {};

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.List = function() {};

/* TODO: IndexSignature: multiplex */

/**
 * Adds an object to the end of the List.
 * @param {T} item The object to be added to the end of the List.
 * @return {void}
 */
multiplex.List.prototype.add = function(item) {};

/**
 * Adds the elements of the specified collection to the end of the List.
 * @param {!multiplex.Iterable<T>} collection The collection whose elements should be added to the end of the List.
 * @return {void}
 */
multiplex.List.prototype.addRange = function(collection) {};

/**
 * Returns a read-only wrapper for the current list.
 * @return {!multiplex.ReadOnlyCollection<T>}
 */
multiplex.List.prototype.asReadOnly = function() {};

/**
 * Searches the entire sorted List for an element using the default comparer and returns the zero-based index of the element.
 * Returns The zero-based index of item in the sorted List, if item is found; otherwise, a negative number
 * that is the  bitwise complement of the index of the  next element that is larger than item or, if there is no larger element,
 * the bitwise complement of List.count().
 * Searches the entire sorted List for an element using the specified comparer and returns the zero-based index of the element.
 * returns The zero-based index of item in the sorted List, if item is found; otherwise, a negative number
 * that is the  bitwise complement of the index of the  next element that is larger than item or, if there is no larger element,
 * the bitwise complement of List.count().
 * Searches a range of elements in the sorted List for an element using the specified comparer and returns the zero-based index of the element.
 * returns The zero-based index of item in the sorted List, if item is found; otherwise, a negative number
 * that is the  bitwise complement of the index of the  next element that is larger than item or, if there is no larger element,
 * the bitwise complement of List.count().
 * @param {T} item The object to locate. The value can be null for reference types.
 * @param {!multiplex.Comparer<T>|number=} comparer_or_index The Comparer implementation to use when comparing elements. / The zero-based starting index of the range to search.
 * @param {number=} count The length of the range to search.
 * @param {!multiplex.Comparer<T>=} comparer The Comparer implementation to use when comparing elements.
 * @return {number}
 */
multiplex.List.prototype.binarySearch = function(item, comparer_or_index, count, comparer) {};

/**
 * Removes all items from the List.
 * @return {void}
 */
multiplex.List.prototype.clear = function() {};

/**
 * Determines whether the List contains elements that match the conditions defined by the specified predicate.
 * @param {function(T): boolean} match The predicate function that defines the conditions of the elements to search for.
 * @return {boolean}
 */
multiplex.List.prototype.exists = function(match) {};

/**
 * Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire List.
 * @param {function(T): boolean} match The predicate function that defines the conditions of the elements to search for.
 * @return {T}
 */
multiplex.List.prototype.find = function(match) {};

/**
 * Retrieves all the elements that match the conditions defined by the specified predicate.
 * @param {function(T): boolean} match The predicate function that defines the conditions of the elements to search for.
 * @return {!multiplex.List}
 */
multiplex.List.prototype.findAll = function(match) {};

/**
 * Searches for an element that matches the conditions defined by the specified predicate,
 * and returns the zero-based index of the first occurrence within the entire List, if found; otherwise, –1.
 * Searches for an element that matches the conditions defined by the specified predicate,
 * and returns the zero-based index of the first occurrence within the range of elements
 * in the List that extends from the specified index to the last element, if found; otherwise, –1.
 * Searches for an element that matches the conditions defined by the specified predicate,
 * and returns the zero-based index of the first occurrence within the range of elements
 * in the List that starts at the specified index and contains the specified number of elements, if found; otherwise, –1.
 * @param {function(T): boolean|number} match_or_startIndex The predicate function that defines the conditions of the elements to search for. / The zero-based starting index of the search.
 * @param {function(T): boolean|number=} match_or_count The predicate function that defines the conditions of the elements to search for. / The number of elements in the section to search.
 * @param {function(T): boolean=} match The predicate function that defines the conditions of the elements to search for.
 * @return {number}
 */
multiplex.List.prototype.findIndex = function(match_or_startIndex, match_or_count, match) {};

/**
 * Searches for an element that matches the conditions defined by the specified predicate,
 * and returns the last occurrence within the entire List.
 * @param {function(T): boolean} match The predicate function that defines the conditions of the elements to search for.
 * @return {T}
 */
multiplex.List.prototype.findLast = function(match) {};

/**
 * Searches for an element that matches the conditions defined by the specified predicate,
 * and returns the zero-based index of the last occurrence within the entire List, if found; otherwise, –1.
 * Searches for an element that matches the conditions defined by the specified predicate,
 * and returns the zero-based index  of the last occurrence within the range of elements
 * in the List that extends from the first element to the specified index, if found; otherwise, –1.
 * Searches for an element that matches the conditions defined by the specified predicate,
 * and returns the zero-based index  of the last occurrence within the range of elements
 * in the List that contains the specified number of elements and ends at the specified index, if found; otherwise, –1.
 * @param {function(T): boolean|number} match_or_startIndex The predicate function that defines the conditions of the elements to search for. / The zero-based starting index of the search.
 * @param {function(T): boolean|number=} match_or_count The predicate function that defines the conditions of the elements to search for. / The number of elements in the section to search.
 * @param {function(T): boolean=} match The predicate function that defines the conditions of the elements to search for.
 * @return {number}
 */
multiplex.List.prototype.findLastIndex = function(match_or_startIndex, match_or_count, match) {};

/**
 * Performs the specified action on each element of the List.
 * @param {function(T, number): void} action The action function to perform on each element of an List; the second parameter of the function represents the index of the source element.
 * @return {void}
 */
multiplex.List.prototype.forEach = function(action) {};

/**
 * Gets the element at the specified index.
 * @param {number} index The zero-based index of the element to get.
 * @return {T}
 */
multiplex.List.prototype.get = function(index) {};

/**
 * Creates a shallow copy of a range of elements in the source List.
 * @param {number} index The zero-based List index at which the range starts.
 * @param {number} count The number of elements in the range.
 * @return {!multiplex.List}
 */
multiplex.List.prototype.getRange = function(index, count) {};

/**
 *   Searches for the specified object and returns the zero-based index of the first occurrence within the entire List, if found; otherwise, –1.
 *   \@param item The object to locate in the List.
 *   Searches for the specified object and returns the zero-based index of the first occurrence within
 *   the range of elements in the List that extends from the specified index to the last element, if found; otherwise, –1.
 *   \@param item The object to locate in the List.
 *   \@param index The zero-based starting index of the search. 0 (zero) is valid in an empty list.
 * @param {T} item
 * @param {number=} index
 * @return {number}
 */
multiplex.List.prototype.indexOf = function(item, index) {};

/**
 * Inserts an element into the List at the specified index.
 * @param {number} index The zero-based index at which item should be inserted.
 * @param {T} item The object to insert. The value can be null for reference types.
 * @return {void}
 */
multiplex.List.prototype.insert = function(index, item) {};

/**
 * Inserts the elements of a collection into the List at the specified index.
 * @param {number} index The zero-based index at which item should be inserted.
 * @param {!multiplex.Iterable<T>} collection The collection whose elements should be inserted into the List.
 * @return {void}
 */
multiplex.List.prototype.insertRange = function(index, collection) {};

/**
 * Gets an Array wrapper around the List.
 * @return {!Array<T>}
 */
multiplex.List.prototype.items = function() {};

/**
 *   Searches for the specified object and returns the zero-based index of the last occurrence within the entire List, if found; otherwise, –1.
 *   \@param item The object to locate in the List.
 *   Searches for the specified object and returns the zero-based index of the last occurrence
 *   within the range of elements in the List that extends from the specified index to the last element if found; otherwise, –1.
 *   \@param item The object to locate in the List.
 *   \@param index The zero-based starting index of the search. 0 (zero) is valid in an empty list.
 * @param {T} item
 * @param {number=} index
 * @return {number}
 */
multiplex.List.prototype.lastIndexOf = function(item, index) {};

/**
 * Removes the first occurrence of a specific object from the List.
 * @param {T} item The object to remove from the List.
 * @return {boolean}
 */
multiplex.List.prototype.remove = function(item) {};

/**
 * Removes all the elements that match the conditions defined by the specified predicate.
 * @param {function(T): boolean} match The predicate function that defines the conditions of the elements to remove.
 * @return {number}
 */
multiplex.List.prototype.removeAll = function(match) {};

/**
 * Removes the element at the specified index of the List.
 * @param {number} index The zero-based index of the element to remove.
 * @return {void}
 */
multiplex.List.prototype.removeAt = function(index) {};

/**
 * Removes a range of elements from the List.
 * @param {number} index The zero-based index of the element to remove.
 * @param {number} count The number of elements to remove.
 * @return {void}
 */
multiplex.List.prototype.removeRange = function(index, count) {};

/**
 * Reverses the order of the elements in the entire List
 * Reverses the order of the elements in the entire List
 * @param {number=} index The zero-based starting index of the range to reverse.
 * @param {number=} count The number of elements in the range to reverse.
 * @return {?|void}
 */
multiplex.List.prototype.reverse = function(index, count) {};

/**
 * Sets the element at the specified index.
 * @param {number} index The zero-based index of the element to set.
 * @param {T} value
 * @return {void}
 */
multiplex.List.prototype.set = function(index, value) {};

/**
 * Sorts the elements in the entire List using the default comparer.
 * Sorts the elements in the entire List using the specified Comparison.
 * Sorts the elements in the entire List using the specified comparer.
 * Sorts the elements in a range of elements in List using the specified comparer.
 * @param {function(T, T): number|!multiplex.Comparer<T>|number=} comparison_or_comparer_or_index The comparison function to use when comparing elements. / The Comparer implementation to use when comparing elements. / The zero-based starting index of the range to sort.
 * @param {number=} count The length of the range to sort.
 * @param {!multiplex.Comparer<T>=} comparer The Comparer implementation to use when comparing elements.
 * @return {void}
 */
multiplex.List.prototype.sort = function(comparison_or_comparer_or_index, count, comparer) {};

/**
 * Copies the elements of the List to a new array.
 * @return {!Array<T>}
 */
multiplex.List.prototype.toArray = function() {};

/**
 * Determines whether every element in the List matches the conditions defined by the specified predicate.
 * @param {function(T): boolean} match The Predicate function that defines the conditions to check against the elements.
 * @return {boolean}
 */
multiplex.List.prototype.trueForAll = function(match) {};
/**
 * @record
 * @struct
 */
multiplex.ListConstructor = function() {};

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.SortedList = function() {};

/**
 * Adds an element with the specified key and value into the SortedList.
 * @param {TKey} key The key of the element to add.
 * @param {TValue} value The value of the element to add. The value can be null for reference types.
 * @return {void}
 */
multiplex.SortedList.prototype.add = function(key, value) {};

/**
 * Gets the value associated with the specified key.
 * @param {TKey} key The key whose value to get.
 * @return {TValue}
 */
multiplex.SortedList.prototype.get = function(key) {};

/**
 * Gets or sets the number of elements that the SortedList can contain.
 * @param {number=} value The number of elements that the SortedList can contain.
 * @return {number}
 */
multiplex.SortedList.prototype.capacity = function(value) {};

/**
 * Removes all elements from the SortedList.
 * @return {void}
 */
multiplex.SortedList.prototype.clear = function() {};

/**
 * Gets the Comparer for the sorted list.
 * @return {!multiplex.Comparer<TKey>}
 */
multiplex.SortedList.prototype.comparer = function() {};

/**
 * Determines whether the SortedList contains a specific key.
 * @param {TKey} key The key to locate in the SortedList.
 * @return {boolean}
 */
multiplex.SortedList.prototype.containsKey = function(key) {};

/**
 * Determines whether the SortedList contains a specific value.
 * @param {TValue} value The value to locate in the SortedList.
 * @return {boolean}
 */
multiplex.SortedList.prototype.containsValue = function(value) {};

/**
 * Gets a collection containing the keys in the SortedList, in sorted order.
 * @return {!multiplex.Collection<TKey>}
 */
multiplex.SortedList.prototype.keys = function() {};

/**
 * Gets a collection containing the values in the SortedLis.
 * @return {!multiplex.Collection<TValue>}
 */
multiplex.SortedList.prototype.values = function() {};

/**
 * Searches for the specified key and returns the zero-based index within the entire SortedList.
 * @param {TKey} key The key to locate in the SortedList.
 * @return {number}
 */
multiplex.SortedList.prototype.indexOfKey = function(key) {};

/**
 * Searches for the specified value and returns the zero-based index of the first occurrence within the entire SortedList.
 * @param {TValue} value The value to locate in the SortedList.
 * @return {number}
 */
multiplex.SortedList.prototype.indexOfValue = function(value) {};

/**
 * Removes the element with the specified key from the SortedList.
 * Returns true if the element is successfully removed; otherwise, false. This method also returns false if key was not found in the original SortedList.
 * @param {TKey} key The key of the element to remove.
 * @return {boolean}
 */
multiplex.SortedList.prototype.remove = function(key) {};

/**
 * Removes the element at the specified index of the SortedList.
 * @param {number} index The zero-based index of the element to remove.
 * @return {void}
 */
multiplex.SortedList.prototype.removeAt = function(index) {};

/**
 * Sets the value associated with the specified key.
 * @param {TKey} key The key whose value to get or set.
 * @param {TValue} value The value associated with the specified key.
 * @return {void}
 */
multiplex.SortedList.prototype.set = function(key, value) {};

/**
 * Sets the capacity to the actual number of elements in the SortedList, if that number is less than 90 percent of current capacity.
 * @return {void}
 */
multiplex.SortedList.prototype.trimExcess = function() {};

/**
 * Gets the value associated with the specified key.
 * @param {TKey} key The key whose value to get.
 * @param {function(TValue): void} callback When this method returns, callback method is called with the value
 * associated with the specified key, if the key is found; otherwise, null for the type of the value parameter.
 * @return {boolean}
 */
multiplex.SortedList.prototype.tryGetValue = function(key, callback) {};
/**
 * @record
 * @struct
 */
multiplex.SortedListConstructor = function() {};

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */
/**
 * @record
 * @struct
 */
multiplex.KeyValuePair = function() {};
 /** @type {TKey} */
multiplex.KeyValuePair.prototype.key;
 /** @type {TValue} */
multiplex.KeyValuePair.prototype.value;
/**
 * @record
 * @struct
 */
multiplex.KeyValuePairConstructor = function() {};

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.Dictionary = function() {};

/**
 * Adds an element with the provided key and value to the Dictionary.
 * @param {TKey} key The object to use as the key of the element to add.
 * @param {TValue} value The object to use as the value of the element to add.
 * @return {void}
 */
multiplex.Dictionary.prototype.add = function(key, value) {};

/**
 * Removes all keys and values from the Dictionary.
 * @return {void}
 */
multiplex.Dictionary.prototype.clear = function() {};

/**
 * Determines whether the Dictionary contains the specified key.
 * @param {TKey} key The key to locate in the Dictionary.
 * @return {boolean}
 */
multiplex.Dictionary.prototype.containsKey = function(key) {};

/**
 * Determines whether the Dictionary contains a specific value.
 * @param {TValue} value The value to locate in the Dictionary.
 * @return {boolean}
 */
multiplex.Dictionary.prototype.containsValue = function(value) {};

/**
 * Copies the Dictionary keys to an existing one-dimensional Array, starting at the specified array index.
 * @param {!Array<TKey>|!Array<!multiplex.KeyValuePair<TKey, TValue>>} array The one-dimensional Array that is the destination of the elements copied from Dictionary keys.
 * @param {number} arrayIndex The zero-based index in array at which copying begins.
 * @return {void}
 */
multiplex.Dictionary.prototype.copyTo = function(array, arrayIndex) {};

/**
 * Gets a Collection containing the keys of the Dictionary.
 * @return {!multiplex.Collection<TKey>}
 */
multiplex.Dictionary.prototype.keys = function() {};

/**
 * Gets a Collection containing the values in the Dictionary.
 * @return {!multiplex.Collection<TValue>}
 */
multiplex.Dictionary.prototype.values = function() {};

/**
 * Gets element with the specified key.
 * @param {TKey} key The key of the element to get.
 * @return {TValue}
 */
multiplex.Dictionary.prototype.get = function(key) {};

/**
 * Sets the element with the specified key.
 * @param {TKey} key The key of the element to set.
 * @param {TValue} value The object to use as the value of the element to set.
 * @return {void}
 */
multiplex.Dictionary.prototype.set = function(key, value) {};

/**
 * Gets the value associated with the specified key.
 * @param {TKey} key The key whose value to get.
 * @param {function(TValue): void} callback When this method returns, callback method is called with the value
 * associated with the specified key, if the key is found; otherwise, null for the type of the value parameter.
 * @return {boolean}
 */
multiplex.Dictionary.prototype.tryGetValue = function(key, callback) {};

/**
 * Removes the element with the specified key from the Dictionary.
 * @param {TKey} key The key of the element to remove.
 * @return {boolean}
 */
multiplex.Dictionary.prototype.remove = function(key) {};
/**
 * @record
 * @struct
 */
multiplex.DictionaryConstructor = function() {};

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.HashSet = function() {};

/**
 * Adds an element to the current set.
 * @param {T} item The element to add to the set.
 * @return {boolean}
 */
multiplex.HashSet.prototype.add = function(item) {};

/**
 * Removes all elements from a HashSet object.
 * @return {void}
 */
multiplex.HashSet.prototype.clear = function() {};

/**
 * Copies the elements of a HashSet object to an array.
 * Copies the elements of a HashSet object to an array. starting at the specified array index.
 * Copies the elements of a HashSet object to an array.
 * @param {!Array<T>} array The one-dimensional array that is the destination of the elements copied from the HashSet object.
 * @param {number=} arrayIndex The zero-based index in array at which copying begins.
 * @param {number=} count The number of elements to copy to array.
 * @return {void}
 */
multiplex.HashSet.prototype.copyTo = function(array, arrayIndex, count) {};

/**
 * Gets the EqualityComparer object that is used to determine equality for the values in the set.
 * @return {!multiplex.EqualityComparer<T>}
 */
multiplex.HashSet.prototype.comparer = function() {};

/**
 * Removes the specified element from a HashSet object.
 * @param {T} item The element to remove.
 * @return {boolean}
 */
multiplex.HashSet.prototype.remove = function(item) {};

/**
 * Removes all elements that match the conditions defined by the specified predicate from a HashSet collection.
 * @param {function(T): boolean} match The predicate function that defines the conditions of the elements to remove.
 * @return {number}
 */
multiplex.HashSet.prototype.removeWhere = function(match) {};

/**
 * Removes all elements in the specified collection from the current set.
 * @param {!multiplex.Iterable<T>} other The collection of items to remove from the set.
 * @return {void}
 */
multiplex.HashSet.prototype.exceptWith = function(other) {};

/**
 * Modifies the current set so that it contains only elements that are also in a specified collection.
 * @param {!multiplex.Iterable<T>} other The collection to compare to the current set.
 * @return {void}
 */
multiplex.HashSet.prototype.intersectWith = function(other) {};

/**
 * Determines whether the current set is a proper (strict) subset of a specified collection.
 * @param {!multiplex.Iterable<T>} other The collection to compare to the current set.
 * @return {boolean}
 */
multiplex.HashSet.prototype.isProperSubsetOf = function(other) {};

/**
 * Determines whether the current set is a proper (strict) superset of a specified collection.
 * @param {!multiplex.Iterable<T>} other The collection to compare to the current set.
 * @return {boolean}
 */
multiplex.HashSet.prototype.isProperSupersetOf = function(other) {};

/**
 * Determines whether a set is a subset of a specified collection.
 * @param {!multiplex.Iterable<T>} other The collection to compare to the current set.
 * @return {boolean}
 */
multiplex.HashSet.prototype.isSubsetOf = function(other) {};

/**
 * Determines whether the current set is a superset of a specified collection.
 * @param {!multiplex.Iterable<T>} other The collection to compare to the current set.
 * @return {boolean}
 */
multiplex.HashSet.prototype.isSupersetOf = function(other) {};

/**
 * Determines whether the current set overlaps with the specified collection.
 * @param {!multiplex.Iterable<T>} other The collection to compare to the current set.
 * @return {boolean}
 */
multiplex.HashSet.prototype.overlaps = function(other) {};

/**
 * Determines whether the current set and the specified collection contain the same elements.
 * @param {!multiplex.Iterable<T>} other The collection to compare to the current set.
 * @return {boolean}
 */
multiplex.HashSet.prototype.setEquals = function(other) {};

/**
 * Modifies the current set so that it contains only elements that are present
 * either in the current set or in the specified collection, but not both.
 * @param {!multiplex.Iterable<T>} other The collection to compare to the current set.
 * @return {void}
 */
multiplex.HashSet.prototype.symmetricExceptWith = function(other) {};

/**
 * Modifies the current set so that it contains all elements that are present
 * in either the current set or the specified collection.
 * @param {!multiplex.Iterable<T>} other The collection to compare to the current set.
 * @return {void}
 */
multiplex.HashSet.prototype.unionWith = function(other) {};
/**
 * @record
 * @struct
 */
multiplex.HashSetConstructor = function() {};

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */
/**
 * @record
 * @struct
 */
multiplex.LinkedListNode = function() {};

/**
 * Gets the value contained in the node.
 * @return {T}
 */
multiplex.LinkedListNode.prototype.value = function() {};

/**
 * Gets the LinkedList that the LinkedListNode belongs to.
 * @return {!multiplex.LinkedList<T>}
 */
multiplex.LinkedListNode.prototype.list = function() {};

/**
 * Gets the next node in the LinkedList.
 * @return {!multiplex.LinkedListNode}
 */
multiplex.LinkedListNode.prototype.next = function() {};

/**
 * Gets the previous node in the LinkedList.
 * @return {!multiplex.LinkedListNode}
 */
multiplex.LinkedListNode.prototype.previous = function() {};
/**
 * @record
 * @struct
 */
multiplex.LinkedListNodeConstructor = function() {};

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.LinkedList = function() {};

/**
 * Adds an item to the LinkedList.
 * @param {T} item The object to add to the LinkedList.
 * @return {void}
 */
multiplex.LinkedList.prototype.add = function(item) {};

/**
 * Removes all nodes from the LinkedList.
 * @return {void}
 */
multiplex.LinkedList.prototype.clear = function() {};

/**
 * Determines whether a value is in the LinkedList.
 * @param {T} item
 * @return {boolean}
 */
multiplex.LinkedList.prototype.contains = function(item) {};

/**
 * Gets the first node of the LinkedList.
 * @return {!multiplex.LinkedListNode<T>}
 */
multiplex.LinkedList.prototype.getFirst = function() {};

/**
 * Gets the last node of the LinkedList.
 * @return {!multiplex.LinkedListNode<T>}
 */
multiplex.LinkedList.prototype.getLast = function() {};

/**
 * Adds the specified new node after the specified existing node in the LinkedList and returns the new LinkedListNode.
 * Adds the specified new node after the specified existing node in the LinkedList.
 * returns The new LinkedListNode containing value.
 * @param {!multiplex.LinkedListNode<T>} node The LinkedListNode after which to insert newNode.
 * @param {!multiplex.LinkedListNode<T>|T} newNode_or_value The new LinkedListNode to add to the LinkedList. / The value to add to the LinkedList.
 * @return {!multiplex.LinkedListNode<T>}
 */
multiplex.LinkedList.prototype.addAfter = function(node, newNode_or_value) {};

/**
 * Adds the specified new node before the specified existing node in the LinkedList.
 * returns The new LinkedListNode.
 * Adds the specified new node before the specified existing node in the LinkedList.
 * returns The new LinkedListNode containing value.
 * @param {!multiplex.LinkedListNode<T>} node The LinkedListNode before which to insert newNode.
 * @param {!multiplex.LinkedListNode<T>|T} newNode_or_value The new LinkedListNode to add to the LinkedList. / The value to add to the LinkedList.
 * @return {!multiplex.LinkedListNode<T>}
 */
multiplex.LinkedList.prototype.addBefore = function(node, newNode_or_value) {};

/**
 * Adds the specified new node at the start of the LinkedList.
 * returns The new LinkedListNode.
 * Adds the specified new node at the start of the LinkedList.
 * returns The new LinkedListNode containing value.
 * @param {!multiplex.LinkedListNode<T>|T} node_or_value The new LinkedListNode to add at the start of the LinkedList. / The value to add at the start of the LinkedList.
 * @return {!multiplex.LinkedListNode<T>}
 */
multiplex.LinkedList.prototype.addFirst = function(node_or_value) {};

/**
 * Adds the specified new node at the end of the LinkedList.
 * returns The new LinkedListNode.
 * Adds the specified new node at the end of the LinkedList.
 * returns The new LinkedListNode containing value.
 * @param {!multiplex.LinkedListNode<T>|T} node_or_value The new LinkedListNode to add at the end of the LinkedList. / The value to add at the end of the LinkedList.
 * @return {!multiplex.LinkedListNode<T>}
 */
multiplex.LinkedList.prototype.addLast = function(node_or_value) {};

/**
 * Finds the first node that contains the specified value.
 * @param {T} value The value to locate in the LinkedList.
 * @return {!multiplex.LinkedListNode<T>}
 */
multiplex.LinkedList.prototype.find = function(value) {};

/**
 * Finds the last node that contains the specified value.
 * @param {T} value The value to locate in the LinkedList.
 * @return {!multiplex.LinkedListNode<T>}
 */
multiplex.LinkedList.prototype.findLast = function(value) {};

/**
 * Removes the node at the start of the LinkedList.
 * returns true if the node is successfully removed; otherwise, false.
 * This method also returns false if value was not found in the original LinkedList.
 * Removes the first occurrence of the specified value from the LinkedList.
 * returns true if the element containing value is successfully removed; otherwise, false.
 * This method also returns false if value was not found in the original LinkedList.
 * @param {!multiplex.LinkedListNode<T>|T} node_or_value The value to remove from the LinkedList.
 * @return {boolean}
 */
multiplex.LinkedList.prototype.remove = function(node_or_value) {};

/**
 * Removes the node at the start of the LinkedList.
 * @return {void}
 */
multiplex.LinkedList.prototype.removeFirst = function() {};

/**
 * Removes the node at the end of the LinkedList.
 * @return {void}
 */
multiplex.LinkedList.prototype.removeLast = function() {};
/**
 * @record
 * @struct
 */
multiplex.LinkedListConstructor = function() {};

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.Queue = function() {};

/**
 * Removes all objects from the Queue.
 * @return {void}
 */
multiplex.Queue.prototype.clear = function() {};

/**
 * Determines whether an element is in the Queue.
 * @param {T} item The object to locate in the Queue.
 * @return {boolean}
 */
multiplex.Queue.prototype.contains = function(item) {};

/**
 * Removes and returns the object at the beginning of the Queue.
 * @return {T}
 */
multiplex.Queue.prototype.dequeue = function() {};

/**
 * Adds an object to the end of the Queue.
 * @param {T} item The object to add to the Queue.
 * @return {void}
 */
multiplex.Queue.prototype.enqueue = function(item) {};

/**
 * Returns the object at the beginning of the Queue without removing it.
 * @return {T}
 */
multiplex.Queue.prototype.peek = function() {};

/**
 * Copies the Queue to a new array.
 * @return {!Array<T>}
 */
multiplex.Queue.prototype.toArray = function() {};
/**
 * @record
 * @struct
 */
multiplex.QueueConstructor = function() {};

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.Stack = function() {};

/**
 * Removes all objects from the Stack.
 * @return {void}
 */
multiplex.Stack.prototype.clear = function() {};

/**
 * Determines whether an element is in the Stack.
 * @param {T} item The object to locate in the Stack.
 * @return {boolean}
 */
multiplex.Stack.prototype.contains = function(item) {};

/**
 * Returns the object at the top of the Stack without removing it.
 * @return {T}
 */
multiplex.Stack.prototype.peek = function() {};

/**
 *   Removes and returns the object at the top of the Stack.
 * @return {T}
 */
multiplex.Stack.prototype.pop = function() {};

/**
 * Inserts an object at the top of the Stack.
 * @param {T} item The object to push onto the Stack.
 * @return {void}
 */
multiplex.Stack.prototype.push = function(item) {};

/**
 *   Copies the Stack to a new array.
 * @return {!Array<T>}
 */
multiplex.Stack.prototype.toArray = function() {};
/**
 * @record
 * @struct
 */
multiplex.StackConstructor = function() {};

/* TODO: ConstructSignature: multiplex */

/* TODO: ConstructSignature: multiplex */
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.Lookup = function() {};

/**
 * Determines whether a specified key exists in the Lookup.
 * @param {TKey|!multiplex.Grouping<TKey, TElement>} key_or_item The key to search for in the Lookup.
 * @return {boolean}
 */
multiplex.Lookup.prototype.contains = function(key_or_item) {};

/**
 * Gets the value associated with the specified key.
 * @param {TKey} key The key of the element to add.
 * @return {!multiplex.Enumerable<TElement>}
 */
multiplex.Lookup.prototype.get = function(key) {};
/**
 * @extends {multiplex.Collection}
 * @record
 * @struct
 */
multiplex.Grouping = function() {};
 /** @type {TKey} */
multiplex.Grouping.prototype.key;
/**
 * @extends {multiplex.Enumerable}
 * @record
 * @struct
 */
multiplex.OrderedEnumerable = function() {};

/**
 * Performs a subsequent ordering on the elements of an OrderedEnumerable<TElement> according to a key.
 * @template TKey
 * @param {function(TElement): TKey} keySelector The selector used to extract the key for each element.
 * @param {!multiplex.Comparer<TKey>} comparer The Comparer used to compare keys for placement in the returned sequence.
 * @param {boolean} descending true to sort the elements in descending order; false to sort the elements in ascending order.
 * @return {!multiplex.OrderedEnumerable}
 */
multiplex.OrderedEnumerable.prototype.createOrderedEnumerable = function(keySelector, comparer, descending) {};

/**
 * Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.
 * Returns an OrderedEnumerable whose elements are sorted in descending order according to a key.
 * Performs a subsequent ordering of the elements in a sequence in ascending order by using a specified comparer.
 * Returns an OrderedEnumerable whose elements are sorted according to a key.
 * @template TKey
 * @param {function(TElement): TKey} keySelector A function to extract a key from each element.
 * @param {!multiplex.Comparer<TKey>=} comparer A Comparer to compare keys.
 * @return {!multiplex.OrderedEnumerable}
 */
multiplex.OrderedEnumerable.prototype.thenBy = function(keySelector, comparer) {};

/**
 * Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.
 * Returns an OrderedEnumerable whose elements are sorted in descending order according to a key.
 * Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.
 * Returns an OrderedEnumerable whose elements are sorted in descending order according to a key.
 * @template TKey
 * @param {function(TElement): TKey} keySelector A function to extract a key from each element.
 * @param {!multiplex.Comparer<TKey>=} comparer A Comparer to compare keys.
 * @return {!multiplex.OrderedEnumerable}
 */
multiplex.OrderedEnumerable.prototype.thenByDescending = function(keySelector, comparer) {};

/**
 * Applies an accumulator function over a sequence.
 * Returns the final accumulator value.
 * Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.
 * Returns the final accumulator value.
 * Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value,
 * and the specified function is used to select the result value.
 * Returns the final accumulator value.
 * @template TAccumulate, TResult
 * @param {function(T, T): T|TAccumulate} func_or_seed An accumulator function to be invoked on each element. / The initial accumulator value.
 * @param {function(TAccumulate, T): TAccumulate=} func An accumulator function to be invoked on each element.
 * @param {function(TAccumulate): TResult=} resultSelector A function to transform the final accumulator value into the result value.
 * @return {T|TAccumulate|TResult}
 */
multiplex.Enumerable.prototype.aggregate = function(func_or_seed, func, resultSelector) {};

/**
 * Determines whether all elements of a sequence satisfy a condition.
 * Returns true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false.
 * @param {function(T): boolean} predicate A function to test each element for a condition.
 * @return {boolean}
 */
multiplex.Enumerable.prototype.all = function(predicate) {};

/**
 * Determines whether a sequence contains any elements.
 * Returns true if the source sequence contains any elements; otherwise, false.
 * Determines whether any element of a sequence satisfies a condition.
 * Returns true if any elements in the source sequence pass the test in the specified predicate; otherwise, false.
 * @param {function(T): boolean=} predicate A function to test each element for a condition.
 * @return {boolean}
 */
multiplex.Enumerable.prototype.any = function(predicate) {};

/**
 * Returns the input typed as Enumerable.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.asEnumerable = function() {};

/**
 * Computes the average of a sequence of numeric values.
 * Computes the average of a sequence of numeric values that are obtained by invoking a transform function on each element of the input sequence.
 * @param {function(number): number=} selector A transform function to apply to each element.
 * @return {number}
 */
multiplex.Enumerable.prototype.average = function(selector) {};

/**
 * Concatenates two sequences.
 * @param {!multiplex.Iterable<T>} second The sequence to concatenate to the first sequence.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.concat = function(second) {};

/**
 * Determines whether a sequence contains a specified element by using the default equality comparer.
 * Returns the last element of a sequence that satisfies a specified condition.
 * @param {T} value The value to locate in the sequence.
 * @param {!multiplex.EqualityComparer<T>=} comparer An equality comparer to compare values.
 * @return {boolean}
 */
multiplex.Enumerable.prototype.contains = function(value, comparer) {};

/**
 * Returns the number of elements in a sequence.
 * Returns a number that represents how many elements in the specified sequence satisfy a condition.
 * @param {function(T): boolean=} predicate A function to test each element for a condition.
 * @return {number}
 */
multiplex.Enumerable.prototype.count = function(predicate) {};

/**
 * Returns the elements of the specified sequence or null if the sequence is empty.
 * Returns the elements of the specified sequence or the specified value in  a singleton collection if the sequence is empty.
 * @param {T=} defaultValue The value to return if the sequence is empty.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.defaultIfEmpty = function(defaultValue) {};

/**
 * Returns distinct elements from a sequence by using the default equality comparer to compare values.
 * Produces the set difference of two sequences by using the EqualityComparer to compare values.
 * @param {!multiplex.EqualityComparer<T>=} comparer An EqualityComparer to compare values.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.distinct = function(comparer) {};

/**
 * Produces the set difference of two sequences by using the default equality comparer to compare values.
 * Produces the set difference of two sequences by using the specified EqualityComparer to compare values.
 * @param {!multiplex.Iterable<T>} second An Iterable whose elements that also occur in the first sequence will cause those elements to be removed from the returned sequence.
 * @param {!multiplex.EqualityComparer<T>=} comparer An EqualityComparer to compare values.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.except = function(second, comparer) {};

/**
 * Returns the element at a specified index in a sequence. Throws an error if the index is less than 0 or greater than or equal to the number of elements in source.
 * @param {number} index The zero-based index of the element to retrieve.
 * @return {T}
 */
multiplex.Enumerable.prototype.elementAt = function(index) {};

/**
 * Returns the first element of a sequence. this method throws an exception if there is no element in the sequence.
 * Returns the first element in a sequence that satisfies a specified condition. this method throws an exception if there is no element in the sequence.
 * @param {function(T): boolean=} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
 * @return {T}
 */
multiplex.Enumerable.prototype.first = function(predicate) {};

/**
 * Returns the first element of a sequence, or null if the sequence contains no elements.
 * Returns the first element of the sequence that satisfies a condition or null if no such element is found.
 * Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.
 * @param {function(T): boolean=} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
 * @param {T=} defaultValue The value to return if no element exists with specified condition.
 * @return {T}
 */
multiplex.Enumerable.prototype.firstOrDefault = function(predicate, defaultValue) {};

/**
 * Performs the specified action on each element of an Enumerable.
 * @param {function(T, number): void} action The action function to perform on each element of an Enumerable; the second parameter of the function represents the index of the source element.
 * @return {void}
 */
multiplex.Enumerable.prototype.forEach = function(action) {};

/**
 * Groups the elements of a sequence according to a specified key selector function.
 * Groups the elements of a sequence according to a specified key selector function.
 * Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function.
 * Groups the elements of a sequence according to a key selector function.
 * The keys are compared by using a comparer and each group's elements are projected by using a specified function.
 * Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function.
 * Groups the elements of a sequence according to a key selector function.
 * The keys are compared by using a comparer and each group's elements are projected by using a specified function.
 * @template TKey, TElement, TResult
 * @param {function(T): TKey} keySelector A function to extract the key for each element.
 * @param {!multiplex.EqualityComparer<TKey>|function(T): TElement=} comparer_or_elementSelector An equality comparer to compare values. / A function to map each source element to an element in the Grouping.
 * @param {!multiplex.EqualityComparer<TKey>|function(TKey, !multiplex.Iterable<TElement>): TResult=} comparer_or_resultSelector An equality comparer to compare values. / A function to extract the key for each element.
 * @param {!multiplex.EqualityComparer<TKey>=} comparer An equality comparer to compare values.
 * @return {!multiplex.Enumerable<!multiplex.Grouping<TKey, T>>|!multiplex.Enumerable<!multiplex.Grouping<TKey, TElement>>|!multiplex.Enumerable<TResult>}
 */
multiplex.Enumerable.prototype.groupBy = function(keySelector, comparer_or_elementSelector, comparer_or_resultSelector, comparer) {};

/**
 * Correlates the elements of two sequences based on equality of keys and groups the results. The default equality comparer is used to compare keys.
 * Correlates the elements of two sequences based on key equality and groups the results. A specified EqualityComparer is used to compare keys.
 * @template TInner, TKey, TResult
 * @param {!multiplex.Iterable<TInner>} inner The sequence to join to the current sequence.
 * @param {function(T): TKey} outerKeySelector A function to extract the join key from each element of the first sequence.
 * @param {function(TInner): TKey} innerKeySelector A function to extract the join key from each element of the second sequence.
 * @param {function(T, !multiplex.Enumerable<TInner>): TResult} resultSelector A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.
 * @param {!multiplex.EqualityComparer<TKey>=} comparer An equality comparer to compare values.
 * @return {!multiplex.Enumerable<TResult>}
 */
multiplex.Enumerable.prototype.groupJoin = function(inner, outerKeySelector, innerKeySelector, resultSelector, comparer) {};

/**
 * Produces the set intersection of two sequences by using the default equality comparer to compare values.
 * Produces the set intersection of two sequences by using the default equality comparer to compare values.
 * @param {!multiplex.Iterable<T>} second An Iterable whose distinct elements that also appear in the first sequence will be returned.
 * @param {!multiplex.EqualityComparer<T>=} comparer An EqualityComparer to compare values.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.intersect = function(second, comparer) {};

/**
 * Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.
 * Correlates the elements of two sequences based on matching keys. A specified EqualityComparer is used to compare keys.
 * @template TInner, TKey, TResult
 * @param {!multiplex.Iterable<TInner>} inner The sequence to join to the current sequence.
 * @param {function(T): TKey} outerKeySelector A function to extract the join key from each element of the first sequence.
 * @param {function(TInner): TKey} innerKeySelector A function to extract the join key from each element of the second sequence.
 * @param {function(T, TInner): TResult} resultSelector A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.
 * @param {!multiplex.EqualityComparer<TKey>=} comparer An equality comparer to compare values.
 * @return {!multiplex.Enumerable<TResult>}
 */
multiplex.Enumerable.prototype.join = function(inner, outerKeySelector, innerKeySelector, resultSelector, comparer) {};

/**
 * Returns the last element of a sequence.
 * Returns the last element of a sequence that satisfies a specified condition.
 * @param {function(T): boolean=} predicate A function to test each source element for a condition.
 * @return {T}
 */
multiplex.Enumerable.prototype.last = function(predicate) {};

/**
 * Returns the first element of a sequence, or null if the sequence contains no elements.
 * Returns the last element of a sequence, or null if the sequence contains no elements.
 * Returns the last element of a sequence that satisfies a condition or null if no such element is found.
 * @param {function(T): boolean=} predicate A function to test each source element for a condition.
 * @param {T=} defaultValue The value to return if no element exists with specified condition.
 * @return {T}
 */
multiplex.Enumerable.prototype.lastOrDefault = function(predicate, defaultValue) {};

/**
 * Returns the maximum value in a sequence of values.
 * Invokes a transform function on each element of a sequence and returns the maximum value.
 * @template TResult
 * @param {function(T): TResult=} selector A transform function to apply to each element.
 * @return {T|TResult}
 */
multiplex.Enumerable.prototype.max = function(selector) {};

/**
 * Returns the minimum value in a sequence of values.
 * Invokes a transform function on each element of a sequence and returns the minimum value.
 * @template TResult
 * @param {function(T): TResult=} selector A transform function to apply to each element.
 * @return {T|TResult}
 */
multiplex.Enumerable.prototype.min = function(selector) {};

/**
 * Filters the elements of an Enumerable based on a specified type.
 * @template TResult
 * @param {function(new: (TResult), !Array<?>): ?} type The type to filter the elements of the sequence on.
 * @return {!multiplex.Enumerable<TResult>}
 */
multiplex.Enumerable.prototype.ofType = function(type) {};

/**
 * Sorts the elements of a sequence in ascending order by using a specified comparer.
 * Sorts the elements of a sequence in ascending order by using a specified comparer.
 * Returns an OrderedEnumerable whose elements are sorted according to a key.
 * @template TKey
 * @param {function(T): TKey} keySelector A function to extract a key from each element.
 * @param {!multiplex.EqualityComparer<TKey>=} comparer A Comparer to compare keys.
 * @return {!multiplex.OrderedEnumerable<T>}
 */
multiplex.Enumerable.prototype.orderBy = function(keySelector, comparer) {};

/**
 * Sorts the elements of a sequence in descending order by using a specified comparer.
 * Returns an OrderedEnumerable whose elements are sorted according to a key.
 * Returns an OrderedEnumerable whose elements are sorted in descending order according to a key.
 * Sorts the elements of a sequence in descending order by using a specified comparer.
 * Returns an OrderedEnumerable whose elements are sorted in descending order according to a key.
 * @template TKey
 * @param {function(T): TKey} keySelector A function to extract a key from each element.
 * @param {!multiplex.EqualityComparer<TKey>=} comparer A Comparer to compare keys.
 * @return {!multiplex.OrderedEnumerable<T>}
 */
multiplex.Enumerable.prototype.orderByDescending = function(keySelector, comparer) {};

/**
 * Inverts the order of the elements in a sequence.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.reverse = function() {};

/**
 * Determines whether two sequences are equal by comparing the elements by using the default equality comparer for their type.
 * Determines whether two sequences are equal by comparing their elements by using a specified EqualityComparer.
 * @param {!multiplex.Iterable<T>} second An Iterable to compare to the first sequence.
 * @param {!multiplex.EqualityComparer<T>=} comparer The EqualityComparer to compare values.
 * @return {boolean}
 */
multiplex.Enumerable.prototype.sequenceEqual = function(second, comparer) {};

/**
 * Projects each element of a sequence into a new form. May incorporate the element's index.
 * @template TResult
 * @param {function(T, number): TResult} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
 * @return {!multiplex.Enumerable<TResult>}
 */
multiplex.Enumerable.prototype.select = function(selector) {};

/**
 * Projects each element of a sequence to an Enumerable and flattens the resulting sequences into one sequence. The index of each source element is used in the projected form of that element.
 * @template TCollection, TResult
 * @param {function(T, number): !multiplex.Iterable<TCollection>} collectionSelector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
 * @param {function(T, TCollection): TResult=} resultSelector A transform function to apply to each element of the intermediate sequence.
 * @return {!multiplex.Enumerable<TResult>}
 */
multiplex.Enumerable.prototype.selectMany = function(collectionSelector, resultSelector) {};

/**
 * Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.
 * Returns the only element of a sequence that satisfies a specified condition, and throws an exception if more than one such element exists.
 * @param {function(T): boolean=} predicate A function to test each source element for a condition.
 * @return {T}
 */
multiplex.Enumerable.prototype.single = function(predicate) {};

/**
 * Returns the only element of a sequence, or a null if the sequence is empty; this method throws an exception if there is more than one element in the sequence.
 * Returns the only element of a sequence that satisfies a specified condition or a null if no such element exists; this method throws an exception if more than one element satisfies the condition.
 * Returns the only element of a sequence that satisfies a specified condition or a default value if no such element exists; this method throws an exception if more than one element satisfies the condition.
 * @param {function(T): boolean=} predicate A function to test each source element for a condition.
 * @param {T=} defaultValue The value to return if no element exists with specified condition.
 * @return {T}
 */
multiplex.Enumerable.prototype.singleOrDefault = function(predicate, defaultValue) {};

/**
 * Bypasses a specified number of elements in a sequence and then returns the remaining elements.
 * @param {number} count The number of elements to skip before returning the remaining elements.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.skip = function(count) {};

/**
 * Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.
 * Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.
 * @param {function(T): boolean|function(T, number): boolean} predicate A function to test each source element for a condition. / A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.skipWhile = function(predicate) {};

/**
 * Computes the sum of a sequence of values.
 * Computes the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.
 * @param {function(T): number=} selector A transform function to apply to each element.
 * @return {number}
 */
multiplex.Enumerable.prototype.sum = function(selector) {};

/**
 * Returns a specified number of contiguous elements from the start of a sequence.
 * @param {number} count The number of elements to return.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.take = function(count) {};

/**
 * Returns elements from a sequence as long as a specified condition is true.
 * Returns elements from a sequence as long as a specified condition is true. The element's index is used in the logic of the predicate function.
 * @param {function(T): boolean|function(T, number): boolean} predicate A function to test each source element for a condition. / A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.takeWhile = function(predicate) {};

/**
 * Creates an array from an Enumerable.
 * @return {!Array<T>}
 */
multiplex.Enumerable.prototype.toArray = function() {};

/**
 * Creates a Dictionary from an Enumerable according to a specified key selector function.
 * Creates a Dictionary from an Enumerable according to specified key selector and comparer.
 * Creates a Dictionary from an Enumerable according to specified key selector and element selector functions.
 * Creates a Dictionary from an Enumerable according to a specified key selector function, a comparer, and an element selector function.
 * @template TKey, TElement
 * @param {function(T): TKey} keySelector A function to extract a key from each element.
 * @param {!multiplex.EqualityComparer<TKey>|function(T): TElement=} comparer_or_elementSelector An equality comparer to compare values. / A transform function to produce a result element value from each element.
 * @param {!multiplex.EqualityComparer<TKey>=} comparer An equality comparer to compare values.
 * @return {!multiplex.Dictionary<TKey, T>|!multiplex.Dictionary<TKey, TElement>}
 */
multiplex.Enumerable.prototype.toDictionary = function(keySelector, comparer_or_elementSelector, comparer) {};

/**
 * Creates a List from an Enumerable.
 * @return {!multiplex.List<T>}
 */
multiplex.Enumerable.prototype.toList = function() {};

/**
 * Creates a Lookup from an Enumerable according to a specified key selector function.
 * Creates a Lookup from an Enumerable according to a specified key selector function and comparer.
 * Creates a Lookup from an Enumerable according to specified key selector and element selector functions.
 * Creates a Lookup from an Enumerable according to a specified key selector function, a comparer and an element selector function.
 * @template TKey, TElement
 * @param {function(T): TKey} keySelector A function to extract a key from each element.
 * @param {!multiplex.EqualityComparer<TKey>|function(T): TElement=} comparer_or_elementSelector An equality comparer to compare values. / A transform function to produce a result element value from each element.
 * @param {!multiplex.EqualityComparer<TKey>=} comparer An equality comparer to compare values.
 * @return {!multiplex.Lookup<TKey, T>|!multiplex.Lookup<TKey, TElement>}
 */
multiplex.Enumerable.prototype.toLookup = function(keySelector, comparer_or_elementSelector, comparer) {};

/**
 * Produces the set union of two sequences by using the default equality comparer.
 * Produces the set union of two sequences by using a specified EqualityComparer.
 * @param {!multiplex.Iterable<T>} second An Iterable whose distinct elements form the second set for the union.
 * @param {!multiplex.EqualityComparer<T>=} comparer The EqualityComparer to compare values.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.union = function(second, comparer) {};

/**
 * Filters a sequence of values based on a predicate.
 * Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.
 * @param {function(T): boolean|function(T, number): boolean} predicate A function to test each source element for a condition. / A function to test each source element for a condition; the second parameter of the function represents the index of the source element.
 * @return {!multiplex.Enumerable}
 */
multiplex.Enumerable.prototype.where = function(predicate) {};

/**
 * Merges two sequences by using the specified predicate function.
 * @template TSecond, TResult
 * @param {!multiplex.Iterable<TSecond>} second The second sequence to merge.
 * @param {function(T, TSecond): TResult} resultSelector A function that specifies how to merge the elements from the two sequences.
 * @return {!multiplex.Enumerable<TResult>}
 */
multiplex.Enumerable.prototype.zip = function(second, resultSelector) {};
/**
 * @record
 * @struct
 */
multiplex.ArrayLike = function() {};
 /** @type {number} */
multiplex.ArrayLike.prototype.length;

/* TODO: IndexSignature: multiplex */
/**
 * @record
 * @struct
 */
multiplex.RuntimeComparer = function() {};

/**
 * Serves as a hash function for a particular type.
 * @return {number}
 */
multiplex.RuntimeComparer.prototype.__hash__ = function() {};

/**
 * Determines whether the specified Object is equal to the current Object.
 * @param {?} obj
 * @return {boolean}
 */
multiplex.RuntimeComparer.prototype.__equals__ = function(obj) {};
/**
 * @record
 * @struct
 */
multiplex.MultiplexRuntime = function() {};

/**
 * Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures such as a hash table.
 * @param {?} obj An object to retrieve the hash code for.
 * @return {number}
 */
multiplex.MultiplexRuntime.prototype.hash = function(obj) {};

/**
 * Determines whether the specified object instances are considered equal.
 * @param {?} objA The first object to compare.
 * @param {?} objB The second object to compare.
 * @return {boolean}
 */
multiplex.MultiplexRuntime.prototype.equals = function(objA, objB) {};

/**
 * Performs a comparison of two objects of the same type and returns a value indicating whether one object is less than, equal to, or greater than the other.
 * @template T
 * @param {T} objA The first object to compare.
 * @param {T} objB The second object to compare.
 * @return {number}
 */
multiplex.MultiplexRuntime.prototype.compare = function(objA, objB) {};

/**
 * Creates A function expression from the specified string lambda expression
 * Creates A function expression from the specified string lambda expression
 * Creates A function expression from the specified string lambda expression
 * Creates A function expression from the specified string lambda expression
 * @template T, TResult, T1, T2, T3
 * @param {string} exp String lambda expression.
 * @return {function(T): TResult|function(T1, T2): TResult|function(T1, T2, T3): TResult|function(!Array<?>): TResult}
 */
multiplex.MultiplexRuntime.prototype.lambda = function(exp) {};

/**
 * Defines new or modifies existing properties directly on the specified object, returning the object.
 * @template T
 * @param {T} obj The object on which to define or modify properties.
 * @param {!String} prop The name of the property to be defined or modified.
 * @param {!PropertyDescriptor} attributes The descriptor for the property being defined or modified.
 * @return {T}
 */
multiplex.MultiplexRuntime.prototype.define = function(obj, prop, attributes) {};

/**
 * Extends the given object by implementing supplied members.
 * @template T
 * @param {T} obj The object on which to define or modify properties.
 * @param {!Object} properties Represetnts the mixin source object
 * @param {!PropertyDescriptor=} attributes The descriptor for the property being defined or modified.
 * @return {T}
 */
multiplex.MultiplexRuntime.prototype.mixin = function(obj, properties, attributes) {};
/**
 * @record
 * @struct
 */
multiplex.MultiplexStatic = function() {};

/* TODO: CallSignature: multiplex */

/* TODO: CallSignature: multiplex */

/* TODO: CallSignature: multiplex */

/* TODO: CallSignature: multiplex */

/* TODO: CallSignature: multiplex */
 /** @type {!multiplex.MultiplexRuntime} */
multiplex.MultiplexStatic.prototype.runtime;
 /** @type {!multiplex.EnumeratorConstructor} */
multiplex.MultiplexStatic.prototype.Enumerator;
 /** @type {!multiplex.EnumerableConstructor} */
multiplex.MultiplexStatic.prototype.Enumerable;
 /** @type {!multiplex.ComparerConstructor} */
multiplex.MultiplexStatic.prototype.Comparer;
 /** @type {!multiplex.EqualityComparerConstructor} */
multiplex.MultiplexStatic.prototype.EqualityComparer;
 /** @type {!multiplex.CollectionConstructor} */
multiplex.MultiplexStatic.prototype.Collection;
 /** @type {!multiplex.ReadOnlyCollectionConstructor} */
multiplex.MultiplexStatic.prototype.ReadOnlyCollection;
 /** @type {!multiplex.ListConstructor} */
multiplex.MultiplexStatic.prototype.List;
 /** @type {!multiplex.SortedListConstructor} */
multiplex.MultiplexStatic.prototype.SortedList;
 /** @type {!multiplex.KeyValuePairConstructor} */
multiplex.MultiplexStatic.prototype.KeyValuePair;
 /** @type {!multiplex.DictionaryConstructor} */
multiplex.MultiplexStatic.prototype.Dictionary;
 /** @type {!multiplex.HashSetConstructor} */
multiplex.MultiplexStatic.prototype.HashSet;
 /** @type {!multiplex.LinkedListNodeConstructor} */
multiplex.MultiplexStatic.prototype.LinkedListNode;
 /** @type {!multiplex.LinkedListConstructor} */
multiplex.MultiplexStatic.prototype.LinkedList;
 /** @type {!multiplex.QueueConstructor} */
multiplex.MultiplexStatic.prototype.Queue;
 /** @type {!multiplex.StackConstructor} */
multiplex.MultiplexStatic.prototype.Stack;

/**
 * Gets and combines hash code for the given parameters, calls the overridden "hash" method when available.
 * @param {...?} obj
 * @return {number}
 */
multiplex.MultiplexStatic.prototype.hash = function(obj) {};

/**
 * Determines whether the specified object instances are considered equal. calls the overridden "equals" method when available.
 * Determines whether the specified object instances are considered equal. calls the overridden "equals" method when available.
 * @param {?} objA The first object to compare.
 * @param {?} objB The second object to compare.
 * @param {!multiplex.EqualityComparer<?>=} comparer An equality comparer to compare values.
 * @return {boolean}
 */
multiplex.MultiplexStatic.prototype.equals = function(objA, objB, comparer) {};

/**
 * Performs a comparison of two objects of the same type and returns a value indicating whether one object is less than, equal to, or greater than the other.
 * @template T
 * @param {T} objA The first object to compare.
 * @param {T} objB The second object to compare.
 * @return {number}
 */
multiplex.MultiplexStatic.prototype.compare = function(objA, objB) {};

/**
 * Extends Enumerable extension methods to the given type
 * @param {!Function} type The type to extend.
 * @return {void}
 */
multiplex.MultiplexStatic.prototype.enumerableExtend = function(type) {};

/**
 * Returns an empty Enumerable.
 * @template T
 * @return {!multiplex.Enumerable<T>}
 */
multiplex.MultiplexStatic.prototype.empty = function() {};

/**
 * Detects if an object is Enumerable.
 * @param {?} obj An object to check its Enumerability.
 * @return {boolean}
 */
multiplex.MultiplexStatic.prototype.is = function(obj) {};

/**
 * Generates a sequence of integral numbers within a specified range.
 * @param {number} start The value of the first integer in the sequence.
 * @param {number} count The number of sequential integers to generate.
 * @return {!multiplex.Enumerable<number>}
 */
multiplex.MultiplexStatic.prototype.range = function(start, count) {};

/**
 * Generates a sequence that contains one repeated value.
 * @template T
 * @param {T} element The value to be repeated.
 * @param {number} count The number of times to repeat the value in the generated sequence.
 * @return {!multiplex.Enumerable<T>}
 */
multiplex.MultiplexStatic.prototype.repeat = function(element, count) {};
