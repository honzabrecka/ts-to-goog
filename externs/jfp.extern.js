/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/jfp/index.d.ts:
 /** @type {!j.JfpStatic} */
var j;

/* TODO: ExportAssignment in  */

/* TODO: NamespaceExportDeclaration in  */
/**
 * @record
 * @struct
 */
j.JfpStatic = function() {};

/* TODO: CallSignature: j */

/* TODO: CallSignature: j */
/**
 * @record
 * @struct
 */
j.JfpCurriedOutput = function() {};

/**
 * Removes falsey values from an array
 * @param {!Array<?>} values The array to compact
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.compact = function(values) {};

/**
 * Clones and concatenates two arrays
 * @param {!Array<?>} values1 The array to concatenate to
 * @param {!Array<?>} values2 The array to concatenate with
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.concat = function(values1, values2) {};

/**
 * Appends value to clone of destination array
 * @param {?} value The value to add to the end of an array
 * @param {!Array<?>} destination The array to be cloned and appended to
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.conj = function(value, destination) {};

/**
 * Prepends value to clone of destination array
 * @param {?} value The value to add to the beginning of an array
 * @param {!Array<?>} destination The array to be cloned and prepended to
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.cons = function(value, destination) {};

/**
 * Returns a copy of passed array
 * @param {!Array<?>} list
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.copyArray = function(list) {};

/**
 * Takes the difference of sets A and B where the difference is A - B
 * @param {!Array<?>} lista
 * @param {!Array<?>} listb
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.difference = function(lista, listb) {};

/**
 * Drops value at specified index from clone of array
 * @param {number} index Index to perform drop at
 * @param {!Array<?>} values Array to remove value from
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.drop = function(index, values) {};

/**
 * Drops first element from clone of values array
 * @param {!Array<?>} values Array to drop first value of
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.dropFirst = function(values) {};

/**
 * Drops last element from clone of values array
 * @param {!Array<?>} values Array to drop last value from
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.dropLast = function(values) {};

/**
 * Drops values from array until predicate is satisfied
 * @param {function(!Array<?>): boolean} predicate
 * @param {!Array<?>} list
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.dropUntil = function(predicate, list) {};

/**
 * Performs iterable function on each value of provided array
 * @param {function(?): void} iteratable
 * @param {!Array<?>} values Array to operate on
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.each = function(iteratable, values) {};

/**
 * Filters all values not passing provided predicate
 * @param {function(?): boolean} predicate Function which performs a boolean resultant operation on a value of the array
 * @param {!Array<?>} values Array to filter
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.filter = function(predicate, values) {};

/**
 * Finds the first value in an array that satisfies provided predicate
 * @param {function(?): boolean} predicate Function which performs a boolean resultant operation on a value of the array
 * @param {!Array<?>} values Array to run predicate against
 * @return {?}
 */
j.JfpStatic.prototype.find = function(predicate, values) {};

/**
 * Drops last element of array
 * @param {!Array<?>} list
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.init = function(list) {};

/**
 * Takes the intersection of two arrays
 * @param {!Array<?>} lista
 * @param {!Array<?>} listb
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.intersect = function(lista, listb) {};

/**
 * Returns the first value in an array
 * @param {!Array<?>} values Array of values
 * @return {?}
 */
j.JfpStatic.prototype.first = function(values) {};

/**
 * Returns last value in an array
 * @param {!Array<?>} values Array of values
 * @return {?}
 */
j.JfpStatic.prototype.last = function(values) {};

/**
 * Returns last index of an array
 * @param {!Array<?>} values Array
 * @return {number}
 */
j.JfpStatic.prototype.lastIndex = function(values) {};

/**
 * Maps functions into new array using mapper function
 * @param {function(?): ?} mapper Mapping function
 * @param {!Array<?>} values Array to map
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.map = function(mapper, values) {};

/**
 * Takes multiple partitions of a list using a partitioning predicate and criteria
 * @param {function(?, ?): boolean} predicate
 * @param {!Array<?>} criteria
 * @param {!Array<?>} list
 * @return {!Array<!Array<?>>}
 */
j.JfpStatic.prototype.multiPartition = function(predicate, criteria, list) {};

/**
 * Counts number of list values which satisfy predicate
 * @param {function(?): boolean} predicate
 * @param {!Array<?>} list
 * @return {number}
 */
j.JfpStatic.prototype.numberOf = function(predicate, list) {};

/**
 * Partitions array on values which pass and do not pass predicate
 * @param {function(?): boolean} predicate
 * @param {!Array<?>} list
 * @return {!Array<!Array<?>>}
 */
j.JfpStatic.prototype.partition = function(predicate, list) {};

/**
 * Returns nth value of passed array
 * @param {number} index Array index
 * @param {!Array<?>} values Array of values
 * @return {?}
 */
j.JfpStatic.prototype.nth = function(index, values) {};

/**
 * Reduces array using reducer function
 * Reduces array using reducer function
 * @param {function(?, ?): ?} reducer Function to reduce values with
 * @param {!Array<?>} values Array to reduce
 * @param {?=} initialCondition Initial value to use in first reduction application
 * @return {?}
 */
j.JfpStatic.prototype.reduce = function(reducer, values, initialCondition) {};

/**
 * Returns all but the first element of array
 * @param {!Array<?>} values Array to return the rest of
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.rest = function(values) {};

/**
 * Returns a slice of an array
 * Returns a slice of an array
 * @param {number} initialIndex index to start slicing at
 * @param {!Array<?>} values Array to slice
 * @param {number=} lastIndex Index to end slice with
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.slice = function(initialIndex, values, lastIndex) {};

/**
 * Returns true if at least one array element satisfies predicate, else false
 * @param {function(?): boolean} predicate
 * @param {!Array<?>} list
 * @return {boolean}
 */
j.JfpStatic.prototype.some = function(predicate, list) {};

/**
 * Sorts values in an array with an optional comparator arguments
 * @param {!Array<?>} list
 * @param {function(?, ?): number=} comparator
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.sort = function(list, comparator) {};

/**
 * Takes the symmetric difference of two arrays
 * @param {!Array<?>} lista
 * @param {!Array<?>} listb
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.symmetricDifference = function(lista, listb) {};

/**
 * Returns first n values of an array
 * @param {number} quantity Number of values to return
 * @param {!Array<?>} values Array of values to take from
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.take = function(quantity, values) {};

/**
 * Takes values from array until predicate is satisfied
 * @param {function(?): boolean} predicate
 * @param {!Array<?>} list
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.takeUntil = function(predicate, list) {};

/**
 * Takes the union of two arrays
 * @param {!Array<?>} lista
 * @param {!Array<?>} listb
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.union = function(lista, listb) {};

/**
 * Returns array of values with duplicates removed
 * @param {!Array<?>} values Array of values to filter by uniqueness
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.unique = function(values) {};

/**
 * Zips two arrays together into an array of arrays
 * @param {!Array<?>} lista
 * @param {!Array<?>} listb
 * @return {!Array<!Array<?>>}
 */
j.JfpStatic.prototype.zip = function(lista, listb) {};

/**
 * Returns preferred value if truthy, otherwise returns default value
 * Returns provided value if truthy or matches datatype, otherwise returns default value
 * @param {?} defaultValue Default value
 * @param {?} preferredValue Preferred value
 * @param {string=} datatype Type preferred value should be
 * @return {?}
 */
j.JfpStatic.prototype.either = function(defaultValue, preferredValue, datatype) {};

/**
 * Returns preferred value if truthy, otherwise returns default value
 * @param {?} defaultValue Default value
 * @param {?} preferredValue Preferred value
 * @param {boolean} predicateValue Boolean switch to return default or preferred value
 * @return {?}
 */
j.JfpStatic.prototype.eitherIf = function(defaultValue, preferredValue, predicateValue) {};

/**
 * Returns provided value if truthy, otherwise returns default value
 * @param {?} defaultValue Default value
 * @param {?} preferredValue Preferred value
 * @param {function(?): boolean} predicate Predicate function preferred value is tested against
 * @return {?}
 */
j.JfpStatic.prototype.eitherWhen = function(defaultValue, preferredValue, predicate) {};

/**
 * Returns preferred value if truthy, otherwise null
 * Returns preferred value if truthy or matches datatype, otherwise null
 * @param {?} preferredValue Preferred value to check
 * @param {string=} datatype Datatype to match
 * @return {?}
 */
j.JfpStatic.prototype.maybe = function(preferredValue, datatype) {};

/**
 * Executes function if value is truthy, otherwise returns default
 * @param {?} defaultValue
 * @param {function(!Array<?>): ?} userFn
 * @param {?} value
 * @return {?}
 */
j.JfpStatic.prototype.shortCircuit = function(defaultValue, userFn, value) {};

/**
 * Executes function when condition is true
 * Executes function when condition is true
 * @param {boolean} predicateValue Value to set behavior execution
 * @param {function(!Array<?>): ?} userFunction Behavior to execute
 * @param {...?} args
 * @return {?}
 */
j.JfpStatic.prototype.when = function(predicateValue, userFunction, args) {};

/**
 * Converts value to decimal equivalent returns null if non-convertable
 * @param {string|number} value String or number value to convert
 * @return {number}
 */
j.JfpStatic.prototype.toDec = function(value) {};

/**
 * Converts an object literal into an array of values
 * @param {!Object} value Object literal
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.toValues = function(value) {};

/**
 * Returns function which returns provided value
 * Signature: (any) -> () -> any
 * @param {?} value Value to return from produced function
 * @return {function(!Array<?>): ?}
 */
j.JfpStatic.prototype.always = function(value) {};

/**
 * Applies an array of values to a function
 * @param {function(!Array<?>): ?} userFn Function to perform application against
 * @param {!Array<?>} values Array of arguments for function
 * @return {void}
 */
j.JfpStatic.prototype.apply = function(userFn, values) {};

/**
 * Composes a set of functions into a new single function
 * @param {...function(!Array<?>): ?} args
 * @return {function(!Array<?>): ?}
 */
j.JfpStatic.prototype.compose = function(args) {};

/**
 * Counts the number of arguments in a function declaration
 * @param {function(!Array<?>): ?} userFn Function to count arguments of
 * @return {number}
 */
j.JfpStatic.prototype.countArguments = function(userFn) {};

/**
 * Curries function until all arguments are satisfied
 * @param {function(!Array<?>): ?} userFn Function to curry
 * @param {...?} args
 * @return {function(!Array<?>): ?|?}
 */
j.JfpStatic.prototype.curry = function(userFn, args) {};

/**
 * Executes passed function
 * @param {function(!Array<?>): ?} userFn
 * @return {?}
 */
j.JfpStatic.prototype.execute = function(userFn) {};

/**
 * Gets type of passed value
 * @param {?} value
 * @return {string}
 */
j.JfpStatic.prototype.getType = function(value) {};

/**
 * Returns value passed to the function
 * @param {?} value Value to return
 * @return {?}
 */
j.JfpStatic.prototype.identity = function(value) {};

/**
 * Applies values to a function and returns partially applied function
 * @param {function(!Array<?>): ?} userFn Function to apply values to
 * @param {...?} args
 * @return {function(!Array<?>): ?}
 */
j.JfpStatic.prototype.partial = function(userFn, args) {};

/**
 * Pipelines or chains functions producing a single final output
 * @param {?} value Initial condition for function pipelining
 * @param {...function(!Array<?>): ?} args
 * @return {?}
 */
j.JfpStatic.prototype.pipeline = function(value, args) {};

/**
 * Recursion function to allow for tail-optimized recursion
 * @param {function(!Array<?>): ?} userFn Function to recur on
 * @param {...?} args
 * @return {?}
 */
j.JfpStatic.prototype.recur = function(userFn, args) {};

/**
 * Reverses arguments of provided function
 * @param {function(!Array<?>): ?} userFn
 * @return {function(!Array<?>): ?}
 */
j.JfpStatic.prototype.reverseArgs = function(userFn) {};

/**
 * Performs a right partial application on a function
 * @param {function(!Array<?>): ?} userFn Function to apply arguments
 * @param {...?} args
 * @return {?}
 */
j.JfpStatic.prototype.rpartial = function(userFn, args) {};

/**
 * Performs a split partial application
 * @param {function(!Array<?>): ?} userFn
 * @param {!Array<?>} leftArgs
 * @param {!Array<?>} rightArgs
 * @return {function(!Array<?>): ?}
 */
j.JfpStatic.prototype.splitPartial = function(userFn, leftArgs, rightArgs) {};

/**
 * Returns true if array contains provided value, else false
 * @param {?} value
 * @param {!Array<?>} list
 * @return {boolean}
 */
j.JfpStatic.prototype.contains = function(value, list) {};

/**
 * Checks value equality of two arguments
 * @param {?} valuea
 * @param {?} valueb
 * @return {boolean}
 */
j.JfpStatic.prototype.equal = function(valuea, valueb) {};

/**
 * Checks if every value in an array passes a predicate
 * @param {function(?): boolean} predicate
 * @param {!Array<?>} list
 * @return {boolean}
 */
j.JfpStatic.prototype.every = function(predicate, list) {};

/**
 * Checks if value is an empty string
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isEmptyString = function(value) {};

/**
 * Checks if value is null
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isNull = function(value) {};

/**
 * Checks if value is of type passed as string
 * @param {string} type
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isType = function(type, value) {};

/**
 * Checks if passed value is an array
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isArray = function(value) {};

/**
 * Checks if passed value is a boolean
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isBoolean = function(value) {};

/**
 * Checks if passed value is a function
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isFunction = function(value) {};

/**
 * Checks if passed value is a number
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isNumber = function(value) {};

/**
 * Checks if passed value is an object
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isObject = function(value) {};

/**
 * Checks if passed value is a string
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isString = function(value) {};

/**
 * Checks if passed value is undefined
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isUndefined = function(value) {};

/**
 * Checks if passed value is a tuple
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isTuple = function(value) {};

/**
 * Checks if passed value is a tuple of length 2
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isPair = function(value) {};

/**
 * Checks if passed value is a tuple of length 1
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isSingle = function(value) {};

/**
 * Checks if passed value is a tuple of length 3
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isTriple = function(value) {};

/**
 * Checks that passed value is an array which contains a first value
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.hasFirst = function(value) {};

/**
 * Checks if passed value is either a number or a numeric string
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isNumeric = function(value) {};

/**
 * Checks if passed value is a primitive Javascript type
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isPrimitive = function(value) {};

/**
 * Checks if passed value is truthy
 * @param {?} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isTruthy = function(value) {};

/**
 * Returns boolean inverse of passed value
 * @param {boolean} value
 * @return {boolean}
 */
j.JfpStatic.prototype.not = function(value) {};

/**
 * Clones values to an optional depth
 * @param {?} value
 * @param {number=} depth
 * @return {?}
 */
j.JfpStatic.prototype.clone = function(value, depth) {};

/**
 * Composes functions together in common nested order
 * @param {...function(!Array<?>): ?} args
 * @return {function(!Array<?>): ?}
 */
j.JfpStatic.prototype.compose = function(args) {};

/**
 * Curries passed function and applies optional arguments
 * @param {function(!Array<?>): ?} fn
 * @param {...?} args
 * @return {function(!Array<?>): ?}
 */
j.JfpStatic.prototype.curry = function(fn, args) {};

/**
 * Returns either typed value based on type parameter
 * @param {string} type
 * @param {?} defaultValue
 * @param {?} value
 * @return {?}
 */
j.JfpStatic.prototype.eitherType = function(type, defaultValue, value) {};

/**
 * Returns maybe typed value based on type parameter
 * @param {string} type
 * @param {?} value
 * @return {?}
 */
j.JfpStatic.prototype.maybeType = function(type, value) {};

/**
 * Returns a partially applied function with remaining arguments reversed
 * @param {function(!Array<?>): ?} fn
 * @param {...?} args
 * @return {function(!Array<?>): ?}
 */
j.JfpStatic.prototype.partialReverse = function(fn, args) {};

/**
 * Passes chains functions together with an initial arguments
 * @param {?} value
 * @param {...function(!Array<?>): ?} args
 * @return {?}
 */
j.JfpStatic.prototype.pipeline = function(value, args) {};

/**
 * Composes functions executing from left to right
 * @param {...function(!Array<?>): ?} args
 * @return {function(!Array<?>): ?}
 */
j.JfpStatic.prototype.rcompose = function(args) {};

/**
 * Executes a trampolined tail-optimized recursive function
 * @param {function(!Array<?>): ?} fn
 * @return {?}
 */
j.JfpStatic.prototype.recur = function(fn) {};

/**
 * Repeats action n times
 * @param {number} count
 * @param {function(!Array<?>): ?} action
 * @return {?}
 */
j.JfpStatic.prototype.repeat = function(count, action) {};

/**
 * Outputs a string composed of n copies of base string
 * @param {number} count
 * @param {string} value
 * @return {string}
 */
j.JfpStatic.prototype.times = function(count, value) {};

/**
 * Converts string to decimal safely
 * @param {?} value
 * @return {number}
 */
j.JfpStatic.prototype.toDec = function(value) {};

/**
 * Adds two numbers
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
j.JfpStatic.prototype.add = function(a, b) {};

/**
 * Divides first number by second
 * @param {number} numerator
 * @param {number} denominator
 * @return {number}
 */
j.JfpStatic.prototype.divide = function(numerator, denominator) {};

/**
 * Takes the factorial of passed number
 * @param {number} n
 * @return {number}
 */
j.JfpStatic.prototype.fac = function(n) {};

/**
 * Increments a number
 * @param {number} value
 * @return {number}
 */
j.JfpStatic.prototype.inc = function(value) {};

/**
 * Takes the maximum of two numbers
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
j.JfpStatic.prototype.max = function(a, b) {};

/**
 * Takes the minimum of two numbers
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
j.JfpStatic.prototype.min = function(a, b) {};

/**
 * Takes the modulus of first number against second number
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
j.JfpStatic.prototype.mod = function(a, b) {};

/**
 * Takes mathematical modulo of first number against second number
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
j.JfpStatic.prototype.modulo = function(a, b) {};

/**
 * Multiplies two numbers
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
j.JfpStatic.prototype.multiply = function(a, b) {};

/**
 * Creates a range either from 0 to an integer or from one integer to another
 * @param {number} end_or_start
 * @param {number=} end
 * @return {!Array<number>}
 */
j.JfpStatic.prototype.range = function(end_or_start, end) {};

/**
 * Subtracts second argument from first
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
j.JfpStatic.prototype.subtract = function(a, b) {};

/**
 * Truncates number to floor if positive or to ceil if negative
 * @param {number} value
 * @return {number}
 */
j.JfpStatic.prototype.truncate = function(value) {};

/**
 * Checks if number is negative
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isNegative = function(value) {};

/**
 * Checks if number is positive
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isPositive = function(value) {};

/**
 * Checks if number is 0
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isZero = function(value) {};

/**
 * Checks if number is between two values
 * @param {!Array<number>} bounds
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.between = function(bounds, value) {};

/**
 * Checks if value is even
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isEven = function(value) {};

/**
 * Checks if value is an integer
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isInt = function(value) {};

/**
 * Checks if value is a multiple of base value
 * @param {number} base
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isMultipleOf = function(base, value) {};

/**
 * Checks if value is positive or 0
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isNonNegative = function(value) {};

/**
 * Checks if value is negative or 0
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isNonPositive = function(value) {};

/**
 * Checks if value is not 0
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isNonZero = function(value) {};

/**
 * Checks if value is odd
 * @param {number} value
 * @return {boolean}
 */
j.JfpStatic.prototype.isOdd = function(value) {};

/**
 * Checks if a is greater or equal to b
 * @param {number} a
 * @param {number} b
 * @return {boolean}
 */
j.JfpStatic.prototype.geq = function(a, b) {};

/**
 * Checks if a is greater than b
 * @param {number} a
 * @param {number} b
 * @return {boolean}
 */
j.JfpStatic.prototype.greater = function(a, b) {};

/**
 * Checks if a is less than or equal to b
 * @param {number} a
 * @param {number} b
 * @return {boolean}
 */
j.JfpStatic.prototype.leq = function(a, b) {};

/**
 * Checks if a is less than b
 * @param {number} a
 * @param {number} b
 * @return {boolean}
 */
j.JfpStatic.prototype.less = function(a, b) {};

/**
 * Gets object keys
 * @param {!Object} dataset
 * @return {!Array<string>}
 */
j.JfpStatic.prototype.getKeys = function(dataset) {};

/**
 * Merges right object into a copy of left object
 * @param {!Object} left
 * @param {!Object} right
 * @return {!Object}
 */
j.JfpStatic.prototype.merge = function(left, right) {};

/**
 * Picks key from object
 * @param {string} key
 * @param {!Object} dataset
 * @return {?}
 */
j.JfpStatic.prototype.pick = function(key, dataset) {};

/**
 * Traverses object tree and retrieves dot-delimited key or returns null
 * @param {string} key
 * @param {!Object} dataset
 * @return {?}
 */
j.JfpStatic.prototype.deref = function(key, dataset) {};

/**
 * Picks value from object by key and returns a new object containing key value pair
 * @param {string} key
 * @param {!Object} dataset
 * @return {!Object}
 */
j.JfpStatic.prototype.pluck = function(key, dataset) {};

/**
 * Performs pluck across an array of keys, returns a single object containing all key value pairs
 * @param {!Array<string>} keys
 * @param {!Object} dataset
 * @return {!Object}
 */
j.JfpStatic.prototype.pluckKeys = function(keys, dataset) {};

/**
 * Converts object to an array of values
 * @param {!Object} dataset
 * @return {!Array<?>}
 */
j.JfpStatic.prototype.toValues = function(dataset) {};

/**
 * Transforms object to a new object containing transformed keys
 * @param {!Array<!Array<string>>} transformation
 * @param {!Object} dataset
 * @return {!Object}
 */
j.JfpStatic.prototype.transform = function(transformation, dataset) {};

/**
 * Performs a conjunction (and) operation on two or more booleans
 * @param {boolean} a
 * @param {boolean} b
 * @param {...boolean} args
 * @return {boolean}
 */
j.JfpStatic.prototype.and = function(a, b, args) {};

/**
 * Performs a disjunction (or) operation on two or more booleans
 * @param {boolean} a
 * @param {boolean} b
 * @param {...boolean} args
 * @return {boolean}
 */
j.JfpStatic.prototype.or = function(a, b, args) {};

/**
 * Performs an exclusive or operation on two booleans
 * @param {boolean} a
 * @param {boolean} b
 * @return {boolean}
 */
j.JfpStatic.prototype.xor = function(a, b) {};

/**
 * Creates composite predicate which performs each check on a value and then conjoins the result
 * @param {...function(!Array<?>): boolean} args
 * @return {function(!Array<?>): boolean}
 */
j.JfpStatic.prototype.composePredicate = function(args) {};
