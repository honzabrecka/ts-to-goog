/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/streamjs/index.d.ts:
/**
 * @constructor
 * @struct
 */
function Stream() {}

/**
 * @template T
 * @param {!Array<T>|string} elems_or_str
 * @return {!Stream<T>|!Stream<string>}
 */
Stream.from = function(elems_or_str) {};

/**
 * @template T
 * @param {...T} elems
 * @return {!Stream<T>}
 */
Stream.of = function(elems) {};

/**
 * @param {number} startInclusive
 * @param {number} endExclusive
 * @return {!Stream<number>}
 */
Stream.range = function(startInclusive, endExclusive) {};

/**
 * @param {number} startInclusive
 * @param {number} endInclusive
 * @return {!Stream<number>}
 */
Stream.rangeClosed = function(startInclusive, endInclusive) {};

/**
 * @template T
 * @param {!Stream.Supplier<T>} supplier
 * @return {!Stream<T>}
 */
Stream.generate = function(supplier) {};

/**
 * @template T
 * @param {T} seed
 * @param {!Stream.Function<T, T>} fn
 * @return {!Stream<T>}
 */
Stream.iterate = function(seed, fn) {};

/**
 * @param {!Stream.Predicate<T>|!RegExp|!Stream.Sample} predicate_or_regexp_or_sample
 * @return {boolean}
 */
Stream.prototype.anyMatch = function(predicate_or_regexp_or_sample) {};

/**
 * @param {!Stream.Predicate<T>|!RegExp|!Stream.Sample} predicate_or_regexp_or_sample
 * @return {boolean}
 */
Stream.prototype.allMatch = function(predicate_or_regexp_or_sample) {};

/**
 * @param {string=} path
 * @return {number}
 */
Stream.prototype.average = function(path) {};

/**
 * @param {string=} path
 * @return {number}
 */
Stream.prototype.avg = function(path) {};

/**
 * @param {!Stream.Collector<T>} collector
 * @return {T}
 */
Stream.prototype.collect = function(collector) {};

/**
 * @return {number}
 */
Stream.prototype.count = function() {};

/**
 * @return {!Stream}
 */
Stream.prototype.distinct = function() {};

/**
 * @param {!Stream.Predicate<T>|!RegExp|!Stream.Sample} predicate_or_regexp_or_sample
 * @return {!Stream|!Stream<string>}
 */
Stream.prototype.dropWhile = function(predicate_or_regexp_or_sample) {};

/**
 * @param {!Stream.Consumer<T>} consumer
 * @return {void}
 */
Stream.prototype.each = function(consumer) {};

/**
 * @param {!Stream.Predicate<T>|!RegExp|!Stream.Sample} predicate_or_regexp_or_sample
 * @return {!Stream|!Stream<string>}
 */
Stream.prototype.filter = function(predicate_or_regexp_or_sample) {};

/**
 * @return {!Stream.Optional<T>}
 */
Stream.prototype.findAny = function() {};

/**
 * @return {!Stream.Optional<T>}
 */
Stream.prototype.findFirst = function() {};

/**
 * @param {!Stream.Consumer<T>} consumer
 * @return {void}
 */
Stream.prototype.forEach = function(consumer) {};

/**
 * @param {!Stream.Function<T, string>|string} mapper_or_path
 * @return {!Stream.GroupingResult<T>}
 */
Stream.prototype.groupBy = function(mapper_or_path) {};

/**
 * @param {!Stream.Function<T, string>|string} mapper_or_path
 * @return {!Stream.GroupingResult<T>}
 */
Stream.prototype.groupingBy = function(mapper_or_path) {};

/**
 * @param {!Stream.Function<T, string>} keyMapper
 * @param {!Stream.Accumulator<T>=} mergeFunction
 * @return {!Stream.Map<T>}
 */
Stream.prototype.indexBy = function(keyMapper, mergeFunction) {};

/**
 * @template U
 * @param {!Stream.Function<T, U>} mapper
 * @return {!Stream<U>}
 */
Stream.prototype.map = function(mapper) {};

/**
 * @param {!Stream.Comparator<T>|string=} comparator_or_path
 * @return {!Stream.Optional<T>}
 */
Stream.prototype.max = function(comparator_or_path) {};

/**
 * @param {!Stream.Comparator<T>|string=} comparator_or_path
 * @return {!Stream.Optional<T>}
 */
Stream.prototype.min = function(comparator_or_path) {};

/**
 * @param {function(T): boolean|!RegExp} predicate_or_regexp
 * @return {boolean}
 */
Stream.prototype.noneMatch = function(predicate_or_regexp) {};

/**
 * @template U
 * @param {!Stream.Function<T, !Array<U>>} mapper
 * @return {!Stream<U>}
 */
Stream.prototype.flatMap = function(mapper) {};

/**
 * @return {!Stream.Iterator<T>}
 */
Stream.prototype.iterator = function() {};

/**
 * @param {string|!Stream.JoinOptions=} delimiter_or_options
 * @return {string}
 */
Stream.prototype.joining = function(delimiter_or_options) {};

/**
 * @param {string|!Stream.JoinOptions=} delimiter_or_options
 * @return {string}
 */
Stream.prototype.join = function(delimiter_or_options) {};

/**
 * @param {number} limit
 * @return {!Stream}
 */
Stream.prototype.limit = function(limit) {};

/**
 * @param {!Stream.Predicate<T>|!RegExp|number|!Stream.Sample} predicate_or_regexp_or_size_or_sample
 * @return {!Array<!Array<T>>}
 */
Stream.prototype.partitioningBy = function(predicate_or_regexp_or_size_or_sample) {};

/**
 * @param {!Stream.Predicate<T>|!Stream.Sample|!RegExp|number} predicate_or_sample_or_regexp_or_size
 * @return {!Array<!Array<T>>}
 */
Stream.prototype.partitionBy = function(predicate_or_sample_or_regexp_or_size) {};

/**
 * @param {!Stream.Consumer<T>} consumer
 * @return {!Stream}
 */
Stream.prototype.peek = function(consumer) {};

/**
 * @param {T|!Stream.Accumulator<T>} identity_or_accumulator
 * @param {!Stream.Accumulator<T>=} accumulator
 * @return {T|!Stream.Optional<T>}
 */
Stream.prototype.reduce = function(identity_or_accumulator, accumulator) {};

/**
 * @return {!Stream}
 */
Stream.prototype.reverse = function() {};

/**
 * @return {number}
 */
Stream.prototype.size = function() {};

/**
 * @param {!Stream.Comparator<T>|string=} comparator_or_path
 * @return {!Stream}
 */
Stream.prototype.sorted = function(comparator_or_path) {};

/**
 * @param {!Stream.Comparator<T>|string=} comparator_or_path
 * @return {!Stream}
 */
Stream.prototype.sort = function(comparator_or_path) {};

/**
 * @return {!Stream}
 */
Stream.prototype.shuffle = function() {};

/**
 * @param {number} n
 * @return {!Stream}
 */
Stream.prototype.skip = function(n) {};

/**
 * @param {number} begin
 * @param {number} end
 * @return {!Stream}
 */
Stream.prototype.slice = function(begin, end) {};

/**
 * @param {string=} path
 * @return {number}
 */
Stream.prototype.sum = function(path) {};

/**
 * @param {!Stream.Predicate<T>|!RegExp|!Stream.Sample} predicate_or_regexp_or_sample
 * @return {!Stream|!Stream<string>}
 */
Stream.prototype.takeWhile = function(predicate_or_regexp_or_sample) {};

/**
 * @return {!Array<T>}
 */
Stream.prototype.toArray = function() {};

/**
 * @return {!Array<T>}
 */
Stream.prototype.toList = function() {};

/**
 * @param {!Stream.Function<T, string>|string} keyMapper_or_path
 * @param {!Stream.Accumulator<T>=} mergeFunction
 * @return {!Stream.Map<T>}
 */
Stream.prototype.toMap = function(keyMapper_or_path, mergeFunction) {};
/**
 * @record
 * @struct
 */
Stream.Map = function() {};

/* TODO: IndexSignature: Stream */
/**
 * @record
 * @struct
 */
Stream.Sample = function() {};

/* TODO: IndexSignature: Stream */
/**
 * @record
 * @struct
 */
Stream.Accumulator = function() {};

/* TODO: CallSignature: Stream */
/**
 * @record
 * @struct
 */
Stream.Collector = function() {};
 /** @type {!Stream.Supplier<T>} */
Stream.Collector.prototype.supplier;
 /** @type {!Stream.Accumulator<T>} */
Stream.Collector.prototype.accumulator;
 /** @type {!Stream.Function<T, T>} */
Stream.Collector.prototype.finisher;
/**
 * @record
 * @struct
 */
Stream.Comparator = function() {};

/* TODO: CallSignature: Stream */
/**
 * @record
 * @struct
 */
Stream.Consumer = function() {};

/* TODO: CallSignature: Stream */
/**
 * @record
 * @struct
 */
Stream.Function = function() {};

/* TODO: CallSignature: Stream */
/**
 * @record
 * @struct
 */
Stream.GroupingResult = function() {};

/* TODO: IndexSignature: Stream */
/**
 * @record
 * @struct
 */
Stream.Iterator = function() {};
 /** @type {boolean} */
Stream.Iterator.prototype.done;

/**
 * @return {T}
 */
Stream.Iterator.prototype.next = function() {};
/**
 * @record
 * @struct
 */
Stream.JoinOptions = function() {};
 /** @type {string} */
Stream.JoinOptions.prototype.prefix;
 /** @type {string} */
Stream.JoinOptions.prototype.delimiter;
 /** @type {string} */
Stream.JoinOptions.prototype.suffix;
/**
 * @record
 * @struct
 */
Stream.Predicate = function() {};

/* TODO: CallSignature: Stream */
/**
 * @record
 * @struct
 */
Stream.Supplier = function() {};

/* TODO: CallSignature: Stream */
/**
 * @constructor
 * @struct
 */
Stream.Optional = function() {};

/**
 * @template T
 * @param {T} elem
 * @return {!Stream.Optional<T>}
 */
Stream.Optional.of = function(elem) {};

/**
 * @template T
 * @param {T} elem
 * @return {!Stream.Optional<T>}
 */
Stream.Optional.ofNullable = function(elem) {};

/**
 * @param {function(T): boolean} predicate
 * @return {!Stream.Optional}
 */
Stream.Optional.prototype.filter = function(predicate) {};

/**
 * @template U
 * @param {function(T): U} mapper
 * @return {!Stream.Optional<U>}
 */
Stream.Optional.prototype.map = function(mapper) {};

/**
 * @template U
 * @param {function(T): !Stream.Optional<U>} mapper
 * @return {!Stream.Optional<U>}
 */
Stream.Optional.prototype.flatMap = function(mapper) {};

/**
 * @return {boolean}
 */
Stream.Optional.prototype.isPresent = function() {};

/**
 * @return {T}
 */
Stream.Optional.prototype.get = function() {};

/**
 * @param {function(T): void} consumer
 * @return {void}
 */
Stream.Optional.prototype.ifPresent = function(consumer) {};

/**
 * @param {T} other
 * @return {T}
 */
Stream.Optional.prototype.orElse = function(other) {};

/**
 * @param {!Stream.Supplier<T>} supplier
 * @return {T}
 */
Stream.Optional.prototype.orElseGet = function(supplier) {};

/**
 * @param {?} error
 * @return {T}
 */
Stream.Optional.prototype.orElseThrow = function(error) {};
