/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/mandrill-api/index.d.ts:
/**
 * @record
 * @struct
 */
function ICallback() {}

/* TODO: CallSignature:  */
/**
 * @record
 * @struct
 */
function IErrorCallback() {}

/* TODO: CallSignature:  */

/**
 * @constructor
 * @struct
 * @param {string} apikey
 * @param {boolean=} debug
 */
function Mandrill(apikey, debug) {}
 /** @type {string} */
Mandrill.prototype.apikey;
 /** @type {boolean} */
Mandrill.prototype.debug;
 /** @type {!Templates} */
Mandrill.prototype.templates;
 /** @type {!Exports} */
Mandrill.prototype.exports;
 /** @type {!Users} */
Mandrill.prototype.users;
 /** @type {!Rejects} */
Mandrill.prototype.rejects;
 /** @type {!Inbound} */
Mandrill.prototype.inbound;
 /** @type {!Tags} */
Mandrill.prototype.tags;
 /** @type {!Messages} */
Mandrill.prototype.messages;
 /** @type {!Whitelists} */
Mandrill.prototype.whitelists;
 /** @type {!Ips} */
Mandrill.prototype.ips;
 /** @type {!Internal} */
Mandrill.prototype.internal;
 /** @type {!Subaccounts} */
Mandrill.prototype.subaccounts;
 /** @type {!Urls} */
Mandrill.prototype.urls;
 /** @type {!Webhooks} */
Mandrill.prototype.webhooks;
 /** @type {!Senders} */
Mandrill.prototype.senders;
 /** @type {!Metadata} */
Mandrill.prototype.metadata;
 /** @type {?} */
Mandrill.prototype.onerror;

/**
 * @param {string} uri
 * @param {?} params
 * @param {?=} onresult
 * @param {?=} onerror
 * @return {void}
 */
Mandrill.prototype.call = function(uri, params, onresult, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Templates(master) {}

/**
 * Add a new template
 * \@option params {String} name the name for the new template - must be unique
 * \@option params {String} from_email a default sending address for emails sent using this template
 * \@option params {String} from_name a default from name to be used
 * \@option params {String} subject a default subject line to be used
 * \@option params {String} code the HTML code for the template with mc:edit attributes for the editable elements
 * \@option params {String} text a default text part to be used when sending with this template
 * \@option params {Boolean} publish set to false to add a draft template without publishing
 * \@option params {Array} labels an optional array of up to 10 labels to use for filtering templates
 *    - labels[] {String} a single label
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Templates.prototype.add = function(params, onsuccess, onerror) {};

/**
 * Get the information for an existing template
 * \@option params {String} name the immutable name of an existing template
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Templates.prototype.info = function(params, onsuccess, onerror) {};

/**
 * Update the code for an existing template. If null is provided for any fields, the values will remain unchanged.
 * \@option params {String} name the immutable name of an existing template
 * \@option params {String} from_email the new default sending address
 * \@option params {String} from_name the new default from name
 * \@option params {String} subject the new default subject line
 * \@option params {String} code the new code for the template
 * \@option params {String} text the new default text part to be used
 * \@option params {Boolean} publish set to false to update the draft version of the template without publishing
 * \@option params {Array} labels an optional array of up to 10 labels to use for filtering templates
 *    - labels[] {String} a single label
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Templates.prototype.update = function(params, onsuccess, onerror) {};

/**
 * Publish the content for the template. Any new messages sent using this template will start using the content that was previously in draft.
 * \@option params {String} name the immutable name of an existing template
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Templates.prototype.publish = function(params, onsuccess, onerror) {};

/**
 * Delete a template
 * \@option params {String} name the immutable name of an existing template
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Templates.prototype.delete = function(params, onsuccess, onerror) {};

/**
 * Return a list of all the templates available to this user
 * \@option params {String} label an optional label to filter the templates
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Templates.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Return the recent history (hourly stats for the last 30 days) for a template
 * \@option params {String} name the name of an existing template
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Templates.prototype.timeSeries = function(params, onsuccess, onerror) {};

/**
 * Inject content and optionally merge fields into a template, returning the HTML that results
 * \@option params {String} template_name the immutable name of a template that exists in the user's account
 * \@option params {Array} template_content an array of template content to render.  Each item in the array should be a struct with two keys - name: the name of the content block to set the content for, and content: the actual content to put into the block
 *    - template_content[] {Object} the injection of a single piece of content into a single editable region
 *        - name {String} the name of the mc:edit editable region to inject into
 *        - content {String} the content to inject
 * \@option params {Array} merge_vars optional merge variables to use for injecting merge field content.  If this is not provided, no merge fields will be replaced.
 *    - merge_vars[] {Object} a single merge variable
 *        - name {String} the merge variable's name. Merge variable names are case-insensitive and may not start with _
 *        - content {String} the merge variable's content
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Templates.prototype.render = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Exports(master) {}

/**
 * Returns information about an export job. If the export job's state is 'complete',
 * the returned data will include a URL you can use to fetch the results. Every export
 * job produces a zip archive, but the format of the archive is distinct for each job
 * type. The api calls that initiate exports include more details about the output format
 * for that job type.
 * \@option params {String} id an export job identifier
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Exports.prototype.info = function(params, onsuccess, onerror) {};

/**
 * Returns a list of your exports.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Exports.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Begins an export of your rejection blacklist. The blacklist will be exported to a zip archive
 * containing a single file named rejects.csv that includes the following fields: email,
 * reason, detail, created_at, expires_at, last_event_at, expires_at.
 * \@option params {String} notify_email an optional email address to notify when the export job has finished.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Exports.prototype.rejects = function(params, onsuccess, onerror) {};

/**
 * Begins an export of your rejection whitelist. The whitelist will be exported to a zip archive
 * containing a single file named whitelist.csv that includes the following fields:
 * email, detail, created_at.
 * \@option params {String} notify_email an optional email address to notify when the export job has finished.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Exports.prototype.whitelist = function(params, onsuccess, onerror) {};

/**
 * Begins an export of your activity history. The activity will be exported to a zip archive
 * containing a single file named activity.csv in the same format as you would be able to export
 * from your account's activity view. It includes the following fields: Date, Email Address,
 * Sender, Subject, Status, Tags, Opens, Clicks, Bounce Detail. If you have configured any custom
 * metadata fields, they will be included in the exported data.
 * \@option params {String} notify_email an optional email address to notify when the export job has finished
 * \@option params {String} date_from start date as a UTC string in YYYY-MM-DD HH:MM:SS format
 * \@option params {String} date_to end date as a UTC string in YYYY-MM-DD HH:MM:SS format
 * \@option params {Array} tags an array of tag names to narrow the export to; will match messages that contain ANY of the tags
 *      - tags[] {String} a tag name
 * \@option params {Array} senders an array of senders to narrow the export to
 *      - senders[] {String} a sender address
 * \@option params {Array} states an array of states to narrow the export to; messages with ANY of the states will be included
 *      - states[] {String} a message state
 * \@option params {Array} api_keys an array of api keys to narrow the export to; messsagse sent with ANY of the keys will be included
 *      - api_keys[] {String} an API key associated with your account
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Exports.prototype.activity = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Users(master) {}

/**
 * Return the information about the API-connected user
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Users.prototype.info = function(params, onsuccess, onerror) {};

/**
 * Validate an API key and respond to a ping
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Users.prototype.ping = function(params, onsuccess, onerror) {};

/**
 * Validate an API key and respond to a ping (anal JSON parser version)
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Users.prototype.ping2 = function(params, onsuccess, onerror) {};

/**
 * Return the senders that have tried to use this account, both verified and unverified
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Users.prototype.senders = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Rejects(master) {}

/**
 * Adds an email to your email rejection blacklist. Addresses that you
 * add manually will never expire and there is no reputation penalty
 * for removing them from your blacklist. Attempting to blacklist an
 * address that has been whitelisted will have no effect.
 * \@option params {String} email an email address to block
 * \@option params {String} comment an optional comment describing the rejection
 * \@option params {String} subaccount an optional unique identifier for the subaccount to limit the blacklist entry
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Rejects.prototype.add = function(params, onsuccess, onerror) {};

/**
 * Retrieves your email rejection blacklist. You can provide an email
 * address to limit the results. Returns up to 1000 results. By default,
 * entries that have expired are excluded from the results; set
 * include_expired to true to include them.
 * \@option params {String} email an optional email address to search by
 * \@option params {Boolean} include_expired whether to include rejections that have already expired.
 * \@option params {String} subaccount an optional unique identifier for the subaccount to limit the blacklist
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Rejects.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Deletes an email rejection. There is no limit to how many rejections
 * you can remove from your blacklist, but keep in mind that each deletion
 * has an affect on your reputation.
 * \@option params {String} email an email address
 * \@option params {String} subaccount an optional unique identifier for the subaccount to limit the blacklist deletion
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Rejects.prototype.delete = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Inbound(master) {}

/**
 * List the domains that have been configured for inbound delivery
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Inbound.prototype.domains = function(params, onsuccess, onerror) {};

/**
 * Add an inbound domain to your account
 * \@option params {String} domain a domain name
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Inbound.prototype.addDomain = function(params, onsuccess, onerror) {};

/**
 * Check the MX settings for an inbound domain. The domain must have already been added with the add-domain call
 * \@option params {String} domain an existing inbound domain
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Inbound.prototype.checkDomain = function(params, onsuccess, onerror) {};

/**
 * Delete an inbound domain from the account. All mail will stop routing for this domain immediately.
 * \@option params {String} domain an existing inbound domain
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Inbound.prototype.deleteDomain = function(params, onsuccess, onerror) {};

/**
 * List the mailbox routes defined for an inbound domain
 * \@option params {String} domain the domain to check
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Inbound.prototype.routes = function(params, onsuccess, onerror) {};

/**
 * Add a new mailbox route to an inbound domain
 * \@option params {String} domain an existing inbound domain
 * \@option params {String} pattern the search pattern that the mailbox name should match
 * \@option params {String} url the webhook URL where the inbound messages will be published
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Inbound.prototype.addRoute = function(params, onsuccess, onerror) {};

/**
 * Update the pattern or webhook of an existing inbound mailbox route. If null is provided for any fields, the values will remain unchanged.
 * \@option params {String} id the unique identifier of an existing mailbox route
 * \@option params {String} pattern the search pattern that the mailbox name should match
 * \@option params {String} url the webhook URL where the inbound messages will be published
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Inbound.prototype.updateRoute = function(params, onsuccess, onerror) {};

/**
 * Delete an existing inbound mailbox route
 * \@option params {String} id the unique identifier of an existing route
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Inbound.prototype.deleteRoute = function(params, onsuccess, onerror) {};

/**
 * Take a raw MIME document destined for a domain with inbound domains set up, and send it to the inbound hook exactly as if it had been sent over SMTP
 * \@option params {String} raw_message the full MIME document of an email message
 * \@option params {Array|null} to optionally define the recipients to receive the message - otherwise we'll use the To, Cc, and Bcc headers provided in the document
 *      - to[] {String} the email address of the recipient
 * \@option params {String} mail_from the address specified in the MAIL FROM stage of the SMTP conversation. Required for the SPF check.
 * \@option params {String} helo the identification provided by the client mta in the MTA state of the SMTP conversation. Required for the SPF check.
 * \@option params {String} client_address the remote MTA's ip address. Optional; required for the SPF check.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Inbound.prototype.sendRaw = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Tags(master) {}

/**
 * Return all of the user-defined tag information
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Tags.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Deletes a tag permanently. Deleting a tag removes the tag from any messages
 * that have been sent, and also deletes the tag's stats. There is no way to
 * undo this operation, so use it carefully.
 * \@option params {String} tag a tag name
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Tags.prototype.delete = function(params, onsuccess, onerror) {};

/**
 * Return more detailed information about a single tag, including aggregates of recent stats
 * \@option params {String} tag an existing tag name
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Tags.prototype.info = function(params, onsuccess, onerror) {};

/**
 * Return the recent history (hourly stats for the last 30 days) for a tag
 * \@option params {String} tag an existing tag name
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Tags.prototype.timeSeries = function(params, onsuccess, onerror) {};

/**
 * Return the recent history (hourly stats for the last 30 days) for all tags
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Tags.prototype.allTimeSeries = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Messages(master) {}

/**
 * Send a new transactional message through Mandrill
 * \@option params {Struct} message the information on the message to send
 * -html {String} the full HTML content to be sent
 * -text {String} optional full text content to be sent
 * -subject {String} the message subject
 * -from_email {String} the sender email address.
 * -from_name {String} optional from name to be used
 * -to {Array} an array of recipient information.
 *      -to[] {Object} a single recipient's information.
 *      -email {String} the email address of the recipient
 *      -name {String} the optional display name to use for the recipient
 *      -type {String} the header type to use for the recipient, defaults to "to" if not provided
 * -headers {Object} optional extra headers to add to the message (most headers are allowed)
 * -important {Boolean} whether or not this message is important, and should be delivered ahead of non-important messages
 * -track_opens {Boolean} whether or not to turn on open tracking for the message
 * -track_clicks {Boolean} whether or not to turn on click tracking for the message
 * -auto_text {Boolean} whether or not to automatically generate a text part for messages that are not given text
 * -auto_html {Boolean} whether or not to automatically generate an HTML part for messages that are not given HTML
 * -inline_css {Boolean} whether or not to automatically inline all CSS styles provided in the message HTML - only for HTML documents less than 256KB in size
 * -url_strip_qs {Boolean} whether or not to strip the query string from URLs when aggregating tracked URL data
 * -preserve_recipients {Boolean} whether or not to expose all recipients in to "To" header for each email
 * -view_content_link {Boolean} set to false to remove content logging for sensitive emails
 * -bcc_address {String} an optional address to receive an exact copy of each recipient's email
 * -tracking_domain {String} a custom domain to use for tracking opens and clicks instead of mandrillapp.com
 * -signing_domain {String} a custom domain to use for SPF/DKIM signing instead of mandrill (for "via" or "on behalf of" in email clients)
 * -return_path_domain {String} a custom domain to use for the messages's return-path
 * -merge {Boolean} whether to evaluate merge tags in the message. Will automatically be set to true if either merge_vars or global_merge_vars are provided.
 * -merge_language {String} the merge tag language to use when evaluating merge tags, either mailchimp or handlebars
 * -global_merge_vars {Array} global merge variables to use for all recipients. You can override these per recipient.
 *      -global_merge_vars[] {Object} a single global merge variable
 *      -name {String} the global merge variable's name. Merge variable names are case-insensitive and may not start with _
 *      -content {Mixed} the global merge variable's content
 * -merge_vars {Array} per-recipient merge variables, which override global merge variables with the same name.
 *   -merge_vars[] {Object} per-recipient merge variables
 *      -rcpt {String} the email address of the recipient that the merge variables should apply to
 *      -vars {Array} the recipient's merge variables
 *          -vars[] {Object} a single merge variable
 *          -name {String} the merge variable's name. Merge variable names are case-insensitive and may not start with _
 *          -content {Mixed} the merge variable's content
 * -tags {Array} an array of string to tag the message with.  Stats are accumulated using tags, though we only store the first 100 we see, so this should not be unique or change frequently.  Tags should be 50 characters or less.  Any tags starting with an underscore are reserved for internal use and will cause errors.
 *      -tags[] {String} a single tag - must not start with an underscore
 * -subaccount {String} the unique id of a subaccount for this message - must already exist or will fail with an error
 * -google_analytics_domains {Array} an array of strings indicating for which any matching URLs will automatically have Google Analytics parameters appended to their query string automatically.
 * -google_analytics_campaign {Array|string} optional string indicating the value to set for the utm_campaign tracking parameter. If this isn't provided the email's from address will be used instead.
 * -metadata {Array} metadata an associative array of user metadata. Mandrill will store this metadata and make it available for retrieval. In addition, you can select up to 10 metadata fields to index and make searchable using the Mandrill search api.
 * -recipient_metadata {Array} Per-recipient metadata that will override the global values specified in the metadata parameter.
 *      -recipient_metadata[] {Object} metadata for a single recipient
 *          -rcpt {String} the email address of the recipient that the metadata is associated with
 *          -values {Array} an associated array containing the recipient's unique metadata. If a key exists in both the per-recipient metadata and the global metadata, the per-recipient metadata will be used.
 * -attachments {Array} an array of supported attachments to add to the message
 *      -attachments[] {Object} a single supported attachment
 *          -type {String} the MIME type of the attachment
 *          -name {String} the file name of the attachment
 *          -content {String} the content of the attachment as a base64-encoded string
 * -images {Array} an array of embedded images to add to the message
 *      -images[] {Object} a single embedded image
 *          -type {String} the MIME type of the image - must start with "image/"
 *          -name {String} the Content ID of the image - use <img src="cid:THIS_VALUE"> to reference the image in your HTML content
 *          -content {String} the content of the image as a base64-encoded string
 * \@option params {Boolean} async enable a background sending mode that is optimized for bulk sending. In async mode, messages/send will immediately return a status of "queued" for every recipient. To handle rejections when sending in async mode, set up a webhook for the 'reject' event. Defaults to false for messages with no more than 10 recipients; messages with more than 10 recipients are always sent asynchronously, regardless of the value of async.
 * \@option params {String} ip_pool the name of the dedicated ip pool that should be used to send the message. If you do not have any dedicated IPs, this parameter has no effect. If you specify a pool that does not exist, your default pool will be used instead.
 * \@option params {String} send_at when this message should be sent as a UTC timestamp in YYYY-MM-DD HH:MM:SS format. If you specify a time in the past, the message will be sent immediately. An additional fee applies for scheduled email, and this feature is only available to accounts with a positive balance.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.send = function(params, onsuccess, onerror) {};

/**
 * Send a new transactional message through Mandrill using a template
 * \@option params {String} template_name the immutable name or slug of a template that exists in the user's account. For backwards-compatibility, the template name may also be used but the immutable slug is preferred.
 * \@option params {Array} template_content an array of template content to send.  Each item in the array should be a struct with two keys - name: the name of the content block to set the content for, and content: the actual content to put into the block
 * -template_content[] {Object} the injection of a single piece of content into a single editable region
 *     -name {String} the name of the mc:edit editable region to inject into
 *     -content {String} the content to inject
 * \@option params {Struct} message the other information on the message to send - same as /messages/send, but without the html content
 * -html {String} optional full HTML content to be sent if not in template
 * -text {String} optional full text content to be sent
 * -subject {String} the message subject
 * -from_email {String} the sender email address.
 * -from_name {String} optional from name to be used
 * -to {Array} an array of recipient information.
 *      -to[] {Object} a single recipient's information.
 *         -email {String} the email address of the recipient
 *         -name {String} the optional display name to use for the recipient
 *         -type {String} the header type to use for the recipient, defaults to "to" if not provided
 * -headers {Object} optional extra headers to add to the message (most headers are allowed)
 * -important {Boolean} whether or not this message is important, and should be delivered ahead of non-important messages
 * -track_opens {Boolean} whether or not to turn on open tracking for the message
 * -track_clicks {Boolean} whether or not to turn on click tracking for the message
 * -auto_text {Boolean} whether or not to automatically generate a text part for messages that are not given text
 * -auto_html {Boolean} whether or not to automatically generate an HTML part for messages that are not given HTML
 * -inline_css {Boolean} whether or not to automatically inline all CSS styles provided in the message HTML - only for HTML documents less than 256KB in size
 * -url_strip_qs {Boolean} whether or not to strip the query string from URLs when aggregating tracked URL data
 * -preserve_recipients {Boolean} whether or not to expose all recipients in to "To" header for each email
 * -view_content_link {Boolean} set to false to remove content logging for sensitive emails
 * -bcc_address {String} an optional address to receive an exact copy of each recipient's email
 * -tracking_domain {String} a custom domain to use for tracking opens and clicks instead of mandrillapp.com
 * -signing_domain {String} a custom domain to use for SPF/DKIM signing instead of mandrill (for "via" or "on behalf of" in email clients)
 * -return_path_domain {String} a custom domain to use for the messages's return-path
 * -merge {Boolean} whether to evaluate merge tags in the message. Will automatically be set to true if either merge_vars or global_merge_vars are provided.
 * -merge_language {String} the merge tag language to use when evaluating merge tags, either mailchimp or handlebars
 * -global_merge_vars {Array} global merge variables to use for all recipients. You can override these per recipient.
 *      -global_merge_vars[] {Object} a single global merge variable
 *          -name {String} the global merge variable's name. Merge variable names are case-insensitive and may not start with _
 *          -content {Mixed} the global merge variable's content
 * -merge_vars {Array} per-recipient merge variables, which override global merge variables with the same name.
 *      -merge_vars[] {Object} per-recipient merge variables
 *          -rcpt {String} the email address of the recipient that the merge variables should apply to
 *          -vars {Array} the recipient's merge variables
 *              -vars[] {Object} a single merge variable
 *                  -name {String} the merge variable's name. Merge variable names are case-insensitive and may not start with _
 *                  -content {Mixed} the merge variable's content
 * -tags {Array} an array of string to tag the message with.  Stats are accumulated using tags, though we only store the first 100 we see, so this should not be unique or change frequently.  Tags should be 50 characters or less.  Any tags starting with an underscore are reserved for internal use and will cause errors.
 *      -tags[] {String} a single tag - must not start with an underscore
 * -subaccount {String} the unique id of a subaccount for this message - must already exist or will fail with an error
 * -google_analytics_domains {Array} an array of strings indicating for which any matching URLs will automatically have Google Analytics parameters appended to their query string automatically.
 * -google_analytics_campaign {Array|string} optional string indicating the value to set for the utm_campaign tracking parameter. If this isn't provided the email's from address will be used instead.
 * -metadata {Array} metadata an associative array of user metadata. Mandrill will store this metadata and make it available for retrieval. In addition, you can select up to 10 metadata fields to index and make searchable using the Mandrill search api.
 * -recipient_metadata {Array} Per-recipient metadata that will override the global values specified in the metadata parameter.
 *       -recipient_metadata[] {Object} metadata for a single recipient
 *           -rcpt {String} the email address of the recipient that the metadata is associated with
 *           -values {Array} an associated array containing the recipient's unique metadata. If a key exists in both the per-recipient metadata and the global metadata, the per-recipient metadata will be used.
 * -attachments {Array} an array of supported attachments to add to the message
 *      -attachments[] {Object} a single supported attachment
 *          -type {String} the MIME type of the attachment
 *          -name {String} the file name of the attachment
 *          -content {String} the content of the attachment as a base64-encoded string
 * -images {Array} an array of embedded images to add to the message
 *      -images[] {Object} a single embedded image
 *          -type {String} the MIME type of the image - must start with "image/"
 *          -name {String} the Content ID of the image - use <img src="cid:THIS_VALUE"> to reference the image in your HTML content
 *          -content {String} the content of the image as a base64-encoded string
 * \@option params {Boolean} async enable a background sending mode that is optimized for bulk sending. In async mode, messages/send will immediately return a status of "queued" for every recipient. To handle rejections when sending in async mode, set up a webhook for the 'reject' event. Defaults to false for messages with no more than 10 recipients; messages with more than 10 recipients are always sent asynchronously, regardless of the value of async.
 * \@option params {String} ip_pool the name of the dedicated ip pool that should be used to send the message. If you do not have any dedicated IPs, this parameter has no effect. If you specify a pool that does not exist, your default pool will be used instead.
 * \@option params {String} send_at when this message should be sent as a UTC timestamp in YYYY-MM-DD HH:MM:SS format. If you specify a time in the past, the message will be sent immediately. An additional fee applies for scheduled email, and this feature is only available to accounts with a positive balance.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.sendTemplate = function(params, onsuccess, onerror) {};

/**
 * Search recently sent messages and optionally narrow by date range, tags, senders, and API keys. If no date range is specified, results within the last 7 days are returned. This method may be called up to 20 times per minute. If you need the data more often, you can use <a href="/api/docs/messages.html#method=info">/messages/info.json</a> to get the information for a single message, or <a href="http://help.mandrill.com/entries/21738186-Introduction-to-Webhooks">webhooks</a> to push activity to your own application for querying.
 * \@option params {String} query <a href="http://help.mandrill.com/entries/22211902">search terms</a> to find matching messages
 * \@option params {String} date_from start date
 * \@option params {String} date_to end date
 * \@option params {Array} tags an array of tag names to narrow the search to, will return messages that contain ANY of the tags
 * \@option params {Array} senders an array of sender addresses to narrow the search to, will return messages sent by ANY of the senders
 * \@option params {Array} api_keys an array of API keys to narrow the search to, will return messages sent by ANY of the keys
 * \@option params {Integer} limit the maximum number of results to return, defaults to 100, 1000 is the maximum
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.search = function(params, onsuccess, onerror) {};

/**
 * Search the content of recently sent messages and return the aggregated hourly stats for matching messages
 * \@option params {String} query the search terms to find matching messages for
 * \@option params {String} date_from start date
 * \@option params {String} date_to end date
 * \@option params {Array} tags an array of tag names to narrow the search to, will return messages that contain ANY of the tags
 * \@option params {Array} senders an array of sender addresses to narrow the search to, will return messages sent by ANY of the senders
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.searchTimeSeries = function(params, onsuccess, onerror) {};

/**
 * Get the information for a single recently sent message
 * \@option params {String} id the unique id of the message to get - passed as the "_id" field in webhooks, send calls, or search calls
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.info = function(params, onsuccess, onerror) {};

/**
 * Get the full content of a recently sent message
 * \@option params {String} id the unique id of the message to get - passed as the "_id" field in webhooks, send calls, or search calls
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.content = function(params, onsuccess, onerror) {};

/**
 * Parse the full MIME document for an email message, returning the content of the message broken into its constituent pieces
 * \@option params {String} raw_message the full MIME document of an email message
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.parse = function(params, onsuccess, onerror) {};

/**
 * Take a raw MIME document for a message, and send it exactly as if it were sent through Mandrill's SMTP servers
 * \@option params {String} raw_message the full MIME document of an email message
 * \@option params {String|null} from_email optionally define the sender address - otherwise we'll use the address found in the provided headers
 * \@option params {String|null} from_name optionally define the sender alias
 * \@option params {Array|null} to optionally define the recipients to receive the message - otherwise we'll use the To, Cc, and Bcc headers provided in the document
 * -to[] {String} the email address of the recipient
 * \@option params {Boolean} async enable a background sending mode that is optimized for bulk sending. In async mode, messages/sendRaw will immediately return a status of "queued" for every recipient. To handle rejections when sending in async mode, set up a webhook for the 'reject' event. Defaults to false for messages with no more than 10 recipients; messages with more than 10 recipients are always sent asynchronously, regardless of the value of async.
 * \@option params {String} ip_pool the name of the dedicated ip pool that should be used to send the message. If you do not have any dedicated IPs, this parameter has no effect. If you specify a pool that does not exist, your default pool will be used instead.
 * \@option params {String} send_at when this message should be sent as a UTC timestamp in YYYY-MM-DD HH:MM:SS format. If you specify a time in the past, the message will be sent immediately.
 * \@option params {String} return_path_domain a custom domain to use for the messages's return-path
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.sendRaw = function(params, onsuccess, onerror) {};

/**
 * Queries your scheduled emails by sender or recipient, or both.
 * \@option params {String} to an optional recipient address to restrict results to
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.listScheduled = function(params, onsuccess, onerror) {};

/**
 * Cancels a scheduled email.
 * \@option params {String} id a scheduled email id, as returned by any of the messages/send calls or messages/list-scheduled
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.cancelScheduled = function(params, onsuccess, onerror) {};

/**
 * Reschedules a scheduled email.
 * \@option params {String} id a scheduled email id, as returned by any of the messages/send calls or messages/list-scheduled
 * \@option params {String} send_at the new UTC timestamp when the message should sent. Mandrill can't time travel, so if you specify a time in past the message will be sent immediately
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Messages.prototype.reschedule = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Whitelists(master) {}

/**
 * Adds an email to your email rejection whitelist. If the address is
 * currently on your blacklist, that blacklist entry will be removed
 * automatically.
 * \@option params {String} email an email address to add to the whitelist
 * \@option params {String} comment an optional description of why the email was whitelisted
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Whitelists.prototype.add = function(params, onsuccess, onerror) {};

/**
 * Retrieves your email rejection whitelist. You can provide an email
 * address or search prefix to limit the results. Returns up to 1000 results.
 * \@option params {String} email an optional email address or prefix to search by
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Whitelists.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Removes an email address from the whitelist.
 * \@option params {String} email the email address to remove from the whitelist
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Whitelists.prototype.delete = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Ips(master) {}

/**
 * Lists your dedicated IPs.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Retrieves information about a single dedicated ip.
 * \@option params {String} ip a dedicated IP address
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.info = function(params, onsuccess, onerror) {};

/**
 * Requests an additional dedicated IP for your account. Accounts may
 * have one outstanding request at any time, and provisioning requests
 * are processed within 24 hours.
 * \@option params {Boolean} warmup whether to enable warmup mode for the ip
 * \@option params {String} pool the id of the pool to add the dedicated ip to, or null to use your account's default pool
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.provision = function(params, onsuccess, onerror) {};

/**
 * Begins the warmup process for a dedicated IP. During the warmup process,
 * Mandrill will gradually increase the percentage of your mail that is sent over
 * the warming-up IP, over a period of roughly 30 days. The rest of your mail
 * will be sent over shared IPs or other dedicated IPs in the same pool.
 * \@option params {String} ip a dedicated ip address
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.startWarmup = function(params, onsuccess, onerror) {};

/**
 * Cancels the warmup process for a dedicated IP.
 * \@option params {String} ip a dedicated ip address
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.cancelWarmup = function(params, onsuccess, onerror) {};

/**
 * Moves a dedicated IP to a different pool.
 * \@option params {String} ip a dedicated ip address
 * \@option params {String} pool the name of the new pool to add the dedicated ip to
 * \@option params {Boolean} create_pool whether to create the pool if it does not exist; if false and the pool does not exist, an Unknown_Pool will be thrown.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.setPool = function(params, onsuccess, onerror) {};

/**
 * Deletes a dedicated IP. This is permanent and cannot be undone.
 * \@option params {String} ip the dedicated ip to remove from your account
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.delete = function(params, onsuccess, onerror) {};

/**
 * Lists your dedicated IP pools.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.listPools = function(params, onsuccess, onerror) {};

/**
 * Describes a single dedicated IP pool.
 * \@option params {String} pool a pool name
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.poolInfo = function(params, onsuccess, onerror) {};

/**
 * Creates a pool and returns it. If a pool already exists with this
 * name, no action will be performed.
 * \@option params {String} pool the name of a pool to create
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.createPool = function(params, onsuccess, onerror) {};

/**
 * Deletes a pool. A pool must be empty before you can delete it, and you cannot delete your default pool.
 * \@option params {String} pool the name of the pool to delete
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.deletePool = function(params, onsuccess, onerror) {};

/**
 * Tests whether a domain name is valid for use as the custom reverse
 * DNS for a dedicated IP.
 * \@option params {String} ip a dedicated ip address
 * \@option params {String} domain the domain name to test
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.checkCustomDns = function(params, onsuccess, onerror) {};

/**
 * Configures the custom DNS name for a dedicated IP.
 * \@option params {String} ip a dedicated ip address
 * \@option params {String} domain a domain name to set as the dedicated IP's custom dns name.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Ips.prototype.setCustomDns = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Internal(master) {}

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Subaccounts(master) {}

/**
 * Get the list of subaccounts defined for the account, optionally filtered by a prefix
 * \@option params {String} q an optional prefix to filter the subaccounts' ids and names
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Subaccounts.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Add a new subaccount
 * \@option params {String} id a unique identifier for the subaccount to be used in sending calls
 * \@option params {String} name an optional display name to further identify the subaccount
 * \@option params {String} notes optional extra text to associate with the subaccount
 * \@option params {Integer} custom_quota an optional manual hourly quota for the subaccount. If not specified, Mandrill will manage this based on reputation
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Subaccounts.prototype.add = function(params, onsuccess, onerror) {};

/**
 * Given the ID of an existing subaccount, return the data about it
 * \@option params {String} id the unique identifier of the subaccount to query
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Subaccounts.prototype.info = function(params, onsuccess, onerror) {};

/**
 * Update an existing subaccount
 * \@option params {String} id the unique identifier of the subaccount to update
 * \@option params {String} name an optional display name to further identify the subaccount
 * \@option params {String} notes optional extra text to associate with the subaccount
 * \@option params {Integer} custom_quota an optional manual hourly quota for the subaccount. If not specified, Mandrill will manage this based on reputation
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Subaccounts.prototype.update = function(params, onsuccess, onerror) {};

/**
 * Delete an existing subaccount. Any email related to the subaccount will be saved, but stats will be removed and any future sending calls to this subaccount will fail.
 * \@option params {String} id the unique identifier of the subaccount to delete
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Subaccounts.prototype.delete = function(params, onsuccess, onerror) {};

/**
 * Pause a subaccount's sending. Any future emails delivered to this subaccount will be queued for a maximum of 3 days until the subaccount is resumed.
 * \@option params {String} id the unique identifier of the subaccount to pause
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Subaccounts.prototype.pause = function(params, onsuccess, onerror) {};

/**
 * Resume a paused subaccount's sending
 * \@option params {String} id the unique identifier of the subaccount to resume
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Subaccounts.prototype.resume = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Urls(master) {}

/**
 * Get the 100 most clicked URLs
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Urls.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Return the 100 most clicked URLs that match the search query given
 * \@option params {String} q a search query
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Urls.prototype.search = function(params, onsuccess, onerror) {};

/**
 * Return the recent history (hourly stats for the last 30 days) for a url
 * \@option params {String} url an existing URL
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Urls.prototype.timeSeries = function(params, onsuccess, onerror) {};

/**
 * Get the list of tracking domains set up for this account
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Urls.prototype.trackingDomains = function(params, onsuccess, onerror) {};

/**
 * Add a tracking domain to your account
 * \@option params {String} domain a domain name
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Urls.prototype.addTrackingDomain = function(params, onsuccess, onerror) {};

/**
 * Checks the CNAME settings for a tracking domain. The domain must have been added already with the add-tracking-domain call
 * \@option params {String} domain an existing tracking domain name
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Urls.prototype.checkTrackingDomain = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Webhooks(master) {}

/**
 * Get the list of all webhooks defined on the account
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Webhooks.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Add a new webhook
 * \@option params {String} url the URL to POST batches of events
 * \@option params {String} description an optional description of the webhook
 * \@option params {Array} events an optional list of events that will be posted to the webhook
 *    - events[] {String} the individual event to listen for
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Webhooks.prototype.add = function(params, onsuccess, onerror) {};

/**
 * Given the ID of an existing webhook, return the data about it
 * \@option params {Integer} id the unique identifier of a webhook belonging to this account
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Webhooks.prototype.info = function(params, onsuccess, onerror) {};

/**
 * Update an existing webhook
 * \@option params {Integer} id the unique identifier of a webhook belonging to this account
 * \@option params {String} url the URL to POST batches of events
 * \@option params {String} description an optional description of the webhook
 * \@option params {Array} events an optional list of events that will be posted to the webhook
 *    - events[] {String} the individual event to listen for
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Webhooks.prototype.update = function(params, onsuccess, onerror) {};

/**
 * Delete an existing webhook
 * \@option params {Integer} id the unique identifier of a webhook belonging to this account
 * @param {{id: number}} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Webhooks.prototype.delete = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Senders(master) {}

/**
 * Return the senders that have tried to use this account.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Senders.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Returns the sender domains that have been added to this account.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Senders.prototype.domains = function(params, onsuccess, onerror) {};

/**
 * Adds a sender domain to your account. Sender domains are added automatically as you
 * send, but you can use this call to add them ahead of time.
 * \@option params {String} domain a domain name
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Senders.prototype.addDomain = function(params, onsuccess, onerror) {};

/**
 * Checks the SPF and DKIM settings for a domain. If you haven't already added this domain to your
 * account, it will be added automatically.
 * \@option params {String} domain a domain name
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Senders.prototype.checkDomain = function(params, onsuccess, onerror) {};

/**
 * Sends a verification email in order to verify ownership of a domain.
 * Domain verification is an optional step to confirm ownership of a domain. Once a
 * domain has been verified in a Mandrill account, other accounts may not have their
 * messages signed by that domain unless they also verify the domain. This prevents
 * other Mandrill accounts from sending mail signed by your domain.
 * \@option params {String} domain a domain name at which you can receive email
 * \@option params {String} mailbox a mailbox at the domain where the verification email should be sent
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Senders.prototype.verifyDomain = function(params, onsuccess, onerror) {};

/**
 * Return more detailed information about a single sender, including aggregates of recent stats
 * \@option params {String} address the email address of the sender
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Senders.prototype.info = function(params, onsuccess, onerror) {};

/**
 * Return the recent history (hourly stats for the last 30 days) for a sender
 * \@option params {String} address the email address of the sender
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Senders.prototype.timeSeries = function(params, onsuccess, onerror) {};

/**
 * @constructor
 * @struct
 * @param {!Mandrill} master
 */
function Metadata(master) {}

/**
 * Get the list of custom metadata fields indexed for the account.
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Metadata.prototype.list = function(params, onsuccess, onerror) {};

/**
 * Add a new custom metadata field to be indexed for the account.
 * \@option params {String} name a unique identifier for the metadata field
 * \@option params {String} view_template optional Mustache template to control how the metadata is rendered in your activity log
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Metadata.prototype.add = function(params, onsuccess, onerror) {};

/**
 * Update an existing custom metadata field.
 * \@option params {String} name the unique identifier of the metadata field to update
 * \@option params {String} view_template optional Mustache template to control how the metadata is rendered in your activity log
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Metadata.prototype.update = function(params, onsuccess, onerror) {};

/**
 * Delete an existing custom metadata field. Deletion isn't instataneous, and /metadata/list will continue to return the field until the asynchronous deletion process is complete.
 * \@option params {String} name the unique identifier of the metadata field to update
 * @param {?} params
 * @param {?=} onsuccess
 * @param {?=} onerror
 * @return {void}
 */
Metadata.prototype.delete = function(params, onsuccess, onerror) {};
