/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/d3-geo/index.d.ts:

/* TODO: ImportDeclaration in  */
/**
 * @record
 * @struct
 */
function GeoSphere() {}
 /** @type {string} */
GeoSphere.prototype.type;

/** @typedef {?} */
var GeoGeometryObjects;
/**
 * @record
 * @struct
 */
function ExtendedGeometryCollection() {}
 /** @type {string} */
ExtendedGeometryCollection.prototype.type;
 /** @type {!Array<number>} */
ExtendedGeometryCollection.prototype.bbox;
 /** @type {?} */
ExtendedGeometryCollection.prototype.crs;
 /** @type {!Array<?>} */
ExtendedGeometryCollection.prototype.geometries;
/**
 * @extends {GeoJsonObject}
 * @record
 * @struct
 */
function ExtendedFeature() {}
 /** @type {?} */
ExtendedFeature.prototype.geometry;
 /** @type {?} */
ExtendedFeature.prototype.properties;
 /** @type {string} */
ExtendedFeature.prototype.id;
/**
 * @extends {GeoJsonObject}
 * @record
 * @struct
 */
function ExtendedFeatureCollection() {}
 /** @type {!Array<?>} */
ExtendedFeatureCollection.prototype.features;

/** @typedef {?} */
var GeoPermissibleObjects;

/**
 * Returns the spherical area of the specified feature in steradians.
 * This is the spherical equivalent of path.area.
 * 
 * Returns the spherical area of the specified feature collection in steradians.
 * This is the spherical equivalent of path.area.
 * 
 * Returns the spherical area of the specified GeoJson Geometry Object or GeoSphere object in steradians.
 * This is the spherical equivalent of path.area.
 * 
 * Returns the spherical area of the specified geographic geometry collection in steradians.
 * This is the spherical equivalent of path.area.
 * 
 * @param {?} object A geographic feature supported by d3-geo (An extension of GeoJSON feature). / A geographic feature collection supported by d3-geo (An extension of GeoJSON feature). / A GeoJson Geometry Object or GeoSphere object supported by d3-geo (An extension of GeoJSON). / A geographic geometry collection supported by d3-geo (An extension of GeoJSON geometry collection).
 * @return {number}
 */
function geoArea(object) {}

/**
 * Returns the spherical bounding box for the specified feature. The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]],
 * where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude. All coordinates are given in degrees.
 * (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.)
 * This is the spherical equivalent of path.bounds.
 * 
 * Returns the spherical bounding box for the specified feature collection. The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]],
 * where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude. All coordinates are given in degrees.
 * (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.)
 * This is the spherical equivalent of path.bounds.
 * 
 * Returns the spherical bounding box for the specified GeoJson Geometry Object or GeoSphere object. The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]],
 * where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude. All coordinates are given in degrees.
 * (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.)
 * This is the spherical equivalent of path.bounds.
 * 
 * Returns the spherical bounding box for the specified geometry collection. The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]],
 * where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude. All coordinates are given in degrees.
 * (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.)
 * This is the spherical equivalent of path.bounds.
 * 
 * @param {?} object A geographic feature supported by d3-geo (An extension of GeoJSON feature). / A geographic feature collection supported by d3-geo (An extension of GeoJSON feature). / A GeoJson Geometry Object or GeoSphere object supported by d3-geo (An extension of GeoJSON). / A geographic geometry collection supported by d3-geo (An extension of GeoJSON geometry collection).
 * @return {!Array<?>}
 */
function geoBounds(object) {}

/**
 * Returns the spherical centroid of the specified feature in steradians.
 * This is the spherical equivalent of path.centroid.
 * 
 * Returns the spherical centroid of the specified feature collection in steradians.
 * This is the spherical equivalent of path.centroid.
 * 
 * Returns the spherical centroid of the specified GeoJson Geometry Object or GeoSphere object in steradians.
 * This is the spherical equivalent of path.centroid.
 * 
 * Returns the spherical centroid of the specified geographic geometry collection in steradians.
 * This is the spherical equivalent of path.centroid.
 * 
 * @param {?} object A geographic feature supported by d3-geo (An extension of GeoJSON feature). / A geographic feature collection supported by d3-geo (An extension of GeoJSON feature). / A GeoJson Geometry Object or GeoSphere object supported by d3-geo (An extension of GeoJSON). / A geographic geometry collection supported by d3-geo (An extension of GeoJSON geometry collection).
 * @return {!Array<?>}
 */
function geoCentroid(object) {}

/**
 * Returns true if and only if the specified GeoJSON object contains the specified point, or false if the object does not contain the point.
 * The point must be specified as a two-element array [longitude, latitude] in degrees. For Point and MultiPoint geometries, an exact test is used;
 * for a Sphere, true is always returned; for other geometries, an epsilon threshold is applied.
 * 
 * Returns true if and only if the specified GeoJSON object contains the specified point, or false if the object does not contain the point.
 * The point must be specified as a two-element array [longitude, latitude] in degrees. For Point and MultiPoint geometries, an exact test is used;
 * for a Sphere, true is always returned; for other geometries, an epsilon threshold is applied.
 * 
 * Returns true if and only if the specified GeoJSON object contains the specified point, or false if the object does not contain the point.
 * The point must be specified as a two-element array [longitude, latitude] in degrees. For Point and MultiPoint geometries, an exact test is used;
 * for a Sphere, true is always returned; for other geometries, an epsilon threshold is applied.
 * 
 * Returns true if and only if the specified GeoJSON object contains the specified point, or false if the object does not contain the point.
 * The point must be specified as a two-element array [longitude, latitude] in degrees. For Point and MultiPoint geometries, an exact test is used;
 * for a Sphere, true is always returned; for other geometries, an epsilon threshold is applied.
 * 
 * @param {?} object A geographic feature supported by d3-geo (An extension of GeoJSON feature). / A geographic feature collection supported by d3-geo (An extension of GeoJSON feature). / A GeoJson Geometry Object or GeoSphere object supported by d3-geo (An extension of GeoJSON). / A geographic geometry collection supported by d3-geo (An extension of GeoJSON geometry collection).
 * @param {!Array<?>} point Point specified as a two-element array [longitude, latitude] in degrees.
 * @return {boolean}
 */
function geoContains(object, point) {}

/**
 * Returns the great-arc distance in radians between the two points a and b.
 * Each point must be specified as a two-element array [longitude, latitude] in degrees.
 * 
 * @param {!Array<?>} a Point specified as a two-element array [longitude, latitude] in degrees.
 * @param {!Array<?>} b Point specified as a two-element array [longitude, latitude] in degrees.
 * @return {number}
 */
function geoDistance(a, b) {}

/**
 * Returns the great-arc length of the specified feature in radians. For polygons, returns the perimeter of the exterior ring plus that of any interior rings.
 * This is the spherical equivalent of path.measure.
 * 
 * Returns the great-arc length of the specified feature collection in radians. For polygons, returns the perimeter of the exterior ring plus that of any interior rings.
 * This is the spherical equivalent of path.measure.
 * 
 * Returns the great-arc length of the specified GeoJson Geometry Object or GeoSphere object in radians. For polygons, returns the perimeter of the exterior ring plus that of any interior rings.
 * This is the spherical equivalent of path.measure.
 * 
 * Returns the great-arc length of the specified geographic geometry collection in radians For polygons, returns the perimeter of the exterior ring plus that of any interior rings.
 * This is the spherical equivalent of path.measure..
 * 
 * @param {?} object A geographic feature supported by d3-geo (An extension of GeoJSON feature). / A geographic feature collection supported by d3-geo (An extension of GeoJSON feature). / A GeoJson Geometry Object or GeoSphere object supported by d3-geo (An extension of GeoJSON). / A geographic geometry collection supported by d3-geo (An extension of GeoJSON geometry collection).
 * @return {number}
 */
function geoLength(object) {}

/**
 * Returns an interpolator function given two points a and b.
 * Each point must be specified as a two-element array [longitude, latitude] in degrees.
 * 
 * @param {!Array<?>} a Point specified as a two-element array [longitude, latitude] in degrees.
 * @param {!Array<?>} b Point specified as a two-element array [longitude, latitude] in degrees.
 * @return {?}
 */
function geoInterpolate(a, b) {}
/**
 * @record
 * @struct
 */
function GeoRotation() {}

/* TODO: CallSignature:  */

/**
 * Returns a new array [longitude, latitude] in degrees representing the point of the given rotated point; the inverse of rotation.
 * 
 * @param {!Array<?>} point The rotated point must be specified as a two-element array [longitude, latitude] in degrees.
 * @return {!Array<?>}
 */
GeoRotation.prototype.invert = function(point) {};

/**
 * Returns a rotation function for the given angles.
 * 
 * @param {!Array<?>} angles  A two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis.
 * (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0.
 * @return {?}
 */
function geoRotation(angles) {}
/**
 * @record
 * @struct
 */
function GeoCircleGenerator() {}

/* TODO: CallSignature:  */

/**
 * Returns the current center accessor, which defaults to a function returning [0, 0].
 * Sets the circle center to the specified point [longitude, latitude] in degrees, and returns this circle generator.
 * 
 * Sets the circle center to the specified center point accessor function, and returns this circle generator.
 * 
 * @param {!Array<?>|?=} center Center point specified as [longitude, latitude] in degrees. / An accessor function which will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator.
 * It returns the center point specified as [longitude, latitude] in degrees.
 * @return {?}
 */
GeoCircleGenerator.prototype.center = function(center) {};

/**
 * Returns the current radius accessor, which defaults to a function returning 90.
 * Sets the circle radius to the specified angle in degrees, and returns this circle generator.
 * 
 * Sets the circle radius to the specified radius accessor function, and returns this circle generator.
 * 
 * @param {number|?=} radius Circle radius as the specified angle in degrees. / An accessor function which will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator.
 * It returns the radius as the specified angle in degrees.
 * @return {?}
 */
GeoCircleGenerator.prototype.radius = function(radius) {};

/**
 * Returns the current precision accessor, which defaults to a function returning 6.
 * Sets the circle precision to the specified angle in degrees, and returns this circle generator.
 * 
 * Small circles do not follow great arcs and thus the generated polygon is only an approximation.
 * Specifying a smaller precision angle improves the accuracy of the approximate polygon, but also increase the cost to generate and render it.
 * 
 * Sets the circle precision to the precision accessor function, and returns this circle generator.
 * 
 * Small circles do not follow great arcs and thus the generated polygon is only an approximation.
 * Specifying a smaller precision angle improves the accuracy of the approximate polygon, but also increase the cost to generate and render it.
 * 
 * @param {number|?=} precision Precision as specified angle in degrees. / An accessor function which will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator.
 * It returns the precision as the specified angle in degrees.
 * @return {?}
 */
GeoCircleGenerator.prototype.precision = function(precision) {};

/**
 * Returns a new geo circle generator
 * Returns a new geo circle generator
 * 
 * The generic corresponds to the data type of the first argument passed into the geo circle generator and its accessor functions.
 * Returns a new geo circle generator
 * 
 * The first generic corresponds to the "this" context within which the geo circle generator and its accessors will be invoked.
 * 
 * The second generic corresponds to the data type of the first argument passed into the geo circle generator and its accessor functions.
 * @template Datum, This
 * @return {?}
 */
function geoCircle() {}
/**
 * @record
 * @struct
 */
function GeoGraticuleGenerator() {}

/* TODO: CallSignature:  */

/**
 * Returns an array of GeoJSON LineString geometry objects, one for each meridian or parallel for this graticule.
 * @return {!Array<?>}
 */
GeoGraticuleGenerator.prototype.lines = function() {};

/**
 * Returns a GeoJSON Polygon geometry object representing the outline of this graticule, i.e. along the meridians and parallels defining its extent.
 * @return {?}
 */
GeoGraticuleGenerator.prototype.outline = function() {};

/**
 * Returns the current minor extent, which defaults to ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.
 * Sets the major and minor extents of this graticule.
 * 
 * @param {!Array<?>=} extent Extent to use for major and minor extent of graticule.
 * @return {!Array<?>|?}
 */
GeoGraticuleGenerator.prototype.extent = function(extent) {};

/**
 * Returns the current major extent, which defaults to ⟨⟨-180°, -90° + ε⟩, ⟨180°, 90° - ε⟩⟩.
 * Sets the major extent of this graticule.
 * 
 * @param {!Array<?>=} extent Major extent of graticule.
 * @return {!Array<?>|?}
 */
GeoGraticuleGenerator.prototype.extentMajor = function(extent) {};

/**
 * Returns the current minor extent, which defaults to  ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.
 * Sets the minor extent of this graticule.
 * 
 * @param {!Array<?>=} extent Minor extent of graticule.
 * @return {!Array<?>|?}
 */
GeoGraticuleGenerator.prototype.extentMinor = function(extent) {};

/**
 * Returns the current minor step, which defaults to ⟨10°, 10°⟩.
 * Sets the major and minor step for this graticule
 * 
 * @param {!Array<?>=} step Major and minor step to use for this graticule.
 * @return {!Array<?>|?}
 */
GeoGraticuleGenerator.prototype.step = function(step) {};

/**
 * Returns the current major step, which defaults to ⟨90°, 360°⟩.
 * Sets the major step for this graticule.
 * 
 * @param {!Array<?>=} step Major step.
 * @return {!Array<?>|?}
 */
GeoGraticuleGenerator.prototype.stepMajor = function(step) {};

/**
 * Returns the current major step, which defaults to ⟨10°, 10°⟩.
 * Sets the minor step for this graticule.
 * 
 * @param {!Array<?>=} step Minor step.
 * @return {!Array<?>|?}
 */
GeoGraticuleGenerator.prototype.stepMinor = function(step) {};

/**
 * Returns the current precision, which defaults to 2.5°.
 * Sets the precision for this graticule, in degrees.
 * 
 * @param {number=} angle Precision in degrees.
 * @return {number|?}
 */
GeoGraticuleGenerator.prototype.precision = function(angle) {};

/**
 * Constructs a feature generator for creating graticules: a uniform grid of meridians and parallels for showing projection distortion.
 * The default graticule has meridians and parallels every 10° between ±80° latitude; for the polar regions, there are meridians every 90°.
 * @return {?}
 */
function geoGraticule() {}

/**
 * A convenience method for directly generating the default 10° global graticule as a GeoJSON MultiLineString geometry object.
 * @return {?}
 */
function geoGraticule10() {}
/**
 * @record
 * @struct
 */
function GeoStream() {}

/**
 * Indicates the end of a line or ring. Within a polygon, indicates the end of a ring.
 * Unlike GeoJSON, the redundant closing coordinate of a ring is not indicated via point, and instead is implied via lineEnd within a polygon.
 * @return {void}
 */
GeoStream.prototype.lineEnd = function() {};

/**
 * Indicates the start of a line or ring. Within a polygon, indicates the start of a ring. The first ring of a polygon is the exterior ring, and is typically clockwise.
 * Any subsequent rings indicate holes in the polygon, and are typically counterclockwise.
 * @return {void}
 */
GeoStream.prototype.lineStart = function() {};

/**
 * Indicates a point with the specified coordinates x and y (and optionally z). The coordinate system is unspecified and implementation-dependent;
 * for example, projection streams require spherical coordinates in degrees as input. Outside the context of a polygon or line,
 * a point indicates a point geometry object (Point or MultiPoint). Within a line or polygon ring, the point indicates a control point.
 * 
 * @param {number} x x-coordinate of point.
 * @param {number} y y-coordinate of point.
 * @param {number=} z Optional z-coordinate of point.
 * @return {void}
 */
GeoStream.prototype.point = function(x, y, z) {};

/**
 * Indicates the end of a polygon.
 * @return {void}
 */
GeoStream.prototype.polygonEnd = function() {};

/**
 * Indicates the start of a polygon. The first line of a polygon indicates the exterior ring, and any subsequent lines indicate interior holes.
 * @return {void}
 */
GeoStream.prototype.polygonStart = function() {};

/**
 * Indicates the sphere (the globe; the unit sphere centered at ⟨0,0,0⟩).
 * @return {void}
 */
GeoStream.prototype.sphere = function() {};

/**
 * Streams the specified GeoJSON object to the specified projection stream. While both features and geometry objects are supported as input,
 * the stream interface only describes the geometry, and thus additional feature properties are not visible to streams.
 * 
 * Streams the specified GeoJSON object to the specified projection stream. While both features and geometry objects are supported as input,
 * the stream interface only describes the geometry, and thus additional feature properties are not visible to streams.
 * 
 * Streams the specified GeoJSON object to the specified projection stream. While both features and geometry objects are supported as input,
 * the stream interface only describes the geometry, and thus additional feature properties are not visible to streams.
 * 
 * Streams the specified GeoJSON object to the specified projection stream. While both features and geometry objects are supported as input,
 * the stream interface only describes the geometry, and thus additional feature properties are not visible to streams.
 * 
 * @param {?} object
 * @param {?} stream A projection stream.
 * @return {void}
 */
function geoStream(object, stream) {}
/**
 * @record
 * @struct
 */
function GeoRawProjection() {}

/* TODO: CallSignature:  */

/**
 * Inverts the projected point [x, y] in unitless coordinates, returning an unprojected point in spherical coordinates [lambda, phi] in radians.
 * @param {number} x x-coordinate (unitless).
 * @param {number} y y-coordinate (unitless).
 * @return {!Array<?>}
 */
GeoRawProjection.prototype.invert = function(x, y) {};
/**
 * @record
 * @struct
 */
function GeoStreamWrapper() {}

/**
 * Returns a projection stream for the specified output stream. Any input geometry is projected before being streamed to the output stream.
 * A typical projection involves several geometry transformations: the input geometry is first converted to radians, rotated on three axes,
 * clipped to the small circle or cut along the antimeridian, and lastly projected to the plane with adaptive resampling, scale and translation.
 * 
 * @param {?} stream An input stream
 * @return {?}
 */
GeoStreamWrapper.prototype.stream = function(stream) {};
/**
 * @extends {GeoStreamWrapper}
 * @record
 * @struct
 */
function GeoProjection() {}

/* TODO: CallSignature:  */

/**
 * Returns the current center of the projection, which defaults to ⟨0°,0°⟩.
 * Sets the projection’s center to the specified center,
 * a two-element array of longitude and latitude in degrees and returns the projection.
 * The default is ⟨0°,0°⟩.
 * 
 * @param {!Array<?>=} point A point specified as a two-dimensional array [longitude, latitude] in degrees.
 * @return {!Array<?>|?}
 */
GeoProjection.prototype.center = function(point) {};

/**
 * Returns the current clip angle which defaults to null.
 * 
 * null switches to antimeridian cutting rather than small-circle clipping.
 * Switches to antimeridian cutting rather than small-circle clipping.
 * 
 * Sets the projection’s clipping circle radius to the specified angle in degrees and returns the projection.
 * Small-circle clipping is independent of viewport clipping via projection.clipExtent.
 * 
 * @param {null|number=} angle Set to null to switch to antimeridian cutting. / Angle in degrees.
 * @return {number|?}
 */
GeoProjection.prototype.clipAngle = function(angle) {};

/**
 * Returns the current viewport clip extent which defaults to null.
 * Sets the clip extent to null and returns the projection.
 * With a clip extent of null, no viewport clipping is performed.
 * 
 * Viewport clipping is independent of small-circle clipping via projection.clipAngle.
 * 
 * Sets the projection’s viewport clip extent to the specified bounds in pixels and returns the projection.
 * The extent bounds are specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the top, x₁ is the right and y₁ is the bottom.
 * 
 * Viewport clipping is independent of small-circle clipping via projection.clipAngle.
 * 
 * @param {null|!Array<?>=} extent Set to null to disable viewport clipping. / The extent bounds are specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the top, x₁ is the right and y₁ is the bottom.
 * @return {!Array<?>|?}
 */
GeoProjection.prototype.clipExtent = function(extent) {};

/**
 * Sets the projection’s scale and translate to fit the specified geographic feature in the center of the given extent.
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic feature collection in the center of the given extent.
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic geometry object in the center of the given extent.
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic geometry collection in the center of the given extent.
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * @param {!Array<?>} extent The extent, specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left side of the bounding box, y₀ is the top, x₁ is the right and y₁ is the bottom.
 * @param {?} object A geographic feature supported by d3-geo (An extension of GeoJSON feature). / A geographic feature collection supported by d3-geo (An extension of GeoJSON feature collection). / A GeoJson Geometry Object or GeoSphere object supported by d3-geo (An extension of GeoJSON). / A geographic geometry collection supported by d3-geo (An extension of GeoJSON geometry collection).
 * @return {?}
 */
GeoProjection.prototype.fitExtent = function(extent, object) {};

/**
 * Sets the projection’s scale and translate to fit the specified geographic feature in the center of an extent with the given size and top-left corner of [0, 0].
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic feature collection in the center of an extent with the given size and top-left corner of [0, 0].
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic geometry object in the center of an extent with the given size and top-left corner of [0, 0].
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic geometry collection in the center of an extent with the given size and top-left corner of [0, 0].
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * @param {!Array<?>} size The size of the extent, specified as an array [width, height].
 * @param {?} object A geographic feature supported by d3-geo (An extension of GeoJSON feature). / A geographic feature collection supported by d3-geo (An extension of GeoJSON feature collection). / A GeoJson Geometry Object or GeoSphere object supported by d3-geo (An extension of GeoJSON). / A geographic geometry collection supported by d3-geo (An extension of GeoJSON geometry collection).
 * @return {?}
 */
GeoProjection.prototype.fitSize = function(size, object) {};

/**
 * Returns a new array [longitude, latitude] in degrees representing the unprojected point of the given projected point.
 * May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.
 * 
 * @param {!Array<?>} point The projected point, specified as a two-element array [x, y] (typically in pixels).
 * @return {!Array<?>}
 */
GeoProjection.prototype.invert = function(point) {};

/**
 * Returns the projection’s current resampling precision which defaults to square root of 0.5.
 * This value corresponds to the Douglas–Peucker distance.
 * Sets the threshold for the projection’s adaptive resampling to the specified value in pixels and returns the projection.
 * This value corresponds to the Douglas–Peucker distance.
 * 
 * @param {number=} precision A numeric value in pixels to use as the threshold for the projection’s adaptive resampling.
 * @return {number|?}
 */
GeoProjection.prototype.precision = function(precision) {};

/**
 * Returns the current rotation [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis.
 * (These correspond to yaw, pitch and roll.) which defaults [0, 0, 0].
 * Sets the projection’s three-axis rotation to the specified angles, which must be a two- or three-element array of numbers.
 * 
 * @param {!Array<?>=} angles  A two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis.
 * (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0.
 * @return {!Array<?>|?}
 */
GeoProjection.prototype.rotate = function(angles) {};

/**
 * Returns the current scale factor; the default scale is projection-specific.
 * 
 * The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.
 * Sets the projection’s scale factor to the specified value and returns the projection.
 * The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.
 * 
 * @param {number=} scale Scale factor to be used for the projection; the default scale is projection-specific.
 * @return {number|?}
 */
GeoProjection.prototype.scale = function(scale) {};

/**
 * Returns the current translation offset which defaults to [480, 250] and places ⟨0°,0°⟩ at the center of a 960×500 area.
 * The translation offset determines the pixel coordinates of the projection’s center.
 * Sets the projection’s translation offset to the specified two-element array [tx, ty] and returns the projection.
 * The translation offset determines the pixel coordinates of the projection’s center. The default translation offset places ⟨0°,0°⟩ at the center of a 960×500 area.
 * 
 * @param {!Array<?>=} point A two-element array [tx, ty] specifying the translation offset. The default translation offset of defaults to [480, 250] places ⟨0°,0°⟩ at the center of a 960×500 area.
 * @return {!Array<?>|?}
 */
GeoProjection.prototype.translate = function(point) {};
/**
 * @extends {GeoProjection}
 * @record
 * @struct
 */
function GeoConicProjection() {}

/**
 * Return the standard parallels for the conic projection in degrees.
 * Set the standard parallels for the conic projection in degrees and return the projection.
 * 
 * @param {!Array<?>=} value A two-dimensional array representing the standard parallels in degrees.
 * @return {!Array<?>|?}
 */
GeoConicProjection.prototype.parallels = function(value) {};
/**
 * @record
 * @struct
 */
function GeoContext() {}

/**
 * Adds an arc to the path with center point (x, y) and radius r starting at startAngle and ending at endAngle.
 * The arc is drawn in clockwise directio by default.
 * 
 * @param {number} x x-coordinate of arc center point.
 * @param {number} y y-coordinate of arc center point.
 * @param {number} radius Radius of arc.
 * @param {number} startAngle The starting angle of the arc, measured clockwise from the positive x axis and expressed in radians.
 * @param {number} endAngle The end angle of the arc, measured clockwise from the positive x axis and expressed in radians.
 * @param {boolean=} anticlockwise Optional boolean flag, if true the arc is drawn counter-clockwise between the two angles.
 * @return {void}
 */
GeoContext.prototype.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {};

/**
 * Start a new path by emptying the list of sub-paths.
 * @return {void}
 */
GeoContext.prototype.beginPath = function() {};

/**
 * Causes the point of the pen to move back to the start of the current sub-path.
 * It tries to draw a straight line from the current point to the start.
 * If the shape has already been closed or has only one point, this function does nothing.
 * @return {void}
 */
GeoContext.prototype.closePath = function() {};

/**
 * Connects the last point in the sub-path to the x, y coordinates with a straight line (but does not actually draw it).
 * 
 * @param {number} x The x-coordinate for the end of the line.
 * @param {number} y The y-coordinate for the end of the line.
 * @return {void}
 */
GeoContext.prototype.lineTo = function(x, y) {};

/**
 * Move the starting point of a new sub-path to the (x, y) coordinates.
 * 
 * @param {number} x The x-coordinate for the new starting point.
 * @param {number} y The y-coordinate for the new starting point.
 * @return {void}
 */
GeoContext.prototype.moveTo = function(x, y) {};
/**
 * @record
 * @struct
 */
function GeoPath() {}

/* TODO: CallSignature:  */

/* TODO: CallSignature:  */

/**
 * Returns the projected planar area (typically in square pixels) for the specified GeoJSON object.
 * Point, MultiPoint, LineString and MultiLineString geometries have zero area. For Polygon and MultiPolygon geometries,
 * this method first computes the area of the exterior ring, and then subtracts the area of any interior holes.
 * This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of d3.geoArea.
 * 
 * @param {?} object An object for which the area is to be calculated.
 * @return {number}
 */
GeoPath.prototype.area = function(object) {};

/**
 * Returns the projected planar bounding box (typically in pixels) for the specified GeoJSON object.
 * The bounding box is represented by a two-dimensional array: [[x₀, y₀], [x₁, y₁]], where x₀ is the minimum x-coordinate, y₀ is the minimum y-coordinate,
 * x₁ is maximum x-coordinate, and y₁ is the maximum y-coordinate.
 * 
 * This is handy for, say, zooming in to a particular feature. (Note that in projected planar coordinates,
 * the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.)
 * This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of d3.geoBounds.
 * 
 * @param {?} object An object for which the bounds are to be calculated.
 * @return {!Array<?>}
 */
GeoPath.prototype.bounds = function(object) {};

/**
 * Returns the projected planar centroid (typically in pixels) for the specified GeoJSON object.
 * This is handy for, say, labeling state or county boundaries, or displaying a symbol map.
 * For example, a noncontiguous cartogram might scale each state around its centroid.
 * This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of d3.geoCentroid.
 * 
 * @param {?} object An object for which the centroid is to be calculated.
 * @return {!Array<?>}
 */
GeoPath.prototype.centroid = function(object) {};

/**
 * Returns the projected planar length (typically in pixels) for the specified GeoJSON object.
 * Point and MultiPoint geometries have zero length. For Polygon and MultiPolygon geometries, this method computes the summed length of all rings.
 * 
 * This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of d3.geoLength.
 * 
 * @param {?} object An object for which the measure is to be calculated.
 * @return {number}
 */
GeoPath.prototype.measure = function(object) {};

/**
 * Returns the current render context which defaults to null.
 * 
 * Use the generic to cast the return type of the rendering context, if it is known for a specific application.
 * Set the current rendering context to null and return the path generator.
 * The path generator will return an SVG path string;
 * 
 * Set the current rendering context and return the path generator.
 * The path generator will render to the specified context.
 * 
 * @template C
 * @param {null|?=} context Null to remove the current rendering context, if any. / Rendering context to be used by the path generator.
 * The context must at least implement GeoContext, a subset of the CanvasRenderingContext2D API.
 * @return {?}
 */
GeoPath.prototype.context = function(context) {};

/**
 * Get the current projection. The generic parameter can be used to cast the result to the
 * correct, known type of the projection, e.g. GeoProjection or GeoConicProjection. Otherwise,
 * the return type defaults to the minimum type requirement for a projection which
 * can be passed into a GeoPath.
 * 
 * Use the generic to cast the return type of the projection, if it is known for a specific application.
 * Set the projection to the identity projection.
 * 
 * Set the current projection to be used with the geo path generator.
 * 
 * The given projection is typically one of D3’s built-in geographic projections;
 * however, any object that exposes a projection.stream function can be used, enabling the use of custom projections.
 * See D3’s transforms for more examples of arbitrary geometric transformations.
 * 
 * Set the projection to be used with the geo path generator to a custom projection.
 * Custom projections must minimally contain a stream method.
 * 
 * The given projection is typically one of D3’s built-in geographic projections;
 * however, any object that exposes a projection.stream function can be used, enabling the use of custom projections.
 * See D3’s transforms for more examples of arbitrary geometric transformations.
 * 
 * @template P
 * @param {null|?=} projection Use null to set the identity projection. / A projection. / A wrapper object exposing, at a minimum a "stream" method to be used for custom projections.
 * @return {?}
 */
GeoPath.prototype.projection = function(projection) {};

/**
 * Returns the current radius or radius accessor used to determine the radius for the display of Point and MultiPoint geometries.
 * The default is a constant radius of 4.5.
 * Sets the radius used to display Point and MultiPoint geometries to the specified number and return the geo path generator.
 * 
 * Sets the radius used to display Point and MultiPoint geometries to use the specified radius accessor function.
 * 
 * While the radius is commonly specified as a number constant, it may also be specified as a function which is computed per feature,
 * being passed the any arguments passed to the path generator. For example, if your GeoJSON data has additional properties,
 * you might access those properties inside the radius function to vary the point size;
 * alternatively, you could d3.symbol and a projection for greater flexibility.
 * 
 * @param {number|?=} value Fixed radius value. / A value accessor function for the radius which is evaluated for each path to be rendered.
 * The value accessor function is invoked within the "this" context in which the path generator is used.
 * It is passed the object to be rendered, and any additional arguments which have been passed into the call to the render function of the path generator.
 * @return {(number|?)|?}
 */
GeoPath.prototype.pointRadius = function(value) {};

/**
 * Creates a new geographic path generator.
 * 
 * The default projection is the null projection. The null projection represents the identity transformation, i.e.
 * the input geometry is not projected and is instead rendered directly in raw coordinates.
 * This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.
 * 
 * The default context is null, which implies that the path generator will return an SVG path string.
 * 
 * Creates a new geographic path generator with the default settings.
 * 
 * The default projection is the null projection. The null projection represents the identity transformation:
 * the input geometry is not projected and is instead rendered directly in raw coordinates.
 * This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.
 * 
 * The default context is null, which implies that the path generator will return an SVG path string.
 * 
 * The generic corresponds to the type of the DatumObject which will be passed into the geo path generator for rendering
 * 
 * Creates a new geographic path generator with the default settings.
 * 
 * The default projection is the null projection. The null projection represents the identity transformation:
 * the input geometry is not projected and is instead rendered directly in raw coordinates.
 * This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.
 * 
 * The default context is null, which implies that the path generator will return an SVG path string.
 * 
 * The first generic corresponds to the "this"-context within which the geo path generator will be invoked.
 * This could be e.g. the DOMElement bound to "this" when using selection.attr("d", ...) with the path generator.
 * 
 * The second generic corresponds to the type of the DatumObject which will be passed into the geo path generator for rendering.
 * 
 * @template DatumObject, This
 * @param {?=} projection An (optional) current projection to be used. Typically this is one of D3’s built-in geographic projections;
 * however, any object that exposes a projection.stream function can be used, enabling the use of custom projections.
 * See D3’s transforms for more examples of arbitrary geometric transformations. Setting the projection to "null" uses the identity projection. The default  value is "null", the identity projection.
 * @param {?=} context An (optional) rendering context to be used. If a context is provided, it must at least implement the interface described by GeoContext, a subset of the CanvasRenderingContext2D API.
 * Setting the context to "null" means that the path generator will return an SVG path string representing the to be rendered object. The default is "null".
 * @return {?}
 */
function geoPath(projection, context) {}

/**
 * Constructs a new projection from the specified raw projection, project.
 * The project function takes the longitude and latitude of a given point in radians,
 * often referred to as lambda (λ) and phi (φ), and returns a two-element array [x, y] representing its unit projection.
 * The project function does not need to scale or translate the point, as these are applied automatically by projection.scale, projection.translate, and projection.center.
 * Likewise, the project function does not need to perform any spherical rotation, as projection.rotate is applied prior to projection.
 * 
 * If the project function exposes an invert method, the returned projection will also expose projection.invert.
 * @param {?} project
 * @return {?}
 */
function geoProjection(project) {}

/**
 * Constructs a new projection from the specified raw projection factory and returns a mutate function to call whenever the raw projection changes.
 * The factory must return a raw projection. The returned mutate function returns the wrapped projection.
 * 
 * When creating a mutable projection, the mutate function is typically not exposed.
 * @param {?} factory
 * @return {?}
 */
function geoProjectionMutator(factory) {}

/**
 * The azimuthal equal-area projection.
 * @return {?}
 */
function geoAzimuthalEqualArea() {}

/**
 * The raw azimuthal equal-area projection.
 * @return {?}
 */
function geoAzimuthalEqualAreaRaw() {}

/**
 * The azimuthal equidistant projection.
 * @return {?}
 */
function geoAzimuthalEquidistant() {}

/**
 * The raw azimuthal equidistant projection.
 * @return {?}
 */
function geoAzimuthalEquidistantRaw() {}

/**
 * The gnomonic projection.
 * @return {?}
 */
function geoGnomonic() {}

/**
 * The raw gnomonic projection.
 * @return {?}
 */
function geoGnomonicRaw() {}

/**
 * The orthographic projection.
 * @return {?}
 */
function geoOrthographic() {}

/**
 * The raw orthographic projection.
 * @return {?}
 */
function geoOrthographicRaw() {}

/**
 * The stereographic projection.
 * @return {?}
 */
function geoStereographic() {}

/**
 * The raw stereographic projection.
 * @return {?}
 */
function geoStereographicRaw() {}

/**
 * A U.S.-centric composite projection of three d3.geoConicEqualArea projections: d3.geoAlbers is used for the lower forty-eight states,
 * and separate conic equal-area projections are used for Alaska and Hawaii. Note that the scale for Alaska is diminished: it is projected at 0.35× its true relative area.
 * 
 * Composite consist of several projections that are composed into a single display. The constituent projections have fixed clip, center and rotation,
 * and thus composite projections do not support projection.center, projection.rotate, projection.clipAngle, or projection.clipExtent.
 * @return {?}
 */
function geoAlbersUsa() {}

/**
 * The Albers’ equal area-conic projection. This is a U.S.-centric configuration of d3.geoConicEqualArea.
 * @return {?}
 */
function geoAlbers() {}

/**
 * The conic conformal projection. The parallels default to [30°, 30°] resulting in flat top.
 * @return {?}
 */
function geoConicConformal() {}

/**
 * The raw conic conformal projection.
 * @param {number} phi0
 * @param {number} phi1
 * @return {?}
 */
function geoConicConformalRaw(phi0, phi1) {}

/**
 * The Albers’ equal-area conic projection.
 * @return {?}
 */
function geoConicEqualArea() {}

/**
 * The raw Albers’ equal-area conic projection.
 * @param {number} phi0
 * @param {number} phi1
 * @return {?}
 */
function geoConicEqualAreaRaw(phi0, phi1) {}

/**
 * The conic equidistant projection.
 * @return {?}
 */
function geoConicEquidistant() {}

/**
 * The raw conic equidistant projection.
 * @param {number} phi0
 * @param {number} phi1
 * @return {?}
 */
function geoConicEquidistantRaw(phi0, phi1) {}

/**
 * The equirectangular (plate carrée) projection.
 * @return {?}
 */
function geoEquirectangular() {}

/**
 * The raw equirectangular (plate carrée) projection.
 * @return {?}
 */
function geoEquirectangularRaw() {}

/**
 * The spherical Mercator projection.
 * Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.
 * @return {?}
 */
function geoMercator() {}

/**
 * The raw spherical Mercator projection.
 * @return {?}
 */
function geoMercatorRaw() {}

/**
 * The transverse spherical Mercator projection.
 * Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.
 * @return {?}
 */
function geoTransverseMercator() {}

/**
 * The raw transverse spherical Mercator projection.
 * @return {?}
 */
function geoTransverseMercatorRaw() {}
/**
 * @record
 * @struct
 */
function GeoTransformPrototype() {}

/**
 * Indicates the end of a line or ring. Within a polygon, indicates the end of a ring.
 * Unlike GeoJSON, the redundant closing coordinate of a ring is not indicated via point, and instead is implied via lineEnd within a polygon.
 * @this {?}
 * @return {void}
 */
GeoTransformPrototype.prototype.lineEnd = function() {};

/**
 * Indicates the start of a line or ring. Within a polygon, indicates the start of a ring. The first ring of a polygon is the exterior ring, and is typically clockwise.
 * Any subsequent rings indicate holes in the polygon, and are typically counterclockwise.
 * @this {?}
 * @return {void}
 */
GeoTransformPrototype.prototype.lineStart = function() {};

/**
 * Indicates a point with the specified coordinates x and y (and optionally z). The coordinate system is unspecified and implementation-dependent;
 * for example, projection streams require spherical coordinates in degrees as input. Outside the context of a polygon or line,
 * a point indicates a point geometry object (Point or MultiPoint). Within a line or polygon ring, the point indicates a control point.
 * 
 * @this {?}
 * @param {number} x x-coordinate of point.
 * @param {number} y y-coordinate of point.
 * @param {number=} z Optional z-coordinate of point.
 * @return {void}
 */
GeoTransformPrototype.prototype.point = function(x, y, z) {};

/**
 * Indicates the end of a polygon.
 * @this {?}
 * @return {void}
 */
GeoTransformPrototype.prototype.polygonEnd = function() {};

/**
 * Indicates the start of a polygon. The first line of a polygon indicates the exterior ring, and any subsequent lines indicate interior holes.
 * @this {?}
 * @return {void}
 */
GeoTransformPrototype.prototype.polygonStart = function() {};

/**
 * Indicates the sphere (the globe; the unit sphere centered at ⟨0,0,0⟩).
 * @this {?}
 * @return {void}
 */
GeoTransformPrototype.prototype.sphere = function() {};

/**
 * Defines an arbitrary transform using the methods defined on the specified methods object.
 * Any undefined methods will use pass-through methods that propagate inputs to the output stream.
 * 
 * @template T
 * @param {?} methods An object with custom method implementations, which are used to create a transform projection.
 * @return {?}
 */
function geoTransform(methods) {}
/**
 * @extends {GeoStreamWrapper}
 * @record
 * @struct
 */
function GeoIdentityTranform() {}

/**
 * Returns the current viewport clip extent which defaults to null.
 * Sets the clip extent to null and returns the projection.
 * With a clip extent of null, no viewport clipping is performed.
 * 
 * Viewport clipping is independent of small-circle clipping via projection.clipAngle.
 * 
 * Sets the projection’s viewport clip extent to the specified bounds in pixels and returns the projection.
 * The extent bounds are specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the top, x₁ is the right and y₁ is the bottom.
 * 
 * Viewport clipping is independent of small-circle clipping via projection.clipAngle.
 * 
 * @param {null|!Array<?>=} extent Set to null to disable viewport clipping. / The extent bounds are specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the top, x₁ is the right and y₁ is the bottom.
 * @return {!Array<?>|?}
 */
GeoIdentityTranform.prototype.clipExtent = function(extent) {};

/**
 * Sets the projection’s scale and translate to fit the specified geographic feature in the center of the given extent.
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic feature collection in the center of the given extent.
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic geometry object in the center of the given extent.
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic geometry collection in the center of the given extent.
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * @param {!Array<?>} extent The extent, specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left side of the bounding box, y₀ is the top, x₁ is the right and y₁ is the bottom.
 * @param {?} object A geographic feature supported by d3-geo (An extension of GeoJSON feature). / A geographic feature collection supported by d3-geo (An extension of GeoJSON feature collection). / A GeoJson Geometry Object or GeoSphere object supported by d3-geo (An extension of GeoJSON). / A geographic geometry collection supported by d3-geo (An extension of GeoJSON geometry collection).
 * @return {?}
 */
GeoIdentityTranform.prototype.fitExtent = function(extent, object) {};

/**
 * Sets the projection’s scale and translate to fit the specified geographic feature in the center of an extent with the given size and top-left corner of [0, 0].
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic feature collection in the center of an extent with the given size and top-left corner of [0, 0].
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic geometry object in the center of an extent with the given size and top-left corner of [0, 0].
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * Sets the projection’s scale and translate to fit the specified geographic geometry collection in the center of an extent with the given size and top-left corner of [0, 0].
 * Returns the projection.
 * 
 * Any clip extent is ignored when determining the new scale and translate. The precision used to compute the bounding box of the given object is computed at an effective scale of 150.
 * 
 * @param {!Array<?>} size The size of the extent, specified as an array [width, height].
 * @param {?} object A geographic feature supported by d3-geo (An extension of GeoJSON feature). / A geographic feature collection supported by d3-geo (An extension of GeoJSON feature collection). / A GeoJson Geometry Object or GeoSphere object supported by d3-geo (An extension of GeoJSON). / A geographic geometry collection supported by d3-geo (An extension of GeoJSON geometry collection).
 * @return {?}
 */
GeoIdentityTranform.prototype.fitSize = function(size, object) {};

/**
 * Returns true if x-reflection is enabled, which defaults to false.
 * Sets whether or not the x-dimension is reflected (negated) in the output.
 * 
 * @param {boolean=} reflect true = reflect x-dimension, false = do not reflect x-dimension.
 * @return {boolean|?}
 */
GeoIdentityTranform.prototype.reflectX = function(reflect) {};

/**
 * Returns true if y-reflection is enabled, which defaults to false.
 * Sets whether or not the y-dimension is reflected (negated) in the output.
 * 
 * This is especially useful for transforming from standard spatial reference systems,
 * which treat positive y as pointing up, to display coordinate systems such as Canvas and SVG,
 * which treat positive y as pointing down.
 * 
 * @param {boolean=} reflect true = reflect y-dimension, false = do not reflect y-dimension.
 * @return {boolean|?}
 */
GeoIdentityTranform.prototype.reflectY = function(reflect) {};

/**
 * Returns the current scale factor.
 * 
 * The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.
 * Sets the projection’s scale factor to the specified value and returns the projection.
 * The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.
 * 
 * @param {number=} scale Scale factor to be used for the projection.
 * @return {number|?}
 */
GeoIdentityTranform.prototype.scale = function(scale) {};

/**
 * Returns the current translation offset.
 * The translation offset determines the pixel coordinates of the projection’s center.
 * Sets the projection’s translation offset to the specified two-element array [tx, ty] and returns the projection.
 * The translation offset determines the pixel coordinates of the projection’s center.
 * 
 * @param {!Array<?>=} point A two-element array [tx, ty] specifying the translation offset.
 * @return {!Array<?>|?}
 */
GeoIdentityTranform.prototype.translate = function(point) {};

/**
 * Returns the identity transform which can be used to scale, translate and clip planar geometry.
 * @return {?}
 */
function geoIdentity() {}
