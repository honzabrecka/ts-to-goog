/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/traverse/index.d.ts:
/**
 * @record
 * @struct
 */
function Traverse() {}

/**
 * Get the element at the array `path`.
 * @param {!Array<string>} path
 * @return {?}
 */
Traverse.prototype.get = function(path) {};

/**
 * Return whether the element at the array `path` exists.
 * @param {!Array<string>} path
 * @return {boolean}
 */
Traverse.prototype.has = function(path) {};

/**
 * Set the element at the array `path` to `value`.
 * @param {!Array<string>} path
 * @param {?} value
 * @return {?}
 */
Traverse.prototype.set = function(path, value) {};

/**
 * Execute `fn` for each node in the object and return a new object with the results of the walk. To update nodes in the result use `this.update(value)`.
 * @param {?} cb
 * @return {?}
 */
Traverse.prototype.map = function(cb) {};

/**
 * Execute `fn` for each node in the object but unlike `.map()`, when `this.update()` is called it updates the object in-place.
 * @param {?} cb
 * @return {?}
 */
Traverse.prototype.forEach = function(cb) {};

/**
 * For each node in the object, perform a [left-fold](http://en.wikipedia.org/wiki/Fold_(higher-order_function)) with the return value of `fn(acc, node)`.
 * 
 * If `init` isn't specified, `init` is set to the root object for the first step and the root element is skipped.
 * @param {?} cb
 * @param {?=} init
 * @return {?}
 */
Traverse.prototype.reduce = function(cb, init) {};

/**
 * Return an `Array` of every possible non-cyclic path in the object. 
 * Paths are `Array`s of string keys.
 * @return {!Array<string>}
 */
Traverse.prototype.paths = function() {};

/**
 * Return an `Array` of every node in the object.
 * @return {!Array<?>}
 */
Traverse.prototype.nodes = function() {};

/**
 * Create a deep clone of the object.
 * @return {?}
 */
Traverse.prototype.clone = function() {};
/**
 * @record
 * @struct
 */
function StaticTraverse() {}

/**
 * Get the element at the array `path`.
 * @param {?} obj
 * @param {!Array<string>} path
 * @return {?}
 */
StaticTraverse.prototype.get = function(obj, path) {};

/**
 * Return whether the element at the array `path` exists.
 * @param {?} obj
 * @param {!Array<string>} path
 * @return {boolean}
 */
StaticTraverse.prototype.has = function(obj, path) {};

/**
 * Set the element at the array `path` to `value`.
 * @param {?} obj
 * @param {!Array<string>} path
 * @param {?} value
 * @return {?}
 */
StaticTraverse.prototype.set = function(obj, path, value) {};

/**
 * Execute `fn` for each node in the object and return a new object with the results of the walk. To update nodes in the result use `this.update(value)`.
 * @param {?} obj
 * @param {?} cb
 * @return {?}
 */
StaticTraverse.prototype.map = function(obj, cb) {};

/**
 * Execute `fn` for each node in the object but unlike `.map()`, when `this.update()` is called it updates the object in-place.
 * @param {?} obj
 * @param {?} cb
 * @return {?}
 */
StaticTraverse.prototype.forEach = function(obj, cb) {};

/**
 * For each node in the object, perform a [left-fold](http://en.wikipedia.org/wiki/Fold_(higher-order_function)) with the return value of `fn(acc, node)`.
 * 
 * If `init` isn't specified, `init` is set to the root object for the first step and the root element is skipped.
 * @param {?} obj
 * @param {?} cb
 * @param {?=} init
 * @return {?}
 */
StaticTraverse.prototype.reduce = function(obj, cb, init) {};

/**
 * Return an `Array` of every possible non-cyclic path in the object. 
 * Paths are `Array`s of string keys.
 * @param {?} obj
 * @return {!Array<string>}
 */
StaticTraverse.prototype.paths = function(obj) {};

/**
 * Return an `Array` of every node in the object.
 * @param {?} obj
 * @return {!Array<?>}
 */
StaticTraverse.prototype.nodes = function(obj) {};

/**
 * Create a deep clone of the object.
 * @template T
 * @param {?} obj
 * @return {?}
 */
StaticTraverse.prototype.clone = function(obj) {};
/**
 * @record
 * @struct
 */
function TraverseContext() {}
 /** @type {?} */
TraverseContext.prototype.node;
 /** @type {!Array<string>} */
TraverseContext.prototype.path;
 /** @type {?} */
TraverseContext.prototype.parent;
 /** @type {string} */
TraverseContext.prototype.key;
 /** @type {boolean} */
TraverseContext.prototype.isRoot;
 /** @type {boolean} */
TraverseContext.prototype.notRoot;
 /** @type {boolean} */
TraverseContext.prototype.isLeaf;
 /** @type {boolean} */
TraverseContext.prototype.notLeaf;
 /** @type {number} */
TraverseContext.prototype.level;
 /** @type {?} */
TraverseContext.prototype.circular;

/**
 * Set a new value for the present node.
 * 
 * All the elements in `value` will be recursively traversed unless `stopHere` is true (false by default).
 * @param {?} value
 * @param {boolean=} stopHere
 * @return {void}
 */
TraverseContext.prototype.update = function(value, stopHere) {};

/**
 * Remove the current element from the output. If the node is in an Array it will be spliced off. Otherwise it will be deleted from its parent.
 * @param {boolean=} stopHere
 * @return {void}
 */
TraverseContext.prototype.remove = function(stopHere) {};

/**
 * Delete the current element from its parent in the output. Calls `delete` even on Arrays.
 * @param {boolean=} stopHere
 * @return {void}
 */
TraverseContext.prototype.delete = function(stopHere) {};

/**
 * Call this function before all of the children are traversed.
 * You can assign into `this.keys` here to traverse in a custom order.
 * @param {?} callback
 * @return {void}
 */
TraverseContext.prototype.before = function(callback) {};

/**
 * Call this function after all of the children are traversed.
 * @param {?} callback
 * @return {void}
 */
TraverseContext.prototype.after = function(callback) {};

/**
 * Call this function before each of the children are traversed.
 * @param {?} callback
 * @return {void}
 */
TraverseContext.prototype.pre = function(callback) {};

/**
 * Call this function after each of the children are traversed.
 * @param {?} callback
 * @return {void}
 */
TraverseContext.prototype.post = function(callback) {};

/**
 * @template T
 * @param {T} obj
 * @return {?}
 */
function traverseFunction(obj) {}
 /** @type {?} */
var traverse;

/* TODO: ExportAssignment in  */
