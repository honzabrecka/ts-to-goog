/**
 * @externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
// externs from d/bull/index.d.ts:

/* TODO: ImportDeclaration in  */
 /** @type {function(new: (!Bull.Queue), string, !Bull.QueueOptions): ?} */
var Bull;
/**
 * @record
 * @struct
 */
Bull.QueueOptions = function() {};
 /** @type {!IORedis.RedisOptions} */
Bull.QueueOptions.prototype.redis;
 /** @type {string} */
Bull.QueueOptions.prototype.prefix;
 /** @type {!Bull.AdvancedSettings} */
Bull.QueueOptions.prototype.settings;

/**
 * When specified, the `Queue` will use this function to create new `ioredis` client connections.
 * This is useful if you want to re-use connections.
 * @param {string} type
 * @param {!IORedis.RedisOptions=} redisOpts
 * @return {!IORedis.Redis}
 */
Bull.QueueOptions.prototype.createClient = function(type, redisOpts) {};
/**
 * @record
 * @struct
 */
Bull.AdvancedSettings = function() {};
 /** @type {number} */
Bull.AdvancedSettings.prototype.lockDuration;
 /** @type {number} */
Bull.AdvancedSettings.prototype.stalledInterval;
 /** @type {number} */
Bull.AdvancedSettings.prototype.maxStalledCount;
 /** @type {number} */
Bull.AdvancedSettings.prototype.guardInterval;
 /** @type {number} */
Bull.AdvancedSettings.prototype.retryProcessDelay;

/** @typedef {function(!Error, ?): void} */
Bull.DoneCallback;

/** @typedef {(string|number)} */
Bull.JobId;
/**
 * @record
 * @struct
 */
Bull.Job = function() {};
 /** @type {(string|number)} */
Bull.Job.prototype.id;
 /** @type {?} */
Bull.Job.prototype.data;

/**
 * Report progress on a job
 * @param {?} value
 * @return {!Promise<void>}
 */
Bull.Job.prototype.progress = function(value) {};

/**
 * Removes a job from the queue and from any lists it may be included in.
 * @return {!Promise<void>}
 */
Bull.Job.prototype.remove = function() {};

/**
 * Re-run a job that has failed.
 * @return {!Promise<void>}
 */
Bull.Job.prototype.retry = function() {};

/**
 * Returns a promise the resolves when the job has been finished.
 * TODO: Add a watchdog to check if the job has finished periodically.
 * since pubsub does not give any guarantees.
 * @return {!Promise<void>}
 */
Bull.Job.prototype.finished = function() {};

/** @typedef {string} */
Bull.JobStatus;
/**
 * @record
 * @struct
 */
Bull.BackoffOptions = function() {};
 /** @type {string} */
Bull.BackoffOptions.prototype.type;
 /** @type {number} */
Bull.BackoffOptions.prototype.delay;
/**
 * @record
 * @struct
 */
Bull.RepeatOptions = function() {};
 /** @type {string} */
Bull.RepeatOptions.prototype.cron;
 /** @type {string} */
Bull.RepeatOptions.prototype.tz;
 /** @type {(string|number|!Date)} */
Bull.RepeatOptions.prototype.endDate;
/**
 * @record
 * @struct
 */
Bull.JobOptions = function() {};
 /** @type {number} */
Bull.JobOptions.prototype.priority;
 /** @type {number} */
Bull.JobOptions.prototype.delay;
 /** @type {number} */
Bull.JobOptions.prototype.attempts;
 /** @type {!Bull.RepeatOptions} */
Bull.JobOptions.prototype.repeat;
 /** @type {(number|!Bull.BackoffOptions)} */
Bull.JobOptions.prototype.backoff;
 /** @type {boolean} */
Bull.JobOptions.prototype.lifo;
 /** @type {number} */
Bull.JobOptions.prototype.timeout;
 /** @type {(string|number)} */
Bull.JobOptions.prototype.jobId;
 /** @type {boolean} */
Bull.JobOptions.prototype.removeOnComplete;
 /** @type {boolean} */
Bull.JobOptions.prototype.removeOnFail;
/**
 * @record
 * @struct
 */
Bull.JobCounts = function() {};
 /** @type {number} */
Bull.JobCounts.prototype.wait;
 /** @type {number} */
Bull.JobCounts.prototype.active;
 /** @type {number} */
Bull.JobCounts.prototype.completed;
 /** @type {number} */
Bull.JobCounts.prototype.failed;
 /** @type {number} */
Bull.JobCounts.prototype.delayed;
/**
 * @record
 * @struct
 */
Bull.Queue = function() {};

/**
 * Returns a promise that resolves when Redis is connected and the queue is ready to accept jobs.
 * This replaces the `ready` event emitted on Queue in previous verisons.
 * @return {!Promise<Queue>}
 */
Bull.Queue.prototype.isReady = function() {};

/**
 * Defines a processing function for the jobs placed into a given Queue.
 * 
 * The callback is called everytime a job is placed in the queue.
 * It is passed an instance of the job as first argument.
 * 
 * The done callback can be called with an Error instance, to signal that the job did not complete successfully,
 * or with a result as second argument as second argument (e.g.: done(null, result);) when the job is successful.
 * Errors will be passed as a second argument to the "failed" event;
 * results, as a second argument to the "completed" event.
 * 
 * concurrency: Bull will then call you handler in parallel respecting this max number.
 * Defines a processing function for the jobs placed into a given Queue.
 * 
 * The callback is called everytime a job is placed in the queue.
 * It is passed an instance of the job as first argument.
 * 
 * The done callback can be called with an Error instance, to signal that the job did not complete successfully,
 * or with a result as second argument as second argument (e.g.: done(null, result);) when the job is successful.
 * Errors will be passed as a second argument to the "failed" event;
 * results, as a second argument to the "completed" event.
 * Defines a processing function for the jobs placed into a given Queue.
 * 
 * The callback is called everytime a job is placed in the queue.
 * It is passed an instance of the job as first argument.
 * 
 * A promise must be returned to signal job completion.
 * If the promise is rejected, the error will be passed as a second argument to the "failed" event.
 * If it is resolved, its value will be the "completed" event's second argument.
 * 
 * concurrency: Bull will then call you handler in parallel respecting this max number.
 * Defines a processing function for the jobs placed into a given Queue.
 * 
 * The callback is called everytime a job is placed in the queue.
 * It is passed an instance of the job as first argument.
 * 
 * A promise must be returned to signal job completion.
 * If the promise is rejected, the error will be passed as a second argument to the "failed" event.
 * If it is resolved, its value will be the "completed" event's second argument.
 * @param {number|function(!Bull.Job, function(!Error, ?): void): void|function(!Bull.Job): void} concurrency_or_callback
 * @param {function(!Bull.Job, function(!Error, ?): void): void|function(!Bull.Job): void=} callback
 * @return {void|!Promise<?>}
 */
Bull.Queue.prototype.process = function(concurrency_or_callback, callback) {};

/**
 * Creates a new job and adds it to the queue.
 * If the queue is empty the job will be executed directly,
 * otherwise it will be placed in the queue and executed as soon as possible.
 * @param {?} data
 * @param {!Bull.JobOptions=} opts
 * @return {!Promise<!Bull.Job>}
 */
Bull.Queue.prototype.add = function(data, opts) {};

/**
 * Returns a promise that resolves when the queue is paused.
 * The pause is global, meaning that all workers in all queue instances for a given queue will be paused.
 * A paused queue will not process new jobs until resumed,
 * but current jobs being processed will continue until they are finalized.
 * 
 * Pausing a queue that is already paused does nothing.
 * @return {!Promise<void>}
 */
Bull.Queue.prototype.pause = function() {};

/**
 * Returns a promise that resolves when the queue is resumed after being paused.
 * The resume is global, meaning that all workers in all queue instances for a given queue will be resumed.
 * 
 * Resuming a queue that is not paused does nothing.
 * @return {!Promise<void>}
 */
Bull.Queue.prototype.resume = function() {};

/**
 * Returns a promise that returns the number of jobs in the queue, waiting or paused.
 * Since there may be other processes adding or processing jobs, this value may be true only for a very small amount of time.
 * @return {!Promise<number>}
 */
Bull.Queue.prototype.count = function() {};

/**
 * Empties a queue deleting all the input lists and associated jobs.
 * @return {!Promise<void>}
 */
Bull.Queue.prototype.empty = function() {};

/**
 * Closes the underlying redis client. Use this to perform a graceful shutdown.
 * 
 * `close` can be called from anywhere, with one caveat:
 * if called from within a job handler the queue won't close until after the job has been processed
 * @return {!Promise<void>}
 */
Bull.Queue.prototype.close = function() {};

/**
 * Returns a promise that will return the job instance associated with the jobId parameter.
 * If the specified job cannot be located, the promise callback parameter will be set to null.
 * @param {(string|number)} jobId
 * @return {!Promise<!Bull.Job>}
 */
Bull.Queue.prototype.getJob = function(jobId) {};

/**
 * Returns a promise that resolves with the job counts for the given queue
 * @return {!Promise<!Bull.JobCounts>}
 */
Bull.Queue.prototype.getJobCounts = function() {};

/**
 * Tells the queue remove all jobs created outside of a grace period in milliseconds.
 * You can clean the jobs with the following states: completed, waiting, active, delayed, and failed.
 * @param {number} grace
 * @param {string=} status
 * @param {number=} limit
 * @return {!Promise<!Array<!Bull.Job>>}
 */
Bull.Queue.prototype.clean = function(grace, status, limit) {};

/**
 * Listens to queue events
 * An error occured
 * A job has started. You can use `jobPromise.cancel()` to abort it
 * A job has been marked as stalled.
 * This is useful for debugging job workers that crash or pause the event loop.
 * A job's progress was updated
 * A job successfully completed with a `result`
 * A job failed with `err` as the reason
 * The queue has been paused
 * The queue has been resumed
 * Old jobs have been cleaned from the queue.
 * `jobs` is an array of jobs that were removed, and `type` is the type of those jobs.
 * 
 * @see Queue#clean() for details
 * @param {string} event
 * @param {function(!Array<?>): void|function(!Error): void|function(!Bull.Job, !Bull.JobPromise): void|function(!Bull.Job): void|function(!Bull.Job, ?): void|function(!Bull.Job, !Error): void|function(): void|function(!Array<!Bull.Job>, string): void} callback
 * @return {Queue}
 */
Bull.Queue.prototype.on = function(event, callback) {};

/** @typedef {function(): void} */
Bull.EventCallback;

/** @typedef {function(!Error): void} */
Bull.ErrorEventCallback;
/**
 * @record
 * @struct
 */
Bull.JobPromise = function() {};

/**
 * Abort this job
 * @return {void}
 */
Bull.JobPromise.prototype.cancel = function() {};

/** @typedef {function(!Bull.Job, !Bull.JobPromise): void} */
Bull.ActiveEventCallback;

/** @typedef {function(!Bull.Job): void} */
Bull.StalledEventCallback;

/** @typedef {function(!Bull.Job, ?): void} */
Bull.ProgressEventCallback;

/** @typedef {function(!Bull.Job, ?): void} */
Bull.CompletedEventCallback;

/** @typedef {function(!Bull.Job, !Error): void} */
Bull.FailedEventCallback;

/** @typedef {function(!Array<!Bull.Job>, string): void} */
Bull.CleanedEventCallback;

/* TODO: ExportAssignment in  */
